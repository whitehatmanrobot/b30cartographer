);
   STDMETHOD (ContextSensitiveHelp) (BOOL);

   //IShellView methods
   STDMETHOD (TranslateAccelerator) (LPMSG);
   STDMETHOD (EnableModeless) (BOOL);
   STDMETHOD (UIActivate) (UINT);
   STDMETHOD (Refresh) (VOID);
   STDMETHOD (CreateViewWindow) (LPSHELLVIEW, LPCFOLDERSETTINGS, LPSHELLBROWSER, LPRECT, HWND*);
   STDMETHOD (DestroyViewWindow) (VOID);
   STDMETHOD (GetCurrentInfo) (LPFOLDERSETTINGS);
   STDMETHOD (AddPropertySheetPages) (DWORD, LPFNADDPROPSHEETPAGE, LPARAM);
   STDMETHOD (SaveViewState) (VOID);
   STDMETHOD (SelectItem) (LPCITEMIDLIST, UINT);
   STDMETHOD (GetItemObject) (UINT, REFIID, LPVOID*);

private:
   static LRESULT CALLBACK WndProc(HWND hWnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    LRESULT UpdateMenu(HMENU hMenu);
    LRESULT UpdateToolbar(VOID);
    VOID MergeFileMenu(HMENU, BOOL);
    VOID MergeViewMenu(HMENU);
    VOID MergeEditMenu(HMENU, BOOL);
    VOID MergeToolbar(VOID);
    LRESULT OnCommand(DWORD, DWORD, HWND);
    LRESULT OnActivate(UINT);
    VOID OnDeactivate(VOID);
    LRESULT OnSetFocus(VOID);
    LRESULT OnKillFocus(VOID);
    LRESULT OnNotify(UINT, LPNMHDR);
    LRESULT OnSize(WORD, WORD);
    LRESULT OnCreate(VOID);
    LRESULT OnDestroy(VOID);
    BOOL CreateList(VOID);
    BOOL InitList(VOID);
    VOID FillList(VOID);
    LRESULT OnSettingChange(LPCTSTR);
   VOID GetShellSettings(VOID);
   VOID DoContextMenu(WORD, WORD, BOOL, DWORD);
   int FindItemPidl(LPCITEMIDLIST);
   LRESULT OnViewLarge(VOID);
   LRESULT OnViewSmall(VOID);
   LRESULT OnViewList(VOID);
   LRESULT OnViewDetails(VOID);
   BOOL AddItem(LPCITEMIDLIST);
   BOOL DeleteItem(LPCITEMIDLIST);
   BOOL RenameItem(LPCITEMIDLIST, LPCITEMIDLIST);
   LPITEMIDLIST GetPidl();
   LPITEMIDLIST GetFQPidl();
   VOID MarkItemsAsCut(LPCITEMIDLIST*, UINT);
   VOID EditItem(LPCITEMIDLIST);
   VOID UpdateData(LPCITEMIDLIST);

};

#endif   //SHELLVIEW_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\tools.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1997 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          Tools.h
   
   Description:   

**************************************************************************/

/**************************************************************************
   #include statements
**************************************************************************/

#include "resource.h"

/**************************************************************************
   structure definitions
**************************************************************************/

typedef struct
   {
   UINT  uImageSet;
   UINT  idCommand;
   int   iImage;
   int   idString;
   BYTE  bState;
   BYTE  bStyle;
   }MYTOOLINFO, *LPMYTOOLINFO;

extern MYTOOLINFO g_Tools[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\viewlist.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          ViewList.h
   
   Description:   CViewList definitions.

**************************************************************************/

#ifndef VIEWLIST_H
#define VIEWLIST_H

#include <windows.h>
#include <shlobj.h>

#include "PidlMgr.h"
#include "ShlView.h"

/**************************************************************************
   structure defintions
**************************************************************************/

typedef struct tagVIEWLIST
   {
   struct tagVIEWLIST   *pNext;
   CShellView           *pView;
   }VIEWLIST, FAR *LPVIEWLIST;

/**************************************************************************

   CViewList class definition

**************************************************************************/

class CViewList
{
public:
   CViewList();
   ~CViewList();
   
   CShellView* GetNextView (CShellView*);
   BOOL AddToList(CShellView*);
   VOID RemoveFromList(CShellView*);
   
private:
   BOOL DeleteList(VOID);
   LPMALLOC m_pMalloc;
   LPVIEWLIST m_pFirst;
   LPVIEWLIST m_pLast;
};

#endif   //VIEWLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\utility.h ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          Utility.h
   
   Description:   Utility definitions.

**************************************************************************/

#ifndef UTILITY_H
#define UTILITY_H

/**************************************************************************
   #include statements
**************************************************************************/

#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include <Regstr.h>

#ifndef SFGAO_BROWSABLE
#define SFGAO_BROWSABLE (0)
#endif

#ifndef SHGDN_INCLUDE_NONFILESYS
#define SHGDN_INCLUDE_NONFILESYS (0)
#endif

#ifdef _cplusplus
extern "C" {
#endif   //_cplusplus

typedef struct {
    BOOL fCut;
    UINT cidl;
    UINT aoffset[1];
   }PRIVCLIPDATA, FAR *LPPRIVCLIPDATA;

/**************************************************************************
   global variables
**************************************************************************/

#define TITLE_SIZE   64

#define FILTER_ATTRIBUTES  (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_HIDDEN)

#define INITIAL_COLUMN_SIZE    100

#define CFSTR_SAMPVIEWDATA TEXT("SampleViewDataFormat")

#define NS_CLASS_NAME   (TEXT("SampleViewNSClass"))

#define VIEW_POINTER_OFFSET   GWL_USERDATA

extern HINSTANCE     g_hInst;
extern UINT          g_DllRefCount;
extern HIMAGELIST    g_himlLarge;
extern HIMAGELIST    g_himlSmall;
extern TCHAR         g_szStoragePath[];
extern TCHAR         g_szExtTitle[];
extern const TCHAR   c_szDataFile[];
extern const TCHAR   c_szSection[];
extern const TCHAR g_szXMLUrl[];
extern int           g_nColumn;

/**************************************************************************
   function prototypes
**************************************************************************/

//utility functions
int CALLBACK CompareItems(LPARAM, LPARAM, LPARAM);
BOOL SaveGlobalSettings(VOID);
VOID GetGlobalSettings(VOID);
VOID CreateImageLists(VOID);
VOID DestroyImageLists(VOID);
int WideCharToLocal(LPTSTR, LPWSTR, DWORD);
int LocalToWideChar(LPWSTR, LPTSTR, DWORD);
int LocalToAnsi(LPSTR, LPCTSTR, DWORD);
VOID SmartAppendBackslash(LPTSTR);
int BuildDataFileName(LPTSTR, LPCTSTR, DWORD);
BOOL GetTextFromSTRRET(IMalloc*, LPSTRRET, LPCITEMIDLIST, LPTSTR, DWORD);
BOOL IsViewWindow(HWND);
BOOL DeleteDirectory(LPCTSTR);
HGLOBAL CreatePrivateClipboardData(LPITEMIDLIST, LPITEMIDLIST*, UINT, BOOL);
HGLOBAL CreateShellIDList(LPITEMIDLIST, LPITEMIDLIST*, UINT);
BOOL CALLBACK ItemDataDlgProc(HWND, UINT, WPARAM, LPARAM);
LPVOID GetViewInterface(HWND);
UINT AddViewMenuItems(HMENU, UINT, UINT, BOOL);
UINT AddFileMenuItems(HMENU, UINT, UINT, BOOL);
int AddIconImageList(HIMAGELIST, LPCTSTR);

#ifdef _cplusplus
}
#endif   //_cplusplus

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#endif   //UTILITY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\viewlist.cpp ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          ViewList.cpp
   
   Description:   Implements CViewList.

**************************************************************************/

/**************************************************************************
   #include statements
**************************************************************************/

#include "ViewList.h"

/**************************************************************************

   CViewList::CViewList

**************************************************************************/

CViewList::CViewList()
{
m_pFirst = m_pLast = NULL;

//get the shell's IMalloc pointer
//we'll keep this until we get destroyed
if(FAILED(SHGetMalloc(&m_pMalloc)))
   {
   delete this;
   return;
   }
}

/**************************************************************************

   CViewList::~CViewList

**************************************************************************/

CViewList::~CViewList()
{
DeleteList();

if(m_pMalloc)
   m_pMalloc->Release();
}

/**************************************************************************

   CViewList::GetNextView()
   
**************************************************************************/

CShellView* CViewList::GetNextView(CShellView *pViewIn)
{
LPVIEWLIST  pTemp;
CShellView  *pViewOut = NULL;

if(!pViewIn)
   pTemp = m_pFirst;
else
   {
   for(pTemp = m_pFirst; pTemp; pTemp = pTemp->pNext)
      {
      if(pTemp->pView == pViewIn)
         {
         pTemp = pTemp->pNext;
         break;
         }
      }
   }

if(pTemp)
   {
   pViewOut = pTemp->pView;
   }

return pViewOut;
}

/**************************************************************************

   CViewList::AddToList()

**************************************************************************/

BOOL CViewList::AddToList(CShellView *pView)
{
LPVIEWLIST  pNew;

pNew = (LPVIEWLIST)m_pMalloc->Alloc(sizeof(VIEWLIST));

if(pNew)
   {
   //set the next pointer
   pNew->pNext = NULL;
   pNew->pView = pView;

   //is this the first item in the list?
   if(!m_pFirst)
      {
      m_pFirst = pNew;
      }

   if(m_pLast)
      {
      //add the new item to the end of the list
      m_pLast->pNext = pNew;
      }
   
   //update the last item pointer
   m_pLast = pNew;

   return TRUE;
   }

return FALSE;
}

/**************************************************************************

   CViewList::RemoveFromList()

**************************************************************************/

VOID CViewList::RemoveFromList(CShellView *pView)
{
LPVIEWLIST  pDelete;
LPVIEWLIST  pPrev;

//find the item to be removed
for(pDelete = m_pFirst, pPrev = NULL; pDelete; pDelete = pDelete->pNext)
   {
   if(pDelete->pView == pView)
      break;
   
   //save the previous item in the list
   pPrev = pDelete;
   }

if(pDelete)
   {
   if(pPrev)
      {
      pPrev->pNext = pDelete->pNext;
      }
   else
      {
      //the item being deleted is the first item in the list
      m_pFirst = pDelete->pNext;
      }

   //was the last item deleted?
   if(!pDelete->pNext)
      m_pLast = pPrev;
   
   //free the list item
   m_pMalloc->Free(pDelete);
   }
}

/**************************************************************************

   CViewList::DeleteList()
   
**************************************************************************/

BOOL CViewList::DeleteList(VOID)
{
LPVIEWLIST  pDelete;

while(m_pFirst)
   {
   pDelete = m_pFirst;
   m_pFirst = pDelete->pNext;

   //free the list item
   m_pMalloc->Free(pDelete);
   }

m_pFirst = m_pLast = NULL;

return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\utility.cpp ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          Utility.cpp
   
   Description:   Utility function implementation

**************************************************************************/

/**************************************************************************
   #include statements
**************************************************************************/

#include "Utility.h"
#include "ShlFldr.h"
#include "resource.h"
#include "Commands.h"

/**************************************************************************
   global variables
**************************************************************************/

#define MAIN_KEY_STRING          (TEXT("Software\\SampleView"))
#define VALUE_STRING             (TEXT("Display Settings"))
#define DISPLAY_SETTINGS_COUNT   1

/**************************************************************************

   CompareItems()
   
**************************************************************************/

int CALLBACK CompareItems(LPARAM lParam1, LPARAM lParam2, LPARAM lpData)
{
CShellFolder  *pFolder = (CShellFolder*)lpData;

if(!pFolder)
   return 0;

HRESULT  hr = pFolder->CompareIDs(0, (LPITEMIDLIST)lParam1, (LPITEMIDLIST)lParam2);

return (SHORT)HRESULT_CODE(hr);
}

/**************************************************************************

   SaveGlobalSettings()
   
**************************************************************************/

BOOL SaveGlobalSettings(void)
{
HKEY  hKey;
LONG  lResult;
DWORD dwDisp;

lResult = RegCreateKeyEx(  HKEY_CURRENT_USER,
                           MAIN_KEY_STRING,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE, 
                           KEY_ALL_ACCESS,
                           NULL, 
                           &hKey,
                           &dwDisp);

if(lResult != ERROR_SUCCESS)
   return FALSE;

//create an array to put our data in
DWORD dwArray[DISPLAY_SETTINGS_COUNT];
dwArray[0] = g_nColumn;

//save the last printer selected
lResult = RegSetValueEx(   hKey,
                           VALUE_STRING,
                           0,
                           REG_BINARY,
                           (LPBYTE)dwArray,
                           sizeof(dwArray));

RegCloseKey(hKey);

if(lResult != ERROR_SUCCESS)
   return FALSE;

return TRUE;
}

/**************************************************************************

   GetGlobalSettings()
   
**************************************************************************/

VOID GetGlobalSettings(VOID)
{
LPITEMIDLIST   pidl = NULL;

g_nColumn = INITIAL_COLUMN_SIZE;

LoadString(g_hInst, IDS_EXT_TITLE, g_szExtTitle, TITLE_SIZE);

*g_szStoragePath = 0;
SHGetSpecialFolderLocation(NULL, CSIDL_APPDATA, &pidl);

if(pidl)
   {
   IMalloc *pMalloc;

   SHGetPathFromIDList(pidl, g_szStoragePath);
   
   SHGetMalloc(&pMalloc);
   if(pMalloc)
      {
      pMalloc->Free(pidl);
      pMalloc->Release();
      }
   }
else
   {
   GetWindowsDirectory(g_szStoragePath, MAX_PATH);
   }

SmartAppendBackslash(g_szStoragePath);
lstrcat(g_szStoragePath, g_szExtTitle);
SmartAppendBackslash(g_szStoragePath);
CreateDirectory(g_szStoragePath, NULL);

HKEY     hKey;
LRESULT  lResult;
lResult = RegOpenKeyEx( HKEY_CURRENT_USER,
                        MAIN_KEY_STRING,
                        0,
                        KEY_ALL_ACCESS,
                        &hKey);

if(lResult != ERROR_SUCCESS)
   return;

//create an array to put our data in
DWORD dwArray[DISPLAY_SETTINGS_COUNT];
DWORD dwType;
DWORD dwSize = sizeof(dwArray);

//get the saved data
lResult = RegQueryValueEx( hKey,
                           VALUE_STRING,
                           NULL,
                           &dwType,
                           (LPBYTE)dwArray,
                           &dwSize);

RegCloseKey(hKey);

if(lResult != ERROR_SUCCESS)
   return;

g_nColumn = dwArray[0];
}

/**************************************************************************

   CreateImageLists()
   
**************************************************************************/

VOID CreateImageLists(VOID)
{
int   cx;
int   cy;

cx = GetSystemMetrics(SM_CXSMICON);
cy = GetSystemMetrics(SM_CYSMICON);

if(g_himlSmall)
   ImageList_Destroy(g_himlSmall);

//set the small image list
g_himlSmall = ImageList_Create(cx, cy, ILC_COLORDDB | ILC_MASK, 3, 0);

if(g_himlSmall)
   {
   HICON       hIcon;
   TCHAR       szFolder[MAX_PATH];
   SHFILEINFO  sfi;
   
   //add the item icon
   hIcon = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(IDI_MAINICON), IMAGE_ICON, cx, cy, LR_DEFAULTCOLOR);
   ImageList_AddIcon(g_himlSmall, hIcon);

   //add the closed folder icon
   GetWindowsDirectory(szFolder, MAX_PATH);
   SHGetFileInfo( szFolder,
                  0,
                  &sfi,
                  sizeof(sfi),
                  SHGFI_ICON | SHGFI_SMALLICON);
   ImageList_AddIcon(g_himlSmall, sfi.hIcon);

   //add the open folder icon
   SHGetFileInfo( szFolder,
                  0,
                  &sfi,
                  sizeof(sfi),
                  SHGFI_ICON | SHGFI_SMALLICON | SHGFI_OPENICON);
   ImageList_AddIcon(g_himlSmall, sfi.hIcon);
   }

if(g_himlLarge)
   ImageList_Destroy(g_himlLarge);

cx = GetSystemMetrics(SM_CXICON);
cy = GetSystemMetrics(SM_CYICON);

//set the large image list
g_himlLarge = ImageList_Create(cx, cy, ILC_COLORDDB | ILC_MASK, 4, 0);

if(g_himlLarge)
   {
   HICON       hIcon;
   TCHAR       szFolder[MAX_PATH];
   SHFILEINFO  sfi;
   
   //add the item icon
   hIcon = (HICON)LoadImage(g_hInst, MAKEINTRESOURCE(IDI_MAINICON), IMAGE_ICON, cx, cy, LR_DEFAULTCOLOR);
   ImageList_AddIcon(g_himlLarge, hIcon);

   //add the closed folder icon
   GetWindowsDirectory(szFolder, MAX_PATH);
   ZeroMemory(&sfi, sizeof(sfi));
   SHGetFileInfo( szFolder,
                  0,
                  &sfi,
                  sizeof(sfi),
                  SHGFI_ICON);
   ImageList_AddIcon(g_himlLarge, sfi.hIcon);

   //add the open folder icon
   GetWindowsDirectory(szFolder, MAX_PATH);
   ZeroMemory(&sfi, sizeof(sfi));
   SHGetFileInfo( szFolder,
                  0,
                  &sfi,
                  sizeof(sfi),
                  SHGFI_ICON | SHGFI_OPENICON);
   ImageList_AddIcon(g_himlLarge, sfi.hIcon);
   }

}

/**************************************************************************

   AddIconImageLists()
   
**************************************************************************/
int AddIconImageList(HIMAGELIST himl, LPCTSTR  szImagePath)
{
    if(himl)
    {
       HICON       hIcon;
   
       //add the item icon
       hIcon = (HICON)LoadImage(NULL, szImagePath, IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR | LR_LOADFROMFILE | LR_DEFAULTSIZE);
       return ImageList_AddIcon(himl, hIcon);
   }
    else 
        return -1;
}

/**************************************************************************

   DestroyImageLists()
   
**************************************************************************/

VOID DestroyImageLists(VOID)
{
if(g_himlSmall)
   ImageList_Destroy(g_himlSmall);

if(g_himlLarge)
   ImageList_Destroy(g_himlLarge);
}

/**************************************************************************

   WideCharToLocal()
   
**************************************************************************/

int WideCharToLocal(LPTSTR pLocal, LPWSTR pWide, DWORD dwChars)
{
*pLocal = 0;

#ifdef UNICODE
lstrcpyn(pLocal, pWide, dwChars);
#else
WideCharToMultiByte( CP_ACP, 
                     0, 
                     pWide, 
                     -1, 
                     pLocal, 
                     dwChars, 
                     NULL, 
                     NULL);
#endif

return lstrlen(pLocal);
}

/**************************************************************************

   LocalToWideChar()
   
**************************************************************************/

int LocalToWideChar(LPWSTR pWide, LPTSTR pLocal, DWORD dwChars)
{
*pWide = 0;

#ifdef UNICODE
lstrcpyn(pWide, pLocal, dwChars);
#else
MultiByteToWideChar( CP_ACP, 
                     0, 
                     pLocal, 
                     -1,
                     pWide, 
                     dwChars); 
#endif

return lstrlenW(pWide);
}

/**************************************************************************

   LocalToAnsi()

**************************************************************************/

int LocalToAnsi(LPSTR pAnsi, LPCTSTR pLocal, DWORD dwChars)
{
*pAnsi = 0;

#ifdef UNICODE
WideCharToMultiByte( CP_ACP, 
                     0, 
                     pLocal, 
                     -1, 
                     pAnsi, 
                     dwChars, 
                     NULL, 
                     NULL);
#else
lstrcpyn(pAnsi, pLocal, dwChars);
#endif

return lstrlenA(pAnsi);
}

/**************************************************************************

   SmartAppendBackslash()

**************************************************************************/

VOID SmartAppendBackslash(LPTSTR pszPath)
{
if(*(pszPath + lstrlen(pszPath) - 1) != '\\')
   lstrcat(pszPath, TEXT("\\"));
}

/**************************************************************************

   BuildDataFileName()

**************************************************************************/

int BuildDataFileName(LPTSTR pszDataFile, LPCTSTR pszPath, DWORD dwChars)
{
if(dwChars < (DWORD)(lstrlen(pszPath) + 1 + lstrlen(c_szDataFile)))
   return 0;

if(IsBadWritePtr(pszDataFile, dwChars))
   return 0;

lstrcpy(pszDataFile, pszPath);
SmartAppendBackslash(pszDataFile);
lstrcat(pszDataFile, c_szDataFile);

return lstrlen(pszDataFile);
}

/**************************************************************************

   AnsiToLocal()

**************************************************************************/

int AnsiToLocal(LPTSTR pLocal, LPSTR pAnsi, DWORD dwChars)
{
*pLocal = 0;

#ifdef UNICODE
MultiByteToWideChar( CP_ACP, 
                     0, 
                     pAnsi, 
                     -1, 
                     pLocal, 
                     dwChars); 
#else
lstrcpyn(pLocal, pAnsi, dwChars);
#endif

return lstrlen(pLocal);
}

/**************************************************************************

   GetTextFromSTRRET()

**************************************************************************/

BOOL GetTextFromSTRRET( IMalloc * pMalloc,
                        LPSTRRET pStrRet, 
                        LPCITEMIDLIST pidl, 
                        LPTSTR pszText, 
                        DWORD dwSize)
{
if(IsBadReadPtr(pStrRet, sizeof(UINT)))
   return FALSE;

if(IsBadWritePtr(pszText, dwSize))
   return FALSE;

switch(pStrRet->uType)
   {
   case STRRET_CSTR:
      AnsiToLocal(pszText, pStrRet->cStr, dwSize);
      break;

   case STRRET_OFFSET:
      lstrcpyn(pszText, (LPTSTR)(((LPBYTE)pidl) + pStrRet->uOffset), dwSize);
      break;

   case STRRET_WSTR:
      {
      WideCharToLocal(pszText, pStrRet->pOleStr, dwSize);

      if(!pMalloc)
         {
         SHGetMalloc(&pMalloc);
         }
      else
         {
         pMalloc->AddRef();
         }
      if(pMalloc)
         {
         pMalloc->Free(pStrRet->pOleStr);
         pMalloc->Release();
         }
      }
      break;
   
   default:
      return FALSE;
   }

return TRUE;
}

/**************************************************************************

   IsViewWindow()

**************************************************************************/

BOOL IsViewWindow(HWND hWnd)
{
if(!hWnd)
   return FALSE;

TCHAR szClass[MAX_PATH] = TEXT("");

GetClassName(hWnd, szClass, MAX_PATH);

if(0 == lstrcmpi(szClass, NS_CLASS_NAME))
   return TRUE;

return FALSE;
}

/**************************************************************************

   DeleteDirectory()

**************************************************************************/

BOOL DeleteDirectory(LPCTSTR pszDir)
{
BOOL              fReturn = FALSE;
HANDLE            hFind;
WIN32_FIND_DATA   wfd;
TCHAR             szTemp[MAX_PATH];

lstrcpy(szTemp, pszDir);
SmartAppendBackslash(szTemp);
lstrcat(szTemp, TEXT("*.*"));
hFind = FindFirstFile(szTemp, &wfd);

if(INVALID_HANDLE_VALUE != hFind)
   {
   do
      {
      if(lstrcmpi(wfd.cFileName, TEXT(".")) && 
         lstrcmpi(wfd.cFileName, TEXT("..")))
         {
         //build the path of the directory or file found
         lstrcpy(szTemp, pszDir);
         SmartAppendBackslash(szTemp);
         lstrcat(szTemp, wfd.cFileName);

         if(FILE_ATTRIBUTE_DIRECTORY & wfd.dwFileAttributes)
            {
            //we found a directory - call this function recursively
            DeleteDirectory(szTemp);
            }
         else
            {
            /*
            We found a file. Only delete the data file to prevent us from 
            deleteting something that the user has placed in the folder.
            */
            if(0 == lstrcmpi(wfd.cFileName, c_szDataFile))
               {
               DeleteFile(szTemp);
               }
            }
         }
      }
   while(FindNextFile(hFind, &wfd));

   FindClose(hFind);

   /*
   If this fails it means the directory is not empty, so just remove our 
   attributes so the enumerator won't see it.
   */
   fReturn = RemoveDirectory(pszDir);
   if(!fReturn)
      {
      DWORD dwAttr = GetFileAttributes(pszDir);
      dwAttr &= ~FILTER_ATTRIBUTES;
      fReturn = SetFileAttributes(pszDir, dwAttr);
      }
   }

return fReturn;
}

/**************************************************************************

   CreatePrivateClipboardData()

**************************************************************************/

HGLOBAL CreatePrivateClipboardData( LPITEMIDLIST pidlParent, 
                                    LPITEMIDLIST *aPidls, 
                                    UINT uItemCount,
                                    BOOL fCut)
{
HGLOBAL        hGlobal = NULL;
LPPRIVCLIPDATA pData;
UINT           iCurPos;
UINT           cbPidl;
UINT           i;
CPidlMgr       *pPidlMgr;

pPidlMgr = new CPidlMgr();

if(!pPidlMgr)
   return NULL;

//get the size of the parent folder's PIDL
cbPidl = pPidlMgr->GetSize(pidlParent);

//get the total size of all of the PIDLs
for(i = 0; i < uItemCount; i++)
   {
   cbPidl += pPidlMgr->GetSize(aPidls[i]);
   }

/*
Find the end of the PRIVCLIPDATA structure. This is the size of the 
PRIVCLIPDATA structure itself (which includes one element of aoffset) plus the 
additional number of elements in aoffset.
*/
iCurPos = sizeof(PRIVCLIPDATA) + (uItemCount * sizeof(UINT));

/*
Allocate the memory for the PRIVCLIPDATA structure and it's variable length members.
*/
hGlobal = GlobalAlloc(GHND | GMEM_SHARE, (DWORD)
         (iCurPos +        // size of the PRIVCLIPDATA structure and the additional aoffset elements
         (cbPidl + 1)));   // size of the pidls

if (NULL == hGlobal)
   return (hGlobal);

pData = (LPPRIVCLIPDATA)GlobalLock(hGlobal);

if(pData)
   {
   pData->fCut = fCut;
   pData->cidl = uItemCount + 1;
   pData->aoffset[0] = iCurPos;

   //add the PIDL for the parent folder
   cbPidl = pPidlMgr->GetSize(pidlParent);
   CopyMemory((LPBYTE)(pData) + iCurPos, (LPBYTE)pidlParent, cbPidl);
   iCurPos += cbPidl;

   for(i = 0; i < uItemCount; i++)
      {
      //get the size of the PIDL
      cbPidl = pPidlMgr->GetSize(aPidls[i]);

      //fill out the members of the PRIVCLIPDATA structure.
      pData->aoffset[i + 1] = iCurPos;

      //copy the contents of the PIDL
      CopyMemory((LPBYTE)(pData) + iCurPos, (LPBYTE)aPidls[i], cbPidl);

      //set up the position of the next PIDL
      iCurPos += cbPidl;
      }
   
   GlobalUnlock(hGlobal);
   }

delete pPidlMgr;

return (hGlobal);
}

/**************************************************************************

   CreateShellIDList()

**************************************************************************/

HGLOBAL CreateShellIDList( LPITEMIDLIST pidlParent, 
                           LPITEMIDLIST *aPidls, 
                           UINT uItemCount)
{
HGLOBAL        hGlobal = NULL;
LPIDA          pData;
UINT           iCurPos;
UINT           cbPidl;
UINT           i;
CPidlMgr       *pPidlMgr;

pPidlMgr = new CPidlMgr();

if(!pPidlMgr)
   return NULL;

//get the size of the parent folder's PIDL
cbPidl = pPidlMgr->GetSize(pidlParent);

//get the total size of all of the PIDLs
for(i = 0; i < uItemCount; i++)
   {
   cbPidl += pPidlMgr->GetSize(aPidls[i]);
   }

/*
Find the end of the CIDA structure. This is the size of the 
CIDA structure itself (which includes one element of aoffset) plus the 
additional number of elements in aoffset.
*/
iCurPos = sizeof(CIDA) + (uItemCount * sizeof(UINT));

/*
Allocate the memory for the CIDA structure and it's variable length members.
*/
hGlobal = GlobalAlloc(GHND | GMEM_SHARE, (DWORD)
         (iCurPos +        // size of the CIDA structure and the additional aoffset elements
         (cbPidl + 1)));   // size of the pidls

if (NULL == hGlobal)
   return (hGlobal);

pData = (LPIDA)GlobalLock(hGlobal);

if(pData)
   {
   pData->cidl = uItemCount + 1;
   pData->aoffset[0] = iCurPos;

   //add the PIDL for the parent folder
   cbPidl = pPidlMgr->GetSize(pidlParent);
   CopyMemory((LPBYTE)(pData) + iCurPos, (LPBYTE)pidlParent, cbPidl);
   iCurPos += cbPidl;

   for(i = 0; i < uItemCount; i++)
      {
      //get the size of the PIDL
      cbPidl = pPidlMgr->GetSize(aPidls[i]);

      //fill out the members of the CIDA structure.
      pData->aoffset[i + 1] = iCurPos;

      //copy the contents of the PIDL
      CopyMemory((LPBYTE)(pData) + iCurPos, (LPBYTE)aPidls[i], cbPidl);

      //set up the position of the next PIDL
      iCurPos += cbPidl;
      }
   
   GlobalUnlock(hGlobal);
   }

delete pPidlMgr;

return (hGlobal);
}

/**************************************************************************

   ItemDataDlgProc()

**************************************************************************/

BOOL CALLBACK ItemDataDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
static LPTSTR  pszData;

switch(uMsg)
   {
   case WM_INITDIALOG:
      pszData = (LPTSTR)lParam;
      if(IsBadWritePtr((LPVOID)pszData, MAX_DATA))
         {
         EndDialog(hWnd, IDCANCEL);
         break;
         }
      
      SendDlgItemMessage(hWnd, IDC_DATA, EM_LIMITTEXT, MAX_DATA - 1, 0);
      
      SetDlgItemText(hWnd, IDC_DATA, pszData);
      break;

   case WM_COMMAND:
      switch(GET_WM_COMMAND_ID(wParam, lParam))
         {
         case IDCANCEL:
            EndDialog(hWnd, IDCANCEL);
            break;

         case IDOK:
            GetDlgItemText(hWnd, IDC_DATA, pszData, MAX_DATA);
            EndDialog(hWnd, IDOK);
            break;

         }
      break;
   
   default:
      break;
   }

return FALSE;
}

/**************************************************************************

   GetViewInterface()

**************************************************************************/

LPVOID GetViewInterface(HWND hWnd)
{
IUnknown *pRet = NULL;

if(IsViewWindow(hWnd))
   {
   pRet = (IUnknown*)GetWindowLong(hWnd, VIEW_POINTER_OFFSET);
   }

if(pRet)
   pRet->AddRef();

return (LPVOID)pRet;
}

/**************************************************************************

   AddViewMenuItems()

**************************************************************************/

UINT AddViewMenuItems(  HMENU hMenu, 
                        UINT uOffset, 
                        UINT uInsertBefore, 
                        BOOL fByPosition)
{
MENUITEMINFO   mii;
TCHAR          szText[MAX_PATH] = TEXT("");
UINT           uAdded = 0;

ZeroMemory(&mii, sizeof(mii));
mii.cbSize = sizeof(mii);

//add the view menu items at the correct position in the menu
LoadString(g_hInst, IDS_VIEW_LARGE, szText, sizeof(szText));
mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
mii.fType = MFT_STRING;
mii.fState = MFS_ENABLED;
mii.dwTypeData = szText;
mii.wID = uOffset + IDM_VIEW_LARGE;
InsertMenuItem(hMenu, uInsertBefore, fByPosition, &mii);

uAdded++;

LoadString(g_hInst, IDS_VIEW_SMALL, szText, sizeof(szText));
mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
mii.fType = MFT_STRING;
mii.fState = MFS_ENABLED;
mii.dwTypeData = szText;
mii.wID = uOffset + IDM_VIEW_SMALL;
InsertMenuItem(hMenu, uInsertBefore, fByPosition, &mii);

uAdded++;

LoadString(g_hInst, IDS_VIEW_LIST, szText, sizeof(szText));
mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
mii.fType = MFT_STRING;
mii.fState = MFS_ENABLED;
mii.dwTypeData = szText;
mii.wID = uOffset + IDM_VIEW_LIST;
InsertMenuItem(hMenu, uInsertBefore, fByPosition, &mii);

uAdded++;

LoadString(g_hInst, IDS_VIEW_DETAILS, szText, sizeof(szText));
mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
mii.fType = MFT_STRING;
mii.fState = MFS_ENABLED;
mii.dwTypeData = szText;
mii.wID = uOffset + IDM_VIEW_DETAILS;
InsertMenuItem(hMenu, uInsertBefore, fByPosition, &mii);

uAdded++;

return uAdded;
}

/**************************************************************************

   AddFileMenuItems()

**************************************************************************/

UINT AddFileMenuItems(  HMENU hMenu, 
                        UINT uOffset, 
                        UINT uInsertBefore, 
                        BOOL fByPosition)
{
//add the file menu items
TCHAR          szText[MAX_PATH] = TEXT("");
MENUITEMINFO   mii;
HMENU          hPopup;
UINT           uAdded = 0;

hPopup = CreatePopupMenu();

if(hPopup)
   {
   ZeroMemory(&mii, sizeof(mii));
   mii.cbSize = sizeof(mii);

   LoadString(g_hInst, IDS_NEW_FOLDER, szText, sizeof(szText));
   mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
   mii.fType = MFT_STRING;
   mii.fState = MFS_ENABLED;
   mii.dwTypeData = szText;
   mii.wID = uOffset + IDM_NEW_FOLDER;
   InsertMenuItem(hPopup, -1, FALSE, &mii);

   LoadString(g_hInst, IDS_NEW_ITEM, szText, sizeof(szText));
   mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE;
   mii.fType = MFT_STRING;
   mii.fState = MFS_ENABLED;
   mii.dwTypeData = szText;
   mii.wID = uOffset + IDM_NEW_ITEM;
   InsertMenuItem(hPopup, -1, FALSE, &mii);

   LoadString(g_hInst, IDS_NEW, szText, sizeof(szText));
   mii.fMask = MIIM_TYPE | MIIM_ID | MIIM_STATE | MIIM_SUBMENU;
   mii.fType = MFT_STRING;
   mii.fState = MFS_ENABLED;
   mii.dwTypeData = szText;
   mii.wID = uOffset + IDM_NEW;
   mii.hSubMenu = hPopup;
   InsertMenuItem(hMenu, uInsertBefore, fByPosition, &mii);

   uAdded++;
   }

return uAdded;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\alertemail\source\alerteventconsumer\alertemailproviderguid.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000 Microsoft Corporation
//
//  Module Name:
//      AlertEmailProviderGuid.h
//
//  Description:
//      Guid definition of Alert->Email event consumer provider.
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

// {8B95D170-3890-4dc4-8796-1CE073CD1C58}
DEFINE_GUID(CLSID_AlertEmailConsumerProvider, 
0x8b95d170, 0x3890, 0x4dc4, 0x87, 0x96, 0x1c, 0xe0, 0x73, 0xcd, 0x1c, 0x58);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\alertemail\source\alerteventconsumer\calertemailconsumer.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999--2001 Microsoft Corporation
//
//  Module Name:
//      CAlertEmailConsumer.cpp
//
//  Description:
//      Implementation of CAlertEmailConsumer class methods
//
//  [Header File:]
//      CAlertEmailConsumer.h
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <cdosys_i.c>
#include <wbemcli.h>
#include <wbemprov.h>
#include <wbemidl.h>
#include <appsrvcs.h>
#include <appmgrobjs.h>
#include <iads.h>
#include <Adshlp.h>


#include "alertemailmsg.h"

#include "CAlertEmailConsumer.h"



//
// Name of WBEM class
//
const WCHAR PROPERTY_CLASS_NAME  [] = L"__CLASS";

//
// Key name of alert email's settings.
//
const WCHAR SA_ALERTEMAIL_KEYPATH [] = 
                        L"SOFTWARE\\Microsoft\\ServerAppliance\\AlertEmail";
//
// Delimiter
//
const WCHAR DELIMITER[] = L"\\";

const WCHAR ENTER[] = L"\n";

const WCHAR COLON = L':';

const WCHAR ENDCODE = L'\0';

//
// HTTP header
//
const WCHAR HTTPHEADER[] = L"http://";

//
// SMTP Meta path
//
const WCHAR SMTP_META_PATH[] = L"IIS://LOCALHOST/SMTPSVC/1";





//
// Value name of alert email's settings.
//
const WCHAR ENABLEALERTEAMIL[] = L"EnableAlertEmail";

const WCHAR SENDEMAILTYPE[] = L"SendEmailType";

const WCHAR RECEIVEREMAILADDRESS[] = L"ReceiverEmailAddress";

//
// The setting value of alert->email disabled. 
//
const DWORD ALERTEMAILDISABLED = 0;

//
// Name of caption ID in alertdefinitions.
//
const WCHAR ALERTDEFINITIONCAPTIONID [] = L"CaptionRID";

//
// Name of description ID in alertdefinitions.
//
const WCHAR ALERTDEFINITIONDESCRIPTIONRID [] = L"DescriptionRID";

//
// Name of resource file in alertdefintions.
//
const WCHAR ALERTDEFINITIONSOURCE [] = L"Source";

//
// Name of alert email resource
//
const WCHAR ALERTEMAILRESOURCE[] = L"AlertEmailMsg.dll";

//
// Max value of Appliance Name
//
const DWORD MAXAPPLIANCEDNSNAME = 1024;

//
// WBEM namespace to connection to
//
const WCHAR DEFAULT_NAMESPACE[] = L"root\\MicrosoftIISv1";

//
// Query Language to use for WBEM
//
const WCHAR QUERY_LANGUAGE [] = L"WQL";

//
// WBEM query which specifies the IIS server settings we're interest in.
//
const WCHAR QUERY_STRING [] = 
        L"select * from IIS_WebServerSetting where servercomment=\"Administration\"";

const WCHAR SERVERBINDINGSPROP[] = L"ServerBindings";

//
// PROGID of the Element Manager
//
const WCHAR ELEMENT_RETRIEVER [] = L"Elementmgr.ElementRetriever";

//
// PROGID of the Localization Manager
//
const WCHAR LOCALIZATION_MANAGER [] = L"ServerAppliance.LocalizationManager";

//
// Type name of alert resource information.
//
const WCHAR ALERTDEFINITIONS [] = L"AlertDefinitions";


//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::CAlertEmailConsumer
//
//  Description:
//      Class constructor.
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
CAlertEmailConsumer::CAlertEmailConsumer()
{
    m_cRef = 0L;
    m_lCurAlertType = 0;
    m_lAlertEmailDisabled = ALERTEMAILDISABLED;

    m_pLocInfo = NULL;
    m_pcdoIMessage = NULL;
    m_pElementEnum = NULL;

    m_hAlertKey = NULL;
    m_hThread = NULL;
    m_hCloseThreadEvent = NULL;    
    m_pstrFullyQualifiedDomainName = NULL;

    m_pstrNetBIOSName = NULL;

}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::~CAlertEmailConsumer
//
//  Description:
//      Class deconstructor.
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
CAlertEmailConsumer::~CAlertEmailConsumer()
{
    if( m_hAlertKey != NULL )
    {
        ::RegCloseKey( m_hAlertKey );
    }

    if( m_pLocInfo != NULL )
    {
        m_pLocInfo->Release();
    }

    if( m_pElementEnum != NULL )
    {
        m_pElementEnum->Release();
    }

    if( m_pcdoIMessage != NULL )
    {
        m_pcdoIMessage->Release();
    }

    if( m_pstrFullyQualifiedDomainName != NULL )
    {
        ::free( m_pstrFullyQualifiedDomainName );
    }

    if( m_pstrNetBIOSName != NULL )
    {
        ::free( m_pstrNetBIOSName );
    }

    if( m_hThread != NULL )
    {
        ::CloseHandle( m_hThread );
    }

    if( m_hCloseThreadEvent != NULL )
    {
        ::CloseHandle( m_hCloseThreadEvent );
    }
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::QueryInterface
//
//  Description:
//      An method implement of IUnkown interface.
//
//  Arguments:
//        [in]  riid        Identifier of the requested interface
//        [out] ppv        Address of output variable that receives the 
//                        interface pointer requested in iid
//
//    Returns:
//        NOERROR            if the interface is supported
//        E_NOINTERFACE    if not
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CAlertEmailConsumer::QueryInterface(
    IN  REFIID riid,    
    OUT LPVOID FAR *ppv 
    )
{
    *ppv=NULL;

    if (riid == IID_IUnknown || riid == IID_IWbemUnboundObjectSink)
    {
        *ppv = (IWbemUnboundObjectSink *) this;
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::AddRef
//
//  Description:
//      increments the reference count for an interface on an object
//
//    Returns:
//        The new reference count.
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
CAlertEmailConsumer::AddRef(void)
{
    InterlockedIncrement( &m_cRef );
    return m_cRef;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::Release
//
//  Description:
//      decrements the reference count for an interface on an object.
//
//    Returns:
//        The new reference count.
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
CAlertEmailConsumer::Release(void)
{
    InterlockedDecrement( &m_cRef );
    if (0 != m_cRef)
    {
        return m_cRef;
    }

//    delete this;
    BOOL bReturn;
    bReturn = ::SetEvent( m_hCloseThreadEvent );
    if( !bReturn )
    {
        SATraceString( 
            "AlertEmail:Release setevent error!!!" 
            );
    }
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::IndicateToConsumer
//
//  Description:
//      An method implement of IWbemUnboundObjectSink interface.
//
//  Arguments:
//        [in] pLogicalConsumer   Pointer to the logical consumer object for 
//                              which this set of objects is delivered.
//      [in] lObjectCount       Number of objects delivered in the array that 
//                              follows.
//      [in] ppObjArray         Pointer to an array of IWbemClassObject 
//                              instances which represent the events delivered.
//
//    Returns:
//        WBEM_S_NO_ERROR         if successful
//        WBEM_E_FAILED           if not
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CAlertEmailConsumer::IndicateToConsumer(
    IN IWbemClassObject    *pLogicalConsumer,
    IN long                lObjectCount,
    IN IWbemClassObject    **ppObjArray
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
      
    if( m_lAlertEmailDisabled == ALERTEMAILDISABLED )
    {
        return WBEM_S_NO_ERROR;
    }

    try
    {
        for (LONG lCount = 0; lCount < lObjectCount; lCount++)
        {

           
            //
            // get the event type 
            //
            CComVariant vtName;
            hr = ppObjArray[lCount]->Get (
                                    PROPERTY_CLASS_NAME, 
                                    0,          //reserved
                                    &vtName,
                                    NULL,       // type
                                    NULL        // flavor
                                    );

            if (FAILED (hr))
            {
                SATraceString( 
                    "AlertEmail: IndicateToConsumer Get Class name failed" 
                    );
                break;
            }
            
            //
            // check if we support the event received
            //
            if (0 == _wcsicmp (CLASS_WBEM_RAISE_ALERT, V_BSTR (&vtName)))
            {
                //
                // handle a raise alert event
                //
                hr = RaiseAlert ( ppObjArray[lCount] );
                if ( FAILED (hr) )
                {
                    SATraceString( 
                        "AlertEmail: IndicateToConsumer RaiseAlert failed" 
                        );
                    break;
                }
            }
            else if (0 == _wcsicmp (CLASS_WBEM_CLEAR_ALERT, V_BSTR (&vtName)))
            {
                //
                // handle a clear alert
                //
                hr = ClearAlert ( ppObjArray[lCount] );
                if ( FAILED (hr) )  
                {
                    SATraceString( 
                        "AlertEmail: IndicateToConsumer ClearAlert failed" 
                        );
                    break;
                }
            }
        } // for loop
    }
    catch (...)
    {
        hr = WBEM_E_FAILED;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::ClearAlert
//
//  Description:
//      This is the CAlertEmailConsumer class private method 
//      which is NOT used now. 
//
//  Arguments:
//      [in] pObject         Pointer to an IWbemClassObject instances which 
//                           represent ClearAlert events delivered.
//
//    Returns:
//        WBEM_S_NO_ERROR     if successful
//        WBEM_E_FAILED       if not
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CAlertEmailConsumer::ClearAlert(
    IN IWbemClassObject *pObject
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    return hr;    
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::RaiseAlert
//
//  Description:
//      This is the CAlertEmailConsumer class private method 
//      which is used to send email with the alert information
//      by local SMTP server. 
//
//  Arguments:
//      [in] pObject        Pointer to an IWbemClassObject instances which 
//                          represent RaiseAlert events delivered.
//
//    Returns:
//        WBEM_S_NO_ERROR     if successful
//        WBEM_E_FAILED       if not
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CAlertEmailConsumer::RaiseAlert(
    IN IWbemClassObject *pObject
    )
{
    LONG        lAlertType;
    CComVariant vtProperty;
    HRESULT     hr = WBEM_S_NO_ERROR;
    
    //
    // Get alert type.
    //
    hr = pObject->Get (
                    PROPERTY_ALERT_TYPE, 
                    0,                 //reserved
                    &vtProperty,
                    NULL,              // type
                    NULL               // flavor
                    );
    if( FAILED (hr) )
    {
        SATraceString( 
            "AlertEmail:RaiseAlert get alert type failed" 
            );
        return hr;
    }


    //
    // Map to bitmap type definition
    //
    lAlertType = 1 << V_I4( &vtProperty );

    if( lAlertType & m_lCurAlertType )
    {
        //
        // It's the type user set to send mail.
        //
        do
        {
            //
            // Get name of alert resource dll.
            //
            CComVariant vtAlertLog;
            hr = pObject->Get (
                            PROPERTY_ALERT_LOG, 
                            0,             //reserved
                            &vtAlertLog,
                            NULL,          // type
                            NULL           // flavor
                            );

            if( FAILED (hr) )
            {
                SATraceString( 
                    "AlertEmail:RaiseAlert get alert source failed" 
                    );
                break;
            }

            //
            // Get alert ID.
            //
            CComVariant vtAlertID;
            hr = pObject->Get (
                            PROPERTY_ALERT_ID, 
                            0,             //reserved
                            &vtAlertID,
                            NULL,          // type
                            NULL           // flavor
                            );
            if( FAILED (hr) )
            {
                SATraceString( 
                    "AlertEmail:RaiseAlert get alert ID failed" 
                    );
                break;
            }
            
            //
            // Get replace strings.
            //
            CComVariant vtReplaceStr;
            hr = pObject->Get (
                            PROPERTY_ALERT_STRINGS, 
                            0,             //reserved
                            &vtReplaceStr,
                            NULL,          // type
                            NULL           // flavor
                            );

            if( FAILED (hr) )
            {
                SATraceString( 
                    "AlertEmail:RaiseAlert get alert replace string failed" 
                    );
                break;
            }
            
            //
            // We got all neccessary info,it's time to send email.
            //
            hr = SendMailFromResource( 
                        V_BSTR( &vtAlertLog ),
                        V_I4( &vtAlertID ),
                        &vtReplaceStr
                        );

            if( FAILED (hr) )
            {
                SATraceString( 
                    "AlertEmail:RaiseAlert call SendMailFromResource failed" 
                    );
                break;
            }
            
        } //do
        while ( FALSE );

    } // if( lAlertType & m_lCurAlertType )

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::SendMailFromResource
//
//  Description:
//      This is the CAlertEmailConsumer class private method which is used 
//      to get useful message about the alert from Local Manager and send 
//      mail with the messages.
//
//  Arguments:
//      [in] lpszSource     Point to the name of alert resource.
//      [in] lSourceID      Alert ID.
//      [in] pvtReplaceStr  Point to array of replace strings.
//
//    Returns:
//        WBEM_S_NO_ERROR     if successful
//        WBEM_E_FAILED       if not
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CAlertEmailConsumer::SendMailFromResource(
    LPWSTR      lpszSource, 
    LONG        lSourceID, 
    VARIANT*    pvtReplaceStr
    )
{
    HRESULT         hr = WBEM_S_NO_ERROR;
    WCHAR           wstrAlertItem[MAX_PATH];  
    IWebElement*    pWebElement;
    IDispatch*      pDispatch;
    
    //
    // Format the alert item name:
    // Name = AlertDefinitions<AlertLog><AlertID>
    //
    ::wsprintf( wstrAlertItem, L"AlertDefinitions%s%lX", lpszSource,lSourceID );
    //int cchWritten = _snwprintf( wstrAlertItem, MAX_PATH, L"AlertDefinitions%s%lX",
    //                             lpszSource, lSourceID );
    //if ( cchWritten >= MAX_PATH || cchWritten < 0 )
    //{
    //    return E_INVALIDARG;
    //}

  
    do
    {
        //
        // Get the element of alert definition from element manager.
        //
        hr = m_pElementEnum->Item( 
                            &CComVariant( wstrAlertItem ), 
                            &pDispatch 
                            );
        if( FAILED(hr) )
        {
            SATraceString( 
                "AlertEmail:SendMailFromResource find alert item failed" 
                );
            break;
        }

        hr = pDispatch->QueryInterface( 
                        __uuidof (IWebElement),
                        reinterpret_cast <PVOID*> (&pWebElement) 
                        );
        if( FAILED(hr) )
        {
            SATraceString( 
                "AlertEmail:SendMailFromResource queryinterface failed" 
                );
            break;
        }



        //
        // allocate BSTR for alertdefintion source
        //
        CComBSTR bstrAlertDefinitionSourceName  (ALERTDEFINITIONSOURCE);
        if (NULL == bstrAlertDefinitionSourceName.m_str)
        {
            SATraceString ("AlertEmail::SendMailFromResouce failed on SysAllocString (ALERTDEFINTIONSOURCE)");
            hr = E_OUTOFMEMORY;
            break;
        }
        
        //
        //Get name of alert's resource dll.
        // AlertLog != AlertSource now! -- 2001/02/07 i-xingj
        //
        CComVariant vtAlertSource;
        hr = pWebElement->GetProperty ( 
            bstrAlertDefinitionSourceName,
            &vtAlertSource 
            );
        if( FAILED(hr) )
        {
            SATraceString( 
                "AlertEmail:SendMailFromResource get Alert source failed" 
                );
            break;
        }

        //
        // allocate BSTR for DesinitionCaptionID string
        //
        CComBSTR bstrAlertDefinitionCaptionIDName (ALERTDEFINITIONCAPTIONID);
        if (NULL == bstrAlertDefinitionCaptionIDName.m_str)
        {
            SATraceString ("AlertEmail::SendMailFromResouce failed on SysAllocString (ALERTDEFINTIONCAPTIONID)");
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // Get caption ID string
        //
        CComVariant vtCaptionID;
        hr = pWebElement->GetProperty ( 
            bstrAlertDefinitionCaptionIDName,
            &vtCaptionID 
            );
        if( FAILED(hr) )
        {
            SATraceString( 
                "AlertEmail:SendMailFromResource find alert captionID failed" 
                );
            break;
        }

        //
        // allocate BSTR for AlertDescription RID
        //
        CComBSTR bstrAlertDefinitionDescriptionRIDName  (ALERTDEFINITIONDESCRIPTIONRID);
        if (NULL == bstrAlertDefinitionDescriptionRIDName.m_str)
        {
            SATraceString ("AlertEmail::SendMailFromResouce failed on SysAllocString (ALERTDEFINITIONDESCRIPTIONRID)");
            hr = E_OUTOFMEMORY;
            break;
        }

        //
        // Get description ID string
        //
        CComVariant vtDescriptionID;
        hr = pWebElement->GetProperty ( 
            bstrAlertDefinitionDescriptionRIDName,
            &vtDescriptionID 
            );
        if( FAILED(hr) )
        {
            SATraceString( 
                "AlertEmail:SendMailFromResource get alert descriptionID failed" 
                );
            break;
        }

               
        LONG lAlertCaptionID;
        LONG lAlertDescriptionID;

        //
        // Change type from string to long.
        //
        if ( EOF == ::swscanf( V_BSTR( &vtCaptionID ), L"%X", &lAlertCaptionID ))
        {
            SATraceString( "AlertEmail:SendMailFromResource get caption invalid" );
            break;
        }
        if ( EOF == ::swscanf( V_BSTR( &vtDescriptionID ), L"%X", &lAlertDescriptionID ))
        {
            SATraceString( "AlertEmail:SendMailFromResource get description invalid" );
            break;
        }

        //
        // Get caption string from resource as email's subject.
        //
        CComBSTR pszSubject;
        hr = m_pLocInfo->GetString( 
                            V_BSTR( &vtAlertSource ), 
                            lAlertCaptionID,
                            pvtReplaceStr,
                            &pszSubject
                            );
        if( FAILED(hr) )
        {
            SATraceString( 
                "AlertEmail:SendMailFromResource get subjuct failed" 
                );
            break;
        }

        //
        // Get description string from resource as email's message.
        //
        CComBSTR pszMessage;
        hr = m_pLocInfo->GetString( 
                            V_BSTR( &vtAlertSource ), 
                            lAlertDescriptionID,
                            pvtReplaceStr,
                            &pszMessage
                            );
        if( FAILED(hr) )
        {
            SATraceString( 
                "AlertEmail:SendMailFromResource get message failed" 
                );
            break;
        }

        //
        // allocate BSTR for email source
        //
        CComBSTR bstrAlertEmailResourceName (ALERTEMAILRESOURCE);
        if (NULL == bstrAlertEmailResourceName.m_str)
        {
            SATraceString ("AlertEmail::SendMailFromResouce failed on SysAllocString (ALERTEMAILRESOURCE)");
            hr = E_OUTOFMEMORY;
            break;
        }
 
        //
        // Get alert email defined message.
        //
        CComBSTR pszConstantMessage;
        hr = m_pLocInfo->GetString( 
                            bstrAlertEmailResourceName, 
                            SA_ALERTEMAIL_SETTINGS_EMAIL_CONTENT,
                            NULL,
                            &pszConstantMessage
                            );
        if( FAILED(hr) )
        {
            SATraceString( 
                "AlertEmail:SendMailFromResource get constantMsg failed" 
                );
            break;
        }
        
        pszMessage += CComBSTR( ENTER );
        pszMessage += CComBSTR( ENTER );
        pszMessage += pszConstantMessage;

        //
        // Send mail use local SMTP server.
        //
        hr = SendMail( pszSubject, pszMessage ); 

    } //do
    while( FALSE );

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::Initialize
//
//  Description:
//      This is the CAlertEmailConsumer class public method call by 
//      CAlertEmailConsumerProvider to initialize useful parameters.
//
//    Returns:
//        S_OK         if successful
//        E_FAIL      if not
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CAlertEmailConsumer::Initialize()
{
    ULONG   ulReturn;
    HRESULT hr = S_OK;
    DWORD   dwThreadID;

    //
    // Initialize Element Manager.
    //
    hr = InitializeElementManager();
    if (FAILED (hr))
    {
        SATraceString( 
            "AlertEmailProvider:Initialize InitializeElementManager failed" 
            );
        return WBEM_E_FAILED;
    }

    //
    //  Initialize Local Manager
    //
    hr = InitializeLocalManager();
    if (FAILED (hr))
    {
        SATraceString( 
            "AlertEmailProvider:Initialize InitializeLocalManager failed" 
            );
        return WBEM_E_FAILED;
    }

    //
    //  Initialize a CDO IMessage interface.
    //
    hr = InitializeCDOMessage();
    if (FAILED (hr))
    {
        SATraceString( 
            "AlertEmailProvider:Initialize InitializeCDOMessage failed" 
            );
        return WBEM_E_FAILED;
    }

    //
    // Open registry key of alertemail settings.
    //
    ulReturn = ::RegOpenKey( 
                    HKEY_LOCAL_MACHINE,
                    SA_ALERTEMAIL_KEYPATH,
                    &m_hAlertKey 
                    );
    if( ulReturn != ERROR_SUCCESS )
    {
        SATraceString( 
            "AlertEmail:Initialize OpenKey failed" 
            );
        return E_FAIL;
    }
    
    //
    // Get alert email settings from registry.
    //
    if( FALSE == RetrieveRegInfo() )
    {
        SATraceString( 
            "AlertEmail:Initialize RetrieveRegInfo failed" 
            );
        return E_FAIL;
    }

    //
    // Get server name fully qualified domain anem.
    //
    if( FALSE == GetComputerName( &m_pstrFullyQualifiedDomainName, ComputerNameDnsFullyQualified ) )
    {
        SATraceString( 
            "AlertEmail:Initialize GetComputerName ComputerNameDnsFullyQualified failed" 
            );
        return E_FAIL;
    }

    //
    // Get server name.
    //
    if( FALSE == GetComputerName( &m_pstrNetBIOSName, ComputerNameNetBIOS ) )
    {
        SATraceString( 
            "AlertEmail:Initialize GetComputerName ComputerNameNetBIOS failed" 
            );
        return E_FAIL;
    }


    //
    // Event for notify thread exit.
    //
    m_hCloseThreadEvent = ::CreateEvent( NULL, TRUE, FALSE, NULL );
    if( m_hCloseThreadEvent == NULL )
    {
        SATraceString( 
            "AlertEmail:Initialize CreateEvent failed" 
            );
        return E_FAIL;
    }
    
    //
    // Thread used to monitor registy change.
    //
    m_hThread = ::CreateThread( 0, 
                                0, 
                                CAlertEmailConsumer::RegThreadProc, 
                                this, 
                                0, 
                                &dwThreadID );
    if( m_hThread == NULL )
    {
        SATraceString( 
            "AlertEmail:Initialize CreateThread failed" 
            );
        return E_FAIL;
    }


    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::GetSMTPFromDomainName
//
//  Description:
//   Get the value of "Full Qualified Domain Name" entry in SMTP Delivery tab in MMC.
//
//  Arguments:
//      [out] bstrDomainName   returns domain name that is found in Metabase.
//
//    Returns:
//        hr
//
//
//////////////////////////////////////////////////////////////////////////////

HRESULT CAlertEmailConsumer::GetSMTPFromDomainName( BSTR* bstrDomainName )
{

    HRESULT hr = S_OK;
    CComPtr<IADs> pADs;

    //
    // Initialize for return
    //
    *bstrDomainName = NULL;

    CComBSTR bstrADSPath( SMTP_META_PATH );
    if (NULL == bstrADSPath.m_str)  
    {
        SATraceString ("CAlertEmailConsumer::GetSMTPFromDomainName failed to allocate memory for bstrADsPath");
        return (E_OUTOFMEMORY);
    }      

    hr = ADsGetObject( bstrADSPath, IID_IADs, (void**) &pADs );

    if ( SUCCEEDED(hr) )
    {
        CComVariant varValue;
              CComBSTR bstrFullyQualifiedDomainName (L"FullyQualifiedDomainName" );
              if (NULL == bstrFullyQualifiedDomainName.m_str)
              {
                   SATraceString ("CAlertEmailConsumer::GetSMTPFromDomainName failed to allocate memory for bstrFullyQualifiedDomainName");
                   hr = E_OUTOFMEMORY;
              }
              else
              {
            // Getting the FullyQualifiedDomainName property 
            hr = pADs->Get(bstrFullyQualifiedDomainName, &varValue );                        
            if ( SUCCEEDED(hr) )
            {
                *bstrDomainName =  SysAllocString( V_BSTR( &varValue ) );
            }
              }
    }
    
    return hr;
 
}


//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::SendMail
//
//  Description:
//      This is the CAlertEmailConsumer class private method which is used 
//      to send mail through local SMTP server.
//
//  Arguments:
//      [in] bstrSubject   Subject string.
//      [in] bstrMessage   Message string.
//
//    Returns:
//        WBEM_S_NO_ERROR     if successful
//        WBEM_E_FAILED       if not
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CAlertEmailConsumer::SendMail(
    BSTR bstrSubject,
    BSTR bstrMessage 
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;
    WCHAR* pstrPort = NULL;
    do
    {


        //
        // The algorithm is
        //   Look at the value of "Full Qualified Domain Name" entry in SMTP Delivery tab in MMC.
        //   1) If the value is empty then the e-mail From Address is same as fully qualified domain name
        //   2) IF there is value and that value is different from Full Qualified Computer Name then use 
        //   3) the following as From address.
        //     4) Use the From Address as appliance_name@"Full Qualified Domain Name"
        //
        //

        //
        // allocate memory for BSTR
        //
        CComBSTR bstrFullyQualifiedDomainName( m_pstrFullyQualifiedDomainName );
              if (NULL == bstrFullyQualifiedDomainName.m_str)
              {
                 SATraceString("AlertEmail:SendMail failed to allocate memory for bstrFullyQualifiedDomainName" );
                 hr = E_OUTOFMEMORY;
                 break;
              }

        CComBSTR bstrFromAddress( m_pstrNetBIOSName );
        if (NULL == bstrFromAddress.m_str)
              {
                 SATraceString("AlertEmail:SendMail failed to allocate memory for bstrFromAddress" );
                 hr = E_OUTOFMEMORY;
                 break;
              }

        BSTR bstrDomainName = NULL;

        //
        // Read SMTP "Full Qualified Domain Name" from Metabase
        hr = GetSMTPFromDomainName( &bstrDomainName );

        if ( FAILED(hr) )
        {
            SATraceString( 
                "AlertEmail:SendMail GetSMTPFromDomainName failed" 
                );

            return E_FAIL;
        }

        if ( bstrDomainName )
        {
            if (  _wcsicmp( bstrFullyQualifiedDomainName, bstrDomainName ) != 0 )
            {
                bstrFromAddress += CComBSTR( L"@" );
                bstrFromAddress += bstrDomainName ;

            }
        }


        //
        //  Set bstrFromAddress that is formed using the above algorithm
        //    as mail sender.
        //
        hr = m_pcdoIMessage->put_From( bstrFromAddress );

        //
        // Free BSTR
        //
        if ( bstrDomainName )
        {
            SysFreeString(  bstrDomainName );
        }

        CComBSTR bstrMailAddress (m_pstrMailAddress );
     if (NULL == bstrMailAddress.m_str)
        {
                 SATraceString("AlertEmail:SendMail failed to allocate memory for bstrMailAddress" );
                 hr = E_OUTOFMEMORY;
                 break;
         }

        //
        // Set mail address.
        //
        hr = m_pcdoIMessage->put_To( bstrMailAddress);
        if( FAILED(hr) )
        {
            SATraceString( 
                "AlertEmail:SendMail put_To failed" 
                );
            break;
        }

        //
        // Set mail subject.
        //
        hr = m_pcdoIMessage->put_Subject( bstrSubject );
        if( FAILED(hr) )
        {
            SATraceString( 
                "AlertEmail:SendMail put_Subject failed" 
                );
            break;
        }

        //
        // Get text bodypart from the message object.
        //
        CComPtr<IBodyPart> pMsgBodyPart;
        hr = m_pcdoIMessage->get_BodyPart( &pMsgBodyPart );
        if( FAILED(hr) )
        {
            SATraceString( 
                "AlertEmail:SendMail get_TextBodyPart failed" 
                );
            break;
        }

        //
        // Get current char set from localize manager.
        //
        CComBSTR bstrCharSet;
        hr = m_pLocInfo->get_CurrentCharSet( &bstrCharSet );
        if( FAILED(hr) )
        {
            SATraceString( 
                "AlertEmail:SendMail get_CurrentCharSet failed" 
                );
            break;
        }

        //
        // Set char set to text bodypart with current char set.
        //
        // TMARSH: Hardcode charset to UTF-8.
        hr = pMsgBodyPart->put_Charset( CComBSTR(L"utf-8") );
//      hr = pMsgBodyPart->put_Charset( bstrCharSet );
        if( FAILED(hr) )
        {
            SATraceString( 
                "AlertEmail:SendMail put_CharSet failed" 
                );
            break;
        }

        CComBSTR bstrExtendMessage;
        bstrExtendMessage.AppendBSTR( bstrMessage );
/*      bstrExtendMessage += CComBSTR( ENTER );
        bstrExtendMessage += CComBSTR( HTTPHEADER );
        bstrExtendMessage += CComBSTR( m_pstrApplianceName );

        hr = GetAppliancePort( &pstrPort );
        if( SUCCEEDED( hr ) )
        {
            bstrExtendMessage += CComBSTR( pstrPort );
        }
        else
        {
            SATraceString( 
                "AlertEmail:SendMail GetAppliancePort failed" 
                );
        }
*/
        //
        // Set mail message.
        //
        hr = m_pcdoIMessage->put_TextBody( bstrExtendMessage );
        if( FAILED(hr) )
        {
            SATraceString( 
                "AlertEmail:SendMail put_TextBody failed" 
                );
            break;
        }
        
        //
        // Send it.
        //
        hr = m_pcdoIMessage->Send();

    }while( FALSE );

    if( pstrPort!= NULL )
    {
        ::free( pstrPort );
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::GetFullyQualifiedDomainName
//
//  Description:
//      This is the CAlertEmailConsumer class private method which is used 
//      to get local appliance name in DNS format.
//
//  Arguments:
//      [in,out] pstrComputerName   Pointer of computer name string.
//
//    Returns:
//        TRUE     if successful
//        FALSE   if not
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
BOOL
CAlertEmailConsumer::GetComputerName(
    LPWSTR* pstrComputerName,
    COMPUTER_NAME_FORMAT nametype
    )
{
    BOOL    bReturn = FALSE;
    DWORD   dwSize = 0;
    DWORD   dwCount = 1;

    do
    {
        if( *pstrComputerName != NULL )
        {
            ::free( *pstrComputerName );
        }
        
        dwSize = MAXAPPLIANCEDNSNAME * dwCount;

        *pstrComputerName = ( LPWSTR ) ::malloc( sizeof(WCHAR) * dwSize );
        if( *pstrComputerName == NULL )
        {
            SATraceString( 
                "AlertEmail:GetApplianceName malloc failed" 
                );
            break;
        }

        //
        // Get local computer name.
        //
        bReturn = ::GetComputerNameEx( 
                                nametype, 
                                *pstrComputerName,
                                &dwSize                
                                );

        dwCount <<= 1;
    }
    while( !bReturn && 
           ERROR_MORE_DATA == ::GetLastError() &&
           dwCount < 32 
           );

    return bReturn;
}




//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::GetAppliancePort
//
//  Description:
//      This is the CAlertEmailConsumer class private method which is used 
//      to get local appliance port.
//
//  Arguments:
//      [in,out] pstrPort   Pointer of server port string.
//
//    Returns:
//        TRUE     if successful
//        FALSE   if not
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
HRESULT
CAlertEmailConsumer::GetAppliancePort(
    LPWSTR* pstrPort
    )
{
    HRESULT hr = S_OK;

    try
    {
        do
        {

            CComPtr  <IWbemLocator> pWbemLocator;
            CComPtr  <IWbemServices> pWbemServices;
            CComPtr  <IEnumWbemClassObject> pEnumServices;

            //
            // create the WBEM locator object  
            //
            hr = ::CoCreateInstance (
                            CLSID_WbemLocator,
                            0,                      //aggregation pointer
                            CLSCTX_INPROC_SERVER,
                            IID_IWbemLocator,
                            (PVOID*) &pWbemLocator
                            );

            if( FAILED(hr) )
            {
                SATraceString( 
                    "AlertEmail:GetAppliancePort CoCreateInstance failed" 
                    );
                break;
            }


            //
            // allocate memory for BSTR
            //
            CComBSTR bstrDefaultNameSpace (DEFAULT_NAMESPACE);
            if (NULL == bstrDefaultNameSpace.m_str)
            {
                 SATraceString("AlertEmail:GetAppliancePort failed to allocate memory for DEFAULT_NAMESPACE" );
                 hr = E_OUTOFMEMORY;
                 break;
            }
            
            //
            // connect to WMI 
            //
            hr =  pWbemLocator->ConnectServer (
                                        bstrDefaultNameSpace,
                                        NULL,               //user-name
                                        NULL,               //password
                                        0,               //current-locale
                                        0,                  //reserved
                                        NULL,               //authority
                                        NULL,               //context
                                        &pWbemServices
                                        );
            if( hr != WBEM_S_NO_ERROR )
            {
                SATraceString( 
                    "AlertEmail:GetAppliancePort ConnectServer failed" 
                    );
                break;
            }

            //
            // Query Web server instance.
            //
            hr = pWbemServices->ExecQuery(
                                    CComBSTR( QUERY_LANGUAGE ),
                                    CComBSTR( QUERY_STRING ),
                                    0,                  
                                    NULL,               
                                    &pEnumServices
                                    );
            if( hr != WBEM_S_NO_ERROR )
            {
                SATraceString( 
                    "AlertEmail:GetAppliancePort ExecQuery failed" 
                    );
                break;
            }

            CComPtr  <IWbemClassObject> pService;
            ULONG uReturned;

            //
            // Now,we only care for the first match.
            //
            hr = pEnumServices->Next( 
                                    WBEM_NO_WAIT, 
                                    1,
                                    &pService, 
                                    &uReturned 
                                    ); 
            if( hr != WBEM_S_NO_ERROR )
            {
                SATraceString( 
                    "AlertEmail:GetAppliancePort nothing found" 
                    );
                break;
            }

            CComVariant vtServerBindings;

            //
            // Get the "ServerBindings" property.
            //
            hr = pService->Get( 
                            CComBSTR( SERVERBINDINGSPROP ), 
                            0, 
                            &vtServerBindings, 
                            0, 
                            0 
                            );
            if ( FAILED(hr) || !V_ISARRAY( &vtServerBindings ) )
            {
                hr = E_FAIL;
                SATraceString( 
                    "AlertEmail:GetAppliancePort get serverbindings failed" 
                    );
                break;
            }

            SAFEARRAY* psa;
            BSTR HUGEP *pbstr;

            //
            // The property type is VT_ARRAY | VT_BSTR.
            //
            psa = V_ARRAY( &vtServerBindings );
            if( psa->cDims <= 0 )
            {
                hr = E_FAIL;
                SATraceString( 
                    "AlertEmail:GetAppliancePort array dim error" 
                    );
                break;
            }

            //
            // Access array data directly,it's a faster way.
            //
            hr = ::SafeArrayAccessData( psa, ( void HUGEP** )&pbstr );
            if (FAILED(hr))
            {
                SATraceString( 
                    "AlertEmail:GetAppliancePort SafeArrayAccessData failed" 
                    );
                break;
            }
            
            //
            // Now we can alloc the port string.
            //
            *pstrPort = ( LPWSTR )malloc( sizeof(WCHAR) * MAX_COMPUTERNAME_LENGTH );
            if( *pstrPort == NULL )
            {
                hr = E_FAIL;
                SATraceString( 
                    "AlertEmail:GetAppliancePort malloc failed" 
                    );
                break;
            }
            
            WCHAR* pszTemp1;
            WCHAR* pszTemp2;

            pszTemp1 = ::wcschr( pbstr[0], COLON );
            pszTemp2 = ::wcsrchr( pbstr[0], COLON );

            if( pszTemp2 != NULL && pszTemp1 != NULL )
            {
                pszTemp2[0] = ENDCODE;        
                ::wcscpy( *pstrPort, pszTemp1 );
            }
            else
            {
                SATraceString( 
                    "AlertEmail:GetAppliancePort string formate error" 
                    );
                hr = E_FAIL;
            }

            ::SafeArrayUnaccessData( psa );           
        }
        while( false );
    }
    catch (...)
    {
        SATraceString( 
            "AlertEmail:GetAppliancePort unkown exception" 
            );
        hr = E_FAIL;
    }

    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::RetrieveRegInfo
//
//  Description:
//      This is the CAlertEmailConsumer class private method which is used 
//      to retrieve alert email settings from registry.
//
//    Returns:
//        TRUE     if successful
//        FALSE   if not
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
BOOL
CAlertEmailConsumer::RetrieveRegInfo()
{
    BOOL    bReturn = TRUE;
    LONG    lReturn;
    DWORD   dwDataSize;

    //
    // Get the email address will be send to.
    //
    dwDataSize = sizeof(m_pstrMailAddress);
    lReturn = ::RegQueryValueEx( 
                            m_hAlertKey,
                            RECEIVEREMAILADDRESS,
                            NULL,
                            NULL,
                            reinterpret_cast<PBYTE>(m_pstrMailAddress),
                            &dwDataSize );
    if( lReturn != ERROR_SUCCESS)
    {
        m_pstrMailAddress[0] = L'\0'; // RegQueryValueEx doesn't guarantee
                                      // a desirable value, so clear the string.
        SATraceString( 
            "AlertEmail:RetrieveRegInfo query address failed" 
            );
        bReturn = FALSE;
    }
    else
    {
        _ASSERT(dwDataSize <= sizeof(m_pstrMailAddress));

        //
        // Validate the e-mail address length.
        //
        LONG lLastCharacter;
        if( sizeof( m_pstrMailAddress[0] ) > dwDataSize )
        {
            lLastCharacter = 0;
        }
        else
        {
            lLastCharacter = dwDataSize / sizeof( m_pstrMailAddress[0] ) - 1;
        }

        if( sizeof(m_pstrMailAddress) == dwDataSize && 
            L'\0' != m_pstrMailAddress[lLastCharacter] )
        {
            SATraceString( "AlertEmail:RetrieveRegInfo address too long" );
            bReturn = FALSE;
        }
        m_pstrMailAddress[lLastCharacter] = L'\0';
    }

    //
    // Get alert enable setting.
    //
    dwDataSize = sizeof( LONG );
    lReturn = ::RegQueryValueEx( 
                            m_hAlertKey,
                            ENABLEALERTEAMIL,
                            NULL,
                            NULL,
                            reinterpret_cast<PBYTE>(&m_lAlertEmailDisabled),
                            &dwDataSize 
                            );
    if( lReturn != ERROR_SUCCESS)
    {
        SATraceString( 
            "AlertEmail:RetrieveRegInfo query enablealertemail failed" 
            );
           bReturn = FALSE;
    }

    //
    // Get alert type setting.
    //
    dwDataSize = sizeof( LONG );
    lReturn = ::RegQueryValueEx( 
                            m_hAlertKey,
                            SENDEMAILTYPE,
                            NULL,
                            NULL,
                            reinterpret_cast<PBYTE>(&m_lCurAlertType),
                            &dwDataSize 
                            );
    if( lReturn != ERROR_SUCCESS)
    {
        SATraceString( 
            "AlertEmail:RetrieveRegInfo query enablealertemail failed" 
            );
           bReturn = FALSE;
    }
    
    return bReturn;
}


//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::RegThreadProc
//
//  Description:
//      This is the CAlertEmailConsumer class static method which is used
//      as worker thread entry.
//
//  Arguments:
//      [in] pIn   Point to an instance of CAlertEmailConsumer class.
//
//    Returns:
//        0         if successful
//        -1      if not
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
DWORD WINAPI 
CAlertEmailConsumer::RegThreadProc( 
    PVOID pIn 
    )
{
    //
    // Make transition to the per-instance method.
    //
    ( (CAlertEmailConsumer *) pIn )->RegThread();
    return 0;
}


//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::RegThread
//
//  Description:
//      This is the CAlertEmailConsumer class public method which is real
//      worker thread process.
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
void
CAlertEmailConsumer::RegThread()
{
    HANDLE hHandleArray[2]; 
    DWORD  dwEventCount;
    DWORD  dwReturn;

    SATraceString( 
    "AlertEmail:RegThread enter" 
    );

    //
    // Handle list used by WaitForMultipleObjects
    //
    hHandleArray[0] = m_hCloseThreadEvent;

    //
    // Event for RegNotifyChangeKeyValue.
    //
    hHandleArray[1] = ::CreateEvent( NULL, FALSE, FALSE, NULL );
    
    if( hHandleArray[1] != NULL )
    {
        dwEventCount = 2;

        // 
        // Monitor key change action.
        //
        ::RegNotifyChangeKeyValue( m_hAlertKey,                 //AlertEmail key
                                   FALSE,                       //No subkey
                                   REG_NOTIFY_CHANGE_LAST_SET,  //Value change
                                   hHandleArray[1],             //Event handle
                                   TRUE );                      //APC
    }
    else
    {
        SATraceString( 
            "AlertEmail:RegThread CreateEvent failed" 
            );
        dwEventCount = 1;
    }

    while( TRUE )
    {
        //
        // Wait for both close and regchange event.
        //
        dwReturn = ::WaitForMultipleObjects( dwEventCount, 
                                             hHandleArray, 
                                             FALSE, 
                                             INFINITE );
        switch( dwReturn )
        {
            case WAIT_OBJECT_0:
            {
                //
                // Close thread event set in release method.
                //
                SATraceString( 
                "AlertEmail:RegThread get close event" 
                );

                if( hHandleArray[1] != NULL )
                {
                    ::CloseHandle( hHandleArray[1] );
                }
                
                //
                // Clean up.
                //
                delete this;
                return;
            } //case WAIT_OBJECT_0:

            case WAIT_OBJECT_0 + 1:
            {
                //
                // Registry changed event.
                //
                SATraceString( 
                "AlertEmail:RegThread get reg event" 
                );

                BOOL bReturn;

                //
                // Refresh alert email settings.
                //
                bReturn = RetrieveRegInfo();
                if( bReturn == FALSE )
                {
                    SATraceString( 
                        "AlertEmail:RegThread RetrieveRegInfo failed" 
                        );
                }
                break;
            } //case WAIT_OBJECT_0 + 1:

            default:
            {
                //
                // Wait error ocupied.
                //
                SATraceString( 
                    "AlertEmail:RegThread waitevent error" 
                    );
                break;
            } //default:

        } //switch(dwReturn)

    } // While( TRUE )
   
    return;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::InitializeLocalManager
//
//  Description:
//      This is the CAlertEmailConsumer class private method which is used 
//      to get object of Local Manager.
//
//    Returns:
//        WBEM_S_NO_ERROR     if successful
//        WBEM_E_FAILED       if not
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CAlertEmailConsumer::InitializeLocalManager()
{
    CLSID clsidLocMgr;
    HRESULT hr;

    hr = ::CLSIDFromProgID (
                 LOCALIZATION_MANAGER,
                 &clsidLocMgr
                 );
    if (SUCCEEDED (hr))
    {
        //
        // create the Localization Manager COM object
        //
        hr = ::CoCreateInstance (
                    clsidLocMgr,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    __uuidof (ISALocInfo), 
                    (PVOID*) &m_pLocInfo
                    ); 
    }
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::InitializeElementManager
//
//  Description:
//      This is the CAlertEmailConsumer class private method which is used 
//      to get object of elements enum interface from Element manager.
//
//    Returns:
//        WBEM_S_NO_ERROR     if successful
//        WBEM_E_FAILED       if not
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CAlertEmailConsumer::InitializeElementManager()
{
    HRESULT     hr = WBEM_S_NO_ERROR;
    IDispatch   *pDispatch  = NULL;

    IWebElementRetriever *pWebElementRetriever = NULL;

    do
    {
        //
        // Get Element Manager's CLSID.
        //
        CLSID clsid;
        hr =  ::CLSIDFromProgID (
                ELEMENT_RETRIEVER,
                &clsid
                );
        if (FAILED (hr))
        {
            break;
        }

        //
        // create the WebElementRetriever now
        //
        hr = ::CoCreateInstance (
                        clsid,
                        NULL,
                        CLSCTX_LOCAL_SERVER,
                        IID_IWebElementRetriever,
                        (PVOID*) &pWebElementRetriever
                        );
        if (FAILED (hr))
        {
            break;
        }

        //
        // allocate memory for BSTR(alert definitions)
        //
        CComBSTR bstrAlertDefinitions (ALERTDEFINITIONS);
        if (NULL == bstrAlertDefinitions.m_str)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        
        //
        // Initial now
        //  
        hr = pWebElementRetriever->GetElements (
                                WEB_ELEMENT_TYPE_DEFINITION,
                                bstrAlertDefinitions,
                                &pDispatch
                                );
        if (FAILED (hr))
        {
            break;
        }

        //
        //  get the enum variant
        //
        hr = pDispatch->QueryInterface (
            IID_IWebElementEnum,
            reinterpret_cast <PVOID*> (&m_pElementEnum)
            );

    }while( FALSE );
    
    if( pDispatch != NULL )
    {
        pDispatch->Release();
    }

    if( pWebElementRetriever != NULL )
    {
        pWebElementRetriever->Release();
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumer::InitializeCDOMessage
//
//  Description:
//      This is the CAlertEmailConsumer class private method which is used 
//      to get object of CDO::IMessage and set the configuration as using 
//      local SMTP server.
//
//    Returns:
//        WBEM_S_NO_ERROR     if successful
//        WBEM_E_FAILED       if not
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
HRESULT CAlertEmailConsumer::InitializeCDOMessage()
{
    HRESULT hr = S_OK;
    CComPtr <IConfiguration> pConfig;

    do
    {
        //
        // Get an object of IMessage
        //
        hr = CoCreateInstance(
                            CLSID_Message, 
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IMessage,
                            (PVOID*) &m_pcdoIMessage
                            );

        if (FAILED (hr))
        {
            SATraceString( 
                "AlertEmail: InitializeCDOMessage CoCreateInstance failed" 
                );

            break;
        }

        //
        // Get the configuration in this message object.
        //
        hr = m_pcdoIMessage->get_Configuration(&pConfig);
        if (FAILED (hr))
        {
            SATraceString( 
                "AlertEmail: InitializeCDOMessage get_Configuration failed" 
                );
            break;
        }
        
        //
        // Set the configuration as default setting of local 
        // SMTP server.
        //
        hr = pConfig->Load( cdoIIS, NULL );
        
    }
    while( FALSE );

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\frameworks\webui\xmlview\xmlview.cpp ===
/**************************************************************************
   THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
   ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
   THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
   PARTICULAR PURPOSE.

   Copyright 1998 Microsoft Corporation.  All Rights Reserved.
**************************************************************************/

/**************************************************************************

   File:          SampView.cpp
   
   Description:   Contains DLLMain and standard OLE COM object creation stuff.

**************************************************************************/

/**************************************************************************
   #include statements
**************************************************************************/

#include "ShlView.h"
#include "ClsFact.h"
#include "ViewList.h"
#include "Utility.h"
#include <olectl.h>
#include "ParseXML.h"

/**************************************************************************
   GUID stuff
**************************************************************************/

//this part is only done once
//if you need to use the GUID in another file, just include Guid.h
#pragma data_seg(".text")
#define INITGUID
#include <initguid.h>
#include <shlguid.h>
#include "Guid.h"
#pragma data_seg()

/**************************************************************************
   private function prototypes
**************************************************************************/

extern "C" BOOL WINAPI DllMain(HINSTANCE, DWORD, LPVOID);

/**************************************************************************
   global variables
**************************************************************************/

HINSTANCE   g_hInst;
UINT        g_DllRefCount;
HIMAGELIST  g_himlLarge = NULL;
HIMAGELIST  g_himlSmall = NULL;
TCHAR       g_szStoragePath[MAX_PATH];
TCHAR       g_szExtTitle[TITLE_SIZE];
const TCHAR c_szDataFile[] = TEXT("items.ini\0");
const TCHAR c_szSection[] = TEXT("Items\0");
int         g_nColumn = INITIAL_COLUMN_SIZE;
CViewList   *g_pViewList;
IXMLDocument *g_pXMLDoc = NULL;
const TCHAR g_szXMLUrl[] = TEXT("http://a-yurip1/test/test.xml");

/**************************************************************************

   DllMain

**************************************************************************/

extern "C" BOOL WINAPI DllMain(  HINSTANCE hInstance, 
                                 DWORD dwReason, 
                                 LPVOID lpReserved)
{
HRESULT hr;
PSTR pszErr = NULL;

switch(dwReason)
   {
   case DLL_PROCESS_ATTACH:
      g_hInst = hInstance;
      g_DllRefCount = 0;
      // Open the sourse XML
      // For now we are using global XML object because we have only one file
      // In the future we have to associate the file with the folder and put the object in IDL
      if (g_pXMLDoc == NULL)
      {
            hr = GetSourceXML(&g_pXMLDoc, TEXT("http://a-yurip1/test/test.xml"));
            if (!SUCCEEDED(hr) || !g_pXMLDoc)
            {
                SAFERELEASE(g_pXMLDoc);
                return FALSE;
            }
            BSTR bstrVal;
            hr = g_pXMLDoc->get_version(&bstrVal);
            // Check if the version is correct ???????
            // 
            SysFreeString(bstrVal);
            bstrVal = NULL;
      }

      GetGlobalSettings();
      
      //create the global image lists
      CreateImageLists();

      g_pViewList = new CViewList();
      break;

   case DLL_PROCESS_DETACH:
      SaveGlobalSettings();

      //destroy the global image lists
      DestroyImageLists();

      if(g_pViewList)
         delete g_pViewList;

      if (g_pXMLDoc)
          SAFERELEASE(g_pXMLDoc);

      break;
   }
   
return TRUE;
}                                 

/**************************************************************************

   DllCanUnloadNow

**************************************************************************/

STDAPI DllCanUnloadNow(VOID)
{
return (g_DllRefCount ? S_FALSE : S_OK);
}

/**************************************************************************

   DllGetClassObject

**************************************************************************/

STDAPI DllGetClassObject(  REFCLSID rclsid, 
                           REFIID riid, 
                           LPVOID *ppReturn)
{
*ppReturn = NULL;

//if we don't support this classid, return the proper error code
if(!IsEqualCLSID(rclsid, CLSID_SampleNameSpace))
   return CLASS_E_CLASSNOTAVAILABLE;
   
//create a CClassFactory object and check it for validity
CClassFactory *pClassFactory = new CClassFactory();
if(NULL == pClassFactory)
   return E_OUTOFMEMORY;
   
//get the QueryInterface return for our return value
HRESULT hResult = pClassFactory->QueryInterface(riid, ppReturn);

//call Release to decrement the ref count - creating the object set it to one 
//and QueryInterface incremented it - since its being used externally (not by 
//us), we only want the ref count to be 1
pClassFactory->Release();

//return the result from QueryInterface
return hResult;
}

/**************************************************************************

   DllRegisterServer

**************************************************************************/

typedef struct{
   HKEY  hRootKey;
   LPTSTR lpszSubKey;
   LPTSTR lpszValueName;
   LPTSTR lpszData;
}REGSTRUCT, *LPREGSTRUCT;

STDAPI DllRegisterServer(VOID)
{
int      i;
HKEY     hKey;
LRESULT  lResult;
DWORD    dwDisp;
TCHAR    szSubKey[MAX_PATH];
TCHAR    szCLSID[MAX_PATH];
TCHAR    szModule[MAX_PATH];
LPWSTR   pwsz;

//get the CLSID in string form
StringFromIID(CLSID_SampleNameSpace, &pwsz);

if(pwsz)
   {
   WideCharToLocal(szCLSID, pwsz, ARRAYSIZE(szCLSID));

   //free the string
   LPMALLOC pMalloc;
   CoGetMalloc(1, &pMalloc);
   if(pMalloc)
      {
      pMalloc->Free(pwsz);
      pMalloc->Release();
      }
   }

//get this DLL's path and file name
GetModuleFileName(g_hInst, szModule, ARRAYSIZE(szModule));

//register the CLSID entries
REGSTRUCT ClsidEntries[] = {  HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s"),                  NULL,                   g_szExtTitle,
                              HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s\\InprocServer32"),  NULL,                   TEXT("%s"),
                              HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s\\InprocServer32"),  TEXT("ThreadingModel"), TEXT("Apartment"),
                              HKEY_CLASSES_ROOT,   TEXT("CLSID\\%s\\DefaultIcon"),     NULL,                   TEXT("%s,0"),
                              NULL,                NULL,                               NULL,                   NULL};

for(i = 0; ClsidEntries[i].hRootKey; i++)
   {
   //Create the sub key string.
   wsprintf(szSubKey, ClsidEntries[i].lpszSubKey, szCLSID);

   lResult = RegCreateKeyEx(  ClsidEntries[i].hRootKey,
                              szSubKey,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              &dwDisp);
   
   if(NOERROR == lResult)
      {
      TCHAR szData[MAX_PATH];

      //if necessary, create the value string
      wsprintf(szData, ClsidEntries[i].lpszData, szModule);
   
      lResult = RegSetValueEx(   hKey,
                                 ClsidEntries[i].lpszValueName,
                                 0,
                                 REG_SZ,
                                 (LPBYTE)szData,
                                 (lstrlen(szData) + 1) * sizeof(TCHAR));
      
      RegCloseKey(hKey);
      }
   else
      return SELFREG_E_CLASS;
   }

//Register the default flags for the folder.

wsprintf(   szSubKey, 
            TEXT("CLSID\\%s\\ShellFolder"), 
            szCLSID);

lResult = RegCreateKeyEx(  HKEY_CLASSES_ROOT,
                           szSubKey,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           NULL,
                           &hKey,
                           &dwDisp);

if(NOERROR == lResult)
   {
   DWORD dwData = SFGAO_FOLDER | SFGAO_HASSUBFOLDER | SFGAO_BROWSABLE | SFGAO_DROPTARGET;

   lResult = RegSetValueEx(   hKey,
                              TEXT("Attributes"),
                              0,
                              REG_BINARY,
                              (LPBYTE)&dwData,
                              sizeof(dwData));
   
   RegCloseKey(hKey);
   }
else
   return SELFREG_E_CLASS;

//Register the name space extension

/*
Create the sub key string. Change this from "...MyComputer..." to 
"...Desktop..." if desired.
*/
wsprintf(   szSubKey, 
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\%s"), 
            //TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\NameSpace\\%s"), 
            szCLSID);

lResult = RegCreateKeyEx(  HKEY_LOCAL_MACHINE,
                           szSubKey,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_WRITE,
                           NULL,
                           &hKey,
                           &dwDisp);

if(NOERROR == lResult)
   {
   TCHAR szData[MAX_PATH];

   //Create the value string.
   lstrcpy(szData, g_szExtTitle);

   lResult = RegSetValueEx(   hKey,
                              NULL,
                              0,
                              REG_SZ,
                              (LPBYTE)szData,
                              (lstrlen(szData) + 1) * sizeof(TCHAR));
   
   RegCloseKey(hKey);
   }
else
   return SELFREG_E_CLASS;

//If running on NT, register the extension as approved.
OSVERSIONINFO  osvi;

osvi.dwOSVersionInfoSize = sizeof(osvi);
GetVersionEx(&osvi);

if(VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
   {
   lstrcpy( szSubKey, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"));

   lResult = RegCreateKeyEx(  HKEY_LOCAL_MACHINE,
                              szSubKey,
                              0,
                              NULL,
                              REG_OPTION_NON_VOLATILE,
                              KEY_WRITE,
                              NULL,
                              &hKey,
                              &dwDisp);

   if(NOERROR == lResult)
      {
      TCHAR szData[MAX_PATH];

      //Create the value string.
      lstrcpy(szData, g_szExtTitle);

      lResult = RegSetValueEx(   hKey,
                                 szCLSID,
                                 0,
                                 REG_SZ,
                                 (LPBYTE)szData,
                                 (lstrlen(szData) + 1) * sizeof(TCHAR));
      
      RegCloseKey(hKey);
      }
   else
      return SELFREG_E_CLASS;
   }

return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\alertemail\source\alerteventconsumer\calertemailconsumer.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999--2001 Microsoft Corporation
//
//  Module Name:
//      CAlertEmailConsumer.h
//
//  Description:
//      Implement the interface of IWbemUnboundObjectSink
//
//  [Implementation Files:]
//      CAlertEmailConsumer.cpp
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

const ULONG MAX_EMAILADDRESS = 1024; // Including the NULL.

//////////////////////////////////////////////////////////////////////////////
//
//
//  class CAlertEmailConsumer
//
//  Description:
//      Physical event of consumer for Alert Event.
//
//  History
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

class CAlertEmailConsumer :
    public IWbemUnboundObjectSink
{

//
// Public data
//
public:

    //
    // Constructors & Destructors
    //
    CAlertEmailConsumer();
    ~CAlertEmailConsumer();

    //
    // Initial function called by consumer provider.
    //
    HRESULT Initialize();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    //
    // IWbemUnboundObjectSink members
    //
    STDMETHOD(IndicateToConsumer)(
        IWbemClassObject *pLogicalConsumer,
        long lNumObjects,
        IWbemClassObject **ppObjects
        );

    static DWORD WINAPI RegThreadProc( PVOID pIn );
    void RegThread();

//
// private data
//
private:

    //
    // Method for email sending.
    //
    HRESULT 
    SendMail(    
        BSTR bstrSubject,
        BSTR bstrMessage 
        );

    //
    // Method to get alert's resource information and send mail.
    //
    HRESULT 
    SendMailFromResource(
        LPWSTR      lpszSource, 
        LONG        lSourceID, 
        VARIANT*    pvtReplaceStr
        );

    //
    // Method to get FullyQualifiedDomainName.
    //
    BOOL
    GetComputerName(
        LPWSTR* pstrFullyQualifiedDomainName,
        COMPUTER_NAME_FORMAT nametype
        );


    //
    // Get the port local server appliance is using.
    //
    HRESULT
    GetAppliancePort(
        LPWSTR* pstrPort
        );

    BOOL RetrieveRegInfo();

    //
    // Method to intialize CDO.
    //
    HRESULT InitializeCDOMessage(void);

    //
    // Method to intialize Element Manager.
    //
    HRESULT InitializeElementManager(void);

    //
    // Method to intialize CDO interface.
    //
    HRESULT InitializeLocalManager(void);

    //
    // Handler for raised alert event.
    //
    HRESULT RaiseAlert(IWbemClassObject    *pObject);

    //
    // Get SMTP "Fully Qualified Domain Name" from metabase
    //
    HRESULT GetSMTPFromDomainName( BSTR* bstrDomainName );

    //
    // Handler for cleared alert event.
    //
    HRESULT ClearAlert(IWbemClassObject    *pObject);

    LONG    m_cRef;            // Reference counter.

    HKEY    m_hAlertKey;       // Handle of AlertEmail key. 

    LONG    m_lCurAlertType;   // Current alert type.

    LONG    m_lAlertEmailDisabled;

    WCHAR   m_pstrMailAddress[MAX_EMAILADDRESS];

    LPWSTR  m_pstrFullyQualifiedDomainName;

    LPWSTR    m_pstrNetBIOSName;

    HANDLE  m_hCloseThreadEvent;

    HANDLE  m_hThread;



    //
    // Reference to Local Manager.
    //
    ISALocInfo*         m_pLocInfo;

    //
    // Reference to CDO::IMessage.
    //
    IMessage*           m_pcdoIMessage;

    //
    // Reference to Element Manager.
    //
    IWebElementEnum*    m_pElementEnum;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\alertemail\source\alerteventconsumer\calertemailconsumerprovider.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      CAlertEmailConsumerProvider.cpp
//
//  Description:
//      Implementation of CAlertEmailConsumerProvider class methods
//
//  [Header File:]
//      CAlertEmailConsumerProvider.h
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
//#include <cdosys_i.c>
//#include <SALOCMGR_I.C>
//#include <ELEMENTMGR_I.C>  

#include "CAlertEmailConsumerProvider.h"
#include "CAlertEmailConsumer.h"
#include "AlertEmailProviderGuid.h"

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumerProvider::CAlertEmailConsumerProvider
//
//  Description:
//      Class constructor.
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
CAlertEmailConsumerProvider::CAlertEmailConsumerProvider()
{
    m_cRef = 0L;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumerProvider::~CAlertEmailConsumerProvider
//
//  Description:
//      Class deconstructor.
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
CAlertEmailConsumerProvider::~CAlertEmailConsumerProvider()
{
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumerProvider::QueryInterface
//
//  Description:
//      An method implement of IUnkown interface.
//
//  Arguments:
//        [in]  riid        Identifier of the requested interface
//        [out] ppv        Address of output variable that receives the 
//                        interface pointer requested in iid
//
//    Returns:
//        NOERROR            if the interface is supported
//        E_NOINTERFACE    if not
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CAlertEmailConsumerProvider::QueryInterface(
    IN  REFIID riid,    
    OUT LPVOID FAR *ppv 
    )
{
    *ppv = NULL;
    
    if ( ( IID_IUnknown==riid ) || 
        (IID_IWbemEventConsumerProvider == riid ) )
    {
        *ppv = (IWbemEventConsumerProvider *) this;
        AddRef();
        return NOERROR;
    }

    if (IID_IWbemProviderInit==riid)
    {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        return NOERROR;
    }

    SATraceString( 
        "AlertEmail:CAlertEmailConsumerProvider QueryInterface failed" 
        );

    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumerProvider::AddRef
//
//  Description:
//      increments the reference count for an interface on an object
//
//    Returns:
//        The new reference count.
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
CAlertEmailConsumerProvider::AddRef(void)
{
    InterlockedIncrement( &m_cRef );
    return m_cRef;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumerProvider::Release
//
//  Description:
//      decrements the reference count for an interface on an object.
//
//    Returns:
//        The new reference count.
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP_(ULONG) 
CAlertEmailConsumerProvider::Release(void)
{

    InterlockedDecrement( &m_cRef );
    if (0 != m_cRef)
    {
        return m_cRef;
    }

    delete this;
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumerProvider::Initialize
//
//  Description:
//      An method implement of IWbemProviderInit interface.
//
//  Arguments:
//        [in] wszUser        Pointer to the user name
//      [in] lFlags         Reserved
//      [in] wszNamespace   Namespace name for which the provider is being 
//                          initialized
//      [in] wszLocale      Locale name for which the provider is being 
//                          initialized
//      [in] IWbemServices  An IWbemServices pointer back into Windows 
//                          Management
//      [in] pCtx           An IWbemContext pointer associated with initialization
//      [in] pInitSink      An IWbemProviderInitSink pointer that is used by 
//                          the provider to report initialization status. 
//
//
//    Returns:
//        WBEM_S_NO_ERROR         if successful
//        WBEM_E_FAILED           if not
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CAlertEmailConsumerProvider::Initialize(
    LPWSTR wszUser, 
    LONG lFlags,
    LPWSTR wszNamespace, 
    LPWSTR wszLocale,
    IWbemServices __RPC_FAR *pNamespace,
    IWbemContext __RPC_FAR *pCtx,
    IWbemProviderInitSink __RPC_FAR *pInitSink
    )
{   
    HRESULT hr;

    //
    // Tell CIMOM that we are initialized
    //
    pInitSink->SetStatus(WBEM_S_INITIALIZED, 0);
    return WBEM_S_NO_ERROR;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CAlertEmailConsumerProvider::FindConsumer
//
//  Description:
//      An method implement of IWbemEventConsumerProvider interface.
//
//  Arguments:
//      [in]  pLogicalConsumer  Pointer to the logical consumer object to 
//                              which the event objects are to be delivered
//      [out] ppConsumer        Returns an event object sink to Windows 
//                              Management.
//
//    Returns:
//        WBEM_S_NO_ERROR         if successful
//        WBEM_E_FAILED           if not
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CAlertEmailConsumerProvider::FindConsumer(
    IWbemClassObject* pLogicalConsumer,
    IWbemUnboundObjectSink** ppConsumer
    )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    //
    // Allocate an IWembUnboundedSink object.
    //
    CAlertEmailConsumer* pSink = new CAlertEmailConsumer();
    
    //
    // Initialize the sink object.
    //
    hr = pSink->Initialize();

    if( FAILED(hr) )
    {
        SATraceString( 
            "AlertEmail:FindConsumer Initialize failed" 
            );
        delete pSink;
        return WBEM_E_NOT_FOUND;
    }

    return pSink->QueryInterface(
                            IID_IWbemUnboundObjectSink, 
                            ( void** )ppConsumer
                            );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\alertemail\source\alerteventconsumer\oleserverexport.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999--2001 Microsoft Corporation
//
//  Module Name:
//      OleServerExport.cpp
//
//  Description:
//      description-for-module
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <time.h>
#include <locale.h>

#include "CFactory.h"
#include "CAlertEmailConsumerProvider.h"
#include "AlertEmailProviderGuid.h"

static HINSTANCE    g_hInstance;

LONG        g_cObj = 0;
LONG        g_cLock= 0;

//////////////////////////////////////////////////////////////////////////////
//
//  DllMain
//
//  Description:
//        Entry point of the module.
//
//  Arguments:
//        [in]    hinstDLLIn
//                dwReasonIn
//                lpReservedIn
//
//    Returns:
//        TRUE    
//        FALSE    
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

BOOL 
WINAPI 
DllMain(
    HINSTANCE hinstDLLIn,
    DWORD dwReasonIn,
    LPVOID lpReservedIn
    )
{
    if ( dwReasonIn == DLL_PROCESS_ATTACH )
    {
        g_hInstance = hinstDLLIn;
        setlocale( LC_ALL, "" );    
    }
    else if ( dwReasonIn == DLL_PROCESS_DETACH )
    {
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
//
//  DllGetClassObject
//
//  Description:
//      Retrieves the class object from the module.
//
//  Arguments:
//        [in]    rclsidIn
//                riidIn
//        [out]    ppvOut
//
//    Return:
//        S_OK     
//        CLASS_E_CLASSNOTAVAILABLE     
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
extern "C"
HRESULT 
APIENTRY 
DllGetClassObject(
    REFCLSID rclsidIn,
    REFIID riidIn,
    LPVOID * ppvOut
    )
{
    HRESULT                    hr;
    CFactory *        pFactory;

    //
    //  Verify the caller is asking for our type of object.
    //
    if ( CLSID_AlertEmailConsumerProvider != rclsidIn ) 
    {
        return E_FAIL;
    }

    //
    // Check that we can provide the interface.
    //
    if ( IID_IUnknown != riidIn && IID_IClassFactory != riidIn )
    {
        return E_NOINTERFACE;
    }

    //
    // Get a new class factory.
    //
    pFactory = new CFactory( rclsidIn );

    if ( !pFactory )
    {
        return E_OUTOFMEMORY;
    }

    //
    // Verify we can get an instance.
    //
    hr = pFactory->QueryInterface( riidIn, ppvOut );

    if ( FAILED( hr ) )
    {
        delete pFactory;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  DllCanUnloadNow
//
//  Description:
//      Retrieves the class object from the module.
//
//    Return:
//        SA_OK
//        SA_FALSE
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
extern "C"
HRESULT 
APIENTRY 
DllCanUnloadNow(void)
{
    SCODE sc = TRUE;

    if (g_cObj || g_cLock)
        sc = S_FALSE;

    return sc;
}

//////////////////////////////////////////////////////////////////////////////
//
//  DllRegisterServer
//
//  Description:
//        Standard OLE entry point for registering the server.
//
//  Returns:
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

extern "C"
HRESULT
APIENTRY 
DllRegisterServer(void)
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];

    //
    // Where are we?
    //
    DWORD dwResult =  GetModuleFileNameW(g_hInstance, Path, 1023);
    if (0 == dwResult)
    {
        return (HRESULT_FROM_WIN32 (GetLastError ()));
    }
    Path[1023] = L'\0';

    //
    // Convert CLSID to string.
    //
    HRESULT hr = StringFromCLSID(CLSID_AlertEmailConsumerProvider, &pGuidStr);
    if (FAILED (hr))
    {
        return (hr);
    }
    
    int cchWritten = _snwprintf(KeyPath, 1023, L"CLSID\\\\%s", pGuidStr);
    if (cchWritten < 0)
    {
        CoTaskMemFree(pGuidStr);
        return E_FAIL;
    }
    KeyPath [1023] = L'\0';

    HKEY hKey;
    LONG lRes = RegCreateKeyW(HKEY_CLASSES_ROOT, KeyPath, &hKey);
    if (ERROR_SUCCESS != lRes)
    {
            CoTaskMemFree(pGuidStr);
            return E_FAIL;
    }
    
    wchar_t *pName = L"Microsoft Server Appliance: Alert Email Consumer Provider";
    lRes = RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, wcslen(pName) * 2 + 2);
    if (ERROR_SUCCESS != lRes)
    {
            RegCloseKey (hKey);
            CoTaskMemFree(pGuidStr);
            return E_FAIL;
    }

    HKEY hSubkey;
    lRes = RegCreateKey(hKey, L"InprocServer32", &hSubkey);
    if (ERROR_SUCCESS != lRes)
    {
            RegCloseKey (hKey);
            CoTaskMemFree(pGuidStr);
            return E_FAIL;
    }

    lRes = RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, wcslen(Path) * 2 + 2);
    if (ERROR_SUCCESS != lRes)
    {
            RegCloseKey (hSubkey);
            RegCloseKey (hKey);
            CoTaskMemFree(pGuidStr);
            return E_FAIL;
    }

    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//  DllUnregisterServer
//
//  Description:
//        Standard OLE entry point for unregistering the server.
//
//  Returns:
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

extern "C"
HRESULT 
APIENTRY 
DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];

    HRESULT hr = StringFromCLSID(CLSID_AlertEmailConsumerProvider, &pGuidStr);
    if (FAILED (hr))
    {
        return (hr);
    }
    
    int cchWritten = _snwprintf(KeyPath, 255, L"CLSID\\%s", pGuidStr);
    if (cchWritten < 0)
    {
       CoTaskMemFree(pGuidStr);
       return E_FAIL;
    }
    KeyPath [255] = L'\0';

    //
    // Delete InProcServer32 subkey.
    //
    LONG lRes = RegOpenKeyW(HKEY_CLASSES_ROOT, KeyPath, &hKey);
    if ( lRes )
    {
         CoTaskMemFree(pGuidStr);
            return E_FAIL;
    }

    RegDeleteKeyW(hKey, L"InprocServer32");
    RegCloseKey(hKey);

    //
    // Delete CLSID GUID key.
    //
    lRes = RegOpenKeyW(HKEY_CLASSES_ROOT, L"CLSID", &hKey);
    if ( lRes )
    {
         CoTaskMemFree(pGuidStr);
            return E_FAIL;
    }

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\alertemail\source\alerteventconsumer\cfactory.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000 Microsoft Corporation
//
//  Module Name:
//      CDiskEventFactory.h
//
//  Description:
//      description-for-module
//
//  [Implementation Files:]
//      CDiskEventFactory.cpp
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//
//
//  class CDiskEventFactory
//
//  Description:
//      class-description
//
//  History
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

class CFactory : 
    public IClassFactory    
{
//
// Private data
//
private:

    LONG           m_cRef;
    CLSID           m_ClsId;
//
// Public data
//
public:

    //
    // Constructors & Destructors
    //

    CFactory(const CLSID & ClsId);
    ~CFactory();

    //
    // IUnknown members
    //
    STDMETHODIMP            QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG)    AddRef(void);
    STDMETHODIMP_(ULONG)    Release(void);

    //
    // IClassFactory members
    //
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP     LockServer(BOOL);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\alertemail\source\alerteventconsumer\stdafx.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999--2001 Microsoft Corporation
//
//  Module Name:
//      stdafx.h
//
//  Description:
//      Global header file.
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#undef _ATL_NO_DEBUG_CRT

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>

#include <atlbase.h>

#include <wbemidl.h>
#include <initguid.h>

#include <wbemcli.h>
#include <wbemprov.h>
#include <cdosys.h>
#include <cdosysstr.h>
#include <cdosyserr.h>
using namespace CDO;

#include <salocmgr.h>

#include <elementmgr.h>

#include <satrace.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\alertemail\source\alerteventconsumer\calertemailconsumerprovider.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999--2001 Microsoft Corporation
//
//  Module Name:
//      CAlertEmailConsumerProvider.h
//
//  Description:
//      Implement the interfaces of IWbemEventConsumerProvider and 
//      IWbemProviderInit. 
//
//  [Implementation Files:]
//      CAlertEmailConsumerProvider.cpp
//
//  History:
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//
//
//  class CAlertEmailConsumerProvider
//
//  Description:
//      Implemented as WMI event consumer provider for 
//      filtering alert event.
//
//  History
//      Xing Jin (i-xingj) 23-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

class CAlertEmailConsumerProvider :
    public IWbemEventConsumerProvider,
    public IWbemProviderInit
{

//
// Public data
//
public:

    //
    // Constructors & Destructors
    //
    CAlertEmailConsumerProvider();
    ~CAlertEmailConsumerProvider();
    
    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IWbemProviderInit members
    //
    STDMETHOD(Initialize)( 
            LPWSTR pszUser,
            LONG lFlags,
            LPWSTR pszNamespace,
            LPWSTR pszLocale,
            IWbemServices __RPC_FAR *pNamespace,
            IWbemContext __RPC_FAR *pCtx,
            IWbemProviderInitSink __RPC_FAR *pInitSink
            );

    //
    // IWbemEventConsumerProvider members
    //
    STDMETHOD(FindConsumer)(
            IWbemClassObject* pLogicalConsumer,
            IWbemUnboundObjectSink** ppConsumer
            );

//
// Private data
//
private:

    LONG                m_cRef;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\alertemail\source\alerteventconsumer\cfactory.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 2000 Microsoft Corporation
//
//  Module Name:
//      CFactory.cpp
//
//  Description:
//      description-for-module
//
//  [Header File:]
//      CFactory.h
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////


#include "stdafx.h"
#include "CFactory.h"
#include "CAlertEmailConsumerProvider.h"
#include "AlertEmailProviderGuid.h"

extern LONG g_cObj;
extern LONG g_cLock;

//////////////////////////////////////////////////////////////////////////////
//
//  CFactory::CFactory
//
//  Description:
//      Class constructor.
//
//  Arguments:
//        [in] ClsIdIn    
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

CFactory::CFactory(
    const CLSID    &    ClsIdIn 
    )
{
    m_cRef = 0;
    m_ClsId = ClsIdIn;

    InterlockedIncrement( &g_cObj );
}

//////////////////////////////////////////////////////////////////////////////
//
//  CFactory::CFactory
//
//  Description:
//      Class deconstructor.
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

CFactory::~CFactory()
{
    // nothing
    InterlockedDecrement( &g_cObj );
}

//////////////////////////////////////////////////////////////////////////////
//
//  CFactory::QueryInterface
//
//  Description:
//      An method implement of IUnkown interface.
//
//  Arguments:
//        [in]  riidIn    Identifier of the requested interface
//        [out] ppvOut    Address of output variable that receives the 
//                        interface pointer requested in iid
//
//    Returns:
//        NOERROR            if the interface is supported
//        E_NOINTERFACE    if not
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CFactory::QueryInterface(
    REFIID        riidIn, 
    LPVOID *    ppvOut 
    )
{
    *ppvOut = NULL;

    if ( ( IID_IUnknown == riidIn ) 
        || ( IID_IClassFactory==riidIn ) )
    {
        *ppvOut = this;

        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CFactory::AddRef
//
//  Description:
//      increments the reference count for an interface on an object
//
//    Returns:
//        The new reference count.
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
ULONG 
CFactory::AddRef()
{
    InterlockedIncrement( &m_cRef );
    return m_cRef;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CFactory::Release
//
//  Description:
//      decrements the reference count for an interface on an object.
//
//    Returns:
//        The new reference count.
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
ULONG 
CFactory::Release()
{
    InterlockedDecrement( &m_cRef );
    if (0 != m_cRef)
    {
        return m_cRef;
    }

    delete this;
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CFactory::CreateInstance
//
//  Description:
//      Instance creation.
//
//  Arguments:
//        [in]    riidIn        Reference to the identifier of the interface    
//        [out]    pUnkOuter    Pointer to whether object is or isn't part of 
//                            an aggregate
//                ppvObjOut    Address of output variable that receives the 
//                            interface pointer requested in riid
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CFactory::CreateInstance(
    LPUNKNOWN    pUnkOuter,
    REFIID        riidIn,
    LPVOID *    ppvObjOut
    )
{
    IUnknown* pObj = NULL;
    HRESULT  hr;

    //
    //  Defaults
    //
    *ppvObjOut = NULL;
    hr = E_OUTOFMEMORY;

    //
    // We aren't supporting aggregation.
    //
    if ( pUnkOuter )
    {
        return CLASS_E_NOAGGREGATION;
    }

    if (m_ClsId == CLSID_AlertEmailConsumerProvider)
    {
        pObj = (IWbemEventConsumerProvider *) new CAlertEmailConsumerProvider;
    }

    if ( pObj == NULL )
    {
        return hr;
    }

    //
    //  Initialize the object and verify that it can return the
    //  interface in question.
    //                                         
    hr = pObj->QueryInterface( riidIn, ppvObjOut );

    //
    // Kill the object if initial creation or Init failed.
    //
    if ( FAILED( hr ) )
    {
        delete pObj;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CFactory::LockServer
//
//  Description:
//      Call by client to keep server in memory.
//
//  Arguments:
//        [in] fLockIn    //Increments or decrements the lock count
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CFactory::LockServer(
    BOOL    fLockIn
    )
{
    if ( fLockIn )
    {
        InterlockedIncrement( &g_cLock );
    }
    else
    {
        InterlockedDecrement( &g_cLock );
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\alertemail\source\setalertemail\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\alertemail\source\setalertemail\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SetAlertEmail.rc
//
#define IDS_PROJNAME                    100
#define IDR_CONFIGALERTEMAIL            101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\alertemail\source\setalertemail\configalertemail.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ConfigAlertEmail.h
//
//  Description:
//      declare the class CConfigAlertEmail
//
//    Implement files:
//        ConfigAlertEmail.cpp        
//
//  History:
//      1. lustar.li (Guogang Li), creation date in 17-DEC-2000
//
//  Notes:
//      
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _CONFIGALERTEMAIL_H_
#define _CONFIGALERTEMAIL_H_

#include "resource.h"       // main symbols
#include "taskctx.h"
#include "comdef.h"

//
// Define the tasks supported by this COM Server
//
typedef enum 
{
    NONE_FOUND,
    RAISE_SET_ALERT_EMAIL_ALERT,
    SET_ALERT_EMAIL
} SET_ALERT_EMAIL_TASK_TYPE;

#define MAX_MAIL_ADDRESS_LENGH                256

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CConfigAlertEmail
//
//  Description:
//      The class implement the COM interface SetAlertEmail.AlertEmail.1, used
//    to config the alert email on server appliance. 
//
//  History:
//      1. lustar.li (Guogang Li), creation date in 17-DEC-2000
//--
//////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CConfigAlertEmail : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CConfigAlertEmail, &CLSID_ConfigAlertEmail>,
    public IDispatchImpl<IApplianceTask, &IID_IApplianceTask, &LIBID_SETALERTEMAILLib>
{
public:
    //
    // Constructor and Destructor
    //
    CConfigAlertEmail()
    {
    }
    ~CConfigAlertEmail()
    {
    }


DECLARE_REGISTRY_RESOURCEID(IDR_CONFIGALERTEMAIL)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CConfigAlertEmail)
    COM_INTERFACE_ENTRY(IApplianceTask)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

public:
    //
    // IApplianceTask
    //
    STDMETHOD(OnTaskExecute)(
                     /*[in]*/ IUnknown* pTaskContext
                            );

    STDMETHOD(OnTaskComplete)(
                      /*[in]*/ IUnknown* pTaskContext, 
                      /*[in]*/ LONG      lTaskResult
                             );    

private:
    SET_ALERT_EMAIL_TASK_TYPE GetMethodName(IN ITaskContext *pTaskParameter);
    
    //
    // Functions to raise the Set Chime Settings alert
    //
    STDMETHOD(RaiseSetAlertEmailAlert)(void);
    BOOL ShouldRaiseSetAlertEmailAlert(void);
    BOOL DoNotRaiseSetAlertEmailAlert(void);
    BOOL ClearSetAlertEmailAlert(void);

    //
    // Functions for setting Chime Settings
    //
    STDMETHOD(SetAlertEmailSettings)(
                                    IN ITaskContext  *pTaskContext
                                    );
    STDMETHOD(RollbackSetAlertEmailSettings)(
                                    IN ITaskContext  *pTaskContext
                                    );
    STDMETHOD(GetSetAlertEmailSettingsParameters)(
                                    IN ITaskContext  *pTaskContext, 
                                    OUT BOOL *pbEnableAlertEmail,
                                    OUT DWORD *pdwSendEmailType, 
                                    OUT _bstr_t *pbstrMailAddress
                                    );

    //
    // Data members for saving previous values
    //
    DWORD        m_bEnableAlertEmail;
    DWORD        m_dwSendEmailType;
    TCHAR        m_szReceiverMailAddress[MAX_MAIL_ADDRESS_LENGH];
};

#endif //_CONFIGALERTEMAIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\alertemail\source\setalertemail\configalertemail.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      ConfigAlertEmail.cpp
//
//  Description:
//      implement the class CConfigAlertEmail
//
//    Dependency files:
//        ConfigAlertEmail.h
//
//  History:
//      1. lustar.li (Guogang Li), creation date in 18-DEC-2000
//
//  Notes:
//      
//
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <regstr.h>
#include <comdef.h>
#include <comutil.h>
#include "SetAlertEmail.h"

#include "appliancetask.h"
#include "taskctx.h"
#include "ConfigAlertEmail.h"

#include "appsrvcs.h"
#include "alertemailmsg.h"


//
// Name and parameters for SetAlertEmail Task
//
const WCHAR    SET_ALERT_EMAIL_TASK[]            = L"SetAlertEmail";
const WCHAR    PARAM_ENABLE_ALERT_EMAIL[]        = L"EnableAlertEmail";
const WCHAR    PARAM_SEND_EMAIL_TYPE[]            = L"SendEmailType";
const WCHAR PARAM_RECEIVER_EMAIL_ADDRESS[]    = L"ReceiverEmailAddress";

//
// Alert source information
//
const WCHAR    ALERT_LOG_NAME[]=L"MSSAKitComm";
const WCHAR    ALERT_SOURCE []=L"";

//
// Registry locations
//
const WCHAR    REGKEY_SA_ALERTEMAIL[]            =
                L"Software\\Microsoft\\ServerAppliance\\AlertEmail";
const WCHAR    REGSTR_VAL_ENABLE_ALERT_EMAIL[]        = L"EnableAlertEmail";
const WCHAR    REGSTR_VAL_ALERTEMAIL_RAISEALERT[]    = L"RaiseAlert";
const WCHAR    REGSTR_VAL_SEND_EMAIL_TYPE[]        = L"SendEmailType";
const WCHAR    REGSTR_VAL_RECEIVER_EMAIL_ADDRESS[]    = L"ReceiverEmailAddress";


//
// Various strings used in the program
//
const WCHAR SZ_METHOD_NAME[]=L"MethodName";
const WCHAR SZ_APPLIANCE_INITIALIZATION_TASK []=L"ApplianceInitializationTask";

///////////////////////////////////////////////////////////////////////////////
//
// Function:  CConfigAlertEmail::OnTaskExecute
//
// Synopsis:  This function is the entry point for AppMgr.
//
// Arguments: pTaskContext - The TaskContext object contains the method name
//                                and parameters as name value pairs
//
// Returns:   HRESULT
//
///////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CConfigAlertEmail::OnTaskExecute(IUnknown *pTaskContext)
{
    HRESULT hrRet=E_FAIL;
    CComPtr<ITaskContext> pTaskParameters;
    SET_ALERT_EMAIL_TASK_TYPE saetChoice;

    ASSERT(pTaskContext);

    TRACE(("CConfigAlertEmail::OnTaskExecute"));

    try
    {
        do
        {
            if(NULL == pTaskContext)
            {
                TRACE("CConfigAlertEmail::OnTaskExecute got NULL pTaskContext");
                break;
            }
            
            hrRet = pTaskContext->QueryInterface(IID_ITaskContext,
                                              (void **)&pTaskParameters);

            if(FAILED(hrRet))
            {
                TRACE1("CConfigAlertEmail::OnTaskExecute pTaskContext QI failed \
                    for pTaskParameters, %X",hrRet);
                break;
            }
           
            // Check which Task is being executed and call that method
            
            saetChoice = GetMethodName(pTaskParameters);

            switch (saetChoice)
            {
               case SET_ALERT_EMAIL:
                hrRet = SetAlertEmailSettings(pTaskParameters);
                TRACE1(("SetAlertEmailSettings returned %X"), hrRet);
                break;
            case RAISE_SET_ALERT_EMAIL_ALERT:
                //
                // Alert will be raised on OnTaskExcute
                //
                hrRet = S_OK;
                TRACE(("RaiseSetAlertEmailAlert method called"));
                break;
            default:
                 TRACE("GetMethodName() failed to get method name in OnTaskExecute");
                 hrRet = E_INVALIDARG;
                 break;
            }
        }
        while(false);
    }
    catch(...)
    {
        TRACE("CConfigAlertEmail::OnTaskExecute caught unknown exception");
        hrRet=E_FAIL;
    }

   TRACE1("CConfigAlertEmail::OnTaskExecute returning %X", hrRet);
    return hrRet;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function:  CConfigAlertEmail::OnTaskComplete
//
// Synopsis:  
//
// Arguments: pTaskContext - The TaskContext object contains the method name
//                                and parameters as name value pairs
//
// Returns:   HRESULT
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CConfigAlertEmail::OnTaskComplete(IUnknown *pTaskContext, 
                                LONG lTaskResult)
{
    HRESULT hrRet = E_FAIL;
    CComPtr<ITaskContext> pTaskParameters;
    SET_ALERT_EMAIL_TASK_TYPE     saetChoice;


    ASSERT(pTaskContext);  
    TRACE(("CConfigAlertEmail::OnTaskComplete"));

    try
    {
        do
        {
            hrRet = pTaskContext->QueryInterface(IID_ITaskContext,
                                              (void **)&pTaskParameters);

            if (FAILED(hrRet))
            {    
                TRACE1("CConfigAlertEmail::OnTaskComplete failed in pTaskContext \
                    QI for pTaskParameters,  %X", hrRet);
                break;
            }
           
            //
            // Check which Task is being executed and call that method
            //
            saetChoice = GetMethodName(pTaskParameters);
            switch (saetChoice)
            {
               case SET_ALERT_EMAIL:
                if (lTaskResult == SA_TASK_RESULT_COMMIT)
                {
                      //
                      // Clear any existing CConfigAlertEmail alert,
                      // do not raise the alert on subsequent boots
                      //
                    ClearSetAlertEmailAlert();
                    DoNotRaiseSetAlertEmailAlert();
                    TRACE("No rollback in OnTaskComplete");
                    hrRet = S_OK;
                }
                else
                {
                    hrRet = RollbackSetAlertEmailSettings(pTaskParameters);
                    TRACE1(("RollbackSetAlertEmailSettings returned %X"), hrRet);
                }
                break;
                    
              case RAISE_SET_ALERT_EMAIL_ALERT:
                if (lTaskResult == SA_TASK_RESULT_COMMIT)
                {
                    if (TRUE == ShouldRaiseSetAlertEmailAlert())
                    {
                        hrRet = RaiseSetAlertEmailAlert();
                        if (FAILED(hrRet))
                        {
                            TRACE1(("RaiseSetAlertEmailAlert returned %X"), hrRet);
                        }
                    }
                    else
                    {
                        TRACE("No need to raise the alert email alert");
                    }
                }
                else
                {
                       //
                    // Do nothing on Commit failure
                    //
                    hrRet = S_OK;
                }
                break;
            default:
                TRACE("GetMethodName() failed to get method name in OnTaskComplete");
                hrRet = E_INVALIDARG;
                break;
            }
        }
        while(false);
    }
    catch(...)
    {
        TRACE("CConfigAlertEmail::OnTaskComplete caught unknown exception");
        hrRet=E_FAIL;
    }
    
    TRACE1("CConfigAlertEmail::OnTaskComplete returning %X", hrRet);
    return hrRet;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function:  CConfigAlertEmail::RaiseSetAlertEmailAlert
//
// Synopsis:  Raises the initial "Alert email not set up" alert during appliance 
//            initialization
//
// Arguments: None
//
// Returns:   HRESULT
//
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CConfigAlertEmail::RaiseSetAlertEmailAlert()
{
    CComPtr<IApplianceServices>    pAppSrvcs;
    DWORD             dwAlertType = SA_ALERT_TYPE_ATTENTION;
    DWORD            dwAlertId = SA_ALERTEMAIL_SETTINGS_NOTSET_ALERT_CAPTION;
    HRESULT            hrRet = E_FAIL;
    _bstr_t            bstrAlertLog(ALERT_LOG_NAME);
    _bstr_t         bstrAlertSource(ALERT_SOURCE);
    _variant_t         varReplacementStrings;
    _variant_t         varRawData;
    LONG             lCookie;
    
    TRACE("Entering RaiseSetAlertEmailAlert");

    try
    {
        do
        {
            hrRet = CoCreateInstance(CLSID_ApplianceServices,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IApplianceServices,
                                    (void**)&pAppSrvcs);
            if (FAILED(hrRet))
            {
                ASSERTMSG(FALSE, 
                    L"RaiseSetAlertEmailAlert failed at CoCreateInstance");
                TRACE1("RaiseSetAlertEmailAlert failed at CoCreateInstance, %x",
                    hrRet);
                break;
            }

            ASSERT(pAppSrvcs);

            //
            // Initialize() is called prior to using other component services.
            //Performscomponent initialization operations.
            //
            hrRet = pAppSrvcs->Initialize(); 
            if (FAILED(hrRet))
            {
                ASSERTMSG(FALSE, 
                    L"RaiseSetAlertEmailAlert failed at pAppSrvcs->Initialize");
                TRACE1("RaiseSetAlertEmailAlert failed at pAppSrvcs->Initialize, %x",
                    hrRet);
                break;
            }

            hrRet = pAppSrvcs->RaiseAlert(
                                        dwAlertType, 
                                        dwAlertId,
                                        bstrAlertLog, 
                                        bstrAlertSource, 
                                        SA_ALERT_DURATION_ETERNAL,
                                        &varReplacementStrings,    
                                        &varRawData,      
                                        &lCookie
                                        );

            if (FAILED(hrRet))
            {
                ASSERTMSG(FALSE, 
                    TEXT("RaiseSetAlertEmailAlert failed at pAppSrvcs->RaiseAlert"));
                TRACE1("RaiseSetAlertEmailAlert failed at pAppSrvcs->RaiseAlert, %x", 
                    hrRet);
                break;
            }
        }
        while(false);
    }
    catch(...)
    {
        TRACE("CConfigAlertEmail::RaiseSetAlertEmailAlert exception caught");
        hrRet=E_FAIL;
    }

    return hrRet;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function:  CConfigAlertEmail::ShouldRaiseSetAlertEmailAlert
//
// Synopsis:  Returns TRUE if the alert needs to be raised. Reads RaiseAlert 
//            regkey to determine this.
//
// Arguments: None
//
// Returns:   BOOL
//
//////////////////////////////////////////////////////////////////////////////

BOOL 
CConfigAlertEmail::ShouldRaiseSetAlertEmailAlert()
{
    LONG     lReturnValue;
    HKEY    hKey = NULL;
    DWORD    dwSize, dwType, dwRaiseAlertEmailAlert = 0;
    BOOL    bReturnCode = TRUE;

    TRACE("ShouldRaiseSetAlertEmailAlert");
    
    do
    {
        //
        // Open HKLM\Software\Microsoft\ServerAppliance\AlertEmail reg key
        //
        lReturnValue = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                    REGKEY_SA_ALERTEMAIL, 
                                    0, 
                                    KEY_READ, 
                                    &hKey);

        if (lReturnValue != ERROR_SUCCESS)
        {
            TRACE1("RegOpenKeyEx failed with %X", lReturnValue);
            bReturnCode=FALSE;
            break;
        }

        //
        // Read the RaiseAlert reg key
        //
        dwSize = sizeof(DWORD);
        lReturnValue = RegQueryValueEx(hKey,
                                        REGSTR_VAL_ALERTEMAIL_RAISEALERT,
                                        0,
                                        &dwType,
                                        (LPBYTE) &dwRaiseAlertEmailAlert,
                                        &dwSize);
        if (lReturnValue != ERROR_SUCCESS)
        {
            TRACE2("RegQueryValueEx of %ws failed with %X", 
                REGSTR_VAL_ALERTEMAIL_RAISEALERT, lReturnValue);
            bReturnCode=FALSE;
            break;
        }

        if (0 == dwRaiseAlertEmailAlert)
        {
            bReturnCode = FALSE;
        }
    }
    while(false);

    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    return bReturnCode;
}

///////////////////////////////////////////////////////////////////////////////
//
// Function:  CConfigAlertEmail::DoNotRaiseSetAlertEmailAlert
//
// Synopsis: After alert email is setup the initial "Alert email not set up"   
//        alert needs to be disabled. This function sets the RaiseAlert regkey  
//        to 0 to prevent the alert to be raised.
//
// Arguments: None
//
// Returns:   BOOL
//
///////////////////////////////////////////////////////////////////////////////

BOOL 
CConfigAlertEmail::DoNotRaiseSetAlertEmailAlert()
{
    LONG     lReturnValue;
    HKEY    hKey = NULL;
    DWORD    dwDisposition, dwRaiseAlertEmailAlert = 0;
    BOOL    bReturnCode = FALSE;

    TRACE("Entering DoNotRaiseSetAlertEmailAlert");
    

    //
    // Write Settings to registry
    //
    do
    {
        lReturnValue =  RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                        REGKEY_SA_ALERTEMAIL,
                                        0,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &hKey,
                                        &dwDisposition);
        if (lReturnValue != ERROR_SUCCESS)
        {
            TRACE1("RegCreateKeyEx failed with %X", lReturnValue);
            break;
        }

        //
        // Set RaiseAlert value to 0
        //
        dwRaiseAlertEmailAlert = 0;
        lReturnValue = RegSetValueEx(hKey,
                                    REGSTR_VAL_ALERTEMAIL_RAISEALERT,
                                    0,
                                    REG_DWORD,
                                    (LPBYTE) &dwRaiseAlertEmailAlert,
                                    sizeof(DWORD));
        if (lReturnValue != ERROR_SUCCESS)
        {
            TRACE2("RegSetValueEx of %ws failed with %X", 
                REGSTR_VAL_ALERTEMAIL_RAISEALERT, lReturnValue);
            break;
        }
        else
        {
            bReturnCode = TRUE;
        }
    }
    while(false);

    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    return bReturnCode;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function:  CConfigAlertEmail::ClearSetAlertEmailAlert
//
// Synopsis:  Clear the alert email alert
//
// Arguments: NONE
//
// Returns:   BOOL
//
//////////////////////////////////////////////////////////////////////////////

BOOL
CConfigAlertEmail::ClearSetAlertEmailAlert()
{
    CComPtr<IApplianceServices>    pAppSrvcs;
    HRESULT                        hrRet = E_FAIL;
    _bstr_t                        bstrAlertLog(ALERT_LOG_NAME);
    BOOL                        bReturnCode = FALSE;
    
    
    TRACE("ClearSetAlertEmailAlert");

    try
    {
        do
        {
            hrRet = CoCreateInstance(CLSID_ApplianceServices,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IApplianceServices,
                                    (void**)&pAppSrvcs);
            if (FAILED(hrRet))
            {
                ASSERTMSG(FALSE, 
                    L"ClearSetAlertEmailAlert failed at CoCreateInstance");
                TRACE1("ClearSetAlertEmailAlert failed at CoCreateInstance, %x",
                    hrRet);
                break;
            }

            ASSERT(pAppSrvcs);
            hrRet = pAppSrvcs->Initialize(); 
            if (FAILED(hrRet))
            {
                ASSERTMSG(FALSE, 
                    L"ClearSetAlertEmailAlert failed at pAppSrvcs->Initialize");
                TRACE1("ClearSetAlertEmailAlert failed at pAppSrvcs->Initialize, %x", 
                    hrRet);
                break;
            }

            //
            // Clear the Setup Chime Settings alert
            //
            hrRet = pAppSrvcs->ClearAlertAll(
                            SA_ALERTEMAIL_SETTINGS_NOTSET_ALERT_CAPTION,    
                            bstrAlertLog
                            );

            //
            // DISP_E_MEMBERNOTFOUND means that there were no matching alerts
            //
            if ((hrRet != DISP_E_MEMBERNOTFOUND) && (FAILED(hrRet)))
            {
                ASSERTMSG(FALSE, 
                    TEXT("ClearSetAlertEmailAlert failed at pAppSrvcs->RaiseAlert"));
                TRACE1("ClearSetAlertEmailAlert failed at pAppSrvcs->RaiseAlert, %x",
                    hrRet);
            }
            else
            {
                bReturnCode = TRUE;
            }
        }
        while(false);
    }
    catch(...)
    {
        TRACE("CConfigAlertEmail::ClearSetAlertEmailAlert caught unknown exception");
        bReturnCode=FALSE;

    }

    return bReturnCode;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function:  CConfigAlertEmail::SetAlertEmailSettings
//
// Synopsis:  Writes alert email settings passed by task context to registry
//
// Arguments: pTaskContext - The TaskContext object contains the method name
//                                and parameters as name value pairs
//
// Returns:   HRESULT
//
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CConfigAlertEmail::SetAlertEmailSettings(
                                    ITaskContext *pTaskContext
                                    )
{
    HRESULT hrRet=E_FAIL;
    LONG     lResult;
    CRegKey crKey;
    DWORD    dwDisposition;
    DWORD    dwCount=MAX_MAIL_ADDRESS_LENGH;

    BOOL    bEnableAlertEmail=0;
    DWORD    dwSendEmailType = 0;
    _bstr_t bstrReceriverEmailAddress;


    ASSERT(pTaskContext);  

    try
    {
        do
        {
            //
            // Get all parameters from the TaskContext object
            //
            hrRet = GetSetAlertEmailSettingsParameters(
                                                pTaskContext, 
                                                &bEnableAlertEmail, 
                                                &dwSendEmailType,
                                                &bstrReceriverEmailAddress
                                                );
            if (S_OK != hrRet)
            {
                break;
            }


            //
            // Save current values - this will be used to restore the settings
            // if this task needs to be rolledback
            //
            lResult = crKey.Open(
                                HKEY_LOCAL_MACHINE,
                                REGKEY_SA_ALERTEMAIL,
                                KEY_ALL_ACCESS
                                );
            if (ERROR_SUCCESS == lResult)
            {
                if (ERROR_SUCCESS != crKey.QueryValue(m_bEnableAlertEmail, 
                                                REGSTR_VAL_ENABLE_ALERT_EMAIL))
                {
                    //
                    // Could be due to bad setup - let log it and continue on
                    //
                    TRACE2("QueryValue of %ws failed in SetAlertEmailSettings, \
                        %x", REGSTR_VAL_ENABLE_ALERT_EMAIL, lResult);
                }
                if (ERROR_SUCCESS != crKey.QueryValue(m_dwSendEmailType, 
                                                REGSTR_VAL_SEND_EMAIL_TYPE))
                {
                    //
                    // Could be due to bad setup - let log it and continue on
                    //
                    TRACE2("QueryValue of %ws failed in SetChimeSettings, %x", 
                                REGSTR_VAL_SEND_EMAIL_TYPE, lResult);
                }
                if (ERROR_SUCCESS != crKey.QueryValue(m_szReceiverMailAddress, 
                                                REGSTR_VAL_RECEIVER_EMAIL_ADDRESS,
                                                &dwCount))
                {
                    //
                    // Could be due to bad setup - let log it and continue on
                    //
                    TRACE2("QueryValue of %ws failed in ReceiverMailAddress, %x", 
                                REGSTR_VAL_RECEIVER_EMAIL_ADDRESS, lResult);
                }
            }
            else
            {
                //
                // If we couldn't open the key, it probably because the key does 
                // not exist. Let's create it
                //
                lResult = crKey.Create(HKEY_LOCAL_MACHINE,
                                        REGKEY_SA_ALERTEMAIL,
                                        NULL,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_ALL_ACCESS,
                                        NULL,
                                        &dwDisposition);

                if (ERROR_SUCCESS != lResult)
                {
                    TRACE1("Create failed in CConfigAlertEmail::SetAlertEmailSettings, \
                        %x", lResult);
                    hrRet=HRESULT_FROM_WIN32(lResult);
                    break;
                }
            }


            //
            // Set the new values
            //
            lResult = crKey.SetValue(bEnableAlertEmail, REGSTR_VAL_ENABLE_ALERT_EMAIL);
            if (ERROR_SUCCESS != lResult)
            {
                TRACE2("SetValue of %ws failed, %x", REGSTR_VAL_ENABLE_ALERT_EMAIL, 
                    lResult);
                hrRet=HRESULT_FROM_WIN32(lResult);
                break;
            }

            lResult = crKey.SetValue(dwSendEmailType, REGSTR_VAL_SEND_EMAIL_TYPE);
            if (ERROR_SUCCESS != lResult)
            {
                TRACE2("SetValue of %ws failed, %x", REGSTR_VAL_SEND_EMAIL_TYPE, 
                    lResult);
                hrRet=HRESULT_FROM_WIN32(lResult);
                break;
            }

            lResult = crKey.SetValue(bstrReceriverEmailAddress, 
                                    REGSTR_VAL_RECEIVER_EMAIL_ADDRESS);
            if (ERROR_SUCCESS != lResult)
            {
                TRACE2("SetValue of %ws failed, %x", 
                    REGSTR_VAL_RECEIVER_EMAIL_ADDRESS, lResult);
                hrRet=HRESULT_FROM_WIN32(lResult);
                break;
            }
            hrRet = S_OK;

        }
        while(false);
    }
    catch(...)
    {
        TRACE("CConfigAlertEmail::SetAlertEmailSettings caught unknown exception");
        hrRet=E_FAIL;
    }

    return hrRet;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function:  CConfigAlertEmail::RollbackSetAlertEmailSettings
//
// Synopsis:  
//
// Arguments: pTaskContext - The TaskContext object contains the method name
//                            and parameters as name value pairs
//
// Returns:   HRESULT
//
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CConfigAlertEmail::RollbackSetAlertEmailSettings(
                                        ITaskContext *pTaskContext
                                        )
{
    CRegKey crKey;
    LONG     lResult;
    HRESULT hrRet = S_OK;

     ASSERT(pTaskContext); 

    try
    {
        do
        {
            lResult = crKey.Open(HKEY_LOCAL_MACHINE,
                                REGKEY_SA_ALERTEMAIL,
                                KEY_WRITE);

            if (ERROR_SUCCESS != lResult)
            {
                TRACE1("CConfigAlertEmail::RollbackSetAlertEmailSettings failed \
                    to open Chime regkey, %d",lResult);
                hrRet=HRESULT_FROM_WIN32(lResult);
                break;
            }

            //
            // Restore the old values
            //
            lResult = crKey.SetValue(m_bEnableAlertEmail, REGSTR_VAL_ENABLE_ALERT_EMAIL);
            if (ERROR_SUCCESS != lResult)
            {
                TRACE2("SetValue of %ws failed, %x", REGSTR_VAL_ENABLE_ALERT_EMAIL, 
                    lResult);
                hrRet=HRESULT_FROM_WIN32(lResult);
                break;
            }

            lResult = crKey.SetValue(m_dwSendEmailType, REGSTR_VAL_SEND_EMAIL_TYPE);
            if (ERROR_SUCCESS != lResult)
            {
                TRACE2("SetValue of %ws failed, %x", REGSTR_VAL_SEND_EMAIL_TYPE, 
                    lResult);
                hrRet=HRESULT_FROM_WIN32(lResult);
                break;
            }

            lResult = crKey.SetValue(m_szReceiverMailAddress, 
                                    REGSTR_VAL_RECEIVER_EMAIL_ADDRESS);
            if (ERROR_SUCCESS != lResult)
            {
                TRACE2("SetValue of %ws failed, %x", REGSTR_VAL_RECEIVER_EMAIL_ADDRESS, 
                    lResult);
                hrRet=HRESULT_FROM_WIN32(lResult);
                break;
            }
            hrRet = S_OK;
        }
        while(false);
    
    }
    catch(...)
   {
        TRACE("CConfigAlertEmail::RollbackSetAlertEmailSettings caught unknown \
            exception");
        hrRet=E_FAIL;
   }
       
    return hrRet;
}

//////////////////////////////////////////////////////////////////////////////
//
// Function:    CConfigAlertEmail::GetSetAlertEmailSettingsParameters
//
// Synopsis:    Extracts AlertEmail settings parameters from task context
//
// Arguments:    pTaskContext - The TaskContext object contains the method name
//                                and parameters as name value pairs
//                pbEnableAlertEmail - Enable send alert email
//                pdwSendEmailType   - Sent email type
//                pbstrMailAddress   - Receiver email address
//
// Returns:   HRESULT
//
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CConfigAlertEmail::GetSetAlertEmailSettingsParameters(
                                        ITaskContext *pTaskContext,
                                        BOOL *pbEnableAlertEmail,
                                        DWORD *pdwSendEmailType,
                                        _bstr_t *pbstrMailAddress
                                        )
{
    HRESULT hrRet = S_OK;
    _variant_t varValue;

    _bstr_t bstrParamEnableAlertEmail(PARAM_ENABLE_ALERT_EMAIL);
    _bstr_t bstrParamSendEmailType(PARAM_SEND_EMAIL_TYPE);
    _bstr_t bstrParamReceiverEmailAddress(PARAM_RECEIVER_EMAIL_ADDRESS);

    ASSERT(pTaskContext && pbEnableAlertEmail && pdwSendEmailType&&
        pbstrMailAddress);  

    //
    // Retrieve Parameters from TaskContext
    //
    try
    {
        do
        {
            //
            // Retrieve EnableAlertEmail from TaskContext
            //
            VariantClear(&varValue);
            hrRet = pTaskContext->GetParameter(bstrParamEnableAlertEmail,
                                            &varValue);

            if(FAILED(hrRet))
            {
                TRACE1("CConfigAlertEmail::GetSetAlertEmailSettingsParameters \
                    failed in GetParameters, %X",hrRet);
                break;
            }

            if (V_VT(&varValue) != VT_BSTR)
            {
                TRACE2(("Non-BSTR (%X) parameter received for %ws in \
                    GetParameter in CConfigAlertEmail:GetSetAlertEmailSettings\
                    Parameters"), V_VT(&varValue), PARAM_ENABLE_ALERT_EMAIL);
                hrRet = E_INVALIDARG;

                break;
            }
            *pbEnableAlertEmail = _ttoi(V_BSTR(&varValue));

            
            //
            // Retrieve SendEmailType from TaskContext
            //
            VariantClear(&varValue);
            hrRet = pTaskContext->GetParameter(bstrParamSendEmailType,
                                            &varValue);
            
            if(FAILED(hrRet))
            {
                TRACE1("CConfigAlertEmail::GetSetAlertEmailSettings failed \
                    in GetParameters, %X",hrRet);
                break;
            }
            
            if (V_VT(&varValue) != VT_BSTR)
            {
                TRACE2(("Non-BSTR(%X) parameter received for %ws in \
                    GetParameter in CConfigAlertEmail::GetSetAlertEmailSettings"),
                    V_VT(&varValue), PARAM_SEND_EMAIL_TYPE);
                hrRet = E_INVALIDARG;
                    break;
            }
            *pdwSendEmailType = _ttol(V_BSTR(&varValue));
            //
            // Retrieve ReceiverEmailAddress from TaskContext
            //
            VariantClear(&varValue);
            hrRet = pTaskContext->GetParameter(bstrParamReceiverEmailAddress,
                                            &varValue);
            
            if(FAILED(hrRet))
            {
                TRACE1("CConfigAlertEmail::GetSetAlertEmailSettings failed \
                    in GetParameters, %X",hrRet);
                break;
            }
           
            if (V_VT(&varValue) != VT_BSTR)
            {
                TRACE2(("Non-String(%X) parameter received for %ws in \
                    GetParameter in CConfigAlertEmail::GetSetAlertEmailSettings"),
                    V_VT(&varValue), PARAM_RECEIVER_EMAIL_ADDRESS);
                hrRet = E_INVALIDARG;
                    break;
            }
            *pbstrMailAddress = V_BSTR(&varValue);
            
            TRACE1(("EnableAlertEmail = 0x%x"),*pbEnableAlertEmail);
            TRACE1(("SendEmailType = 0x%x"), *pdwSendEmailType);
            TRACE1(("ReceiverEmailAddress = %ws"), *pbstrMailAddress);

        }
        while(false);
    }
    catch(...)
    {
        TRACE1("CConfigAlertEmail::GetSetAlertEmailSettings exception caught", 
            hrRet);
        hrRet=E_FAIL;
    }
         
    return hrRet;
}

/////////////////////////////////////////////////////////////////////////////
//
// Function:  CConfigAlertEmail::GetMethodName
//
// Synopsis:  
//
// Arguments: pTaskContext - The TaskContext object contains the method name
//                            and parameters as name value pairs
//
// Returns:   SET_CHIME_SETTINGS_TASK_TYPE
//
/////////////////////////////////////////////////////////////////////////////

SET_ALERT_EMAIL_TASK_TYPE 
CConfigAlertEmail::GetMethodName(ITaskContext *pTaskParameter)
{
    HRESULT hrRet;
    _variant_t varValue;
    _bstr_t bstrParamName(SZ_METHOD_NAME);
    SET_ALERT_EMAIL_TASK_TYPE saetChoice = NONE_FOUND;


    ASSERT(pTaskParameter);
    
    try
    {
        do
        {
            hrRet = pTaskParameter->GetParameter(bstrParamName,
                                              &varValue);

            if (FAILED(hrRet))
            {
                TRACE1(("GetParameter failed in CConfigAlertEmail::Ge    \
                        tMethodName %X"), hrRet);
            }

            if (V_VT(&varValue) != VT_BSTR)
            {
                TRACE1(("Non-strint(%X) parameter received in GetParameter \
                    in CConfigAlertEmail::GetMethodName"), V_VT(&varValue));
                hrRet = E_INVALIDARG;
                break;
            }

            if (lstrcmp(V_BSTR(&varValue), SET_ALERT_EMAIL_TASK) == 0)
            {
                saetChoice = SET_ALERT_EMAIL;
                break;
            }
            if (lstrcmp(V_BSTR(&varValue),SZ_APPLIANCE_INITIALIZATION_TASK)==0)
            {
                saetChoice = RAISE_SET_ALERT_EMAIL_ALERT;
                break;
            }
        }
        while(false);
    }
    catch(...)
    {
        TRACE("SET_ALERT_EMAIL_TASK::GetMethodName caught unknown exception");
        hrRet=E_FAIL;
    }

    if (FAILED(hrRet))
    {
        saetChoice = NONE_FOUND;
    }

    return saetChoice;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\alertemail\source\setalertemail\setalertemail.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      SetAlertEmail.cpp
//
//  Description:
//      Implementation of DLL Exports.
//
//  History:
//      1. lustar.li (Guogang Li), creation date in 18-DEC-2000
//
//  Notes:
//      
//
//////////////////////////////////////////////////////////////////////////////

//
// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SetAlertEmailps.mk in the project directory.
//

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SetAlertEmail.h"

#include "ConfigAlertEmail.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ConfigAlertEmail, CConfigAlertEmail)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\alertemail\source\setalertemail\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__CB4BAF5B_3E40_4D99_BF7D_64C0CE85A21B__INCLUDED_)
#define AFX_STDAFX_H__CB4BAF5B_3E40_4D99_BF7D_64C0CE85A21B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED
#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#ifndef ALERTEMAIL_TRACE_OFF
#include <debug.h>
#endif

#ifdef ALERTEMAIL_TRACE_OFF
#define TRACE(x)
#define TRACE1(x,y) 
#define TRACE2(x,y,z)
#define ASSERT(x) 
#define ASSERTMSG(x,y)
#define SATraceFunction(x)
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CB4BAF5B_3E40_4D99_BF7D_64C0CE85A21B__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\appletalk\saappletalk\appletalk.h ===
// AppleTalk.h : Declaration of the CAppleTalk

#ifndef __APPLETALK_H_
#define __APPLETALK_H_

#include "resource.h"       // main symbols
#include <string>
#include <vector>
#include "AtlkAdapter.h"
using namespace std;

/////////////////////////////////////////////////////////////////////////////
// CAppleTalk
class ATL_NO_VTABLE CAppleTalk : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAppleTalk, &CLSID_AppleTalk>,
    public ISupportErrorInfo,
    public IDispatchImpl<IAppleTalk, &IID_IAppleTalk, &LIBID_SAAPPLETALKLib>
{
public:
    CAppleTalk()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_APPLETALK)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAppleTalk)
    COM_INTERFACE_ENTRY(IAppleTalk)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IAppleTalk
public:
    STDMETHOD(SetAsDefaultPort)(/*[in]*/ BSTR bstrDeviceName);
    STDMETHOD(IsDefaultPort)(/*[in]*/ BSTR bstrDeviceName, /*[out,retval]*/ BOOL * bDefaultPort);
    STDMETHOD(get_Zone)(/*[in]*/ BSTR bstrDeviceName, /*[out, retval]*/ BSTR *pVal);
    STDMETHOD(put_Zone)(/*[in]*/ BSTR bstrDeviceName, /*[in]*/ BSTR newVal);
    STDMETHOD(GetZones)(/*[in]*/ BSTR bstrDeviceName, /*[out,retval]*/ VARIANT* pbstrZones);


private:
    //bool GetZonesForAdapter(const WCHAR* pwcDeviceName, vector<wstring>& rZones);
    HRESULT GetZonesForAdapter(const WCHAR* pwcDeviceName, TZoneListVector *prZones);
    wstring m_wsCurrentZone;

};

#endif //__APPLETALK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\appletalk\saappletalk\atlkadapter.cpp ===
#include "stdafx.h"
#include "AtlkAdapter.h"
#include "ndispnpevent.h"





HRESULT CAtlkAdapter::Initialize()
{
    HRESULT hr;

    hr = ValidateAdapGuid();
    
    if(hr != S_OK)
        return hr;

    hr = UpdateZoneList();
    if(hr != S_OK)
        return hr;
    
    UpdateDesiredZone();
    
    m_bstrNewDesiredZone = m_bstrDesiredZone;
    
    return hr;
}

VOID CAtlkAdapter::GetZoneList(TZoneListVector *pZonesList)
{
    *pZonesList = m_ZonesList;
}

HRESULT CAtlkAdapter::SetAsDefaultPort()
{
    HRESULT hr=S_OK;

    if(m_bDefaultPort)
        return hr;

    if( (hr = SetDefaultPortInReg()) != S_OK)
        return hr;

    m_bDefPortDirty = TRUE;

    return AtlkReconfig();
}

HRESULT CAtlkAdapter::SetDesiredZone(BSTR bstrZoneName)
{
    HRESULT hr=S_OK;
    ULONG ulIndex;

    
    for(ulIndex=0; ulIndex < m_ZonesList.size(); ulIndex++)
    {
        wstring ZoneName;
        ZoneName = m_ZonesList[ulIndex];
        if(!lstrcmpi(ZoneName.c_str(), bstrZoneName))
        {
            break;
        }
    }

    if(ulIndex == m_ZonesList.size())
        return E_INVALIDARG; //invalid zone name specified

    if(!m_bDefaultPort)
    {
        if( (hr = SetDefaultPortInReg()) != S_OK)
            return hr;

        m_bDefPortDirty = TRUE;
    }

    if(!lstrcmpi(m_bstrDesiredZone.m_str, bstrZoneName))
        return hr; //already is the desired zone just return
    
    m_bstrNewDesiredZone = bstrZoneName;
    if( (hr=SetDesiredZoneInReg()) != S_OK)
        return hr;

    m_bDesZoneDirty = TRUE;

    return AtlkReconfig();
}


//private method
//check whether this adapter is configured for appletalk
HRESULT CAtlkAdapter::ValidateAdapGuid()
{
    HKEY hAdRegKey = NULL;
    HRESULT hr = S_OK;
    DWORD dwDataSize, dwType;
    LPBYTE pDataBuffer = NULL;
    WCHAR *szAdapGuid;
    
    try
    {
        LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szATLKLinkage,0, KEY_QUERY_VALUE, &hAdRegKey);

        if(lRet != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lRet);
            throw hr;
        }

        lRet = RegQueryValueEx(hAdRegKey, c_szRoute, NULL, NULL, NULL, &dwDataSize);
        if(lRet != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lRet);
            throw hr;
        }

        pDataBuffer = new BYTE[dwDataSize];
        if(pDataBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
            throw hr;
        }

        lRet = RegQueryValueEx(hAdRegKey, c_szRoute, NULL, &dwType, pDataBuffer, &dwDataSize);
        if(lRet != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lRet);
            throw hr;
        }

        szAdapGuid = (WCHAR *) pDataBuffer;

        hr = E_INVALIDARG;
        while(szAdapGuid[0] != _TEXT('\0'))
        {
            if( wcsstr (szAdapGuid, m_bstrAdapGuid.m_str) )
            {
                hr = S_OK;
                break;
            }
            szAdapGuid = szAdapGuid + lstrlen(szAdapGuid) + 1;
        }
        
    }
    catch( ... )
    {
    }

    if ( pDataBuffer )
        delete [] pDataBuffer;

    return hr;
}


//private method
HRESULT CAtlkAdapter::UpdateZoneList()
{
    HRESULT hr = S_OK;
    WCHAR *szAppTalkAd = NULL;
    HKEY hAdRegKey = NULL;
    LPBYTE    pZoneBuffer=NULL;
    DWORD dwDataSize;
    DWORD dwType;
    WCHAR *szZone;

    
    try
    {
        //read the zonelist from registry and add to global zone list

        szAppTalkAd = new WCHAR[m_bstrAdapGuid.Length() + lstrlen(c_szATLKAdapters) + 10];
        if(szAppTalkAd == NULL )
        {
            hr = E_OUTOFMEMORY;
            throw hr;
        }

        wsprintf(szAppTalkAd, L"%s\\%s",c_szATLKAdapters,m_bstrAdapGuid.m_str);  
        
        LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szAppTalkAd,0, KEY_QUERY_VALUE, &hAdRegKey);

        if(lRet != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lRet);
            throw hr;
        }

        lRet = RegQueryValueEx(hAdRegKey, c_szZoneList, NULL, NULL, NULL, &dwDataSize);
        if(lRet != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lRet);
            throw hr;
        }

        pZoneBuffer = new BYTE[dwDataSize];
        if(pZoneBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
            throw hr;
        }

        lRet = RegQueryValueEx(hAdRegKey, c_szZoneList, NULL, &dwType, pZoneBuffer, &dwDataSize);
        if(lRet != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lRet);
            throw hr;
        }

        szZone = (WCHAR *) pZoneBuffer;

        while(szZone[0] != _TEXT('\0'))
        {
            wstring ZoneName(szZone);
            m_ZonesList.push_back(ZoneName);
            szZone = szZone + lstrlen(szZone) + 1;
        }
        

        /*if( (hr=UpdateZonesListFromSocket()) != S_OK)
            throw hr;*/

        //return value is not checked beacuse bind fails if the adapter is not the
        //default port, need to investigate
        UpdateZonesListFromSocket();

    }
    catch ( ... )
    {
    }

    if(szAppTalkAd != NULL)
        delete [] szAppTalkAd;

    if(pZoneBuffer != NULL)
        delete [] pZoneBuffer;

    if(hAdRegKey != NULL)
        RegCloseKey(hAdRegKey);

    return hr;
}



//private method
VOID CAtlkAdapter::UpdateDesiredZone()
{
    if(!GetDesiredZoneFromReg())
        m_bstrDesiredZone = m_bstrDefZone;
}
    

//private method
BOOL CAtlkAdapter::GetDesiredZoneFromReg()
{
    HKEY hParmRegKey=NULL;
    DWORD dwDataSize;
    DWORD dwType;
    LPBYTE pZoneData;
    BOOL bRetVal = FALSE;
    WCHAR *szAppTalkAd;
    HKEY hAdRegKey=NULL;
    
    try
    {
        LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szATLKParameters,0, KEY_QUERY_VALUE, &hParmRegKey);

        if(lRet != ERROR_SUCCESS)
        {
            throw bRetVal;
        }

        lRet = RegQueryValueEx(hParmRegKey, c_szDefaultPort, NULL, NULL, NULL, &dwDataSize);
        if(lRet != ERROR_SUCCESS)
        {
            throw bRetVal;
        }

        pZoneData = new BYTE[dwDataSize];
        if(pZoneData == NULL)
        {
            bRetVal = FALSE;
            throw bRetVal;
        }

        lRet = RegQueryValueExW(hParmRegKey, c_szDefaultPort, NULL, &dwType, pZoneData, &dwDataSize);
        if(lRet != ERROR_SUCCESS)
        {
            throw bRetVal;
        }

        if(!lstrcmpi(m_bstrPortName.m_str, (WCHAR*)pZoneData))
        {
            //this adapter is the default port, so also update the flag m_bDeafultPort to true
            delete [] pZoneData;
            pZoneData = NULL;

            m_bDefaultPort = TRUE;

            lRet = RegQueryValueEx(hParmRegKey, c_szDesiredZone, NULL, NULL, NULL, &dwDataSize);
            if(lRet != ERROR_SUCCESS)
            {
                throw bRetVal;
            }

            pZoneData = new BYTE[dwDataSize];

            lRet = RegQueryValueEx(hParmRegKey, c_szDesiredZone, NULL, &dwType, pZoneData, &dwDataSize);
            if(lRet == ERROR_SUCCESS)
            {
                if( ((WCHAR*)pZoneData)[0] != _TEXT('\0'))
                {
                    bRetVal = TRUE;
                    m_bstrDesiredZone =  (WCHAR*)pZoneData;
                    throw bRetVal;
                }
            }
        }

        delete [] pZoneData;
        pZoneData = NULL;


        //adapter is not the default one, so try to read the default zone from Adapters/GUID reg loc
        
        szAppTalkAd = new WCHAR[m_bstrAdapGuid.Length() + lstrlen(c_szATLKAdapters) + 10];
        wsprintf(szAppTalkAd, L"%s\\%s",c_szATLKAdapters,m_bstrAdapGuid.m_str);  
        
        lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szAppTalkAd,0, KEY_QUERY_VALUE, &hAdRegKey);

        if(lRet != ERROR_SUCCESS)
        {
            throw bRetVal;
        }

        lRet = RegQueryValueEx(hAdRegKey, c_szDefaultZone, NULL, NULL, NULL, &dwDataSize);
        if(lRet != ERROR_SUCCESS)
        {
            throw bRetVal;
        }

        pZoneData = new BYTE[dwDataSize];

        lRet = RegQueryValueEx(hAdRegKey, c_szDefaultZone, NULL, &dwType, pZoneData, &dwDataSize);
        if(lRet != ERROR_SUCCESS)
        {
            throw bRetVal;
        }

        if( ((WCHAR*)pZoneData)[0] != _TEXT('\0'))
        {
            bRetVal = TRUE;
            m_bstrDesiredZone =  (WCHAR*)pZoneData;
        }

    }
    catch(...)
    {
        
    }

    if(hParmRegKey != NULL)
        RegCloseKey(hParmRegKey);

    if(pZoneData)
        delete [] pZoneData;

    return bRetVal;

}


//private method
HRESULT CAtlkAdapter::UpdateZonesListFromSocket()
{
    SOCKADDR_AT    address;
    BOOL           fWSInitialized = FALSE;
    SOCKET         mysocket = INVALID_SOCKET;
    WSADATA        wsadata;
    DWORD          dwWsaerr;
    HRESULT hr = S_OK;
        
    try
    {

        // Create the socket/bind
        dwWsaerr = WSAStartup(0x0101, &wsadata);
        if (0 != dwWsaerr)
        {
            hr = HRESULT_FROM_WIN32(dwWsaerr);
            throw hr;
        }

        // Winsock successfully initialized
        fWSInitialized = TRUE;

        mysocket = socket(AF_APPLETALK, SOCK_DGRAM, DDPPROTO_ZIP);
        if (INVALID_SOCKET == mysocket)
        {
            dwWsaerr = ::WSAGetLastError();
            hr = HRESULT_FROM_WIN32(dwWsaerr);
            throw hr;
        }

        address.sat_family = AF_APPLETALK;
        address.sat_net = 0;
        address.sat_node = 0;
        address.sat_socket = 0;

        dwWsaerr = bind(mysocket, (struct sockaddr *)&address, sizeof(address));
        if (dwWsaerr != 0)
        {
            dwWsaerr = ::WSAGetLastError();
            hr = HRESULT_FROM_WIN32(dwWsaerr);
            throw hr;
        }

            
        // Failures from query the zone list for a given adapter can be from
        // the adapter not connected to the network, zone seeder not running, etc.
        // Because we want to process all the adapters, we ignore these errors.
        hr = UpdateDefZonesFromSocket(mysocket);
                

    }
    catch( ... )
    {
    }

    if (INVALID_SOCKET != mysocket)
    {
        closesocket(mysocket);
    }

    if (fWSInitialized)
    {
        WSACleanup();
    }

    return hr;

}


//private method
//
// Function:    CAtlkAdapter::UpdateDefZonesFromSocket
//
// Purpose:
//
// Parameters:
//
// Returns:     DWORD, ERROR_SUCCESS on success
//
#define PARM_BUF_LEN    512
#define ASTERISK_CHAR   "*"

HRESULT CAtlkAdapter::UpdateDefZonesFromSocket (  SOCKET socket )
{
    CHAR         *pZoneBuffer = NULL;
    CHAR         *pDefParmsBuffer = NULL;
    CHAR         *pZoneListStart;
    INT          BytesNeeded ;
    WCHAR        *pwDefZone = NULL;
    INT          ZoneLen = 0;
    DWORD        dwWsaerr = ERROR_SUCCESS;
    CHAR         *pDefZone = NULL;
    HRESULT hr = S_OK;

    PWSH_LOOKUP_ZONES                pGetNetZones;
    PWSH_LOOKUP_NETDEF_ON_ADAPTER    pGetNetDefaults;



    try
    {
        pZoneBuffer = new CHAR [ZONEBUFFER_LEN + sizeof(WSH_LOOKUP_ZONES)];


        pGetNetZones = (PWSH_LOOKUP_ZONES)pZoneBuffer;

        wcscpy((WCHAR *)(pGetNetZones+1), m_bstrPortName.m_str);

        BytesNeeded = ZONEBUFFER_LEN;

        dwWsaerr = getsockopt(socket, SOL_APPLETALK, SO_LOOKUP_ZONES_ON_ADAPTER,
                            (char *)pZoneBuffer, &BytesNeeded);
        if (0 != dwWsaerr)
        {
            hr = HRESULT_FROM_WIN32(dwWsaerr);
            throw hr;
        }

        pZoneListStart = pZoneBuffer + sizeof(WSH_LOOKUP_ZONES);
        if (!lstrcmpA(pZoneListStart, ASTERISK_CHAR))
        {
            // Success, wildcard zone set.
            throw hr;
        }

        dwWsaerr = UpdateDefZonesToZoneList(pZoneListStart, ((PWSH_LOOKUP_ZONES)pZoneBuffer)->NoZones);
        if (dwWsaerr != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(dwWsaerr);
            throw hr;
        }

        //
        // Get the DefaultZone/NetworkRange Information
        pDefParmsBuffer = new CHAR[PARM_BUF_LEN+sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER)];


        pGetNetDefaults = (PWSH_LOOKUP_NETDEF_ON_ADAPTER)pDefParmsBuffer;
        BytesNeeded = PARM_BUF_LEN + sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER);

        wcscpy((WCHAR*)(pGetNetDefaults+1), m_bstrPortName.m_str);
        pGetNetDefaults->NetworkRangeLowerEnd = pGetNetDefaults->NetworkRangeUpperEnd = 0;

        dwWsaerr = getsockopt(socket, SOL_APPLETALK, SO_LOOKUP_NETDEF_ON_ADAPTER,
                            (char*)pDefParmsBuffer, &BytesNeeded);
        if (0 != dwWsaerr)
        {
    #ifdef DBG
            DWORD dwErr = WSAGetLastError();
    #endif
            hr = HRESULT_FROM_WIN32(dwWsaerr);
            throw hr;
        }
    

        pDefZone  = pDefParmsBuffer + sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER);
        ZoneLen = lstrlenA(pDefZone) + 1;

        pwDefZone = new WCHAR [sizeof(WCHAR) * ZoneLen];
        //Assert(NULL != pwDefZone);

        mbstowcs(pwDefZone, pDefZone, ZoneLen);

        m_bstrDefZone = pwDefZone;
    
    }
    catch( ... )
    {
        if (pZoneBuffer != NULL)
        {
            delete [] pZoneBuffer;
        }

        if (pwDefZone != NULL)
        {
            delete [] pwDefZone;
        }

        if (pDefParmsBuffer != NULL)
        {
            delete [] pDefParmsBuffer;
        }
    }

    return hr;

}


//private method
HRESULT CAtlkAdapter::UpdateDefZonesToZoneList(CHAR * szZoneList, ULONG NumZones)
{
    INT      cbAscii = 0;
    ULONG iIndex=0;
    WCHAR *pszZone = NULL;
    HRESULT hr = S_OK;
         
    while(NumZones--)
    {
        cbAscii = lstrlenA(szZoneList) + 1;

        pszZone = new WCHAR [sizeof(WCHAR) * cbAscii];
        
        if(pszZone == NULL)
        {
            hr = E_POINTER;
            return hr;
        }
        
        mbstowcs(pszZone, szZoneList, cbAscii);

        for(iIndex=0; iIndex<m_ZonesList.size(); iIndex++)
        {
            wstring ZoneName;
            ZoneName = m_ZonesList[iIndex];
            if(!lstrcmpi(pszZone, ZoneName.c_str()))
                break;
        }

        if(iIndex >= m_ZonesList.size())
        {
            wstring ZoneName(pszZone);
            m_ZonesList.push_back(ZoneName);
        }

                
        szZoneList += cbAscii;

        delete [] pszZone;
       
    }

    return hr;
}


//private method
HRESULT CAtlkAdapter::AtlkReconfig()
{
    HRESULT hrRet = S_OK;

    ATALK_PNP_EVENT Config;
    
    ZeroMemory(&Config, sizeof(Config));

    if(m_bDefPortDirty)
    {
        // notify atlk
        Config.PnpMessage = AT_PNP_SWITCH_DEFAULT_ADAPTER;
        hrRet = HrSendNdisPnpReconfig(NDIS, c_szAtlk, NULL,
                                          &Config, sizeof(ATALK_PNP_EVENT));
        if (FAILED(hrRet))
        {
             return hrRet;
        }

    }

   
    if(m_bDesZoneDirty)
    {
        Config.PnpMessage = AT_PNP_RECONFIGURE_PARMS;


        // Now submit the reconfig notification
        hrRet = HrSendNdisPnpReconfig(NDIS, c_szAtlk, m_bstrAdapGuid.m_str,
                                              &Config, sizeof(ATALK_PNP_EVENT));
        if (FAILED(hrRet))
        {
             return hrRet;
        }
    }

   return hrRet;
}

//private method
HRESULT CAtlkAdapter::SetDefaultPortInReg()
{
    HRESULT hr=S_OK;
    HKEY hParamRegKey = NULL;

    try
    {
        LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szATLKParameters,0, KEY_SET_VALUE, &hParamRegKey);

        if(lRet != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lRet);
            throw hr;
        }

        DWORD dwSize = m_bstrPortName.Length()*sizeof(WCHAR) + 2;
        lRet = RegSetValueEx(hParamRegKey,c_szDefaultPort,0,REG_SZ,(BYTE *) m_bstrPortName.m_str, dwSize);

        if(lRet != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lRet);
            throw hr;
        }

        
    }
    catch( ... )
    {
    }

    if(hParamRegKey)
        RegCloseKey(hParamRegKey);

    return hr;
}

//private method
HRESULT CAtlkAdapter::SetDesiredZoneInReg()
{
    HRESULT hr=S_OK;
    HKEY hParamRegKey = NULL;

    try
    {
        if(m_bstrNewDesiredZone[0] == _TEXT('\0'))
            throw hr;

        LONG lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szATLKParameters,0, KEY_SET_VALUE, &hParamRegKey);

        if(lRet != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lRet);
            throw hr;
        }

        DWORD dwSize = m_bstrNewDesiredZone.Length()*sizeof(WCHAR) + 2;
        lRet = RegSetValueEx(hParamRegKey,c_szDesiredZone,0,REG_SZ,(BYTE *) m_bstrNewDesiredZone.m_str, dwSize);

        if(lRet != ERROR_SUCCESS)
        {
            hr = HRESULT_FROM_WIN32(lRet);
            throw hr;
        }


    }
    catch( ... )
    {
    }

    if(hParamRegKey)
        RegCloseKey(hParamRegKey);

    return hr;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\appletalk\saappletalk\atalkwsh.h ===
/*++

Copyright (c) 1992-1996  Microsoft Corporation

Module Name:

    wshatalk.h

Abstract:

    This is the header file for application using Windows Sockets for
    Appletalk.

Revision History:
    10 Jul 1992     Initial Version

--*/

#ifndef    _ATALKWSH_
#define    _ATALKWSH_

//
//  All protocol types should be specified in the Decimal base
//

#define DECIMAL_BASE                10

//
//  Protocol number 0 is invalid in the Appletalk case
//

#define    ATPROTO_BASE                (1000 * AF_APPLETALK)
#define    SOL_APPLETALK                (ATPROTO_BASE)

#define DDPPROTO_RTMP               (ATPROTO_BASE + 1)
#define DDPPROTO_NBP                (ATPROTO_BASE + 2)
#define DDPPROTO_ATP                (ATPROTO_BASE + 3)
#define DDPPROTO_AEP                (ATPROTO_BASE + 4)
#define DDPPROTO_RTMPRQ             (ATPROTO_BASE + 5)
#define DDPPROTO_ZIP                (ATPROTO_BASE + 6)
#define DDPPROTO_ADSP               (ATPROTO_BASE + 7)

#define DDPPROTO_MAX                (ATPROTO_BASE + 255)

//
//  Define the higher layer appletalk protocol types
//

#define ATPROTO_ADSP                (DDPPROTO_MAX + 1)
#define ATPROTO_ATP                 (DDPPROTO_MAX + 2)
#define ATPROTO_ASP                 (DDPPROTO_MAX + 3)
#define ATPROTO_PAP                 (DDPPROTO_MAX + 4)

#define SO_REGISTER_NAME             0xA000
#define SO_DEREGISTER_NAME           0xA001
#define SO_REMOVE_NAME                SO_DEREGISTER_NAME
#define SO_LOOKUP_NAME               0xA002
#define SO_CONFIRM_NAME               0xA003
#define    SO_LOOKUP_MYZONE            0xA004
#define    SO_GETMYZONE                SO_LOOKUP_MYZONE
#define SO_LOOKUP_ZONES              0xA005
#define SO_GETZONELIST                SO_LOOKUP_ZONES
#define    SO_LOOKUP_ZONES_ON_ADAPTER    0xA006
#define    SO_GETLOCALZONES            SO_LOOKUP_ZONES_ON_ADAPTER
#define    SO_LOOKUP_NETDEF_ON_ADAPTER    0xA007
#define    SO_GETNETINFO                SO_LOOKUP_NETDEF_ON_ADAPTER

//
//  PAP-specific options
//

#define SO_PAP_SET_SERVER_STATUS    0xA007
#define SO_PAP_GET_SERVER_STATUS    0xA008
#define    SO_PAP_PRIME_READ            0xA009


#define ATADDR_ANY                     0            // Dynamic socket (=0)
#define ATADDR_BROADCAST               0xFF         // Broadcast node id (=ff)

//
//    Define flags/error codes peculiar to Appletalk
//

#define    WSAEMSGPARTIAL                (WSABASEERR+100)


//    Maximum pap status size
#define    MAX_PAP_STATUS_SIZE            255
#define    MIN_PAP_READ_BUF_SIZE        4096

//    These are the unused 4 bytes returned in the PAP status packet. If ever
//    they are to be interpreted, they will be available.
#define    PAP_UNUSED_STATUS_BYTES        4


//
//  SOCKADDR_AT structure
//

typedef struct sockaddr_at
{
    USHORT    sat_family;
    USHORT    sat_net;
    UCHAR     sat_node;
    UCHAR     sat_socket;
} SOCKADDR_AT, *PSOCKADDR_AT;


//
//    ***WARNING***
//    This is defined to be the same as the ATALK ADDRESS defined in atalktdi.h
//    Change this if the other changes.
//

typedef    union
{
    struct
    {
        USHORT        Network;
        UCHAR        Node;
        UCHAR       Socket;
    };
    ULONG            Address;
} WSH_ATALK_ADDRESS, *PWSH_ATALK_ADDRESS;

//
//  Typedefs for the various options
//

//
//  ***WARNING***:
//  This should be exactly the same as NBP_NAME defined in atalktdi.h
//

#define MAX_ENTITY  32
typedef struct
{
    CHAR    ObjectNameLen;
    CHAR    ObjectName[MAX_ENTITY];
    CHAR    TypeNameLen;
    CHAR    TypeName[MAX_ENTITY];
    CHAR    ZoneNameLen;
    CHAR    ZoneName[MAX_ENTITY];
} WSH_NBP_NAME, *PWSH_NBP_NAME;

typedef struct
{
    WSH_ATALK_ADDRESS        Address;
    USHORT                    Enumerator;
    WSH_NBP_NAME            NbpName;
} WSH_NBP_TUPLE, *PWSH_NBP_TUPLE;

typedef WSH_NBP_NAME    WSH_REGISTER_NAME, *PWSH_REGISTER_NAME;
typedef WSH_NBP_NAME    WSH_DEREGISTER_NAME, *PWSH_DEREGISTER_NAME;
typedef WSH_NBP_NAME    WSH_REMOVE_NAME, *PWSH_REMOVE_NAME;

typedef struct _WSH_LOOKUP_ZONES
{
    ULONG   NoZones;

    //
    //  CHAR    Zones[] - null separated zones
    //

} WSH_LOOKUP_ZONES, *PWSH_LOOKUP_ZONES;

typedef struct _WSH_LOOKUP_NETDEF_ON_ADAPTER
{
    USHORT    NetworkRangeLowerEnd;
    USHORT    NetworkRangeUpperEnd;

    //    This will be followed by a null terminated ansi default zone.
    //    PUCHAR    DefaultZone[]

} WSH_LOOKUP_NETDEF_ON_ADAPTER , *PWSH_LOOKUP_NETDEF_ON_ADAPTER;

typedef struct _WSH_LOOKUP_NAME
{
    WSH_NBP_TUPLE    LookupTuple;
    ULONG   NoTuples;

    //
    //  Array of NoTuple WSH_NBP_TUPLEs
    //

} WSH_LOOKUP_NAME, *PWSH_LOOKUP_NAME;

typedef struct _WSH_PAP_GET_SERVER_STATUS
{
    SOCKADDR_AT            ServerAddr;
    UCHAR                Reserved[PAP_UNUSED_STATUS_BYTES];
    UCHAR                ServerStatus[MAX_PAP_STATUS_SIZE+1];

} WSH_PAP_GET_SERVER_STATUS, *PWSH_PAP_GET_SERVER_STATUS;

#endif    // _ATALKWSH_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\appletalk\saappletalk\appletalk.cpp ===
// AppleTalk.cpp : Implementation of CAppleTalk
#include "stdafx.h"
#include "SAAppleTalk.h"
#include "AppleTalk.h"
#include <comdef.h>


STDMETHODIMP CAppleTalk::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IAppleTalk
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (IsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}



STDMETHODIMP CAppleTalk::GetZones(BSTR bstrDeviceName, VARIANT *pvaVariant)
{
    HRESULT hr = S_OK;

    try 
    {
        wstring wsDeviceName(bstrDeviceName);
        TZoneListVector vwsZoneList;

        // Validate input arguemnts
        if ( !pvaVariant || wsDeviceName.length() <= 0) 
        {
            hr = E_INVALIDARG;
            throw hr;
        }



        // Get zones for this adapter
        hr = GetZonesForAdapter(wsDeviceName.c_str(), &vwsZoneList);
        if(hr != S_OK )
            throw hr;

        // Size the output array
        SAFEARRAYBOUND rgsabound[] = {vwsZoneList.size(), 0};

        // Initialize the output variable
        VariantInit(pvaVariant);

        // Create safe array of variants that will hold the output zone BSTR's
        SAFEARRAY* psa;
        psa = SafeArrayCreate(VT_VARIANT, 1, rgsabound);
        if ( !psa )
        {
            hr =  E_OUTOFMEMORY;
            throw hr;
        }


        LPVARIANT rgElems;
        SafeArrayAccessData(psa, (LPVOID*)&rgElems);

        // Add the zones to the output array
        int i;
        vector<wstring>::iterator it;
        for( i=0, it = vwsZoneList.begin(); it != vwsZoneList.end(); it++, i++ )
        {
            VARIANT vZone;

            VariantInit(&vZone);
            V_VT(&vZone) = VT_BSTR;

            V_BSTR(&vZone) = SysAllocString((*it).c_str());
            rgElems[i] = vZone;

        }

        SafeArrayUnaccessData(psa);

        V_VT(pvaVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvaVariant) = psa;


    }
    catch(_com_error& )
    {
    }
    catch(...)
    {
    }


    return hr;
}


STDMETHODIMP CAppleTalk::get_Zone(/*[in]*/ BSTR bstrDeviceName, BSTR *pVal)
{
    // TODO: Get the current zone
        
    
    CAtlkAdapter AtlkAd(bstrDeviceName);
    
    HRESULT hr=AtlkAd.Initialize();
    
    if(hr != S_OK)
        return hr;

    if(!AtlkAd.GetDesiredZone(pVal))
        hr = E_FAIL;

    return hr;
}


STDMETHODIMP CAppleTalk::put_Zone(/*[in]*/ BSTR bstrDeviceName, BSTR newVal)
{
    // TODO: Set the current zone
    m_wsCurrentZone = newVal;

    CAtlkAdapter AtlkAd(bstrDeviceName);
    
    HRESULT hr=AtlkAd.Initialize();

    if(hr != S_OK)
        return hr;

    hr = AtlkAd.SetDesiredZone(newVal);

    return hr;
}



HRESULT CAppleTalk::GetZonesForAdapter(const WCHAR* pwcDeviceName, TZoneListVector *prZones)
{
    BSTR bstrGUID;

    prZones->clear();
    
    bstrGUID = ::SysAllocString((OLECHAR *)pwcDeviceName);
    CAtlkAdapter AtlkAd(bstrGUID);
    
    HRESULT hr=AtlkAd.Initialize();

    if(hr != S_OK)
        return hr;
    
    AtlkAd.GetZoneList(prZones);

    return S_OK;
}



STDMETHODIMP CAppleTalk::IsDefaultPort(BSTR bstrDeviceName, BOOL *bDefaultPort)
{
    // TODO: Add your implementation code here
    HRESULT hr = S_OK;

    CAtlkAdapter AtlkAd(bstrDeviceName);

    
    hr=AtlkAd.Initialize();

    if(hr != S_OK)
        return hr;

    *bDefaultPort = AtlkAd.IsDefaultPort();

    return hr;
}

STDMETHODIMP CAppleTalk::SetAsDefaultPort(BSTR bstrDeviceName)
{
    // TODO: Add your implementation code here
    CAtlkAdapter AtlkAd(bstrDeviceName);
    
    HRESULT hr=AtlkAd.Initialize();
    if(hr != S_OK)
        return hr;

    hr = AtlkAd.SetAsDefaultPort();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\appletalk\saappletalk\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\appletalk\saappletalk\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SAAppleTalk.rc
//
#define IDS_PROJNAME                    100
#define IDR_APPLETALK                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\appletalk\saappletalk\atlkadapter.h ===
#ifndef _ATLKADAPTER_H
#define _ATLKADAPTER_H


#include <windows.h>
#include <atlbase.h>
#include <winsock.h>
#include <stdio.h>
#include <tchar.h>
#include <shlwapi.h>
#include <vector>
#include <string>
using namespace std;

typedef std::vector<wstring>        TZoneListVector;

#include "atalkwsh.h"

#define ZONEBUFFER_LEN      32*255

#define NDIS            0x01


//registry constants

// Registry Paths
static const WCHAR c_szAtlk[]                 = L"AppleTalk";
static const WCHAR c_szATLKParameters[]       = L"System\\CurrentControlSet\\Services\\AppleTalk\\Parameters";
static const WCHAR c_szATLKAdapters[]         = L"System\\CurrentControlSet\\Services\\AppleTalk\\Parameters\\Adapters";
static const WCHAR c_szATLKLinkage[]          = L"System\\CurrentControlSet\\Services\\AppleTalk\\Linkage";


// Values under AppleTalk\Parameters
static const WCHAR c_szDefaultPort[]          = L"DefaultPort";  // REG_SZ
static const WCHAR c_szDesiredZone[]          = L"DesiredZone";  // REG_SZ


// Values under AppleTalk\Parameters\Adapters\<AdapterId>
static const WCHAR c_szDefaultZone[]          = L"DefaultZone";         // REG_SZ
static const WCHAR c_szPortName[]             = L"PortName";            // REG_SZ
static const WCHAR c_szZoneList[]             = L"ZoneList";            // REG_MULTI_SZ

// Values under AppleTalk\Linkage
static const WCHAR c_szRoute[]                  = L"Route";                // REG_MULTI_SZ



typedef struct _ZONE_LIST
{
    WCHAR szZone[200];
}ZONE_LIST;

typedef enum
{
    AT_PNP_SWITCH_ROUTING = 0,
    AT_PNP_SWITCH_DEFAULT_ADAPTER,
    AT_PNP_RECONFIGURE_PARMS
} ATALK_PNP_MSGTYPE;

typedef struct _ATALK_PNP_EVENT
{
    ATALK_PNP_MSGTYPE   PnpMessage;
} ATALK_PNP_EVENT, *PATALK_PNP_EVENT;



class CAtlkAdapter
{
public:
    CAtlkAdapter(BSTR bstrAdapGuid)
    {
        m_bstrAdapGuid = bstrAdapGuid;

        // For each known adapter, create a device name by merging the "\\device\\"
        // prefix and the adapter's bind name.
        m_bstrPortName.Append(L"\\Device\\");
        m_bstrPortName.Append(m_bstrAdapGuid.m_str);
        m_bDefaultPort = FALSE;
        m_bNewDefPort = FALSE;

        m_bDefPortDirty = FALSE;
        m_bDesZoneDirty = FALSE;
    }

    HRESULT Initialize();
    
    VOID GetZoneList(TZoneListVector *pZonesList);
    
    BOOL GetDesiredZone(BSTR *bstrZoneName)
    {
        if(m_bstrDesiredZone && m_bstrDesiredZone.m_str[0] != _TEXT('\0'))
        {
            *bstrZoneName = SysAllocString(m_bstrDesiredZone.m_str);

        }
        else
            *bstrZoneName = SysAllocString(_TEXT(""));

        return TRUE;
    }
        

    BOOL IsDefaultPort()
    {
        return m_bDefaultPort;
    }

    HRESULT SetAsDefaultPort();
    HRESULT SetDesiredZone(BSTR bstrZoneName);

private:
    CComBSTR m_bstrAdapGuid;
    CComBSTR m_bstrPortName;
    CComBSTR m_bstrDesiredZone;
    CComBSTR m_bstrNewDesiredZone;
    CComBSTR m_bstrDefZone;
    
    TZoneListVector m_ZonesList;
    BOOL m_bDefaultPort;
    BOOL m_bNewDefPort;

    BOOL m_bDefPortDirty;
    BOOL m_bDesZoneDirty;

    

    HRESULT UpdateZoneList();
    HRESULT UpdateZonesListFromSocket();
    HRESULT UpdateDefZonesFromSocket (  SOCKET socket );
    HRESULT UpdateDefZonesToZoneList(CHAR * szZoneList, ULONG NumZones);
    
    VOID UpdateDesiredZone();
    BOOL GetDesiredZoneFromReg();
    HRESULT AtlkReconfig();

    HRESULT SetDefaultPortInReg();
    HRESULT SetDesiredZoneInReg();
    HRESULT ValidateAdapGuid();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\appletalk\saappletalk\ndispnpevent.cpp ===
#include "stdafx.h"
#include "ndispnpevent.h"


//+---------------------------------------------------------------------------
// Function:    HrSendNdisHandlePnpEvent
//
// Purpose:     Send to Ndis a HandlePnpEvent notification
//
// Parameters:
//      uiLayer - either NDIS or TDI
//      uiOperation - either BIND, RECONFIGURE, or UNBIND
//      pszUpper - a WIDE string containing the upper component name
//      pszLower - a WIDE string containing the lower component name
//            This is one of the Export names from that component
//            The values NULL and c_szEmpty are both supported
//      pmszBindList - a WIDE string containing the NULL terminiated list of strings
//            representing the bindlist, vaid only for reconfigure
//            The values NULL and c_szEmpty are both supported
//      pvData - Pointer to ndis component notification data. Content
//            determined by each component.
//      dwSizeData - Count of bytes in pvData
//
// Returns:     HRESULT  S_OK on success, HrFromLastWin32Error otherwise
//
// Notes:  Do not use this routine directly, see...
//                  HrSendNdisPnpBindOrderChange,
//                  HrSendNdisPnpReconfig
//
HRESULT
HrSendNdisHandlePnpEvent (
    UINT        uiLayer,
    UINT        uiOperation,
    PCWSTR      pszUpper,
    PCWSTR      pszLower,
    PCWSTR      pmszBindList,
    PVOID       pvData,
    DWORD       dwSizeData)
{
    UNICODE_STRING    umstrBindList;
    UNICODE_STRING    ustrLower;
    UNICODE_STRING    ustrUpper;
    UINT nRet;
    HRESULT hr = S_OK;

  /*  ASSERT(NULL != pszUpper);
    ASSERT((NDIS == uiLayer)||(TDI == uiLayer));
    ASSERT( (BIND == uiOperation) || (RECONFIGURE == uiOperation) ||
            (UNBIND == uiOperation) || (UNLOAD == uiOperation) ||
            (REMOVE_DEVICE == uiOperation));
    AssertSz( FImplies( ((NULL != pmszBindList) && (0 != lstrlenW( pmszBindList ))),
            (RECONFIGURE == uiOperation) &&
            (TDI == uiLayer) &&
            (0 == lstrlenW( pszLower ))),
            "bind order change requires a bind list, no lower, only for TDI, "
            "and with Reconfig for the operation" );*/

    // optional strings must be sent as empty strings
    //
    if (NULL == pszLower)
    {
        pszLower = c_szEmpty;
    }
    if (NULL == pmszBindList)
    {
        pmszBindList = c_szEmpty;
    }

    // build UNICDOE_STRINGs
    SetUnicodeMultiString( &umstrBindList, pmszBindList );
    SetUnicodeString( &ustrUpper, pszUpper );
    SetUnicodeString( &ustrLower, pszLower );

/*    TraceTag(ttidNetCfgPnp,
                "HrSendNdisHandlePnpEvent( layer- %d, op- %d, upper- %S, lower- %S, &bindlist- %08lx, &data- %08lx, sizedata- %d )",
                uiLayer,
                uiOperation,
                pszUpper,
                pszLower,
                pmszBindList,
                pvData,
                dwSizeData );*/

    // Now submit the notification
    nRet = NdisHandlePnPEvent( uiLayer,
            uiOperation,
            &ustrLower,
            &ustrUpper,
            &umstrBindList,
            (PVOID)pvData,
            dwSizeData );
    if (!nRet)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());

        // If the transport is not started, ERROR_FILE_NOT_FOUND is expected
        // when the NDIS layer is notified.  If the components of the TDI
        // layer aren't started, we get ERROR_GEN_FAILURE.  We need to map
        // these to one consistent error

        if ((HRESULT_FROM_WIN32(ERROR_GEN_FAILURE) == hr) && (TDI == uiLayer))
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }
    }

//    TraceError( "HrSendNdisHandlePnpEvent",
  //          HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr ? S_OK : hr );
    return hr;
}

//+---------------------------------------------------------------------------
// Function:    HrSendNdisPnpReconfig
//
// Purpose:     Send to Ndis a HandlePnpEvent reconfig notification
//
// Parameters:  uiLayer - either NDIS or TDI
//              pszUpper - a WIDE string containing the upper component name
//                         (typically a protocol)
//              pszLower - a WIDE string containing the lower component name
//                         (typically an adapter bindname) The values NULL and
//                         c_szEmpty are both supported
//              pvData - Pointer to ndis component notification data. Content
//                       determined by each component.
//              dwSizeData - Count of bytes in pvData
//
// Returns:     HRESULT  S_OK on success, HrFromLastWin32Error otherwise
//
HRESULT
HrSendNdisPnpReconfig (
    UINT        uiLayer,
    PCWSTR      pszUpper,
    PCWSTR      pszLower,
    PVOID       pvData,
    DWORD       dwSizeData)
{
    //ASSERT(NULL != pszUpper);
    //ASSERT((NDIS == uiLayer) || (TDI == uiLayer));

    HRESULT hr;
    tstring strLower;

    // If a lower component is specified, prefix with "\Device\" else
    // strLower's default of an empty string will be used.
    if (pszLower && *pszLower)
    {
        strLower = c_szDevice;
        strLower += pszLower;
    }

    hr = HrSendNdisHandlePnpEvent(
                uiLayer,
                RECONFIGURE,
                pszUpper,
                strLower.c_str(),
                c_szEmpty,
                pvData,
                dwSizeData);

//    TraceError("HrSendNdisPnpReconfig",
  //            (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) ? S_OK : hr);
    return hr;
}

//+---------------------------------------------------------------------------
// Function:    SetUnicodeString
//
// Purpose:     given a UNICODE_STRING initialize it to the given WSTR
//
// Parameters:
//      pustr - the UNICODE_STRING to initialize
//      psz - the WSTR to use to initialize the UNICODE_STRING
//
// Notes:  This differs from the RtlInitUnicodeString in that the
//      MaximumLength value contains the terminating null
//
void
SetUnicodeString (
    OUT UNICODE_STRING* pustr,
    IN PCWSTR psz )
{
    //Assert(pustr);
    //Assert(psz);

    pustr->Buffer = const_cast<PWSTR>(psz);
    pustr->Length = wcslen(psz) * sizeof(WCHAR);
    pustr->MaximumLength = pustr->Length + sizeof(WCHAR);
}

//+---------------------------------------------------------------------------
// Function:    SetUnicodeMultiString
//
// Purpose:     given a UNICODE_STRING initialize it to the given WSTR
//              multi string buffer
//
// Parameters:
//      pustr - the UNICODE_STRING to initialize
//      pmsz - the multi sz WSTR to use to initialize the UNICODE_STRING
//
void
SetUnicodeMultiString (
    OUT UNICODE_STRING* pustr,
    IN PCWSTR pmsz )
{
    //AssertSz( pustr != NULL, "Invalid Argument" );
    //AssertSz( pmsz != NULL, "Invalid Argument" );

    pustr->Buffer = const_cast<PWSTR>(pmsz);

    ULONG cb = CchOfMultiSzAndTermSafe(pustr->Buffer) * sizeof(WCHAR);
    //Assert (cb <= USHRT_MAX);
    pustr->Length = (USHORT)cb;

    pustr->MaximumLength = pustr->Length;
}


//+---------------------------------------------------------------------------
//
//  Function:   CchOfMultiSzAndTermSafe
//
//  Purpose:    Count the number of characters of a double NULL terminated
//              multi-sz, including all NULLs.
//
//  Arguments:
//      pmsz [in]   The multi-sz to count characters for.
//
//  Returns:    The count of characters.
//
//  Author:     tongl   17 June 1997
//
//  Notes:
//
ULONG
CchOfMultiSzAndTermSafe (
    IN PCWSTR pmsz)
{
    // NULL strings have zero length by definition.
    if (!pmsz)
        return 0;

    // Return the count of characters plus room for the
    // extra null terminator.
    return CchOfMultiSzSafe (pmsz) + 1;
}

//+---------------------------------------------------------------------------
//
//  Function:   CchOfMultiSzSafe
//
//  Purpose:    Count the number of characters of a double NULL terminated
//              multi-sz, including all NULLs except for the final terminating
//              NULL.
//
//  Arguments:
//      pmsz [in]   The multi-sz to count characters for.
//
//  Returns:    The count of characters.
//
//  Author:     tongl   17 June 1997
//
//  Notes:
//
ULONG
CchOfMultiSzSafe (
    IN PCWSTR pmsz)
{
    // NULL strings have zero length by definition.
    if (!pmsz)
        return 0;

    ULONG cchTotal = 0;
    ULONG cch;
    while (*pmsz)
    {
        cch = wcslen (pmsz) + 1;
        cchTotal += cch;
        pmsz += cch;
    }

    // Return the count of characters.
    return cchTotal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\appletalk\saappletalk\saappletalk.cpp ===
// SAAppleTalk.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for SAAppleTalk.idl by adding the following 
//      files to the Outputs.
//          SAAppleTalk_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f SAAppleTalkps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SAAppleTalk.h"
//#include "dlldatax.h"

#include "SAAppleTalk_i.c"
#include "AppleTalk.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_AppleTalk, CAppleTalk)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        //_Module.Init(ObjectMap, hInstance, &LIBID_SAAPPLETALKLib);
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    //return _Module.UnregisterServer(TRUE);
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\changelang\changelangmsg\makefile.inc ===
ChangeLangMsg.rc: msg00001.bin

ChangeLangMsg.h msg00001.bin: ChangeLangMsg.mc
    mc -v ChangeLangMsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\appletalk\saappletalk\ndispnpevent.h ===
#ifndef _NDISPNPEVENT_H
#define _NDISPNPEVENT_H

#include <windows.h>
#include <string>

typedef std::basic_string<TCHAR>   tstring;
//
// Definitions for Layer
//
#define NDIS            0x01
#define TDI             0x02

//
// Definitions for Operation
//
#define BIND                0x01
#define UNBIND              0x02
#define RECONFIGURE         0x03
#define UNBIND_FORCE        0x04
#define UNLOAD              0x05
#define REMOVE_DEVICE       0x06    // This is a notification that a device is about to be removed.
#define ADD_IGNORE_BINDING  0x07
#define DEL_IGNORE_BINDING  0x08

const TCHAR c_szEmpty[] = TEXT("");
const WCHAR c_szDevice[]= L"\\Device\\";

#ifndef UNICODE_STRING

typedef struct _UNICODE_STRING
{
    USHORT  Length;
    USHORT  MaximumLength;
    PWSTR   Buffer;
} UNICODE_STRING, *PUNICODE_STRING;

#endif

void
SetUnicodeString (
    OUT UNICODE_STRING* pustr,
    IN PCWSTR psz );

void
SetUnicodeMultiString (
    OUT UNICODE_STRING* pustr,
    IN PCWSTR pmsz );

ULONG
CchOfMultiSzSafe (
    IN PCWSTR pmsz);

ULONG
CchOfMultiSzAndTermSafe (
    IN PCWSTR pmsz);

extern "C" 
{
UINT __stdcall
NdisHandlePnPEvent(
    IN  UINT            Layer,
    IN  UINT            Operation,
    IN  PUNICODE_STRING LowerComponent      OPTIONAL,
    IN  PUNICODE_STRING UpperComponent      OPTIONAL,
    IN  PUNICODE_STRING BindList            OPTIONAL,
    IN  PVOID           ReConfigBuffer      OPTIONAL,
    IN  UINT            ReConfigBufferSize  OPTIONAL
    );
}

HRESULT
HrSendNdisPnpReconfig (
    UINT        uiLayer,
    PCWSTR      pszUpper,
    PCWSTR      pszLower,
    PVOID       pvData,
    DWORD       dwSizeData);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\changelang\setsystemlocale\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\changelang\setsystemlocale\csetsystemlocale.h ===
// CSetSystemLocal.h: Definition of the SetSystemLocal class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CSETSYSTEMLOCAL_H__4E8493EC_93BD_48EA_8CD5_A469C1937D7F__INCLUDED_)
#define AFX_CSETSYSTEMLOCAL_H__4E8493EC_93BD_48EA_8CD5_A469C1937D7F__INCLUDED_

#pragma once

#include "resource.h"       // main symbols

class ATL_NO_VTABLE SetSystemLocale : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<ISetSystemLocale, &IID_ISetSystemLocale, &LIBID_SETSYSTEMLOCALLib>, 
    public CComCoClass<SetSystemLocale,&CLSID_SetSystemLocale>
{
public:
    SetSystemLocale() {}
BEGIN_COM_MAP(SetSystemLocale)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISetSystemLocale)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_SetSystemLocale)

// ISetSystemLocal
public:
    STDMETHOD(SetLocale)(/*[in]*/ BSTR LocalID);
    
private:
    void SetMUILangauge(/*[in]*/ BSTR LocalID);    
};

#endif // !defined(AFX_CSETSYSTEMLOCAL_H__4E8493EC_93BD_48EA_8CD5_A469C1937D7F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\appletalk\saappletalk\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__A0AAB15A_1CA9_4F6D_9CBA_1F41C406BE65__INCLUDED_)
#define AFX_STDAFX_H__A0AAB15A_1CA9_4F6D_9CBA_1F41C406BE65__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__A0AAB15A_1CA9_4F6D_9CBA_1F41C406BE65__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\changelang\setsystemlocale\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SetSystemLocal.rc
//
#define IDS_PROJNAME                    100
#define IDS_SETSYSTEMLOCALE_DESC        101
#define IDR_SetSystemLocale             102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\changelang\setsystemlocale\csetsystemlocale.cpp ===
// CSetSystemLocal.cpp : Implementation of CSetSystemLocalApp and DLL registration.

#include "stdafx.h"
#include "SetSystemLocale.h"
#include "CSetSystemLocale.h"
#include "Aclapi.h"
#include "Userenv.h"

const ULONG CMDLINE_LENGTH = MAX_PATH+128;  

const TCHAR G_LOCALEFILEPATH [] = TEXT("\\System32\\ServerAppliance\\SetSysLoc.txt");
const TCHAR G_COMMANDLINE [] = TEXT("rundll32.exe shell32,Control_RunDLL intl.cpl,,/f:");
const TCHAR G_LOCALEFILEINFO [] = TEXT("[RegionalSettings]\nSystemLocale=%04s\nUserLocale=%04s");
const TCHAR G_QUOTATION [] =  TEXT("\"");
const TCHAR G_MUILANGPENDING_VALUENAME[] = TEXT("MUILanguagePending");
const TCHAR G_MUILANGID_VALUENAME[] = TEXT("MultiUILanguageId");
const TCHAR G_REGSUBKEY_PATH[] = TEXT("Control Panel\\Desktop");
const TCHAR G_DEFAULTUSER_KEYNAME[] = TEXT(".DEFAULT\\Control Panel\\Desktop");
const DWORD MAX_LOCALEID_LENGTH = 8;

STDMETHODIMP SetSystemLocale::SetLocale(BSTR LocalID)
{

    BOOL    bReturn;
    HANDLE  hFile;
    HANDLE  hPriToken = NULL;
    HANDLE  hCurToken = NULL;
    TCHAR   pstrLocalInfo[CMDLINE_LENGTH];
    TCHAR   pstrSystemDir[CMDLINE_LENGTH];
    TCHAR   pstrCmdLine[CMDLINE_LENGTH];
    DWORD   dwStrLeng,dwWritedLeng;
    HRESULT hr = S_OK;

    STARTUPINFO startupInfo;
    PROCESS_INFORMATION procInfo;

    SATraceString( "SetSystemLocal::SetLocal" );

    if (wcslen (LocalID) > MAX_LOCALEID_LENGTH)
    {
        SATracePrintf ("SetSystemLocale passed invalid parameter:%ws", LocalID);
        return (E_INVALIDARG);
    }
    
    SetMUILangauge( LocalID );        

    DWORD dwRetVal = ::GetWindowsDirectory( pstrSystemDir, sizeof(pstrSystemDir)/sizeof (pstrSystemDir [0]));
    if (0 == dwRetVal)
    {
        SATraceFailure ("SetSystemLocale-GetWindowsDirectory", GetLastError ());
        return (E_FAIL);
    }
        
    ::wcscat( pstrSystemDir, G_LOCALEFILEPATH );    

    do
    {

        hFile = ::CreateFile( pstrSystemDir, 
                              GENERIC_ALL | MAXIMUM_ALLOWED, 
                              FILE_SHARE_READ, 
                              NULL, 
                              CREATE_ALWAYS, 
                              FILE_ATTRIBUTE_NORMAL, 
                              NULL );
        if( hFile == INVALID_HANDLE_VALUE )
        {
            SATracePrintf( "CreateFile in SetSystemLocaleOnTaskExecute" );
            hr      = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        swprintf( pstrLocalInfo, G_LOCALEFILEINFO, LocalID, LocalID );
        dwStrLeng = wcslen( pstrLocalInfo );

        bReturn = ::WriteFile( hFile,  
                               pstrLocalInfo, 
                               sizeof(TCHAR)*dwStrLeng, 
                               &dwWritedLeng, 
                               NULL );
        if( !bReturn )
        {
            SATracePrintf( "WriteFile in SetLocaleExecute" );
            hr      = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        bReturn = OpenThreadToken( ::GetCurrentThread(),  
                                   TOKEN_DUPLICATE | TOKEN_IMPERSONATE | TOKEN_QUERY,  
                                   TRUE,
                                   &hCurToken );
        if( !bReturn )
        {
            SATracePrintf( "OpenThreadToken in SetLocaleExecute" );
            bReturn = OpenProcessToken( ::GetCurrentProcess(),
                                        TOKEN_DUPLICATE | TOKEN_IMPERSONATE,
                                        &hCurToken );
            if( !bReturn )
            {
                SATracePrintf( "OpenProcessToken in SetLocal" );
                hr      = HRESULT_FROM_WIN32( GetLastError() );
                break;
            }
        }

        bReturn =  DuplicateToken( hCurToken,                           
                                   SecurityImpersonation,        
                                   &hPriToken );
        if( !bReturn )
        {
            SATracePrintf( "DuplicateToken in SetLocExecute" );
            hr      = HRESULT_FROM_WIN32( GetLastError() );
            break;
        }

        ::wcscpy( pstrCmdLine, G_COMMANDLINE );    
        ::wcscat( pstrCmdLine, G_QUOTATION );
        ::wcscat( pstrCmdLine, pstrSystemDir );
        ::wcscat( pstrCmdLine, G_QUOTATION );

        ::ZeroMemory (&startupInfo, sizeof (STARTUPINFO));
        startupInfo.cb = sizeof( STARTUPINFO );

        //::RevertToSelf();
        bReturn = ::CreateProcess(  NULL, 
                                    pstrCmdLine, 
                                    NULL, 
                                    NULL,
                                    TRUE,
                                    CREATE_SUSPENDED | NORMAL_PRIORITY_CLASS,
                                    NULL,
                                    NULL,
                                    &startupInfo,
                                    &procInfo );
        if( !bReturn )
        {
            SATracePrintf( "CreateProcess in SetSystemLocaleOnTaskExecute" );
            hr      = HRESULT_FROM_WIN32( GetLastError() );
        }
        else
        {
             if ( !::SetThreadToken( &procInfo.hThread, hPriToken ) )
             {
                SATracePrintf("SetThreadToken Error %d", GetLastError());
                hr      = HRESULT_FROM_WIN32( GetLastError() );
                break;
             }

             if ( ( ::ResumeThread( procInfo.hThread ) ) == -1 )
             {
                SATracePrintf("ResumeThread Error %d", GetLastError());
                hr      = HRESULT_FROM_WIN32( GetLastError() );
                break;
             }

            SATracePrintf( "Success in SetSystemLocaleOnTaskExecute" );
            hr = S_OK;
        }
        
       
    }
    while( FALSE );

    if( hFile ) 
    {
        ::CloseHandle( hFile );
    }

    if( hPriToken )
    {
        ::CloseHandle(hPriToken);
    }

    if( hCurToken )
    {
        ::CloseHandle( hCurToken );
    }

    return hr;
}

void SetSystemLocale::SetMUILangauge(BSTR LocalID)
{
    HKEY hCurrentUserKey;
    HKEY hDefaultUserKey;
    
    long lCurrentUserReturn;
    long lDefaultUserReturn;

    WCHAR szLocalID[MAX_LOCALEID_LENGTH+1];
    
    DWORD dwDataSize = (wcslen( LocalID ) +1);

    if (dwDataSize < MAX_LOCALEID_LENGTH)
    {
        swprintf(szLocalID,L"%08s",LocalID);
        dwDataSize = MAX_LOCALEID_LENGTH;;
    }
    
    ::RegCloseKey(HKEY_CURRENT_USER);
    
    lCurrentUserReturn = ::RegOpenKeyEx( HKEY_CURRENT_USER,
                                         G_REGSUBKEY_PATH,
                                         0,
                                         KEY_SET_VALUE,
                                         &hCurrentUserKey );
    if( ERROR_SUCCESS == lCurrentUserReturn )
    {
        lCurrentUserReturn = ::RegSetValueEx(
                                          hCurrentUserKey,
                                          G_MUILANGPENDING_VALUENAME,
                                          0,      
                                          REG_SZ, 
                                          (BYTE*)szLocalID,
                                          dwDataSize * sizeof(TCHAR)
                                            );

        if( lCurrentUserReturn != ERROR_SUCCESS )
        {
           SATracePrintf( "Set current user pending failed" );     
        }   
        
        ::CloseHandle( hCurrentUserKey );            
    }
    else
    {
        SATracePrintf( "Create current user key failed" );
    }
    

    lDefaultUserReturn = ::RegOpenKeyEx( HKEY_USERS,
                                         G_DEFAULTUSER_KEYNAME,
                                         0,
                                         KEY_SET_VALUE,
                                         &hDefaultUserKey );
                                         
    if( ERROR_SUCCESS == lDefaultUserReturn )
    {
        lDefaultUserReturn = ::RegSetValueEx(
                                      hDefaultUserKey,
                                      G_MUILANGPENDING_VALUENAME,
                                      0,      
                                      REG_SZ, 
                                      (BYTE*)szLocalID,
                                      dwDataSize * sizeof(TCHAR)
                                       );
        if( lDefaultUserReturn != ERROR_SUCCESS )
        {
           SATracePrintf( "Set current user key failed" );     
        }   
                   
        ::CloseHandle( hDefaultUserKey );            
    }
    else
    {
        SATracePrintf( "Create default user key failed" );
    }
        
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\changelang\setsystemlocale\setsystemlocale.cpp ===
// SetSystemLocal.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SetSystemLocalps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SetSystemLocale.h"

#include "SetSystemLocale_i.c"
#include "CSetSystemLocale.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SetSystemLocale, SetSystemLocale)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\changelang\setsystemlocale\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__F19921F1_2C87_4DC0_91B6_BE21BBF30A02__INCLUDED_)
#define AFX_STDAFX_H__F19921F1_2C87_4DC0_91B6_BE21BBF30A02__INCLUDED_

#pragma once

#define STRICT

#define _ATL_APARTMENT_THREADED

#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
#include <satrace.h>

#endif // !defined(AFX_STDAFX_H__F19921F1_2C87_4DC0_91B6_BE21BBF30A02__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\help\script\makefile.inc ===
#
# This file was copied from mergedcomponents\setupinfs
#

_HTM=.

build_html_files:\
  $(O)\sahtm001.htm \
  $(O)\sahtm001.htm \
  $(O)\sahtm002.htm \
  $(O)\sahtm003.htm \
  $(O)\sahtm004.htm \
  $(O)\sahtm005.htm \
  $(O)\sahtm006.htm \
  $(O)\sahtm007.htm \
  $(O)\sahtm008.htm \
  $(O)\sahtm009.htm \
  $(O)\sahtm010.htm \
  $(O)\sahtm011.htm \
  $(O)\sahtm012.htm \
  $(O)\sahtm013.htm \
  $(O)\sahtm014.htm \
  $(O)\sahtm015.htm \
  $(O)\sahtm016.htm \
  $(O)\sahtm017.htm \
  $(O)\sahtm018.htm \
  $(O)\sahtm019.htm \
  $(O)\sahtm020.htm \
  $(O)\sahtm021.htm \
  $(O)\sahtm022.htm \
  $(O)\sahtm023.htm \
  $(O)\sahtm024.htm \
  $(O)\sahtm025.htm \
  $(O)\sahtm026.htm \
  $(O)\sahtm027.htm \
  $(O)\sahtm028.htm \
  $(O)\sahtm029.htm \
  $(O)\sahtm030.htm \
  $(O)\sahtm031.htm \
  $(O)\sahtm032.htm \
  $(O)\sahtm033.htm \
  $(O)\sahtm034.htm \
  $(O)\sahtm035.htm \
  $(O)\sahtm036.htm \
  $(O)\sahtm037.htm \
  $(O)\sahtm038.htm \
  $(O)\sahtm039.htm \
  $(O)\sahtm040.htm \
  $(O)\sahtm041.htm \
  $(O)\sahtm042.htm \
  $(O)\sahtm043.htm \
  $(O)\sahtm044.htm \
  $(O)\sahtm045.htm \
  $(O)\sahtm046.htm \
  $(O)\sahtm047.htm \
  $(O)\sahtm048.htm \
  $(O)\sahtm049.htm \
  $(O)\sahtm050.htm \
  $(O)\sahtm051.htm \
  $(O)\sahtm052.htm \
  $(O)\sahtm053.htm \
  $(O)\sahtm054.htm \
  $(O)\sahtm055.htm \
  $(O)\sahtm056.htm \
  $(O)\sahtm057.htm \
  $(O)\sahtm058.htm \
  $(O)\sahtm059.htm \
  $(O)\sahtm060.htm \
  $(O)\sahtm061.htm \
  $(O)\sahtm062.htm \
  $(O)\sahtm063.htm \
  $(O)\sahtm064.htm \
  $(O)\sahtm065.htm \
  $(O)\sahtm066.htm \
  $(O)\sahtm067.htm \
  $(O)\sahtm068.htm \
  $(O)\sahtm069.htm \
  $(O)\sahtm070.htm \
  $(O)\sahtm071.htm \
  $(O)\sahtm072.htm \
  $(O)\sahtm073.htm \
  $(O)\sahtm074.htm \
  $(O)\sahtm075.htm \
  $(O)\sahtm076.htm \
  $(O)\sahtm077.htm \
  $(O)\sahtm078.htm \
  $(O)\sahtm079.htm \
  $(O)\sahtm080.htm \
  $(O)\sahtm081.htm \
  $(O)\sahtm082.htm \
  $(O)\sahtm083.htm \
  $(O)\sahtm084.htm \
  $(O)\sahtm085.htm \
  $(O)\sahtm086.htm \
  $(O)\sahtm087.htm \
  $(O)\sahtm088.htm \
  $(O)\sahtm089.htm \
  $(O)\sahtm090.htm \
  $(O)\sahtm091.htm \
  $(O)\sahtm092.htm \
  $(O)\sahtm093.htm \
  $(O)\sahtm094.htm \
  $(O)\sahtm095.htm \
  $(O)\sahtm096.htm \
  $(O)\sahtm097.htm \
  $(O)\sahtm098.htm \
  $(O)\sahtm099.htm \
  $(O)\sahtm100.htm \
  $(O)\sahtm101.htm \
  $(O)\sahtm102.htm \
  $(O)\sahtm103.htm \
  $(O)\sahtm104.htm \
  $(O)\sahtm105.htm \
  $(O)\sahtm106.htm \
  $(O)\sahtm107.htm \
  $(O)\sahtm108.htm \
  $(O)\sahtm109.htm \
  $(O)\sahtm110.htm \
  $(O)\sahtm111.htm \
  $(O)\sahtm112.htm \
  $(O)\sahtm113.htm \
  $(O)\sahtm114.htm \
  $(O)\sahtm115.htm \
  $(O)\sahtm116.htm \
  $(O)\sahtm117.htm \
  $(O)\sahtm118.htm \
  $(O)\sahtm119.htm \
  $(O)\sahtm120.htm \
  $(O)\sahtm121.htm \
  $(O)\sahtm122.htm \
  $(O)\sahtm123.htm \
  $(O)\sahtm124.htm \
  $(O)\sahtm125.htm \
  $(O)\sahtm126.htm \
  $(O)\sahtm127.htm \
  $(O)\sahtm128.htm \
  $(O)\sahtm129.htm \
  $(O)\sahtm130.htm \
  $(O)\sahtm131.htm \
  $(O)\sahtm132.htm \
  $(O)\sahtm133.js  \
  $(O)\sahtm134.css \
  $(O)\sahtm135.css \
  $(O)\sahtm136.gif \


$(O)\sahtm001.htm: $(_HTM)\_alertemail_alert_e_mail.htm 
    copy $(_HTM)\_alertemail_alert_e_mail.htm $(O)\sahtm001.htm
    $(BINPLACE_CMD)

$(O)\sahtm002.htm: $(_HTM)\_backuprestore_backup.htm 
    copy $(_HTM)\_backuprestore_backup.htm  $(O)\sahtm002.htm
    $(BINPLACE_CMD)

$(O)\sahtm003.htm: $(_HTM)\_core_getting_started.htm 
    copy $(_HTM)\_core_getting_started.htm  $(O)\sahtm003.htm
    $(BINPLACE_CMD)

$(O)\sahtm004.htm: $(_HTM)\_core_initial_nas_server_appliance_configuration.htm 
    copy $(_HTM)\_core_initial_nas_server_appliance_configuration.htm  $(O)\sahtm004.htm
    $(BINPLACE_CMD)

$(O)\sahtm005.htm: $(_HTM)\_core_initial_web_server_appliance_configuration.htm 
    copy $(_HTM)\_core_initial_web_server_appliance_configuration.htm  $(O)\sahtm005.htm
    $(BINPLACE_CMD)

$(O)\sahtm006.htm: $(_HTM)\_core_navigation_model_of_the_web_ui.htm 
    copy $(_HTM)\_core_navigation_model_of_the_web_ui.htm  $(O)\sahtm006.htm
    $(BINPLACE_CMD)

$(O)\sahtm007.htm: $(_HTM)\_core_primary_navigation_page.htm 
    copy $(_HTM)\_core_primary_navigation_page.htm  $(O)\sahtm007.htm
    $(BINPLACE_CMD)

$(O)\sahtm008.htm: $(_HTM)\_core_server_appliance_powered_by_microsoft_windows.htm 
    copy $(_HTM)\_core_server_appliance_powered_by_microsoft_windows.htm  $(O)\sahtm008.htm
    $(BINPLACE_CMD)

$(O)\sahtm009.htm: $(_HTM)\_core_set_default_page.htm 
    copy $(_HTM)\_core_set_default_page.htm  $(O)\sahtm009.htm
    $(BINPLACE_CMD)

$(O)\sahtm010.htm: $(_HTM)\_core_status.htm 
    copy $(_HTM)\_core_status.htm  $(O)\sahtm010.htm
    $(BINPLACE_CMD)

$(O)\sahtm011.htm: $(_HTM)\_core_status_alerts.htm 
    copy $(_HTM)\_core_status_alerts.htm  $(O)\sahtm011.htm
    $(BINPLACE_CMD)

$(O)\sahtm012.htm: $(_HTM)\_core_tour.htm 
    copy $(_HTM)\_core_tour.htm  $(O)\sahtm012.htm
    $(BINPLACE_CMD)

$(O)\sahtm013.htm: $(_HTM)\_core_using_help.htm 
    copy $(_HTM)\_core_using_help.htm  $(O)\sahtm013.htm
    $(BINPLACE_CMD)

$(O)\sahtm014.htm: $(_HTM)\_datetime_date_and_time.htm 
    copy $(_HTM)\_datetime_date_and_time.htm  $(O)\sahtm014.htm
    $(BINPLACE_CMD)

$(O)\sahtm015.htm: $(_HTM)\_disksvolumes_adding_quota_entries.htm 
    copy $(_HTM)\_disksvolumes_adding_quota_entries.htm  $(O)\sahtm015.htm
    $(BINPLACE_CMD)

$(O)\sahtm016.htm: $(_HTM)\_disksvolumes_configure_disk_and_volume_properties.htm 
    copy $(_HTM)\_disksvolumes_configure_disk_and_volume_properties.htm  $(O)\sahtm016.htm
    $(BINPLACE_CMD)

$(O)\sahtm017.htm: $(_HTM)\_disksvolumes_disk_quotas.htm 
    copy $(_HTM)\_disksvolumes_disk_quotas.htm  $(O)\sahtm017.htm
    $(BINPLACE_CMD)

$(O)\sahtm018.htm: $(_HTM)\_disksvolumes_disks.htm 
    copy $(_HTM)\_disksvolumes_disks.htm  $(O)\sahtm018.htm
    $(BINPLACE_CMD)

$(O)\sahtm019.htm: $(_HTM)\_disksvolumes_modifying_quota_properties.htm 
    copy $(_HTM)\_disksvolumes_modifying_quota_properties.htm  $(O)\sahtm019.htm
    $(BINPLACE_CMD)

$(O)\sahtm020.htm: $(_HTM)\_disksvolumes_quota_entries.htm 
    copy $(_HTM)\_disksvolumes_quota_entries.htm  $(O)\sahtm020.htm
    $(BINPLACE_CMD)

$(O)\sahtm021.htm: $(_HTM)\_disksvolumes_quota_management.htm 
    copy $(_HTM)\_disksvolumes_quota_management.htm  $(O)\sahtm021.htm
    $(BINPLACE_CMD)

$(O)\sahtm022.htm: $(_HTM)\_disksvolumes_removing_quota_entries.htm 
    copy $(_HTM)\_disksvolumes_removing_quota_entries.htm  $(O)\sahtm022.htm
    $(BINPLACE_CMD)

$(O)\sahtm023.htm: $(_HTM)\_folders-shares_adding_a_folder.htm 
    copy $(_HTM)\_folders-shares_adding_a_folder.htm  $(O)\sahtm023.htm
    $(BINPLACE_CMD)

$(O)\sahtm024.htm: $(_HTM)\_folders-shares_adding_a_share.htm 
    copy $(_HTM)\_folders-shares_adding_a_share.htm  $(O)\sahtm024.htm
    $(BINPLACE_CMD)

$(O)\sahtm025.htm: $(_HTM)\_folders-shares_adding_nfs_client_groups.htm 
    copy $(_HTM)\_folders-shares_adding_nfs_client_groups.htm  $(O)\sahtm025.htm
    $(BINPLACE_CMD)

$(O)\sahtm026.htm: $(_HTM)\_folders-shares_appletalk.htm 
    copy $(_HTM)\_folders-shares_appletalk.htm  $(O)\sahtm026.htm
    $(BINPLACE_CMD)

$(O)\sahtm027.htm: $(_HTM)\_folders-shares_appletalk_sharing.htm 
    copy $(_HTM)\_folders-shares_appletalk_sharing.htm  $(O)\sahtm027.htm
    $(BINPLACE_CMD)

$(O)\sahtm028.htm: $(_HTM)\_folders-shares_configure_protocol_properties.htm 
    copy $(_HTM)\_folders-shares_configure_protocol_properties.htm  $(O)\sahtm028.htm
    $(BINPLACE_CMD)

$(O)\sahtm029.htm: $(_HTM)\_folders-shares_disable_ftp_anonymous_access.htm 
    copy $(_HTM)\_folders-shares_disable_ftp_anonymous_access.htm  $(O)\sahtm029.htm
    $(BINPLACE_CMD)

$(O)\sahtm030.htm: $(_HTM)\_folders-shares_disable_protocols.htm 
    copy $(_HTM)\_folders-shares_disable_protocols.htm  $(O)\sahtm030.htm
    $(BINPLACE_CMD)

$(O)\sahtm031.htm: $(_HTM)\_folders-shares_editing_nfs_client_groups.htm 
    copy $(_HTM)\_folders-shares_editing_nfs_client_groups.htm  $(O)\sahtm031.htm
    $(BINPLACE_CMD)

$(O)\sahtm032.htm: $(_HTM)\_folders-shares_enable_ftp_anonymous_access.htm 
    copy $(_HTM)\_folders-shares_enable_ftp_anonymous_access.htm  $(O)\sahtm032.htm
    $(BINPLACE_CMD)

$(O)\sahtm033.htm: $(_HTM)\_folders-shares_enable_protocols.htm 
    copy $(_HTM)\_folders-shares_enable_protocols.htm  $(O)\sahtm033.htm
    $(BINPLACE_CMD)

$(O)\sahtm034.htm: $(_HTM)\_folders-shares_explicit_group_maps.htm 
    copy $(_HTM)\_folders-shares_explicit_group_maps.htm  $(O)\sahtm034.htm
    $(BINPLACE_CMD)

$(O)\sahtm035.htm: $(_HTM)\_folders-shares_explicit_user_maps.htm 
    copy $(_HTM)\_folders-shares_explicit_user_maps.htm  $(O)\sahtm035.htm
    $(BINPLACE_CMD)

$(O)\sahtm036.htm: $(_HTM)\_folders-shares_ftp.htm 
    copy $(_HTM)\_folders-shares_ftp.htm  $(O)\sahtm036.htm
    $(BINPLACE_CMD)

$(O)\sahtm037.htm: $(_HTM)\_folders-shares_ftp_protocol.htm 
    copy $(_HTM)\_folders-shares_ftp_protocol.htm  $(O)\sahtm037.htm
    $(BINPLACE_CMD)

$(O)\sahtm038.htm: $(_HTM)\_folders-shares_ftp_protocol_anonymous_access.htm 
    copy $(_HTM)\_folders-shares_ftp_protocol_anonymous_access.htm  $(O)\sahtm038.htm
    $(BINPLACE_CMD)

$(O)\sahtm039.htm: $(_HTM)\_folders-shares_ftp_protocol_logging.htm 
    copy $(_HTM)\_folders-shares_ftp_protocol_logging.htm  $(O)\sahtm039.htm
    $(BINPLACE_CMD)

$(O)\sahtm040.htm: $(_HTM)\_folders-shares_ftp_protocol_messages.htm 
    copy $(_HTM)\_folders-shares_ftp_protocol_messages.htm  $(O)\sahtm040.htm
    $(BINPLACE_CMD)

$(O)\sahtm041.htm: $(_HTM)\_folders-shares_ftp_sharing.htm 
    copy $(_HTM)\_folders-shares_ftp_sharing.htm  $(O)\sahtm041.htm
    $(BINPLACE_CMD)

$(O)\sahtm042.htm: $(_HTM)\_folders-shares_general_tab_for_user_and_group_mappings.htm 
    copy $(_HTM)\_folders-shares_general_tab_for_user_and_group_mappings.htm  $(O)\sahtm042.htm
    $(BINPLACE_CMD)

$(O)\sahtm043.htm: $(_HTM)\_folders-shares_manage_folders.htm 
    copy $(_HTM)\_folders-shares_manage_folders.htm  $(O)\sahtm043.htm
    $(BINPLACE_CMD)

$(O)\sahtm044.htm: $(_HTM)\_folders-shares_manage_protocols.htm 
    copy $(_HTM)\_folders-shares_manage_protocols.htm  $(O)\sahtm044.htm
    $(BINPLACE_CMD)

$(O)\sahtm045.htm: $(_HTM)\_folders-shares_manage_shares.htm 
    copy $(_HTM)\_folders-shares_manage_shares.htm  $(O)\sahtm045.htm
    $(BINPLACE_CMD)

$(O)\sahtm046.htm: $(_HTM)\_folders-shares_modifying_folder_properties.htm 
    copy $(_HTM)\_folders-shares_modifying_folder_properties.htm  $(O)\sahtm046.htm
    $(BINPLACE_CMD)

$(O)\sahtm047.htm: $(_HTM)\_folders-shares_modifying_share_properties.htm 
    copy $(_HTM)\_folders-shares_modifying_share_properties.htm  $(O)\sahtm047.htm
    $(BINPLACE_CMD)

$(O)\sahtm048.htm: $(_HTM)\_folders-shares_navigating_among_folders.htm 
    copy $(_HTM)\_folders-shares_navigating_among_folders.htm  $(O)\sahtm048.htm
    $(BINPLACE_CMD)

$(O)\sahtm049.htm: $(_HTM)\_folders-shares_nfs.htm 
    copy $(_HTM)\_folders-shares_nfs.htm  $(O)\sahtm049.htm
    $(BINPLACE_CMD)

$(O)\sahtm050.htm: $(_HTM)\_folders-shares_nfs_client_groups.htm 
    copy $(_HTM)\_folders-shares_nfs_client_groups.htm  $(O)\sahtm050.htm
    $(BINPLACE_CMD)

$(O)\sahtm051.htm: $(_HTM)\_folders-shares_nfs_locks.htm 
    copy $(_HTM)\_folders-shares_nfs_locks.htm  $(O)\sahtm051.htm
    $(BINPLACE_CMD)

$(O)\sahtm052.htm: $(_HTM)\_folders-shares_nfs_protocol.htm 
    copy $(_HTM)\_folders-shares_nfs_protocol.htm  $(O)\sahtm052.htm
    $(BINPLACE_CMD)

$(O)\sahtm053.htm: $(_HTM)\_folders-shares_nfs_sharing.htm 
    copy $(_HTM)\_folders-shares_nfs_sharing.htm  $(O)\sahtm053.htm
    $(BINPLACE_CMD)

$(O)\sahtm054.htm: $(_HTM)\_folders-shares_opening_a_folder.htm 
    copy $(_HTM)\_folders-shares_opening_a_folder.htm  $(O)\sahtm054.htm
    $(BINPLACE_CMD)

$(O)\sahtm055.htm: $(_HTM)\_folders-shares_removing_a_folder.htm 
    copy $(_HTM)\_folders-shares_removing_a_folder.htm  $(O)\sahtm055.htm
    $(BINPLACE_CMD)

$(O)\sahtm056.htm: $(_HTM)\_folders-shares_removing_a_share.htm 
    copy $(_HTM)\_folders-shares_removing_a_share.htm  $(O)\sahtm056.htm
    $(BINPLACE_CMD)

$(O)\sahtm057.htm: $(_HTM)\_folders-shares_removing_nfs_client_groups.htm 
    copy $(_HTM)\_folders-shares_removing_nfs_client_groups.htm  $(O)\sahtm057.htm
    $(BINPLACE_CMD)

$(O)\sahtm058.htm: $(_HTM)\_folders-shares_shares.htm 
    copy $(_HTM)\_folders-shares_shares.htm  $(O)\sahtm058.htm
    $(BINPLACE_CMD)

$(O)\sahtm059.htm: $(_HTM)\_folders-shares_sharing_a_folder.htm 
    copy $(_HTM)\_folders-shares_sharing_a_folder.htm  $(O)\sahtm059.htm
    $(BINPLACE_CMD)

$(O)\sahtm060.htm: $(_HTM)\_folders-shares_simple_maps.htm 
    copy $(_HTM)\_folders-shares_simple_maps.htm  $(O)\sahtm060.htm
    $(BINPLACE_CMD)

$(O)\sahtm061.htm: $(_HTM)\_folders-shares_understanding_sharing_protocols.htm 
    copy $(_HTM)\_folders-shares_understanding_sharing_protocols.htm  $(O)\sahtm061.htm
    $(BINPLACE_CMD)

$(O)\sahtm062.htm: $(_HTM)\_folders-shares_user_and_group_mappings.htm 
    copy $(_HTM)\_folders-shares_user_and_group_mappings.htm  $(O)\sahtm062.htm
    $(BINPLACE_CMD)

$(O)\sahtm063.htm: $(_HTM)\_folders-shares_web_http_.htm 
    copy $(_HTM)\_folders-shares_web_http_.htm  $(O)\sahtm063.htm
    $(BINPLACE_CMD)

$(O)\sahtm064.htm: $(_HTM)\_folders-shares_web_http_protocol.htm 
    copy $(_HTM)\_folders-shares_web_http_protocol.htm  $(O)\sahtm064.htm
    $(BINPLACE_CMD)

$(O)\sahtm065.htm: $(_HTM)\_folders-shares_web_http_sharing.htm 
    copy $(_HTM)\_folders-shares_web_http_sharing.htm  $(O)\sahtm065.htm
    $(BINPLACE_CMD)

$(O)\sahtm066.htm: $(_HTM)\_folders-shares_windows_cifs_.htm 
    copy $(_HTM)\_folders-shares_windows_cifs_.htm  $(O)\sahtm066.htm
    $(BINPLACE_CMD)

$(O)\sahtm067.htm: $(_HTM)\_folders-shares_windows_cifs_sharing.htm 
    copy $(_HTM)\_folders-shares_windows_cifs_sharing.htm  $(O)\sahtm067.htm
    $(BINPLACE_CMD)

$(O)\sahtm068.htm: $(_HTM)\_logs_application_log.htm 
    copy $(_HTM)\_logs_application_log.htm  $(O)\sahtm068.htm
    $(BINPLACE_CMD)

$(O)\sahtm069.htm: $(_HTM)\_logs_clear_log_files.htm 
    copy $(_HTM)\_logs_clear_log_files.htm  $(O)\sahtm069.htm
    $(BINPLACE_CMD)

$(O)\sahtm070.htm: $(_HTM)\_logs_download_log_files.htm 
    copy $(_HTM)\_logs_download_log_files.htm  $(O)\sahtm070.htm
    $(BINPLACE_CMD)

$(O)\sahtm071.htm: $(_HTM)\_logs_ftp_log.htm 
    copy $(_HTM)\_logs_ftp_log.htm  $(O)\sahtm071.htm
    $(BINPLACE_CMD)

$(O)\sahtm072.htm: $(_HTM)\_logs_logs.htm 
    copy $(_HTM)\_logs_logs.htm  $(O)\sahtm072.htm
    $(BINPLACE_CMD)

$(O)\sahtm073.htm: $(_HTM)\_logs_modify_log_properties.htm 
    copy $(_HTM)\_logs_modify_log_properties.htm  $(O)\sahtm073.htm
    $(BINPLACE_CMD)

$(O)\sahtm074.htm: $(_HTM)\_logs_nfs_log.htm 
    copy $(_HTM)\_logs_nfs_log.htm  $(O)\sahtm074.htm
    $(BINPLACE_CMD)

$(O)\sahtm075.htm: $(_HTM)\_logs_security_log.htm 
    copy $(_HTM)\_logs_security_log.htm  $(O)\sahtm075.htm
    $(BINPLACE_CMD)

$(O)\sahtm076.htm: $(_HTM)\_logs_system_log.htm 
    copy $(_HTM)\_logs_system_log.htm  $(O)\sahtm076.htm
    $(BINPLACE_CMD)

$(O)\sahtm077.htm: $(_HTM)\_logs_view_log_details.htm 
    copy $(_HTM)\_logs_view_log_details.htm  $(O)\sahtm077.htm
    $(BINPLACE_CMD)

$(O)\sahtm078.htm: $(_HTM)\_logs_web__http__shares_log.htm 
    copy $(_HTM)\_logs_web__http__shares_log.htm  $(O)\sahtm078.htm
    $(BINPLACE_CMD)

$(O)\sahtm079.htm: $(_HTM)\_logs_web_administration_log.htm 
    copy $(_HTM)\_logs_web_administration_log.htm  $(O)\sahtm079.htm
    $(BINPLACE_CMD)

$(O)\sahtm080.htm: $(_HTM)\_maintenance_maintenance.htm 
    copy $(_HTM)\_maintenance_maintenance.htm  $(O)\sahtm080.htm
    $(BINPLACE_CMD)

$(O)\sahtm081.htm: $(_HTM)\_networksetup_administration_web_server.htm 
    copy $(_HTM)\_networksetup_administration_web_server.htm  $(O)\sahtm081.htm
    $(BINPLACE_CMD)

$(O)\sahtm082.htm: $(_HTM)\_networksetup_change_administrator_password.htm 
    copy $(_HTM)\_networksetup_change_administrator_password.htm  $(O)\sahtm082.htm
    $(BINPLACE_CMD)

$(O)\sahtm083.htm: $(_HTM)\_networksetup_dns_configuration.htm 
    copy $(_HTM)\_networksetup_dns_configuration.htm  $(O)\sahtm083.htm
    $(BINPLACE_CMD)

$(O)\sahtm084.htm: $(_HTM)\_networksetup_dns_name_resolution.htm 
    copy $(_HTM)\_networksetup_dns_name_resolution.htm  $(O)\sahtm084.htm
    $(BINPLACE_CMD)

$(O)\sahtm085.htm: $(_HTM)\_networksetup_dns_suffixes.htm 
    copy $(_HTM)\_networksetup_dns_suffixes.htm  $(O)\sahtm085.htm
    $(BINPLACE_CMD)

$(O)\sahtm086.htm: $(_HTM)\_networksetup_domain.htm 
    copy $(_HTM)\_networksetup_domain.htm  $(O)\sahtm086.htm
    $(BINPLACE_CMD)

$(O)\sahtm087.htm: $(_HTM)\_networksetup_global_network_settings.htm 
    copy $(_HTM)\_networksetup_global_network_settings.htm  $(O)\sahtm087.htm
    $(BINPLACE_CMD)

$(O)\sahtm088.htm: $(_HTM)\_networksetup_identification.htm 
    copy $(_HTM)\_networksetup_identification.htm  $(O)\sahtm088.htm
    $(BINPLACE_CMD)

$(O)\sahtm089.htm: $(_HTM)\_networksetup_interfaces__network_adapters.htm 
    copy $(_HTM)\_networksetup_interfaces__network_adapters.htm  $(O)\sahtm089.htm
    $(BINPLACE_CMD)

$(O)\sahtm090.htm: $(_HTM)\_networksetup_ip_address_configuration.htm 
    copy $(_HTM)\_networksetup_ip_address_configuration.htm  $(O)\sahtm090.htm
    $(BINPLACE_CMD)

$(O)\sahtm091.htm: $(_HTM)\_networksetup_netbios_lmhosts_file.htm 
    copy $(_HTM)\_networksetup_netbios_lmhosts_file.htm  $(O)\sahtm091.htm
    $(BINPLACE_CMD)

$(O)\sahtm092.htm: $(_HTM)\_networksetup_network.htm 
    copy $(_HTM)\_networksetup_network.htm  $(O)\sahtm092.htm
    $(BINPLACE_CMD)

$(O)\sahtm093.htm: $(_HTM)\_networksetup_rename_connection.htm 
    copy $(_HTM)\_networksetup_rename_connection.htm  $(O)\sahtm093.htm
    $(BINPLACE_CMD)

$(O)\sahtm094.htm: $(_HTM)\_networksetup_server_appliance_name.htm 
    copy $(_HTM)\_networksetup_server_appliance_name.htm  $(O)\sahtm094.htm
    $(BINPLACE_CMD)

$(O)\sahtm095.htm: $(_HTM)\_networksetup_tcpip_hosts.htm 
    copy $(_HTM)\_networksetup_tcpip_hosts.htm  $(O)\sahtm095.htm
    $(BINPLACE_CMD)

$(O)\sahtm096.htm: $(_HTM)\_networksetup_telnet_administration_configuration.htm 
    copy $(_HTM)\_networksetup_telnet_administration_configuration.htm  $(O)\sahtm096.htm
    $(BINPLACE_CMD)

$(O)\sahtm097.htm: $(_HTM)\_networksetup_wins_configuration.htm 
    copy $(_HTM)\_networksetup_wins_configuration.htm  $(O)\sahtm097.htm
    $(BINPLACE_CMD)

$(O)\sahtm098.htm: $(_HTM)\_networksetup_workgroup.htm 
    copy $(_HTM)\_networksetup_workgroup.htm  $(O)\sahtm098.htm
    $(BINPLACE_CMD)

$(O)\sahtm099.htm: $(_HTM)\_remotedesktop_terminal_services.htm 
    copy $(_HTM)\_remotedesktop_terminal_services.htm  $(O)\sahtm099.htm
    $(BINPLACE_CMD)

$(O)\sahtm100.htm: $(_HTM)\_sak_no_topic_available.htm 
    copy $(_HTM)\_sak_no_topic_available.htm  $(O)\sahtm100.htm
    $(BINPLACE_CMD)

$(O)\sahtm101.htm: $(_HTM)\_setlanguage_set_language.htm 
    copy $(_HTM)\_setlanguage_set_language.htm  $(O)\sahtm101.htm
    $(BINPLACE_CMD)

$(O)\sahtm102.htm: $(_HTM)\_shutdown_shutdown_appliance.htm 
    copy $(_HTM)\_shutdown_shutdown_appliance.htm  $(O)\sahtm102.htm
    $(BINPLACE_CMD)

$(O)\sahtm103.htm: $(_HTM)\_swupdate_Software_Update.htm 
    copy $(_HTM)\_swupdate_Software_Update.htm  $(O)\sahtm103.htm
    $(BINPLACE_CMD)

$(O)\sahtm104.htm: $(_HTM)\_usersgroups_adding_a_group_account.htm 
    copy $(_HTM)\_usersgroups_adding_a_group_account.htm  $(O)\sahtm104.htm
    $(BINPLACE_CMD)

$(O)\sahtm105.htm: $(_HTM)\_usersgroups_adding_a_user_account.htm 
    copy $(_HTM)\_usersgroups_adding_a_user_account.htm  $(O)\sahtm105.htm
    $(BINPLACE_CMD)

$(O)\sahtm106.htm: $(_HTM)\_usersgroups_enable_guest_account.htm 
    copy $(_HTM)\_usersgroups_enable_guest_account.htm  $(O)\sahtm106.htm
    $(BINPLACE_CMD)

$(O)\sahtm107.htm: $(_HTM)\_usersgroups_manage_local_groups.htm 
    copy $(_HTM)\_usersgroups_manage_local_groups.htm  $(O)\sahtm107.htm
    $(BINPLACE_CMD)

$(O)\sahtm108.htm: $(_HTM)\_usersgroups_manage_local_users.htm 
    copy $(_HTM)\_usersgroups_manage_local_users.htm  $(O)\sahtm108.htm
    $(BINPLACE_CMD)

$(O)\sahtm109.htm: $(_HTM)\_usersgroups_modifying_group_properties.htm 
    copy $(_HTM)\_usersgroups_modifying_group_properties.htm  $(O)\sahtm109.htm
    $(BINPLACE_CMD)

$(O)\sahtm110.htm: $(_HTM)\_usersgroups_modifying_user_properties.htm 
    copy $(_HTM)\_usersgroups_modifying_user_properties.htm  $(O)\sahtm110.htm
    $(BINPLACE_CMD)

$(O)\sahtm111.htm: $(_HTM)\_usersgroups_removing_a_group_account.htm 
    copy $(_HTM)\_usersgroups_removing_a_group_account.htm  $(O)\sahtm111.htm
    $(BINPLACE_CMD)

$(O)\sahtm112.htm: $(_HTM)\_usersgroups_removing_a_user_account.htm 
    copy $(_HTM)\_usersgroups_removing_a_user_account.htm  $(O)\sahtm112.htm
    $(BINPLACE_CMD)

$(O)\sahtm113.htm: $(_HTM)\_usersgroups_setting_a_user_password.htm 
    copy $(_HTM)\_usersgroups_setting_a_user_password.htm  $(O)\sahtm113.htm
    $(BINPLACE_CMD)

$(O)\sahtm114.htm: $(_HTM)\_usersgroups_users.htm 
    copy $(_HTM)\_usersgroups_users.htm  $(O)\sahtm114.htm
    $(BINPLACE_CMD)

$(O)\sahtm115.htm: $(_HTM)\_web_application_settings.htm 
    copy $(_HTM)\_web_application_settings.htm  $(O)\sahtm115.htm
    $(BINPLACE_CMD)

$(O)\sahtm116.htm: $(_HTM)\_web_create_site.htm 
    copy $(_HTM)\_web_create_site.htm  $(O)\sahtm116.htm
    $(BINPLACE_CMD)

$(O)\sahtm117.htm: $(_HTM)\_web_delete_site.htm 
    copy $(_HTM)\_web_delete_site.htm  $(O)\sahtm117.htm
    $(BINPLACE_CMD)

$(O)\sahtm118.htm: $(_HTM)\_web_ftp_log_settings.htm 
    copy $(_HTM)\_web_ftp_log_settings.htm  $(O)\sahtm118.htm
    $(BINPLACE_CMD)

$(O)\sahtm119.htm: $(_HTM)\_web_ftp_master_settings.htm 
    copy $(_HTM)\_web_ftp_master_settings.htm  $(O)\sahtm119.htm
    $(BINPLACE_CMD)

$(O)\sahtm120.htm: $(_HTM)\_web_ftp_messages.htm 
    copy $(_HTM)\_web_ftp_messages.htm  $(O)\sahtm120.htm
    $(BINPLACE_CMD)

$(O)\sahtm121.htm: $(_HTM)\_web_general_settings.htm 
    copy $(_HTM)\_web_general_settings.htm  $(O)\sahtm121.htm
    $(BINPLACE_CMD)

$(O)\sahtm122.htm: $(_HTM)\_web_host_headers.htm 
    copy $(_HTM)\_web_host_headers.htm  $(O)\sahtm122.htm
    $(BINPLACE_CMD)

$(O)\sahtm123.htm: $(_HTM)\_web_modify_site_settings.htm 
    copy $(_HTM)\_web_modify_site_settings.htm  $(O)\sahtm123.htm
    $(BINPLACE_CMD)

$(O)\sahtm124.htm: $(_HTM)\_web_pause.htm 
    copy $(_HTM)\_web_pause.htm  $(O)\sahtm124.htm
    $(BINPLACE_CMD)

$(O)\sahtm125.htm: $(_HTM)\_web_site_identities.htm 
    copy $(_HTM)\_web_site_identities.htm  $(O)\sahtm125.htm
    $(BINPLACE_CMD)

$(O)\sahtm126.htm: $(_HTM)\_web_start.htm 
    copy $(_HTM)\_web_start.htm  $(O)\sahtm126.htm
    $(BINPLACE_CMD)

$(O)\sahtm127.htm: $(_HTM)\_web_stop.htm 
    copy $(_HTM)\_web_stop.htm  $(O)\sahtm127.htm
    $(BINPLACE_CMD)

$(O)\sahtm128.htm: $(_HTM)\_web_web_execute_permissions.htm 
    copy $(_HTM)\_web_web_execute_permissions.htm  $(O)\sahtm128.htm
    $(BINPLACE_CMD)

$(O)\sahtm129.htm: $(_HTM)\_web_web_log_settings.htm 
    copy $(_HTM)\_web_web_log_settings.htm  $(O)\sahtm129.htm
    $(BINPLACE_CMD)

$(O)\sahtm130.htm: $(_HTM)\_web_web_master_settings.htm 
    copy $(_HTM)\_web_web_master_settings.htm  $(O)\sahtm130.htm
    $(BINPLACE_CMD)

$(O)\sahtm131.htm: $(_HTM)\_web_web_server.htm 
    copy $(_HTM)\_web_web_server.htm  $(O)\sahtm131.htm
    $(BINPLACE_CMD)

$(O)\sahtm132.htm: $(_HTM)\_web_web_site_configuration.htm 
    copy $(_HTM)\_web_web_site_configuration.htm  $(O)\sahtm132.htm
    $(BINPLACE_CMD)

$(O)\sahtm133.js: $(_HTM)\linkcss.js 
    copy $(_HTM)\linkcss.js  $(O)\sahtm133.js
    $(BINPLACE_CMD)

$(O)\sahtm134.css: $(_HTM)\nas_msie.css 
    copy $(_HTM)\nas_msie.css  $(O)\sahtm134.css
    $(BINPLACE_CMD)

$(O)\sahtm135.css: $(_HTM)\nas_nscp.css 
    copy $(_HTM)\nas_nscp.css  $(O)\sahtm135.css
    $(BINPLACE_CMD)

$(O)\sahtm136.gif: $(_HTM)\navbar.gif 
    copy $(_HTM)\navbar.gif  $(O)\sahtm136.gif
    $(BINPLACE_CMD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\adminacl.h ===
#ifndef _adminacl_h_
#define _adminacl_h_


class CAdminACL
{
private:

    IADs* m_pADs;
    IADsSecurityDescriptor* m_pSD;
    IADsAccessControlList* m_pDACL;

public:

    CAdminACL();
    ~CAdminACL();

    HRESULT GetObjectAsync(
        IWbemClassObject* pObj,
        ParsedObjectPath* pParsedObject,
        WMI_CLASS* pWMIClass
        ); 

    HRESULT PutObjectAsync(
        IWbemClassObject* pObj,
        ParsedObjectPath* pParsedObject,
        WMI_CLASS* pWMIClass
        );

    HRESULT DeleteObjectAsync(ParsedObjectPath* pParsedObject);

    HRESULT OpenSD(_bstr_t bstrAdsPath);
    
    void CloseSD();

    HRESULT GetACEEnum(IEnumVARIANT** pEnum);

private:

    HRESULT SetSD();

    HRESULT GetAdsPath(_bstr_t& bstrAdsPath);
    
    HRESULT PingAdminACL(IWbemClassObject* pObj);
    
    HRESULT SetAdminACL(
        IWbemClassObject* pObj
        );

    HRESULT PingACE(
        IWbemClassObject* pObj,
        IADsAccessControlEntry* pACE
        );

    HRESULT GetACE(
        IWbemClassObject* pObj,
        _bstr_t& bstrTrustee
        );

    void GetTrustee(
        IWbemClassObject* pObj,
        ParsedObjectPath* pPath,    
        _bstr_t&          bstrTrustee 
        );

    HRESULT AddACE(
        IWbemClassObject* pObj,
        _bstr_t& bstrTrustee
        );

    HRESULT NewACE(
        IWbemClassObject* pObj,
        _bstr_t& bstrTrustee,
        IADsAccessControlEntry** ppACE
        );

    HRESULT RemoveACE(_bstr_t& bstrTrustee);

    HRESULT SetDataOfACE(
        IWbemClassObject* pObj,
        IADsAccessControlEntry* pACE
        );

    HRESULT UpdateACE(
        IWbemClassObject* pObj,
        _bstr_t& bstrTrustee,
        BOOL& fAceExisted
        );
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\certmap.h ===
#if !defined( _CERT_INCLUDED )
#define _CERT_INCLUDED


class CCertMapperMethod
{
#define IISMAPPER_LOCATE_BY_CERT    1
#define IISMAPPER_LOCATE_BY_NAME    2
#define IISMAPPER_LOCATE_BY_ACCT    3
#define IISMAPPER_LOCATE_BY_INDEX   4

private:

    IMSAdminBase*       m_pIABase;   //interface pointer
    METADATA_HANDLE     m_hmd;
    LPWSTR m_pszMetabasePath;

    HRESULT Init(LPCWSTR);        
    HRESULT Locate(LONG, VARIANT, LPWSTR);
    HRESULT SetString(LONG, VARIANT, BSTR, DWORD);       
    HRESULT SetBSTR(BSTR*, DWORD, LPBYTE);
    HRESULT SetVariantAsByteArray(VARIANT*, DWORD, LPBYTE);
    HRESULT SetVariantAsBSTR(VARIANT*, DWORD, LPBYTE);
    HRESULT SetVariantAsLong(VARIANT*, DWORD);
    HRESULT GetStringFromBSTR(BSTR, LPSTR*, LPDWORD, BOOL fAddDelimInCount = true);
    HRESULT GetStringFromVariant(VARIANT*, LPSTR*, LPDWORD, BOOL fAddDelimInCount = true);
    HRESULT OpenMd(LPWSTR, DWORD dwPermission = METADATA_PERMISSION_READ);
    HRESULT CloseMd(BOOL fSave = FALSE);
    HRESULT DeleteMdObject(LPWSTR);
    HRESULT CreateMdObject(LPWSTR);
    HRESULT OpenAdminBaseKey(LPWSTR, DWORD);
    void CloseAdminBaseKey();
    void FreeString(LPSTR psz);

public:

    CCertMapperMethod(LPCWSTR);
    ~CCertMapperMethod();

    HRESULT CreateMapping(VARIANT, BSTR, BSTR, BSTR, LONG);

    HRESULT GetMapping(LONG, VARIANT, VARIANT*, VARIANT*, VARIANT*, VARIANT*, VARIANT*);
    HRESULT DeleteMapping(LONG, VARIANT);
    HRESULT SetEnabled(LONG, VARIANT, LONG);
    HRESULT SetName(LONG, VARIANT, BSTR);
    HRESULT SetPwd(LONG, VARIANT, BSTR);
    HRESULT SetAcct(LONG, VARIANT, BSTR);

    HRESULT SetMdData(LPWSTR, DWORD, DWORD, DWORD, LPBYTE);
    HRESULT GetMdData(LPWSTR, DWORD, DWORD, LPDWORD, LPBYTE*);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\debug.cpp ===
#include "iisprov.h"
#include <stdio.h>
#include <stdarg.h>
#include "debug.h"

#if DBG

void __cdecl
Trace(
    LPCWSTR ptszFormat,
    ...)
{
    WCHAR tszBuff[2048];
    va_list args;
    
    va_start(args, ptszFormat);
    vswprintf(tszBuff, ptszFormat, args);
    va_end(args);
    OutputDebugString(tszBuff);
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\classfac.cpp ===
//***************************************************************************
//
//  CLASSFAC.CPP
//
//  Module: WMI IIS Instance provider
//
//  Purpose: Contains the class factory.  This creates objects when
//           connections are requested.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "iisprov.h"


//***************************************************************************
//
// CProvFactory::CProvFactory
// CProvFactory::~CProvFactory
//
// Constructor Parameters:
//  None
//***************************************************************************

CProvFactory::CProvFactory()
{
    m_cRef=0L;    
}

CProvFactory::~CProvFactory(void)
{
}

//***************************************************************************
//
// CProvFactory::QueryInterface
// CProvFactory::AddRef
// CProvFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CProvFactory::QueryInterface(
    REFIID riid,
    PPVOID ppv
    )
{
    *ppv=NULL;

    if (IID_IUnknown == riid || IID_IClassFactory == riid)
        *ppv=this;

    if (NULL != *ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CProvFactory::AddRef(void)
{
    return InterlockedIncrement((long *)&m_cRef);
}

STDMETHODIMP_(ULONG) CProvFactory::Release(void)
{
    long lNewCount = InterlockedDecrement((long *)&m_cRef);

    if (0L == lNewCount)
        delete this;
    
    return lNewCount>0 ? lNewCount : 0;
}

//***************************************************************************
//
// CProvFactory::CreateInstance
//
// Purpose: Instantiates a Locator object returning an interface pointer.
//
// Parameters:
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CProvFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid, PPVOID ppvObj
    )
{
    CIISInstProvider *pObj;
    HRESULT hr;

    *ppvObj=NULL;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    // Create the locator object.
    
    pObj = new CIISInstProvider();
    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr = pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// CProvFactory::LockServer
//
// Purpose:
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
// Parameters:
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
// Return Value:
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CProvFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement(&g_cLock);
    else
        InterlockedDecrement(&g_cLock);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\debug.h ===
/*
 * Some simple debugging macros that look and behave a lot like their
 * namesakes in MFC.  These macros should work in both C and C++ and
 * do something useful with almost any Win32 compiler.
 *
 * George V. Reilly  <georger@microcrafts.com>  <a-georgr@microsoft.com>
 */

#ifndef __DEBUG_H__
#define __DEBUG_H__

#if DBG
#  include <crtdbg.h>
# define TRACE                   Trace
# define TRACE0(psz)             Trace(L"%s", psz)
# define TRACE1(psz, p1)         Trace(psz, p1)
# define TRACE2(psz, p1, p2)     Trace(psz, p1, p2)
# define TRACE3(psz, p1, p2, p3) Trace(psz, p1, p2, p3)
#else /* !DBG */
  /* These macros should all compile away to nothing */
# define TRACE                   1 ? (void)0 : Trace
# define TRACE0(psz)
# define TRACE1(psz, p1)
# define TRACE2(psz, p1, p2)
# define TRACE3(psz, p1, p2, p3)

#endif /* !DBG*/


/* in debug version, writes trace messages to debug stream */
void __cdecl
Trace(
    LPCWSTR pszFormat,
    ...);

#endif /* __DEBUG_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\adminacl.cpp ===
//***************************************************************************
//
//  adminacl.cpp
//
//  Module: WBEM Instance provider
//
//  Purpose: IIS AdminACL class 
//
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************



#include "iisprov.h"


CAdminACL::CAdminACL()
{
    m_pADs = NULL;
    m_pSD = NULL;
    m_pDACL = NULL;
}


CAdminACL::~CAdminACL()
{
    CloseSD();
}


void CAdminACL::CloseSD()
{
    if(m_pDACL)
    {
        m_pDACL->Release();
        m_pDACL = NULL;
    }

    if(m_pSD)
    {
        m_pSD->Release();
        m_pSD = NULL;
    }

    if(m_pADs)
    {
        m_pADs->Release();
        m_pADs = NULL;
    }
}


HRESULT CAdminACL::GetObjectAsync(
    IWbemClassObject* pObj,
    ParsedObjectPath* pParsedObject,
    WMI_CLASS* pWMIClass
    )
{
    if(!m_pSD || !m_pSD || !m_pDACL)
        return E_UNEXPECTED;

    HRESULT hr = S_OK;

    if( pWMIClass->eKeyType == TYPE_AdminACL )
    {
        hr = PingAdminACL(pObj);
    }
    else if( pWMIClass->eKeyType == TYPE_AdminACE )
    {
        _bstr_t bstrTrustee;
        GetTrustee(pObj, pParsedObject, bstrTrustee); 
        hr = GetACE(pObj, bstrTrustee);
    }
    else
        hr = E_INVALIDARG;

    return hr;
}

HRESULT CAdminACL::DeleteObjectAsync(ParsedObjectPath* pParsedObject)
{
    HRESULT hr = S_OK;
    _bstr_t bstrTrustee;

    // get the trustee from key
    GetTrustee(NULL, pParsedObject, bstrTrustee); 

    // remove the ACE
    hr = RemoveACE(bstrTrustee);

    // set the modified AdminACL back into the metabase
    if(SUCCEEDED(hr))
        hr = SetSD();

    return hr;
}

HRESULT CAdminACL::PutObjectAsync(
    IWbemClassObject* pObj,
    ParsedObjectPath* pParsedObject,
    WMI_CLASS* pWMIClass
    )
{
    if(!m_pSD || !m_pSD || !m_pDACL)
        return E_UNEXPECTED;

    HRESULT hr;

    if( pWMIClass->eKeyType == TYPE_AdminACL )
    {
        hr = SetAdminACL(pObj);
    }
    else if( pWMIClass->eKeyType == TYPE_AdminACE )
    {
        _bstr_t bstrTrustee;
        GetTrustee(NULL, pParsedObject, bstrTrustee);

        BOOL fAceExisted = FALSE;
        hr = UpdateACE(pObj, bstrTrustee, fAceExisted);
        if(fAceExisted == FALSE)
            hr = AddACE(pObj, bstrTrustee);
    }
    else
        hr = E_INVALIDARG;

    // set the modified AdminACL back into the metabase
    if(SUCCEEDED(hr))
        hr = SetSD();

    return hr;
}

HRESULT CAdminACL::PingAdminACL(
    IWbemClassObject* pObj
    )
{
    _variant_t vt;
    BSTR bstr;
    long lVal;
    HRESULT hr;

    // Owner
    hr = m_pSD->get_Owner(&bstr);
    if(SUCCEEDED(hr))
    {
        vt = bstr;
        hr = pObj->Put(L"Owner", 0, &vt, 0);
        SysFreeString(bstr);
    }

    // Group
    if(SUCCEEDED(hr))
       hr = m_pSD->get_Group(&bstr);
    if(SUCCEEDED(hr))
    {
        vt = bstr;
        hr = pObj->Put(L"Group", 0, &vt, 0);
        SysFreeString(bstr);
    }
    
    // ControlFlags
    if(SUCCEEDED(hr))
        hr = m_pSD->get_Control(&lVal);
    if(SUCCEEDED(hr))
    {
        vt.vt   = VT_I4;
        vt.lVal = lVal;
        hr = pObj->Put(L"ControlFlags", 0, &vt, 0);
    }

    return hr;
}

HRESULT CAdminACL::SetAdminACL(
    IWbemClassObject* pObj
    )
{
    _variant_t vt;
    HRESULT hr;

    // Owner
    hr = pObj->Get(L"Owner", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_BSTR)
        hr = m_pSD->put_Owner(vt.bstrVal); 

    // Owner
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"Group", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_BSTR)
        hr = m_pSD->put_Group(vt.bstrVal); 

    // ControlFlags
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"ControlFlags", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_I4)
        hr = m_pSD->put_Control(vt.lVal); 

    return hr;
}

HRESULT CAdminACL::OpenSD(_bstr_t bstrAdsPath)
{
    _variant_t var;
    HRESULT hr;
    IDispatch* pDisp = NULL;

    // close SD interface first
    CloseSD();

    hr = GetAdsPath(bstrAdsPath);
    if(FAILED(hr))
       return hr;

    // get m_pADs
    hr = ADsGetObject(
         bstrAdsPath,
         IID_IADs,
         (void**)&m_pADs
         );
    if(FAILED(hr))
        return hr;
     
    // get m_pSD
    hr = m_pADs->Get(L"AdminACL",&var);
    if(FAILED(hr))
        return hr;  
    
    hr = V_DISPATCH(&var)->QueryInterface(
        IID_IADsSecurityDescriptor,
        (void**)&m_pSD
        );
    if(FAILED(hr))
        return hr;

    // get m_pDACL
    hr = m_pSD->get_DiscretionaryAcl(&pDisp);
    if(FAILED(hr))
        return hr;

    hr = pDisp->QueryInterface(
       IID_IADsAccessControlList, 
       (void**)&m_pDACL
       );

    pDisp->Release();
    
    return hr;
}


HRESULT CAdminACL::SetSD()
{
    _variant_t var;
    HRESULT hr;
    IDispatch* pDisp = NULL;

    // put m_pDACL
    hr = m_pDACL->QueryInterface(
       IID_IDispatch, 
       (void**)&pDisp
       );
    if(FAILED(hr))
        return hr;

    hr = m_pSD->put_DiscretionaryAcl(pDisp);
    pDisp->Release();
    if(FAILED(hr))
       return hr;

    // put AdminACL
    hr = m_pSD->QueryInterface(
        IID_IDispatch,
        (void**)&pDisp
        );
    if(FAILED(hr))
       return hr;

    var.vt = VT_DISPATCH;
    var.pdispVal = pDisp;
    hr = m_pADs->Put(L"AdminACL",var);  // pDisp will be released by this call Put().
    if(FAILED(hr))
       return hr;

    // Commit the change to the active directory
    hr = m_pADs->SetInfo();

    return hr;
}


HRESULT CAdminACL::GetAdsPath(_bstr_t& bstrAdsPath)
{
    WCHAR* p = new WCHAR[bstrAdsPath.length() + 1];
    if(p == NULL)
        return E_OUTOFMEMORY;

    lstrcpyW(p, bstrAdsPath);

    bstrAdsPath = L"IIS://LocalHost";

    // trim first three charaters "/LM" 
    bstrAdsPath += (p+3);

    delete [] p;

    return S_OK;
}


HRESULT CAdminACL::PingACE(
    IWbemClassObject* pObj,
    IADsAccessControlEntry* pACE
    )
{
    _variant_t vt;
    BSTR bstr;
    long lVal;
    HRESULT hr;

    // AccessMask
    hr = pACE->get_AccessMask(&lVal);
    if(SUCCEEDED(hr))
    {
        vt.vt   = VT_I4;
        vt.lVal = lVal;
        hr = pObj->Put(L"AccessMask", 0, &vt, 0);
    }

    // AceType
    if(SUCCEEDED(hr))
       hr = pACE->get_AceType(&lVal);
    if(SUCCEEDED(hr))
    {
        vt.vt   = VT_I4;
        vt.lVal = lVal;
        hr = pObj->Put(L"AceType", 0, &vt, 0);
    }
    
    // AceFlags
    if(SUCCEEDED(hr))
       hr = pACE->get_AceFlags(&lVal);
    if(SUCCEEDED(hr))
    {
        vt.vt   = VT_I4;
        vt.lVal = lVal;
        hr = pObj->Put(L"AceFlags", 0, &vt, 0);
    }

    // Flags
    if(SUCCEEDED(hr))
       hr = pACE->get_Flags(&lVal);
    if(SUCCEEDED(hr))
    {
        vt.vt   = VT_I4;
        vt.lVal = lVal;
        hr = pObj->Put(L"Flags", 0, &vt, 0);
    }
    
    // ObjectType
    if(SUCCEEDED(hr))
       hr = pACE->get_ObjectType(&bstr);
    if(SUCCEEDED(hr))
    {
        vt = bstr;
        hr = pObj->Put(L"ObjectType", 0, &vt, 0);
        SysFreeString(bstr);
    }

    // InheritedObjectType
    if(SUCCEEDED(hr))
       hr = pACE->get_InheritedObjectType(&bstr);
    if(SUCCEEDED(hr))
    {
        vt = bstr;
        hr = pObj->Put(L"InheritedObjectType", 0, &vt, 0);
        SysFreeString(bstr);
    }
 
    return hr;
}


HRESULT CAdminACL::GetACE(
    IWbemClassObject* pObj,
    _bstr_t& bstrTrustee
    )
{
    HRESULT hr = S_OK;
    _variant_t var;
    IEnumVARIANT* pEnum = NULL;
    ULONG   lFetch;
    BSTR    bstr;
    IDispatch *pDisp = NULL;
    IADsAccessControlEntry *pACE = NULL;

    hr = GetACEEnum(&pEnum);
    if ( FAILED(hr) )
        return hr;

    //////////////////////////////////////////////
    // Enumerate ACEs
    //////////////////////////////////////////////
    hr = pEnum->Next( 1, &var, &lFetch );
    while( hr == S_OK )
    {
        if ( lFetch == 1 )
        {
            if ( VT_DISPATCH != V_VT(&var) )
            {
                hr = E_UNEXPECTED;
                break;
            }

            pDisp = V_DISPATCH(&var);

            /////////////////////////////
            // Get the individual ACE
            /////////////////////////////
            hr = pDisp->QueryInterface( 
                IID_IADsAccessControlEntry, 
                (void**)&pACE 
                ); 

            if ( SUCCEEDED(hr) )
            {
                hr = pACE->get_Trustee(&bstr);

                if( SUCCEEDED(hr) && !lstrcmpiW(bstr, bstrTrustee) )
                {
                    hr = PingACE(pObj, pACE);

                    SysFreeString(bstr);
                    pACE->Release();
                    break;
                }

                SysFreeString(bstr);
                pACE->Release();
           }
        }

        hr = pEnum->Next( 1, &var, &lFetch );
    }

    pEnum->Release();

    return hr;
}

HRESULT CAdminACL::RemoveACE(
    _bstr_t& bstrTrustee
    )
{
    HRESULT hRemoved = WBEM_E_INVALID_PARAMETER;
    HRESULT hr = S_OK;
    _variant_t var;
    IEnumVARIANT* pEnum = NULL;
    ULONG   lFetch;
    BSTR    bstr;
    IDispatch *pDisp = NULL;
    IADsAccessControlEntry *pACE = NULL;


    hr = GetACEEnum(&pEnum);
    if ( FAILED(hr) )
        return hr;

    //////////////////////////////////////////////
    // Enumerate ACEs
    //////////////////////////////////////////////
    hr = pEnum->Next( 1, &var, &lFetch );
    while( hr == S_OK )
    {
        if ( lFetch == 1 )
        {
            if ( VT_DISPATCH != V_VT(&var) )
            {
                hr = E_UNEXPECTED;
                break;
            }

            pDisp = V_DISPATCH(&var);

            /////////////////////////////
            // Get the individual ACE
            /////////////////////////////
            hr = pDisp->QueryInterface( 
                IID_IADsAccessControlEntry, 
                (void**)&pACE 
                ); 

            if ( SUCCEEDED(hr) )
            {
                hr = pACE->get_Trustee(&bstr);

                if( SUCCEEDED(hr) && !lstrcmpiW(bstr, bstrTrustee) )
                {
                    // remove ACE
                    hr = pACE->QueryInterface(IID_IDispatch,(void**)&pDisp);
                    if ( SUCCEEDED(hr) )
                    {
                        hRemoved = m_pDACL->RemoveAce(pDisp);
                        pDisp->Release();
                    }

                    SysFreeString(bstr);
                    pACE->Release();
                    break;
                }

                SysFreeString(bstr);
                pACE->Release();
            }
        }

        hr = pEnum->Next( 1, &var, &lFetch );
    }

    pEnum->Release();

    return hRemoved;
}

// parse ParsedObjectPath to get the Trustee key
void CAdminACL::GetTrustee(
    IWbemClassObject* pObj,
    ParsedObjectPath* pPath,    
    _bstr_t&          bstrTrustee 
    )
{
    KeyRef* pkr;
    WCHAR*  pszKey = L"Trustee";

    pkr = CUtils::GetKey(pPath, pszKey);
    if(pkr == NULL)
        throw WBEM_E_INVALID_OBJECT;

    bstrTrustee = pkr->m_vValue;
    if (pObj)
    {
        _bstr_t bstr = pkr->m_pName;
        HRESULT hr = pObj->Put(bstr, 0, &pkr->m_vValue, 0);
        THROW_ON_ERROR(hr);
    }
}


HRESULT CAdminACL::GetACEEnum(
    IEnumVARIANT** pEnum
    )
{
    HRESULT hr = S_OK;
    LPUNKNOWN  pUnk = NULL;

    if(!pEnum)
        return E_INVALIDARG;

    if(*pEnum)
        (*pEnum)->Release();

    hr = m_pDACL->get__NewEnum( &pUnk );
    if ( SUCCEEDED(hr) )
    {
        hr = pUnk->QueryInterface( IID_IEnumVARIANT, (void**) pEnum );
    }

    return hr;
}

// addd a ACE
HRESULT CAdminACL::AddACE(
    IWbemClassObject* pObj,
    _bstr_t& bstrTrustee
    )
{
    HRESULT hr = m_pDACL->put_AclRevision(ADS_SD_REVISION_DS);
    if(FAILED(hr))
        return hr;

    // create a ACE
    IADsAccessControlEntry* pACE = NULL; 
    hr = NewACE(
        pObj,
        bstrTrustee,
        &pACE
        );
    if(FAILED(hr))
        return hr;

    // add the ACE
    IDispatch* pDisp = NULL;
    hr = pACE->QueryInterface(IID_IDispatch,(void**)&pDisp);
    if(SUCCEEDED(hr))
    {
        hr = m_pDACL->AddAce(pDisp);
        pDisp->Release();
    }

    pACE->Release();

    return hr;
}

////////////////////////////////////
// function to create an ACE
////////////////////////////////////
HRESULT CAdminACL::NewACE(
    IWbemClassObject* pObj,
    _bstr_t& bstrTrustee,
    IADsAccessControlEntry** ppACE
    )
{
    if(!ppACE)
        return E_INVALIDARG;

    HRESULT hr;
    hr = CoCreateInstance(
        CLSID_AccessControlEntry,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IADsAccessControlEntry,
        (void**)ppACE
        );

    // Trustee
    _variant_t vt;
    if(SUCCEEDED(hr))
        hr = (*ppACE)->put_Trustee(bstrTrustee); 

    if(SUCCEEDED(hr))
        hr = SetDataOfACE(pObj, *ppACE);

    return hr;
}


HRESULT CAdminACL::SetDataOfACE(
    IWbemClassObject* pObj,
    IADsAccessControlEntry* pACE
    )
{
    HRESULT hr;
    _variant_t vt;

    // AccessMask
    hr = pObj->Get(L"AccessMask", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_I4)
        hr = pACE->put_AccessMask(vt.lVal); 

    // AceType
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"AceType", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_I4)
        hr = pACE->put_AceType(vt.lVal); 

    // AceFlags
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"AceFlags", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_I4)
        hr = pACE->put_AceFlags(vt.lVal); 

    // Flags
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"Flags", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_I4)
        hr = pACE->put_Flags(vt.lVal); 

    // ObjectType
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"ObjectType", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_BSTR)
        hr = pACE->put_ObjectType(vt.bstrVal); 

    // InheritedObjectType
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"InheritedObjectType", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr) && vt.vt == VT_BSTR)
        hr = pACE->put_InheritedObjectType(vt.bstrVal); 

    return hr;
}


HRESULT CAdminACL::UpdateACE(
    IWbemClassObject* pObj,
    _bstr_t& bstrTrustee,
    BOOL& fAceExisted
    )
{
    HRESULT hr = S_OK;
    _variant_t var;
    IEnumVARIANT* pEnum = NULL;
    ULONG   lFetch;
    BSTR    bstr;
    IDispatch *pDisp = NULL;
    IADsAccessControlEntry *pACE = NULL;

    fAceExisted = FALSE;

    hr = GetACEEnum(&pEnum);
    if ( FAILED(hr) )
        return hr;

    //////////////////////////////////////////////
    // Enumerate ACEs
    //////////////////////////////////////////////
    hr = pEnum->Next( 1, &var, &lFetch );
    while( hr == S_OK )
    {
        if ( lFetch == 1 )
        {
            if ( VT_DISPATCH != V_VT(&var) )
            {
                hr = E_UNEXPECTED;
                break;
            }

            pDisp = V_DISPATCH(&var);

            /////////////////////////////
            // Get the individual ACE
            /////////////////////////////
            hr = pDisp->QueryInterface( 
                IID_IADsAccessControlEntry, 
                (void**)&pACE 
                ); 

            if ( SUCCEEDED(hr) )
            {
                hr = pACE->get_Trustee(&bstr);

                if( SUCCEEDED(hr) && !lstrcmpiW(bstr, bstrTrustee) )
                {
                    fAceExisted = TRUE;
                    
                    // Update the data of the ACE
                    hr = SetDataOfACE(pObj, pACE);
                    
                    SysFreeString(bstr);
                    pACE->Release();
                    break;
                }

                SysFreeString(bstr);
                pACE->Release();
           }
        }

        hr = pEnum->Next( 1, &var, &lFetch );
    }

    pEnum->Release();

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\certmap.cpp ===
////////////////////////////////////////////////////
//
// Copyright (c) 1997  Microsoft Corporation
// 
// Module Name: certmap.cpp
//
// Abstract: IIS privider cert mapper object methods
//
// Author: Philippe Choquier (phillich)    10-Apr-1997
//
// History: Zeyong Xu borrowed the source code from ADSI object 
//          (created by Philippe Choquier at 10-Apr-1997) at 20-Oct-1999
//
///////////////////////////////////////////////////

#include "iisprov.h"


//
// CCertMapperMethod
//

CCertMapperMethod::CCertMapperMethod(LPCWSTR pszMetabasePathIn)
{ 
    m_hmd = NULL; 

    HRESULT hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (void**)&m_pIABase
        );

    THROW_ON_ERROR(hr);
    
    Init(pszMetabasePathIn);
}


CCertMapperMethod::~CCertMapperMethod()
{
    if ( m_pszMetabasePath )
    {
        free( m_pszMetabasePath );
    }

    if(m_pIABase)
        m_pIABase->Release();
}

//
// CreateMapping(): Create a mapping entry
//
// Arguments:
//
//    vCert - X.509 certificate
//    bstrNtAcct - NT acct to map to
//    bstrNtPwd - NT pwd
//    bstrName - friendly name for mapping entry
//    lEnabled - 1 to enable mapping entry, 0 to disable it
//
HRESULT
CCertMapperMethod::CreateMapping(
    VARIANT     vCert,
    BSTR        bstrNtAcct,
    BSTR        bstrNtPwd,
    BSTR        bstrName,
    LONG        lEnabled
    )
{
    HRESULT     hr;
    LPBYTE      pbCert = NULL;
    DWORD       cCert;
    LPSTR       pszNtAcct = NULL;
    LPSTR       pszNtPwd = NULL;
    LPSTR       pszName = NULL;
    LPBYTE      pRes;
    DWORD       cRes;
    DWORD       cName;
    DWORD       cNtAcct;
    DWORD       cNtPwd;
    WCHAR       achIndex[32];
    VARIANT     vOldAcct;
    VARIANT     vOldCert;
    VARIANT     vOldPwd;
    VARIANT     vOldName;
    VARIANT     vOldEnabledFlag;
    PCCERT_CONTEXT pcCert = NULL;

    //
    // Do some sanity checks on the cert 
    //
    if ( SUCCEEDED( hr = GetStringFromVariant( &vCert, 
                                                 (LPSTR*)&pbCert,
                                                 &cCert,
                                                 FALSE ) ) )
    {
        //
        // try to construct a cert context
        //
        if ( !( pcCert = CertCreateCertificateContext( X509_ASN_ENCODING,
                                                       pbCert,
                                                       cCert ) ) )
        {
            //
            // If the decoding fails, GetLastError() returns an ASN1 decoding
            // error that is obtained by subtracting CRYPT_E_OSS_ERROR from the returned
            // error and looking in file asn1code.h for the actual error. To avoid the
            // cryptic ASN1 errors, we'll just return a general "invalid arg" error 
            //
            hr = RETURNCODETOHRESULT( E_INVALIDARG );
            FreeString( (LPSTR) pbCert );
            return hr;
        }

        CertFreeCertificateContext( pcCert );
    }
    else
    {
        return hr;
    }

    //
    // check if we already have a mapping for this cert; if we do, we'll replace that mapping
    // with the new one
    //
    if ( SUCCEEDED( hr = GetMapping( IISMAPPER_LOCATE_BY_CERT,
                                       vCert,
                                       &vOldCert,
                                       &vOldAcct,
                                       &vOldPwd,
                                       &vOldName,
                                       &vOldEnabledFlag ) ) )
    {
        if ( FAILED( hr = SetName( IISMAPPER_LOCATE_BY_CERT,
                                     vCert,
                                     bstrName ) ) ||
             FAILED( hr = SetAcct( IISMAPPER_LOCATE_BY_CERT,
                                     vCert,
                                     bstrNtAcct ) ) ||
             FAILED( hr = SetPwd( IISMAPPER_LOCATE_BY_CERT,
                                    vCert,
                                    bstrNtPwd ) ) ||
             FAILED( hr = SetEnabled( IISMAPPER_LOCATE_BY_CERT,
                                        vCert,
                                        lEnabled ) ) )
        {
            hr; //NOP - Something failed 
        }
    }
    //
    // New mapping
    //
    else if ( hr == RETURNCODETOHRESULT( ERROR_PATH_NOT_FOUND ) )
    {
        //
        // check mapping exists, create if not
        //
        hr = OpenMd( L"Cert11", METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ );

        if ( hr == RETURNCODETOHRESULT( ERROR_PATH_NOT_FOUND ) )
        {
            if ( SUCCEEDED( hr = OpenMd( L"", 
                                           METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
            {
                hr = CreateMdObject( L"Cert11" );
                CloseMd( FALSE );

                // Reopen to the correct node.
                hr = OpenMd( L"Cert11", METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ );
            }
        }

        if ( FAILED( hr ) )
        {
            return hr;
        }

        //
        // adding mapping cert "0" means add @ end of list
        //

        if ( SUCCEEDED( hr = CreateMdObject( L"mappings/0" ) ) )
        {
            if ( SUCCEEDED( hr = GetMdData( L"", MD_NSEPM_ACCESS_CERT, DWORD_METADATA, &
                                              cRes, &pRes ) ) )
            {
                if ( cRes == sizeof(DWORD ) )
                {
                    wsprintfW( achIndex, L"mappings/%u", *(LPDWORD)pRes );

                    if ( FAILED( hr = GetStringFromBSTR( bstrNtAcct, &pszNtAcct, &cNtAcct ) ) ||
                         FAILED( hr = GetStringFromBSTR( bstrNtPwd, &pszNtPwd, &cNtPwd ) ) ||
                         FAILED( hr = GetStringFromBSTR( bstrName, &pszName, &cName ) ) ||
                         FAILED( hr = SetMdData( achIndex, MD_MAPENABLED, DWORD_METADATA, 
                                                   sizeof(DWORD), (LPBYTE)&lEnabled ) ) ||
                         FAILED( hr = SetMdData( achIndex, MD_MAPNAME, STRING_METADATA, 
                                                   cName, (LPBYTE)pszName ) ) ||
                         FAILED( hr = SetMdData( achIndex, MD_MAPNTPWD, STRING_METADATA, 
                                                   cNtPwd, (LPBYTE)pszNtPwd ) ) ||
                         FAILED( hr = SetMdData( achIndex, MD_MAPNTACCT, STRING_METADATA, 
                                                   cNtAcct, (LPBYTE)pszNtAcct ) ) ||
                         FAILED( hr = SetMdData( achIndex, MD_MAPCERT, BINARY_METADATA, 
                                                   cCert, (LPBYTE)pbCert ) ) )
                    {
                    }
                }   
                else
                {
                    hr = E_FAIL;
                }
            }
        }
    }

    CloseMd( SUCCEEDED( hr ) );

    FreeString( (LPSTR)pbCert );
    FreeString( pszNtAcct );
    FreeString( pszNtPwd );
    FreeString( pszName );

    return hr;
}

//
// GetMapping: Get a mapping entry using key
//
// Arguments:
//
//    lMethod - method to use for access ( IISMAPPER_LOCATE_BY_* )
//    vKey - key to use to locate mapping
//    pvCert - X.509 certificate
//    pbstrNtAcct - NT acct to map to
//    pbstrNtPwd - NT pwd
//    pbstrName - friendly name for mapping entry
//    plEnabled - 1 to enable mapping entry, 0 to disable it
//

HRESULT
CCertMapperMethod::GetMapping(
    LONG        lMethod,
    VARIANT     vKey,
    VARIANT*    pvCert,
    VARIANT*    pbstrNtAcct,
    VARIANT*    pbstrNtPwd,
    VARIANT*    pbstrName,
    VARIANT*    plEnabled
    )
{
    WCHAR       achIndex[32];
    HRESULT     hr;
    DWORD       dwLen;
    LPBYTE      pbData;

    VariantInit( pvCert );
    VariantInit( pbstrNtAcct );
    VariantInit( pbstrNtPwd );
    VariantInit( pbstrName );
    VariantInit( plEnabled );

    if ( SUCCEEDED( hr = OpenMd( L"Cert11", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hr = Locate( lMethod, vKey, achIndex )) )
        {
            if ( SUCCEEDED( hr = GetMdData( achIndex, MD_MAPCERT, BINARY_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                hr = SetVariantAsByteArray( pvCert, dwLen, pbData );
                free( pbData );
            }
            else
            {
                CloseMd( FALSE );
                return hr;
            }

            if ( SUCCEEDED( hr = GetMdData( achIndex, MD_MAPNTACCT, STRING_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                hr = SetVariantAsBSTR( pbstrNtAcct, dwLen, pbData );
                free( pbData );
            }
            else
            {
                CloseMd( FALSE );
                return hr;
            }

            if ( SUCCEEDED( hr = GetMdData( achIndex, MD_MAPNTPWD, STRING_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                hr = SetVariantAsBSTR( pbstrNtPwd, dwLen, pbData );
                free( pbData );
            }
            else
            {
                CloseMd( FALSE );
                return hr;
            }

            if ( SUCCEEDED( hr = GetMdData( achIndex, MD_MAPNAME, STRING_METADATA, &dwLen, 
                                              &pbData ) ) )
            {
                hr = SetVariantAsBSTR( pbstrName, dwLen, pbData );
                free( pbData );
            }
            else
            {
                CloseMd( FALSE );
                return hr;
            }

            if ( FAILED( hr = GetMdData( achIndex, MD_MAPENABLED, STRING_METADATA, &dwLen, 
                                           &pbData ) ) )
            {
                SetVariantAsLong( plEnabled, FALSE );
            }
            else
            {
                SetVariantAsLong( plEnabled, *(LPDWORD)pbData );
                free( pbData );
            }
        }

        CloseMd( FALSE );
    }

    return hr;
}

//
// Delete a mapping entry using key
//
HRESULT
CCertMapperMethod::DeleteMapping(
    LONG        lMethod,
    VARIANT     vKey
    )
{
    WCHAR       achIndex[32];
    HRESULT     hr;

    if ( SUCCEEDED( hr = OpenMd( L"Cert11", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hr = Locate( lMethod, vKey, achIndex )) )
        {
            hr = DeleteMdObject( achIndex );
        }
        CloseMd( TRUE );
    }

    return hr;
}

//
// Set the enable flag on a mapping entry using key
//
HRESULT
CCertMapperMethod::SetEnabled(
    LONG        lMethod,
    VARIANT     vKey,
    LONG        lEnabled
    )
{
    WCHAR       achIndex[32];
    HRESULT     hr;

    if ( SUCCEEDED( hr = OpenMd( L"Cert11", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hr = Locate( lMethod, vKey, achIndex )) )
        {
            hr = SetMdData( achIndex, MD_MAPENABLED, DWORD_METADATA, sizeof(DWORD), (LPBYTE)&lEnabled );
        }
        CloseMd( TRUE );
    }

    return hr;
}

//
// Set the Name on a mapping entry using key
//
HRESULT CCertMapperMethod::SetName(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrName
    )
{
    return SetString( lMethod, vKey, bstrName, MD_MAPNAME );
}

//
// Set a string property on a mapping entry using key
//
HRESULT CCertMapperMethod::SetString(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrName,
    DWORD       dwProp
    )
{
    WCHAR       achIndex[32];
    LPSTR       pszName = NULL;
    HRESULT     hr;
    DWORD       dwLen;


    if ( FAILED( hr = GetStringFromBSTR( bstrName, &pszName, &dwLen, TRUE ) ) )
    {
        return hr;
    }

    if ( SUCCEEDED( hr = OpenMd( L"Cert11", 
                                   METADATA_PERMISSION_WRITE|METADATA_PERMISSION_READ ) ) )
    {
        if ( SUCCEEDED(hr = Locate( lMethod, vKey, achIndex )) )
        {
            hr = SetMdData( achIndex, dwProp, STRING_METADATA, dwLen, (LPBYTE)pszName );
        }
        CloseMd( TRUE );
    }

    FreeString( pszName );

    return hr;
}

//
// Set the Password on a mapping entry using key
//
HRESULT
CCertMapperMethod::SetPwd(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrPwd
    )
{
    return SetString( lMethod, vKey, bstrPwd, MD_MAPNTPWD );
}

//
// Set the NT account name on a mapping entry using key
//
HRESULT
CCertMapperMethod::SetAcct(
    LONG        lMethod,
    VARIANT     vKey,
    BSTR        bstrAcct
    )
{
    return SetString( lMethod, vKey, bstrAcct, MD_MAPNTACCT );
}


HRESULT
CCertMapperMethod::OpenMd(
    LPWSTR  pszOpenPath,
    DWORD   dwPermission
    )
{
    HRESULT hr;
    LPWSTR  pszPath;
    UINT    cL = wcslen( m_pszMetabasePath );

    pszPath = (LPWSTR)malloc( (wcslen(pszOpenPath) + 1 + cL + 1)*sizeof(WCHAR) );

    if ( pszPath == NULL )
    {
        return E_OUTOFMEMORY;
    }

    memcpy( pszPath, m_pszMetabasePath, cL * sizeof(WCHAR) );
    if ( cL && m_pszMetabasePath[cL-1] != L'/' && *pszOpenPath && *pszOpenPath != L'/' )
    {
        pszPath[cL++] = L'/';
    }
    wcscpy( pszPath + cL, pszOpenPath );

    hr = OpenAdminBaseKey(
                pszPath,
                dwPermission
                );

    free( pszPath );

    return hr;
}


HRESULT
CCertMapperMethod::CloseMd(
    BOOL fSave
    )
{
    CloseAdminBaseKey();
    m_hmd = NULL;
    
    if ( m_pIABase && fSave )
    {
        m_pIABase->SaveData();
    }

    return S_OK;
}


HRESULT
CCertMapperMethod::DeleteMdObject(
    LPWSTR  pszKey
    )
{
    return m_pIABase->DeleteKey( m_hmd, pszKey );
}


HRESULT
CCertMapperMethod::CreateMdObject(
    LPWSTR  pszKey
    )
{
    return m_pIABase->AddKey( m_hmd, pszKey );
}


HRESULT
CCertMapperMethod::SetMdData( 
    LPWSTR  achIndex, 
    DWORD   dwProp,
    DWORD   dwDataType,
    DWORD   dwDataLen,
    LPBYTE  pbData 
    )
{
    METADATA_RECORD     md;

    md.dwMDDataLen = dwDataLen;
    md.dwMDDataType = dwDataType;
    md.dwMDIdentifier = dwProp;
    md.dwMDAttributes = (dwProp == MD_MAPPWD) ? METADATA_SECURE : 0;
    md.pbMDData = pbData;

    return m_pIABase->SetData( m_hmd, achIndex, &md );
}


HRESULT
CCertMapperMethod::GetMdData( 
    LPWSTR  achIndex, 
    DWORD   dwProp,
    DWORD   dwDataType,
    LPDWORD pdwDataLen,
    LPBYTE* ppbData 
    )
{
    HRESULT             hr;
    METADATA_RECORD     md;
    DWORD               dwRequired;

    md.dwMDDataLen = 0;
    md.dwMDDataType = dwDataType;
    md.dwMDIdentifier = dwProp;
    md.dwMDAttributes = 0;
    md.pbMDData = NULL;

    if ( FAILED(hr = m_pIABase->GetData( m_hmd, achIndex, &md, &dwRequired )) )
    {
        if ( hr == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER) )
        {
            if ( (*ppbData = (LPBYTE)malloc(dwRequired)) == NULL )
            {
                return E_OUTOFMEMORY;
            }
            md.pbMDData = *ppbData;
            md.dwMDDataLen = dwRequired;
            hr = m_pIABase->GetData( m_hmd, achIndex, &md, &dwRequired );
            *pdwDataLen = md.dwMDDataLen;
        }
    }
    else
    {
       *pdwDataLen = 0;
       *ppbData = NULL;
    }

    return hr;
}

//
// Locate a mapping entry based on key 
// OpenMd() must be called 1st
//
HRESULT
CCertMapperMethod::Locate(
    LONG    lMethod,
    VARIANT vKey,
    LPWSTR  pszResKey
    )
{
    HRESULT     hr;
    LPSTR       pV = NULL;
    DWORD       cV;
    DWORD       dwProp;
    LPSTR       pRes;
    DWORD       cRes;
    BOOL        fAddDelim = TRUE;

    //
    // determine method
    //
    switch ( lMethod )
    {
        case IISMAPPER_LOCATE_BY_CERT:
            dwProp = MD_NSEPM_ACCESS_CERT;
            fAddDelim = FALSE;
            break;

        case IISMAPPER_LOCATE_BY_NAME:
            dwProp = MD_NSEPM_ACCESS_NAME;
            break;

        case IISMAPPER_LOCATE_BY_ACCT:
            dwProp = MD_NSEPM_ACCESS_ACCOUNT;
            break;

        case IISMAPPER_LOCATE_BY_INDEX:
            if ( SUCCEEDED( hr = GetStringFromVariant( &vKey, &pV, &cV, TRUE ) ) )
            {
                wsprintfW( pszResKey, L"mappings/%s", pV );
            }
            FreeString( pV );
            return hr;

        default:
            return E_FAIL;
    }

    //
    // get ptr to data
    //
    if ( SUCCEEDED( hr = GetStringFromVariant( &vKey, &pV, &cV, fAddDelim ) ) )
    {
        //
        // set search prop, get result
        //
        if ( SUCCEEDED( hr = SetMdData( L"", dwProp, BINARY_METADATA, cV, (LPBYTE)pV ) ) )
        {
            if ( SUCCEEDED( hr = GetMdData( L"", dwProp, DWORD_METADATA, &cRes, (LPBYTE*)&pRes ) ) )
            {
                if ( cRes == sizeof(DWORD ) )
                {
                    wsprintfW( pszResKey, L"mappings/%u", *(LPDWORD)pRes );
                }
                else
                {
                    hr = E_FAIL;
                }
                free( pRes );
            }
        }
    }

    FreeString( pV );
    return hr;
}

//
// GetStringFromBSTR: Allocate string buffer from BSTR
//
// Arguments:
//
//    bstr - bstr to convert from
//    psz - updated with ptr to buffer, to be freed with FreeString()
//    pdwLen - updated with strlen(string), incremented by 1 if fAddDelimInCount is TRUE
//    fAddDelimInCount - TRUE to increment *pdwLen 
//
HRESULT CCertMapperMethod::GetStringFromBSTR( 
    BSTR    bstr,
    LPSTR*  psz,
    LPDWORD pdwLen,
    BOOL    fAddDelimInCount
    )
{
    UINT    cch = SysStringLen(bstr);
    UINT    cchT;

    // include NULL terminator

    *pdwLen = cch + (fAddDelimInCount ? 1 : 0);

    CHAR *szNew = (CHAR*)malloc((2 * cch) + 1);            // * 2 for worst case DBCS string
    if (szNew == NULL)
    {
        return E_OUTOFMEMORY;
    }

    cchT = WideCharToMultiByte(CP_ACP, 0, bstr, cch + 1, szNew, (2 * cch) + 1, NULL, NULL);

    *psz = szNew;

    return NOERROR;
}

//
// GetStringFromVariant: Allocate string buffer from BSTR
//
// Arguments:
//
//    pVar - variant to convert from. Recognizes BSTR, VT_ARRAY|VT_UI1, ByRef or ByVal
//    psz - updated with ptr to buffer, to be freed with FreeString()
//    pdwLen - updated with size of input, incremented by 1 if fAddDelimInCount is TRUE
//    fAddDelimInCount - TRUE to increment *pdwLen 
//
HRESULT CCertMapperMethod::GetStringFromVariant( 
    VARIANT*    pVar,
    LPSTR*      psz,
    LPDWORD     pdwLen,
    BOOL        fAddDelim
    )
{
    LPBYTE  pbV;
    UINT    cV;
    HRESULT hr;
    WORD    vt = V_VT(pVar);
    BOOL    fByRef = FALSE;
    VARIANT vOut;

    VariantInit( &vOut );

    if ( vt & VT_BYREF )
    {
        vt &= ~VT_BYREF;
        fByRef = TRUE;
    }


    // if pVar is BSTR, convert to multibytes

    if ( vt == VT_VARIANT )
    {
        pVar = (VARIANT*)V_BSTR(pVar);
        vt = V_VT(pVar);
        if ( fByRef = vt & VT_BYREF )
        {
            vt &= ~VT_BYREF;
        }
    }

    if ( vt == VT_BSTR )
    {
        hr = GetStringFromBSTR( 
            fByRef ? *(BSTR*)V_BSTR(pVar) : V_BSTR(pVar), 
            psz, 
            pdwLen,
            fAddDelim 
            );
    }
    else if( vt == (VT_ARRAY | VT_UI1) )
    {
        long        lBound, uBound, lItem;
        BYTE        bValue;
        SAFEARRAY*  pSafeArray;

        // array of VT_UI1 (probably OctetString)   
        pSafeArray  = fByRef ? *(SAFEARRAY**)V_BSTR(pVar) : V_ARRAY( pVar );

        hr = SafeArrayGetLBound(pSafeArray, 1, &lBound);
        hr = SafeArrayGetUBound(pSafeArray, 1, &uBound);

        cV = uBound - lBound + 1;

        if ( !(pbV = (LPBYTE)malloc(cV)) )
        {
            hr = E_OUTOFMEMORY;
            VariantClear( &vOut );
            return hr;
        }

        hr = S_OK;

        for( lItem = lBound; lItem <= uBound ; lItem++ )
        {
            hr  = SafeArrayGetElement( pSafeArray, &lItem, &bValue );
            if( FAILED( hr ) )
            {
                break;
            }
            pbV[lItem-lBound] = bValue;
        }

        *psz = (LPSTR)pbV;
        *pdwLen = cV;
    }
    else if( vt == (VT_ARRAY | VT_VARIANT) )
    {
        long        lBound, uBound, lItem;
        VARIANT     vValue;
        BYTE        bValue;
        SAFEARRAY*  pSafeArray;

   
        // array of VT_VARIANT (probably VT_I4 )
   
        pSafeArray  = fByRef ? *(SAFEARRAY**)V_BSTR(pVar) : V_ARRAY( pVar );

        hr = SafeArrayGetLBound(pSafeArray, 1, &lBound);
        hr = SafeArrayGetUBound(pSafeArray, 1, &uBound);

        cV = uBound - lBound + 1;

        if ( !(pbV = (LPBYTE)malloc(cV)) )
        {
            hr = E_OUTOFMEMORY;
            VariantClear( &vOut );
            return hr;
        }

        hr = S_OK;

        for( lItem = lBound; lItem <= uBound ; lItem++ )
        {
            hr  = SafeArrayGetElement( pSafeArray, &lItem, &vValue );
            if( FAILED( hr ) )
            {
                break;
            }
            if ( V_VT(&vValue) == VT_UI1 )
            {
                bValue = V_UI1(&vValue);
            }
            else if ( V_VT(&vValue) == VT_I2 )
            {
                bValue = (BYTE)V_I2(&vValue);
            }
            else if ( V_VT(&vValue) == VT_I4 )
            {
                bValue = (BYTE)V_I4(&vValue);
            }
            else
            {
                bValue = 0;
            }
            pbV[lItem-lBound] = bValue;
        }

        *psz = (LPSTR)pbV;
        *pdwLen = cV;
    }
    else
    {
        hr = E_FAIL;
    }

    VariantClear( &vOut );
    return hr;
}


VOID CCertMapperMethod::FreeString( 
    LPSTR   psz 
    )
{
    if ( psz )
    {
        free( psz );
    }
}


HRESULT CCertMapperMethod::SetBSTR( 
    BSTR*   pbstrRet,
    DWORD   cch, 
    LPBYTE  sz 
    )
{
    BSTR bstrRet;
    
    if (sz == NULL)
    {
        *pbstrRet = NULL;
        return(NOERROR);
    }
        
    // Allocate a string of the desired length
    // SysAllocStringLen allocates enough room for unicode characters plus a null
    // Given a NULL string it will just allocate the space
    bstrRet = SysAllocStringLen(NULL, cch);
    if (bstrRet == NULL)
    {
        return(E_OUTOFMEMORY);
    }

    // If we were given "", we will have cch=0.  return the empty bstr
    // otherwise, really copy/convert the string
    // NOTE we pass -1 as 4th parameter of MultiByteToWideChar for DBCS support

    if (cch != 0)
    {
        UINT cchTemp = 0;
        if (MultiByteToWideChar(CP_ACP, 0, (LPSTR)sz, -1, bstrRet, cch+1) == 0)
        {
            return(HRESULT_FROM_WIN32(GetLastError()));
        }

        // If there are some DBCS characters in the sz(Input), then, the character count of BSTR(DWORD) is 
        // already set to cch(strlen(sz)) in SysAllocStringLen(NULL, cch), we cannot change the count, 
        // and later call of SysStringLen(bstr) always returns the number of characters specified in the
        // cch parameter at allocation time.  Bad, because one DBCS character(2 bytes) will convert
        // to one UNICODE character(2 bytes), not 2 UNICODE characters(4 bytes).
        // Example: For input sz contains only one DBCS character, we want to see SysStringLen(bstr) 
        // = 1, not 2.
        bstrRet[cch] = 0;
        cchTemp = wcslen(bstrRet);
        if (cchTemp < cch)
        {
            BSTR bstrTemp = SysAllocString(bstrRet);
            SysFreeString(bstrRet);
            bstrRet = bstrTemp;    
            cch = cchTemp;
        }
    }

    bstrRet[cch] = 0;
    *pbstrRet = bstrRet;

    return(NOERROR);
}

HRESULT CCertMapperMethod::Init( 
    LPCWSTR  pszMetabasePath 
    )
{
    UINT cL;

    cL = wcslen( pszMetabasePath );
    while ( cL && pszMetabasePath[cL-1] != L'/' && pszMetabasePath[cL-1] != L'\\' )
    {
        --cL;
    }
    if ( m_pszMetabasePath = (LPWSTR)malloc( cL*sizeof(WCHAR) + sizeof(L"<nsepm>") ) )
    {
        memcpy( m_pszMetabasePath, pszMetabasePath, cL * sizeof(WCHAR) );
        memcpy( m_pszMetabasePath + cL, L"<nsepm>", sizeof(L"<nsepm>") );
    }
    else
    {
        return E_OUTOFMEMORY;
    }

    return S_OK;
}


HRESULT CCertMapperMethod::SetVariantAsByteArray(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
    )
{
    SAFEARRAYBOUND  rgsabound[1];
    BYTE *          pbData = NULL;

    // Set the variant type of the output parameter

    V_VT(pvarReturn) = VT_ARRAY|VT_UI1;
    V_ARRAY(pvarReturn) = NULL;

    // Allocate a SafeArray for the data

    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = cbLen;

    V_ARRAY(pvarReturn) = SafeArrayCreate(VT_UI1, 1, rgsabound);
    if (V_ARRAY(pvarReturn) == NULL)
    {
        return E_OUTOFMEMORY;
    }

    if (FAILED(SafeArrayAccessData(V_ARRAY(pvarReturn), (void **) &pbData)))
    {
        return E_UNEXPECTED;
    }

    memcpy(pbData, pbIn, cbLen );

    SafeArrayUnaccessData(V_ARRAY(pvarReturn));

    return NOERROR;
}


HRESULT CCertMapperMethod::SetVariantAsBSTR(
    VARIANT*    pvarReturn, 
    DWORD       cbLen,
    LPBYTE      pbIn 
    )
{
    V_VT(pvarReturn) = VT_BSTR;
    return SetBSTR( &V_BSTR(pvarReturn), cbLen, pbIn );
}


HRESULT CCertMapperMethod::SetVariantAsLong(
    VARIANT*    pvarReturn, 
    DWORD       dwV
    )
{
    V_VT(pvarReturn) = VT_I4;
    V_I4(pvarReturn) = dwV;

    return S_OK;
}

HRESULT CCertMapperMethod::OpenAdminBaseKey(
    LPWSTR pszPathName,
    DWORD dwAccessType
    )
{
    if(m_hmd)
        CloseAdminBaseKey();
    
    HRESULT t_hr = m_pIABase->OpenKey( 
        METADATA_MASTER_ROOT_HANDLE,
        pszPathName,
        dwAccessType,
        METABASE_TIMEOUT,       // 5 seconds
        &m_hmd 
        );
    
    if(t_hr == ERROR_PATH_BUSY)     // retry one time
        t_hr = m_pIABase->OpenKey( 
            METADATA_MASTER_ROOT_HANDLE,
            pszPathName,
            dwAccessType,
            METABASE_TIMEOUT,       // 5 seconds
            &m_hmd 
            );

    if(FAILED(t_hr))
        m_hmd = NULL;

    return t_hr;
}


VOID CCertMapperMethod::CloseAdminBaseKey()
{
    if(m_hmd && m_pIABase)
    {
        m_pIABase->CloseKey(m_hmd);
        m_hmd = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\enum.h ===
#ifndef _enum_h_
#define _enum_h_


class CEnum
{
public:
    CEnum();
    ~CEnum();
    void Init(IWbemObjectSink FAR*, CWbemServices*, ParsedObjectPath*, LPWSTR, WMI_ASSOCIATION*);
    void Recurse(LPCWSTR, enum_KEY_TYPE, LPCWSTR, LPCWSTR, enum_KEY_TYPE);

private:
    bool ContinueRecurse(enum_KEY_TYPE, enum_KEY_TYPE);
    void SetObjectPath(LPCWSTR, LPCWSTR, IWbemClassObject*);
    void DoPing(LPCWSTR, LPCWSTR, LPCWSTR);
    void PingAssociation(LPCWSTR);
    void PingObject();
    void DoPingAdminACL(enum_KEY_TYPE, LPCWSTR, LPCWSTR);
    void PingAssociationAdminACL(LPCWSTR);
    void EnumACE(LPCWSTR);
    void DoPingIPSecurity(enum_KEY_TYPE, LPCWSTR, LPCWSTR);
    void PingAssociationIPSecurity(LPCWSTR);
    
    CMetabase             m_metabase;
    CWbemInstanceMgr*     m_pInstMgr;
    CWbemServices*        m_pNamespace;
    WMI_ASSOCIATION*      m_pAssociation;
    ParsedObjectPath*     m_pParsedObject;
    METADATA_HANDLE       m_hKey;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\enum.cpp ===
//***************************************************************************
//
//  ENUM.CPP
//
//  Module: WBEM Instance provider
//
//  Purpose: Enumerate metabase tree
//
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************


#include "iisprov.h"


///////////////////////////////////////
//
// CEnum class
//
///////////////////////////////////////

CEnum::CEnum()
{
    m_pInstMgr        = NULL;
    m_pNamespace      = NULL;
    m_pAssociation    = NULL;
    m_pParsedObject   = NULL;
    m_hKey            = NULL;
}

CEnum::~CEnum()
{
    if(m_hKey)
        m_metabase.CloseKey(m_hKey);

    if(m_pInstMgr)
        delete m_pInstMgr;
}

void CEnum::Init(
    IWbemObjectSink FAR*    a_pHandler,
    CWbemServices*          a_pNamespace,
    ParsedObjectPath*       a_pParsedObject,
    LPWSTR                  a_pszKey,
    WMI_ASSOCIATION*        a_pAssociation
    )
{
    if (!a_pHandler || !a_pNamespace || !a_pParsedObject)
        throw WBEM_E_FAILED;

    m_pInstMgr = new CWbemInstanceMgr(a_pHandler);
    THROW_ON_FALSE(m_pInstMgr);

    m_pNamespace      = a_pNamespace;
    m_pAssociation    = a_pAssociation;
    m_pParsedObject   = a_pParsedObject;

    m_hKey = m_metabase.OpenKey(a_pszKey, false);  // read only
}

void CEnum::SetObjectPath(
    LPCWSTR              a_pszPropertyName,
    LPCWSTR              a_pszObjectPath,
    IWbemClassObject*    a_pObj
    )
{
    _bstr_t t_bstr(a_pszPropertyName);
    _variant_t t_v(a_pszObjectPath);

    HRESULT t_hr = a_pObj->Put(t_bstr, 0, &t_v, 0);
    THROW_ON_ERROR(t_hr);
}

void CEnum::PingObject()
{
    IWbemClassObject* t_pObj = NULL;

    try 
    {    
        CUtils obj;
        HRESULT hr = obj.GetObjectAsync(m_pNamespace, &t_pObj, m_pParsedObject, m_metabase);
        if(SUCCEEDED(hr) && t_pObj)
        {
            m_pInstMgr->Indicate(t_pObj);
            t_pObj->Release();
        }
    }
    catch(...)
    {
    }
}

void CEnum::PingAssociation(
    LPCWSTR a_pszLeftKeyPath
    )
{
    HRESULT              t_hr;
    IWbemClassObject*    t_pObj = NULL;
    IWbemClassObject*    t_pClass = NULL;
    LPWSTR               t_pszObjectPath = NULL;
    CObjectPathParser    t_PathParser(e_ParserAcceptRelativeNamespace);
    WCHAR                t_LeftName[20];
    WCHAR                t_RightName[20];

    if(m_pAssociation->at == at_ElementSetting)
    {
        lstrcpyW(t_LeftName, L"Element");
        lstrcpyW(t_RightName, L"Setting");        
    }
    else if(m_pAssociation->at == at_Component)
    {
        lstrcpyW(t_LeftName, L"GroupComponent");
        lstrcpyW(t_RightName, L"PartComponent");
    }
    else
        return;

    try 
    {    
        t_hr = m_pNamespace->GetObject(
            m_pAssociation->pszAssociationName,
            0, 
            NULL, 
            &t_pClass, 
            NULL
            );
        THROW_ON_ERROR(t_hr);

        t_hr = t_pClass->SpawnInstance(0, &t_pObj);
        t_pClass->Release();
        THROW_ON_ERROR(t_hr);

        //
        // first right side
        //
        if (!m_pParsedObject->SetClassName(m_pAssociation->pcRight->pszClassName))
            throw WBEM_E_FAILED;

        if (t_PathParser.Unparse(m_pParsedObject,&t_pszObjectPath))
            throw WBEM_E_FAILED;

        SetObjectPath(t_RightName, t_pszObjectPath, t_pObj);

        if(t_pszObjectPath)
        {
            delete [] t_pszObjectPath;
            t_pszObjectPath = NULL;
        }

        //
        // then left side
        //
        if (m_pAssociation->at == at_Component || m_pAssociation->fFlags & ASSOC_EXTRAORDINARY)
        {
            // clear keyref first
            m_pParsedObject->ClearKeys();
     
            // add a keyref
            _variant_t t_vt;            
            if(m_pAssociation->pcLeft->eKeyType == IIsComputer)
                t_vt = L"LM";              // IIsComputer.Name = "LM"
            else
                t_vt = a_pszLeftKeyPath;

            THROW_ON_FALSE(m_pParsedObject->AddKeyRef(m_pAssociation->pcLeft->pszKeyName,&t_vt));
        }

        if (!m_pParsedObject->SetClassName(m_pAssociation->pcLeft->pszClassName))
            throw WBEM_E_FAILED;

        if (t_PathParser.Unparse(m_pParsedObject,&t_pszObjectPath))
            throw WBEM_E_FAILED;

        SetObjectPath(t_LeftName, t_pszObjectPath, t_pObj);
 
        if(t_pszObjectPath)
        {
            delete [] t_pszObjectPath;
            t_pszObjectPath = NULL;
        }
   
        if(t_pObj)
        {
            m_pInstMgr->Indicate(t_pObj);
            t_pObj->Release();
            t_pObj = NULL;
        }
    }
    catch (...)   
    {
        if(t_pszObjectPath)
            delete [] t_pszObjectPath;

        if(t_pObj)
            t_pObj->Release();
    }
}

void CEnum::DoPing(
    LPCWSTR a_pszKeyName,
    LPCWSTR a_pszKeyPath,
    LPCWSTR a_pszParentKeyPath
    )
{
    // add keyref
    _variant_t t_v(a_pszKeyPath);
    THROW_ON_FALSE(m_pParsedObject->AddKeyRef(a_pszKeyName,&t_v));

    // ping
    if (!m_pAssociation) 
        PingObject();
    else
        PingAssociation(a_pszParentKeyPath);
 
    // clear keyref
    m_pParsedObject->ClearKeys();
}

void CEnum::Recurse(
    LPCWSTR         a_pszMetabasePath,
    enum_KEY_TYPE   a_eParentKeyType,
    LPCWSTR         a_pszLeftPath,
    LPCWSTR         a_pszKeyName,
    enum_KEY_TYPE   a_eKeyType
    )
{
    DWORD   t_i = 0;
    HRESULT t_hr;
    WCHAR   t_szSubKey[METADATA_MAX_NAME_LEN];
    enum_KEY_TYPE  t_eSubKeyType;

    do 
    {
        t_eSubKeyType = a_eKeyType;

        t_hr = m_metabase.EnumKeys(
                m_hKey,
                a_pszMetabasePath,
                t_szSubKey,
                &t_i,
                t_eSubKeyType
                );
        t_i++;

        if( t_hr == ERROR_SUCCESS)
        {
            _bstr_t t_bstrMetabasePath;
            if(a_pszMetabasePath)
            {
                t_bstrMetabasePath = a_pszMetabasePath;
                t_bstrMetabasePath += L"/";
            }
            t_bstrMetabasePath += t_szSubKey;

            if( t_eSubKeyType == a_eKeyType &&
                !( m_pAssociation && 
                   (m_pAssociation->at == at_Component || m_pAssociation->fFlags & ASSOC_EXTRAORDINARY) && 
                   m_pAssociation->pcLeft->eKeyType != a_eParentKeyType
                   )
                )
            {
                DoPing(a_pszKeyName, t_bstrMetabasePath, a_pszLeftPath);
            }
            else if( a_eKeyType == TYPE_AdminACL ||   // AdminACL
                     a_eKeyType == TYPE_AdminACE
                     )
            {
                if( !(m_pAssociation &&
                      m_pAssociation->at == at_AdminACL && 
                      m_pAssociation->pcLeft->eKeyType != t_eSubKeyType &&
                      lstrcmpiW(m_pAssociation->pszAssociationName, L"IIs_AdminACL_ACE")
                      )
                    )
                {
                    DoPingAdminACL(a_eKeyType, a_pszKeyName, t_bstrMetabasePath);
                }
            }
            else if( a_eKeyType == TYPE_IPSecurity )   // IPSecurity
            {
                if( !(m_pAssociation &&
                      m_pAssociation->at == at_IPSecurity && 
                      m_pAssociation->pcLeft->eKeyType != t_eSubKeyType
                      )
                    )
                {
                    DoPingIPSecurity(a_eKeyType, a_pszKeyName, t_bstrMetabasePath);
                }
            }
            
            // recusive
            if(ContinueRecurse(t_eSubKeyType, a_eKeyType))
            {
                LPCWSTR t_pszLeftPath = a_pszLeftPath;

                // if the association is extraordinary (see schema.h for explanation)
                if (m_pAssociation && m_pAssociation->fFlags & ASSOC_EXTRAORDINARY)
                {
                    // When the left endpoint of the assoc. is found freeze the
                    // parent key type and path.
                    if (a_pszLeftPath != NULL || (a_eParentKeyType == IIsComputer && a_eParentKeyType == m_pAssociation->pcLeft->eKeyType))
                    {
                        t_eSubKeyType = a_eParentKeyType; 
                    }
                    if (t_eSubKeyType == m_pAssociation->pcLeft->eKeyType && a_pszLeftPath == NULL)
                    {
                        t_pszLeftPath = t_bstrMetabasePath;
                    }

                }
                else
                {
                    // this is the parent path, because the next thing we are doing is
                    // calling recurse.
                    t_pszLeftPath = t_bstrMetabasePath;
                }
                Recurse(t_bstrMetabasePath, t_eSubKeyType, t_pszLeftPath, a_pszKeyName, a_eKeyType);
            }
        }

    }while(t_hr == ERROR_SUCCESS);
}

// DESC: You are looking for a_eKeyType by traversing thru the tree. You are
//       currently at a_eParentKeyType and need to determine if you should keep
//       on going.
// COMM: This seems very similar to CMetabase::CheckKey
bool CEnum::ContinueRecurse(
    enum_KEY_TYPE  a_eParentKeyType,
    enum_KEY_TYPE  a_eKeyType
    )
{
    bool bRet = false;

    switch(a_eKeyType)
    {
    case IIsLogModule:
        if( a_eParentKeyType == IIsLogModules )
            bRet = true;
        break;

    case IIsFtpInfo:
        if( a_eParentKeyType == IIsFtpService )
            bRet = true;
        break;

    case IIsFtpServer:
         if( a_eParentKeyType == IIsFtpService )
            bRet = true;
        break;

    case IIsFtpVirtualDir:
        if( a_eParentKeyType == IIsFtpService ||
            a_eParentKeyType == IIsFtpServer ||
            a_eParentKeyType == IIsFtpVirtualDir
            )
            bRet = true;
        break;

    case IIsWebInfo:
        if( a_eParentKeyType == IIsWebService )
            bRet = true;
        break;

    case IIsFilters:
        if( a_eParentKeyType == IIsWebService ||
            a_eParentKeyType == IIsWebServer
            )
            bRet = true;
        break;

    case IIsFilter:
        if( a_eParentKeyType == IIsWebService ||
            a_eParentKeyType == IIsWebServer ||
            a_eParentKeyType == IIsFilters 
            )
            bRet = true;
        break;

    case IIsCompressionSchemes:
        if( a_eParentKeyType == IIsWebService ||
            a_eParentKeyType == IIsWebServer ||
            a_eParentKeyType == IIsFilters 
            )
            bRet = true;
        break;

    case IIsCompressionScheme:
        if( a_eParentKeyType == IIsWebService ||
            a_eParentKeyType == IIsWebServer ||
            a_eParentKeyType == IIsFilters ||
            a_eParentKeyType == IIsCompressionSchemes )
            bRet = true;
        break;

    case IIsWebServer:
        if( a_eParentKeyType == IIsWebService )
            bRet = true;
        break;

    case IIsCertMapper:
        if( a_eParentKeyType == IIsWebService ||
            a_eParentKeyType == IIsWebServer 
            )
            bRet = true;
        break;

    case IIsWebVirtualDir:
        if( a_eParentKeyType == IIsWebService ||
            a_eParentKeyType == IIsWebServer ||
            a_eParentKeyType == IIsWebVirtualDir ||
            a_eParentKeyType == IIsWebDirectory
            )
            bRet = true;
        break;

    case IIsWebDirectory:
        if( a_eParentKeyType == IIsWebService ||
            a_eParentKeyType == IIsWebServer ||
            a_eParentKeyType == IIsWebVirtualDir ||
            a_eParentKeyType == IIsWebDirectory
            )
            bRet = true;
        break;

    case IIsWebFile:
        if( a_eParentKeyType == IIsWebService ||
            a_eParentKeyType == IIsWebServer ||
            a_eParentKeyType == IIsWebVirtualDir ||
            a_eParentKeyType == IIsWebDirectory
            )
            bRet = true;
        break;

    case TYPE_AdminACL:
    case TYPE_AdminACE:
        if( a_eParentKeyType == IIsWebService ||
            a_eParentKeyType == IIsWebServer ||
            a_eParentKeyType == IIsWebVirtualDir ||
            a_eParentKeyType == IIsWebDirectory ||
            a_eParentKeyType == IIsFtpService ||
            a_eParentKeyType == IIsFtpServer ||
            a_eParentKeyType == IIsFtpVirtualDir
            )
            bRet = true;
        break;

    case TYPE_IPSecurity:
        if( a_eParentKeyType == IIsWebService ||
            a_eParentKeyType == IIsWebServer ||
            a_eParentKeyType == IIsWebVirtualDir ||
            a_eParentKeyType == IIsWebDirectory ||
            a_eParentKeyType == IIsFtpService ||
            a_eParentKeyType == IIsFtpServer ||
            a_eParentKeyType == IIsFtpVirtualDir
            )
            bRet = true;
        break;

    default:
        break;
    }

    return bRet;
}

void CEnum::DoPingAdminACL(
    enum_KEY_TYPE  a_eKeyType,
    LPCWSTR a_pszKeyName,
    LPCWSTR a_pszKeyPath
    )
{
    // add keyref
    _variant_t t_v(a_pszKeyPath);
    THROW_ON_FALSE(m_pParsedObject->AddKeyRef(a_pszKeyName,&t_v));

    if(a_eKeyType == TYPE_AdminACE)
    {
        EnumACE(a_pszKeyPath);
    }
    else if(a_eKeyType == TYPE_AdminACL)
    {
        // ping
        if (!m_pAssociation) 
            PingObject();
        else
            PingAssociationAdminACL(a_pszKeyPath);
    }
    
    // clear keyref
    m_pParsedObject->ClearKeys();
}


// for AdminACL
void CEnum::EnumACE(
    LPCWSTR pszKeyPath
    )
{
    HRESULT hr = S_OK;
    _variant_t var;
    IEnumVARIANT* pEnum = NULL;
    ULONG   lFetch;
    BSTR    bstrTrustee;
    IDispatch* pDisp = NULL;
    IADsAccessControlEntry* pACE = NULL;
    _bstr_t bstrMbPath;
    WMI_CLASS* pWMIClass;

    // get the metabase path of the object
    BOOL fClass = FALSE;
    if(m_pAssociation)
        fClass = CUtils::GetClass(m_pAssociation->pcLeft->pszClassName,&pWMIClass);
    else
        fClass = CUtils::GetClass(m_pParsedObject->m_pClass,&pWMIClass);
    
    if(!fClass)
        return;

    CUtils::GetMetabasePath(NULL,m_pParsedObject,pWMIClass,bstrMbPath);
   
    // open ADSI
    CAdminACL objACL;
    hr = objACL.OpenSD(bstrMbPath);
    if(SUCCEEDED(hr))
        hr = objACL.GetACEEnum(&pEnum);
    if ( FAILED(hr) )
        return;

    //////////////////////////////////////////////
    // Enumerate ACEs
    //////////////////////////////////////////////
    hr = pEnum->Next( 1, &var, &lFetch );
    while( hr == S_OK )
    {
        if ( lFetch == 1 )
        {
            if ( VT_DISPATCH != V_VT(&var) )
            {
                break;
            }

            pDisp = V_DISPATCH(&var);

            /////////////////////////////
            // Get the individual ACE
            /////////////////////////////
            hr = pDisp->QueryInterface( 
                IID_IADsAccessControlEntry, 
                (void**)&pACE 
                ); 

            if ( SUCCEEDED(hr) )
            {
                hr = pACE->get_Trustee(&bstrTrustee);

                if( SUCCEEDED(hr) )
                {
                    // add keyref
                    _variant_t t_v(bstrTrustee);
                    //m_pParsedObject->RemoveKeyRef(L"Trustee");
                    THROW_ON_FALSE(m_pParsedObject->AddKeyRefEx(L"Trustee",&t_v));

                    // ping
                    if (!m_pAssociation) 
                        PingObject();
                    else
                        PingAssociationAdminACL(pszKeyPath);
                }

                SysFreeString(bstrTrustee);
                pACE->Release();
            }
        }

        hr = pEnum->Next( 1, &var, &lFetch );
    }

    pEnum->Release();    
}


void CEnum::PingAssociationAdminACL(
    LPCWSTR a_pszLeftKeyPath
    )
{
    HRESULT              t_hr;
    IWbemClassObject*    t_pObj = NULL;
    IWbemClassObject*    t_pClass = NULL;
    LPWSTR               t_pszObjectPath = NULL;
    CObjectPathParser    t_PathParser(e_ParserAcceptRelativeNamespace);
    WCHAR                t_LeftName[20];
    WCHAR                t_RightName[20];
    _bstr_t              bstrMbPath;
    WMI_CLASS*           pWMIClass;


    if(m_pAssociation->at != at_AdminACL)
        return;

    // get the metabase path of the object
    if (CUtils::GetClass(m_pAssociation->pcLeft->pszClassName,&pWMIClass))
    {
        CUtils::GetMetabasePath(NULL,m_pParsedObject,pWMIClass,bstrMbPath);
    }
    else
        return;

    // check if AdminACL existed
    CAdminACL objACL;
    t_hr = objACL.OpenSD(bstrMbPath);
    objACL.CloseSD();
    if(FAILED(t_hr))
        return;
    
    // set the key name
    lstrcpyW(t_LeftName, L"GroupComponent");
    lstrcpyW(t_RightName, L"PartComponent");        

    try 
    {    
        t_hr = m_pNamespace->GetObject(
            m_pAssociation->pszAssociationName,
            0, 
            NULL, 
            &t_pClass, 
            NULL
            );
        THROW_ON_ERROR(t_hr);

        t_hr = t_pClass->SpawnInstance(0, &t_pObj);
        t_pClass->Release();
        THROW_ON_ERROR(t_hr);

        //
        // first right side
        //
        if (!m_pParsedObject->SetClassName(m_pAssociation->pcRight->pszClassName))
            throw WBEM_E_FAILED;

        if (t_PathParser.Unparse(m_pParsedObject,&t_pszObjectPath))
            throw WBEM_E_FAILED;

        SetObjectPath(t_RightName, t_pszObjectPath, t_pObj);

        if(t_pszObjectPath)
        {
            delete [] t_pszObjectPath;
            t_pszObjectPath = NULL;
        }

        //
        // then left side
        //
        if(!lstrcmpiW(m_pAssociation->pszAssociationName, L"IIs_AdminACL_ACE"))
        {
            // clear keyref first
            m_pParsedObject->ClearKeys();
     
            // add a keyref
            _variant_t t_vt = a_pszLeftKeyPath;
            THROW_ON_FALSE(m_pParsedObject->AddKeyRef(m_pAssociation->pcLeft->pszKeyName,&t_vt));
        }

        if (!m_pParsedObject->SetClassName(m_pAssociation->pcLeft->pszClassName))
            throw WBEM_E_FAILED;

        if (t_PathParser.Unparse(m_pParsedObject,&t_pszObjectPath))
            throw WBEM_E_FAILED;

        SetObjectPath(t_LeftName, t_pszObjectPath, t_pObj);
 
        if(t_pszObjectPath)
        {
            delete [] t_pszObjectPath;
            t_pszObjectPath = NULL;
        }
   
        if(t_pObj)
        {
            m_pInstMgr->Indicate(t_pObj);
            t_pObj->Release();
            t_pObj = NULL;
        }
    }
    catch (...)   
    {
        if(t_pszObjectPath)
            delete [] t_pszObjectPath;

        if(t_pObj)
            t_pObj->Release();
    }
}


// for IPSecurity
void CEnum::DoPingIPSecurity(
    enum_KEY_TYPE  a_eKeyType,
    LPCWSTR a_pszKeyName,
    LPCWSTR a_pszKeyPath
    )
{
    // add keyref
    _variant_t t_v(a_pszKeyPath);
    THROW_ON_FALSE(m_pParsedObject->AddKeyRef(a_pszKeyName,&t_v));

    // ping
    if (!m_pAssociation) 
        PingObject();
    else
        PingAssociationIPSecurity(a_pszKeyPath);
    
    // clear keyref
    m_pParsedObject->ClearKeys();
}

// for IPSecurity
void CEnum::PingAssociationIPSecurity(
    LPCWSTR a_pszLeftKeyPath
    )
{
    HRESULT              t_hr;
    IWbemClassObject*    t_pObj = NULL;
    IWbemClassObject*    t_pClass = NULL;
    LPWSTR               t_pszObjectPath = NULL;
    CObjectPathParser    t_PathParser(e_ParserAcceptRelativeNamespace);
    WCHAR                t_LeftName[20];
    WCHAR                t_RightName[20];
    _bstr_t              bstrMbPath;
    WMI_CLASS*           pWMIClass;


    if(m_pAssociation->at != at_IPSecurity)
        return;

    // get the metabase path of the object
    if (CUtils::GetClass(m_pAssociation->pcLeft->pszClassName,&pWMIClass))
    {
        CUtils::GetMetabasePath(NULL,m_pParsedObject,pWMIClass,bstrMbPath);
    }
    else
        return;

    // check if IPSecurity existed
    CIPSecurity objIPsec;
    t_hr = objIPsec.OpenSD(bstrMbPath);
    objIPsec.CloseSD();
    if(FAILED(t_hr))
        return;
    
    // set the key name
    lstrcpyW(t_LeftName, L"Element");
    lstrcpyW(t_RightName, L"Setting");        

    try 
    {    
        t_hr = m_pNamespace->GetObject(
            m_pAssociation->pszAssociationName,
            0, 
            NULL, 
            &t_pClass, 
            NULL
            );
        THROW_ON_ERROR(t_hr);

        t_hr = t_pClass->SpawnInstance(0, &t_pObj);
        t_pClass->Release();
        THROW_ON_ERROR(t_hr);

        //
        // first right side
        //
        if (!m_pParsedObject->SetClassName(m_pAssociation->pcRight->pszClassName))
            throw WBEM_E_FAILED;

        if (t_PathParser.Unparse(m_pParsedObject,&t_pszObjectPath))
            throw WBEM_E_FAILED;

        SetObjectPath(t_RightName, t_pszObjectPath, t_pObj);

        if(t_pszObjectPath)
        {
            delete [] t_pszObjectPath;
            t_pszObjectPath = NULL;
        }

        //
        // then left side
        //
        if (!m_pParsedObject->SetClassName(m_pAssociation->pcLeft->pszClassName))
            throw WBEM_E_FAILED;

        if (t_PathParser.Unparse(m_pParsedObject,&t_pszObjectPath))
            throw WBEM_E_FAILED;

        SetObjectPath(t_LeftName, t_pszObjectPath, t_pObj);
 
        if(t_pszObjectPath)
        {
            delete [] t_pszObjectPath;
            t_pszObjectPath = NULL;
        }
   
        if(t_pObj)
        {
            m_pInstMgr->Indicate(t_pObj);
            t_pObj->Release();
            t_pObj = NULL;
        }
    }
    catch (...)   
    {
        if(t_pszObjectPath)
            delete [] t_pszObjectPath;

        if(t_pObj)
            t_pObj->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\globdata.cpp ===
#include "iisprov.h"

#define ALL_BITS_ON 0xFFFFFFFF

///
// initialize METABASE_PROPERTY_DATA
//
METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AccessExecute =
    { L"AccessExecute",MD_ACCESS_PERM, IIS_MD_UT_FILE, DWORD_METADATA, MD_ACCESS_EXECUTE, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AccessFlags =
    { L"AccessFlags",MD_ACCESS_PERM, IIS_MD_UT_FILE, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AccessNoRemoteExecute =
    { L"AccessNoRemoteExecute",MD_ACCESS_PERM, IIS_MD_UT_FILE, DWORD_METADATA, MD_ACCESS_NO_REMOTE_EXECUTE, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AccessNoRemoteRead =
    { L"AccessNoRemoteRead",MD_ACCESS_PERM, IIS_MD_UT_FILE, DWORD_METADATA, MD_ACCESS_NO_REMOTE_READ, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AccessNoRemoteScript =
    { L"AccessNoRemoteScript",MD_ACCESS_PERM, IIS_MD_UT_FILE, DWORD_METADATA, MD_ACCESS_NO_REMOTE_SCRIPT, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AccessNoRemoteWrite =
    { L"AccessNoRemoteWrite",MD_ACCESS_PERM, IIS_MD_UT_FILE, DWORD_METADATA, MD_ACCESS_NO_REMOTE_WRITE, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AccessRead =
    { L"AccessRead",MD_ACCESS_PERM, IIS_MD_UT_FILE, DWORD_METADATA, MD_ACCESS_READ, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AccessSource =
    { L"AccessSource",MD_ACCESS_PERM, IIS_MD_UT_FILE, DWORD_METADATA, MD_ACCESS_SOURCE, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AccessScript =
    { L"AccessScript",MD_ACCESS_PERM, IIS_MD_UT_FILE, DWORD_METADATA, MD_ACCESS_SCRIPT, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AccessSSL =
    { L"AccessSSL",MD_SSL_ACCESS_PERM, IIS_MD_UT_FILE, DWORD_METADATA, MD_ACCESS_SSL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AccessSSL128 =
    { L"AccessSSL128",MD_SSL_ACCESS_PERM, IIS_MD_UT_FILE, DWORD_METADATA, MD_ACCESS_SSL128, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AccessSSLFlags =
    { L"AccessSSLFlags",MD_SSL_ACCESS_PERM, IIS_MD_UT_FILE, DWORD_METADATA, MD_ACCESS_SSL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AccessSSLMapCert =
    { L"AccessSSLMapCert",MD_SSL_ACCESS_PERM, IIS_MD_UT_FILE, DWORD_METADATA, MD_ACCESS_MAP_CERT, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AccessSSLNegotiateCert =
    { L"AccessSSLNegotiateCert",MD_SSL_ACCESS_PERM, IIS_MD_UT_FILE, DWORD_METADATA, MD_ACCESS_NEGO_CERT, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AccessSSLRequireCert =
    { L"AccessSSLRequireCert",MD_SSL_ACCESS_PERM, IIS_MD_UT_FILE, DWORD_METADATA, MD_ACCESS_REQUIRE_CERT, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AccessWrite =
    { L"AccessWrite",MD_ACCESS_PERM, IIS_MD_UT_FILE, DWORD_METADATA, MD_ACCESS_WRITE, METADATA_INHERIT, FALSE };

//METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AdminACL =
//    { L"AdminACL",MD_ADMIN_ACL, IIS_MD_UT_FILE, BINARY_METADATA, NULL, METADATA_INHERIT | METADATA_SECURE, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AdminServer =
    { L"AdminServer",MD_ADMIN_INSTANCE, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AllowAnonymous =
    { L"AllowAnonymous",MD_ALLOW_ANONYMOUS, IIS_MD_UT_SERVER, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AllowKeepAlive =
    { L"AllowKeepAlive",MD_ALLOW_KEEPALIVES, IIS_MD_UT_FILE, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AllowPathInfoForScriptMappings =
    { L"AllowPathInfoForScriptMappings",MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS, IIS_MD_UT_SERVER, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AnonymousOnly =
    { L"AnonymousOnly",MD_ANONYMOUS_ONLY, IIS_MD_UT_SERVER, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AnonymousPasswordSync =
    { L"AnonymousPasswordSync",MD_ANONYMOUS_USE_SUBAUTH, IIS_MD_UT_FILE, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AnonymousUserName =
    { L"AnonymousUserName",MD_ANONYMOUS_USER_NAME, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AnonymousUserPass =
    { L"AnonymousUserPass",MD_ANONYMOUS_PWD, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT | METADATA_SECURE, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AppAllowClientDebug =
    { L"AppAllowClientDebug",MD_ASP_ENABLECLIENTDEBUG, ASP_MD_UT_APP, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AppAllowDebugging =
    { L"AppAllowDebugging",MD_ASP_ENABLESERVERDEBUG, IIS_MD_UT_WAM, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AppFriendlyName =
    { L"AppFriendlyName",MD_APP_FRIENDLY_NAME, IIS_MD_UT_WAM, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AppIsolated =
    { L"AppIsolated",MD_APP_ISOLATED, IIS_MD_UT_WAM, DWORD_METADATA, NULL, METADATA_INHERIT, TRUE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AppOopRecoverLimit =
    { L"AppOopRecoverLimit",MD_APP_OOP_RECOVER_LIMIT, ASP_MD_UT_APP, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AppPackageID =
    { L"AppPackageId",MD_APP_PACKAGE_ID, IIS_MD_UT_WAM, STRING_METADATA, NULL, METADATA_INHERIT, TRUE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AppPackageName =
    { L"AppPackageName",MD_APP_PACKAGE_NAME, IIS_MD_UT_WAM, STRING_METADATA, NULL, METADATA_INHERIT, TRUE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AppRoot =
    { L"AppRoot",MD_APP_ROOT, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT, TRUE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AppWamClsid =
    { L"AppWamClsID",MD_APP_WAM_CLSID, IIS_MD_UT_WAM, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspAllowOutOfProcComponents =
    { L"AspAllowOutOfProcComponents",MD_ASP_ALLOWOUTOFPROCCOMPONENTS, IIS_MD_UT_WAM, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspAllowSessionState =
    { L"AspAllowSessionState",MD_ASP_ALLOWSESSIONSTATE, ASP_MD_UT_APP, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspBufferingOn =
    { L"AspBufferingOn",MD_ASP_BUFFERINGON, ASP_MD_UT_APP, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspCodepage =
    { L"AspCodepage",MD_ASP_CODEPAGE, ASP_MD_UT_APP, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspEnableApplicationRestart =
    { L"AspEnableApplicationRestart",MD_ASP_ENABLEAPPLICATIONRESTART, ASP_MD_UT_APP, DWORD_METADATA, ALL_BITS_ON, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspEnableAspHtmlFallback =
    { L"AspEnableAspHtmlFallback",MD_ASP_ENABLEASPHTMLFALLBACK, ASP_MD_UT_APP, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspEnableChunkedEncoding =
    { L"AspEnableChunkedEncoding",MD_ASP_ENABLECHUNKEDENCODING, ASP_MD_UT_APP, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspEnableParentPaths =
    { L"AspEnableParentPaths",MD_ASP_ENABLEPARENTPATHS, ASP_MD_UT_APP, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspEnableTypelibCache =
    { L"AspEnableTypelibCache",MD_ASP_ENABLETYPELIBCACHE, ASP_MD_UT_APP, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspErrorsToNTLog =
    { L"AspErrorsToNTLog",MD_ASP_ERRORSTONTLOG, ASP_MD_UT_APP, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspExceptionCatchEnable =
    { L"AspExceptionCatchEnable", MD_ASP_EXCEPTIONCATCHENABLE, IIS_MD_UT_WAM, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspLogErrorRequests =
    { L"AspLogErrorRequests",MD_ASP_LOGERRORREQUESTS, IIS_MD_UT_WAM, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspProcessorThreadMax =
    { L"AspProcessorThreadMax",MD_ASP_PROCESSORTHREADMAX, ASP_MD_UT_APP, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspQueueConnectionTestTime =
    { L"AspQueueConnectionTestTime",MD_ASP_QUEUECONNECTIONTESTTIME, ASP_MD_UT_APP, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspQueueTimeout =
    { L"AspQueueTimeout", MD_ASP_QUEUETIMEOUT, ASP_MD_UT_APP, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspRequestQueueMax =
    { L"AspRequestQueueMax", MD_ASP_REQEUSTQUEUEMAX, ASP_MD_UT_APP, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspScriptEngineCacheMax =
    { L"AspScriptEngineCacheMax", MD_ASP_SCRIPTENGINECACHEMAX, IIS_MD_UT_WAM, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspScriptErrorMessage =
    { L"AspScriptErrorMessage", MD_ASP_SCRIPTERRORMESSAGE, IIS_MD_UT_WAM, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspScriptErrorSentToBrowser =
    { L"AspScriptErrorSentToBrowser", MD_ASP_SCRIPTERRORSSENTTOBROWSER, IIS_MD_UT_WAM, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspScriptFileCacheSize =
    { L"AspScriptFileCacheSize",MD_ASP_SCRIPTFILECACHESIZE, IIS_MD_UT_WAM, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspScriptLanguage =
    { L"AspScriptLanguage", MD_ASP_SCRIPTLANGUAGE, ASP_MD_UT_APP, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspScriptTimeout =
    { L"AspScriptTimeout", MD_ASP_SCRIPTTIMEOUT, ASP_MD_UT_APP, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspSessionMax =
    { L"AspSessionMax", MD_ASP_SESSIONMAX, ASP_MD_UT_APP, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspSessionTimeout =
    { L"AspSessionTimeout", MD_ASP_SESSIONTIMEOUT, ASP_MD_UT_APP, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspThreadGateEnabled =
    { L"AspThreadGateEnabled", MD_ASP_THREADGATEENABLED, ASP_MD_UT_APP, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspThreadGateLoadHigh =
    { L"AspThreadGateLoadHigh", MD_ASP_THREADGATELOADHIGH, ASP_MD_UT_APP, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspThreadGateLoadLow =
    { L"AspThreadGateLoadLow", MD_ASP_THREADGATELOADLOW, ASP_MD_UT_APP, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspThreadGateSleepDelay =
    { L"AspThreadGateSleepDelay", MD_ASP_THREADGATESLEEPDELAY, ASP_MD_UT_APP, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspThreadGateSleepMax =
    { L"AspThreadGateSleepMax", MD_ASP_THREADGATESLEEPMAX, ASP_MD_UT_APP, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspThreadGateTimeSlice =
    { L"AspThreadGateTimeSlice", MD_ASP_THREADGATETIMESLICE, ASP_MD_UT_APP, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AspTrackThreadingModel =
    { L"AspTrackThreadingModel", MD_ASP_TRACKTHREADINGMODEL, ASP_MD_UT_APP, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AuthAnonymous =
    { L"AuthAnonymous",MD_AUTHORIZATION, IIS_MD_UT_FILE, DWORD_METADATA, MD_AUTH_ANONYMOUS, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AuthBasic =
    { L"AuthBasic",MD_AUTHORIZATION, IIS_MD_UT_FILE, DWORD_METADATA, MD_AUTH_BASIC, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AuthFlags =
    { L"AuthFlags",MD_AUTHORIZATION, IIS_MD_UT_FILE, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AuthNTLM =
    { L"AuthNTLM",MD_AUTHORIZATION, IIS_MD_UT_FILE, DWORD_METADATA, MD_AUTH_NT, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AuthPersistence =
    { L"AuthPersistence",MD_AUTHORIZATION_PERSISTENCE, IIS_MD_UT_FILE, DWORD_METADATA, NULL};

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AuthPersistSingleRequest =
    { L"AuthPersistSingleRequest",MD_AUTHORIZATION_PERSISTENCE, IIS_MD_UT_FILE, DWORD_METADATA, MD_AUTH_SINGLEREQUEST};

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AuthPersistSingleRequestIfProxy =
    { L"AuthPersistSingleRequestIfProxy",MD_AUTHORIZATION_PERSISTENCE, IIS_MD_UT_FILE, DWORD_METADATA, MD_AUTH_SINGLEREQUESTIFPROXY};

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_AuthPersistSingleRequestAlwaysIfProxy =
    { L"AuthPersistSingleRequestAlwaysIfProxy",MD_AUTHORIZATION_PERSISTENCE, IIS_MD_UT_FILE, DWORD_METADATA, MD_AUTH_SINGLEREQUESTALWAYSIFPROXY};

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CacheControlCustom =
    { L"CacheControlCustom",MD_CC_OTHER, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CacheControlMaxAge =
    { L"CacheControlMaxAge",MD_CC_MAX_AGE, IIS_MD_UT_FILE, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CacheControlNoCache =
    { L"CacheControlNoCache",MD_CC_NO_CACHE, IIS_MD_UT_FILE, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CacheISAPI =
    { L"CacheISAPI",MD_CACHE_EXTENSIONS, IIS_MD_UT_FILE, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CGITimeout =
    { L"CGITimeout",MD_SCRIPT_TIMEOUT, IIS_MD_UT_FILE, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ConnectionTimeout =
    { L"ConnectionTimeout",MD_CONNECTION_TIMEOUT, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ContentIndexed =
    { L"ContentIndexed", MD_IS_CONTENT_INDEXED, IIS_MD_UT_SERVER, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuAppEnabled =
    { L"CpuAppenabled",MD_CPU_APP_ENABLED, IIS_MD_UT_FILE, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuCgiEnabled =
    { L"CpuCgiEnabled",MD_CPU_CGI_ENABLED, IIS_MD_UT_FILE, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuLoggingMask =
    { L"CpuLoggingMask",MD_CPU_LOGGING_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuEnableActiveProcs =
    { L"CpuEnableActiveProcs",MD_CPU_LOGGING_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_CPU_ENABLE_ACTIVE_PROCS, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuEnableAllProcLogging =
    { L"CpuEnableAllProcLogging",MD_CPU_LOGGING_OPTIONS, IIS_MD_UT_SERVER, DWORD_METADATA, MD_CPU_ENABLE_ALL_PROC_LOGGING, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuEnableApplicationLogging =
    { L"CpuEnableApplicationLogging",MD_CPU_LOGGING_OPTIONS, IIS_MD_UT_SERVER, DWORD_METADATA, MD_CPU_ENABLE_APP_LOGGING, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuEnableCgiLogging =
    { L"CpuEnableCgiLogging",MD_CPU_LOGGING_OPTIONS, IIS_MD_UT_SERVER, DWORD_METADATA, MD_CPU_ENABLE_CGI_LOGGING, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuEnableEvent =
    { L"CpuEnableEvent",MD_CPU_LOGGING_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_CPU_ENABLE_EVENT, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuEnableKernelTime =
    { L"CpuEnableKernelTime",MD_CPU_LOGGING_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_CPU_ENABLE_KERNEL_TIME, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuEnableLogging =
    { L"CpuEnableLogging",MD_CPU_LOGGING_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_CPU_ENABLE_LOGGING, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuEnablePageFaults =
    { L"CpuEnablePageFaults",MD_CPU_LOGGING_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_CPU_ENABLE_PAGE_FAULTS, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuEnableProcType =
    { L"CpuEnableProcType",MD_CPU_LOGGING_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_CPU_ENABLE_PROC_TYPE, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuEnableTerminatedProcs =
    { L"CpuEnableTerminatedProcs",MD_CPU_LOGGING_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_CPU_ENABLE_TERMINATED_PROCS, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuEnableTotalProcs =
    { L"CpuEnableTotalProcs",MD_CPU_LOGGING_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_CPU_ENABLE_TOTAL_PROCS, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuEnableUserTime =
    { L"CpuEnableUserTime",MD_CPU_ENABLE_USER_TIME, IIS_MD_UT_SERVER, DWORD_METADATA, MD_CPU_ENABLE_USER_TIME, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuLimitLogEvent =
    { L"CpuLimitLogEvent",MD_CPU_LIMIT_LOGEVENT, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuLimitPause =
    { L"CpuLimitPause",MD_CPU_LIMIT_PAUSE, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuLimitPriority =
    { L"CpuLimitPriority",MD_CPU_LIMIT_PRIORITY, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuLimitProcStop =
    { L"CpuLimitProcStop",MD_CPU_LIMIT_PROCSTOP, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuLimitsEnabled =
    { L"CpuLimitsEnabled",MD_CPU_LIMITS_ENABLED, IIS_MD_UT_SERVER, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuLoggingInterval =
    { L"CpuLoggingInterval",MD_CPU_LOGGING_INTERVAL, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuLoggingOptions =
    { L"CpuLoggingOptions",MD_CPU_LOGGING_OPTIONS, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CpuResetInterval =
    { L"CpuResetInterval",MD_CPU_RESET_INTERVAL, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CreateCGIWithNewConsole =
    { L"CreateCGIWithNewConsole",MD_CREATE_PROC_NEW_CONSOLE, IIS_MD_UT_FILE, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CreateProcessAsUser =
    { L"CreateProcessAsUser",MD_CREATE_PROCESS_AS_USER, IIS_MD_UT_FILE, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_CustomErrorDescriptions =
    { L"CustomErrorDescriptions", MD_CUSTOM_ERROR_DESC, IIS_MD_UT_SERVER, MULTISZ_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_DefaultDoc =
    { L"DefaultDoc",MD_DEFAULT_LOAD_FILE, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_DefaultDocFooter =
    { L"DefaultDocFooter",MD_FOOTER_DOCUMENT, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_DefaultLogonDomain =
    { L"DefaultLogonDomain",MD_DEFAULT_LOGON_DOMAIN, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_DirBrowseFlags =
    { L"DirBrowseFlags", MD_DIRECTORY_BROWSING, IIS_MD_UT_FILE, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_DirBrowseShowDate =
    { L"DirBrowseShowDate",MD_DIRECTORY_BROWSING, IIS_MD_UT_FILE, DWORD_METADATA, MD_DIRBROW_SHOW_DATE, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_DirBrowseShowExtension =
    { L"DirBrowseShowExtension",MD_DIRECTORY_BROWSING, IIS_MD_UT_FILE, DWORD_METADATA, MD_DIRBROW_SHOW_EXTENSION, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_DirBrowseShowLongDate =
    { L"DirBrowseShowLongDate",MD_DIRECTORY_BROWSING, IIS_MD_UT_FILE, DWORD_METADATA, MD_DIRBROW_LONG_DATE, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_DirBrowseShowSize =
    { L"DirBrowseShowSize",MD_DIRECTORY_BROWSING, IIS_MD_UT_FILE, DWORD_METADATA, MD_DIRBROW_SHOW_SIZE, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_DirBrowseShowTime =
    { L"DirBrowseShowTime",MD_DIRECTORY_BROWSING, IIS_MD_UT_FILE, DWORD_METADATA, MD_DIRBROW_SHOW_TIME, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_DirectoryLevelsToScan =
    { L"DirectoryLevelsToScan",MD_LEVELS_TO_SCAN, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_DisableSocketPooling =
    { L"DisableSocketPooling",MD_DISABLE_SOCKET_POOLING, IIS_MD_UT_SERVER, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_DontLog =
    { L"DontLog",MD_DONT_LOG, IIS_MD_UT_FILE, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_DownlevelAdminInstance =
    { L"DownlevelAdminInstance",MD_DOWNLEVEL_ADMIN_INSTANCE, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_EnableDefaultDoc =
    { L"EnableDefaultDoc",MD_DIRECTORY_BROWSING, IIS_MD_UT_FILE, DWORD_METADATA, MD_DIRBROW_LOADDEFAULT, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_EnableDirBrowsing =
    { L"EnableDirBrowsing",MD_DIRECTORY_BROWSING, IIS_MD_UT_FILE, DWORD_METADATA, MD_DIRBROW_ENABLED, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_EnableDocFooter =
    { L"EnableDocFooter",MD_FOOTER_ENABLED, IIS_MD_UT_FILE, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_EnableReverseDns =
    { L"EnableReverseDns",MD_DO_REVERSE_DNS, IIS_MD_UT_FILE, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ExitMessage =
    { L"ExitMessage",MD_EXIT_MESSAGE, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_FilterDescription =
    { L"FilterDescription",MD_FILTER_DESCRIPTION, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_FilterEnabled =
    { L"FilterEnabled",MD_FILTER_ENABLED, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_FilterFlags =
    { L"FilterFlags",MD_FILTER_FLAGS, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_FilterLoadOrder =
    { L"FilterLoadOrder",MD_FILTER_LOAD_ORDER, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_FilterPath =
    { L"FilterPath",MD_FILTER_IMAGE_PATH, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_FilterState =
    { L"FilterState",MD_FILTER_STATE, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_FrontPageWeb =
    { L"FrontPageWeb",MD_FRONTPAGE_WEB, IIS_MD_UT_SERVER, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_GreetingMessage =
    { L"GreetingMessage",MD_GREETING_MESSAGE, IIS_MD_UT_SERVER, MULTISZ_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_HcCompressionDll =
    { L"HcCompressionDll",MD_HC_COMPRESSION_DLL, IIS_MD_UT_SERVER, EXPANDSZ_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_HcCreateFlags =
    { L"HcCreateFlags",MD_HC_CREATE_FLAGS, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_HcDoDynamicCompression =
    { L"HcDoDynamicCompression",MD_HC_DO_DYNAMIC_COMPRESSION, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_HcDoOnDemandCompression =
    { L"HcDoOnDemandCompression",MD_HC_DO_ON_DEMAND_COMPRESSION, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_HcDoStaticCompression =
    { L"HcDoStaticCompression",MD_HC_DO_STATIC_COMPRESSION, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_HcDynamicCompressionLevel =
    { L"HcDynamicCompressionLevel",MD_HC_DYNAMIC_COMPRESSION_LEVEL, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_HcFileExtensions =
    { L"HcFileExtensions",MD_HC_FILE_EXTENSIONS, IIS_MD_UT_SERVER, MULTISZ_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_HcMimeType =
    { L"HcMimeType",MD_HC_MIME_TYPE, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_HcOnDemandCompLevel =
    { L"HcOnDemandCompLevel",MD_HC_ON_DEMAND_COMP_LEVEL, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_HcPriority =
    { L"HcPriority",MD_HC_PRIORITY, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_HcScriptFileExtensions =
    { L"HcScriptFileExtensions",MD_HC_SCRIPT_FILE_EXTENSIONS, IIS_MD_UT_SERVER, MULTISZ_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_HttpCustomHeaders =
    { L"HttpCustomHeaders",MD_HTTP_CUSTOM, IIS_MD_UT_FILE, MULTISZ_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_HttpErrors =
    { L"HttpErrors",MD_CUSTOM_ERROR, IIS_MD_UT_FILE, MULTISZ_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_HttpExpires =
    { L"HttpExpires",MD_HTTP_EXPIRES, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_HttpPics =
    { L"HttpPics",MD_HTTP_PICS, IIS_MD_UT_FILE, MULTISZ_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_HttpRedirect =
    { L"HttpRedirect",MD_HTTP_REDIRECT, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_InProcessIsapiApps =
    { L"InProcessIsapiApps",MD_SERVER_STATE, IIS_MD_UT_SERVER, MULTISZ_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

//METABASE_PROPERTY METABASE_PROPERTY_DATA::s_IPSecurity =
//    { L"IPSecurity",MD_IP_SEC, IIS_MD_UT_FILE, BINARY_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogAnonymous =
    { L"LogAnonymous",MD_LOG_ANONYMOUS, IIS_MD_UT_SERVER, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogCustomPropertyDataType =
    { L"LogCustomPropertyDataType",MD_LOGCUSTOM_PROPERTY_DATATYPE, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogCustomPropertyHeader =
    { L"LogCustomPropertyHeader",MD_LOGCUSTOM_PROPERTY_HEADER, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogCustomPropertyID =
    { L"LogCustomPropertyID",MD_LOGCUSTOM_PROPERTY_ID, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogCustomPropertyMask =
    { L"LogCustomPropertyMask",MD_LOGCUSTOM_PROPERTY_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogCustomPropertyName =
    { L"LogCustomPropertyName",MD_LOGCUSTOM_PROPERTY_NAME, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogCustomPropertyServicesString =
    { L"LogCustomPropertyServicesString",MD_LOGCUSTOM_SERVICES_STRING, IIS_MD_UT_SERVER, MULTISZ_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileBytesRecv =
    { L"LogExtFileBytesRecv",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_BYTES_RECV, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileBytesSent =
    { L"LogExtFileBytesSent",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_BYTES_SENT, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileClientIp =
    {L"LogExtFileClientIp",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_CLIENT_IP, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileComputerName =
    { L"LogExtFileComputerName",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_COMPUTER_NAME, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileCookie =
    { L"LogExtFileCookie",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_COOKIE, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileDate =
    { L"LogExtFileDate",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_DATE, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileFlags =
    { L"LogExtFileFlags",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_FILE, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileHttpStatus =
    { L"LogExtFileHttpStatus",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_HTTP_STATUS, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileMethod =
    { L"LogExtFileMethod",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_METHOD, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileProtocolVersion =
    { L"LogExtFileProtocolVersion",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_PROTOCOL_VERSION, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileReferer =
    { L"LogExtFileReferer",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_REFERER, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileServerIp =
    { L"LogExtFileServerIp",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_SERVER_IP, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileServerPort =
    { L"LogExtFileServerPort",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_SERVER_PORT, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileSiteName =
    { L"LogExtFileSiteName",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_SITE_NAME, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileTime =
    { L"LogExtFileTime",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_TIME, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileTimeTaken =
    { L"LogExtFileTimeTaken",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_TIME_TAKEN, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileUriQuery =
    { L"LogExtFileUriquery",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_URI_QUERY, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileUriStem =
    { L"LogExtFileUriStem",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_URI_STEM, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileUserAgent =
    { L"LogExtFileUserAgent",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_USER_AGENT, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileUserName =
    { L"LogExtFileUserName",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_USERNAME, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogExtFileWin32Status =
    { L"LogExtFileWin32Status",MD_LOGEXT_FIELD_MASK, IIS_MD_UT_SERVER, DWORD_METADATA, MD_EXTLOG_WIN32_STATUS, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogFileDirectory =
    { L"LogFileDirectory",MD_LOGFILE_DIRECTORY, IIS_MD_UT_SERVER, EXPANDSZ_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogFileLocaltimeRollover =
    { L"LogFileLocaltimeRollover",MD_LOGFILE_LOCALTIME_ROLLOVER, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogFilePeriod =
    { L"LogFilePeriod",MD_LOGFILE_PERIOD, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogFileTruncateSize =
    { L"LogFileTruncateSize",MD_LOGFILE_TRUNCATE_SIZE, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogModuleId =
    { L"LogModuleId", MD_LOG_PLUGIN_MOD_ID, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogModuleUiId =
    { L"LogModuleUiId", MD_LOG_PLUGIN_UI_ID, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogModuleList =
    { L"LogModuleList", MD_LOG_PLUGINS_AVAILABLE, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogNonAnonymous =
    { L"LogNonAnonymous",MD_LOG_NONANONYMOUS, IIS_MD_UT_SERVER, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogOdbcDataSource =
    { L"LogOdbcDataSource",MD_LOGSQL_DATA_SOURCES, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogOdbcPassword =
    { L"LogOdbcPassword",MD_LOGSQL_PASSWORD, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_INHERIT | METADATA_SECURE, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogOdbcTableName =
    { L"LogOdbcTableName",MD_LOGSQL_TABLE_NAME, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogOdbcUserName =
    { L"LogOdbcUserName",MD_LOGSQL_USER_NAME, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogonMethod =
    { L"LogonMethod",MD_LOGON_METHOD, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogPluginClsId =
    { L"LogPluginClsId",MD_LOG_PLUGIN_ORDER, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_LogType =
    { L"LogType",MD_LOG_TYPE, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_MaxBandwidth =
    { L"MaxBandwidth",MD_MAX_BANDWIDTH, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_MaxBandwidthBlocked =
    { L"MaxBandwidthBlocked",MD_MAX_BANDWIDTH_BLOCKED, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_MaxClientsMessage =
    { L"MaxClientsMessage",MD_MAX_CLIENTS_MESSAGE, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_MaxConnections =
    { L"MaxConnections",MD_MAX_CONNECTIONS, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_MaxEndpointConnections =
    { L"MaxEndpointConnections",MD_MAX_ENDPOINT_CONNECTIONS, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_MimeMap =
    { L"MimeMap",MD_MIME_MAP, IIS_MD_UT_FILE, MULTISZ_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_MSDOSDirOutput =
    { L"MSDOSDirOutput",MD_MSDOS_DIR_OUTPUT, IIS_MD_UT_SERVER, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_NetLogonWorkstation =
    { L"NetLogonWorkstation",MD_NET_LOGON_WKS, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_NotDeletable =
    { L"NotDeletable",MD_NOT_DELETABLE, IIS_MD_UT_SERVER, DWORD_METADATA, ALL_BITS_ON, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_NotifyAccessDenied =
    { L"NotifyAccessDenied",MD_FILTER_FLAGS, IIS_MD_UT_SERVER, DWORD_METADATA, MD_NOTIFY_ACCESS_DENIED, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_NotifyAuthentication =
    { L"NotifyAuthentication",MD_FILTER_FLAGS, IIS_MD_UT_SERVER, DWORD_METADATA, MD_NOTIFY_AUTHENTICATION, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_NotifyEndOfNetSession =
    { L"NotifyEndOfNetSession",MD_FILTER_FLAGS, IIS_MD_UT_SERVER, DWORD_METADATA, MD_NOTIFY_END_OF_NET_SESSION, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_NotifyEndOfRequest =
    { L"NotifyEndOfRequest",MD_FILTER_FLAGS, IIS_MD_UT_SERVER, DWORD_METADATA, MD_NOTIFY_END_OF_REQUEST, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_NotifyLog =
    { L"NotifyLog",MD_FILTER_FLAGS, IIS_MD_UT_SERVER, DWORD_METADATA, MD_NOTIFY_LOG, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_NotifyNonSecurePort =
    { L"NotifyNonSecurePort",MD_FILTER_FLAGS, IIS_MD_UT_SERVER, DWORD_METADATA, MD_NOTIFY_NONSECURE_PORT, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_NotifyOrderHigh =
    { L"NotifyOrderHigh",MD_FILTER_FLAGS, IIS_MD_UT_SERVER, DWORD_METADATA, MD_NOTIFY_ORDER_HIGH, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_NotifyOrderLow =
    { L"NotifyOrderLow",MD_FILTER_FLAGS, IIS_MD_UT_SERVER, DWORD_METADATA, MD_NOTIFY_ORDER_LOW, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_NotifyOrderMedium =
    { L"NotifyOrderMedium",MD_FILTER_FLAGS, IIS_MD_UT_SERVER, DWORD_METADATA, MD_NOTIFY_ORDER_MEDIUM, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_NotifyPreProcHeaders =
    { L"NotifyPreProcHeaders",MD_FILTER_FLAGS, IIS_MD_UT_SERVER, DWORD_METADATA, MD_NOTIFY_PREPROC_HEADERS, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_NotifyReadRawData =
    { L"NotifyReadRawData",MD_FILTER_FLAGS, IIS_MD_UT_SERVER, DWORD_METADATA, MD_NOTIFY_READ_RAW_DATA, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_NotifySecurePort =
    { L"NotifySecurePort",MD_FILTER_FLAGS, IIS_MD_UT_SERVER, DWORD_METADATA, MD_NOTIFY_SECURE_PORT, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_NotifySendRawData =
    { L"NotifySendRawData",MD_FILTER_FLAGS, IIS_MD_UT_SERVER, DWORD_METADATA, MD_NOTIFY_SEND_RAW_DATA, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_NotifySendResponse =
    { L"NotifySendResponse",MD_FILTER_FLAGS, IIS_MD_UT_SERVER, DWORD_METADATA, MD_NOTIFY_SEND_RESPONSE, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_NotifyUrlMap =
    { L"NotifyUrlMap",MD_FILTER_FLAGS, IIS_MD_UT_SERVER, DWORD_METADATA, MD_NOTIFY_URL_MAP, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_NTAuthenticationProviders =
    { L"NTAuthenticationProviders",MD_NTAUTHENTICATION_PROVIDERS, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_PasswordCacheTTL =
    { L"PasswordCacheTTL", MD_ADV_CACHE_TTL, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_PasswordChangeFlags =
    { L"PasswordChangeFlags", MD_AUTH_CHANGE_FLAGS, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_PasswordExpirePrenotifyDays =
    { L"PasswordExpirePrenotifyDays", MD_ADV_NOTIFY_PWD_EXP_IN_DAYS, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_Path =
    { L"Path", MD_VR_PATH, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_PoolIDCTimeout =
    { L"PoolIDCTimeout", MD_POOL_IDC_TIMEOUT, IIS_MD_UT_FILE, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ProcessNTCRIfLoggedOn =
    { L"ProcessNTCRIfLoggedOn", MD_PROCESS_NTCR_IF_LOGGED_ON, IIS_MD_UT_SERVER, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_PutReadSize =
    { L"PutReadSize", MD_PUT_READ_SIZE, IIS_MD_UT_FILE, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_Realm =
    { L"Realm", MD_REALM, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_RedirectHeaders =
    { L"RedirectHeaders", MD_REDIRECT_HEADERS, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ScriptMaps =
    { L"ScriptMaps", MD_SCRIPT_MAPS, IIS_MD_UT_FILE, MULTISZ_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ServerAutoStart =
    { L"ServerAutoStart", MD_SERVER_AUTOSTART, IIS_MD_UT_SERVER, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_SecureBindings =
    { L"SecureBindings",MD_SECURE_BINDINGS, IIS_MD_UT_SERVER, MULTISZ_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ServerBindings =
    { L"ServerBindings",MD_SERVER_BINDINGS, IIS_MD_UT_SERVER, MULTISZ_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ServerComment =
    { L"ServerComment",MD_SERVER_COMMENT, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ServerConfigAutoPWSync =
    { L"ServerConfigAutoPWSync",MD_SERVER_CONFIGURATION_INFO, IIS_MD_UT_SERVER, DWORD_METADATA, MD_SERVER_CONFIG_AUTO_PW_SYNC, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ServerConfigFlags =
    { L"ServerConfigFlags",MD_SERVER_CONFIGURATION_INFO, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ServerConfigSSL128 =
    { L"ServerConfigSSL128",MD_SERVER_CONFIGURATION_INFO, IIS_MD_UT_SERVER, DWORD_METADATA, MD_SERVER_CONFIG_SSL_128, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ServerConfigSSL40 =
    { L"ServerConfigSSL40",MD_SERVER_CONFIGURATION_INFO, IIS_MD_UT_SERVER, DWORD_METADATA, MD_SERVER_CONFIG_SSL_40, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ServerConfigSSLAllowEncrypt =
    { L"ServerConfigSSLAllowEncrypt",MD_SERVER_CONFIGURATION_INFO, IIS_MD_UT_SERVER, DWORD_METADATA, MD_SERVER_CONFIG_ALLOW_ENCRYPT, METADATA_NO_ATTRIBUTES, FALSE };

// custom property: ServerID
METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ServerID =
    { L"ServerID",0, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ServerListenBacklog =
    { L"ServerListenBacklog",MD_SERVER_LISTEN_BACKLOG, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ServerListenTimeout =
    { L"ServerListenTimeout",MD_SERVER_LISTEN_TIMEOUT, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ServerSize =
    { L"ServerSize",MD_SERVER_SIZE, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_ServerState =
    { L"ServerState",MD_SERVER_STATE, IIS_MD_UT_SERVER, DWORD_METADATA, NULL, METADATA_NO_ATTRIBUTES, TRUE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_SSIExecDisable =
    { L"SSIExecDisable",MD_SSI_EXEC_DISABLED, IIS_MD_UT_FILE, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_UNCAuthenticationPassthrough =
    { L"UNCAuthenticationPassthrough", MD_VR_PASSTHROUGH, IIS_MD_UT_FILE, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_UNCPassword =
    { L"UNCPassword", MD_VR_PASSWORD, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT | METADATA_SECURE, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_UNCUserName =
    { L"UNCUserName", MD_VR_USERNAME, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_FtpDirBrowseShowLongDate =
    { L"FtpDirBrowseShowLongDate", MD_SHOW_4_DIGIT_YEAR, IIS_MD_UT_FILE, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_UploadReadAheadSize =
    { L"UploadReadAheadSize", MD_UPLOAD_READAHEAD_SIZE, IIS_MD_UT_FILE, DWORD_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_UseHostName =
    { L"UseHostName", MD_USE_HOST_NAME, IIS_MD_UT_SERVER, DWORD_METADATA, ALL_BITS_ON, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_WAMUserName =
    { L"WamUserName", MD_WAM_USER_NAME, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_WAMUserPass =
    { L"WamUserPass", MD_WAM_PWD, IIS_MD_UT_FILE, STRING_METADATA, NULL, METADATA_INHERIT | METADATA_SECURE, FALSE };

METABASE_PROPERTY METABASE_PROPERTY_DATA::s_KeyType =
    { L"", MD_KEY_TYPE, IIS_MD_UT_SERVER, STRING_METADATA, NULL, METADATA_NO_ATTRIBUTES, FALSE };


METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpComputerSettings[] = 
{
    &s_MaxBandwidth,
    &s_MaxBandwidthBlocked,
    &s_MimeMap,
    NULL
    };


METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpComputer[] = 
{
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpMimeMapSetting[] = 
{
    &s_MimeMap,
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpLogModuleSetting[] = 
{
    &s_LogModuleId,
    &s_LogModuleUiId,
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpCustomLogModuleSetting[] = 
{
    &s_LogCustomPropertyDataType,
    &s_LogCustomPropertyHeader,
    &s_LogCustomPropertyID,
    &s_LogCustomPropertyMask,
    &s_LogCustomPropertyName,
    &s_LogCustomPropertyServicesString,
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpCompressionSchemeSetting[] = 
{
    &s_HcCompressionDll,
    &s_HcCreateFlags,
    &s_HcDoDynamicCompression,
    &s_HcDoOnDemandCompression,
    &s_HcDoStaticCompression,
    &s_HcDynamicCompressionLevel,
    &s_HcFileExtensions,
    &s_HcMimeType,
    &s_HcOnDemandCompLevel,
    &s_HcPriority,
    &s_HcScriptFileExtensions,
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpFtpService[] = 
{
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpFtpInfoSetting[] = 
{
    &s_LogModuleList,
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpFtpServer[] = 
{
    &s_ServerState,
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpFtpVirtualDir[] = 
{
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpFtpVirtualDirSettings[] = 
{
    &s_AccessFlags,
    &s_AccessRead,
    &s_AccessWrite,
    &s_DontLog,
    &s_FtpDirBrowseShowLongDate,
    &s_Path,
    &s_UNCPassword,
    &s_UNCUserName,
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpFtpServiceSettings[] = 
{
    &s_LogExtFileFlags,
    &s_AccessFlags,
    &s_AccessRead,
    &s_AccessWrite,
    &s_DontLog,
    &s_FtpDirBrowseShowLongDate,
    &s_AllowAnonymous,
    &s_AnonymousOnly,
    &s_AnonymousPasswordSync,
    &s_AnonymousUserName,
    &s_AnonymousUserPass,
    &s_ConnectionTimeout,
    &s_DefaultLogonDomain,
    &s_DisableSocketPooling,
    &s_ExitMessage,
    &s_GreetingMessage,
    &s_LogAnonymous,
    &s_LogExtFileBytesRecv,
    &s_LogExtFileBytesSent,
    &s_LogExtFileClientIp,
    &s_LogExtFileComputerName,
    &s_LogExtFileCookie,
    &s_LogExtFileDate,
    &s_LogExtFileHttpStatus,
    &s_LogExtFileMethod,
    &s_LogExtFileProtocolVersion,
    &s_LogExtFileReferer,
    &s_LogExtFileServerIp,
    &s_LogExtFileServerPort,
    &s_LogExtFileSiteName,
    &s_LogExtFileTime,
    &s_LogExtFileTimeTaken,
    &s_LogExtFileUriQuery,
    &s_LogExtFileUriStem,
    &s_LogExtFileUserAgent,
    &s_LogExtFileUserName,
    &s_LogExtFileWin32Status,
    &s_LogFileDirectory,
    &s_LogFileLocaltimeRollover,
    &s_LogFilePeriod,
    &s_LogFileTruncateSize,
    &s_LogNonAnonymous,
    &s_LogOdbcDataSource,
    &s_LogOdbcPassword,
    &s_LogOdbcTableName,
    &s_LogOdbcUserName,
    &s_LogPluginClsId,
    &s_LogType,
    &s_MaxClientsMessage,
    &s_MaxConnections,
    &s_MaxEndpointConnections,
    &s_MSDOSDirOutput,
    &s_Realm,
    &s_ServerAutoStart,
    &s_ServerBindings,
    &s_ServerComment,
    &s_ServerListenBacklog,
    &s_ServerListenTimeout,
    &s_ServerSize,
    &s_DirectoryLevelsToScan,
    &s_DownlevelAdminInstance,
//    &s_AdminACL,
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpFtpServerSettings[] = 
{
    &s_LogExtFileFlags,
    &s_AccessFlags,
    &s_AccessRead,
    &s_AccessWrite,
    &s_DontLog,
    &s_FtpDirBrowseShowLongDate,
    &s_AllowAnonymous,
    &s_AnonymousOnly,
    &s_AnonymousPasswordSync,
    &s_AnonymousUserName,
    &s_AnonymousUserPass,
    &s_ConnectionTimeout,
    &s_DefaultLogonDomain,
    &s_DisableSocketPooling,
    &s_ExitMessage,
    &s_GreetingMessage,
    &s_LogAnonymous,
    &s_LogExtFileBytesRecv,
    &s_LogExtFileBytesSent,
    &s_LogExtFileClientIp,
    &s_LogExtFileComputerName,
    &s_LogExtFileCookie,
    &s_LogExtFileDate,
    &s_LogExtFileHttpStatus,
    &s_LogExtFileMethod,
    &s_LogExtFileProtocolVersion,
    &s_LogExtFileReferer,
    &s_LogExtFileServerIp,
    &s_LogExtFileServerPort,
    &s_LogExtFileSiteName,
    &s_LogExtFileTime,
    &s_LogExtFileTimeTaken,
    &s_LogExtFileUriQuery,
    &s_LogExtFileUriStem,
    &s_LogExtFileUserAgent,
    &s_LogExtFileUserName,
    &s_LogExtFileWin32Status,
    &s_LogFileDirectory,
    &s_LogFileLocaltimeRollover,
    &s_LogFilePeriod,
    &s_LogFileTruncateSize,
    &s_LogNonAnonymous,
    &s_LogOdbcDataSource,
    &s_LogOdbcPassword,
    &s_LogOdbcTableName,
    &s_LogOdbcUserName,
    &s_LogPluginClsId,
    &s_LogType,
    &s_MaxClientsMessage,
    &s_MaxConnections,
    &s_MaxEndpointConnections,
    &s_MSDOSDirOutput,
    &s_Realm,
    &s_ServerAutoStart,
    &s_ServerBindings,
    &s_ServerComment,
    &s_ServerListenBacklog,
    &s_ServerListenTimeout,
    &s_ServerSize,
//    &s_AdminACL,
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpWebService[] = 
{
    &s_AdminServer,
    &s_AppPackageName,
    &s_AppIsolated,
    &s_AppWamClsid,
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpWebInfoSetting[] = 
{
    &s_ServerConfigFlags,
    &s_CustomErrorDescriptions,
    &s_LogModuleList,
    &s_ServerConfigAutoPWSync,
    &s_ServerConfigSSL128,
    &s_ServerConfigSSL40,
    &s_ServerConfigSSLAllowEncrypt,
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpWebFilter[] = 
{
    &s_FilterFlags,
    &s_FilterDescription,
    &s_FilterEnabled,
    &s_FilterPath,
    &s_FilterState,
    &s_NotifyAuthentication,
    &s_NotifyEndOfNetSession,
    &s_NotifyEndOfRequest,
    &s_NotifyLog,
    &s_NotifyNonSecurePort,
    &s_NotifyOrderHigh,
    &s_NotifyOrderLow,
    &s_NotifyOrderMedium,
    &s_NotifyPreProcHeaders,
    &s_NotifyReadRawData,
    &s_NotifySecurePort,
    &s_NotifySendRawData,
    &s_NotifySendResponse,
    &s_NotifyUrlMap,
    &s_NotifyAccessDenied,
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpWebServer[] = 
{
    &s_ServerState,
    &s_AppPackageName,
    &s_AppIsolated,
    &s_AppWamClsid,
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpWebCertMapper[] = 
{
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpWebVirtualDir[] = 
{
    &s_AppIsolated,
    &s_AppPackageName,
    &s_AppWamClsid,
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpWebDirectory[] = 
{
    &s_AppIsolated,
    &s_AppPackageName,
    &s_AppWamClsid,
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpWebFile[] = 
{
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpWebServiceSettings[] = 
{
    &s_CpuLoggingOptions,
    &s_CpuLoggingMask,            
    &s_LogExtFileFlags,
    &s_AuthFlags,
    &s_AuthPersistence,
    &s_AccessFlags,
    &s_AccessSSLFlags,
    &s_DirBrowseFlags,
    &s_AccessExecute,
    &s_AccessNoRemoteExecute,
    &s_AccessNoRemoteRead,
    &s_AccessNoRemoteScript,
    &s_AccessNoRemoteWrite,
    &s_AccessRead,
    &s_AccessScript,
    &s_AccessSSL,                        
    &s_AccessSSL128,
    &s_AccessSSLMapCert,
    &s_AccessSSLNegotiateCert,
    &s_AccessSSLRequireCert,
    &s_AccessWrite,
    &s_AnonymousPasswordSync,
    &s_AnonymousUserName,
    &s_AnonymousUserPass,
    &s_AuthAnonymous,
    &s_AuthBasic,
    &s_AuthNTLM,
    &s_AuthPersistSingleRequest,
    &s_AuthPersistSingleRequestAlwaysIfProxy,
    &s_AuthPersistSingleRequestIfProxy,
    &s_CacheControlCustom,
    &s_CacheControlMaxAge,
    &s_CacheControlNoCache,
    &s_CGITimeout,
    &s_CpuAppEnabled,
    &s_CpuCgiEnabled,
    &s_CreateCGIWithNewConsole,
    &s_CreateProcessAsUser,
    &s_DefaultDocFooter,
    &s_DefaultLogonDomain,
    &s_DontLog,
    &s_EnableDocFooter,
    &s_EnableReverseDns,
    &s_HttpCustomHeaders,
    &s_HttpErrors,
    &s_HttpExpires,
    &s_HttpPics,
    &s_HttpRedirect,
    &s_LogonMethod,
    &s_MimeMap,
    &s_PoolIDCTimeout,            
    &s_PutReadSize,            
    &s_Realm,                    
    &s_RedirectHeaders,            
    &s_ScriptMaps,
    &s_SSIExecDisable,
    &s_UNCAuthenticationPassthrough,
    &s_UploadReadAheadSize, 
    &s_AppAllowClientDebug,
    &s_AppAllowDebugging,
    &s_AppFriendlyName,
    &s_AppPackageID,
    &s_AppRoot,
    &s_AspAllowOutOfProcComponents,
    &s_AspAllowSessionState, 
    &s_AspBufferingOn,
    &s_AspCodepage, 
    &s_AspEnableApplicationRestart,
    &s_AspEnableAspHtmlFallback,
    &s_AspEnableChunkedEncoding,
    &s_AspEnableParentPaths,
    &s_AspEnableTypelibCache,
    &s_AspErrorsToNTLog,
    &s_AspExceptionCatchEnable, 
    &s_AspLogErrorRequests, 
    &s_AspProcessorThreadMax,
    &s_AspQueueConnectionTestTime,
    &s_AspQueueTimeout,
    &s_AspRequestQueueMax,
    &s_AspScriptEngineCacheMax,
    &s_AspScriptErrorMessage,
    &s_AspScriptErrorSentToBrowser,
    &s_AspScriptFileCacheSize,
    &s_AspScriptLanguage,
    &s_AspScriptTimeout,
    &s_AspSessionMax,
    &s_AspSessionTimeout,
    &s_AspThreadGateEnabled,
    &s_AspThreadGateLoadHigh,
    &s_AspThreadGateLoadLow,
    &s_AspThreadGateSleepDelay, 
    &s_AspThreadGateSleepMax,
    &s_AspThreadGateTimeSlice,
    &s_AspTrackThreadingModel,
    &s_CacheISAPI,                    
    &s_ContentIndexed,
    &s_DefaultDoc,
    &s_DirBrowseShowDate,
    &s_DirBrowseShowExtension,
    &s_DirBrowseShowLongDate,
    &s_DirBrowseShowSize,
    &s_DirBrowseShowTime,
    &s_EnableDefaultDoc,
    &s_EnableDirBrowsing,
    &s_AccessSource,
    &s_AllowKeepAlive,
    &s_AllowPathInfoForScriptMappings,
    &s_CGITimeout,
    &s_ConnectionTimeout,
    &s_CpuEnableActiveProcs,
    &s_CpuEnableAllProcLogging,        
    &s_CpuEnableApplicationLogging, 
    &s_CpuEnableCgiLogging,
    &s_CpuEnableEvent,
    &s_CpuEnableKernelTime,
    &s_CpuEnableLogging,
    &s_CpuEnablePageFaults,
    &s_CpuEnableProcType,
    &s_CpuEnableTerminatedProcs,    
    &s_CpuEnableTotalProcs,
    &s_CpuEnableUserTime,            
    &s_CpuLimitLogEvent,            
    &s_CpuLimitPause,
    &s_CpuLimitPriority,            
    &s_CpuLimitProcStop,
    &s_CpuLimitsEnabled,
    &s_CpuLoggingInterval,  
    &s_CpuResetInterval,
    &s_LogExtFileBytesRecv,
    &s_LogExtFileBytesSent,
    &s_LogExtFileClientIp,
    &s_LogExtFileComputerName,
    &s_LogExtFileCookie,
    &s_LogExtFileDate,
    &s_LogExtFileHttpStatus,
    &s_LogExtFileMethod,
    &s_LogExtFileProtocolVersion,
    &s_LogExtFileReferer,
    &s_LogExtFileServerIp,
    &s_LogExtFileServerPort,
    &s_LogExtFileSiteName,
    &s_LogExtFileTime,
    &s_LogExtFileTimeTaken,
    &s_LogExtFileUriQuery,
    &s_LogExtFileUriStem,
    &s_LogExtFileUserAgent,
    &s_LogExtFileUserName,
    &s_LogExtFileWin32Status,
    &s_LogFileDirectory,
    &s_LogFileLocaltimeRollover,
    &s_LogFilePeriod,
    &s_LogFileTruncateSize,
    &s_LogOdbcDataSource,
    &s_LogOdbcPassword,
    &s_LogOdbcTableName,
    &s_LogOdbcUserName,
    &s_LogPluginClsId,
    &s_LogType,
    &s_MaxConnections,  
    &s_MaxEndpointConnections,    
    &s_NetLogonWorkstation,        
    &s_NTAuthenticationProviders,
    &s_PasswordCacheTTL,        
    &s_PasswordChangeFlags,        
    &s_PasswordExpirePrenotifyDays,
    &s_ProcessNTCRIfLoggedOn,
    &s_ServerAutoStart,
    &s_ServerBindings,
    &s_ServerComment,
    &s_ServerListenBacklog,
    &s_ServerListenTimeout,
    &s_ServerSize,
    &s_UseHostName, 
    &s_InProcessIsapiApps,
    &s_WAMUserName, 
    &s_WAMUserPass,
    &s_DirectoryLevelsToScan,
    &s_DownlevelAdminInstance,
//    &s_AdminACL,
//    &s_IPSecurity,
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpWebServerSettings[] = 
{
    &s_CpuLoggingOptions,
    &s_CpuLoggingMask,            
    &s_LogExtFileFlags,
    &s_AuthFlags,
    &s_AuthPersistence,
    &s_AccessFlags,
    &s_AccessSSLFlags,
    &s_DirBrowseFlags,
    &s_AccessExecute,
    &s_AccessNoRemoteExecute,
    &s_AccessNoRemoteRead,
    &s_AccessNoRemoteScript,
    &s_AccessNoRemoteWrite,
    &s_AccessRead,
    &s_AccessScript,
    &s_AccessSSL,                        
    &s_AccessSSL128,
    &s_AccessSSLMapCert,
    &s_AccessSSLNegotiateCert,
    &s_AccessSSLRequireCert,
    &s_AccessWrite,
    &s_AnonymousPasswordSync,
    &s_AnonymousUserName,
    &s_AnonymousUserPass,
    &s_AuthAnonymous,
    &s_AuthBasic,
    &s_AuthNTLM,
    &s_AuthPersistSingleRequest,
    &s_AuthPersistSingleRequestAlwaysIfProxy,
    &s_AuthPersistSingleRequestIfProxy,
    &s_CacheControlCustom,
    &s_CacheControlMaxAge,
    &s_CacheControlNoCache,
    &s_CGITimeout,
    &s_CpuAppEnabled,
    &s_CpuCgiEnabled,
    &s_CreateCGIWithNewConsole,
    &s_CreateProcessAsUser,
    &s_DefaultDocFooter,
    &s_DefaultLogonDomain,
    &s_DontLog,
    &s_EnableDocFooter,
    &s_EnableReverseDns,
    &s_HttpCustomHeaders,
    &s_HttpErrors,
    &s_HttpExpires,
    &s_HttpPics,
    &s_HttpRedirect,
    &s_LogonMethod,
    &s_MimeMap,
    &s_PoolIDCTimeout,            
    &s_PutReadSize,            
    &s_Realm,                    
    &s_RedirectHeaders,            
    &s_ScriptMaps,
    &s_SSIExecDisable,
    &s_UNCAuthenticationPassthrough,
    &s_UploadReadAheadSize, 
    &s_AppAllowClientDebug,
    &s_AppAllowDebugging,
    &s_AppFriendlyName,
    &s_AppPackageID,
    &s_AppRoot,
    &s_AspAllowOutOfProcComponents,
    &s_AspAllowSessionState, 
    &s_AspBufferingOn,
    &s_AspCodepage, 
    &s_AspEnableApplicationRestart,
    &s_AspEnableAspHtmlFallback,
    &s_AspEnableChunkedEncoding,
    &s_AspEnableParentPaths,
    &s_AspEnableTypelibCache,
    &s_AspErrorsToNTLog,
    &s_AspExceptionCatchEnable, 
    &s_AspLogErrorRequests, 
    &s_AspProcessorThreadMax,
    &s_AspQueueConnectionTestTime,
    &s_AspQueueTimeout,
    &s_AspRequestQueueMax,
    &s_AspScriptEngineCacheMax,
    &s_AspScriptErrorMessage,
    &s_AspScriptErrorSentToBrowser,
    &s_AspScriptFileCacheSize,
    &s_AspScriptLanguage,
    &s_AspScriptTimeout,
    &s_AspSessionMax,
    &s_AspSessionTimeout,
    &s_AspThreadGateEnabled,
    &s_AspThreadGateLoadHigh,
    &s_AspThreadGateLoadLow,
    &s_AspThreadGateSleepDelay, 
    &s_AspThreadGateSleepMax,
    &s_AspThreadGateTimeSlice,
    &s_AspTrackThreadingModel,
    &s_CacheISAPI,                    
    &s_ContentIndexed,
    &s_DefaultDoc,
    &s_DirBrowseShowDate,
    &s_DirBrowseShowExtension,
    &s_DirBrowseShowLongDate,
    &s_DirBrowseShowSize,
    &s_DirBrowseShowTime,
    &s_EnableDefaultDoc,
    &s_EnableDirBrowsing,
    &s_AccessSource,
    &s_AllowKeepAlive,
    &s_AllowPathInfoForScriptMappings,
    &s_CGITimeout,
    &s_ConnectionTimeout,
    &s_CpuEnableActiveProcs,
    &s_CpuEnableAllProcLogging,        
    &s_CpuEnableApplicationLogging, 
    &s_CpuEnableCgiLogging,
    &s_CpuEnableEvent,
    &s_CpuEnableKernelTime,
    &s_CpuEnableLogging,
    &s_CpuEnablePageFaults,
    &s_CpuEnableProcType,
    &s_CpuEnableTerminatedProcs,    
    &s_CpuEnableTotalProcs,
    &s_CpuEnableUserTime,            
    &s_CpuLimitLogEvent,            
    &s_CpuLimitPause,
    &s_CpuLimitPriority,            
    &s_CpuLimitProcStop,
    &s_CpuLimitsEnabled,
    &s_CpuLoggingInterval,  
    &s_CpuResetInterval,
    &s_LogExtFileBytesRecv,
    &s_LogExtFileBytesSent,
    &s_LogExtFileClientIp,
    &s_LogExtFileComputerName,
    &s_LogExtFileCookie,
    &s_LogExtFileDate,
    &s_LogExtFileHttpStatus,
    &s_LogExtFileMethod,
    &s_LogExtFileProtocolVersion,
    &s_LogExtFileReferer,
    &s_LogExtFileServerIp,
    &s_LogExtFileServerPort,
    &s_LogExtFileSiteName,
    &s_LogExtFileTime,
    &s_LogExtFileTimeTaken,
    &s_LogExtFileUriQuery,
    &s_LogExtFileUriStem,
    &s_LogExtFileUserAgent,
    &s_LogExtFileUserName,
    &s_LogExtFileWin32Status,
    &s_LogFileDirectory,
    &s_LogFileLocaltimeRollover,
    &s_LogFilePeriod,
    &s_LogFileTruncateSize,
    &s_LogOdbcDataSource,
    &s_LogOdbcPassword,
    &s_LogOdbcTableName,
    &s_LogOdbcUserName,
    &s_LogPluginClsId,
    &s_LogType,
    &s_MaxConnections,  
    &s_MaxEndpointConnections,    
    &s_NetLogonWorkstation,        
    &s_NTAuthenticationProviders,
    &s_PasswordCacheTTL,        
    &s_PasswordChangeFlags,        
    &s_PasswordExpirePrenotifyDays,
    &s_ProcessNTCRIfLoggedOn,
    &s_ServerAutoStart,
    &s_ServerBindings,
    &s_ServerComment,
    &s_ServerListenBacklog,
    &s_ServerListenTimeout,
    &s_ServerSize,
    &s_UseHostName, 
    &s_AppOopRecoverLimit,    
    &s_MaxBandwidth,
    &s_MaxBandwidthBlocked,
    &s_NotDeletable,
    &s_SecureBindings,
    &s_ServerID,
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpWebVirtualDirSettings[] = 
{
    &s_AuthFlags,
    &s_AuthPersistence,
    &s_AccessFlags,
    &s_AccessSSLFlags,
    &s_DirBrowseFlags,
    &s_AccessExecute,
    &s_AccessNoRemoteExecute,
    &s_AccessNoRemoteRead,
    &s_AccessNoRemoteScript,
    &s_AccessNoRemoteWrite,
    &s_AccessRead,
    &s_AccessScript,
    &s_AccessSSL,                        
    &s_AccessSSL128,
    &s_AccessSSLMapCert,
    &s_AccessSSLNegotiateCert,
    &s_AccessSSLRequireCert,
    &s_AccessWrite,
    &s_AnonymousPasswordSync,
    &s_AnonymousUserName,
    &s_AnonymousUserPass,
    &s_AuthAnonymous,
    &s_AuthBasic,
    &s_AuthNTLM,
    &s_AuthPersistSingleRequest,
    &s_AuthPersistSingleRequestAlwaysIfProxy,
    &s_AuthPersistSingleRequestIfProxy,
    &s_CacheControlCustom,
    &s_CacheControlMaxAge,
    &s_CacheControlNoCache,
    &s_CGITimeout,
    &s_CpuAppEnabled,
    &s_CpuCgiEnabled,
    &s_CreateCGIWithNewConsole,
    &s_CreateProcessAsUser,
    &s_DefaultDocFooter,
    &s_DefaultLogonDomain,
    &s_DontLog,
    &s_EnableDocFooter,
    &s_EnableReverseDns,
    &s_HttpCustomHeaders,
    &s_HttpErrors,
    &s_HttpExpires,
    &s_HttpPics,
    &s_HttpRedirect,
    &s_LogonMethod,
    &s_MimeMap,
    &s_PoolIDCTimeout,            
    &s_PutReadSize,            
    &s_Realm,                    
    &s_RedirectHeaders,            
    &s_ScriptMaps,
    &s_SSIExecDisable,
    &s_UNCAuthenticationPassthrough,
    &s_UploadReadAheadSize, 
    &s_AppAllowClientDebug,
    &s_AppAllowDebugging,
    &s_AppFriendlyName,
    &s_AppPackageID,
    &s_AppRoot,
    &s_AspAllowOutOfProcComponents,
    &s_AspAllowSessionState, 
    &s_AspBufferingOn,
    &s_AspCodepage, 
    &s_AspEnableApplicationRestart,
    &s_AspEnableAspHtmlFallback,
    &s_AspEnableChunkedEncoding,
    &s_AspEnableParentPaths,
    &s_AspEnableTypelibCache,
    &s_AspErrorsToNTLog,
    &s_AspExceptionCatchEnable, 
    &s_AspLogErrorRequests, 
    &s_AspProcessorThreadMax,
    &s_AspQueueConnectionTestTime,
    &s_AspQueueTimeout,
    &s_AspRequestQueueMax,
    &s_AspScriptEngineCacheMax,
    &s_AspScriptErrorMessage,
    &s_AspScriptErrorSentToBrowser,
    &s_AspScriptFileCacheSize,
    &s_AspScriptLanguage,
    &s_AspScriptTimeout,
    &s_AspSessionMax,
    &s_AspSessionTimeout,
    &s_AspThreadGateEnabled,
    &s_AspThreadGateLoadHigh,
    &s_AspThreadGateLoadLow,
    &s_AspThreadGateSleepDelay, 
    &s_AspThreadGateSleepMax,
    &s_AspThreadGateTimeSlice,
    &s_AspTrackThreadingModel,
    &s_CacheISAPI,                    
    &s_ContentIndexed,
    &s_DefaultDoc,
    &s_DirBrowseShowDate,
    &s_DirBrowseShowExtension,
    &s_DirBrowseShowLongDate,
    &s_DirBrowseShowSize,
    &s_DirBrowseShowTime,
    &s_EnableDefaultDoc,
    &s_EnableDirBrowsing,
    &s_AccessSource,
    &s_AppOopRecoverLimit,    
    &s_Path,
    &s_UNCPassword,
    &s_UNCUserName,
//    &s_IPSecurity,
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpWebDirectorySettings[] = 
{
    &s_AuthFlags,
    &s_AuthPersistence,
    &s_AccessFlags,
    &s_AccessSSLFlags,
    &s_DirBrowseFlags,
    &s_AccessExecute,
    &s_AccessNoRemoteExecute,
    &s_AccessNoRemoteRead,
    &s_AccessNoRemoteScript,
    &s_AccessNoRemoteWrite,
    &s_AccessRead,
    &s_AccessScript,
    &s_AccessSSL,                        
    &s_AccessSSL128,
    &s_AccessSSLMapCert,
    &s_AccessSSLNegotiateCert,
    &s_AccessSSLRequireCert,
    &s_AccessWrite,
    &s_AnonymousPasswordSync,
    &s_AnonymousUserName,
    &s_AnonymousUserPass,
    &s_AuthAnonymous,
    &s_AuthBasic,
    &s_AuthNTLM,
    &s_AuthPersistSingleRequest,
    &s_AuthPersistSingleRequestAlwaysIfProxy,
    &s_AuthPersistSingleRequestIfProxy,
    &s_CacheControlCustom,
    &s_CacheControlMaxAge,
    &s_CacheControlNoCache,
    &s_CGITimeout,
    &s_CpuAppEnabled,
    &s_CpuCgiEnabled,
    &s_CreateCGIWithNewConsole,
    &s_CreateProcessAsUser,
    &s_DefaultDocFooter,
    &s_DefaultLogonDomain,
    &s_DontLog,
    &s_EnableDocFooter,
    &s_EnableReverseDns,
    &s_HttpCustomHeaders,
    &s_HttpErrors,
    &s_HttpExpires,
    &s_HttpPics,
    &s_HttpRedirect,
    &s_LogonMethod,
    &s_MimeMap,
    &s_PoolIDCTimeout,            
    &s_PutReadSize,            
    &s_Realm,                    
    &s_RedirectHeaders,            
    &s_ScriptMaps,
    &s_SSIExecDisable,
    &s_UNCAuthenticationPassthrough,
    &s_UploadReadAheadSize, 
    &s_AppAllowClientDebug,
    &s_AppAllowDebugging,
    &s_AppFriendlyName,
    &s_AppPackageID,
    &s_AppRoot,
    &s_AspAllowOutOfProcComponents,
    &s_AspAllowSessionState, 
    &s_AspBufferingOn,
    &s_AspCodepage, 
    &s_AspEnableApplicationRestart,
    &s_AspEnableAspHtmlFallback,
    &s_AspEnableChunkedEncoding,
    &s_AspEnableParentPaths,
    &s_AspEnableTypelibCache,
    &s_AspErrorsToNTLog,
    &s_AspExceptionCatchEnable, 
    &s_AspLogErrorRequests, 
    &s_AspProcessorThreadMax,
    &s_AspQueueConnectionTestTime,
    &s_AspQueueTimeout,
    &s_AspRequestQueueMax,
    &s_AspScriptEngineCacheMax,
    &s_AspScriptErrorMessage,
    &s_AspScriptErrorSentToBrowser,
    &s_AspScriptFileCacheSize,
    &s_AspScriptLanguage,
    &s_AspScriptTimeout,
    &s_AspSessionMax,
    &s_AspSessionTimeout,
    &s_AspThreadGateEnabled,
    &s_AspThreadGateLoadHigh,
    &s_AspThreadGateLoadLow,
    &s_AspThreadGateSleepDelay, 
    &s_AspThreadGateSleepMax,
    &s_AspThreadGateTimeSlice,
    &s_AspTrackThreadingModel,
    &s_CacheISAPI,                    
    &s_ContentIndexed,
    &s_DefaultDoc,
    &s_DirBrowseShowDate,
    &s_DirBrowseShowExtension,
    &s_DirBrowseShowLongDate,
    &s_DirBrowseShowSize,
    &s_DirBrowseShowTime,
    &s_EnableDefaultDoc,
    &s_EnableDirBrowsing,
    &s_AppOopRecoverLimit,    
//    &s_IPSecurity,
    NULL
};

METABASE_PROPERTY* METABASE_PROPERTY_DATA::s_pmbpWebFileSettings[] = 
{
    &s_AuthFlags,
    &s_AuthPersistence,
    &s_AccessFlags,
    &s_AccessSSLFlags,
    &s_AccessExecute,
    &s_AccessNoRemoteExecute,
    &s_AccessNoRemoteRead,
    &s_AccessNoRemoteScript,
    &s_AccessNoRemoteWrite,
    &s_AccessRead,
    &s_AccessScript,
    &s_AccessSSL,                        
    &s_AccessSSL128,
    &s_AccessSSLMapCert,
    &s_AccessSSLNegotiateCert,
    &s_AccessSSLRequireCert,
    &s_AccessWrite,
    &s_AnonymousPasswordSync,
    &s_AnonymousUserName,
    &s_AnonymousUserPass,
    &s_AuthAnonymous,
    &s_AuthBasic,
    &s_AuthNTLM,
    &s_AuthPersistSingleRequest,
    &s_AuthPersistSingleRequestAlwaysIfProxy,
    &s_AuthPersistSingleRequestIfProxy,
    &s_CacheControlCustom,
    &s_CacheControlMaxAge,
    &s_CacheControlNoCache,
    &s_CGITimeout,
    &s_CpuAppEnabled,
    &s_CpuCgiEnabled,
    &s_CreateCGIWithNewConsole,
    &s_CreateProcessAsUser,
    &s_DefaultDocFooter,
    &s_DefaultLogonDomain,
    &s_DontLog,
    &s_EnableDocFooter,
    &s_EnableReverseDns,
    &s_HttpCustomHeaders,
    &s_HttpErrors,
    &s_HttpExpires,
    &s_HttpPics,
    &s_HttpRedirect,
    &s_LogonMethod,
    &s_MimeMap,
    &s_PoolIDCTimeout,            
    &s_PutReadSize,            
    &s_Realm,                    
    &s_RedirectHeaders,            
    &s_ScriptMaps,
    &s_SSIExecDisable,
    &s_UNCAuthenticationPassthrough,
    &s_UploadReadAheadSize, 
    &s_AccessSource,
//    &s_IPSecurity,
    NULL
};


//
//initialize WMI_METHOD_DATA
//
WMI_METHOD WMI_METHOD_DATA::s_ServiceCreateNewServer = {L"CreateNewServer", 0};

WMI_METHOD WMI_METHOD_DATA::s_ServerStart = {L"Start", MD_SERVER_COMMAND_START};
WMI_METHOD WMI_METHOD_DATA::s_ServerStop = {L"Stop", MD_SERVER_COMMAND_STOP};
WMI_METHOD WMI_METHOD_DATA::s_ServerContinue = {L"Continue", MD_SERVER_COMMAND_CONTINUE};
WMI_METHOD WMI_METHOD_DATA::s_ServerPause = {L"Pause", MD_SERVER_COMMAND_PAUSE};

WMI_METHOD WMI_METHOD_DATA::s_AppCreate = {L"AppCreate", 0};
WMI_METHOD WMI_METHOD_DATA::s_AppCreate2 = {L"AppCreate2", 0};
WMI_METHOD WMI_METHOD_DATA::s_AppDelete = {L"AppDelete", 0};
WMI_METHOD WMI_METHOD_DATA::s_AppUnLoad = {L"AppUnLoad", 0};
WMI_METHOD WMI_METHOD_DATA::s_AppDisable = {L"AppDisable", 0};
WMI_METHOD WMI_METHOD_DATA::s_AppEnable = {L"AppEnable", 0};
WMI_METHOD WMI_METHOD_DATA::s_AppGetStatus = {L"AppGetStatus", 0};
WMI_METHOD WMI_METHOD_DATA::s_AspAppRestart = {L"AspAppRestart", 0};

WMI_METHOD WMI_METHOD_DATA::s_Backup = {L"Backup", 0};
WMI_METHOD WMI_METHOD_DATA::s_DeleteBackup = {L"DeleteBackup", 0};
WMI_METHOD WMI_METHOD_DATA::s_EnumBackups = {L"EnumBackups", 0};
WMI_METHOD WMI_METHOD_DATA::s_Restore = {L"Restore", 0};

WMI_METHOD WMI_METHOD_DATA::s_CreateMapping = {L"CreateMapping", 0};
WMI_METHOD WMI_METHOD_DATA::s_DeleteMapping = {L"DeleteMapping", 0};
WMI_METHOD WMI_METHOD_DATA::s_GetMapping = {L"GetMapping", 0};
WMI_METHOD WMI_METHOD_DATA::s_SetAcct = {L"SetAcct", 0};
WMI_METHOD WMI_METHOD_DATA::s_SetEnabled = {L"SetEnabled", 0};
WMI_METHOD WMI_METHOD_DATA::s_SetName = {L"SetName", 0};
WMI_METHOD WMI_METHOD_DATA::s_SetPwd = {L"SetPwd", 0};


WMI_METHOD* WMI_METHOD_DATA::s_ServiceMethods[] = 
{
    &s_ServiceCreateNewServer,
    NULL
};

WMI_METHOD* WMI_METHOD_DATA::s_ServerMethods[] = 
{
    &s_ServerStart,
    &s_ServerStop,
    &s_ServerContinue,
    &s_ServerPause,
    NULL
};

WMI_METHOD* WMI_METHOD_DATA::s_WebAppMethods[] = 
{
    &s_AppCreate,
    &s_AppCreate2,
    &s_AppDelete,
    &s_AppUnLoad,
    &s_AppDisable,
    &s_AppEnable,
    &s_AppGetStatus,
    &s_AspAppRestart,
    NULL
};

WMI_METHOD* WMI_METHOD_DATA::s_ComputerMethods[] = 
{
    &s_Backup,
    &s_DeleteBackup,
    &s_EnumBackups,
    &s_Restore,
    NULL
};

WMI_METHOD* WMI_METHOD_DATA::s_CertMapperMethods[] = 
{
    &s_CreateMapping,
    &s_DeleteMapping,
    &s_GetMapping,
    &s_SetAcct,
    &s_SetEnabled,
    &s_SetName,
    &s_SetPwd,
    NULL
};

//
//initialize WMI_CLASS_DATA
//

//** Computer
WMI_CLASS WMI_CLASS_DATA::s_Computer   =
    {L"IIs_Computer", L"", L"Name", METABASE_PROPERTY_DATA::s_pmbpComputer, IIsComputer, WMI_METHOD_DATA::s_ComputerMethods};
WMI_CLASS WMI_CLASS_DATA::s_ComputerSetting = 
    {L"IIs_ComputerSetting", L"", L"Name", METABASE_PROPERTY_DATA::s_pmbpComputerSettings, IIsComputer, NULL};

//** MimeMap
WMI_CLASS WMI_CLASS_DATA::s_MimeMapSetting   =
    {L"IIs_MimeTypeSetting", L"/LM", L"Name", METABASE_PROPERTY_DATA::s_pmbpMimeMapSetting, IIsMimeMap, NULL};

//** LogModuleSetting
WMI_CLASS WMI_CLASS_DATA::s_LogModuleSetting   =
    {L"IIs_LogModuleSetting", L"/LM", L"Name", METABASE_PROPERTY_DATA::s_pmbpLogModuleSetting, IIsLogModule, NULL};

//** CustomLogModuleSetting
WMI_CLASS WMI_CLASS_DATA::s_CustomLogModuleSetting   =
    {L"IIs_CustomLogModuleSetting", L"/LM", L"Name", METABASE_PROPERTY_DATA::s_pmbpCustomLogModuleSetting, IIsCustomLogModule, NULL};

//** CompressionSchemeSetting
WMI_CLASS WMI_CLASS_DATA::s_CompressionSchemeSetting   =
    {L"IIs_CompressionSchemeSetting", L"/LM", L"Name", METABASE_PROPERTY_DATA::s_pmbpCompressionSchemeSetting, IIsCompressionScheme, NULL};

//** FtpService
WMI_CLASS WMI_CLASS_DATA::s_FtpService = 
    {L"IIs_FtpService", L"/LM", L"Name", METABASE_PROPERTY_DATA::s_pmbpFtpService, IIsFtpService, WMI_METHOD_DATA::s_ServiceMethods};
WMI_CLASS WMI_CLASS_DATA::s_FtpServiceSettings = 
    {L"IIs_FtpServiceSetting", L"/LM", L"Name", METABASE_PROPERTY_DATA::s_pmbpFtpServiceSettings, IIsFtpService, NULL};

//** FtpInfoSetting
WMI_CLASS WMI_CLASS_DATA::s_FtpInfoSetting = 
    {L"IIs_FtpInfoSetting", L"/LM", L"Name", METABASE_PROPERTY_DATA::s_pmbpFtpInfoSetting, IIsFtpInfo, NULL};

//** FtpServer
WMI_CLASS WMI_CLASS_DATA::s_FtpServer  = 
    {L"IIs_FtpServer", L"/LM", L"Name", METABASE_PROPERTY_DATA::s_pmbpFtpServer, IIsFtpServer, WMI_METHOD_DATA::s_ServerMethods};
WMI_CLASS WMI_CLASS_DATA::s_FtpServerSettings  = 
    {L"IIs_FtpServerSetting", L"/LM", L"Name", METABASE_PROPERTY_DATA::s_pmbpFtpServerSettings, IIsFtpServer,NULL};

//** FtpVirtualDir
WMI_CLASS WMI_CLASS_DATA::s_FtpVirtualDir = 
    {L"IIs_FtpVirtualDir",L"/LM",L"Name", METABASE_PROPERTY_DATA::s_pmbpFtpVirtualDir, IIsFtpVirtualDir, NULL};
WMI_CLASS WMI_CLASS_DATA::s_FtpVirtualDirSettings = 
    {L"IIs_FtpVirtualDirSetting", L"/LM", L"Name", METABASE_PROPERTY_DATA::s_pmbpFtpVirtualDirSettings, IIsFtpVirtualDir, NULL};

//** WebService
WMI_CLASS WMI_CLASS_DATA::s_WebService =    
    {L"IIs_WebService", L"/LM", L"Name", METABASE_PROPERTY_DATA::s_pmbpWebService, IIsWebService, WMI_METHOD_DATA::s_ServiceMethods};
WMI_CLASS WMI_CLASS_DATA::s_WebServiceSettings = 
    {L"IIs_WebServiceSetting", L"/LM", L"Name", METABASE_PROPERTY_DATA::s_pmbpWebServiceSettings, IIsWebService, NULL};

//** WebInfoSetting
WMI_CLASS WMI_CLASS_DATA::s_WebInfoSetting =
    {L"IIs_WebInfoSetting", L"/LM", L"Name", METABASE_PROPERTY_DATA::s_pmbpWebInfoSetting, IIsWebInfo, NULL};

//** WebFilter
WMI_CLASS WMI_CLASS_DATA::s_WebFilter =
    {L"IIs_Filter", L"/LM", L"Name", METABASE_PROPERTY_DATA::s_pmbpWebFilter, IIsFilter, NULL};

//** WebServer
WMI_CLASS WMI_CLASS_DATA::s_WebServer =
    {L"IIs_WebServer", L"/LM", L"Name", METABASE_PROPERTY_DATA::s_pmbpWebServer, IIsWebServer, WMI_METHOD_DATA::s_ServerMethods};
WMI_CLASS WMI_CLASS_DATA::s_WebServerSettings = 
    {L"IIs_WebServerSetting", L"/LM",L"Name", METABASE_PROPERTY_DATA::s_pmbpWebServerSettings, IIsWebServer, NULL};

//** Web CertMapper
WMI_CLASS WMI_CLASS_DATA::s_WebCertMapper = 
    {L"IIs_CertMapper",L"/LM",L"Name", METABASE_PROPERTY_DATA::s_pmbpWebCertMapper, IIsCertMapper, WMI_METHOD_DATA::s_CertMapperMethods};

//** Web VirtualDir
WMI_CLASS WMI_CLASS_DATA::s_WebVirtualDir = 
    {L"IIs_WebVirtualDir",L"/LM",L"Name", METABASE_PROPERTY_DATA::s_pmbpWebVirtualDir, IIsWebVirtualDir, WMI_METHOD_DATA::s_WebAppMethods};
WMI_CLASS WMI_CLASS_DATA::s_WebVirtualDirSettings = 
    {L"IIs_WebVirtualDirSetting", L"/LM",L"Name", METABASE_PROPERTY_DATA::s_pmbpWebVirtualDirSettings, IIsWebVirtualDir, NULL};

//** Web Directory
WMI_CLASS WMI_CLASS_DATA::s_WebDirectory = 
    {L"IIs_WebDirectory",L"/LM",L"Name", METABASE_PROPERTY_DATA::s_pmbpWebDirectory, IIsWebDirectory, WMI_METHOD_DATA::s_WebAppMethods};
WMI_CLASS WMI_CLASS_DATA::s_WebDirectorySettings = 
    {L"IIs_WebDirectorySetting", L"/LM",L"Name", METABASE_PROPERTY_DATA::s_pmbpWebDirectorySettings, IIsWebDirectory, NULL};

//** Web File
WMI_CLASS WMI_CLASS_DATA::s_WebFile = 
    {L"IIs_WebFile",L"/LM",L"Name", METABASE_PROPERTY_DATA::s_pmbpWebFile, IIsWebFile, NULL};
WMI_CLASS WMI_CLASS_DATA::s_WebFileSettings = 
    {L"IIs_WebFileSetting", L"/LM",L"Name", METABASE_PROPERTY_DATA::s_pmbpWebFileSettings, IIsWebFile, NULL};


//** AdminACL
WMI_CLASS WMI_CLASS_DATA::s_AdminACL = 
    {L"IIs_AdminACL", L"/LM",L"Name", NULL, TYPE_AdminACL, NULL};

WMI_CLASS WMI_CLASS_DATA::s_ACE = 
    {L"IIs_ACE", L"/LM",L"Name", NULL, TYPE_AdminACE, NULL};


//** IPSecurity
WMI_CLASS WMI_CLASS_DATA::s_IPSecurity = 
    {L"IIs_IPSecuritySetting", L"/LM",L"Name", NULL, TYPE_IPSecurity, NULL};




WMI_CLASS* WMI_CLASS_DATA:: s_WmiClasses[] = 
{
    &s_Computer,
    &s_ComputerSetting,

    &s_MimeMapSetting,
    
    &s_LogModuleSetting,
    &s_CustomLogModuleSetting,

    &s_FtpService,
    &s_FtpServiceSettings,

    &s_FtpInfoSetting,

    &s_FtpServer,
    &s_FtpServerSettings,

    &s_FtpVirtualDir,
    &s_FtpVirtualDirSettings,

    &s_WebService,
    &s_WebServiceSettings,

    &s_WebInfoSetting,

    &s_WebFilter,

    &s_WebServer,
    &s_WebServerSettings,

    &s_WebCertMapper,

    &s_WebVirtualDir,
    &s_WebVirtualDirSettings,

    &s_WebDirectory,
    &s_WebDirectorySettings,

    &s_WebFile,
    &s_WebFileSettings,

    &s_CompressionSchemeSetting,

    &s_AdminACL,
    &s_ACE,    
    &s_IPSecurity,

    NULL
};


//
//initialize WMI_ASSOCIATION_DATA
//

//** Computer **//
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_ComputerToMimeMap = 
    { L"IIs_Computer_MimeTypeSetting", &WMI_CLASS_DATA::s_Computer, &WMI_CLASS_DATA::s_MimeMapSetting, at_ElementSetting, ASSOC_EXTRAORDINARY};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_ComputerToLogModuleSettings = 
    { L"IIs_Computer_LogModuleSetting", &WMI_CLASS_DATA::s_Computer, &WMI_CLASS_DATA::s_LogModuleSetting, at_ElementSetting, ASSOC_EXTRAORDINARY};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_ComputerToCustomLogModuleSetting = 
    { L"IIs_Computer_CustomLogModuleSetting", &WMI_CLASS_DATA::s_Computer, &WMI_CLASS_DATA::s_CustomLogModuleSetting, at_ElementSetting, ASSOC_EXTRAORDINARY};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_ComputerToFtpService = 
    { L"IIs_Computer_FtpService", &WMI_CLASS_DATA::s_Computer, &WMI_CLASS_DATA::s_FtpService, at_Component, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_ComputerToWebService = 
    { L"IIs_Computer_WebService", &WMI_CLASS_DATA::s_Computer, &WMI_CLASS_DATA::s_WebService, at_Component, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_ComputerToComputerSettings = 
    { L"IIs_Computer_ComputerSetting", &WMI_CLASS_DATA::s_Computer, &WMI_CLASS_DATA::s_ComputerSetting, at_ElementSetting, 0};

//** FtpService **//
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_FtpServiceToInfo = 
    { L"IIs_FtpService_FtpInfoSetting", &WMI_CLASS_DATA::s_FtpService, &WMI_CLASS_DATA::s_FtpInfoSetting, at_ElementSetting, ASSOC_EXTRAORDINARY};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_FtpServiceToServer = 
    { L"IIs_FtpService_FtpServer", &WMI_CLASS_DATA::s_FtpService, &WMI_CLASS_DATA::s_FtpServer, at_Component, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_FtpServiceToSettings = 
    { L"IIs_FtpService_FtpServiceSetting", &WMI_CLASS_DATA::s_FtpService, &WMI_CLASS_DATA::s_FtpServiceSettings, at_ElementSetting, 0};

//** FtpServer **//
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_FtpServerToVirtualDir = 
    { L"IIs_FtpServer_FtpVirtualDir", &WMI_CLASS_DATA::s_FtpServer, &WMI_CLASS_DATA::s_FtpVirtualDir, at_Component, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_FtpServerToSettings = 
    { L"IIs_FtpServer_FtpServerSetting", &WMI_CLASS_DATA::s_FtpServer, &WMI_CLASS_DATA::s_FtpServerSettings, at_ElementSetting, 0};

//** Ftp VirtualDir **//
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_FtpVirtualDirToVirtualDir =
    { L"IIs_FtpVirtualSubDir", &WMI_CLASS_DATA::s_FtpVirtualDir, &WMI_CLASS_DATA::s_FtpVirtualDir, at_Component, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_FtpVirtualDirToSettings = 
    { L"IIs_FtpVirtualDir_FtpVirtualDirSetting", &WMI_CLASS_DATA::s_FtpVirtualDir, &WMI_CLASS_DATA::s_FtpVirtualDirSettings, at_ElementSetting, 0};

//** Web Service **//
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebServiceToInfo = 
    { L"IIs_WebService_WebInfoSetting", &WMI_CLASS_DATA::s_WebService, &WMI_CLASS_DATA::s_WebInfoSetting, at_ElementSetting, ASSOC_EXTRAORDINARY};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebServiceToFilter = 
    { L"IIs_WebService_Filter", &WMI_CLASS_DATA::s_WebService, &WMI_CLASS_DATA::s_WebFilter, at_Component, ASSOC_EXTRAORDINARY};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebServiceToServer = 
    { L"IIs_WebService_WebServer", &WMI_CLASS_DATA::s_WebService, &WMI_CLASS_DATA::s_WebServer, at_Component, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebServiceToSettings = 
    { L"IIs_WebService_WebServiceSetting", &WMI_CLASS_DATA::s_WebService, &WMI_CLASS_DATA::s_WebServiceSettings, at_ElementSetting, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebServiceToCompressionSchemeSetting = 
    { L"IIs_WebService_CompressionSchemeSetting", &WMI_CLASS_DATA::s_WebService, &WMI_CLASS_DATA::s_CompressionSchemeSetting, at_ElementSetting, ASSOC_EXTRAORDINARY};

//** WebServer **//
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebServerToCertMapper = 
    { L"IIs_WebServer_CertMapper", &WMI_CLASS_DATA::s_WebServer, &WMI_CLASS_DATA::s_WebCertMapper, at_Component, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebServerToFilter = 
    { L"IIs_WebServer_Filter", &WMI_CLASS_DATA::s_WebServer, &WMI_CLASS_DATA::s_WebFilter, at_Component, ASSOC_EXTRAORDINARY};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebServerToVirtualDir = 
    { L"IIs_WebServer_WebVirtualDir", &WMI_CLASS_DATA::s_WebServer, &WMI_CLASS_DATA::s_WebVirtualDir, at_Component, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebServerToSettings = 
    { L"IIs_WebServer_WebServerSetting", &WMI_CLASS_DATA::s_WebServer, &WMI_CLASS_DATA::s_WebServerSettings, at_ElementSetting, 0};

//** Web VirtualDir **//
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebVirtualDirToVirtualDir =
    { L"IIs_WebVirtualSubDir", &WMI_CLASS_DATA::s_WebVirtualDir, &WMI_CLASS_DATA::s_WebVirtualDir, at_Component, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebVirtualDirToDirectory = 
    { L"IIs_WebVirtualDir_WebDirectory", &WMI_CLASS_DATA::s_WebVirtualDir, &WMI_CLASS_DATA::s_WebDirectory, at_Component, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebVirtualDirToFile = 
    { L"IIs_WebVirtualDir_File", &WMI_CLASS_DATA::s_WebVirtualDir, &WMI_CLASS_DATA::s_WebFile, at_Component, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebVirtualDirToSettings = 
    { L"IIs_WebVirtualDir_WebVirtualDirSetting", &WMI_CLASS_DATA::s_WebVirtualDir, &WMI_CLASS_DATA::s_WebVirtualDirSettings, at_ElementSetting, 0};

//** Web Directory **//
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebDirectoryToDirectory =
    { L"IIs_WebSubDirectory", &WMI_CLASS_DATA::s_WebDirectory, &WMI_CLASS_DATA::s_WebDirectory, at_Component, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebDirectoryToVirtualDir =
    { L"IIs_WebDirectory_WebVirtualDir", &WMI_CLASS_DATA::s_WebDirectory, &WMI_CLASS_DATA::s_WebVirtualDir, at_Component, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebDirectoryToFile =
    { L"IIs_WebDirectory_File", &WMI_CLASS_DATA::s_WebDirectory, &WMI_CLASS_DATA::s_WebFile, at_Component, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebDirectoryToSettings = 
    { L"IIs_WebDirectory_WebDirectorySetting", &WMI_CLASS_DATA::s_WebDirectory, &WMI_CLASS_DATA::s_WebDirectorySettings, at_ElementSetting, 0};

//** Web File **//
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebFileToSettings = 
    { L"IIs_WebFile_WebFileSetting", &WMI_CLASS_DATA::s_WebFile, &WMI_CLASS_DATA::s_WebFileSettings, at_ElementSetting, 0};

//** AdminACL
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_AdminACLToACE = 
    { L"IIs_AdminACL_ACE", &WMI_CLASS_DATA::s_AdminACL, &WMI_CLASS_DATA::s_ACE, at_AdminACL, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_FtpServiceToAdminACL = 
    { L"IIs_FtpService_AdminACL", &WMI_CLASS_DATA::s_FtpService, &WMI_CLASS_DATA::s_AdminACL, at_AdminACL, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_FtpServerToAdminACL = 
    { L"IIs_FtpServer_AdminACL", &WMI_CLASS_DATA::s_FtpServer, &WMI_CLASS_DATA::s_AdminACL, at_AdminACL, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_FtpVirtualDirToAdminACL = 
    { L"IIs_FtpVirtualDir_AdminACL", &WMI_CLASS_DATA::s_FtpVirtualDir, &WMI_CLASS_DATA::s_AdminACL, at_AdminACL, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebServiceToAdminACL = 
    { L"IIs_WebService_AdminACL", &WMI_CLASS_DATA::s_WebService, &WMI_CLASS_DATA::s_AdminACL, at_AdminACL, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebServerToAdminACL = 
    { L"IIs_WebServer_AdminACL", &WMI_CLASS_DATA::s_WebServer, &WMI_CLASS_DATA::s_AdminACL, at_AdminACL, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebVirtualDirToAdminACL = 
    { L"IIs_WebVirtualDir_AdminACL", &WMI_CLASS_DATA::s_WebVirtualDir, &WMI_CLASS_DATA::s_AdminACL, at_AdminACL, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebDirectoryToAdminACL = 
    { L"IIs_WebDirectory_AdminACL", &WMI_CLASS_DATA::s_WebDirectory, &WMI_CLASS_DATA::s_AdminACL, at_AdminACL, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebFileToAdminACL = 
    { L"IIs_WebFile_AdminACL", &WMI_CLASS_DATA::s_WebFile, &WMI_CLASS_DATA::s_AdminACL, at_AdminACL, 0};

//** IPSecurity
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_FtpServiceToIPSecurity = 
    { L"IIs_FtpService_IPSecuritySetting", &WMI_CLASS_DATA::s_FtpService, &WMI_CLASS_DATA::s_IPSecurity, at_IPSecurity, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_FtpServerToIPSecurity = 
    { L"IIs_FtpServer_IPSecuritySetting", &WMI_CLASS_DATA::s_FtpServer, &WMI_CLASS_DATA::s_IPSecurity, at_IPSecurity, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_FtpVirtualDirToIPSecurity = 
    { L"IIs_FtpVirtualDir_IPSecuritySetting", &WMI_CLASS_DATA::s_FtpVirtualDir, &WMI_CLASS_DATA::s_IPSecurity, at_IPSecurity, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebServiceToIPSecurity = 
    { L"IIs_WebService_IPSecuritySetting", &WMI_CLASS_DATA::s_WebService, &WMI_CLASS_DATA::s_IPSecurity, at_IPSecurity, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebServerToIPSecurity = 
    { L"IIs_WebServer_IPSecuritySetting", &WMI_CLASS_DATA::s_WebServer, &WMI_CLASS_DATA::s_IPSecurity, at_IPSecurity, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebVirtualDirToIPSecurity = 
    { L"IIs_WebVirtualDir_IPSecuritySetting", &WMI_CLASS_DATA::s_WebVirtualDir, &WMI_CLASS_DATA::s_IPSecurity, at_IPSecurity, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebDirectoryToIPSecurity = 
    { L"IIs_WebDirectory_IPSecuritySetting", &WMI_CLASS_DATA::s_WebDirectory, &WMI_CLASS_DATA::s_IPSecurity, at_IPSecurity, 0};
WMI_ASSOCIATION WMI_ASSOCIATION_DATA::s_WebFileToIPSecurity = 
    { L"IIs_WebFile_IPSecuritySetting", &WMI_CLASS_DATA::s_WebFile, &WMI_CLASS_DATA::s_IPSecurity, at_IPSecurity, 0};


WMI_ASSOCIATION* WMI_ASSOCIATION_DATA:: s_WmiAssociations[] = 
{
    &s_ComputerToMimeMap,                     // Computer
    &s_ComputerToFtpService, 
    &s_ComputerToWebService, 
    &s_ComputerToComputerSettings,
    &s_ComputerToLogModuleSettings, 
    &s_ComputerToCustomLogModuleSetting,

    &s_FtpServiceToInfo,                      // FtpService
    &s_FtpServiceToServer, 
    &s_FtpServiceToSettings,

    &s_FtpServerToVirtualDir,                 //FtpServer
    &s_FtpServerToSettings,
    
    &s_FtpVirtualDirToVirtualDir,             //FtpVirtualDir
    &s_FtpVirtualDirToSettings,

    &s_WebServiceToInfo,                      //WebService
    &s_WebServiceToFilter,
    &s_WebServiceToServer,
    &s_WebServiceToSettings,
    &s_WebServiceToCompressionSchemeSetting,

    &s_WebServerToCertMapper,                //WebServer
    &s_WebServerToFilter,
    &s_WebServerToVirtualDir,
    &s_WebServerToSettings,

    &s_WebVirtualDirToVirtualDir,             //WebVirtualDir
    &s_WebVirtualDirToDirectory,
    &s_WebVirtualDirToFile,
    &s_WebVirtualDirToSettings,

    &s_WebDirectoryToDirectory,             //WebDirectory
    &s_WebDirectoryToVirtualDir,
    &s_WebDirectoryToFile, 
    &s_WebDirectoryToSettings,

    &s_WebFileToSettings,        //WebFile  

    &s_AdminACLToACE,        //AdminACL
    &s_FtpServiceToAdminACL,
    &s_FtpServerToAdminACL,
    &s_FtpVirtualDirToAdminACL,
    &s_WebServiceToAdminACL,
    &s_WebServerToAdminACL,
    &s_WebVirtualDirToAdminACL,
    &s_WebDirectoryToAdminACL,
    &s_WebFileToAdminACL,
  
    &s_FtpServiceToIPSecurity,    //IPSecurity
    &s_FtpServerToIPSecurity,
    &s_FtpVirtualDirToIPSecurity,
    &s_WebServiceToIPSecurity,
    &s_WebServerToIPSecurity,
    &s_WebVirtualDirToIPSecurity,
    &s_WebDirectoryToIPSecurity,
    &s_WebFileToIPSecurity,

    NULL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\genlex.cpp ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    GENLEX.CPP

Abstract:

    Generic lexer framework classes.

History:

--*/

#include <windows.h>
#include <stdio.h>

#include <genlex.h>

//***************************************************************************
//
//***************************************************************************

CGenLexer::CGenLexer(LexEl *pTbl, CGenLexSource *pSrc)
{
    m_nCurBufSize = 256;
    m_pTokenBuf = (wchar_t *) HeapAlloc(GetProcessHeap(), 0,
        m_nCurBufSize * 2);
    m_nCurrentLine = 1;
    m_pTable = pTbl;
    m_pSrc = pSrc;
}

//***************************************************************************
//
//***************************************************************************
void CGenLexer::Reset()
{
    m_pSrc->Reset();
    m_nCurrentLine = 1;
}


//***************************************************************************
//
//***************************************************************************

CGenLexer::~CGenLexer()
{
    HeapFree(GetProcessHeap(), 0, m_pTokenBuf);
}

//***************************************************************************
//
//***************************************************************************

int CGenLexer::NextToken()
{
    int nState = 0;
    int nCurBufEnd = 0;
    BOOL bRead = TRUE;
    wchar_t cCurrent = 0;

    BOOL bEOF = FALSE;

    if (m_pTokenBuf == 0)
        return 0;

    *m_pTokenBuf = 0;

    // Generic DFA driver based on the table specified
    // in the constructor.
    // ===============================================

    while (1)
    {
        BOOL bMatch = FALSE;
        WORD wInstructions = m_pTable[nState].wInstructions;

        if (bRead)
        {
            if(bEOF)
            {
                // The lexer table allowed us to go past end of string!!!
                return 1;
            }
            cCurrent = m_pSrc->NextChar();
            if(cCurrent == 0)
                bEOF = TRUE;
        }

        bRead = FALSE;

        // Check here if only the first character is present.
        // ==================================================

        if (m_pTable[nState].cFirst == GLEX_ANY)
            bMatch = TRUE;
        else if (m_pTable[nState].cLast == GLEX_EMPTY)
        {
            if (cCurrent == m_pTable[nState].cFirst)
                bMatch = TRUE;
            else if ((wInstructions & GLEX_NOT) &&
                !(cCurrent == m_pTable[nState].cFirst))
                bMatch = TRUE;
        }

        // If here, both first/last are present and we
        // are testing to see if the input is in between.
        // ==============================================
        else if (m_pTable[nState].cFirst != GLEX_ANY)
        {
            if ((wInstructions & GLEX_NOT) &&
                !(cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast))
                    bMatch = TRUE;
            else if (cCurrent >= m_pTable[nState].cFirst &&
                cCurrent <= m_pTable[nState].cLast)
                    bMatch = TRUE;
        }

        // Interpret the instruction field to determine
        // whether the character is actually to be included
        // in the token text.
        // ================================================

        if (bMatch)
        {
            if (wInstructions & GLEX_ACCEPT)
            {
                // Expand the current buffer, if required.
                // =======================================

                if (nCurBufEnd == m_nCurBufSize - 1)
                {
                    m_nCurBufSize += 256;
                    m_pTokenBuf = (wchar_t *) HeapReAlloc(GetProcessHeap(), 0, m_pTokenBuf,
                        m_nCurBufSize * 2);
                    if (m_pTokenBuf == 0)
                        return 0; // out of memory
                }

                m_pTokenBuf[nCurBufEnd] = cCurrent;
                m_pTokenBuf[++nCurBufEnd]= 0;

                bRead = TRUE;
            }
            if (wInstructions & GLEX_CONSUME)
               bRead = TRUE;

            // else GLEX_CONSUME, which means 'skip'

            // If the PUSHBACK instruction is present,
            // push the char back.
            // ======================================
            if (wInstructions & GLEX_PUSHBACK)
            {
                bRead = TRUE;
                m_pSrc->Pushback(cCurrent);
            }

            // If a linefeed instruction.
            // ==========================
            if (wInstructions & GLEX_LINEFEED)
                m_nCurrentLine++;

            // If the return field is present and there was
            // a match, then return the specified token.  Alternately,
            // the GLEX_RETURN instruction will force a return
            // match, or no match.
            // =======================================================
            if (m_pTable[nState].wReturnTok ||
                (wInstructions & GLEX_RETURN))
                return int(m_pTable[nState].wReturnTok);

            nState = int(m_pTable[nState].wGotoState);
        }

        // If here, there was no match.
        // ===================================
        else
            nState++;
    }

    return 0;   // No path to here
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\iisfiles.h ===
#ifndef _iisfiles_h_
#define _iisfiles_h_

#include <iadmw.h>
#include <wincrypt.h>
#include <iiscnfg.h>    // public\sdk\inc
#include "iiscnfgp.h"   // got from inetsrv\iis\inc (build iis)
#include <iwamreg.h>    // public\sdk\inc
#include <iads.h>
#include <adshlp.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\ipsecurity.h ===
#ifndef _IPSecurity_h_
#define _IPSecurity_h_



#import "adsiis.dll" no_namespace named_guids


class CIPSecurity
{
private:

    IISIPSecurity* m_pIPSec;
    IADs* m_pADs;

public:

    CIPSecurity();
    ~CIPSecurity();

    HRESULT GetObjectAsync(
        IWbemClassObject* pObj
        ); 

    HRESULT PutObjectAsync(
        IWbemClassObject* pObj
        );

    HRESULT OpenSD(_bstr_t bstrAdsPath);
    void CloseSD();

private:

    HRESULT SetSD();
    HRESULT GetAdsPath(_bstr_t& bstrAdsPath);    
    HRESULT LoadBstrArrayFromVariantArray(VARIANT& i_vtVariant, VARIANT& o_vtBstr);
    HRESULT LoadVariantArrayFromBstrArray(VARIANT& i_vtBstr, VARIANT& o_vtVariant);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\iisprov.h ===
//***************************************************************************
//
//  iisprov.h
//
//  Module: WMI IIS Instance provider 
//
//  Purpose: Genral purpose include file.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#ifndef _iisprov_H_
#define _iisprov_H_

#include <windows.h>
#include <wbemprov.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>
#include <comdef.h>
#include <stdio.h>

#include "iisfiles.h"
#include "ntrkcomm.h"
#include "schema.h"
#include "metabase.h"
#include "certmap.h"
#include "adminacl.h"
#include "ipsecurity.h"
#include "enum.h"
#include "utils.h"


// This is an instance qualifier of type bool.  This specifies that the WMI
// client wants child nodes to have their own copy of properties being
// updated even if the properties are inherited from a parent node.
#define WSZ_OVERRIDE_PARENT L"OverrideParent"


// These variables keep track of when the module can be unloaded
extern long  g_cLock;


// Provider interfaces are provided by objects of this class
 
class CIISInstProvider : public CImpersonatedProvider
{
public:
    CIISInstProvider(
        BSTR ObjectPath = NULL, 
        BSTR User = NULL, 
        BSTR Password = NULL, 
        IWbemContext* pCtx = NULL
        )
    {}

    HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync( 
        /* [in] */ const BSTR,    //ObjectPath,
        /* [in] */ long,    // lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,    //pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *    //pResponseHandler
        );

    HRESULT STDMETHODCALLTYPE DoExecQueryAsync( 
        /* [in] */ const BSTR, // QueryLanguage,
        /* [in] */ const BSTR, // Query,
        /* [in] */ long, // lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,   // pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR * //pResponseHandler
        ) 
    {return WBEM_E_NOT_SUPPORTED;};

   
    HRESULT STDMETHODCALLTYPE DoGetObjectAsync( 
        /* [in] */ const BSTR,
        /* [in] */ long,
        /* [in] */ IWbemContext __RPC_FAR *,
        /* [in] */ IWbemObjectSink __RPC_FAR *
        ); // SUPPORTED
  
    HRESULT STDMETHODCALLTYPE DoPutInstanceAsync( 
        IWbemClassObject __RPC_FAR *,
        long,
        IWbemContext __RPC_FAR *,
        IWbemObjectSink __RPC_FAR *
        );
    
    HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync( 
        const BSTR,
        long,
        IWbemContext __RPC_FAR *,
        IWbemObjectSink __RPC_FAR *
        );
    
    HRESULT STDMETHODCALLTYPE DoExecMethodAsync( 
        const BSTR, 
        const BSTR, 
        long, 
        IWbemContext*, 
        IWbemClassObject*, 
        IWbemObjectSink*
    ) ;
    

private:
    IWbemClassObject* SetExtendedStatus(WCHAR* a_psz);

};


// This class is the class factory for CInstPro objects.

class CProvFactory : public IClassFactory
{
protected:
    ULONG           m_cRef;

public:
    CProvFactory(void);
    ~CProvFactory(void);

    //IUnknown members
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IClassFactory members
    STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID, PPVOID);
    STDMETHODIMP         LockServer(BOOL);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\ipsecurity.cpp ===
//***************************************************************************
//
//  IPSecurity.cpp
//
//  Module: WBEM Instance provider
//
//  Purpose: IIS IPSecurity class 
//
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************



#include "iisprov.h"


CIPSecurity::CIPSecurity()
{
    m_pADs = NULL;
    m_pIPSec = NULL;
}


CIPSecurity::~CIPSecurity()
{
    CloseSD();
}


void CIPSecurity::CloseSD()
{
    if(m_pIPSec)
    {
        m_pIPSec->Release();
        m_pIPSec = NULL;
    }

    if(m_pADs)
    {
        m_pADs->Release();
        m_pADs = NULL;
    }
}


HRESULT CIPSecurity::GetObjectAsync(
    IWbemClassObject* pObj
    )
{
    VARIANT vt;
    VARIANT vtBstrArray;
    HRESULT hr;

    // IPDeny
    hr = m_pIPSec->get_IPDeny(&vt);
    if(SUCCEEDED(hr))
    {
        hr = LoadBstrArrayFromVariantArray(vt, vtBstrArray);
        VariantClear(&vt);

        if(SUCCEEDED(hr))
        {
            hr = pObj->Put(L"IPDeny", 0, &vtBstrArray, 0);
            VariantClear(&vtBstrArray);
        }
    }

    // IPGrant
    if(SUCCEEDED(hr))
    {
        hr = m_pIPSec->get_IPGrant(&vt);

        if(SUCCEEDED(hr))
        {
            hr = LoadBstrArrayFromVariantArray(vt, vtBstrArray);
            VariantClear(&vt);

            if(SUCCEEDED(hr))
            {
                hr = pObj->Put(L"IPGrant", 0, &vtBstrArray, 0);
                VariantClear(&vtBstrArray);
            }    
        }
    }

    // DomainDeny
    if(SUCCEEDED(hr))
    {
        hr = m_pIPSec->get_DomainDeny(&vt);

        if(SUCCEEDED(hr))
        {
            hr = LoadBstrArrayFromVariantArray(vt, vtBstrArray);
            VariantClear(&vt);

            if(SUCCEEDED(hr))
            {
                hr = pObj->Put(L"DomainDeny", 0, &vtBstrArray, 0);
                VariantClear(&vtBstrArray);
            }
        }
    }

    // DomainGrant
    if(SUCCEEDED(hr))
    {
        hr = m_pIPSec->get_DomainGrant(&vt);
    
        if(SUCCEEDED(hr))
        {
            hr = LoadBstrArrayFromVariantArray(vt, vtBstrArray);
            VariantClear(&vt);

            if(SUCCEEDED(hr))
            {
                hr = pObj->Put(L"DomainGrant", 0, &vtBstrArray, 0);
                VariantClear(&vtBstrArray);
            }
        }   
    }

    // GrantByDefault
    if(SUCCEEDED(hr))
        hr = m_pIPSec->get_GrantByDefault(&vt.boolVal);
    if(SUCCEEDED(hr))
    {
        vt.vt = VT_BOOL;
        hr = pObj->Put(L"GrantByDefault", 0, &vt, 0);
    }

    return hr;
}

// Convert SAFEARRAY of BSTRs to SAFEARRAY of VARIANTs
HRESULT CIPSecurity::LoadVariantArrayFromBstrArray(
    VARIANT&    i_vtBstr,
    VARIANT&    o_vtVariant)
{
    SAFEARRAYBOUND  aDim;
    SAFEARRAY*      pBstrArray = NULL;
    SAFEARRAY*      pVarArray = NULL;
    BSTR*           paBstr = NULL;
    VARIANT         vt;
    LONG            i=0;
    HRESULT         hr = ERROR_SUCCESS;

    try
    {
        // Verify that the input VARIANT is a BSTR array or NULL.
        if (i_vtBstr.vt != (VT_ARRAY | VT_BSTR) &&
            i_vtBstr.vt != VT_NULL) {
            hr = WBEM_E_INVALID_PARAMETER;
            THROW_ON_ERROR(hr);
        }

        // Initialize the output VARIANT (Set type to VT_EMPTY)
        VariantInit(&o_vtVariant);

        // Handle the case when there is no input array
        if (i_vtBstr.vt == VT_NULL) {
            aDim.lLbound = 0;
            aDim.cElements = 0;
        }
        else {
            // Verify that the input VARIANT contains a SAFEARRAY
            pBstrArray = i_vtBstr.parray;
            if (pBstrArray == NULL) {
                hr = WBEM_E_INVALID_PARAMETER;
                THROW_ON_ERROR(hr);
            }

            // Get the size of the BSTR SAFEARRAY.
            aDim.lLbound = 0;
            aDim.cElements = pBstrArray->rgsabound[0].cElements;
        }

        // Create the new VARIANT SAFEARRAY
        pVarArray = SafeArrayCreate(VT_VARIANT, 1, &aDim);
        if (pVarArray == NULL) {
            hr = E_OUTOFMEMORY;
            THROW_ON_ERROR(hr);
        }

        // Put the new VARIANT SAFEARRAY into our output VARIANT
        o_vtVariant.vt = VT_ARRAY | VT_VARIANT;
        o_vtVariant.parray = pVarArray;

        if(aDim.cElements > 0) {
            // Get the BSTR SAFEARRAY pointer.
            hr = SafeArrayAccessData(pBstrArray, (void**)&paBstr);
            THROW_ON_ERROR(hr);

            // Copy all the BSTRS to VARIANTS
            VariantInit(&vt);
            vt.vt = VT_BSTR;
            for(i = aDim.lLbound; i < (long) aDim.cElements; i++)
            {
                vt.bstrVal = SysAllocString(paBstr[i]);
                if (vt.bstrVal == NULL) {
                    hr = E_OUTOFMEMORY;
                    THROW_ON_ERROR(hr);
                }
                hr = SafeArrayPutElement(pVarArray, &i, &vt);
                THROW_ON_ERROR(hr);
            }

            hr = SafeArrayUnaccessData(pBstrArray);
            THROW_ON_ERROR(hr);
        }
    }
    catch(...)
    {
        // Destroy the VARIANT, the contained SAFEARRAY and the VARIANTs in the SAFEARRAY.
        // It also free the BSTRS contained in the VARIANTs
        VariantClear(&o_vtVariant);

        // Destroy temp VARIANT (It is possible this guy didn't get put into array, but has a BSTR)
        VariantClear(&vt);
    }
    return hr;
}

HRESULT CIPSecurity::LoadBstrArrayFromVariantArray(
    VARIANT&    i_vtVariant,
    VARIANT&    o_vtBstr
    )
{
    SAFEARRAYBOUND  aDim;
    SAFEARRAY*      pVarArray = NULL;
    SAFEARRAY*      pBstrArray = NULL;
    VARIANT*        paVar = NULL;
    BSTR            bstr = NULL;
    LONG            i = 0;
    HRESULT         hr = ERROR_SUCCESS;

    try 
    {
        // Verify the Variant array.
        if (i_vtVariant.vt != (VT_ARRAY | VT_VARIANT)) {
            hr = WBEM_E_INVALID_PARAMETER;
            THROW_ON_ERROR(hr);
        }

        // Verify that the variant contains a safearray.
        pVarArray = i_vtVariant.parray;
        if (pVarArray == NULL) {
            hr = WBEM_E_INVALID_PARAMETER;
            THROW_ON_ERROR(hr);
        }

        // Initialize the out paramter.
        VariantInit(&o_vtBstr);

        // Get the size of the array.
        aDim.lLbound = 0;
        aDim.cElements = pVarArray->rgsabound[0].cElements;

        // Create the new BSTR array
        pBstrArray = SafeArrayCreate(VT_BSTR, 1, &aDim);
        if (pBstrArray == NULL) {
            hr = E_OUTOFMEMORY;
            THROW_ON_ERROR(hr);
        }

        // Put the array into the variant.
        o_vtBstr.vt = VT_ARRAY | VT_BSTR;
        o_vtBstr.parray = pBstrArray;

        // Get the variant array pointer.
        hr = SafeArrayAccessData(pVarArray, (void**)&paVar);
        THROW_ON_ERROR(hr);

        // Copy all the bstrs.
        for (i = aDim.lLbound; i < (long) aDim.cElements; i++)
        {
            if (paVar[i].vt != VT_BSTR) {
                hr = WBEM_E_FAILED;
                THROW_ON_ERROR(hr);
            }
            bstr = SysAllocString(paVar[i].bstrVal);
            if (bstr == NULL) {
                hr = E_OUTOFMEMORY;
                THROW_ON_ERROR(hr);
            }
            hr = SafeArrayPutElement(pBstrArray, &i, bstr);
            THROW_ON_ERROR(hr);    
            bstr = NULL;
        }

        hr = SafeArrayUnaccessData(pVarArray);
        THROW_ON_ERROR(hr);
    }
    catch (...)
    {
        // Destroy the variant, the safearray and the bstr's in the array.
        VariantClear(&o_vtBstr);

        // bstr may not have been put into array but was still allocated
        SysFreeString(bstr);
    }

    return hr;
}



HRESULT CIPSecurity::PutObjectAsync(
    IWbemClassObject* pObj
    )
{
    VARIANT vt;
    VARIANT vtVarArray;
    HRESULT hr;

    // IPDeny
    hr = pObj->Get(L"IPDeny", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr)) {
        hr = LoadVariantArrayFromBstrArray(vt, vtVarArray);
        VariantClear(&vt);
    
        if(SUCCEEDED(hr)) {
            hr = m_pIPSec->put_IPDeny(vtVarArray);
            VariantClear(&vtVarArray);
        }
    }

    // IPGrant
    if(SUCCEEDED(hr)) {
        hr = pObj->Get(L"IPGrant", 0, &vt, NULL, NULL);

        if(SUCCEEDED(hr)) {
            hr = LoadVariantArrayFromBstrArray(vt, vtVarArray);
            VariantClear(&vt);
        
            if(SUCCEEDED(hr)) {
                hr = m_pIPSec->put_IPGrant(vtVarArray);
                VariantClear(&vtVarArray);
            }
        }
    }

    // DomainDeny
    if(SUCCEEDED(hr)) {
        hr = pObj->Get(L"DomainDeny", 0, &vt, NULL, NULL);

        if(SUCCEEDED(hr)) {
            hr = LoadVariantArrayFromBstrArray(vt, vtVarArray);
            VariantClear(&vt);
        
            if(SUCCEEDED(hr)) {
                hr = m_pIPSec->put_DomainDeny(vtVarArray);
                VariantClear(&vtVarArray);
            }
        }
    }

    // DomainGrant
    if(SUCCEEDED(hr)) {
        hr = pObj->Get(L"DomainGrant", 0, &vt, NULL, NULL);

        if(SUCCEEDED(hr)) {
            hr = LoadVariantArrayFromBstrArray(vt, vtVarArray);
            VariantClear(&vt);
        
            if(SUCCEEDED(hr)) {
                hr = m_pIPSec->put_DomainGrant(vtVarArray);
                VariantClear(&vtVarArray);
            }
        }
    }

    // GrantByDefault
    if(SUCCEEDED(hr))
        hr = pObj->Get(L"GrantByDefault", 0, &vt, NULL, NULL);
    if(SUCCEEDED(hr))
        hr = m_pIPSec->put_GrantByDefault(vt.boolVal); 
    VariantClear(&vt);

    // set the modified IPSecurity back into the metabase
    if(SUCCEEDED(hr))
        hr = SetSD();

    return hr;
}

HRESULT CIPSecurity::OpenSD(_bstr_t bstrAdsPath)
{
    _variant_t var;
    HRESULT hr;
    IDispatch* pDisp = NULL;

    try
    {    // close SD interface first
        CloseSD();

        hr = GetAdsPath(bstrAdsPath);
        if(FAILED(hr))
           return hr;

        // get m_pADs
        hr = ADsGetObject(
             bstrAdsPath,
             IID_IADs,
             (void**)&m_pADs
             );
        if(FAILED(hr))
            return hr;
     
        // get m_pSD
        hr = m_pADs->Get(L"IPSecurity",&var);
        if(FAILED(hr))
            return hr;  
    
        hr = V_DISPATCH(&var)->QueryInterface(
            IID_IISIPSecurity,
            (void**)&m_pIPSec
            );
    }
    catch(...)
    {
        hr = E_FAIL;
    }

    return hr;
}


HRESULT CIPSecurity::SetSD()
{
    _variant_t var;
    HRESULT hr;
    IDispatch* pDisp = NULL;

    try
    {
        // put IPSecurity
        hr = m_pIPSec->QueryInterface(
            IID_IDispatch,
            (void**)&pDisp
            );
        if(FAILED(hr))
           return hr;

        var.vt = VT_DISPATCH;
        var.pdispVal = pDisp;
        hr = m_pADs->Put(L"IPSecurity",var);  // pDisp will be released by this call Put().
        if(FAILED(hr))
           return hr;

        // Commit the change to the active directory
        hr = m_pADs->SetInfo();
    }
    catch(...)
    {
        hr = E_FAIL;
    }

    return hr;
}


HRESULT CIPSecurity::GetAdsPath(_bstr_t& bstrAdsPath)
{
    WCHAR* p = new WCHAR[bstrAdsPath.length() + 1];
    if(p == NULL)
        return E_OUTOFMEMORY;

    lstrcpyW(p, bstrAdsPath);

    bstrAdsPath = L"IIS://LocalHost";

    // trim first three charaters "/LM" 
    bstrAdsPath += (p+3);

    delete [] p;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\iisprov.cpp ===
//***************************************************************************
//
//  IISPROV.CPP
//
//  Module: WMI IIS provider code
//
//  Purpose: Defines the CIISInstProvider class.  An object of this class is
//           created by the class factory for each connection.
//
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include "iisprov.h"


//***************************************************************************
//
// CIISInstProvider::CreateInstanceEnumAsync
//
// Purpose: Asynchronously enumerates the instances.  
//
//***************************************************************************

HRESULT CIISInstProvider::DoCreateInstanceEnumAsync( 
    const BSTR              a_ClassName,
    long                    a_lFlags, 
    IWbemContext*           a_pCtx, 
    IWbemObjectSink FAR*    a_pHandler
    )
{
    HRESULT t_hr = WBEM_S_NO_ERROR;
    IWbemClassObject FAR* t_pes = NULL;
  
    // Do a check of arguments and make sure we have pointer to Namespace

    if(a_pHandler == NULL || m_pNamespace == NULL)
        return WBEM_E_INVALID_PARAMETER;

    try 
    {
        CUtils obj;
        obj.EnumObjectAsync(a_ClassName, m_pNamespace, a_pHandler);
    }
    catch (CIIsProvException e)
    {
        t_pes = SetExtendedStatus(e.m_psz);
        t_hr = e.m_hr;
    }
    catch (HRESULT hr)
    {
        t_hr = hr;
    }
    catch (...) 
    {
        t_hr = WBEM_E_FAILED;
    }
   
    // Set status
    SCODE t_sc = a_pHandler->SetStatus(WBEM_STATUS_COMPLETE, t_hr, NULL, t_pes);
    if(t_pes)
        t_pes->Release();

    return t_sc;
}

HRESULT CIISInstProvider::DoDeleteInstanceAsync( 
    const BSTR          a_ObjectPath, 
    long                a_lFlags,
    IWbemContext*       a_pCtx,
    IWbemObjectSink*    a_pHandler
    )
{
    CObjectPathParser t_PathParser(e_ParserAcceptRelativeNamespace);
    ParsedObjectPath* t_pParsedObject = NULL;
    IWbemClassObject* t_pes = NULL;
    HRESULT           t_hr = WBEM_S_NO_ERROR;
    
    try
    {
        if(a_ObjectPath == NULL || a_pHandler == NULL || m_pNamespace == NULL)
            throw WBEM_E_INVALID_PARAMETER;

        if (t_PathParser.Parse(a_ObjectPath, &t_pParsedObject) != 
                CObjectPathParser::NoError)
            throw WBEM_E_INVALID_PARAMETER;

        if (t_pParsedObject == NULL)
            throw WBEM_E_FAILED;

        CUtils obj;
        CMetabase t_metabase;
        obj.DeleteObjectAsync(m_pNamespace, t_pParsedObject, t_metabase);
    }
    catch (CIIsProvException e)
    {
        t_pes = SetExtendedStatus(e.m_psz);
        t_hr = e.m_hr;
    }
    catch (HRESULT hr)
    {
        t_hr = hr;
    }
    catch (...) 
    {
        t_hr = WBEM_E_FAILED;
    }

    if (t_pParsedObject)
        t_PathParser.Free(t_pParsedObject);

    // Set status
    SCODE t_sc = a_pHandler->SetStatus(WBEM_STATUS_COMPLETE, t_hr, NULL, t_pes);
    if(t_pes)
        t_pes->Release();

    return t_sc;
}

//***************************************************************************
//
// CIISInstProvider::ExecMethodAsync
//
// Synopsis
//
//***************************************************************************

HRESULT CIISInstProvider::DoExecMethodAsync(
    const BSTR          a_strObjectPath,                   
    const BSTR          a_strMethodName,
    long                a_lFlags,                       
    IWbemContext*       a_pCtx,                 
    IWbemClassObject*   a_pInParams,
    IWbemObjectSink*    a_pHandler
    )
{
    HRESULT t_hr = WBEM_S_NO_ERROR;
    IWbemClassObject* t_pes = NULL;

    
    // Do a check of arguments and make sure we have pointer to Namespace

    if( a_pHandler == NULL || 
        m_pNamespace == NULL || 
        a_strMethodName == NULL || 
        a_strObjectPath == NULL )
        return WBEM_E_INVALID_PARAMETER;

    try 
    {
        CUtils obj;
        obj.ExecMethodAsync(
            a_strObjectPath,
            a_strMethodName, 
            a_pCtx,
            a_pInParams,
            a_pHandler,
            m_pNamespace
            );
    }
    catch (CIIsProvException e) 
    {
        t_pes = SetExtendedStatus(e.m_psz);
        t_hr = e.m_hr;
    }
    catch (HRESULT hr)
    {
        t_hr = hr;
    }
    catch (...)
    {
        t_hr = WBEM_E_FAILED;
    }

    // Set status
    SCODE t_sc = a_pHandler->SetStatus(WBEM_STATUS_COMPLETE, t_hr, NULL, t_pes);
    if(t_pes)
        t_pes->Release();

    return t_sc;
}

//***************************************************************************
//
// CIISInstProvider::GetObjectByPath
// CIISInstProvider::GetObjectByPathAsync
//
// Purpose: Creates an instance given a particular path value.
//
//***************************************************************************

HRESULT CIISInstProvider::DoGetObjectAsync(
    const BSTR          a_ObjectPath, 
    long                a_lFlags,
    IWbemContext*       a_pCtx,
    IWbemObjectSink*    a_pHandler
    )
{
    CObjectPathParser t_PathParser(e_ParserAcceptRelativeNamespace);
    ParsedObjectPath* t_pParsedObject = NULL;
    IWbemClassObject* t_pObj = NULL;
    IWbemClassObject* t_pes = NULL;
    HRESULT           t_hr = WBEM_S_NO_ERROR;
    
    try
    {
        if(a_ObjectPath == NULL || a_pHandler == NULL || m_pNamespace == NULL)
            throw WBEM_E_INVALID_PARAMETER;

        if (t_PathParser.Parse(a_ObjectPath, &t_pParsedObject) != 
                CObjectPathParser::NoError)
            throw WBEM_E_INVALID_PARAMETER;

        if (t_pParsedObject == NULL)
            throw WBEM_E_FAILED;

        CUtils obj;
        CMetabase t_metabase;
        t_hr = obj.GetObjectAsync(m_pNamespace, &t_pObj, t_pParsedObject, t_metabase);
    
        if(SUCCEEDED(t_hr) && t_pObj)
        {
            t_hr = a_pHandler->Indicate(1,&t_pObj);
            t_pObj->Release();
        }
    }
    catch (CIIsProvException e)
    {
        t_pes = SetExtendedStatus(e.m_psz);
        t_hr = e.m_hr;
    }
    catch (HRESULT hr)
    {
        t_hr = hr;
    }
    catch (...) 
    {
        t_hr = WBEM_E_FAILED;
    }

    if (t_pParsedObject)
        t_PathParser.Free(t_pParsedObject);

    // Set status
    SCODE t_sc = a_pHandler->SetStatus(WBEM_STATUS_COMPLETE, t_hr, NULL, t_pes);
    if(t_pes)
        t_pes->Release();

    return t_sc;
}
    
HRESULT CIISInstProvider::DoPutInstanceAsync( 
    IWbemClassObject*    a_pObj,
    long                 a_lFlags,
    IWbemContext*        a_pCtx,
    IWbemObjectSink*     a_pHandler
    )
{
    HRESULT            t_hr = ERROR_SUCCESS;
    CObjectPathParser  t_PathParser(e_ParserAcceptRelativeNamespace);
    ParsedObjectPath*  t_pParsedObject = NULL;
    IWbemClassObject*  t_pObjOld = NULL;
    IWbemClassObject*  t_pes = NULL;

    CUtils obj;
    CMetabase t_metabase;

    try 
    {
        if (a_pObj == NULL || a_pCtx == NULL || a_pHandler == NULL)
            throw WBEM_E_INVALID_PARAMETER;

        _bstr_t t_bstr = L"__RelPath"; 
        _variant_t t_vt;
        t_hr = a_pObj->Get(t_bstr, 0, &t_vt, NULL, NULL);
        THROW_ON_ERROR(t_hr);

        if (t_vt.vt != VT_BSTR) 
            throw WBEM_E_INVALID_OBJECT;
    
        if (t_PathParser.Parse(t_vt.bstrVal, &t_pParsedObject) != CObjectPathParser::NoError) 
            throw WBEM_E_INVALID_PARAMETER;

        if (t_pParsedObject == NULL)
            throw WBEM_E_FAILED;
    
        t_hr = obj.GetObjectAsync(m_pNamespace, &t_pObjOld, t_pParsedObject, t_metabase);
    }    
    catch (CIIsProvException e)
    {
        t_pes = SetExtendedStatus(e.m_psz);
        t_hr = e.m_hr;
    }
    catch (HRESULT hr)
    {
        t_hr = hr;
    }
    catch (...)
    {
        t_hr = WBEM_E_FAILED;
    }
    
    // a second try catch? messy.
    // will cleanup when exception handling is removed
    try
    {
        if(SUCCEEDED(t_hr) ||
           HRESULT_CODE(t_hr) == ERROR_PATH_NOT_FOUND) 
        {
            if(HRESULT_CODE(t_hr) == ERROR_PATH_NOT_FOUND) {
                t_hr = 0;
            }
            obj.PutObjectAsync(a_pObj, t_pObjOld, t_pParsedObject, a_lFlags);
        }
    }
    catch (CIIsProvException e)
    {
        t_pes = SetExtendedStatus(e.m_psz);
        t_hr = e.m_hr;
    }
    catch (HRESULT hr)
    {
        t_hr = hr;
    }
    catch (...)
    {
        t_hr = WBEM_E_FAILED;
    }
    //

    if (t_pObjOld)
        t_pObjOld->Release();

    if (t_pParsedObject)
        t_PathParser.Free(t_pParsedObject);

    // Set status
    SCODE t_sc = a_pHandler->SetStatus(WBEM_STATUS_COMPLETE, t_hr, NULL, t_pes);
    if(t_pes)
        t_pes->Release();

    return t_sc;
}

IWbemClassObject* CIISInstProvider::SetExtendedStatus(WCHAR* a_psz)
{
    HRESULT t_hr;
    IWbemClassObject* t_pclass;
    IWbemClassObject* t_pes;

    _bstr_t t_bstr = L"__ExtendedStatus";
    t_hr = m_pNamespace->GetObject(
        t_bstr,
        0,
        NULL,
        &t_pclass,
        NULL
        );

    if (t_hr != ERROR_SUCCESS)
        return NULL;

    t_hr = t_pclass->SpawnInstance(0, &t_pes);
    t_pclass->Release();
    
    if (t_hr != ERROR_SUCCESS || t_pes)
        return NULL;

    _variant_t t_vt = a_psz;

    if (!t_vt.bstrVal)
        return NULL;

    t_hr = t_pes->Put(L"Description", 0, &t_vt, 0);

    if (t_hr != ERROR_SUCCESS || t_pes)
    {
        t_pes->Release();
        return NULL;
    }

    return t_pes;   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\iiscnfgp.h ===
/*++

   Copyright (c) 1997-1999 Microsoft Corporation

   Module  Name :

       iiscnfgp.h

   Abstract:

        Contains private Metadata IDs used internally by IIS.

   Environment:

      Win32 User Mode

--*/

#ifndef _IISCNFGP_H_
#define _IISCNFGP_H_

#include <iiscnfg.h>

#define MD_CLUSTER_ENABLED              (IIS_MD_SERVER_BASE+25 )

#define MD_CLUSTER_SERVER_COMMAND       (IIS_MD_SERVER_BASE+26 )

//
// Set by server at startup
//

#define MD_SERVER_PLATFORM              (IIS_MD_SERVER_BASE+100 )
#define MD_SERVER_VERSION_MAJOR         (IIS_MD_SERVER_BASE+101 )
#define MD_SERVER_VERSION_MINOR         (IIS_MD_SERVER_BASE+102 )
#define MD_SERVER_CAPABILITIES          (IIS_MD_SERVER_BASE+103 )

typedef VOID (WINAPI * PFN_MAPPER_TOUCHED)( VOID );

#define MD_SSL_MINSTRENGTH              (IIS_MD_HTTP_BASE+30)
#define MD_SSL_ALG                      (IIS_MD_HTTP_BASE+31)
#define MD_SSL_PROTO                    (IIS_MD_HTTP_BASE+32)
#define MD_SSL_CA                       (IIS_MD_HTTP_BASE+33)

#define MD_ETAG_CHANGE_NUMBER           (IIS_MD_HTTP_BASE+39)

#define MD_AUTH_CHANGE_URL              (IIS_MD_HTTP_BASE+60 )
#define MD_AUTH_EXPIRED_URL             (IIS_MD_HTTP_BASE+61 )
#define MD_AUTH_NOTIFY_PWD_EXP_URL      (IIS_MD_HTTP_BASE+62 )
#define MD_AUTH_EXPIRED_UNSECUREURL     (IIS_MD_HTTP_BASE+67 )
#define MD_AUTH_NOTIFY_PWD_EXP_UNSECUREURL  (IIS_MD_HTTP_BASE+69 )

//
//  Account Mapping properties - these are INTERNAL ONLY and currently
//  reside under /LM/W3Svc/{instance}/<Account Mapper NSE>
//

#define MD_MAPCERT                      (IIS_MD_HTTP_BASE+78 )
#define MD_MAPNTACCT                    (IIS_MD_HTTP_BASE+79 )
#define MD_MAPNAME                      (IIS_MD_HTTP_BASE+80 )
#define MD_MAPENABLED                   (IIS_MD_HTTP_BASE+81 )
#define MD_MAPREALM                     (IIS_MD_HTTP_BASE+82 )
#define MD_MAPPWD                       (IIS_MD_HTTP_BASE+83 )
#define MD_ITACCT                       (IIS_MD_HTTP_BASE+84 )
#define MD_CPP_CERT11                   (IIS_MD_HTTP_BASE+85 )
#define MD_SERIAL_CERT11                (IIS_MD_HTTP_BASE+86 )
#define MD_CPP_CERTW                    (IIS_MD_HTTP_BASE+87 )
#define MD_SERIAL_CERTW                 (IIS_MD_HTTP_BASE+88 )
#define MD_CPP_DIGEST                   (IIS_MD_HTTP_BASE+89 )
#define MD_SERIAL_DIGEST                (IIS_MD_HTTP_BASE+90 )
#define MD_CPP_ITA                      (IIS_MD_HTTP_BASE+91 )
#define MD_SERIAL_ITA                   (IIS_MD_HTTP_BASE+92 )
#define MD_MAPNTPWD                     (IIS_MD_HTTP_BASE+93 )
#define MD_SERIAL_ISSUERS               (IIS_MD_HTTP_BASE+94 )
#define MD_NOTIFY_CERT11_TOUCHED        (IIS_MD_HTTP_BASE+96)

#define MD_NSEPM_ACCESS_ACCOUNT         (IIS_MD_HTTP_BASE+72 )
#define MD_NSEPM_ACCESS_CERT            (IIS_MD_HTTP_BASE+73 )
#define MD_NSEPM_ACCESS_NAME            (IIS_MD_HTTP_BASE+74 )
#define MD_SERIAL_ALL_CERT11            (IIS_MD_HTTP_BASE+76 )
#define MD_SERIAL_ALL_DIGEST            (IIS_MD_HTTP_BASE+77 )

#define MD_APP_LAST_OUTPROC_PID         (IIS_MD_HTTP_BASE+108)
#define MD_APP_STATE                    (IIS_MD_HTTP_BASE+109)
// Default value for MD_APP_OOP_RECOVER_LIMIT
#define APP_OOP_RECOVER_LIMIT_DEFAULT   ((DWORD)-1)

// Used by U2 to tell www admin UI that U2 authentication is installed
#define MD_U2_AUTH                      (IIS_MD_HTTP_BASE+117)

//
//  Private CAL configuration parameters
//

#define MD_CAL_MODE                     (IIS_MD_HTTP_BASE+134)
#define MD_CAL_AUTH_ERRORS              (IIS_MD_HTTP_BASE+135)
#define MD_CAL_SSL_ERRORS               (IIS_MD_HTTP_BASE+136)

#define MD_LB_REDIRECTED_HOST           (IIS_MD_HTTP_BASE+137 )
#define MD_LB_USER_AGENT_LIST           (IIS_MD_HTTP_BASE+138 )

#define MD_CERT_CHECK_MODE      (IIS_MD_HTTP_BASE+160)
#define MD_VR_ACL                       (IIS_MD_VR_BASE+4 )
//
// This is used to flag down updated vr entries - Used for migrating vroots
//

#define MD_VR_UPDATE                    (IIS_MD_VR_BASE+5 )
#define MD_SSL_FRIENDLY_NAME            ( IIS_MD_SSL_BASE+4 )
#define MD_SSL_IDENT                    ( IIS_MD_SSL_BASE+5 )
#define MD_SSL_CERT_HASH                ( IIS_MD_SSL_BASE+6 )
#define MD_SSL_CERT_CONTAINER           ( IIS_MD_SSL_BASE+7 )
#define MD_SSL_CERT_PROVIDER            ( IIS_MD_SSL_BASE+8 )
#define MD_SSL_CERT_PROVIDER_TYPE       ( IIS_MD_SSL_BASE+9 )
#define MD_SSL_CERT_OPEN_FLAGS          ( IIS_MD_SSL_BASE+10 )
#define MD_SSL_CERT_STORE_NAME          ( IIS_MD_SSL_BASE+11 )
#define MD_SSL_CTL_IDENTIFIER           ( IIS_MD_SSL_BASE+12 )
#define MD_SSL_CTL_CONTAINER            ( IIS_MD_SSL_BASE+13 )
#define MD_SSL_CTL_PROVIDER             ( IIS_MD_SSL_BASE+14 )
#define MD_SSL_CTL_PROVIDER_TYPE        ( IIS_MD_SSL_BASE+15 )
#define MD_SSL_CTL_OPEN_FLAGS           ( IIS_MD_SSL_BASE+16 )
#define MD_SSL_CTL_STORE_NAME           ( IIS_MD_SSL_BASE+17 )
#define MD_SSL_CTL_SIGNER_HASH          ( IIS_MD_SSL_BASE+18 )
//
// Metabase property that holds SSL replication information
//
#define MD_SSL_REPLICATION_INFO         ( IIS_MD_SSL_BASE+20 )
#define   MD_SSL_CERT_ENROLL_HISTORY        ( IIS_MD_SSL_BASE+31 )
#define   MD_SSL_CERT_ENROLL_TIME           ( IIS_MD_SSL_BASE+32 )
#define   MD_SSL_CERT_ENROLL_STATE          ( IIS_MD_SSL_BASE+33 )
#define   MD_SSL_CERT_ENROLL_STATE_ERROR    ( IIS_MD_SSL_BASE+34 )
#define MD_SSL_CERT_IS_FORTEZZA             ( IIS_MD_SSL_BASE+35 )
#define MD_SSL_CERT_FORTEZZA_PIN            ( IIS_MD_SSL_BASE+36 )
#define MD_SSL_CERT_FORTEZZA_SERIAL_NUMBER  ( IIS_MD_SSL_BASE+37 )
#define MD_SSL_CERT_FORTEZZA_PERSONALITY    ( IIS_MD_SSL_BASE+38 )
#define MD_SSL_CERT_FORTEZZA_PROG_PIN       ( IIS_MD_SSL_BASE+39 )
#define MD_SSL_CERT_WIZ_DEBUG                      ( IIS_MD_SSL_BASE+50 )
#define MD_SSL_CERT_WIZHIST_SZ_TARGET_CA           ( IIS_MD_SSL_BASE+51 )
#define MD_SSL_CERT_WIZHIST_SZ_FILE_NAME_USED_LAST ( IIS_MD_SSL_BASE+52 )
#define MD_SSL_CERT_WIZHIST_SZ_DN_COMMON_NAME      ( IIS_MD_SSL_BASE+53 )
#define MD_SSL_CERT_WIZHIST_SZ_DN_O                ( IIS_MD_SSL_BASE+54 )
#define MD_SSL_CERT_WIZHIST_SZ_DN_OU               ( IIS_MD_SSL_BASE+55 )
#define MD_SSL_CERT_WIZHIST_SZ_DN_C                ( IIS_MD_SSL_BASE+56 )
#define MD_SSL_CERT_WIZHIST_SZ_DN_L                ( IIS_MD_SSL_BASE+57 )
#define MD_SSL_CERT_WIZHIST_SZ_DN_S                ( IIS_MD_SSL_BASE+58 )
#define MD_SSL_CERT_WIZHIST_SZ_USER_NAME           ( IIS_MD_SSL_BASE+59 )
#define MD_SSL_CERT_WIZHIST_SZ_USER_PHONE          ( IIS_MD_SSL_BASE+60 )
#define MD_SSL_CERT_WIZHIST_SZ_USER_EMAIL          ( IIS_MD_SSL_BASE+61 )

#define MD_SSL_CERT_WIZGUID_ICERTGETCONFIG         ( IIS_MD_SSL_BASE+71 )
#define MD_SSL_CERT_WIZGUID_ICERTREQUEST           ( IIS_MD_SSL_BASE+72 )
#define MD_SSL_CERT_WIZGUID_XENROLL                ( IIS_MD_SSL_BASE+73 )
#define MD_SSL_CERT_WIZGUID_ICERTCONFIG            ( IIS_MD_SSL_BASE+74 )

#define MD_SSL_CERT_WIZ_OOB_PKCS10                 ( IIS_MD_SSL_BASE+80 )
#define MD_SSL_CERT_WIZ_OOB_PKCS10_ACCEPTED        ( IIS_MD_SSL_BASE+81 )
#define MD_SSL_CERT_WIZ_OOB_TEMPCERT               ( IIS_MD_SSL_BASE+82 )
#define MD_CONTENT_NEGOTIATION          (IIS_MD_FILE_PROP_BASE+7 )
#define MD_NOTIFY_EXAUTH                (IIS_MD_FILE_PROP_BASE+40 )

//
// The following are "Virtual Properties", in that they have prop values in
// the Metabase schema, but sets map to a particular metabase property.
// For the most part these are where a DWORD property is used as a bitfield.
//

#define MD_VPROP_DIRBROW_SHOW_DATE            (IIS_MD_FILE_PROP_BASE+200 )
#define MD_VPROP_DIRBROW_SHOW_TIME            (IIS_MD_FILE_PROP_BASE+201 )
#define MD_VPROP_DIRBROW_SHOW_SIZE            (IIS_MD_FILE_PROP_BASE+202 )
#define MD_VPROP_DIRBROW_SHOW_EXTENSION       (IIS_MD_FILE_PROP_BASE+203)
#define MD_VPROP_DIRBROW_LONG_DATE            (IIS_MD_FILE_PROP_BASE+204 )

#define MD_VPROP_DIRBROW_ENABLED              (IIS_MD_FILE_PROP_BASE+205 )  // Allow directory browsing
#define MD_VPROP_DIRBROW_LOADDEFAULT          (IIS_MD_FILE_PROP_BASE+206 )  // Load default doc if exists

#define MD_VPROP_ACCESS_READ                  (IIS_MD_FILE_PROP_BASE+207 )    // Allow for Read
#define MD_VPROP_ACCESS_WRITE                 (IIS_MD_FILE_PROP_BASE+208 )    // Allow for Write
#define MD_VPROP_ACCESS_EXECUTE               (IIS_MD_FILE_PROP_BASE+209 )    // Allow for Execute
#define MD_VPROP_ACCESS_SCRIPT                (IIS_MD_FILE_PROP_BASE+211 )    // Allow for Script execution

#define MD_VPROP_ACCESS_SSL                   (IIS_MD_FILE_PROP_BASE+213 )    // Require SSL
#define MD_VPROP_ACCESS_NEGO_CERT             (IIS_MD_FILE_PROP_BASE+214 )    // Allow client SSL certs
#define MD_VPROP_ACCESS_REQUIRE_CERT          (IIS_MD_FILE_PROP_BASE+215 )    // Require client SSL certs
#define MD_VPROP_ACCESS_MAP_CERT              (IIS_MD_FILE_PROP_BASE+216 )    // Map SSL cert to NT account
#define MD_VPROP_ACCESS_SSL128                (IIS_MD_FILE_PROP_BASE+217 )    // Require 128 bit SSL

#define MD_VPROP_AUTH_ANONYMOUS               (IIS_MD_FILE_PROP_BASE+218 )
#define MD_VPROP_AUTH_BASIC                   (IIS_MD_FILE_PROP_BASE+219 )
#define MD_VPROP_AUTH_NT                      (IIS_MD_FILE_PROP_BASE+220 )    // Use NT auth provider (like NTLM)
#define MD_VPROP_AUTH_MD5                     (IIS_MD_FILE_PROP_BASE+221 )
#define MD_VPROP_AUTH_MAPBASIC                (IIS_MD_FILE_PROP_BASE+222 )

#define MD_VPROP_SERVER_CONFIG_SSL_40         (IIS_MD_FILE_PROP_BASE+223 )
#define MD_VPROP_SERVER_CONFIG_SSL_128        (IIS_MD_FILE_PROP_BASE+224 )
#define MD_VPROP_SERVER_CONFIG_ALLOW_ENCRYPT  (IIS_MD_FILE_PROP_BASE+225 )
#define MD_VPROP_SERVER_CONFIG_AUTO_PW_SYNC   (IIS_MD_FILE_PROP_BASE+226 )

#define MD_VPROP_ACCESS_NO_REMOTE_WRITE       (IIS_MD_FILE_PROP_BASE+230 )    // Local host access only
#define MD_VPROP_ACCESS_NO_REMOTE_READ        (IIS_MD_FILE_PROP_BASE+231 )    // Local host access only
#define MD_VPROP_ACCESS_NO_REMOTE_EXECUTE     (IIS_MD_FILE_PROP_BASE+232 )    // Local host access only
#define MD_VPROP_ACCESS_NO_REMOTE_SCRIPT      (IIS_MD_FILE_PROP_BASE+233 )    // Local host access only

#define MD_VPROP_EXTLOG_DATE                  (IIS_MD_FILE_PROP_BASE+234 )
#define MD_VPROP_EXTLOG_TIME                  (IIS_MD_FILE_PROP_BASE+235 )
#define MD_VPROP_EXTLOG_CLIENT_IP             (IIS_MD_FILE_PROP_BASE+236 )
#define MD_VPROP_EXTLOG_USERNAME              (IIS_MD_FILE_PROP_BASE+237 )
#define MD_VPROP_EXTLOG_SITE_NAME             (IIS_MD_FILE_PROP_BASE+238 )
#define MD_VPROP_EXTLOG_COMPUTER_NAME         (IIS_MD_FILE_PROP_BASE+239 )
#define MD_VPROP_EXTLOG_SERVER_IP             (IIS_MD_FILE_PROP_BASE+240 )
#define MD_VPROP_EXTLOG_METHOD                (IIS_MD_FILE_PROP_BASE+241 )
#define MD_VPROP_EXTLOG_URI_STEM              (IIS_MD_FILE_PROP_BASE+242 )
#define MD_VPROP_EXTLOG_URI_QUERY             (IIS_MD_FILE_PROP_BASE+243 )
#define MD_VPROP_EXTLOG_HTTP_STATUS           (IIS_MD_FILE_PROP_BASE+244 )
#define MD_VPROP_EXTLOG_WIN32_STATUS          (IIS_MD_FILE_PROP_BASE+245 )
#define MD_VPROP_EXTLOG_BYTES_SENT            (IIS_MD_FILE_PROP_BASE+246 )
#define MD_VPROP_EXTLOG_BYTES_RECV            (IIS_MD_FILE_PROP_BASE+247 )
#define MD_VPROP_EXTLOG_TIME_TAKEN            (IIS_MD_FILE_PROP_BASE+248 )
#define MD_VPROP_EXTLOG_SERVER_PORT           (IIS_MD_FILE_PROP_BASE+249 )
#define MD_VPROP_EXTLOG_USER_AGENT            (IIS_MD_FILE_PROP_BASE+250 )
#define MD_VPROP_EXTLOG_COOKIE                (IIS_MD_FILE_PROP_BASE+251 )
#define MD_VPROP_EXTLOG_REFERER               (IIS_MD_FILE_PROP_BASE+252 )

#define MD_VPROP_NOTIFY_SECURE_PORT           (IIS_MD_FILE_PROP_BASE+253 )
#define MD_VPROP_NOTIFY_NONSECURE_PORT        (IIS_MD_FILE_PROP_BASE+254 )
#define MD_VPROP_NOTIFY_READ_RAW_DATA         (IIS_MD_FILE_PROP_BASE+255 )
#define MD_VPROP_NOTIFY_PREPROC_HEADERS       (IIS_MD_FILE_PROP_BASE+256 )
#define MD_VPROP_NOTIFY_AUTHENTICATION        (IIS_MD_FILE_PROP_BASE+257 )
#define MD_VPROP_NOTIFY_URL_MAP               (IIS_MD_FILE_PROP_BASE+258 )
#define MD_VPROP_NOTIFY_ACCESS_DENIED         (IIS_MD_FILE_PROP_BASE+259 )
#define MD_VPROP_NOTIFY_SEND_RESPONSE         (IIS_MD_FILE_PROP_BASE+260 )
#define MD_VPROP_NOTIFY_SEND_RAW_DATA         (IIS_MD_FILE_PROP_BASE+261 )
#define MD_VPROP_NOTIFY_LOG                   (IIS_MD_FILE_PROP_BASE+262 )
#define MD_VPROP_NOTIFY_END_OF_REQUEST        (IIS_MD_FILE_PROP_BASE+263 )
#define MD_VPROP_NOTIFY_END_OF_NET_SESSION    (IIS_MD_FILE_PROP_BASE+264 )
#define MD_VPROP_NOTIFY_ORDER_HIGH            (IIS_MD_FILE_PROP_BASE+265 )
#define MD_VPROP_NOTIFY_ORDER_MEDIUM          (IIS_MD_FILE_PROP_BASE+266 )
#define MD_VPROP_NOTIFY_ORDER_LOW             (IIS_MD_FILE_PROP_BASE+267 )
#define MD_VPROP_EXTLOG_PROTOCOL_VERSION      (IIS_MD_FILE_PROP_BASE+268 )

#define MD_ISM_ACCESS_CHECK                   (IIS_MD_FILE_PROP_BASE+269 )

#define MD_VPROP_CPU_ENABLE_ALL_PROC_LOGGING  (IIS_MD_FILE_PROP_BASE+270 )
#define MD_VPROP_CPU_ENABLE_CGI_LOGGING       (IIS_MD_FILE_PROP_BASE+271 )
#define MD_VPROP_CPU_ENABLE_APP_LOGGING       (IIS_MD_FILE_PROP_BASE+272 )
#define MD_VPROP_CPU_ENABLE_EVENT             (IIS_MD_FILE_PROP_BASE+273 )
#define MD_VPROP_CPU_ENABLE_PROC_TYPE         (IIS_MD_FILE_PROP_BASE+274 )
#define MD_VPROP_CPU_ENABLE_USER_TIME         (IIS_MD_FILE_PROP_BASE+275 )
#define MD_VPROP_CPU_ENABLE_KERNEL_TIME       (IIS_MD_FILE_PROP_BASE+276 )
#define MD_VPROP_CPU_ENABLE_PAGE_FAULTS       (IIS_MD_FILE_PROP_BASE+277 )
#define MD_VPROP_CPU_ENABLE_TOTAL_PROCS       (IIS_MD_FILE_PROP_BASE+278 )
#define MD_VPROP_CPU_ENABLE_ACTIVE_PROCS      (IIS_MD_FILE_PROP_BASE+279 )
#define MD_VPROP_CPU_ENABLE_TERMINATED_PROCS  (IIS_MD_FILE_PROP_BASE+280 )
#define MD_VPROP_CPU_ENABLE_LOGGING           (IIS_MD_FILE_PROP_BASE+281 )
#define MD_VPROP_ACCESS_READ_SOURCE           (IIS_MD_FILE_PROP_BASE+282 )    // part of MD_ACCESS_PERM bit

#define MD_VPROP_AUTH_SINGLEREQUEST                 (IIS_MD_FILE_PROP_BASE+283 )
#define MD_VPROP_AUTH_SINGLEREQUESTIFPROXY          (IIS_MD_FILE_PROP_BASE+284 )
#define MD_VPROP_AUTH_SINGLEREQUESTALWAYSIFPROXY    (IIS_MD_FILE_PROP_BASE+285 )

//
//  The following properties are used for ADSI schema only
//

#define MD_SCHEMA_CLASS_CONTAINMENT           (IIS_MD_FILE_PROP_BASE+350 )
#define MD_SCHEMA_CLASS_CONTAINER             (IIS_MD_FILE_PROP_BASE+351 )
#define MD_SCHEMA_CLASS_CLSID                 (IIS_MD_FILE_PROP_BASE+352 )
#define MD_SCHEMA_CLASS_OID                   (IIS_MD_FILE_PROP_BASE+353 )
#define MD_SCHEMA_CLASS_PRIMARY_INTERFACE     (IIS_MD_FILE_PROP_BASE+354 )
#define MD_SCHEMA_CLASS_OPT_PROPERTIES        (IIS_MD_FILE_PROP_BASE+355 )
#define MD_SCHEMA_CLASS_MAND_PROPERTIES       (IIS_MD_FILE_PROP_BASE+356 )
#define MD_AUTH_MD5                     0x00000010
#define MD_AUTH_MAPBASIC                0x00000020
#define MD_SERVER_STATE_INVALID         ((DWORD)(-1L))

// NOTE: This value is reserved for internal use by the server,
// and cannot be set in the metabase.

#define MD_SCRIPTMAPFLAG_WILDCARD                   0x80000000

#ifdef REMOVE   // SteveBr
//
//  This flag gets ORed in by the server for *all* script maps - i.e., if an
//  entry is in the script map list, then it will never be allowed to be sent.
//  We leave the flag but make it private in case we decide to expose this
//  functionality
//

#define MD_SCRIPTMAPFLAG_NOTRANSMIT_ON_READ_DIR     0x00000002
#endif // REMOVE

//
//  Valid values for MD_CAL_MODE
//

#define MD_CAL_MODE_NONE        0
#define MD_CAL_MODE_HTTPERR     1
#define MD_CAL_MODE_LOGCOUNT    2


#endif // _IISCNFGP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\metabase.h ===
#ifndef _metabase_h_
#define _metabase_h_


#define MAX_METABASE_PATH 1024
#define METABASE_TIMEOUT 5000

// declare a synch object for write access of metabase 
class CSynchObject 
{
private:
    
    CRITICAL_SECTION m_cs;

public:
    
    CSynchObject()
    {
        // Initialize the critical section
        InitializeCriticalSection(&m_cs); 
    }

    ~CSynchObject()
    {
        // Release resources used by the critical section object
        DeleteCriticalSection(&m_cs);
    }

    void Enter()
    {
        // wait for and take ownership of the critical section object
        EnterCriticalSection(&m_cs); 
    }

    void Leave()
    {
        // Release ownership of the critical section object
        LeaveCriticalSection(&m_cs);
    }
};


class CMetabase
{
private:

    IMSAdminBase*     m_pIABase;
    
    void CreateMultiSzFromSafeArray(_variant_t&, WCHAR**,DWORD*);
    void LoadSafeArrayFromMultiSz(WCHAR*, _variant_t&);
    bool CheckKeyType(enum_KEY_TYPE&, LPCWSTR);
    bool CompareMultiSz(WCHAR* a_pmsz1, WCHAR* a_pmsz2);

public:

    CMetabase();
    ~CMetabase();

    HRESULT Backup(LPCWSTR, DWORD, DWORD);
    HRESULT DeleteBackup(LPCWSTR, DWORD);
    HRESULT EnumBackups(LPWSTR, DWORD*, PFILETIME, DWORD);
    HRESULT Restore(LPCWSTR, DWORD, DWORD);

    void CloseKey(METADATA_HANDLE);
    METADATA_HANDLE OpenKey(LPCWSTR, BOOL);
    METADATA_HANDLE CreateKey(LPCWSTR);
    bool CheckKey(LPCWSTR);
    HRESULT DeleteKey(METADATA_HANDLE, LPCWSTR);

    void GetDword(METADATA_HANDLE, METABASE_PROPERTY*, _variant_t&);
    void GetString(METADATA_HANDLE, METABASE_PROPERTY*, _variant_t&);
    void GetMultiSz(METADATA_HANDLE, METABASE_PROPERTY*, _variant_t&);
    long GetWin32Error(METADATA_HANDLE);

    void PutDword(METADATA_HANDLE, METABASE_PROPERTY*, _variant_t&, _variant_t*, bool=false);
    void PutString(METADATA_HANDLE, METABASE_PROPERTY*, _variant_t&, _variant_t*, bool=false);
    void PutMultiSz(METADATA_HANDLE, METABASE_PROPERTY*, _variant_t&, _variant_t*, bool=false);
    void PutMethod(METADATA_HANDLE, DWORD);

    void DeleteData(METADATA_HANDLE, METABASE_PROPERTY*);
    void DeleteData(METADATA_HANDLE, DWORD, DWORD);
    HRESULT EnumKeys(METADATA_HANDLE, LPCWSTR, LPWSTR, DWORD*, enum_KEY_TYPE&);
    HRESULT WebAppCheck(METADATA_HANDLE);
    HRESULT WebAppGetStatus(METADATA_HANDLE, PDWORD);
    HRESULT WebAppSetStatus(METADATA_HANDLE, DWORD);
};


class CWebAppMethod
{
private:

    IWamAdmin2*   m_pWamAdmin;

public:

    CWebAppMethod();
    ~CWebAppMethod();
    
    HRESULT AppCreate(LPCWSTR, bool);
    HRESULT AppCreate2(LPCWSTR, long);
    HRESULT AppDelete(LPCWSTR, bool);
    HRESULT AppUnLoad(LPCWSTR, bool);
    HRESULT AppDisable(LPCWSTR, bool);
    HRESULT AppEnable(LPCWSTR, bool);
    HRESULT AppGetStatus(LPCWSTR, DWORD*);
    HRESULT AspAppRestart(LPCWSTR);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\metabase.cpp ===
//***************************************************************************
//
//  metsbase.cpp
//
//  Module: WBEM Instance provider
//
//  Purpose: IIS metabase class 
//
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************


#include "iisprov.h"
#include "debug.h"


CMetabase::CMetabase()
{ 
    HRESULT hr = CoCreateInstance(
        CLSID_MSAdminBase,
        NULL,
        CLSCTX_ALL,
        IID_IMSAdminBase,
        (void**)&m_pIABase
        );

    THROW_ON_ERROR(hr);
}

CMetabase::~CMetabase()
{
    if(m_pIABase)
        m_pIABase->Release();
}


HRESULT CMetabase::Backup( 
    LPCWSTR pszMDBackupLocation, 
    DWORD   dwMDVersion, 
    DWORD   dwMDFlags 
    )
{
    HRESULT hr;
    hr = m_pIABase->Backup(
        pszMDBackupLocation, 
        dwMDVersion,
        dwMDFlags);

    return hr;
}


HRESULT CMetabase::DeleteBackup( 
    LPCWSTR pszMDBackupLocation, 
    DWORD   dwMDVersion 
    )
{
    HRESULT hr;
    hr = m_pIABase->DeleteBackup(
        pszMDBackupLocation, 
        dwMDVersion
        );

    return hr;
}

HRESULT CMetabase::EnumBackups( 
    LPWSTR    pszMDBackupLocation, 
    DWORD*    pdwMDVersion, 
    PFILETIME pftMDBackupTime, 
    DWORD     dwMDEnumIndex 
    )
{
    HRESULT hr;
    hr = m_pIABase->EnumBackups(
        pszMDBackupLocation, 
        pdwMDVersion,
        pftMDBackupTime,
        dwMDEnumIndex
        );

    return hr;
}

HRESULT CMetabase::Restore( 
    LPCWSTR pszMDBackupLocation, 
    DWORD   dwMDVersion, 
    DWORD   dwMDFlags 
    )
{
    HRESULT hr;
    hr = m_pIABase->Restore(
        pszMDBackupLocation, 
        dwMDVersion,
        dwMDFlags);

    return hr;
}
 
void CMetabase::CloseKey(METADATA_HANDLE a_hKey)
{
    if(a_hKey && m_pIABase)
    {
        m_pIABase->CloseKey(a_hKey);
        TRACE1(L"Close Key: %x\n", a_hKey);
    }
}

// open key handle
METADATA_HANDLE CMetabase::OpenKey(LPCWSTR a_pstrKey, BOOL bWrite)
{
    METADATA_HANDLE t_hKey = NULL;

    DWORD dwMDAccessRequested;
    if(bWrite)
        dwMDAccessRequested = METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE;
    else
        dwMDAccessRequested = METADATA_PERMISSION_READ;
   
    HRESULT t_hr = m_pIABase->OpenKey( 
        METADATA_MASTER_ROOT_HANDLE,
        a_pstrKey,
        dwMDAccessRequested,
        METABASE_TIMEOUT,       // 5 seconds
        &t_hKey 
        );

    if(t_hr == ERROR_PATH_BUSY)     // retry one time
        t_hr = m_pIABase->OpenKey( 
            METADATA_MASTER_ROOT_HANDLE,
            a_pstrKey,
            dwMDAccessRequested,
            METABASE_TIMEOUT,       // 5 seconds
            &t_hKey 
            );

    THROW_ON_ERROR(t_hr);

    TRACE2(L"Open Key on %s, returned handle %x\n", a_pstrKey, t_hKey);
    return t_hKey;
}


// force to create or open a key by read/write permision
METADATA_HANDLE CMetabase::CreateKey(LPCWSTR a_pstrKey)
{
    HRESULT t_hr;
    METADATA_HANDLE t_hKey;

    // open and return key if exists
    t_hr = m_pIABase->OpenKey( 
        METADATA_MASTER_ROOT_HANDLE,
        a_pstrKey,
        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
        METABASE_TIMEOUT,       // 5 seconds
        &t_hKey
        );

    if (t_hr == ERROR_SUCCESS) 
    {
        TRACE2(L"Open Key on %s, returned handle %x\n", a_pstrKey, t_hKey);
        return t_hKey;
    }

    //  create key if not there
    t_hr = m_pIABase->OpenKey( 
        METADATA_MASTER_ROOT_HANDLE,
        NULL,
        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
        METABASE_TIMEOUT,       // 5 seconds
        &t_hKey
        );
    THROW_ON_ERROR(t_hr);

    // add key
    t_hr = m_pIABase->AddKey(t_hKey, a_pstrKey);

    // close this root key first
    CloseKey(t_hKey);
    THROW_ON_ERROR(t_hr);

    // now open the key just created
    t_hr = m_pIABase->OpenKey( 
        METADATA_MASTER_ROOT_HANDLE,
        a_pstrKey,
        METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
        METABASE_TIMEOUT,    // 5 seconds
        &t_hKey 
        );

    THROW_ON_ERROR(t_hr);

    TRACE2(L"Open Key on %s, returned handle %x\n", a_pstrKey, t_hKey);
    return t_hKey;
}

// Check if the key is existed
bool CMetabase::CheckKey(LPCWSTR a_pstrKey)
{
    METADATA_HANDLE t_hKey = NULL;

    HRESULT t_hr = m_pIABase->OpenKey( 
        METADATA_MASTER_ROOT_HANDLE,
        a_pstrKey,
        METADATA_PERMISSION_READ,
        METABASE_TIMEOUT,       // 5 seconds
        &t_hKey 
        );
    
    if(t_hr == ERROR_SUCCESS)  
    {
        TRACE2(L"Open Key on %s, returned handle %x\n", a_pstrKey, t_hKey);
        CloseKey(t_hKey);
    }

    return (t_hr == ERROR_PATH_BUSY) | (t_hr == ERROR_SUCCESS) ? true : false;
}


HRESULT CMetabase::DeleteKey(
    METADATA_HANDLE  a_hKey,
    LPCWSTR          a_szKeyPath)
{
    return m_pIABase->DeleteKey( 
        a_hKey,
        a_szKeyPath
        );
}

//
// GetDword 
//
// A long or bool is returned in the VARIANT.  The value is a bool if the
// METABASE_PROPERTY has a mask otherwise the DWORD is returned as a long.
// The METADATA_HANDLE is expected to be valid and open.
//
void CMetabase::GetDword(
    METADATA_HANDLE     a_hKey,
    METABASE_PROPERTY*  a_pmbp,
    _variant_t&         a_vt
    )
{
    DWORD    t_dw;
    DWORD    t_dwRet;
    HRESULT  t_hr;

    if(a_hKey == NULL || a_pmbp == NULL)
        throw WBEM_E_INVALID_PARAMETER;

    METADATA_RECORD t_mr = {
        a_pmbp->dwMDIdentifier, 
        a_pmbp->dwMDAttributes,
        a_pmbp->dwMDUserType,
        a_pmbp->dwMDDataType,
        sizeof(DWORD),
        (unsigned char*)&t_dw,
        0
        };
    
    t_hr = m_pIABase->GetData(a_hKey, NULL, &t_mr, &t_dwRet);

    if (t_hr == MD_ERROR_DATA_NOT_FOUND)
        a_vt.vt   = VT_NULL;
    else
    {
        THROW_E_ON_ERROR(t_hr,a_pmbp);
        if (a_pmbp->dwMDMask) 
        {
            a_vt.vt      = VT_BOOL;
            a_vt.boolVal = (t_dw & a_pmbp->dwMDMask? -1 : 0);
        }
        else 
        {
            a_vt.vt   = VT_I4;
            a_vt.lVal = t_dw;
        }
    }
}


//
// GetStringFromMetabase 
//
void CMetabase::GetString(
    METADATA_HANDLE     a_hKey,
    METABASE_PROPERTY*  a_pmbp,
    _variant_t&         a_vt
    )
{
    DWORD    t_dwRet;
    HRESULT  t_hr;
    WCHAR    t_buffer[MAX_BUF_SIZE];

    if(a_hKey == NULL || a_pmbp == NULL)
        throw WBEM_E_INVALID_PARAMETER;

    METADATA_RECORD t_mr = {
        a_pmbp->dwMDIdentifier, 
        a_pmbp->dwMDAttributes,
        a_pmbp->dwMDUserType,
        a_pmbp->dwMDDataType,
        MAX_BUF_SIZE*sizeof(WCHAR),
        (unsigned char*)t_buffer,
        0
        };
    
    t_hr = m_pIABase->GetData(a_hKey, NULL, &t_mr, &t_dwRet);
    
    if (t_hr == MD_ERROR_DATA_NOT_FOUND) 
    {
        a_vt.vt = VT_NULL;
        return;
    }

    THROW_E_ON_ERROR(t_hr, a_pmbp);

    a_vt = t_buffer;
}

//
// GetMultiSz 
//
//
void CMetabase::GetMultiSz(
    METADATA_HANDLE     a_hKey,
    METABASE_PROPERTY*  a_pmbp,
    _variant_t&         a_vt
    )
{
    DWORD    t_dwRet;
    HRESULT  t_hr;
    WCHAR    *t_buffer = NULL;

    try 
    {
        if(a_hKey == NULL || a_pmbp == NULL)
            throw WBEM_E_INVALID_PARAMETER;
    
        if ((t_buffer = (WCHAR*)new WCHAR[10*MAX_BUF_SIZE])==NULL)
            throw WBEM_E_OUT_OF_MEMORY;


        METADATA_RECORD t_mr = {
            a_pmbp->dwMDIdentifier, 
            a_pmbp->dwMDAttributes,
            a_pmbp->dwMDUserType,
            a_pmbp->dwMDDataType,
            10*MAX_BUF_SIZE*sizeof(WCHAR),
            (unsigned char*)t_buffer,
            0
            };

        t_hr = m_pIABase->GetData(a_hKey, NULL, &t_mr, &t_dwRet);
        if (t_hr == ERROR_INSUFFICIENT_BUFFER) 
        {
            delete [] t_buffer;
            if ((t_buffer = (WCHAR*)new WCHAR[t_dwRet/sizeof(WCHAR) +1])==NULL)
                throw WBEM_E_OUT_OF_MEMORY;
            t_mr.pbMDData = (unsigned char*)t_buffer;
        
            t_hr = m_pIABase->GetData(a_hKey, NULL, &t_mr, &t_dwRet);
        }
        if (t_hr == MD_ERROR_DATA_NOT_FOUND) {
            a_vt.vt = VT_NULL;
            delete [] t_buffer;
            return;
        }
        THROW_E_ON_ERROR(t_hr,a_pmbp);

        LoadSafeArrayFromMultiSz(t_buffer,a_vt);
        delete [] t_buffer;
    }
    catch (...)
    {
        if (t_buffer)
            delete [] t_buffer;

        throw;
    }
    
}


//
// PutDword 
//
void CMetabase::PutDword(
    METADATA_HANDLE     a_hKey,
    METABASE_PROPERTY*  a_pmbp,
    _variant_t&         a_vt,
    _variant_t*         a_vtOld,
    bool                a_boolOverrideParent // optional
    )
{
    DWORD    t_dw=0;
    DWORD    t_dwOld=0;
    DWORD    t_dwRet=0;
    HRESULT  t_hr=0;

    if(a_hKey == NULL || a_pmbp == NULL)
        throw WBEM_E_INVALID_PARAMETER;

    if((a_vtOld) && 
       (a_vtOld->vt != VT_BOOL) && 
       (a_vtOld->vt != VT_I4) && 
       (a_vtOld->vt != VT_NULL) && (a_vtOld->vt != VT_EMPTY))
        throw WBEM_E_INVALID_PARAMETER;

    if( a_pmbp->fReadOnly )
        return;

    METADATA_RECORD t_mr;
    t_mr.dwMDIdentifier = a_pmbp->dwMDIdentifier;
    t_mr.dwMDAttributes = a_pmbp->dwMDAttributes;
    t_mr.dwMDUserType   = a_pmbp->dwMDUserType;
    t_mr.dwMDDataType   = a_pmbp->dwMDDataType;
    t_mr.dwMDDataLen    = sizeof(DWORD_METADATA);
    t_mr.pbMDData       = (unsigned char*)&t_dwOld;
    t_mr.dwMDDataTag    = 0;

    // if it's the bit of a flag
    if (a_vt.vt == VT_BOOL && a_pmbp->dwMDMask != 0)
    {
        // Read the entire flag from in the metabase so we can set the bit
        t_hr = m_pIABase->GetData(a_hKey, NULL, &t_mr, &t_dwRet);

        if (t_hr == ERROR_SUCCESS) 
        {
            if (a_vt.boolVal)
                t_dw = t_dwOld | a_pmbp->dwMDMask;
            else
                t_dw = t_dwOld & ~a_pmbp->dwMDMask;
        }
        else if (t_hr == MD_ERROR_DATA_NOT_FOUND) 
        {
            t_dw = (a_vt.boolVal ? a_pmbp->dwMDMask : 0);
            t_hr = 0;
        }
        else
            THROW_ON_ERROR(t_hr);

        if(t_dw == -1)
            t_dw = 1;  // true
    }
    else if (a_vt.vt  == VT_I4)
    {
        t_dw = a_vt.lVal;
    }
    else if (a_vt.vt == VT_BOOL)
    {
        t_dw = a_vt.bVal;
    }
    else 
        throw WBEM_E_INVALID_OBJECT;
   
    // Decide whether to write to metabase
    if ((a_boolOverrideParent) || 
        (a_vtOld == NULL) ||
        (*a_vtOld != a_vt))
    {
        t_mr.pbMDData = (unsigned char*)&t_dw;
        t_hr = m_pIABase->SetData(a_hKey, NULL, &t_mr);
    }

    THROW_E_ON_ERROR(t_hr,a_pmbp);
}


//
// PutString 
//

void CMetabase::PutString(
    METADATA_HANDLE     a_hKey,
    METABASE_PROPERTY*  a_pmbp,
    _variant_t&         a_vt,
    _variant_t*         a_vtOld,
    bool                a_boolOverrideParent // optional
    )
{
    HRESULT  t_hr=0;

    if(a_hKey == NULL || a_pmbp == NULL || a_vt.vt != VT_BSTR)
        throw WBEM_E_INVALID_PARAMETER;

    if((a_vtOld) && 
       (a_vtOld->vt != VT_BSTR) && 
       (a_vtOld->vt != VT_NULL) && (a_vtOld->vt != VT_EMPTY))
        throw WBEM_E_INVALID_PARAMETER;

    if( a_pmbp->fReadOnly )
        return;

    METADATA_RECORD t_mr;
    t_mr.dwMDIdentifier = a_pmbp->dwMDIdentifier;
    t_mr.dwMDAttributes = a_pmbp->dwMDAttributes;
    t_mr.dwMDUserType   = a_pmbp->dwMDUserType;
    t_mr.dwMDDataType   = a_pmbp->dwMDDataType;
    t_mr.dwMDDataTag    = 0;

    // Set the value, only if old and new values differ.
    if ((a_boolOverrideParent) || 
        (a_vtOld == NULL) ||
        (a_vtOld->vt == VT_NULL) || (a_vtOld->vt == VT_EMPTY) ||
        (_wcsicmp(a_vtOld->bstrVal, a_vt.bstrVal) != NULL))
    {
        t_mr.dwMDDataLen = (wcslen(a_vt.bstrVal)+1)*sizeof(WCHAR);
        t_mr.pbMDData = (unsigned char*)a_vt.bstrVal;

        t_hr = m_pIABase->SetData(a_hKey, NULL, &t_mr);
    }

    THROW_E_ON_ERROR(t_hr,a_pmbp);
}


//
// PutMultiSz 
//
//
void CMetabase::PutMultiSz(
    METADATA_HANDLE     a_hKey,
    METABASE_PROPERTY*  a_pmbp,
    _variant_t&         a_vt,
    _variant_t*         a_vtOld,
    bool                a_boolOverrideParent // optional
    )
{
    DWORD    t_dwRet;
    DWORD    t_dwRetOld;
    WCHAR    *t_buffer = NULL;
    WCHAR    *t_bufferOld = NULL;
    HRESULT  t_hr=0;
    bool     t_boolChange=false;

    if(a_hKey == NULL || a_pmbp == NULL || a_vt.vt != (VT_ARRAY | VT_BSTR))
        throw WBEM_E_INVALID_PARAMETER;

    if((a_vtOld) && 
       (a_vtOld->vt != (VT_ARRAY | VT_BSTR)) &&
       (a_vtOld->vt != VT_NULL) && (a_vtOld->vt != VT_EMPTY))
        throw WBEM_E_INVALID_PARAMETER;

    if( a_pmbp->fReadOnly )
        return;

    METADATA_RECORD t_mr;
    t_mr.dwMDIdentifier = a_pmbp->dwMDIdentifier;
    t_mr.dwMDAttributes = a_pmbp->dwMDAttributes;
    t_mr.dwMDUserType   = a_pmbp->dwMDUserType;
    t_mr.dwMDDataType   = a_pmbp->dwMDDataType;
    t_mr.dwMDDataTag    = 0;

    try
    {
        // If we didn't get an old value
        // or if the flag is set, write to MB
        if(a_vtOld == NULL || a_vtOld->vt == VT_NULL || a_vtOld->vt == VT_EMPTY ||
           (a_boolOverrideParent))
        {
            t_boolChange = true;
            CreateMultiSzFromSafeArray(a_vt, &t_buffer, &t_dwRet);
        }
        // If we did get an old value, see if there's been a change
        else {
            CreateMultiSzFromSafeArray(*a_vtOld, &t_bufferOld, &t_dwRetOld);
            CreateMultiSzFromSafeArray(a_vt, &t_buffer, &t_dwRet);
            if(!CompareMultiSz(t_bufferOld, t_buffer)) {
                // they're different
                t_boolChange = true;
            }
            delete [] t_bufferOld;
            t_bufferOld = NULL;
        }

        if (t_boolChange)
        {
            t_mr.pbMDData = (unsigned char*)t_buffer;
            t_mr.dwMDDataLen = t_dwRet*sizeof(WCHAR);
        
            t_hr = m_pIABase->SetData(a_hKey, NULL, &t_mr);
        }
        delete [] t_buffer;
        t_buffer = NULL;
        THROW_E_ON_ERROR(t_hr,a_pmbp);
    }
    catch (...)
    {
        if(t_buffer)
            delete [] t_buffer;
        if(t_bufferOld)
            delete [] t_bufferOld;
        throw;
    }   
}


//
// DeleteData 
//
void CMetabase::DeleteData(
    METADATA_HANDLE     a_hKey,
    METABASE_PROPERTY*  a_pmbp)
{
    HRESULT t_hr;

    if(a_hKey == NULL || a_pmbp == NULL)
        throw WBEM_E_INVALID_PARAMETER;

    if(a_pmbp->fReadOnly)
        return;

    t_hr = m_pIABase->DeleteData(
        a_hKey, 
        NULL, 
        a_pmbp->dwMDIdentifier, 
        a_pmbp->dwMDDataType
        );

    if (t_hr == MD_ERROR_DATA_NOT_FOUND ||t_hr == ERROR_SUCCESS)
        return;

    THROW_E_ON_ERROR(t_hr,a_pmbp);
}

//
// DeleteData
//
void CMetabase::DeleteData(
    METADATA_HANDLE     i_hKey,
    DWORD               i_dwMDIdentifier,
    DWORD               i_dwMDDataType)
{
    HRESULT t_hr;

    if(i_hKey == NULL)
        throw WBEM_E_INVALID_PARAMETER;

    t_hr = m_pIABase->DeleteData(
        i_hKey, 
        NULL, 
        i_dwMDIdentifier, 
        i_dwMDDataType
        );

    if (t_hr == MD_ERROR_DATA_NOT_FOUND ||t_hr == ERROR_SUCCESS)
        return;

    THROW_ON_ERROR(t_hr);
}

HRESULT CMetabase::EnumKeys(
    METADATA_HANDLE a_hKey,
    LPCWSTR         a_pszMDPath,         //path to the key
    LPWSTR          a_pszMDName,         //receives the name of the subkey --must be METADATA_MAX_NAME_LEN
    DWORD*          a_pdwMDEnumKeyIndex, //index of the subkey
    enum_KEY_TYPE&  a_eKeyType
    )
{
    HRESULT  t_hr;
    DWORD    t_dwRet;
    WCHAR    t_buffer[MAX_BUF_SIZE];

    if(a_hKey == NULL)
        throw WBEM_E_INVALID_PARAMETER;

    while ( ERROR_SUCCESS == (
                t_hr = m_pIABase->EnumKeys(
                    a_hKey, 
                    a_pszMDPath, 
                    a_pszMDName, 
                    *a_pdwMDEnumKeyIndex
                    )
                )
          )
    {
        t_buffer[0] = L'\0';

        METADATA_RECORD t_mr = {
            MD_KEY_TYPE, 
            METADATA_NO_ATTRIBUTES,
            IIS_MD_UT_SERVER,
            STRING_METADATA,
            MAX_BUF_SIZE*sizeof(WCHAR),
            (unsigned char*)t_buffer,
            0    
            };

        _bstr_t t_bstrPath = L"";
        if(a_pszMDPath)
        {
            t_bstrPath += a_pszMDPath;
            t_bstrPath += L"/";
        }
        t_bstrPath += a_pszMDName;

        t_hr = m_pIABase->GetData(
            a_hKey, 
            t_bstrPath,
            &t_mr, 
            &t_dwRet);

        // found and return
        if (t_hr == ERROR_SUCCESS && CheckKeyType(a_eKeyType,t_buffer))
        {
            break;
        }

        (*a_pdwMDEnumKeyIndex) = (*a_pdwMDEnumKeyIndex)+1;
    }

    return t_hr;
}

void CMetabase::PutMethod(
    METADATA_HANDLE a_hKey,
    DWORD           a_id
    )
{
    HRESULT  t_hr;

    if(a_hKey == NULL )
        throw WBEM_E_INVALID_PARAMETER;

    METADATA_RECORD t_mr = {
        MD_SERVER_COMMAND, 
        METADATA_NO_ATTRIBUTES,
        IIS_MD_UT_SERVER,
        DWORD_METADATA,
        sizeof(DWORD),
        (unsigned char*)&a_id,
        0
        };
    
    t_hr = m_pIABase->SetData(a_hKey, NULL, &t_mr);
    THROW_ON_ERROR(t_hr);
}

long CMetabase::GetWin32Error(
    METADATA_HANDLE a_hKey
    )
{
    if(a_hKey == NULL )
        throw WBEM_E_INVALID_PARAMETER;

    long lWin32Error = 0;
    DWORD dwLen;
    METADATA_RECORD t_mr = {
        MD_WIN32_ERROR, 
        METADATA_NO_ATTRIBUTES,
        IIS_MD_UT_SERVER,
        DWORD_METADATA,
        sizeof(DWORD),
        (unsigned char*)&lWin32Error,
        0
        };   
    
    HRESULT t_hr = m_pIABase->GetData(a_hKey, NULL, &t_mr, &dwLen);  
    
    if (t_hr != MD_ERROR_DATA_NOT_FOUND)
    {
        THROW_ON_ERROR(t_hr);
    }

    return lWin32Error;
}


//
// LoadSafeArrayFromMultiSz 
//
void CMetabase::LoadSafeArrayFromMultiSz(
    WCHAR*       a_pmsz,
    _variant_t&  a_vt
    )
{
    WCHAR*            t_pmsz;
    HRESULT           t_hr = ERROR_SUCCESS;
    DWORD             t_c;
    SAFEARRAYBOUND    t_aDim;
    SAFEARRAY*        t_psa = NULL;
    long              t_i = 0;

    try
    {
        if(a_pmsz == NULL)
            throw WBEM_E_INVALID_PARAMETER;
    
        // figure the dimensions of the multisz
        for (t_c=1,t_pmsz=a_pmsz; *t_pmsz||*(t_pmsz+1); t_pmsz++)
            if(!*t_pmsz) t_c++;

        t_aDim.lLbound    = 0;
        t_aDim.cElements= t_c;

        t_psa = SafeArrayCreate(VT_BSTR, 1, &t_aDim);
        if (!t_psa)
            throw WBEM_E_FAILED;
    
        for (t_pmsz=a_pmsz; ; t_i++) 
        {
            _bstr_t t_bstr = t_pmsz;
            t_hr = SafeArrayPutElement(t_psa,&t_i,BSTR(t_bstr));
            THROW_ON_ERROR(t_hr);    
        
            for ( ; *t_pmsz; t_pmsz++);
            t_pmsz++;
            if (!*t_pmsz) 
                break;
        }
        a_vt.vt = VT_ARRAY | VT_BSTR;
        a_vt.parray = t_psa;
    }
    catch (...) 
    {
        if (t_psa) 
            SafeArrayDestroy(t_psa);
        throw;
    }
}


//
// CreateMultiSzFromSafeArray
//
void CMetabase::CreateMultiSzFromSafeArray(
    _variant_t&  a_vt,
    WCHAR**      a_ppsz,
    DWORD*       a_pdw
    )
{
    WCHAR*          t_psz = NULL;
    long            t_iLo,t_iUp,t_c;
    SAFEARRAY*      t_psa = NULL;
    long            t_i = 0;
    BSTR            t_pstr = NULL;

    if((t_psa = a_vt.parray) == NULL)
        throw WBEM_E_INVALID_PARAMETER;

    THROW_ON_ERROR(SafeArrayGetLBound(t_psa,1,&t_iLo));
    THROW_ON_ERROR(SafeArrayGetUBound(t_psa,1,&t_iUp));

    try 
    {
        CUtils obj;
        for (*a_pdw=0, t_c = t_iLo; t_c <= t_iUp; t_c++)
        {
            THROW_ON_ERROR(SafeArrayGetElement(t_psa,&t_c,&t_pstr));
            *a_pdw = *a_pdw + wcslen(t_pstr) + 1;
            obj.MzCat(&t_psz,t_pstr);
            SysFreeString(t_pstr);
            t_pstr = NULL;
        }
        *a_pdw +=1;
        *a_ppsz = t_psz;
    }
    catch (...) 
    {
        if(t_psz)
            delete t_psz;
        if (t_pstr)
            SysFreeString(t_pstr);
        throw;
    }
}



bool CMetabase::CompareMultiSz(
    WCHAR*       a_pmsz1,
    WCHAR*       a_pmsz2
    )
{
    if(a_pmsz1 == NULL && a_pmsz2 == NULL)
        return true;
    else if(a_pmsz1 == NULL || a_pmsz2 == NULL)
        return false;

    // compare the two multisz buffers.
    for ( ; (*a_pmsz1 && *a_pmsz2); )
    {
        if (_wcsicmp(a_pmsz1, a_pmsz2) != NULL)
            return false;
        a_pmsz1 += wcslen(a_pmsz1) + 1;
        a_pmsz2 += wcslen(a_pmsz2) + 1;
    }

    if (!*a_pmsz1 && !*a_pmsz2)
    {
        return true;
    }

    return false;
}


// DESC: You are enumming all a_eKeyTypes by going through the entire tree
//       and are currently at an a_pszTemp.  You want to see if you should
//       continue recursing down this branch or not.
// FIX:  This information can be obtained from the associations in the schema.
//       But, it may not be trivial to implement.
bool CMetabase::CheckKeyType(
    enum_KEY_TYPE&  a_eKeyType, 
    LPCWSTR         a_pszTemp
    )
{
    bool bRet = false;
    enum_KEY_TYPE  eType = NO_TYPE;

    if(a_eKeyType == NO_TYPE)
        return false;

    CUtils obj;
    if( !obj.TypeStringToEnum(eType, a_pszTemp) )
        return false;

    if(eType == a_eKeyType)
        return true;

    switch(a_eKeyType)
    {
    case IIsLogModule:
        if( eType == IIsLogModules )
            bRet = true;
        break;

    case IIsFtpInfo:
        if( eType == IIsFtpService )
            bRet = true;
        break;

    case IIsFtpServer:
         if( eType == IIsFtpService )
            bRet = true;
        break;

    case IIsFtpVirtualDir:
        if( eType == IIsFtpService ||
            eType == IIsFtpServer ||
            eType == IIsFtpVirtualDir
            )
            bRet = true;
        break;

    case IIsWebInfo:
        if( eType == IIsWebService )
            bRet = true;
        break;

    case IIsFilters:
        if( eType == IIsWebService ||
            eType == IIsWebServer
            )
            bRet = true;
        break;

    case IIsFilter:
        if( eType == IIsWebService ||
            eType == IIsWebServer ||
            eType == IIsFilters
            )
            bRet = true;
        break;

    case IIsCompressionSchemes:
        if( eType == IIsWebService ||
            eType == IIsWebServer ||
            eType == IIsFilters )
            bRet = true;
        break;

    case IIsCompressionScheme:
        if( eType == IIsWebService ||
            eType == IIsWebServer ||
            eType == IIsFilters ||
            eType == IIsCompressionSchemes)
            bRet = true;
        break;

    case IIsWebServer:
        if( eType == IIsWebService )
            bRet = true;
        break;

    case IIsCertMapper:
        if( eType == IIsWebService ||
            eType == IIsWebServer 
            )
            bRet = true;
        break;

    case IIsWebVirtualDir:
        if( eType == IIsWebService ||
            eType == IIsWebServer ||
            eType == IIsWebVirtualDir ||
            eType == IIsWebDirectory
            )
            bRet = true;
        break;

    case IIsWebDirectory:
        if( eType == IIsWebService ||
            eType == IIsWebServer ||
            eType == IIsWebVirtualDir ||
            eType == IIsWebDirectory
            )
            bRet = true;
        break;

    case IIsWebFile:
        if( eType == IIsWebService ||
            eType == IIsWebServer ||
            eType == IIsWebVirtualDir ||
            eType == IIsWebDirectory
            )
            bRet = true;
        break;

    case TYPE_AdminACL:
    case TYPE_AdminACE:
        if( eType == IIsWebService ||
            eType == IIsWebServer ||
            eType == IIsWebVirtualDir ||
            eType == IIsWebDirectory ||
            eType == IIsWebFile ||
            eType == IIsFtpService ||
            eType == IIsFtpServer ||
            eType == IIsFtpVirtualDir
            )
            bRet = true;
        break;

    case TYPE_IPSecurity:
        if( eType == IIsWebService ||
            eType == IIsWebServer ||
            eType == IIsWebVirtualDir ||
            eType == IIsWebDirectory ||
            eType == IIsWebFile ||
            eType == IIsFtpService ||
            eType == IIsFtpServer ||
            eType == IIsFtpVirtualDir
            )
            bRet = true;
        break;

    default:
        break;
    }

    if(bRet)
        a_eKeyType = eType;

    return bRet;
}

HRESULT CMetabase::WebAppCheck(
    METADATA_HANDLE a_hKey
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize;
    METADATA_RECORD mdrMDData;
    WCHAR DataBuf[MAX_PATH];
    DWORD dwState;

    dwBufferSize = MAX_PATH;
    MD_SET_DATA_RECORD(
        &mdrMDData,
        MD_APP_ROOT,
        METADATA_INHERIT|METADATA_ISINHERITED,
        IIS_MD_UT_FILE,
        STRING_METADATA,
        dwBufferSize,
        &DataBuf
        );

    hr = m_pIABase->GetData(
        a_hKey,
        NULL,
        &mdrMDData,
        &dwBufferSize
        );
    THROW_ON_ERROR(hr);

    if (mdrMDData.dwMDAttributes & METADATA_ISINHERITED)
    {
        hr = MD_ERROR_DATA_NOT_FOUND;
        THROW_ON_ERROR(hr);
    }

    dwBufferSize = sizeof(DWORD);
    MD_SET_DATA_RECORD(
        &mdrMDData,
        MD_APP_ISOLATED,
        METADATA_INHERIT|METADATA_ISINHERITED,
        IIS_MD_UT_WAM,
        DWORD_METADATA,
        dwBufferSize,
        &dwState
        );

    hr = m_pIABase->GetData(
        a_hKey,
        NULL,
        &mdrMDData,
        &dwBufferSize
        );
    THROW_ON_ERROR(hr);

    if (mdrMDData.dwMDAttributes & METADATA_ISINHERITED)
    {
        hr = MD_ERROR_DATA_NOT_FOUND;
        THROW_ON_ERROR(hr);
    }

    return hr;
}

HRESULT CMetabase::WebAppGetStatus(
    METADATA_HANDLE a_hKey,
    PDWORD pdwState)
{
    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;

    MD_SET_DATA_RECORD(
        &mdrMDData,
        MD_ASP_ENABLEAPPLICATIONRESTART, 
        METADATA_INHERIT,
        ASP_MD_UT_APP,
        DWORD_METADATA,
        dwBufferSize,
        pdwState
        );

    hr = m_pIABase->GetData(
        a_hKey,
        NULL,
        &mdrMDData,
        &dwBufferSize
        );

    return hr;
}



HRESULT CMetabase::WebAppSetStatus(
    METADATA_HANDLE a_hKey,
    DWORD dwState
    )
{
    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;

    MD_SET_DATA_RECORD(
        &mdrMDData,
        MD_ASP_ENABLEAPPLICATIONRESTART,
        METADATA_INHERIT,
        ASP_MD_UT_APP,
        DWORD_METADATA,
        dwBufferSize,
        &dwState
        );

    hr = m_pIABase->SetData(
        a_hKey,
        NULL,
        &mdrMDData
        );

    return hr;
}



//
// CWebAppMethod
//

CWebAppMethod::CWebAppMethod()
{ 
    HRESULT hr = CoCreateInstance(
        CLSID_WamAdmin,
        NULL,
        CLSCTX_ALL,
        IID_IWamAdmin2,
        (void**)&m_pWamAdmin
        );

    THROW_ON_ERROR(hr);
}

CWebAppMethod::~CWebAppMethod()
{
    if(m_pWamAdmin)
        m_pWamAdmin->Release();
}


HRESULT CWebAppMethod::AppCreate( 
    LPCWSTR szMetaBasePath, 
    bool bInProcFlag
    )
{
    HRESULT hr;
    hr = m_pWamAdmin->AppCreate(
        szMetaBasePath, 
        bInProcFlag);

    return hr;
}

HRESULT CWebAppMethod::AppCreate2( 
    LPCWSTR szMetaBasePath, 
    long lAppMode
    )
{
    HRESULT hr;
    hr = m_pWamAdmin->AppCreate2(
        szMetaBasePath, 
        lAppMode);

    return hr;
}

HRESULT CWebAppMethod::AppDelete( 
    LPCWSTR szMetaBasePath, 
    bool bRecursive
    )
{
    HRESULT hr;
    hr = m_pWamAdmin->AppDelete(
        szMetaBasePath, 
        bRecursive);

    return hr;
}

HRESULT CWebAppMethod::AppUnLoad( 
    LPCWSTR szMetaBasePath, 
    bool bRecursive
    )
{
    HRESULT hr;
    hr = m_pWamAdmin->AppUnLoad(
        szMetaBasePath, 
        bRecursive);

    return hr;
}

HRESULT CWebAppMethod::AppDisable( 
    LPCWSTR szMetaBasePath, 
    bool bRecursive
    )
{
    HRESULT hr;
    hr = m_pWamAdmin->AppDeleteRecoverable(
        szMetaBasePath, 
        bRecursive);

    return hr;
}

HRESULT CWebAppMethod::AppEnable( 
    LPCWSTR szMetaBasePath, 
    bool bRecursive
    )
{
    HRESULT hr;
    hr = m_pWamAdmin->AppRecover(
        szMetaBasePath, 
        bRecursive);

    return hr;
}

HRESULT CWebAppMethod::AppGetStatus( 
    LPCWSTR szMetaBasePath, 
    DWORD* pdwStatus
    )
{
    HRESULT hr;
    hr = m_pWamAdmin->AppGetStatus(
        szMetaBasePath, 
        pdwStatus);

    return hr;
}

HRESULT CWebAppMethod::AspAppRestart(
    LPCWSTR a_szMetaBasePath
    )
{
    HRESULT hr = S_OK;
    DWORD dwState;
    METADATA_HANDLE t_hKey = NULL;
    CMetabase t_mb;
 
    try
    {
        // open key
        t_hKey = t_mb.OpenKey(a_szMetaBasePath, true);

        // check app
        hr = t_mb.WebAppCheck(t_hKey);
        THROW_ON_ERROR(hr);

        // get state
        hr = t_mb.WebAppGetStatus(t_hKey, &dwState);
        THROW_ON_ERROR(hr);

        // change state value
        dwState = dwState ? 0 : 1;
        hr = t_mb.WebAppSetStatus(t_hKey, dwState);
        THROW_ON_ERROR(hr);

        // re-set back state value
        dwState = dwState ? 0 : 1;
        hr = t_mb.WebAppSetStatus(t_hKey, dwState);
        THROW_ON_ERROR(hr);

        t_mb.CloseKey(t_hKey);
    }
    catch (...) 
    {
        t_mb.CloseKey(t_hKey);
        throw;
    };    

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\maindll.cpp ===
//***************************************************************************
//
//  MAINDLL.CPP
// 
//  Module: IIS WMI Instance provider 
//
//  Purpose: Contains DLL entry points.  Also has code that controls
//           when the DLL can be unloaded by tracking the number of
//           objects and locks as well as routines that support
//           self registration.
//
//  Copyright (c)1999 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include <objbase.h>
#include <initguid.h>
#include <olectl.h>
#include "iisprov.h"

static HMODULE s_hModule;


//Count number of objects and number of locks.
long        g_cObj=0;
long        g_cLock=0;

// GuidGen generated GUID for the IIS WMI Provider.
DEFINE_GUID(CLSID_IISWbemProvider, 0x1339f295, 0x5c3f, 0x45ab, 0xa1, 0x17, 0xc9, 0x1b, 0x0, 0x24, 0x8, 0xd5);
// the GUID in somewhat more legibal terms: {1339F295-5C3F-45ab-A117-C91B002408D5}


//***************************************************************************
//
// DllMain
//
// Purpose: Entry point for DLL.
//
// Return: TRUE if OK.
//
//***************************************************************************


BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD ulReason, LPVOID pvReserved)
{
    switch( ulReason )
    {
    case DLL_PROCESS_ATTACH:
        s_hModule = hInstance;
        break;
        
    case DLL_PROCESS_DETACH:
        break;     
    }
    
    return TRUE;
}

//***************************************************************************
//
//  DllGetClassObject
//
//  Purpose: Called by Ole when some client wants a class factory.  Return 
//           one only if it is the sort of class this DLL supports.
//
//***************************************************************************


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, PPVOID ppv)
{
    HRESULT hr;
    CProvFactory *pObj;

    if (CLSID_IISWbemProvider != rclsid)
        return E_FAIL;


    pObj=new CProvFactory();

    if (NULL==pObj)
        return E_OUTOFMEMORY;

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
// DllCanUnloadNow
//
// Purpose: Called periodically by Ole in order to determine if the
//          DLL can be freed.
//
// Return:  S_OK if there are no objects in use and the class factory 
//          isn't locked.
//
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
    sc = (0L>=g_cObj && 0L>=g_cLock) ? S_OK : S_FALSE;

    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{   
    WCHAR   szID[MAX_PATH+1];
    WCHAR   wcID[MAX_PATH+1];
    WCHAR   szCLSID[MAX_PATH+1];
    WCHAR   szModule[MAX_PATH+1];
    WCHAR * pName = L"Microsoft Internet Information Server Provider";
    WCHAR * pModel = L"Both";
    HKEY hKey1, hKey2;

    // Create the path.
    StringFromGUID2(CLSID_IISWbemProvider, wcID, MAX_PATH);
    lstrcpyW(szID, wcID);
    lstrcpyW(szCLSID, L"Software\\classes\\CLSID\\");
    lstrcatW(szCLSID, szID);

    // Create entries under CLSID
    LONG lRet;
    lRet = RegCreateKeyExW(HKEY_LOCAL_MACHINE, 
                          szCLSID, 
                          0, 
                          NULL, 
                          0, 
                          KEY_ALL_ACCESS, 
                          NULL, 
                          &hKey1, 
                          NULL);
    if(lRet != ERROR_SUCCESS)
        return SELFREG_E_CLASS;

    RegSetValueExW(hKey1, 
                  NULL,
                  0, 
                  REG_SZ, 
                  (BYTE *)pName, 
                  lstrlenW(pName)*sizeof(WCHAR)+1);

    lRet = RegCreateKeyExW(hKey1,
                          L"InprocServer32", 
                          0, 
                          NULL, 
                          0, 
                          KEY_ALL_ACCESS, 
                          NULL, 
                          &hKey2, 
                          NULL);
        
    if(lRet != ERROR_SUCCESS)
    {
        RegCloseKey(hKey1);
        return SELFREG_E_CLASS;
    }

    GetModuleFileNameW(s_hModule, szModule,  MAX_PATH);
    RegSetValueExW(hKey2, 
                  NULL, 
                  0, 
                  REG_SZ, 
                  (BYTE*)szModule, 
                  lstrlenW(szModule) * sizeof(WCHAR) + 1);
    RegSetValueExW(hKey2, 
                  L"ThreadingModel", 
                  0, 
                  REG_SZ, 
                  (BYTE *)pModel, 
                  lstrlenW(pModel) * sizeof(WCHAR) + 1);

    RegCloseKey(hKey1);
    RegCloseKey(hKey2);
    
    return S_OK;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    WCHAR      szID[MAX_PATH+1];
    WCHAR      wcID[MAX_PATH+1];
    WCHAR      szCLSID[MAX_PATH+1];
    HKEY       hKey;

    // Create the path using the CLSID
    StringFromGUID2(CLSID_IISWbemProvider, wcID, 128);
    lstrcpyW(szID, wcID);
    lstrcpyW(szCLSID, L"Software\\classes\\CLSID\\");
    lstrcatW(szCLSID, szID);

    // First delete the InProcServer subkey.
    LONG lRet;
    lRet = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE, 
        szCLSID, 
        0,
        KEY_ALL_ACCESS,
        &hKey
        );

    if(lRet == ERROR_SUCCESS)
    {
        RegDeleteKeyW(hKey, L"InProcServer32");
        RegCloseKey(hKey);
    }

    lRet = RegOpenKeyExW(
        HKEY_LOCAL_MACHINE, 
        L"Software\\classes\\CLSID",
        0,
        KEY_ALL_ACCESS,
        &hKey
        );

    if(lRet == ERROR_SUCCESS)
    {
        RegDeleteKeyW(hKey,szID);
        RegCloseKey(hKey);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\ntrkcomm.h ===
#ifndef __ntrkcomm_h__
#define __ntrkcomm_h__

#if _MSC_VER > 1000
#pragma once
#endif 


typedef LPVOID * PPVOID;


class CWbemServices
{
protected:
    IWbemServices* m_pWbemServices;

public:
    CWbemServices(IWbemServices* );
    virtual ~CWbemServices();
    HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
    HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) ;
        
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) ;
        
    HRESULT STDMETHODCALLTYPE ExecMethod( 
        const BSTR, 
        const BSTR, 
        long, 
        IWbemContext*,
        IWbemClassObject*,
        IWbemClassObject**, 
        IWbemCallResult**) ;
};


class CImpersonatedProvider : public IWbemServices, public IWbemProviderInit 
{
protected:
    ULONG           m_cRef;         //Object reference count
    CWbemServices*  m_pNamespace;
 
public:
    CImpersonatedProvider(const BSTR =NULL, const BSTR =NULL , const BSTR =NULL, IWbemContext* =NULL);
    virtual ~CImpersonatedProvider();

    //Non-delegating object IUnknown

    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IWbemProviderInit

    HRESULT STDMETHODCALLTYPE Initialize(
         /* [in] */ LPWSTR pszUser,
         /* [in] */ LONG lFlags,
         /* [in] */ LPWSTR pszNamespace,
         /* [in] */ LPWSTR pszLocale,
         /* [in] */ IWbemServices *pNamespace,
         /* [in] */ IWbemContext *pCtx,
         /* [in] */ IWbemProviderInitSink *pInitSink
                    );

    //IWbemServices  

    HRESULT STDMETHODCALLTYPE OpenNamespace( 
        /* [in] */ const BSTR Namespace,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult)
        {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
        /* [in] */ IWbemObjectSink __RPC_FAR *pSink) 
        {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE QueryObjectSink( 
        /* [in] */ long lFlags,
        /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler) 
        {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE GetObject( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
        {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE GetObjectAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    HRESULT STDMETHODCALLTYPE PutClass( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
        {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutClassAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pObject,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
        {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteClass( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
        {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
        {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateClassEnum( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
        {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
        /* [in] */ const BSTR Superclass,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
        {return WBEM_E_NOT_SUPPORTED;};

    
    HRESULT STDMETHODCALLTYPE PutInstance( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
        {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *pInst,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE DeleteInstance( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
        {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
        {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
        /* [in] */ const BSTR Class,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);
    
    HRESULT STDMETHODCALLTYPE ExecQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
        {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) ;
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
        {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
        /* [in] */ const BSTR QueryLanguage,
        /* [in] */ const BSTR Query,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
        {return WBEM_E_NOT_SUPPORTED;};
    
    HRESULT STDMETHODCALLTYPE ExecMethod( 
        const BSTR, 
        const BSTR, 
        long, 
        IWbemContext*,
        IWbemClassObject*,
        IWbemClassObject**, 
        IWbemCallResult**) 
        {return WBEM_E_NOT_SUPPORTED;}

    virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync(
        const BSTR,
        const BSTR, 
        long, 
        IWbemContext*,
        IWbemClassObject*,
        IWbemObjectSink*);

protected:
    virtual HRESULT STDMETHODCALLTYPE DoCreateInstanceEnumAsync( 
        /* [in] */ const BSTR,    // Class,
        /* [in] */ long,    // lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,    //pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *    //pResponseHandler
        )=0;

    virtual HRESULT STDMETHODCALLTYPE DoDeleteInstanceAsync( 
        /* [in] */ const BSTR ,    //ObjectPath,
        /* [in] */ long,    // lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,    //pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *    //pResponseHandler
        ) =0;

    virtual HRESULT STDMETHODCALLTYPE DoExecMethodAsync(
        const BSTR,
        const BSTR, 
        long, 
        IWbemContext*,
        IWbemClassObject*,
        IWbemObjectSink*
        )=0;

    virtual HRESULT STDMETHODCALLTYPE DoExecQueryAsync( 
        /* [in] */ const BSTR, // QueryLanguage,
        /* [in] */ const BSTR, // Query,
        /* [in] */ long, // lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,   // pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR * //pResponseHandler
        ) =0;

    virtual HRESULT STDMETHODCALLTYPE DoGetObjectAsync(
        /* [in] */ const BSTR ObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
        )=0;

    virtual HRESULT STDMETHODCALLTYPE DoPutInstanceAsync( 
        /* [in] */ IWbemClassObject __RPC_FAR *,    //pInst,
        /* [in] */ long    ,    // lFlags,
        /* [in] */ IWbemContext __RPC_FAR *,    //pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *    //pResponseHandler
        ) =0;
};

class CWbemInstanceMgr
{    
protected:
    IWbemObjectSink* m_pSink;
    IWbemClassObject **m_ppInst;
    DWORD m_dwThreshHold;
    DWORD m_dwIndex;

public:
    CWbemInstanceMgr(
        IWbemObjectSink*,
        DWORD =50);
    virtual ~CWbemInstanceMgr();
    void Indicate(IWbemClassObject*);
    void SetStatus(
        LONG,
        HRESULT,
        const BSTR, 
        IWbemClassObject*);
};



#endif // end of provlib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\objpath.cpp ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

  OBJPATH.CPP

Abstract:

  Object path parser.

History:

--*/

#include <windows.h>
#include <stdio.h>
#include <oleauto.h>
#include <genlex.h>
#include <opathlex.h>
#include <objpath.h>

#define Macro_CloneLPWSTR(x) \
    (x ? wcscpy(new wchar_t[wcslen(x) + 1], x) : 0)


ParsedObjectPath::ParsedObjectPath()
{
    m_pServer = 0;                  // NULL if no server
    m_dwNumNamespaces = 0;          // 0 if no namespaces

    m_dwAllocNamespaces = 2;
    m_paNamespaces = new LPWSTR[m_dwAllocNamespaces];

    for (unsigned i = 0; i < m_dwAllocNamespaces; i++)
        m_paNamespaces[i] = 0;

    m_pClass = 0;                   // Class name
    m_dwNumKeys = 0;                // 0 if no keys (just a class name)
    m_bSingletonObj = FALSE;
    m_dwAllocKeys = 2;
    m_paKeys = new KeyRef *[m_dwAllocKeys];
}

ParsedObjectPath::~ParsedObjectPath()
{
    if(m_pServer) delete [] m_pServer;
    for (DWORD dwIx = 0; dwIx < m_dwNumNamespaces; dwIx++)
        if(m_paNamespaces[dwIx]) delete [] m_paNamespaces[dwIx];
    if(m_paNamespaces) delete [] m_paNamespaces;
    if(m_pClass) delete [] m_pClass;

    for (dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
        if(m_paKeys[dwIx]) delete m_paKeys[dwIx];
    if(m_paKeys) delete [] m_paKeys;
}

BOOL ParsedObjectPath::SetClassName(LPCWSTR wszClassName)
{
    if(m_pClass) delete [] m_pClass;
    if(wszClassName == NULL)
    {
        m_pClass = NULL;
    }
    else
    {
        m_pClass = Macro_CloneLPWSTR(wszClassName);
    }

    return TRUE;
}

BOOL ParsedObjectPath::IsClass()
{
    if(!IsObject())
        return FALSE;

    return (m_dwNumKeys == 0 && !m_bSingletonObj);
}

BOOL ParsedObjectPath::IsInstance()
{
    return IsObject() && !IsClass();
}

BOOL ParsedObjectPath::IsObject()
{
    if(m_pClass == NULL)
        return FALSE;

    if(m_pServer)
    {
        return (m_dwNumNamespaces > 0);
    }
    else
    {
        return (m_dwNumNamespaces == 0);
    }
}

BOOL ParsedObjectPath::AddNamespace(LPCWSTR wszNamespace)
{
    if(m_dwNumNamespaces == m_dwAllocNamespaces)
    {
        DWORD dwNewAllocNamespaces = m_dwAllocNamespaces * 2;
        LPWSTR* paNewNamespaces = new LPWSTR[dwNewAllocNamespaces];
        memcpy(paNewNamespaces, m_paNamespaces,
            sizeof(LPWSTR) * m_dwAllocNamespaces);
        delete [] m_paNamespaces;
        m_paNamespaces = paNewNamespaces;
        m_dwAllocNamespaces = dwNewAllocNamespaces;
    }
    m_paNamespaces[m_dwNumNamespaces++] = Macro_CloneLPWSTR(wszNamespace);

    return TRUE;
}

BOOL ParsedObjectPath::AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue )
{
    BOOL bStatus = TRUE ;
    BOOL bFound = FALSE ;
    BOOL bUnNamed = FALSE ;

    for ( ULONG dwIndex = 0 ; dwIndex < m_dwNumKeys ; dwIndex ++ )
    {
        if ( ( m_paKeys [ dwIndex ]->m_pName ) && wszKeyName )
        {
            if ( _wcsicmp ( m_paKeys [ dwIndex ]->m_pName , wszKeyName )
                                                                        == 0 )
            {
                bFound = TRUE ;
                break ;
            }
        }
        else
        {
            if ( ( ( m_paKeys [ dwIndex ]->m_pName ) == 0 ) )
            {
                bUnNamed = TRUE ;
                if ( ( wszKeyName == 0 ) )
                {
                    bFound = TRUE ;
                    break ;
                }
            }
        }
    }

    if ( ! wszKeyName )
    {
        /* Remove all existing keys */

        for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                                                            dwDeleteIndex ++ )
        {
            delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
            m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
            VariantClear ( &  ( m_paKeys [ dwDeleteIndex ]->m_vValue ) ) ;
        }

        VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ) , ( VARIANT * ) pvValue );

        m_dwNumKeys = 1 ;
    }
    else
    {
        if ( bFound )
        {
            /*
             *    If key already exists then just replace the value
             */

            if ( wszKeyName )
            {
                m_paKeys [ dwIndex ]->m_pName =
                    new wchar_t [ wcslen ( wszKeyName ) + 1 ] ;
                wcscpy ( m_paKeys [ dwIndex ]->m_pName , wszKeyName ) ;
            }

            VariantClear ( & ( m_paKeys [ dwIndex ]->m_vValue ) ) ;
            VariantCopy ( & ( m_paKeys [ dwIndex ]->m_vValue ) ,
                    ( VARIANT * ) pvValue ) ;
        }
        else
        {
            if ( bUnNamed )
            {
                /* Add an un named key */

                for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
                        dwDeleteIndex ++ )
                {
                    delete ( m_paKeys [ dwDeleteIndex ]->m_pName ) ;
                    m_paKeys [ dwDeleteIndex ]->m_pName = NULL ;
                    VariantClear (& ( m_paKeys [ dwDeleteIndex ]->m_vValue ) );
                }

                m_paKeys [ 0 ]->m_pName =
                    new wchar_t [ wcslen ( wszKeyName ) + 1 ] ;
                wcscpy ( m_paKeys [ 0 ]->m_pName , wszKeyName ) ;

                VariantCopy ( & ( m_paKeys [ 0 ]->m_vValue ) ,
                    ( VARIANT * ) pvValue ) ;

                m_dwNumKeys = 1 ;
            }
            else
            {
                /* Add a Named Key */

                AddKeyRef(wszKeyName, pvValue);
            }
        }
    }

    return bStatus;
}

void ParsedObjectPath::ClearKeys ()
{
    for ( ULONG dwDeleteIndex = 0 ; dwDeleteIndex < m_dwNumKeys ;
            dwDeleteIndex ++ )
    {
        if(m_paKeys [ dwDeleteIndex ]) delete m_paKeys [ dwDeleteIndex ] ;
        m_paKeys [ dwDeleteIndex ] = NULL ;
    }

    if(m_paKeys) delete [] m_paKeys ;
    m_paKeys = NULL ;

    m_dwNumKeys = 0;                // 0 if no keys (just a class name)
    m_dwAllocKeys = 2;
    m_paKeys = new KeyRef *[m_dwAllocKeys];
}

BOOL ParsedObjectPath::AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;
        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
        if(m_paKeys) delete [] m_paKeys;
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }

    m_paKeys[m_dwNumKeys] = new KeyRef(wszKeyName, pvValue);
    m_dwNumKeys++;
    return TRUE;
}

BOOL ParsedObjectPath::AddKeyRef(KeyRef* pAcquireRef)
{
    if(m_dwNumKeys == m_dwAllocKeys)
    {
        DWORD dwNewAllocKeys = m_dwAllocKeys * 2;
        KeyRef** paNewKeys = new KeyRef*[dwNewAllocKeys];
        memcpy(paNewKeys, m_paKeys, sizeof(KeyRef*) * m_dwAllocKeys);
        if(m_paKeys) delete [] m_paKeys;
        m_paKeys = paNewKeys;
        m_dwAllocKeys = dwNewAllocKeys;
    }

    m_paKeys[m_dwNumKeys] = pAcquireRef;
    m_dwNumKeys++;
    return TRUE;
}

KeyRef::KeyRef()
{
    m_pName = 0;
    VariantInit(&m_vValue);
}

KeyRef::KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue)
{
    m_pName = Macro_CloneLPWSTR(wszKeyName);
    VariantInit(&m_vValue);
    VariantCopy(&m_vValue, (VARIANT*)pvValue);
}

KeyRef::~KeyRef()
{
    if(m_pName) delete [] m_pName;
    VariantClear(&m_vValue);
}




int WINAPI CObjectPathParser::Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath)
{
    if(pInput->m_pClass == NULL)
    {
        return CObjectPathParser::InvalidParameter;
    }

    // Allocate enough space
    // =====================

    int nSpace = wcslen(pInput->m_pClass);
    nSpace += 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];
        if(pKey->m_pName)
            nSpace += wcslen(pKey->m_pName);
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(    V_VT(&pKey->m_vValue) == VT_I4
                ||    V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            nSpace += 30;
        }
        else if (    V_VT(&pKey->m_vValue) == VT_I2
                ||    V_VT(&pKey->m_vValue) == VT_UI2 )

        {
            nSpace += 15;
        }
        else if (    V_VT(&pKey->m_vValue) == VT_I1
                ||    V_VT(&pKey->m_vValue) == VT_UI1 )

        {
            nSpace += 8;
        }
    }
    if(pInput->m_bSingletonObj)
        nSpace +=2;

    WCHAR wszTemp[30];
    LPWSTR wszPath = new WCHAR[nSpace];
    wcscpy(wszPath, pInput->m_pClass);


    for (dwIx = 0; dwIx < pInput->m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = pInput->m_paKeys[dwIx];

        // We dont want to put a '.' if there isnt a key name,
        // for example, Myclass="value"
        if(dwIx == 0)
        {
            if((pKey->m_pName && (0 < wcslen(pKey->m_pName))) || pInput->m_dwNumKeys > 1)
                wcscat(wszPath, L".");
        }
        else
        {
            wcscat(wszPath, L",");
        }
        if(pKey->m_pName)
            wcscat(wszPath, pKey->m_pName);
        wcscat(wszPath, L"=");

        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            wcscat(wszPath, L"\"");
            WCHAR* pwc = V_BSTR(&pKey->m_vValue);
            WCHAR str[2];
            str[1] = 0;
            while(*pwc)
            {
                if(*pwc == '\\' || *pwc == '"')
                {
                    wcscat(wszPath, L"\\");
                }
                str[0] = *pwc;
                wcscat(wszPath, str);
                pwc++;
            }

            wcscat(wszPath, L"\"");
        }
        else if( V_VT(&pKey->m_vValue) == VT_I4 )
        {
            swprintf(wszTemp, L"%d", V_I4(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI4 )
        {
            swprintf(wszTemp, L"%u", V_UI4(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I2 )
        {
            swprintf(wszTemp, L"%hd", V_I2(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI2 )
        {
            swprintf(wszTemp, L"%hu", V_UI2(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_I1 )
        {
            swprintf(wszTemp, L"%d", V_I1(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
        else if( V_VT(&pKey->m_vValue) == VT_UI1 )
        {
            swprintf(wszTemp, L"%u", V_UI1(&pKey->m_vValue));
            wcscat(wszPath, wszTemp);
        }
    }

    // Take care of the singleton case.  This is a path of the form
    // MyClass=@  and represents a single instance of a class with no
    // keys.

    if(pInput->m_bSingletonObj && pInput->m_dwNumKeys == 0)
        wcscat(wszPath, L"=@");


    *pwszPath = wszPath;

    return NoError;
}


LPWSTR WINAPI CObjectPathParser::GetRelativePath(LPWSTR wszFullPath)
{
    LPWSTR wsz = wcschr(wszFullPath, L':');
    if(wsz)
        return wsz + 1;
    else
        return NULL;
}





void CObjectPathParser::Zero()
{
    m_nCurrentToken = 0;
    m_pLexer = 0;
    m_pInitialIdent = 0;
    m_pOutput = 0;
    m_pTmpKeyRef = 0;
}

CObjectPathParser::CObjectPathParser(ObjectParserFlags eFlags)
    : m_eFlags(eFlags)
{
    Zero();
}

void CObjectPathParser::Empty()
{
    delete m_pLexer;
    delete m_pInitialIdent;
    delete m_pTmpKeyRef;
    // m_pOutput is intentionally left alone,
    // since all code paths delete this already on error, or
    // else the user acquired the pointer.
}

CObjectPathParser::~CObjectPathParser()
{
    Empty();
}

int CObjectPathParser::Parse(
    LPCWSTR pRawPath,
    ParsedObjectPath **pOutput
    )
{
    if (pOutput == 0 || pRawPath == 0 || wcslen(pRawPath) == 0)
        return CObjectPathParser::InvalidParameter;

    // Check for leading / trailing ws.
    // ================================

    if (iswspace(pRawPath[wcslen(pRawPath)-1]) || iswspace(pRawPath[0]))
        return InvalidParameter;

     // These are required for multiple calls to Parse().
    // ==================================================
    Empty();
    Zero();

    // Set default return to NULL initially until we have some output.
    // ===============================================================
    *pOutput = 0;

    m_pOutput = new ParsedObjectPath;

    // Parse the server name (if there is one) manually
    // ================================================

    if ( (pRawPath[0] == '\\' && pRawPath[1] == '\\') ||
         (pRawPath[0] == '/' && pRawPath[1] == '/'))
    {
        const WCHAR* pwcStart = pRawPath + 2;

        // Find the next backslash --- it's the end of the server name
        // ===========================================================

        const WCHAR* pwcEnd = pwcStart;
        while (*pwcEnd != L'\0' && *pwcEnd != L'\\' && *pwcEnd != L'/')
        {
            pwcEnd++;
        }

        if (*pwcEnd == L'\0')
        {
            // If we have already exhausted the object path string,
            // a lone server name was all there was.
            // ====================================================

            if (m_eFlags != e_ParserAcceptAll)
            {
                delete m_pOutput;
                return SyntaxError;
            }
            else    // A lone server name is legal.
            {
                m_pOutput->m_pServer = new WCHAR[wcslen(pwcStart)+1];
                wcscpy(m_pOutput->m_pServer, pwcStart);

                *pOutput = m_pOutput;
                m_pOutput = 0;

                return NoError;
            }
        }

        if (pwcEnd == pwcStart)
        {
            // No name at all.
            // ===============
            delete m_pOutput;
            return SyntaxError;
        }

        m_pOutput->m_pServer = new WCHAR[pwcEnd-pwcStart+1];
        wcsncpy(m_pOutput->m_pServer, pwcStart, pwcEnd-pwcStart);
        m_pOutput->m_pServer[pwcEnd-pwcStart] = 0;

        pRawPath = pwcEnd;
    }

    // Point the lexer at the source.
    // ==============================

    CTextLexSource src(pRawPath);
    m_pLexer = new CGenLexer(OPath_LexTable, &src);

    // Go.
    // ===

    int nRes = begin_parse();
    if (nRes)
    {
        delete m_pOutput;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EOF)
    {
        delete m_pOutput;
        return SyntaxError;
    }

    if (m_pOutput->m_dwNumNamespaces > 0 && m_pOutput->m_pServer == NULL)
    {
        if (m_eFlags != e_ParserAcceptRelativeNamespace && m_eFlags != e_ParserAcceptAll)
        {
            delete m_pOutput;
            return SyntaxError;
        }
        else
        {
            // Local namespace --- set server to "."
            // =====================================
            m_pOutput->m_pServer = new WCHAR[2];
            wcscpy(m_pOutput->m_pServer, L".");
        }
    }

    // Sort the key refs lexically. If there is only
    // one key, there is nothing to sort anyway.
    // =============================================

    if (m_pOutput->m_dwNumKeys > 1)
    {
        BOOL bChanges = TRUE;
        while (bChanges)
        {
            bChanges = FALSE;
            for (DWORD dwIx = 0; dwIx < m_pOutput->m_dwNumKeys - 1; dwIx++)
            {
                if (_wcsicmp(m_pOutput->m_paKeys[dwIx]->m_pName,
                    m_pOutput->m_paKeys[dwIx+1]->m_pName) > 0)
                {
                    KeyRef *pTmp = m_pOutput->m_paKeys[dwIx];
                    m_pOutput->m_paKeys[dwIx] = m_pOutput->m_paKeys[dwIx + 1];
                    m_pOutput->m_paKeys[dwIx + 1] = pTmp;
                    bChanges = TRUE;
                }
            }
        }
    }


    // Add in key refs.
    // ================
    *pOutput = m_pOutput;
    m_pOutput = 0;
    return NoError;
}

BOOL CObjectPathParser::NextToken()
{
    m_nCurrentToken = m_pLexer->NextToken();
    if (m_nCurrentToken == OPATH_TOK_ERROR)
        return FALSE;
    return TRUE;
}


void CObjectPathParser::Free(ParsedObjectPath *pOutput)
{
    if(pOutput) delete pOutput;
}

//
//  <Parse> ::= BACKSLASH <ns_or_server>;
//  <Parse> ::= IDENT <ns_or_class>;
//  <Parse> ::= COLON <objref>;
//
int CObjectPathParser::begin_parse()
{
    if (!NextToken())
        return SyntaxError;

    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_or_server();
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pInitialIdent = Macro_CloneLPWSTR(m_pLexer->GetTokenText());
        if (!NextToken())
            return SyntaxError;

        // Copy the token and put it in a temporary holding place
        // until we figure out whether it is a namespace or a class name.
        // ==============================================================

        return ns_or_class();
    }
    else if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        if (!NextToken())
            return SyntaxError;
        return objref();
    }

    // If here, we had a bad starter token.
    // ====================================

    return SyntaxError;
}

//
//  <ns_or_server> ::= BACKSLASH <dot_or_ident> BACKSLASH <ns_list> <optional_objref>;
//  <ns_or_server> ::= <ns_list> <optional_objref>;
//
//  <dot_or_ident> is embedded.
//
int CObjectPathParser::ns_or_server()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        // Actually, server names have been take care of, so this is a failure
        // ===================================================================

        return SyntaxError;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        int nRes = ns_list();
        if (nRes)
            return nRes;
        return optional_objref();
    }
    else
        if (m_nCurrentToken == OPATH_TOK_EOF)
            return NoError;

    return SyntaxError;
}

//
//  <optional_objref> ::= COLON <objref>;
//  <optional_objref> ::= <>;
//
int CObjectPathParser::optional_objref()
{
    if (m_nCurrentToken == OPATH_TOK_EOF)
        return NoError;

    if (m_nCurrentToken != OPATH_TOK_COLON)
        return SyntaxError;
    if (!NextToken())
        return SyntaxError;
    return objref();
}


//
//  <ns_or_class> ::= COLON <ident_becomes_ns> <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list> COLON <objref>;
//  <ns_or_class> ::= BACKSLASH <ident_becomes_ns> <ns_list>;
//
int CObjectPathParser::ns_or_class()
{
    if (m_nCurrentToken == OPATH_TOK_COLON)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        return objref();
    }
    else if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        ident_becomes_ns();
        if (!NextToken())
            return SyntaxError;
        int nRes = ns_list();
        if (nRes)
            return nRes;
        if (m_nCurrentToken == OPATH_TOK_EOF)    // ns only
            return NoError;

        if (m_nCurrentToken != OPATH_TOK_COLON)
            return SyntaxError;
        if (!NextToken())
            return SyntaxError;
        return objref();
    }

    // Else
    // ====
    ident_becomes_class();
    return objref_rest();
}

//
//  <objref> ::= IDENT <objref_rest>;  // IDENT is classname
//
int CObjectPathParser::objref()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pLexer->GetTokenText());

    if (!NextToken())
        return SyntaxError;

    return objref_rest();
}

//
// <ns_list> ::= IDENT <ns_list_rest>;
//
int CObjectPathParser::ns_list()
{
    if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
        m_pOutput->AddNamespace(m_pLexer->GetTokenText());

        if (!NextToken())
            return SyntaxError;
        return ns_list_rest();
    }

    return SyntaxError;
}

//
//  <ident_becomes_ns> ::= <>;      // <initial_ident> becomes a namespace
//
int CObjectPathParser::ident_becomes_ns()
{
    m_pOutput->AddNamespace(m_pInitialIdent);

    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <ident_becomes_class> ::= <>;   // <initial_ident> becomes the class
//
int CObjectPathParser::ident_becomes_class()
{
    m_pOutput->m_pClass = Macro_CloneLPWSTR(m_pInitialIdent);
    delete m_pInitialIdent;
    m_pInitialIdent = 0;
    return NoError;
}

//
//  <objref_rest> ::= EQUALS <key_const>;
//  <objref_rest> ::= EQUALS *;
//  <objref_rest> ::= DOT <keyref_list>;
//  <objref_rest> ::= <>;
//
int CObjectPathParser::objref_rest()
{
    if (m_nCurrentToken == OPATH_TOK_EQ)
    {
        if (!NextToken())
            return SyntaxError;

        // Take care of the singleton case.  This is a path of the form
        // MyClass=@  and represents a singleton instance of a class with no
        // keys.


        if(m_nCurrentToken == OPATH_TOK_SINGLETON_SYM)
        {
            if(NextToken() && m_nCurrentToken != OPATH_TOK_EOF)
                return SyntaxError;
            m_pOutput->m_bSingletonObj = TRUE;
            return NoError;

        }

        m_pTmpKeyRef = new KeyRef;
        int nRes = key_const();
        if (nRes)
        {
            delete m_pTmpKeyRef;
            m_pTmpKeyRef = 0;
            return nRes;
        }

        m_pOutput->AddKeyRef(m_pTmpKeyRef);
        m_pTmpKeyRef = 0;
    }
    else if (m_nCurrentToken == OPATH_TOK_DOT)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
//  <ns_list_rest> ::= BACKSLASH <ns_list>;
//  <ns_list_rest> ::= <>;
//
int CObjectPathParser::ns_list_rest()
{
    if (m_nCurrentToken == OPATH_TOK_BACKSLASH)
    {
        if (!NextToken())
            return SyntaxError;
        return ns_list();
    }
    return NoError;
}

//
//  <key_const> ::= STRING_CONST;
//  <key_const> ::= INTEGRAL_CONST;
//  <key_const> ::= REAL_CONST;
//  <key_const> ::= IDENT;      // Where IDENT is "OBJECT" for singleton classes
//
int CObjectPathParser::key_const()
{
    // If here, we have a key constant.
    // We may or may not have the property name
    // associated with it.
    // ========================================

    if (m_nCurrentToken == OPATH_TOK_QSTRING)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_BSTR;
        V_BSTR(&m_pTmpKeyRef->m_vValue) = SysAllocString(m_pLexer->GetTokenText());
    }
    else if (m_nCurrentToken == OPATH_TOK_INT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return SyntaxError;
        sprintf(buf, "%S", m_pLexer->GetTokenText());
        V_I4(&m_pTmpKeyRef->m_vValue) = atol(buf);
    }
    else if (m_nCurrentToken == OPATH_TOK_HEXINT)
    {
        V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
        char buf[32];
        if(m_pLexer->GetTokenText() == NULL || wcslen(m_pLexer->GetTokenText()) > 31)
            return SyntaxError;
        sprintf(buf, "%S", m_pLexer->GetTokenText());
        long l;
        sscanf(buf, "%x", &l);
        V_I4(&m_pTmpKeyRef->m_vValue) = l;
    }
    else if (m_nCurrentToken == OPATH_TOK_IDENT)
    {
       if (_wcsicmp(m_pLexer->GetTokenText(), L"TRUE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 1;
          }
       else if (_wcsicmp(m_pLexer->GetTokenText(), L"FALSE") == 0)
       {
            V_VT(&m_pTmpKeyRef->m_vValue) = VT_I4;
            V_I4(&m_pTmpKeyRef->m_vValue) = 0;
       }
       else
            return SyntaxError;
    }
    else return SyntaxError;

    if (!NextToken())
        return SyntaxError;

    return NoError;
}

//
// <keyref_list> ::= <keyref> <keyref_term>;
//
int CObjectPathParser::keyref_list()
{
    int nRes = keyref();
    if (nRes)
        return nRes;
    return keyref_term();
}

//
// <keyref> ::= <propname> EQUALS <key_const>;
//
int CObjectPathParser::keyref()
{
    m_pTmpKeyRef = new KeyRef;

    int nRes = propname();

    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    if (m_nCurrentToken != OPATH_TOK_EQ)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    nRes = key_const();
    if (nRes)
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return nRes;
    }

    m_pOutput->AddKeyRef(m_pTmpKeyRef);
    m_pTmpKeyRef = 0;

    return NoError;
}

//
//  <keyref_term> ::= COMMA <keyref_list>;      // Used for compound keys
//  <keyref_term> ::= <>;
//
int CObjectPathParser::keyref_term()
{
    if (m_nCurrentToken == OPATH_TOK_COMMA)
    {
        if (!NextToken())
            return SyntaxError;
        return keyref_list();
    }

    return NoError;
}

//
// <propname>  ::= IDENT;
//
int CObjectPathParser::propname()
{
    if (m_nCurrentToken != OPATH_TOK_IDENT)
        return SyntaxError;

    m_pTmpKeyRef->m_pName = Macro_CloneLPWSTR(m_pLexer->GetTokenText());

    if (!NextToken())
    {
        delete m_pTmpKeyRef;
        m_pTmpKeyRef = 0;
        return SyntaxError;
    }

    return NoError;
}

//***************************************************************************
//
//  ParsedObjectPath::GetKeyString
//
//  Returns the db-engine compatible key string for the object.
//  The format will likely change after the Alpha PDK Release.
//
//  Return value:
//  NULL on error or for pure classes.  Otherwise returns a pointer to
//  a newly allocated string which must be deallocated with operator
//  delete.
//
//***************************************************************************
LPWSTR ParsedObjectPath::GetKeyString()
{
    if (m_dwNumKeys == 0 && !m_bSingletonObj)
    {
        if (m_pClass == 0 || wcslen(m_pClass) == 0)
            return 0;

        LPWSTR pTmp = new wchar_t[wcslen(m_pClass) + 1];
        wcscpy(pTmp, m_pClass);

        return pTmp;
    }

    // Allocate enough space
    // =====================

    int nSpace = 10;
    DWORD dwIx;
    for (dwIx = 0; dwIx < m_dwNumKeys; dwIx++)
    {
        KeyRef* pKey = m_paKeys[dwIx];
        nSpace += 2; // for the |
        if(V_VT(&pKey->m_vValue) == VT_BSTR)
        {
            nSpace += wcslen(V_BSTR(&pKey->m_vValue))*2 + 10;
        }
        else if(V_VT(&pKey->m_vValue) == VT_I4)
        {
            nSpace += 30;
        }
    }
    if(m_bSingletonObj)
        nSpace +=20;


    LPWSTR pRetVal = new wchar_t[nSpace];
    wchar_t Tmp[32];
    long nVal;

    *pRetVal = 0;
    BOOL bFirst = TRUE;

    // The key are already sorted lexically.
    // =====================================

    WCHAR wszSeparator[2];
    wszSeparator[0] = 0xFFFF;
    wszSeparator[1] = 0;

    for (DWORD i = 0; i < m_dwNumKeys; i++)
    {
        if (!bFirst)
            wcscat(pRetVal, wszSeparator);
        bFirst = FALSE;

        KeyRef *pKeyRef = m_paKeys[i];
        VARIANT *pv = &pKeyRef->m_vValue;

        int nType = V_VT(pv);
        switch (nType)
        {
            case VT_LPWSTR:
            case VT_BSTR:
                wcscat(pRetVal, V_BSTR(pv));
                break;

            case VT_I4:
                nVal = V_I4(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_I2:
                nVal = V_I2(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_UI1:
                nVal = V_UI1(pv);
                swprintf(Tmp, L"%d", nVal);
                wcscat(pRetVal, Tmp);
                break;

            case VT_BOOL:
                nVal = V_BOOL(pv);
                swprintf(Tmp, L"%d", (nVal?1:0));
                wcscat(pRetVal, Tmp);
                break;

            default:
                wcscat(pRetVal, L"NULL");
        }
    }

    if (wcslen(pRetVal) == 0)
    {
        if(m_bSingletonObj)
        {
            wcscpy(pRetVal, L"@");
        }
    }
    return pRetVal;     // This may not be NULL
}

LPWSTR ParsedObjectPath::GetNamespacePart()
{
    if (m_dwNumNamespaces == 0)
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];
    *wszOut = 0;

    // Output
    // ======

    for(i = 0; i < m_dwNumNamespaces; i++)
    {
        if(i != 0) wcscat(wszOut, L"\\");
        wcscat(wszOut, m_paNamespaces[i]);
    }

    return wszOut;
}

LPWSTR ParsedObjectPath::GetParentNamespacePart()
{
    if(m_dwNumNamespaces < 2)
        return NULL;

    // Compute necessary space
    // =======================

    int nSpace = 0;
    for(DWORD i = 0; i < m_dwNumNamespaces - 1; i++)
        nSpace += 1 + wcslen(m_paNamespaces[i]);
    nSpace--;

    // Allocate buffer
    // ===============

    LPWSTR wszOut = new wchar_t[nSpace + 1];
    *wszOut = 0;

    // Output
    // ======

    for(i = 0; i < m_dwNumNamespaces - 1; i++)
    {
        if(i != 0) wcscat(wszOut, L"\\");
        wcscat(wszOut, m_paNamespaces[i]);
    }

    return wszOut;
}

BOOL ParsedObjectPath::IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace)
{
    if(!IsLocal(wszMachine))
        return FALSE;

    if(m_dwNumNamespaces == 0)
        return TRUE;

    LPWSTR wszCopy = new wchar_t[wcslen(wszNamespace) + 1];
    wcscpy(wszCopy, wszNamespace);
    LPWSTR wszLeft = wszCopy;
    BOOL bFailed = FALSE;

    for(DWORD i = 0; i < m_dwNumNamespaces; i++)
    {
        unsigned int nLen = wcslen(m_paNamespaces[i]);
        if(nLen > wcslen(wszLeft))
        {
            bFailed = TRUE;
            break;
        }
        if(i == m_dwNumNamespaces - 1 && wszLeft[nLen] != 0)
        {
            bFailed = TRUE;
            break;
        }
        if(i != m_dwNumNamespaces - 1 && wszLeft[nLen] != L'\\')
        {
            bFailed = TRUE;
            break;
        }

        wszLeft[nLen] = 0;
        if(_wcsicmp(wszLeft, m_paNamespaces[i]))
        {
            bFailed = TRUE;
            break;
        }
        wszLeft += nLen+1;
    }
    delete [] wszCopy;
    return !bFailed;
}

BOOL ParsedObjectPath::IsLocal(LPCWSTR wszMachine)
{
    return (m_pServer == NULL || !_wcsicmp(m_pServer, L".") ||
        !_wcsicmp(m_pServer, wszMachine));
}


////////////////////////////////////////////////////////
//
// Test object path parser by parsing all objects
// in the input file (one object path per line).
// 
////////////////////////////////////////////////////////

#ifdef TEST
void xmain(int argc, char **argv)
{
    printf("Object Path Test\n");
    if (argc < 2 || strchr(argv[1], '?') != NULL)
    {
        printf("Usage: objpath input-file\n");
        return;
    }

    int nLine = 1;
    char buf[2048];
    FILE *f = fopen(argv[1], "rt");
    if (f == NULL)
    {
        printf("Usage: objpath input-file\nError: cannot open file %s!\n", argv[1]);
        return;
    }

    while (fgets(buf, 2048, f) != NULL)
    {
        // Get rid of newline and trailing spaces.
        // =======================================

        char* ptr = strchr(buf, '\n');
        if (ptr != NULL)
        {
            *ptr = ' ';
            while (ptr >= buf && *ptr == ' ')
            {
                *ptr = '\0'; 
                ptr--;
            }
        }

        // Get rid of leading spaces.
        // ==========================

        ptr = buf;
        while (*ptr == ' ')
        {
            ptr++;
        }

        // Convert to wide char and parse.  Ignore blank lines.
        // ====================================================

        if (*ptr != '\0')
        {
            wchar_t buf2[2048];
            MultiByteToWideChar(CP_ACP, 0, ptr, -1, buf2, 2048);

            printf("----Object path----\n");
            printf("%S\n", buf2);

            ParsedObjectPath* pOutput = 0;
            CObjectPathParser p(e_ParserAcceptAll);
            int nStatus = p.Parse(buf2,  &pOutput);

            if (nStatus != 0)
            {
                printf("ERROR: return code is %d\n", nStatus);
                continue;
            }
            printf("No errors.\n");

            printf("------Output------\n");

            LPWSTR pKey = pOutput->GetKeyString();
            printf("Key String = <%S>\n", pKey);
            delete pKey;

            printf("Server = %S\n", pOutput->m_pServer);
            printf("Namespace Part = %S\n", pOutput->GetNamespacePart());
            printf("Parent Part    = %S\n", pOutput->GetParentNamespacePart());

            for (DWORD dwIx = 0; dwIx < pOutput->m_dwNumNamespaces; dwIx++)
            {
                printf("Namespace = <%S>\n", pOutput->m_paNamespaces[dwIx]);
            }

            printf("Class = <%S>\n", pOutput->m_pClass);

            // If here, the key ref is complete.
            // =================================

            for (dwIx = 0; dwIx < pOutput->m_dwNumKeys; dwIx++)
            {
                KeyRef *pTmp = pOutput->m_paKeys[dwIx];
                printf("*** KeyRef contents:\n");
                printf("    Name = %S   Value=", pTmp->m_pName);
                switch (V_VT(&pTmp->m_vValue))
                {
                    case VT_I4: printf("%d", V_I4(&pTmp->m_vValue)); break;
                    case VT_R8: printf("%f", V_R8(&pTmp->m_vValue)); break;
                    case VT_BSTR: printf("<%S>", V_BSTR(&pTmp->m_vValue)); break;
                    default:
                        printf("BAD KEY REF\n");
                }
                printf("\n");
            }

            p.Free(pOutput);
        }
    }
}

void main(int argc, char **argv)
{
        xmain(argc, argv);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\ntrkcomm.cpp ===
#include <wbemprov.h>
#include "ntrkcomm.h"

extern long g_cObj;


CWbemServices::CWbemServices(
    IWbemServices* pNamespace)
    :m_pWbemServices(NULL)
{
    m_pWbemServices = pNamespace;
    if(m_pWbemServices != NULL)
        m_pWbemServices->AddRef();
}

CWbemServices::~CWbemServices()
{
    if(m_pWbemServices != NULL)
        m_pWbemServices->Release();
}

HRESULT
CWbemServices::CreateClassEnum(
    /* [in] */ const BSTR Superclass,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
    ) 
{
    SCODE sc = m_pWbemServices->CreateClassEnum(
        Superclass,
        lFlags,
        pCtx,
        ppEnum);
    CoImpersonateClient();    
    return sc;
}

HRESULT
CWbemServices::CreateInstanceEnum(
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
    HRESULT hr = m_pWbemServices->CreateInstanceEnum(
        Class,
        lFlags,
        pCtx,
        ppEnum);
    CoImpersonateClient();    
    return hr;
}

HRESULT
CWbemServices::DeleteClass(
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
    HRESULT hr = m_pWbemServices->DeleteClass(
        Class,
        lFlags,
        pCtx,
        ppCallResult);
    CoImpersonateClient();    
    return hr;
}

HRESULT
CWbemServices::DeleteInstance(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
    HRESULT hr = m_pWbemServices->DeleteInstance(
        ObjectPath,
        lFlags,
        pCtx,
        ppCallResult);
    CoImpersonateClient();    
    return hr;
}



HRESULT
CWbemServices::ExecMethod(
    const BSTR strObjectPath, 
    const BSTR MethodName, 
    long lFlags, 
    IWbemContext* pCtx,
    IWbemClassObject* pInParams,
    IWbemClassObject** ppOurParams, 
    IWbemCallResult** ppCallResult) 
{
    HRESULT hr = m_pWbemServices->ExecMethod(
        strObjectPath, 
        MethodName, 
        lFlags, 
        pCtx,
        pInParams,
        ppOurParams, 
        ppCallResult) ;
    CoImpersonateClient();    
    return hr;    
}

HRESULT
CWbemServices::ExecNotificationQuery(
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
    HRESULT hr = m_pWbemServices->ExecNotificationQuery(
        QueryLanguage,
        Query,
        lFlags,
        pCtx,
        ppEnum);
    CoImpersonateClient();    
    return hr;
}

HRESULT
CWbemServices::ExecQuery(
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum) 
{
    HRESULT hr = m_pWbemServices->ExecQuery(
        QueryLanguage,
        Query,
        lFlags,
        pCtx,
        ppEnum);
    CoImpersonateClient();    
    return hr;
}

HRESULT
CWbemServices::GetObject(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
    HRESULT hr = m_pWbemServices->GetObject(
        ObjectPath,
        lFlags,
        pCtx,
        ppObject,
        ppCallResult);
    CoImpersonateClient();    
    return hr;

}
 
HRESULT
CWbemServices::PutClass(
    /* [in] */ IWbemClassObject __RPC_FAR *pObject,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{
    HRESULT hr = m_pWbemServices->PutClass(
        pObject,
        lFlags,
        pCtx,
        ppCallResult);
    CoImpersonateClient();    
    return hr;

}

HRESULT
CWbemServices::PutInstance(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult) 
{    

    HRESULT hr = m_pWbemServices->PutInstance(
        pInst,
        lFlags,
        pCtx,
        ppCallResult);
    CoImpersonateClient();    
    return hr;
}

/*CImpersonatedProvider
*  Purpose: provide a general solution for impersonate client for 
*  Wbem providers.
*  USAGE:
*  Inherit from this class, and implement abstact virtual functions.
*  child class should implement function prefixed with "Do".
* ******************************************/
CImpersonatedProvider::CImpersonatedProvider(
    const BSTR ObjectPath,
    const BSTR User, 
    const BSTR Password, 
    IWbemContext * pCtx)
    :m_cRef(0), m_pNamespace(NULL)
{

}

CImpersonatedProvider::~CImpersonatedProvider()
{
    if(m_pNamespace)
        delete m_pNamespace;
}

STDMETHODIMP_(ULONG) 
CImpersonatedProvider::AddRef(void)
{
    InterlockedIncrement(&g_cObj);

    return InterlockedIncrement((long *)&m_cRef);
}

STDMETHODIMP_(ULONG) 
CImpersonatedProvider::Release(void)
{
    InterlockedDecrement(&g_cObj);

    long lNewCount = InterlockedDecrement((long *)&m_cRef);

    if (0L == lNewCount)
        delete this;
    
    return lNewCount>0 ? lNewCount : 0;
}

STDMETHODIMP 
CImpersonatedProvider::QueryInterface(
    REFIID riid, 
    PPVOID ppv)
{
    *ppv=NULL;

    // Since we have dual inheritance, it is necessary to cast the return type

    if(riid== IID_IWbemServices)
       *ppv = (IWbemServices*)this;

    if(IID_IUnknown==riid || riid== IID_IWbemProviderInit)
       *ppv = (IWbemProviderInit*)this;
    

    if (NULL != *ppv)
    {
        AddRef();
        return S_OK;
    }
    else
        return E_NOINTERFACE;
  
}

STDMETHODIMP 
CImpersonatedProvider::Initialize(
    LPWSTR pszUser, LONG lFlags,
    LPWSTR pszNamespace, LPWSTR pszLocale,
    IWbemServices *pNamespace, 
    IWbemContext *pCtx,
    IWbemProviderInitSink *pInitSink)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    LONG lStatus = WBEM_S_INITIALIZED;
    m_pNamespace = new CWbemServices(pNamespace); 
    if(m_pNamespace == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        lStatus = WBEM_E_FAILED;
    }
        
    //Let CIMOM know you are initialized
    //==================================
    
    pInitSink->SetStatus(lStatus,0);
    return hr;
}



HRESULT
CImpersonatedProvider::CreateInstanceEnumAsync(
    /* [in] */ const BSTR Class,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    CoImpersonateClient();
    return DoCreateInstanceEnumAsync(
        Class,
        lFlags,
        pCtx,
        pResponseHandler);
}

HRESULT
CImpersonatedProvider::DeleteInstanceAsync(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
    CoImpersonateClient();
    return DoDeleteInstanceAsync(
        ObjectPath,
        lFlags,
        pCtx,
        pResponseHandler);
}


HRESULT
CImpersonatedProvider::ExecMethodAsync(
    const BSTR strObjectPath,
    const BSTR MethodName, 
    long lFlags, 
    IWbemContext* pCtx,
    IWbemClassObject* pInParams,
    IWbemObjectSink* pResponseHandler)
{
    CoImpersonateClient();
    return DoExecMethodAsync(
        strObjectPath,
        MethodName,
        lFlags,
        pCtx,
        pInParams,
        pResponseHandler);
    
}


HRESULT
CImpersonatedProvider::ExecQueryAsync(
    /* [in] */ const BSTR QueryLanguage,
    /* [in] */ const BSTR Query,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
    CoImpersonateClient();
    return DoExecQueryAsync(
        QueryLanguage,
        Query,
        lFlags,
        pCtx,
        pResponseHandler);
    
}

HRESULT
CImpersonatedProvider::GetObjectAsync(
    /* [in] */ const BSTR ObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
    CoImpersonateClient();
    return DoGetObjectAsync(
        ObjectPath,
        lFlags,
        pCtx,
        pResponseHandler);
    
}


HRESULT
CImpersonatedProvider::PutInstanceAsync(
    /* [in] */ IWbemClassObject __RPC_FAR *pInst,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler) 
{
    CoImpersonateClient();
    return DoPutInstanceAsync(
        pInst,
        lFlags,
        pCtx,
        pResponseHandler);
    
}

// CWbemInstanceMgr

CWbemInstanceMgr::CWbemInstanceMgr(
    IWbemObjectSink* pHandler,
    DWORD dwSize)
    :m_pSink(NULL), m_ppInst(NULL), m_dwIndex(0)
{
    m_pSink = pHandler;
    if(m_pSink != NULL)
        m_pSink->AddRef();
    m_dwThreshHold = dwSize;
    m_ppInst = new IWbemClassObject*[dwSize];
    for(DWORD i = 0; i < dwSize; i++)
        m_ppInst[i] = NULL;
}
CWbemInstanceMgr::~CWbemInstanceMgr()
{
    if(m_ppInst != NULL)
    {
        if(m_dwIndex >0)
        {
            m_pSink->Indicate(
                m_dwIndex,
                m_ppInst);
        }

        for(DWORD i =0; i<m_dwIndex; i++)
        {
            if(m_ppInst[i] != NULL)
                (m_ppInst[i])->Release();
        }
        delete [] m_ppInst;
    }

    if(m_pSink != NULL)
        m_pSink->Release();
}

void 
CWbemInstanceMgr::Indicate(IWbemClassObject* pInst)
{
    if(pInst == NULL)
        throw WBEM_E_INVALID_PARAMETER;

    m_ppInst[m_dwIndex++] = pInst;
    pInst->AddRef();
    if(m_dwIndex == m_dwThreshHold)
    {

        SCODE  sc = m_pSink->Indicate(
            m_dwIndex,
            m_ppInst);
        if(sc != S_OK)
            throw sc;
        
        // reset state
        for(DWORD i=0; i< m_dwThreshHold; i++)
        {
            if(m_ppInst[i] != NULL)
                (m_ppInst[i])->Release();
            m_ppInst[i] = NULL;
        }
        m_dwIndex = 0;
    }

    return;
}

void
CWbemInstanceMgr::SetStatus(
    LONG lFlags,
    HRESULT hr,
    const BSTR strParam,
    IWbemClassObject* pObjParam)
{
    m_pSink->SetStatus(
        lFlags,
        hr,
        strParam,
        pObjParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\objpath.h ===
/*++

Copyright (C) 1999 Microsoft Corporation

Module Name:

    OBJPATH.H

Abstract:

    object path parser

History:

--*/

#ifndef _OBJPATH_H_
#define _OBJPATH_H_

#include <opathlex.h>
#include <Polarity.h>

#define DELETE_ME

struct POLARITY KeyRef
{
    LPWSTR  m_pName;
    VARIANT m_vValue;

    KeyRef();
    KeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue);
   ~KeyRef();
};

struct POLARITY ParsedObjectPath
{
    LPWSTR      m_pServer;              // NULL if no server
    DWORD       m_dwNumNamespaces;      // 0 if no namespaces
    DWORD       m_dwAllocNamespaces;    // size of m_paNamespaces
    LPWSTR     *m_paNamespaces;         // NULL if no namespaces
    LPWSTR      m_pClass;               // Class name
    DWORD       m_dwNumKeys;            // 0 if no keys (just a class name)
    DWORD       m_dwAllocKeys;          // size of m_paKeys
    KeyRef    **m_paKeys;               // NULL if no keys specified
    BOOL        m_bSingletonObj;        // true if object of class with no keys
    ParsedObjectPath();
   ~ParsedObjectPath();

public:
    BOOL SetClassName(LPCWSTR wszClassName);
    BOOL AddKeyRef(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddKeyRef(KeyRef* pAcquireRef);
    BOOL AddKeyRefEx(LPCWSTR wszKeyName, const VARIANT* pvValue);
    BOOL AddNamespace(LPCWSTR wszNamespace);
    LPWSTR GetKeyString();
    LPWSTR GetNamespacePart();
    LPWSTR GetParentNamespacePart();
    void ClearKeys () ;
    BOOL IsRelative(LPCWSTR wszMachine, LPCWSTR wszNamespace);
    BOOL IsLocal(LPCWSTR wszMachine);
    BOOL IsClass();
    BOOL IsInstance();
    BOOL IsObject();
};

// NOTE:
// The m_vValue in the KeyRef may not be of the expected type, i.e., the parser
// cannot distinguish 16 bit integers from 32 bit integers if they fall within the
// legal subrange of a 16 bit value.  Therefore, the parser only uses the following
// types for keys:
//      VT_I4, VT_R8, VT_BSTR
// If the underlying type is different, the user of this parser must do appropriate
// type conversion.
//  
typedef enum
{
    e_ParserAcceptRelativeNamespace,    // Allow a relative namespace
    e_ParserAbsoluteNamespaceOnly,      // Require a full object path
    e_ParserAcceptAll                   // Accept any recognizable subset of a path
} ObjectParserFlags;

class POLARITY CObjectPathParser
{
    LPWSTR m_pInitialIdent;
    int m_nCurrentToken;
    CGenLexer *m_pLexer;
    ParsedObjectPath *m_pOutput;
    KeyRef *m_pTmpKeyRef;
    
    ObjectParserFlags m_eFlags;

private:
    void Zero();
    void Empty();

    int begin_parse();

    int ns_or_server();
    int ns_or_class();
    int objref();
    int ns_list();
    int ident_becomes_ns();
    int ident_becomes_class();
    int objref_rest();
    int ns_list_rest();
    int key_const();
    int keyref_list();
    int keyref();
    int keyref_term();
    int propname();    
    int optional_objref();

    int NextToken();

public:
    enum { NoError, SyntaxError, InvalidParameter };

    CObjectPathParser(ObjectParserFlags eFlags = e_ParserAbsoluteNamespaceOnly);
   ~CObjectPathParser();

    int Parse(
        LPCWSTR RawPath,
        ParsedObjectPath **pOutput
        );
    static int WINAPI Unparse(
        ParsedObjectPath* pInput,
        DELETE_ME LPWSTR* pwszPath);

    static LPWSTR WINAPI GetRelativePath(LPWSTR wszFullPath);

    void Free(ParsedObjectPath *pOutput);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\opathlex.cpp ===
/*++

Copyright (C) 1995-1999 Microsoft Corporation

Module Name:

  OPATHLEX.CPP

Abstract:

  Object Path Lexer Map (for use with GENLEX.CPP).

History:

  24-Jun-95       Created.
  14-Apr-98       Radical update for singly quoted strings, remove
                  unused tokens, add hex constants, etc.

--*/

#include <windows.h>
#include <stdio.h>

#include <genlex.h>
#include <opathlex.h>             


#define ST_IDENT            22
#define ST_NUMERIC          28
#define ST_DECIMAL          30
#define ST_HEX              32
#define ST_SQ_STRING        36
#define ST_DQ_STRING        40
#define ST_DQ_STRING_ESC    43



// DFA State Table for Object Path tokens.
// =======================================

LexEl OPath_LexTable[] =
{

// State    First   Last        New state,  Return tok,      Instructions
// =======================================================================

    // -------------------------------------------------------------
    // Identifiers
    
/* 0 */  L'A',   L'Z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 1 */  L'a',   L'z',       ST_IDENT,   0,               GLEX_ACCEPT,
/* 2 */  0x80,   0xfffd,     ST_IDENT,   0,               GLEX_ACCEPT,
/* 3 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,               GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Single symbols
    
/* 4 */  L'.',   GLEX_EMPTY, 0,  OPATH_TOK_DOT,              GLEX_ACCEPT,
/* 5 */  '@',    GLEX_EMPTY, 0,  OPATH_TOK_SINGLETON_SYM,    GLEX_ACCEPT,
/* 6 */  L'=',   GLEX_EMPTY, 0,  OPATH_TOK_EQ,               GLEX_ACCEPT,
/* 7 */  L':',   GLEX_EMPTY, 0,  OPATH_TOK_COLON,            GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Backslashes & forward slashes are interchangeable and reported
    // as OPATH_TOK_BACKSLASH to the parser.
    
/* 8 */ L'\\',  GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,
/* 9 */ L'/',   GLEX_EMPTY, 0, OPATH_TOK_BACKSLASH,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // Simple numeric transition.  The '-' must be followed
    // by decimal digit sequence.  The '0' may be the beginning of a hex
    // or a decimal sequence.
    
/* 10 */ L'1',   L'9',       ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 11 */ L'-',   GLEX_EMPTY, ST_DECIMAL, 0,               GLEX_ACCEPT,
/* 12 */ L'0',   GLEX_EMPTY, ST_NUMERIC, 0,               GLEX_ACCEPT,


    // -------------------------------------------------------------
    // Simple string transition
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 
        
/* 13 */ L'"',   GLEX_EMPTY, ST_DQ_STRING, 0,               GLEX_CONSUME,
/* 14 */ L'\'',  GLEX_EMPTY, ST_SQ_STRING, 0,               GLEX_CONSUME,


    // -------------------------------------------------------------
    // Whitespace, newlines, etc.  Whitespace is an error.
    
/* 15 */ L' ',   GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 16 */ L'\t',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 17 */ L'\n',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 18 */ L'\r',  GLEX_EMPTY, 0,  OPATH_TOK_ERROR,  GLEX_ACCEPT|GLEX_RETURN,
/* 19 */ 0,      GLEX_EMPTY, 0,  OPATH_TOK_EOF,   GLEX_CONSUME|GLEX_RETURN, // Note forced return
/* 20 */ L',',   GLEX_EMPTY, 0,  OPATH_TOK_COMMA, GLEX_ACCEPT,

    // All remaining unknown characters

/* 21 */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,


    // -------------------------------------------------------------
    // ST_IDENT
    // Accepts C/C++ identifiers, plus any char >= U+0080.

/* 22 */  L'a',   L'z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 23 */  L'A',   L'Z',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 24 */  L'_',   GLEX_EMPTY, ST_IDENT,   0,          GLEX_ACCEPT,
/* 25 */  L'0',   L'9',       ST_IDENT,   0,          GLEX_ACCEPT,
/* 26 */  0x80,  0xfffd,     ST_IDENT,   0,           GLEX_ACCEPT,
/* 27 */  GLEX_ANY, GLEX_EMPTY,  0,       OPATH_TOK_IDENT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_NUMERIC
    // 
    // A zero has been recognized.
    // If the next char is 'x' or 'X', we have a valid hex sequence.
    // Otherwise, if '1' to '9' we have a decimal sequence.
    // 

/* 28 */  L'x',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,
/* 29 */  L'X',  GLEX_EMPTY,  ST_HEX,  0,    GLEX_ACCEPT,


    // -------------------------------------------------------------
    // ST_DECIMAL
    // 

/* 30 */  L'0',     L'9',       ST_DECIMAL, 0,              GLEX_ACCEPT,
/* 31 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_INT,  GLEX_PUSHBACK|GLEX_RETURN,

    // -------------------------------------------------------------
    // ST_HEX
    //
    // Recognizes a valid hex sequence.

/* 32 */  L'a',     L'f',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 33 */  L'A',     L'F',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 34 */  L'0',     L'9',       ST_HEX,     0,                 GLEX_ACCEPT,
/* 35 */  GLEX_ANY, GLEX_EMPTY, 0,          OPATH_TOK_HEXINT,  GLEX_PUSHBACK|GLEX_RETURN,
    
    // -------------------------------------------------------------
    // ST_SQ_STRING : Single quoted strings
    //
    // If a single quote begins the string, it must end the string.
    // Escapes are not supported:   'ab', 'a"b'  <not: 'a\'b'>

/* 36 */   L'\n', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 37 */   L'\r', GLEX_EMPTY, 0,  OPATH_TOK_ERROR,      GLEX_ACCEPT|GLEX_LINEFEED,
/* 38 */   L'\'',  GLEX_EMPTY, 0,  OPATH_TOK_QSTRING,   GLEX_CONSUME,
/* 39 */   GLEX_ANY, GLEX_EMPTY, ST_SQ_STRING,  0,      GLEX_ACCEPT,

    // -------------------------------------------------------------
    // ST_DQ_STRING
    //
    // If a double quote begins the string, it must end the string,
    // except that escape+quote is an embedded double quote:
    //
    //     "ab", "a'b", "a\"b"
    // 

/* 40 */   L'\\', GLEX_EMPTY, ST_DQ_STRING_ESC, 0,                  GLEX_CONSUME,    // Escape
/* 41 */   L'"',  GLEX_EMPTY, 0,                OPATH_TOK_QSTRING,  GLEX_CONSUME,
/* 42 */   L'"',  GLEX_EMPTY, ST_DQ_STRING,     0,                  GLEX_ACCEPT|GLEX_NOT, 
                    // Accept anything but a quote

    //-------------------------------------------------------------
    // ST_DQ_STRING_ESC
    //
    // An escape occurred while in a string.
    // Either an embedded slash or embedded quote must have occurred.
    // Otherwise, an unsupported escape has occurred and we fail.

/* 43  */    L'\\', GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 44  */    L'"',  GLEX_EMPTY, ST_DQ_STRING, 0,  GLEX_ACCEPT,
/* 45  */ GLEX_ANY, GLEX_EMPTY, 0,        OPATH_TOK_ERROR, GLEX_ACCEPT|GLEX_RETURN,

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\utils.cpp ===
//***************************************************************************
//
//  UTILS.CPP
//
//  Module: WBEM Instance provider
//
//  Purpose: General purpose utilities.  
//
//  Copyright (c)1998 Microsoft Corporation, All Rights Reserved
//
//***************************************************************************

#include "iisprov.h"


//define the static synch object
CSynchObject CUtils::s_synObject;

/////////////////////////////////////////////////////////////////////////////
//
// CUtils::MzCat
//
// Synopsis:
// The metabase has this animal called METADATA_STRINGSZ which has the 
// following form: <string><null><string><null><null>.  MzCat concatenates
// strings in the defined way.  *a_ppdst has the new pointer upon exit.  The
// previous value of *a_ppdst is delelted.  *a_ppdst == NULL is handled.
//
/////////////////////////////////////////////////////////////////////////////

void CUtils::MzCat (
    WCHAR**        a_ppdst,
    const WCHAR*   a_psz
    )
{
    WCHAR    *t_psrc, *t_pdst, *t_pnew;
    int        t_ilen;

    if (a_psz == NULL)
        throw WBEM_E_FAILED;

    if (*a_ppdst) 
    {
        for ( t_ilen=0, t_psrc = *a_ppdst
            ; *t_psrc || *(t_psrc+1)
            ; t_psrc++, t_ilen++
            )
        {
            ;
        }

        t_ilen = t_ilen + wcslen(a_psz)+3;
    }
    else t_ilen = wcslen(a_psz)+2;

    t_pnew = t_pdst = new WCHAR[t_ilen];

    if (!t_pdst)
        throw WBEM_E_OUT_OF_MEMORY;
    
    if (*a_ppdst) 
    {
        for ( t_psrc = *a_ppdst
            ; *t_psrc || *(t_psrc+1)
            ; t_pdst++, t_psrc++
            )
        {
            *t_pdst = *t_psrc;
        }

        *t_pdst = L'\0';
        *t_pdst++;
    }
    wcscpy(t_pdst,a_psz);
    *(t_pnew+t_ilen-1)=L'\0';

    delete *a_ppdst;
    *a_ppdst=t_pnew;
}


/////////////////////////////////////////////////////////////////////////////
//
// CUtils::GetToken
//
// Synopsis:
// *a_ppsz is a pointer to string being parsed. a_pszTok returns the next
// token.  
//
/////////////////////////////////////////////////////////////////////////////

void CUtils::GetToken(
    WCHAR** a_ppsz, 
    WCHAR*  a_pszTok
    )
{
    if (*a_ppsz == NULL) 
    {
        *a_pszTok = L'\0';
        return;
    }

    while ( **a_ppsz != L' ' && **a_ppsz )
    {
        *a_pszTok++ = **a_ppsz,(*a_ppsz)++;
    }
    
    *a_pszTok = L'\0';

    while ( **a_ppsz == L' ' )
    {
        (*a_ppsz)++;
    }
     
}

/////////////////////////////////////////////////////////////////////////////
//
// CUtils::GetKey
//
// Synopsis:
// Return the KeyRef pointer from the ParsedObjectPath for the given string.
//
/////////////////////////////////////////////////////////////////////////////

KeyRef* CUtils::GetKey(
    ParsedObjectPath*    a_p, 
    WCHAR*               a_psz
    )
{
    KeyRef* t_pkr;
    DWORD   t_numkeys = a_p->m_dwNumKeys;
    DWORD   t_c;

    for ( t_c=0; t_numkeys; t_numkeys--,t_c++ ) 
    {
        t_pkr = *(a_p->m_paKeys + t_c);
        if (!lstrcmpiW(t_pkr->m_pName,a_psz))
            return t_pkr;
    }

    return NULL;
}


/////////////////////////////////////////////////////////////////////////////
//
// CUtils::GetAssociation
//
// Synopsis:
// Association a_pszAssociationName is returned in a_ppAssociation if found. 
// Returns true if association is found false otherwise.
//
/////////////////////////////////////////////////////////////////////////////

bool CUtils::GetAssociation(
    LPCWSTR              a_pszAssociationName,
    WMI_ASSOCIATION**    a_ppassociation
    )
{
    WMI_ASSOCIATION**    t_ppassociation;

    if (a_pszAssociationName == NULL || a_ppassociation==NULL)
        throw WBEM_E_INVALID_CLASS;

    for ( t_ppassociation = WMI_ASSOCIATION_DATA::s_WmiAssociations
        ; *t_ppassociation != NULL
        ;t_ppassociation++
        )
    {
        if (_wcsicmp(a_pszAssociationName,(*t_ppassociation)->pszAssociationName) ==0)
        {
            *a_ppassociation = *t_ppassociation;        
            return true;
        }
    }

    return false;
    
}

/////////////////////////////////////////////////////////////////////////////
//
// CUtils::GetMetabasePath
//
// Synopsis:
//
/////////////////////////////////////////////////////////////////////////////

void CUtils::GetMetabasePath(
    IWbemClassObject* a_pObj,
    ParsedObjectPath* a_p,    
    WMI_CLASS*        a_pclass,
    _bstr_t&          a_bstrPath 
    )
{
    KeyRef* t_pkr;
    WCHAR*  t_pszKey = a_pclass->pszKeyName;
    WCHAR*  t_psz;

    if (a_p == NULL || a_pclass == NULL)
        throw WBEM_E_FAILED;
        
    if (a_pclass->pszKeyName == NULL) 
    {
        a_bstrPath = a_pclass->pszMetabaseKey;
        return;
    }

    t_psz = new WCHAR[wcslen(t_pszKey) + 1];
    if(!t_psz)
        throw WBEM_E_OUT_OF_MEMORY;

    try
    {
        a_bstrPath = a_pclass->pszMetabaseKey;

        for ( GetToken(&t_pszKey,t_psz); *t_psz; GetToken(&t_pszKey,t_psz) ) 
        {
            if (*t_psz == L'/')
                a_bstrPath += t_psz;
            else 
            {
                if (*t_psz == L'#')
                    t_pkr = GetKey(a_p,&t_psz[1]);
                else 
                    t_pkr = GetKey(a_p,t_psz);

                if(t_pkr == NULL)
                    break;

                if (a_pObj)
                {
                    _bstr_t t_bstr = t_pkr->m_pName;
                    HRESULT t_hr = a_pObj->Put(t_bstr, 0, &t_pkr->m_vValue, 0);
                    THROW_ON_ERROR(t_hr);
                }

                switch ((t_pkr)->m_vValue.vt)
                {
                case VT_I4:
                    swprintf(t_psz,L"/%d",t_pkr->m_vValue.lVal);
                    a_bstrPath += t_psz;
                    break;
                case VT_BSTR:
                    a_bstrPath += L"/";
                    a_bstrPath += t_pkr->m_vValue.bstrVal;
                    break;
                }
            }
        }

        delete [] t_psz;
    }
    catch(...)
    {
        delete [] t_psz;
    }

    return;    
}

/////////////////////////////////////////////////////////////////////////////
//
// CUtils::GetClass
//
// Synopsis:
// Class a_pszClass is returned in a_ppclass if found. 
// Returns true if association is found false otherwise.
//
/////////////////////////////////////////////////////////////////////////////

bool CUtils::GetClass(
    LPCWSTR        a_pszClass,
    WMI_CLASS**    a_ppclass
    )
{
    WMI_CLASS**    t_ppclass;

    if (a_pszClass == NULL || a_ppclass==NULL)
        throw WBEM_E_INVALID_CLASS;

    for (t_ppclass = WMI_CLASS_DATA::s_WmiClasses; *t_ppclass != NULL;t_ppclass++)
        if (_wcsicmp(a_pszClass,(*t_ppclass)->pszClassName) ==0) 
        {
            *a_ppclass = *t_ppclass;        
            return true;
        }

    return false;
}

/////////////////////////////////////////////////////////////////////////////
//
// CUtils::GetMethod
//
// Synopsis:
// The Method descriptor for a_pszMethod is returned via a_ppMethod if found
// NULL otherwise. Returns true if found false otherwise.
//
/////////////////////////////////////////////////////////////////////////////

bool CUtils::GetMethod(
    LPCWSTR         a_pszMethod,
    WMI_METHOD**    a_ppmethodList,
    WMI_METHOD**    a_ppmethod
    )
{
    WMI_METHOD**    t_ppmethod;

    if (a_pszMethod == NULL || a_ppmethod == NULL)
        throw WBEM_E_FAILED;

    for (t_ppmethod = a_ppmethodList; *t_ppmethod != NULL;t_ppmethod++)
        if (_wcsicmp(a_pszMethod,(*t_ppmethod)->pszMethodName) ==0) 
        {
            *a_ppmethod = *t_ppmethod;        
            return true;
        }

    return false;
}


/////////////////////////////////////////////////////////////////////////////
//
// CUtils::ExecMethodAsync
//
// Synopsis:
// 
/////////////////////////////////////////////////////////////////////////////

void CUtils::ExecMethodAsync(
    BSTR                a_strObjectPath,
    BSTR                a_strMethodName,
    IWbemContext*       a_pCtx, 
    IWbemClassObject*   a_pInParams,
    IWbemObjectSink*    a_pHandler,
    CWbemServices*      a_pNameSpace 
    )
{ 
    WMI_CLASS*          t_pWMIClass;
    CObjectPathParser   t_PathParser(e_ParserAcceptRelativeNamespace);
    ParsedObjectPath*   t_pParsedObject = NULL;
    _bstr_t             t_bstrMbPath;
    WMI_METHOD*         t_ppmethod;
    METADATA_HANDLE     t_hKey = NULL;

    try 
    {
        if (t_PathParser.Parse(a_strObjectPath, &t_pParsedObject) != CObjectPathParser::NoError)
            throw WBEM_E_INVALID_PARAMETER;

        if (t_pParsedObject == NULL)
            throw WBEM_E_FAILED;

        if (!GetClass(t_pParsedObject->m_pClass,&t_pWMIClass))
            throw WBEM_E_INVALID_CLASS;
    
        if (!GetMethod(a_strMethodName, t_pWMIClass->ppMethod, &t_ppmethod ))
            throw WBEM_E_NOT_SUPPORTED;

        GetMetabasePath(NULL,t_pParsedObject,t_pWMIClass,t_bstrMbPath);    
    
        switch(t_pWMIClass->eKeyType)
        {
        case IIsFtpService:
            if(a_pHandler == NULL)
                throw WBEM_E_INVALID_PARAMETER;

            ExecFtpServiceMethod(
                t_bstrMbPath, 
                t_pWMIClass->pszClassName,
                t_ppmethod->pszMethodName,
                a_pCtx,
                a_pInParams,
                a_pHandler,
                a_pNameSpace
                );
            break;

        case IIsWebService:
            if(a_pHandler == NULL)
                throw WBEM_E_INVALID_PARAMETER;

            ExecWebServiceMethod(
                t_bstrMbPath, 
                t_pWMIClass->pszClassName,
                t_ppmethod->pszMethodName,
                a_pCtx,
                a_pInParams,
                a_pHandler,
                a_pNameSpace
                );
            break;

        case IIsFtpServer:
        case IIsWebServer:
            {
                CMetabase t_metabase;
                t_hKey = t_metabase.OpenKey(t_bstrMbPath, true);    
                t_metabase.PutMethod(t_hKey, t_ppmethod->dwMDId);
                t_metabase.CloseKey(t_hKey);

                // check if the method call is successful.
                Sleep(500); // 0.5 sec
                t_hKey = t_metabase.OpenKey(t_bstrMbPath, false);    
                long lWin32Error = t_metabase.GetWin32Error(t_hKey);
                t_metabase.CloseKey(t_hKey);
                THROW_ON_ERROR(HRESULT_FROM_WIN32(lWin32Error));
            }
            break;

        case IIsWebVirtualDir:
        case IIsWebDirectory:
            if(a_pHandler == NULL)
                throw WBEM_E_INVALID_PARAMETER;

            ExecWebAppMethod(
                t_bstrMbPath, 
                t_pWMIClass->pszClassName,
                t_ppmethod->pszMethodName,
                a_pCtx,
                a_pInParams,
                a_pHandler,
                a_pNameSpace
                );
            break;

        case IIsComputer:
            if(a_pHandler == NULL)
                throw WBEM_E_INVALID_PARAMETER;

            ExecComputerMethod(
                t_bstrMbPath, 
                t_pWMIClass->pszClassName,
                t_ppmethod->pszMethodName,
                a_pCtx,
                a_pInParams,
                a_pHandler,
                a_pNameSpace
                );
            break;

        case IIsCertMapper:
            if(a_pHandler == NULL)
                throw WBEM_E_INVALID_PARAMETER;

            ExecCertMapperMethod(
                t_bstrMbPath, 
                t_pWMIClass->pszClassName,
                t_ppmethod->pszMethodName,
                a_pCtx,
                a_pInParams,
                a_pHandler,
                a_pNameSpace
                );
            break;
        
        default:
            break;
        }

        if (t_pParsedObject)
            t_PathParser.Free(t_pParsedObject);
    }
    catch (...)
    {
        if (t_pParsedObject)
            t_PathParser.Free(t_pParsedObject);
 
        throw;
    };
}

/////////////////////////////////////////////////////////////////////////////
//
// CUtils::DeleteObjectAsync
//
// Synopsis:
// 
/////////////////////////////////////////////////////////////////////////////

void CUtils::DeleteObjectAsync(
    CWbemServices*       m_pNamespace, 
    ParsedObjectPath*    a_pParsedObject,
    CMetabase&           a_metabase
    )
{ 
    HRESULT              t_hr        = ERROR_SUCCESS;
    _bstr_t              t_bstrMbPath;
    WMI_CLASS*           t_pWMIClass;
    METADATA_HANDLE      t_hKey = NULL;

    if (m_pNamespace==NULL || a_pParsedObject==NULL)
        throw WBEM_E_INVALID_PARAMETER;

    if (!GetClass(a_pParsedObject->m_pClass,&t_pWMIClass))
        throw WBEM_E_INVALID_CLASS;

    // get the mata path of object
    GetMetabasePath(NULL,a_pParsedObject,t_pWMIClass,t_bstrMbPath);
    // check if the path is not existed
    if(!a_metabase.CheckKey(t_bstrMbPath))
        throw WBEM_E_INVALID_PARAMETER;

    try 
    {
        // if AdminACL
        if( t_pWMIClass->eKeyType == TYPE_AdminACL )
            throw WBEM_E_NOT_SUPPORTED;
        else if(t_pWMIClass->eKeyType == TYPE_IPSecurity )
        {                
            t_hKey = a_metabase.OpenKey(t_bstrMbPath, true);
            a_metabase.DeleteData(t_hKey, MD_IP_SEC, BINARY_METADATA);
            a_metabase.CloseKey(t_hKey);
            return;
        }
        else if(t_pWMIClass->eKeyType == TYPE_AdminACE)
        {
            CAdminACL objACL;
            t_hr = objACL.OpenSD(t_bstrMbPath);
            if(SUCCEEDED(t_hr))
                t_hr = objACL.DeleteObjectAsync(a_pParsedObject);
            THROW_ON_ERROR(t_hr);
            return;
        }
        
        t_hKey = a_metabase.OpenKey(METADATA_MASTER_ROOT_HANDLE, true); 
        t_hr = a_metabase.DeleteKey(t_hKey, t_bstrMbPath);
        THROW_ON_ERROR(t_hr);
   
        a_metabase.CloseKey(t_hKey);
    }
    catch (...) 
    {
        a_metabase.CloseKey(t_hKey);
        throw;
    };    
}

/////////////////////////////////////////////////////////////////////////////
//
// CUtils::GetObjectAsync
//
// Synopsis:
// 
/////////////////////////////////////////////////////////////////////////////

HRESULT CUtils::GetObjectAsync(
    CWbemServices*       m_pNamespace, 
    IWbemClassObject**   a_ppObj,
    ParsedObjectPath*    a_pParsedObject,
    CMetabase&           a_metabase
    )
{ 
    HRESULT              t_hr        = WBEM_E_FAILED;
    IWbemClassObject*    t_pClass    = NULL;
    METABASE_PROPERTY**  t_ppmbp;
    _bstr_t              t_bstrMbPath;
    WMI_CLASS*           t_pWMIClass;
    METADATA_HANDLE      t_hKey = NULL;

    if (m_pNamespace==NULL || a_ppObj==NULL || a_pParsedObject==NULL)
        return WBEM_E_INVALID_PARAMETER;

    try 
    {
        if (!GetClass(a_pParsedObject->m_pClass,&t_pWMIClass))
            return WBEM_E_INVALID_CLASS;

        t_hr = m_pNamespace->GetObject(
            a_pParsedObject->m_pClass, 
            0, 
            NULL, 
            &t_pClass, 
            NULL
            );
        THROW_ON_ERROR(t_hr);

        t_hr = t_pClass->SpawnInstance(0, a_ppObj);
        t_pClass->Release();
        THROW_ON_ERROR(t_hr);

        GetMetabasePath(*a_ppObj,a_pParsedObject,t_pWMIClass,t_bstrMbPath);

        // if AdminACL 
        if( t_pWMIClass->eKeyType == TYPE_AdminACL ||
            t_pWMIClass->eKeyType == TYPE_AdminACE
            )
        {
            CAdminACL objACL;
            t_hr = objACL.OpenSD(t_bstrMbPath);
            if(SUCCEEDED(t_hr))
                t_hr  = objACL.GetObjectAsync(*a_ppObj, a_pParsedObject, t_pWMIClass);
            return t_hr;
        }
        else if( t_pWMIClass->eKeyType == TYPE_IPSecurity )  // IPSecurity 
        {
            CIPSecurity IPSecurity;
            t_hr = IPSecurity.OpenSD(t_bstrMbPath);
            if(SUCCEEDED(t_hr))
                t_hr  = IPSecurity.GetObjectAsync(*a_ppObj);
            return t_hr;
        }

        t_hKey = a_metabase.OpenKey(t_bstrMbPath, false);    

        _variant_t t_vt;

        for (t_ppmbp=t_pWMIClass->ppmbp;*t_ppmbp; t_ppmbp++) 
        {            
            switch ((*t_ppmbp)->dwMDDataType) 
            {
                case DWORD_METADATA:
                    a_metabase.GetDword(t_hKey, *t_ppmbp, t_vt);
                    break;

                case EXPANDSZ_METADATA:
                case STRING_METADATA:
                    a_metabase.GetString(t_hKey, *t_ppmbp, t_vt);
                    break;

                case MULTISZ_METADATA:
                    a_metabase.GetMultiSz(t_hKey, *t_ppmbp, t_vt);
                    break;
                default:
                    break;
            }

            _bstr_t t_bstr = (*t_ppmbp)->pszPropName;
            t_hr = (*a_ppObj)->Put(t_bstr, 0, &t_vt, 0);
            t_vt.Clear();
            if(FAILED(t_hr))
                break;
        }  
        
        a_metabase.CloseKey(t_hKey);
    }
    catch (...) 
    {
        a_metabase.CloseKey(t_hKey);

        if (*a_ppObj) 
        {
            (*a_ppObj)->Release();
            *a_ppObj = NULL;
        }
    };    

    return t_hr;
}

/////////////////////////////////////////////////////////////////////////////
//
// CUtils::PutObjectAsync
//
// Synopsis:
// 
//
/////////////////////////////////////////////////////////////////////////////

void CUtils::PutObjectAsync(
    IWbemClassObject*    a_pObj,
    IWbemClassObject*    a_pObjOld,
    ParsedObjectPath*    a_pParsedObject,
    long                 a_lFlags
    )
{ 
    HRESULT              t_hr        = ERROR_SUCCESS;
    METABASE_PROPERTY**  t_ppmbp;
    _bstr_t              t_bstrMbPath;
    WMI_CLASS*           t_pWMIClass;
    METADATA_HANDLE      t_hKey = NULL;
    bool                 t_boolOverrideParent = false;

    if (a_pObj==NULL || a_pParsedObject==NULL)
        throw WBEM_E_INVALID_PARAMETER;

    if (!GetClass(a_pParsedObject->m_pClass,&t_pWMIClass))
        throw WBEM_E_INVALID_CLASS;

    GetMetabasePath(NULL,a_pParsedObject,t_pWMIClass,t_bstrMbPath);

    // if AdminACL
    if( t_pWMIClass->eKeyType == TYPE_AdminACL ||
        t_pWMIClass->eKeyType == TYPE_AdminACE
        )
    {
        CAdminACL objACL;
        t_hr = objACL.OpenSD(t_bstrMbPath);
        if( SUCCEEDED(t_hr) )        
            t_hr = objACL.PutObjectAsync(a_pObj, a_pParsedObject, t_pWMIClass);
        THROW_ON_ERROR(t_hr);
        return;
    }
    if( t_pWMIClass->eKeyType == TYPE_IPSecurity ) // IPSecurity
    {
        CIPSecurity objIPSec;
        t_hr = objIPSec.OpenSD(t_bstrMbPath);
        if( SUCCEEDED(t_hr) )        
            t_hr = objIPSec.PutObjectAsync(a_pObj);
        THROW_ON_ERROR(t_hr);
        return;
    }

    // Get Instance Qualifiers
    IWbemQualifierSet* t_pQualSet = NULL;
    BSTR               t_bstrQualName = NULL;
    VARIANT            t_varQualValue;

    t_hr = a_pObj->GetQualifierSet(&t_pQualSet);
    if(SUCCEEDED(t_hr)) {
        t_hr = t_pQualSet->BeginEnumeration(0);
    }
    THROW_ON_ERROR(t_hr);

    // Looking for OverrideParent qualifier
    while(!t_boolOverrideParent)
    {
        t_hr = t_pQualSet->Next(0, &t_bstrQualName, &t_varQualValue, NULL);
        if(t_hr == WBEM_S_NO_MORE_DATA || !SUCCEEDED(t_hr)) {
            // No more qualifiers.
            // We don't need to worry about cleanup - nothing was allocated.
            break;
        }

        if(lstrcmpW(t_bstrQualName, WSZ_OVERRIDE_PARENT) == 0) {
            if(t_varQualValue.vt == VT_BOOL) {
                if(t_varQualValue.boolVal) {
                    t_boolOverrideParent = true;
                }
            }
        }
        SysFreeString(t_bstrQualName);        
        VariantClear(&t_varQualValue);
    }

    t_pQualSet->Release();
    if(!SUCCEEDED(t_hr))
        THROW_ON_ERROR(t_hr);
    t_hr = ERROR_SUCCESS;

    // open key
    CMetabase t_metabase;
    t_hKey = t_metabase.CreateKey(t_bstrMbPath);

    try
    {
        _variant_t t_vt;
        _variant_t t_vtOld;
        _bstr_t t_bstr;

        for (t_ppmbp=t_pWMIClass->ppmbp;*t_ppmbp && t_hr==ERROR_SUCCESS; t_ppmbp++) 
        {
            t_bstr = (*t_ppmbp)->pszPropName;

            t_hr = a_pObj->Get(t_bstr, 0, &t_vt, NULL, NULL);
            THROW_E_ON_ERROR(t_hr,*t_ppmbp);

            if(a_pObjOld != NULL) {
                t_hr = a_pObjOld->Get(t_bstr, 0, &t_vtOld, NULL, NULL);
                THROW_E_ON_ERROR(t_hr,*t_ppmbp);
            }
        
            if (t_vt.vt == VT_NULL) 
            {
                // Only delete non-flag properties.
                if ((*t_ppmbp)->dwMDMask == 0)
                {
                    t_metabase.DeleteData(t_hKey, *t_ppmbp);
                }
                continue;
            }

            switch ((*t_ppmbp)->dwMDDataType) 
            {
                case DWORD_METADATA:
                    t_metabase.PutDword(t_hKey, *t_ppmbp,t_vt,&t_vtOld,t_boolOverrideParent);
                    break;
    
                case EXPANDSZ_METADATA:
                case STRING_METADATA:                    
                    t_metabase.PutString(t_hKey, *t_ppmbp,t_vt,&t_vtOld,t_boolOverrideParent);
                    break;

                case MULTISZ_METADATA:
                    t_metabase.PutMultiSz(t_hKey, *t_ppmbp,t_vt,&t_vtOld,t_boolOverrideParent);
                    break;

                default:
                    break;
            }
            t_vt.Clear();
            t_vtOld.Clear();
        }
    
        WCHAR szBuffer[MAX_KEY_TYPE_SIZE];
        if(TypeEnumToString(szBuffer, t_pWMIClass->eKeyType))
        {
            t_vt = szBuffer;
            t_metabase.PutString(t_hKey, &METABASE_PROPERTY_DATA::s_KeyType, t_vt, NULL);
        }

        t_metabase.CloseKey(t_hKey);
    }
    catch(...)
    {
        t_metabase.CloseKey(t_hKey);
        throw;
    }
}


/////////////////////////////////////////////////////////////////////////////
//
// CUtils::EnumObjectAsync
//
// Synopsis:
// 
//
/////////////////////////////////////////////////////////////////////////////

void CUtils::EnumObjectAsync(
    BSTR                    a_ClassName, 
    CWbemServices*          m_pNamespace, 
    IWbemObjectSink FAR*    a_pHandler
    )
{
    WMI_CLASS*          t_pClass;
    WMI_ASSOCIATION*    t_pAssociation = NULL;
    ParsedObjectPath    t_ParsedObject;        //deconstructer frees memory
    CObjectPathParser   t_PathParser(e_ParserAcceptRelativeNamespace);

    if (GetAssociation(a_ClassName,&t_pAssociation))
    {
        CEnum EnumAssociation;
        EnumAssociation.Init(
            a_pHandler,
            m_pNamespace,
            &t_ParsedObject,
            t_pAssociation->pcRight->pszMetabaseKey,
            t_pAssociation
            );
        EnumAssociation.Recurse(
            NULL,
            IIsComputer,        
            NULL,
            t_pAssociation->pcRight->pszKeyName,
            t_pAssociation->pcRight->eKeyType
            );
    } 
    else if (GetClass(a_ClassName,&t_pClass))
    {
        if (!t_ParsedObject.SetClassName(t_pClass->pszClassName))
            throw WBEM_E_FAILED;

        CEnum EnumObject;
        EnumObject.Init(
            a_pHandler,
            m_pNamespace,
            &t_ParsedObject,
            t_pClass->pszMetabaseKey,
            NULL
            );
        EnumObject.Recurse(
            NULL,
            NO_TYPE,
            NULL,
            t_pClass->pszKeyName, 
            t_pClass->eKeyType
            );
    }
    else
        throw WBEM_E_INVALID_CLASS;
}


bool CUtils::TypeStringToEnum(
    enum_KEY_TYPE&  a_eType, 
    LPCWSTR         a_szTypeString
    )
{
    if(!lstrcmpiW(a_szTypeString, L"IIsWebVirtualDir"))
        a_eType = IIsWebVirtualDir;
    else if(!lstrcmpiW(a_szTypeString, L"IIsWebDirectory"))
        a_eType = IIsWebDirectory;
    else if(!lstrcmpiW(a_szTypeString, L"IIsWebFile"))
        a_eType = IIsWebFile;
    else if(!lstrcmpiW(a_szTypeString, L"IIsWebServer"))
        a_eType = IIsWebServer;
    else if(!lstrcmpiW(a_szTypeString, L"IIsWebService"))
        a_eType = IIsWebService;
    else if(!lstrcmpiW(a_szTypeString, L"IIsFtpVirtualDir"))
        a_eType = IIsFtpVirtualDir;
    else if(!lstrcmpiW(a_szTypeString, L"IIsFtpServer"))
        a_eType = IIsFtpServer;
    else if(!lstrcmpiW(a_szTypeString, L"IIsFtpService"))
        a_eType = IIsFtpService;
    else if(!lstrcmpiW(a_szTypeString, L"IIsFilters"))
        a_eType = IIsFilters;
    else if(!lstrcmpiW(a_szTypeString, L"IIsFilter"))
        a_eType = IIsFilter;
    else if(!lstrcmpiW(a_szTypeString, L"IIsWebInfo"))
        a_eType = IIsWebInfo;
    else if(!lstrcmpiW(a_szTypeString, L"IIsFtpInfo"))
        a_eType = IIsFtpInfo;
    else if(!lstrcmpiW(a_szTypeString, L"IIsCertMapper"))
        a_eType = IIsCertMapper;
    else if(!lstrcmpiW(a_szTypeString, L"IIsComputer"))
        a_eType = IIsComputer;
    else if(!lstrcmpiW(a_szTypeString, L"IIsMimeMap"))
        a_eType = IIsMimeMap;
    else if(!lstrcmpiW(a_szTypeString, L"IIsLogModules"))
        a_eType = IIsLogModules;
    else if(!lstrcmpiW(a_szTypeString, L"IIsLogModule"))
        a_eType = IIsLogModule;
    else if(!lstrcmpiW(a_szTypeString, L"IIsCompressionSchemes"))
        a_eType = IIsCompressionSchemes;
    else if(!lstrcmpiW(a_szTypeString, L"IIsCompressionScheme"))
        a_eType = IIsCompressionScheme;
    else
        return false;

    return true;
}

bool CUtils::TypeEnumToString(
    LPWSTR          a_szTypeString,
    enum_KEY_TYPE   a_eType
    )
{
    bool bRet = true;

    switch(a_eType)
    {
    case IIsComputer:
        lstrcpyW(a_szTypeString, L"IIsComputer");
        break;

    case IIsMimeMap:
        lstrcpyW(a_szTypeString, L"IIsMimeMap");
        break;

    case IIsLogModules:
        lstrcpyW(a_szTypeString, L"IIsLogModules");
        break;
    
    case IIsLogModule:
        lstrcpyW(a_szTypeString, L"IIsLogModule");
        break;

    case IIsFtpService:
        lstrcpyW(a_szTypeString, L"IIsFtpService");
        break;
    case IIsFtpInfo:
        lstrcpyW(a_szTypeString, L"IIsFtpInfo");
        break;

    case IIsFtpServer:
        lstrcpyW(a_szTypeString, L"IIsFtpServer");
        break;

    case IIsFtpVirtualDir:
        lstrcpyW(a_szTypeString, L"IIsFtpVirtualDir");
        break;

    case IIsWebService:
        lstrcpyW(a_szTypeString, L"IIsWebService");
        break;

    case IIsWebInfo:
        lstrcpyW(a_szTypeString, L"IIsWebInfo");
        break;

    case IIsFilters:
        lstrcpyW(a_szTypeString, L"IIsFilters");
        break;

    case IIsFilter:
        lstrcpyW(a_szTypeString, L"IIsFilter");
        break;

    case IIsWebServer:
        lstrcpyW(a_szTypeString, L"IIsWebServer");
        break;

    case IIsCertMapper:
        lstrcpyW(a_szTypeString, L"IIsCertMapper");
        break;

    case IIsWebVirtualDir:
        lstrcpyW(a_szTypeString, L"IIsWebVirtualDir");
        break;

    case IIsWebDirectory:
        lstrcpyW(a_szTypeString, L"IIsWebDirectory");
        break;

    case IIsWebFile:
        lstrcpyW(a_szTypeString, L"IIsWebFile");
        break;

    case IIsCompressionSchemes:
        lstrcpyW(a_szTypeString, L"IIsCompressionSchemes");
        break;
    
    case IIsCompressionScheme:
        lstrcpyW(a_szTypeString, L"IIsCompressionScheme");
        break;

    default:
        bRet = false;
        break;
    }

    return bRet;
}

void CUtils::ExecWebAppMethod(
    LPCWSTR             a_szMbPath,
    LPCWSTR             a_szClassName,
    LPCWSTR             a_szMethodName,
    IWbemContext*       a_pCtx, 
    IWbemClassObject*   a_pInParams,
    IWbemObjectSink*    a_pHandler,
    CWbemServices*      a_pNameSpace 
    )
{
    HRESULT hr;
    _variant_t t_vt;
    CWebAppMethod obj;

    if(!lstrcmpiW(a_szMethodName, L"AppCreate"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;
        a_pInParams->Get(L"InProcFlag", 0, &t_vt, NULL, NULL);   
        hr = obj.AppCreate(a_szMbPath, t_vt);
    }
    else if(!lstrcmpiW(a_szMethodName, L"AppCreate2"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;
        a_pInParams->Get(L"AppMode", 0, &t_vt, NULL, NULL);   
        hr = obj.AppCreate2(a_szMbPath, t_vt);
    }
    else if(!lstrcmpiW(a_szMethodName, L"AppDelete"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;
        a_pInParams->Get(L"Recursive", 0, &t_vt, NULL, NULL);   
        hr = obj.AppDelete(a_szMbPath, t_vt);
    }
    else if(!lstrcmpiW(a_szMethodName, L"AppDisable"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;
        a_pInParams->Get(L"Recursive", 0, &t_vt, NULL, NULL);   
        hr = obj.AppDisable(a_szMbPath, t_vt);
    }
    else if(!lstrcmpiW(a_szMethodName, L"AppEnable"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;
        a_pInParams->Get(L"Recursive", 0, &t_vt, NULL, NULL);   
        hr = obj.AppEnable(a_szMbPath, t_vt);
    }
    else if(!lstrcmpiW(a_szMethodName, L"AppUnLoad"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;
        a_pInParams->Get(L"Recursive", 0, &t_vt, NULL, NULL);   
        hr = obj.AppUnLoad(a_szMbPath, t_vt);
    }
    else if(!lstrcmpiW(a_szMethodName, L"AppGetStatus"))
    {
        // call method - AppGetStatus
        DWORD dwStatus;
        hr = obj.AppGetStatus(a_szMbPath, &dwStatus);
        THROW_ON_ERROR(hr);

        IWbemClassObject* pClass = NULL;
        IWbemClassObject* pMethodClass = NULL;    
        IWbemClassObject* pOutParams = NULL;

        hr = a_pNameSpace->GetObject(_bstr_t(a_szClassName), 0, a_pCtx, &pClass, NULL);
        THROW_ON_ERROR(hr); 

        // This method returns values, and so create an instance of the
        // output argument class.
        hr = pClass->GetMethod(a_szMethodName, 0, NULL, &pMethodClass);
        pClass->Release();
        THROW_ON_ERROR(hr); 
        hr = pMethodClass->SpawnInstance(0, &pOutParams);
        pMethodClass->Release();
        THROW_ON_ERROR(hr); 

        // put it into the output object
        t_vt.vt = VT_I4;
        t_vt.lVal = dwStatus;
        hr = pOutParams->Put(L"ReturnValue", 0, &t_vt, 0);      
        THROW_ON_ERROR(hr); 

        // Send the output object back to the client via the sink. Then 
        // release the pointers and free the strings.
        hr = a_pHandler->Indicate(1, &pOutParams); 
        pOutParams->Release();
    }
    else if(!lstrcmpiW(a_szMethodName, L"AspAppRestart"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;
        hr = obj.AspAppRestart(a_szMbPath);
    }
    else
        hr = WBEM_E_NOT_SUPPORTED;

    THROW_ON_ERROR(hr);
}

void CUtils::ExecFtpServiceMethod(
    LPCWSTR             a_szMbPath,
    LPCWSTR             a_szClassName,
    LPCWSTR             a_szMethodName,
    IWbemContext*       a_pCtx, 
    IWbemClassObject*   a_pInParams,
    IWbemObjectSink*    a_pHandler,
    CWbemServices*      a_pNameSpace 
    )
{
    HRESULT hr = ERROR_SUCCESS;
    _variant_t t_vt1, t_vt2, t_vt3, t_vt4;
    CMetabase t_metabase;
    METADATA_HANDLE t_hKey;

    if(!lstrcmpiW(a_szMethodName, L"CreateNewServer"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;

        // synchronize
        s_synObject.Enter();

        try
        {
            // get in params
            a_pInParams->Get(L"ServerComment", 0, &t_vt2, NULL, NULL);  
            a_pInParams->Get(L"ServerBindings", 0, &t_vt3, NULL, NULL);  
            a_pInParams->Get(L"PathOfRootVitualDir", 0, &t_vt4, NULL, NULL);  

            _bstr_t t_bstrServicePath = a_szMbPath;
            _bstr_t t_bstrServerPath = t_bstrServicePath;

            // check the optional [in] parameter "ServerNumber"
            a_pInParams->Get(L"ServerNumber", 0, &t_vt1, NULL, NULL);  
            if( t_vt1.vt == VT_BSTR )
            {
                t_bstrServerPath += L"/";
                t_bstrServerPath += t_vt1.bstrVal;

                // check if the server path is not existed
                if(t_metabase.CheckKey(t_bstrServerPath))
                    throw WBEM_E_INVALID_PARAMETER;
            }
            else // if no server is specified
            {
                // find an unique server name(number) and create it
                FindUniqueServerName(t_bstrServicePath, t_bstrServerPath);
            }

            // create new server       
            _bstr_t t_bstrKeyPath = t_bstrServerPath;
            t_hKey = t_metabase.CreateKey(t_bstrKeyPath);
            t_vt1 = L"IIsFtpServer";
            t_metabase.PutString(t_hKey, &METABASE_PROPERTY_DATA::s_KeyType, t_vt1, NULL);
            t_metabase.PutString(t_hKey, &METABASE_PROPERTY_DATA::s_ServerComment, t_vt2, NULL);
            t_metabase.PutMultiSz(t_hKey, &METABASE_PROPERTY_DATA::s_ServerBindings, t_vt3, NULL);
            t_metabase.CloseKey(t_hKey); 

            // create root of virtualdir
            t_bstrKeyPath += L"/";
            t_bstrKeyPath += L"ROOT";
            t_hKey = t_metabase.CreateKey(t_bstrKeyPath);
            t_vt1 = L"IIsFtpVirtualDir";
            t_metabase.PutString(t_hKey, &METABASE_PROPERTY_DATA::s_KeyType, t_vt1, NULL);
            t_metabase.PutString(t_hKey, &METABASE_PROPERTY_DATA::s_Path, t_vt4, NULL); 
            t_metabase.CloseKey(t_hKey); 
   
            // out server name
            IWbemClassObject* pClass = NULL;
            IWbemClassObject* pMethodClass = NULL;    
            IWbemClassObject* pOutParams = NULL;
            hr = a_pNameSpace->GetObject(_bstr_t(a_szClassName), 0, a_pCtx, &pClass, NULL);
            THROW_ON_ERROR(hr); 

            // This method returns values, and so create an instance of the
            // output argument class.
            hr = pClass->GetMethod(a_szMethodName, 0, NULL, &pMethodClass);
            pClass->Release();
            THROW_ON_ERROR(hr); 
            hr = pMethodClass->SpawnInstance(0, &pOutParams);
            pMethodClass->Release();
            THROW_ON_ERROR(hr); 

            // find root key of server and make server name
            WCHAR szServerName[METADATA_MAX_NAME_LEN];
            lstrcpy(szServerName, t_bstrServerPath);
            WMI_CLASS* t_pWMIClass = NULL;
            _bstr_t t_bstrRootKey = L"/LM";
            _bstr_t t_bstrServerName = L"IIs_FtpServer.Name = \"";
            if(GetClass(L"IIs_FtpServer",&t_pWMIClass))
            {
                t_bstrRootKey = t_pWMIClass->pszMetabaseKey;
                t_bstrServerName = t_pWMIClass->pszClassName;
                t_bstrServerName += L".";
                t_bstrServerName += t_pWMIClass->pszKeyName;
                t_bstrServerName += L" = \"";
            }        
            t_bstrServerName += szServerName + t_bstrRootKey.length() + 1;  // remove root key from server path
            t_bstrServerName += L"\"";

            // put it into the output object
            // out "Server name"
            t_vt1 = t_bstrServerName;
            hr = pOutParams->Put(L"ReturnValue", 0, &t_vt1, 0);      
            THROW_ON_ERROR(hr); 

            // Send the output object back to the client via the sink. Then 
            // release the pointers and free the strings.
            hr = a_pHandler->Indicate(1, &pOutParams); 
            pOutParams->Release();
        }
        catch(...)
        {
            hr = WBEM_E_FAILED;
        }

        // synchronize: release
        s_synObject.Leave();
    }
    else
        hr = WBEM_E_NOT_SUPPORTED;

    THROW_ON_ERROR(hr); 
}


void CUtils::ExecWebServiceMethod(
    LPCWSTR             a_szMbPath,
    LPCWSTR             a_szClassName,
    LPCWSTR             a_szMethodName,
    IWbemContext*       a_pCtx, 
    IWbemClassObject*   a_pInParams,
    IWbemObjectSink*    a_pHandler,
    CWbemServices*      a_pNameSpace 
    )
{
    HRESULT hr = ERROR_SUCCESS;
    _variant_t t_vt1, t_vt2, t_vt3, t_vt4;
    CMetabase t_metabase;
    METADATA_HANDLE t_hKey;

    if(!lstrcmpiW(a_szMethodName, L"CreateNewServer"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;

        // synchronize
        s_synObject.Enter();

        try
        {
            // get in params
            a_pInParams->Get(L"ServerComment", 0, &t_vt2, NULL, NULL);  
            a_pInParams->Get(L"ServerBindings", 0, &t_vt3, NULL, NULL);  
            a_pInParams->Get(L"PathOfRootVitualDir", 0, &t_vt4, NULL, NULL);  
 
            _bstr_t t_bstrServicePath = a_szMbPath;
            _bstr_t t_bstrServerPath = t_bstrServicePath;

            // check the optional [in] parameter "ServerNumber"
            a_pInParams->Get(L"ServerNumber", 0, &t_vt1, NULL, NULL);  
            if( t_vt1.vt == VT_BSTR )
            {
                t_bstrServerPath += L"/";
                t_bstrServerPath += t_vt1.bstrVal;

                // check if the server path is not existed
                if(t_metabase.CheckKey(t_bstrServerPath))
                    throw WBEM_E_INVALID_PARAMETER;
            }
            else // if no server is specified
            {
                // find an unique server name(number) and create it
                FindUniqueServerName(t_bstrServicePath, t_bstrServerPath);
            }

            // create new server       
            _bstr_t t_bstrKeyPath = t_bstrServerPath;
            t_hKey = t_metabase.CreateKey(t_bstrKeyPath);
            t_vt1 = L"IIsWebServer";
            t_metabase.PutString(t_hKey, &METABASE_PROPERTY_DATA::s_KeyType, t_vt1, NULL);
            t_metabase.PutString(t_hKey, &METABASE_PROPERTY_DATA::s_ServerComment, t_vt2, NULL);
            t_metabase.PutMultiSz(t_hKey, &METABASE_PROPERTY_DATA::s_ServerBindings, t_vt3, NULL);
            t_metabase.CloseKey(t_hKey); 

            // create root of virtualdir
            t_bstrKeyPath += L"/";
            t_bstrKeyPath += L"ROOT";
            t_hKey = t_metabase.CreateKey(t_bstrKeyPath);
            t_vt1 = L"IIsWebVirtualDir";
            t_metabase.PutString(t_hKey, &METABASE_PROPERTY_DATA::s_KeyType, t_vt1, NULL);
            t_metabase.PutString(t_hKey, &METABASE_PROPERTY_DATA::s_Path, t_vt4, NULL); 
            t_vt1 = t_bstrKeyPath;
            t_metabase.PutString(t_hKey, &METABASE_PROPERTY_DATA::s_AppRoot, t_vt1, NULL); 
            t_metabase.CloseKey(t_hKey); 

            // out server name
            IWbemClassObject* pClass = NULL;
            IWbemClassObject* pMethodClass = NULL;    
            IWbemClassObject* pOutParams = NULL;
            hr = a_pNameSpace->GetObject(_bstr_t(a_szClassName), 0, a_pCtx, &pClass, NULL);
            THROW_ON_ERROR(hr); 

            // This method returns values, and so create an instance of the
            // output argument class.
            hr = pClass->GetMethod(a_szMethodName, 0, NULL, &pMethodClass);
            pClass->Release();
            THROW_ON_ERROR(hr); 
            hr = pMethodClass->SpawnInstance(0, &pOutParams);
            pMethodClass->Release();
            THROW_ON_ERROR(hr); 

            // find root key of server and make server name
            WCHAR szServerName[METADATA_MAX_NAME_LEN];
            lstrcpy(szServerName, t_bstrServerPath);
            WMI_CLASS* t_pWMIClass = NULL;
            _bstr_t t_bstrRootKey = L"/LM";
            _bstr_t t_bstrServerName = L"IIs_WebServer.Name = \"";
            if(GetClass(L"IIs_WebServer",&t_pWMIClass))
            {
                t_bstrRootKey = t_pWMIClass->pszMetabaseKey;
                t_bstrServerName = t_pWMIClass->pszClassName;
                t_bstrServerName += L".";
                t_bstrServerName += t_pWMIClass->pszKeyName;
                t_bstrServerName += L" = \"";
            }        
            t_bstrServerName += szServerName + t_bstrRootKey.length() + 1;  // remove root key from server path
            t_bstrServerName += L"\"";

            // put it into the output object
            // out "Server name"
            t_vt1 = t_bstrServerName;
            hr = pOutParams->Put(L"ReturnValue", 0, &t_vt1, 0);      
            THROW_ON_ERROR(hr); 

            // Send the output object back to the client via the sink. Then 
            // release the pointers and free the strings.
            hr = a_pHandler->Indicate(1, &pOutParams); 
            pOutParams->Release();
        }
        catch(...)
        {
            hr = WBEM_E_FAILED;
        }

        // synchronize: release
        s_synObject.Leave();
    }
    else
        hr = WBEM_E_NOT_SUPPORTED;

    THROW_ON_ERROR(hr); 
}

void CUtils::ExecComputerMethod(
    LPCWSTR             a_szMbPath,
    LPCWSTR             a_szClassName,
    LPCWSTR             a_szMethodName,
    IWbemContext*       a_pCtx, 
    IWbemClassObject*   a_pInParams,
    IWbemObjectSink*    a_pHandler,
    CWbemServices*      a_pNameSpace 
    )
{
    HRESULT hr;
    _variant_t t_vt1, t_vt2, t_vt3, t_vt4;
    CMetabase obj;

    if(!lstrcmpiW(a_szMethodName, L"EnumBackups"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;

        // get in params
        a_pInParams->Get(L"BackupLocation", 0, &t_vt1, NULL, NULL);   
        a_pInParams->Get(L"IndexIn", 0, &t_vt2, NULL, NULL);  
       
        // make in/out params
        WCHAR BackupLocation[MD_BACKUP_MAX_LEN];
        lstrcpyW(BackupLocation, _bstr_t(t_vt1));

        // define out params
        DWORD BackupVersionOut; 
        FILETIME BackupDateTimeOut;

        // call method - EnumBackups.
        hr = obj.EnumBackups(BackupLocation, &BackupVersionOut, &BackupDateTimeOut, t_vt2.lVal);
        THROW_ON_ERROR(hr);

        IWbemClassObject* pClass = NULL;
        IWbemClassObject* pMethodClass = NULL;    
        IWbemClassObject* pOutParams = NULL;

        hr = a_pNameSpace->GetObject(_bstr_t(a_szClassName), 0, a_pCtx, &pClass, NULL);
        THROW_ON_ERROR(hr); 

        // This method returns values, and so create an instance of the
        // output argument class.
        hr = pClass->GetMethod(a_szMethodName, 0, NULL, &pMethodClass);
        pClass->Release();
        THROW_ON_ERROR(hr); 
        hr = pMethodClass->SpawnInstance(0, &pOutParams);
        pMethodClass->Release();
        THROW_ON_ERROR(hr); 

        // put it into the output object
        // out BackupLocation
        t_vt1 = BackupLocation;
        hr = pOutParams->Put(L"BackupLocation", 0, &t_vt1, 0);      
        THROW_ON_ERROR(hr); 
        // out BackupVersionOut        
        t_vt1.vt = VT_I4;
        t_vt1.lVal = BackupVersionOut;
        hr = pOutParams->Put(L"BackupVersionOut", 0, &t_vt1, 0);      
        THROW_ON_ERROR(hr); 
        // out BackupDateTimeOut (UTC time)
        SYSTEMTIME  systime;
        FileTimeToSystemTime(&BackupDateTimeOut, &systime); 
        WCHAR datetime[30];
        swprintf(
            datetime,
            L"%04d%02d%02d%02d%02d%02d.%06d+000",
            systime.wYear,
            systime.wMonth,
            systime.wDay,
            systime.wHour,
            systime.wMinute,
            systime.wSecond,
            systime.wMilliseconds
            );

        t_vt1 = datetime;
        hr = pOutParams->Put(L"BackupDateTimeOut", 0, &t_vt1, 0);      
        THROW_ON_ERROR(hr); 

        // Send the output object back to the client via the sink. Then 
        // release the pointers and free the strings.
        hr = a_pHandler->Indicate(1, &pOutParams); 
        pOutParams->Release();
    }
    else if(!lstrcmpiW(a_szMethodName, L"Backup"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;
        a_pInParams->Get(L"BackupLocation", 0, &t_vt1, NULL, NULL);   
        a_pInParams->Get(L"BackupVersion", 0, &t_vt2, NULL, NULL);   
        a_pInParams->Get(L"BackupFlags", 0, &t_vt3, NULL, NULL);   
        hr = obj.Backup(_bstr_t(t_vt1), t_vt2.lVal, t_vt3.lVal);
    }
    else if(!lstrcmpiW(a_szMethodName, L"DeleteBackup"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;
        a_pInParams->Get(L"BackupLocation", 0, &t_vt1, NULL, NULL);   
        a_pInParams->Get(L"BackupVersion", 0, &t_vt2, NULL, NULL);   
        hr = obj.DeleteBackup(_bstr_t(t_vt1), t_vt2.lVal);
    }
    else if(!lstrcmpiW(a_szMethodName, L"Restore"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;
        a_pInParams->Get(L"BackupLocation", 0, &t_vt1, NULL, NULL);   
        a_pInParams->Get(L"BackupVersion", 0, &t_vt2, NULL, NULL);   
        a_pInParams->Get(L"BackupFlags", 0, &t_vt3, NULL, NULL);   
        hr = obj.Restore(_bstr_t(t_vt1), t_vt2.lVal, t_vt3.lVal);
    }
    else
        hr = WBEM_E_NOT_SUPPORTED;

    THROW_ON_ERROR(hr);
}


void CUtils::ExecCertMapperMethod(
    LPCWSTR             a_szMbPath,
    LPCWSTR             a_szClassName,
    LPCWSTR             a_szMethodName,
    IWbemContext*       a_pCtx, 
    IWbemClassObject*   a_pInParams,
    IWbemObjectSink*    a_pHandler,
    CWbemServices*      a_pNameSpace 
    )
{
    HRESULT hr;
    _variant_t t_vt1, t_vt2, t_vt3=L"1", t_vt4=L"1", t_vt5=L"1", t_vt6=L"1", t_vt7=L"1";
    CCertMapperMethod obj(a_szMbPath);

    if(!lstrcmpiW(a_szMethodName, L"CreateMapping"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;
        a_pInParams->Get(L"vCert", 0, &t_vt1, NULL, NULL);   
        a_pInParams->Get(L"NtAcct", 0, &t_vt2, NULL, NULL);  
        a_pInParams->Get(L"NtPwd", 0, &t_vt3, NULL, NULL);  
        a_pInParams->Get(L"strName", 0, &t_vt4, NULL, NULL);  
        a_pInParams->Get(L"IEnabled", 0, &t_vt5, NULL, NULL);  
      
        // call method - CreateMapping.
        hr = obj.CreateMapping(t_vt1, t_vt2.bstrVal, t_vt3.bstrVal, t_vt4.bstrVal, t_vt5);
    }
    else if(!lstrcmpiW(a_szMethodName, L"DeleteMapping"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;
        a_pInParams->Get(L"IMethod", 0, &t_vt1, NULL, NULL);   
        a_pInParams->Get(L"vKey", 0, &t_vt2, NULL, NULL);  
      
        // call method - DeleteMapping.
        hr = obj.DeleteMapping(t_vt1, t_vt2);
    }
    else if(!lstrcmpiW(a_szMethodName, L"GetMapping"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;

        // get in params
        a_pInParams->Get(L"IMethod", 0, &t_vt1, NULL, NULL);   
        a_pInParams->Get(L"vKey", 0, &t_vt2, NULL, NULL);  
       
        // call method - GetMapping.
        hr = obj.GetMapping(
            t_vt1,
            t_vt2,
            &t_vt3,
            &t_vt4,
            &t_vt5,
            &t_vt6,
            &t_vt7
            );
        THROW_ON_ERROR(hr);

        IWbemClassObject* pClass = NULL;
        IWbemClassObject* pMethodClass = NULL;    
        IWbemClassObject* pOutParams = NULL;

        hr = a_pNameSpace->GetObject(_bstr_t(a_szClassName), 0, a_pCtx, &pClass, NULL);
        THROW_ON_ERROR(hr); 

        // This method returns values, and so create an instance of the
        // output argument class.
        hr = pClass->GetMethod(a_szMethodName, 0, NULL, &pMethodClass);
        pClass->Release();
        THROW_ON_ERROR(hr); 
        hr = pMethodClass->SpawnInstance(0, &pOutParams);
        pMethodClass->Release();
        THROW_ON_ERROR(hr); 

        // put them into the output object
        hr = pOutParams->Put(L"vCert", 0, &t_vt3, 0);      
        THROW_ON_ERROR(hr); 
        hr = pOutParams->Put(L"NtAcct", 0, &t_vt4, 0);      
        THROW_ON_ERROR(hr); 
        hr = pOutParams->Put(L"NtPwd", 0, &t_vt5, 0);      
        THROW_ON_ERROR(hr); 
        hr = pOutParams->Put(L"strName", 0, &t_vt6, 0);      
        THROW_ON_ERROR(hr); 
        hr = pOutParams->Put(L"IEnabled", 0, &t_vt7, 0);      
        THROW_ON_ERROR(hr); 

        // Send the output object back to the client via the sink. Then 
        // release the pointers and free the strings.
        hr = a_pHandler->Indicate(1, &pOutParams); 
        pOutParams->Release();
    }
    else if(!lstrcmpiW(a_szMethodName, L"SetAcct"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;
        a_pInParams->Get(L"IMethod", 0, &t_vt1, NULL, NULL);   
        a_pInParams->Get(L"vKey", 0, &t_vt2, NULL, NULL);  
        a_pInParams->Get(L"NtAcct", 0, &t_vt3, NULL, NULL);  
      
        // call method - SetAcct.
        hr = obj.SetAcct(t_vt1, t_vt2, t_vt3.bstrVal);
    }
    else if(!lstrcmpiW(a_szMethodName, L"SetEnabled"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;
        a_pInParams->Get(L"IMethod", 0, &t_vt1, NULL, NULL);   
        a_pInParams->Get(L"vKey", 0, &t_vt2, NULL, NULL);  
        a_pInParams->Get(L"IEnabled", 0, &t_vt3, NULL, NULL);  
      
        // call method - SetEnabled.
        hr = obj.SetEnabled(t_vt1, t_vt2, t_vt3);
    }
    else if(!lstrcmpiW(a_szMethodName, L"SetName"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;
        a_pInParams->Get(L"IMethod", 0, &t_vt1, NULL, NULL);   
        a_pInParams->Get(L"vKey", 0, &t_vt2, NULL, NULL);  
        a_pInParams->Get(L"strName", 0, &t_vt3, NULL, NULL);  
      
        // call method - SetName.
        hr = obj.SetName(t_vt1, t_vt2, t_vt3.bstrVal);
    }
    else if(!lstrcmpiW(a_szMethodName, L"SetPwd"))
    {
        if(a_pInParams == NULL)
            throw WBEM_E_INVALID_PARAMETER;
        a_pInParams->Get(L"IMethod", 0, &t_vt1, NULL, NULL);   
        a_pInParams->Get(L"vKey", 0, &t_vt2, NULL, NULL);  
        a_pInParams->Get(L"NtPwd", 0, &t_vt3, NULL, NULL);  
      
        // call method - SetPwd.
        hr = obj.SetPwd(t_vt1, t_vt2, t_vt3.bstrVal);
    }
    else
        hr = WBEM_E_NOT_SUPPORTED;

    THROW_ON_ERROR(hr);
}

void CUtils::FindUniqueServerName(
    LPCWSTR  a_szMbPath,
    _bstr_t& a_bstrServerPath
    )
{
    CMetabase t_metabase;
    WCHAR t_szServerNumber[15];
    _bstr_t t_bstrKeyPath;
    DWORD dwServerNumber = 0;

    do
    {
        dwServerNumber++;
        _ltow(dwServerNumber, t_szServerNumber, 10);
    
        // create server key
        t_bstrKeyPath = a_szMbPath;
        t_bstrKeyPath += L"/";
        t_bstrKeyPath += t_szServerNumber;

        // check if the server is not existed
        if(!t_metabase.CheckKey(t_bstrKeyPath))
            break;

    }while( 1 );

    a_bstrServerPath = t_bstrKeyPath;
}


void CUtils::Throw_Exception(
    HRESULT               a_hr,
    METABASE_PROPERTY*    a_pmbp
    )
{
    CIIsProvException t_e;

    t_e.m_hr = a_hr;
    t_e.m_psz = a_pmbp->pszPropName;

    throw(t_e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\schema.h ===
#ifndef _schema_h_
#define _schema_h_

enum enum_KEY_TYPE
{
    NO_TYPE,
    IIsComputer,
    IIsMimeMap,
    IIsLogModules,
    IIsLogModule,
    IIsCustomLogModule,
    IIsFtpService,
    IIsFtpInfo,
    IIsFtpServer,
    IIsFtpVirtualDir,
    IIsWebService,
    IIsWebInfo,
    IIsFilters,
    IIsFilter,
    IIsWebServer,
    IIsCertMapper,
    IIsWebVirtualDir,
    IIsWebDirectory,
    IIsWebFile,
    IIsCompressionSchemes,
    IIsCompressionScheme,

    TYPE_AdminACL,
    TYPE_AdminACE,
    TYPE_IPSecurity
};

struct WMI_METHOD 
{
    LPWSTR   pszMethodName;
    DWORD    dwMDId;    
};

struct METABASE_PROPERTY
{
    LPWSTR pszPropName;
    DWORD  dwMDIdentifier; 
    DWORD  dwMDUserType; 
    DWORD  dwMDDataType; 
    DWORD  dwMDMask;
    DWORD  dwMDAttributes;
    BOOL   fReadOnly;
}; 


struct WMI_CLASS
{
    LPWSTR    pszClassName;
    LPWSTR    pszMetabaseKey;
    LPWSTR    pszKeyName;
    METABASE_PROPERTY**  ppmbp;
    enum_KEY_TYPE        eKeyType;
    WMI_METHOD**         ppMethod;
}; 

enum enum_ASSOCIATION_TYPE
{
    at_ElementSetting,
    at_Component,
    at_AdminACL,
    at_IPSecurity,
};

// Association flags (WMI_ASSOCIATION::fFlags)
#define ASSOC_EXTRAORDINARY 1

struct WMI_ASSOCIATION 
{
    LPWSTR                    pszAssociationName;
    WMI_CLASS*                pcLeft;
    WMI_CLASS*                pcRight;
    enum_ASSOCIATION_TYPE     at;
    DWORD                     fFlags;                       
};




struct METABASE_PROPERTY_DATA
{
    static METABASE_PROPERTY s_AccessExecute;
    static METABASE_PROPERTY s_AccessFlags;
    static METABASE_PROPERTY s_AccessNoRemoteExecute;
    static METABASE_PROPERTY s_AccessNoRemoteRead;
    static METABASE_PROPERTY s_AccessNoRemoteScript;
    static METABASE_PROPERTY s_AccessNoRemoteWrite;
    static METABASE_PROPERTY s_AccessRead;
    static METABASE_PROPERTY s_AccessSource;
    static METABASE_PROPERTY s_AccessScript;
    static METABASE_PROPERTY s_AccessSSL;
    static METABASE_PROPERTY s_AccessSSL128;
    static METABASE_PROPERTY s_AccessSSLFlags;
    static METABASE_PROPERTY s_AccessSSLMapCert; 
    static METABASE_PROPERTY s_AccessSSLNegotiateCert;
    static METABASE_PROPERTY s_AccessSSLRequireCert;
    static METABASE_PROPERTY s_AccessWrite;
    static METABASE_PROPERTY s_AdminServer;
//    static METABASE_PROPERTY s_AdminACL;
    static METABASE_PROPERTY s_AllowAnonymous;
    static METABASE_PROPERTY s_AllowKeepAlive;
    static METABASE_PROPERTY s_AllowPathInfoForScriptMappings;
    static METABASE_PROPERTY s_AnonymousOnly;
    static METABASE_PROPERTY s_AnonymousPasswordSync;
    static METABASE_PROPERTY s_AnonymousUserName;
    static METABASE_PROPERTY s_AnonymousUserPass;
    static METABASE_PROPERTY s_AppAllowClientDebug;
    static METABASE_PROPERTY s_AppAllowDebugging;
    static METABASE_PROPERTY s_AppFriendlyName;
    static METABASE_PROPERTY s_AppIsolated;
    static METABASE_PROPERTY s_AppOopRecoverLimit;
    static METABASE_PROPERTY s_AppPackageID;
    static METABASE_PROPERTY s_AppPackageName;
    static METABASE_PROPERTY s_AppRoot;
    static METABASE_PROPERTY s_AppWamClsid;
    static METABASE_PROPERTY s_AspAllowOutOfProcComponents;
    static METABASE_PROPERTY s_AspAllowSessionState;
    static METABASE_PROPERTY s_AspBufferingOn;
    static METABASE_PROPERTY s_AspCodepage;
    static METABASE_PROPERTY s_AspEnableApplicationRestart;
    static METABASE_PROPERTY s_AspEnableAspHtmlFallback;
    static METABASE_PROPERTY s_AspEnableChunkedEncoding;
    static METABASE_PROPERTY s_AspEnableParentPaths;
    static METABASE_PROPERTY s_AspEnableTypelibCache;
    static METABASE_PROPERTY s_AspErrorsToNTLog;
    static METABASE_PROPERTY s_AspExceptionCatchEnable;
    static METABASE_PROPERTY s_AspLogErrorRequests;
    static METABASE_PROPERTY s_AspProcessorThreadMax;
    static METABASE_PROPERTY s_AspQueueConnectionTestTime;
    static METABASE_PROPERTY s_AspQueueTimeout;
    static METABASE_PROPERTY s_AspRequestQueueMax;
    static METABASE_PROPERTY s_AspScriptEngineCacheMax;
    static METABASE_PROPERTY s_AspScriptErrorMessage;
    static METABASE_PROPERTY s_AspScriptErrorSentToBrowser;
    static METABASE_PROPERTY s_AspScriptFileCacheSize;
    static METABASE_PROPERTY s_AspScriptLanguage;
    static METABASE_PROPERTY s_AspScriptTimeout;
    static METABASE_PROPERTY s_AspSessionMax;
    static METABASE_PROPERTY s_AspSessionTimeout;
    static METABASE_PROPERTY s_AspThreadGateEnabled;
    static METABASE_PROPERTY s_AspThreadGateLoadHigh;
    static METABASE_PROPERTY s_AspThreadGateLoadLow;
    static METABASE_PROPERTY s_AspThreadGateSleepDelay;
    static METABASE_PROPERTY s_AspThreadGateSleepMax;
    static METABASE_PROPERTY s_AspThreadGateTimeSlice;
    static METABASE_PROPERTY s_AspTrackThreadingModel;
    static METABASE_PROPERTY s_AuthAnonymous;
    static METABASE_PROPERTY s_AuthBasic;
    static METABASE_PROPERTY s_AuthFlags;
    static METABASE_PROPERTY s_AuthNTLM;
    static METABASE_PROPERTY s_AuthPersistence;
    static METABASE_PROPERTY s_AuthPersistSingleRequest;
    static METABASE_PROPERTY s_AuthPersistSingleRequestIfProxy;
    static METABASE_PROPERTY s_AuthPersistSingleRequestAlwaysIfProxy;
    static METABASE_PROPERTY s_CacheControlCustom;
    static METABASE_PROPERTY s_CacheControlMaxAge;
    static METABASE_PROPERTY s_CacheControlNoCache;
    static METABASE_PROPERTY s_CacheISAPI;
    static METABASE_PROPERTY s_CGITimeout;
    static METABASE_PROPERTY s_ContentIndexed;
    static METABASE_PROPERTY s_ConnectionTimeout;
    static METABASE_PROPERTY s_CpuAppEnabled;
    static METABASE_PROPERTY s_CpuCgiEnabled;
    static METABASE_PROPERTY s_CpuLoggingMask;
    static METABASE_PROPERTY s_CpuEnableActiveProcs;
    static METABASE_PROPERTY s_CpuEnableAllProcLogging;
    static METABASE_PROPERTY s_CpuEnableApplicationLogging;
    static METABASE_PROPERTY s_CpuEnableCgiLogging;
    static METABASE_PROPERTY s_CpuEnableEvent;
    static METABASE_PROPERTY s_CpuEnableKernelTime;
    static METABASE_PROPERTY s_CpuEnableLogging;
    static METABASE_PROPERTY s_CpuEnablePageFaults;
    static METABASE_PROPERTY s_CpuEnableProcType;
    static METABASE_PROPERTY s_CpuEnableTerminatedProcs;
    static METABASE_PROPERTY s_CpuEnableTotalProcs;
    static METABASE_PROPERTY s_CpuEnableUserTime;
    static METABASE_PROPERTY s_CpuLimitLogEvent;
    static METABASE_PROPERTY s_CpuLimitPause;
    static METABASE_PROPERTY s_CpuLimitPriority;
    static METABASE_PROPERTY s_CpuLimitProcStop;
    static METABASE_PROPERTY s_CpuLimitsEnabled;
    static METABASE_PROPERTY s_CpuLoggingInterval;
    static METABASE_PROPERTY s_CpuLoggingOptions;
    static METABASE_PROPERTY s_CpuResetInterval;
    static METABASE_PROPERTY s_CreateCGIWithNewConsole;
    static METABASE_PROPERTY s_CreateProcessAsUser;
    static METABASE_PROPERTY s_CustomErrorDescriptions;
    static METABASE_PROPERTY s_DefaultDoc;
    static METABASE_PROPERTY s_DefaultDocFooter;
    static METABASE_PROPERTY s_DefaultLogonDomain;
    static METABASE_PROPERTY s_DirBrowseFlags;
    static METABASE_PROPERTY s_DirBrowseShowDate;
    static METABASE_PROPERTY s_DirBrowseShowExtension;
    static METABASE_PROPERTY s_DirBrowseShowLongDate;
    static METABASE_PROPERTY s_DirBrowseShowSize;
    static METABASE_PROPERTY s_DirBrowseShowTime;
    static METABASE_PROPERTY s_DirectoryLevelsToScan;
    static METABASE_PROPERTY s_DisableSocketPooling;
    static METABASE_PROPERTY s_DontLog;
    static METABASE_PROPERTY s_DownlevelAdminInstance;
    static METABASE_PROPERTY s_EnableDefaultDoc;
    static METABASE_PROPERTY s_EnableDirBrowsing;
    static METABASE_PROPERTY s_EnableDocFooter;
    static METABASE_PROPERTY s_EnableReverseDns;
    static METABASE_PROPERTY s_ExitMessage;
    static METABASE_PROPERTY s_FilterDescription;
    static METABASE_PROPERTY s_FilterEnabled;
    static METABASE_PROPERTY s_FilterFlags;
    static METABASE_PROPERTY s_FilterLoadOrder;
    static METABASE_PROPERTY s_FilterPath;
    static METABASE_PROPERTY s_FilterState;
    static METABASE_PROPERTY s_FrontPageWeb;
    static METABASE_PROPERTY s_FtpDirBrowseShowLongDate;
    static METABASE_PROPERTY s_GreetingMessage;
    static METABASE_PROPERTY s_HcCompressionDll;
    static METABASE_PROPERTY s_HcCreateFlags;
    static METABASE_PROPERTY s_HcDoDynamicCompression;
    static METABASE_PROPERTY s_HcDoOnDemandCompression;
    static METABASE_PROPERTY s_HcDoStaticCompression;
    static METABASE_PROPERTY s_HcDynamicCompressionLevel;
    static METABASE_PROPERTY s_HcFileExtensions;
    static METABASE_PROPERTY s_HcMimeType;
    static METABASE_PROPERTY s_HcOnDemandCompLevel;
    static METABASE_PROPERTY s_HcPriority;
    static METABASE_PROPERTY s_HcScriptFileExtensions;
    static METABASE_PROPERTY s_HttpCustomHeaders;
    static METABASE_PROPERTY s_HttpErrors;
    static METABASE_PROPERTY s_HttpExpires;
    static METABASE_PROPERTY s_HttpPics;
    static METABASE_PROPERTY s_HttpRedirect;
    static METABASE_PROPERTY s_InProcessIsapiApps;
    static METABASE_PROPERTY s_IPSecurity;
    static METABASE_PROPERTY s_LogAnonymous;
    static METABASE_PROPERTY s_LogCustomPropertyDataType;
    static METABASE_PROPERTY s_LogCustomPropertyHeader;
    static METABASE_PROPERTY s_LogCustomPropertyID;
    static METABASE_PROPERTY s_LogCustomPropertyMask;
    static METABASE_PROPERTY s_LogCustomPropertyName;
    static METABASE_PROPERTY s_LogCustomPropertyServicesString;
    static METABASE_PROPERTY s_LogExtFileBytesRecv;
    static METABASE_PROPERTY s_LogExtFileBytesSent;
    static METABASE_PROPERTY s_LogExtFileClientIp;
    static METABASE_PROPERTY s_LogExtFileComputerName;
    static METABASE_PROPERTY s_LogExtFileCookie;
    static METABASE_PROPERTY s_LogExtFileDate;
    static METABASE_PROPERTY s_LogExtFileFlags;
    static METABASE_PROPERTY s_LogExtFileHttpStatus;
    static METABASE_PROPERTY s_LogExtFileMethod;
    static METABASE_PROPERTY s_LogExtFileProtocolVersion;
    static METABASE_PROPERTY s_LogExtFileReferer;
    static METABASE_PROPERTY s_LogExtFileServerIp;
    static METABASE_PROPERTY s_LogExtFileServerPort;
    static METABASE_PROPERTY s_LogExtFileSiteName;
    static METABASE_PROPERTY s_LogExtFileTime;
    static METABASE_PROPERTY s_LogExtFileTimeTaken;
    static METABASE_PROPERTY s_LogExtFileUriQuery;
    static METABASE_PROPERTY s_LogExtFileUriStem;
    static METABASE_PROPERTY s_LogExtFileUserAgent;
    static METABASE_PROPERTY s_LogExtFileUserName;
    static METABASE_PROPERTY s_LogExtFileWin32Status;
    static METABASE_PROPERTY s_LogFileDirectory;
    static METABASE_PROPERTY s_LogFileLocaltimeRollover;
    static METABASE_PROPERTY s_LogFilePeriod;
    static METABASE_PROPERTY s_LogFileTruncateSize;
    static METABASE_PROPERTY s_LogModuleId;
    static METABASE_PROPERTY s_LogModuleUiId;
    static METABASE_PROPERTY s_LogModuleList;
    static METABASE_PROPERTY s_LogNonAnonymous;
    static METABASE_PROPERTY s_LogOdbcDataSource;
    static METABASE_PROPERTY s_LogOdbcPassword;
    static METABASE_PROPERTY s_LogOdbcTableName;
    static METABASE_PROPERTY s_LogOdbcUserName;
    static METABASE_PROPERTY s_LogonMethod;
    static METABASE_PROPERTY s_LogPluginClsId;
    static METABASE_PROPERTY s_LogType;
    static METABASE_PROPERTY s_MaxBandwidth;
    static METABASE_PROPERTY s_MaxBandwidthBlocked;
    static METABASE_PROPERTY s_MaxClientsMessage;
    static METABASE_PROPERTY s_MaxConnections;
    static METABASE_PROPERTY s_MaxEndpointConnections;
    static METABASE_PROPERTY s_MimeMap;
    static METABASE_PROPERTY s_MSDOSDirOutput;
    static METABASE_PROPERTY s_NetLogonWorkstation;
    static METABASE_PROPERTY s_NotDeletable;
    static METABASE_PROPERTY s_NotifyAccessDenied;
    static METABASE_PROPERTY s_NotifyAuthentication;
    static METABASE_PROPERTY s_NotifyEndOfNetSession;
    static METABASE_PROPERTY s_NotifyEndOfRequest;
    static METABASE_PROPERTY s_NotifyLog;
    static METABASE_PROPERTY s_NotifyNonSecurePort;
    static METABASE_PROPERTY s_NotifyOrderHigh;
    static METABASE_PROPERTY s_NotifyOrderLow;
    static METABASE_PROPERTY s_NotifyOrderMedium;
    static METABASE_PROPERTY s_NotifyPreProcHeaders;
    static METABASE_PROPERTY s_NotifyReadRawData;
    static METABASE_PROPERTY s_NotifySecurePort;
    static METABASE_PROPERTY s_NotifySendRawData;
    static METABASE_PROPERTY s_NotifySendResponse;
    static METABASE_PROPERTY s_NotifyUrlMap;
    static METABASE_PROPERTY s_NTAuthenticationProviders;
    static METABASE_PROPERTY s_PasswordCacheTTL;
    static METABASE_PROPERTY s_PasswordChangeFlags;
    static METABASE_PROPERTY s_PasswordExpirePrenotifyDays;
    static METABASE_PROPERTY s_Path;
    static METABASE_PROPERTY s_PoolIDCTimeout;
    static METABASE_PROPERTY s_ProcessNTCRIfLoggedOn;
    static METABASE_PROPERTY s_PutReadSize;
    static METABASE_PROPERTY s_Realm;
    static METABASE_PROPERTY s_RedirectHeaders;
    static METABASE_PROPERTY s_ScriptMaps;
    static METABASE_PROPERTY s_ServerAutoStart;
    static METABASE_PROPERTY s_SecureBindings;
    static METABASE_PROPERTY s_ServerBindings;
    static METABASE_PROPERTY s_ServerComment;
    static METABASE_PROPERTY s_ServerConfigAutoPWSync;
    static METABASE_PROPERTY s_ServerConfigFlags;
    static METABASE_PROPERTY s_ServerConfigSSL128;
    static METABASE_PROPERTY s_ServerConfigSSL40;
    static METABASE_PROPERTY s_ServerConfigSSLAllowEncrypt;
    static METABASE_PROPERTY s_ServerID;
    static METABASE_PROPERTY s_ServerListenBacklog;
    static METABASE_PROPERTY s_ServerListenTimeout;
    static METABASE_PROPERTY s_ServerSize;
    static METABASE_PROPERTY s_ServerState;
    static METABASE_PROPERTY s_SSIExecDisable;
    static METABASE_PROPERTY s_UNCAuthenticationPassthrough;
    static METABASE_PROPERTY s_UNCPassword;
    static METABASE_PROPERTY s_UNCUserName;
    static METABASE_PROPERTY s_UploadReadAheadSize;
    static METABASE_PROPERTY s_UseHostName;
    static METABASE_PROPERTY s_WAMUserName;
    static METABASE_PROPERTY s_WAMUserPass;
    static METABASE_PROPERTY s_KeyType;
  
    static METABASE_PROPERTY* s_pmbpComputerSettings[];
    static METABASE_PROPERTY* s_pmbpFtpServiceSettings[];
    static METABASE_PROPERTY* s_pmbpFtpServerSettings[];
    static METABASE_PROPERTY* s_pmbpFtpVirtualDirSettings[];
    static METABASE_PROPERTY* s_pmbpWebServiceSettings[];
    static METABASE_PROPERTY* s_pmbpWebServerSettings[];
    static METABASE_PROPERTY* s_pmbpWebVirtualDirSettings[];
    static METABASE_PROPERTY* s_pmbpWebDirectorySettings[];
    static METABASE_PROPERTY* s_pmbpWebFileSettings[];

    static METABASE_PROPERTY* s_pmbpComputer[];
    static METABASE_PROPERTY* s_pmbpFtpService[];
    static METABASE_PROPERTY* s_pmbpFtpServer[];
    static METABASE_PROPERTY* s_pmbpFtpVirtualDir[];
    static METABASE_PROPERTY* s_pmbpWebService[];
    static METABASE_PROPERTY* s_pmbpWebServer[];
    static METABASE_PROPERTY* s_pmbpWebVirtualDir[];
    static METABASE_PROPERTY* s_pmbpWebDirectory[];
    static METABASE_PROPERTY* s_pmbpWebFile[];

    static METABASE_PROPERTY* s_pmbpMimeMapSetting[];
    static METABASE_PROPERTY* s_pmbpLogModuleSetting[];
    static METABASE_PROPERTY* s_pmbpCustomLogModuleSetting[];
    static METABASE_PROPERTY* s_pmbpFtpInfoSetting[];
    static METABASE_PROPERTY* s_pmbpWebInfoSetting[];
    static METABASE_PROPERTY* s_pmbpWebFilter[];
    static METABASE_PROPERTY* s_pmbpWebCertMapper[];
    static METABASE_PROPERTY* s_pmbpCompressionSchemeSetting[];
};


struct WMI_METHOD_DATA
{
    static WMI_METHOD s_ServiceCreateNewServer;

    static WMI_METHOD s_ServerStart;
    static WMI_METHOD s_ServerStop;
    static WMI_METHOD s_ServerContinue;
    static WMI_METHOD s_ServerPause;

    static WMI_METHOD s_AppCreate;
    static WMI_METHOD s_AppCreate2;
    static WMI_METHOD s_AppDelete;
    static WMI_METHOD s_AppUnLoad;
    static WMI_METHOD s_AppDisable;
    static WMI_METHOD s_AppEnable;
    static WMI_METHOD s_AppGetStatus;
    static WMI_METHOD s_AspAppRestart;

    static WMI_METHOD s_Backup;
    static WMI_METHOD s_DeleteBackup;
    static WMI_METHOD s_EnumBackups;
    static WMI_METHOD s_Restore;

    static WMI_METHOD s_CreateMapping;
    static WMI_METHOD s_DeleteMapping;
    static WMI_METHOD s_GetMapping;
    static WMI_METHOD s_SetAcct;
    static WMI_METHOD s_SetEnabled;
    static WMI_METHOD s_SetName;
    static WMI_METHOD s_SetPwd;

    static WMI_METHOD* s_ServiceMethods[];
    static WMI_METHOD* s_ServerMethods[];
    static WMI_METHOD* s_WebAppMethods[];
    static WMI_METHOD* s_ComputerMethods[];
    static WMI_METHOD* s_CertMapperMethods[];
};


struct WMI_CLASS_DATA
{
    static WMI_CLASS s_Computer;
    static WMI_CLASS s_ComputerSetting;

    static WMI_CLASS s_MimeMapSetting;

    static WMI_CLASS s_LogModuleSetting;
    static WMI_CLASS s_CustomLogModuleSetting;
    
    static WMI_CLASS s_FtpService;
    static WMI_CLASS s_FtpServiceSettings;

    static WMI_CLASS s_FtpInfoSetting;

    static WMI_CLASS s_FtpServer ;
    static WMI_CLASS s_FtpServerSettings ;

    static WMI_CLASS s_FtpVirtualDir;
    static WMI_CLASS s_FtpVirtualDirSettings;

    static WMI_CLASS s_WebService;
    static WMI_CLASS s_WebServiceSettings;

    static WMI_CLASS s_WebInfoSetting;

    static WMI_CLASS s_WebFilter;

    static WMI_CLASS s_WebServer;
    static WMI_CLASS s_WebServerSettings;

    static WMI_CLASS s_WebCertMapper;

    static WMI_CLASS s_WebVirtualDir;
    static WMI_CLASS s_WebVirtualDirSettings;

    static WMI_CLASS s_WebDirectory;
    static WMI_CLASS s_WebDirectorySettings;

    static WMI_CLASS s_WebFile;
    static WMI_CLASS s_WebFileSettings;

    static WMI_CLASS s_AdminACL;
    static WMI_CLASS s_ACE;
    static WMI_CLASS s_IPSecurity;

    static WMI_CLASS s_CompressionSchemeSetting;

    static WMI_CLASS* s_WmiClasses[];
};


struct WMI_ASSOCIATION_DATA
{
    static WMI_ASSOCIATION s_ComputerToMimeMap;
    static WMI_ASSOCIATION s_ComputerToFtpService;
    static WMI_ASSOCIATION s_ComputerToWebService;
    static WMI_ASSOCIATION s_ComputerToComputerSettings;
    static WMI_ASSOCIATION s_ComputerToLogModuleSettings;
    static WMI_ASSOCIATION s_ComputerToCustomLogModuleSetting;

    static WMI_ASSOCIATION s_FtpServiceToInfo;
    static WMI_ASSOCIATION s_FtpServiceToServer;
    static WMI_ASSOCIATION s_FtpServiceToSettings;

    static WMI_ASSOCIATION s_FtpServerToVirtualDir;
    static WMI_ASSOCIATION s_FtpServerToSettings;

    static WMI_ASSOCIATION s_FtpVirtualDirToVirtualDir;
    static WMI_ASSOCIATION s_FtpVirtualDirToSettings;

    static WMI_ASSOCIATION s_WebServiceToInfo;
    static WMI_ASSOCIATION s_WebServiceToFilter;
    static WMI_ASSOCIATION s_WebServiceToServer;
    static WMI_ASSOCIATION s_WebServiceToSettings;
    static WMI_ASSOCIATION s_WebServiceToCompressionSchemeSetting;

    static WMI_ASSOCIATION s_WebServerToCertMapper;
    static WMI_ASSOCIATION s_WebServerToFilter;
    static WMI_ASSOCIATION s_WebServerToVirtualDir;
    static WMI_ASSOCIATION s_WebServerToSettings;
    
    static WMI_ASSOCIATION s_WebVirtualDirToVirtualDir;
    static WMI_ASSOCIATION s_WebVirtualDirToDirectory;
    static WMI_ASSOCIATION s_WebVirtualDirToFile;
    static WMI_ASSOCIATION s_WebVirtualDirToSettings;

    static WMI_ASSOCIATION s_WebDirectoryToDirectory;
    static WMI_ASSOCIATION s_WebDirectoryToVirtualDir;
    static WMI_ASSOCIATION s_WebDirectoryToFile;
    static WMI_ASSOCIATION s_WebDirectoryToSettings;

    static WMI_ASSOCIATION s_WebFileToSettings;

    static WMI_ASSOCIATION s_AdminACLToACE;
    static WMI_ASSOCIATION s_FtpServiceToAdminACL;
    static WMI_ASSOCIATION s_FtpServerToAdminACL;
    static WMI_ASSOCIATION s_FtpVirtualDirToAdminACL;
    static WMI_ASSOCIATION s_WebServiceToAdminACL;
    static WMI_ASSOCIATION s_WebServerToAdminACL;
    static WMI_ASSOCIATION s_WebVirtualDirToAdminACL;
    static WMI_ASSOCIATION s_WebDirectoryToAdminACL;
    static WMI_ASSOCIATION s_WebFileToAdminACL;
 
    static WMI_ASSOCIATION s_FtpServiceToIPSecurity;
    static WMI_ASSOCIATION s_FtpServerToIPSecurity;
    static WMI_ASSOCIATION s_FtpVirtualDirToIPSecurity;
    static WMI_ASSOCIATION s_WebServiceToIPSecurity;
    static WMI_ASSOCIATION s_WebServerToIPSecurity;
    static WMI_ASSOCIATION s_WebVirtualDirToIPSecurity;
    static WMI_ASSOCIATION s_WebDirectoryToIPSecurity;
    static WMI_ASSOCIATION s_WebFileToIPSecurity;

    static WMI_ASSOCIATION* s_WmiAssociations[];
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\iisprov\utils.h ===
#ifndef _utils_h_
#define _utils_h_


#define MAX_BUF_SIZE         1024
#define MAX_KEY_NAME_SIZE      32
#define MAX_KEY_TYPE_SIZE      32


class CUtils
{
public:
    static bool GetClass(LPCWSTR,WMI_CLASS**);
    static bool GetAssociation(LPCWSTR, WMI_ASSOCIATION**);
    static KeyRef* GetKey(ParsedObjectPath*, WCHAR*);
    static void GetMetabasePath(IWbemClassObject*, ParsedObjectPath*, WMI_CLASS*, _bstr_t&);
    static void GetToken(WCHAR**, WCHAR*);

    void ExecMethodAsync(BSTR, BSTR, IWbemContext*, IWbemClassObject*, IWbemObjectSink*, CWbemServices* );
    void DeleteObjectAsync(CWbemServices*, ParsedObjectPath*, CMetabase&);
    void PutObjectAsync(IWbemClassObject*, IWbemClassObject*, ParsedObjectPath*, long);
    void EnumObjectAsync(BSTR, CWbemServices*, IWbemObjectSink FAR*);
    HRESULT GetObjectAsync(CWbemServices*, IWbemClassObject**, ParsedObjectPath*, CMetabase&);

    void MzCat (WCHAR**, const WCHAR*);
    bool TypeStringToEnum(enum_KEY_TYPE&, LPCWSTR);
    bool TypeEnumToString(LPWSTR, enum_KEY_TYPE);
    void Throw_Exception(HRESULT, METABASE_PROPERTY*);

private:
    bool GetMethod(LPCWSTR, WMI_METHOD**, WMI_METHOD**);
    void ExecFtpServiceMethod(LPCWSTR, LPCWSTR, LPCWSTR, IWbemContext*, IWbemClassObject*, IWbemObjectSink*, CWbemServices*);
    void ExecWebServiceMethod(LPCWSTR, LPCWSTR, LPCWSTR, IWbemContext*, IWbemClassObject*, IWbemObjectSink*, CWbemServices*);
    void ExecWebAppMethod(LPCWSTR, LPCWSTR, LPCWSTR, IWbemContext*, IWbemClassObject*, IWbemObjectSink*, CWbemServices*);
    void ExecComputerMethod(LPCWSTR, LPCWSTR, LPCWSTR, IWbemContext*, IWbemClassObject*, IWbemObjectSink*, CWbemServices*);
    void ExecCertMapperMethod(LPCWSTR, LPCWSTR, LPCWSTR, IWbemContext*, IWbemClassObject*, IWbemObjectSink*, CWbemServices*);
    void FindUniqueServerName(LPCWSTR,    _bstr_t&);

private:
    static CSynchObject s_synObject;
};



class CIIsProvException
{
public:
    CIIsProvException() {m_hr = ERROR_SUCCESS; m_psz = NULL;};

    HRESULT m_hr;
    WCHAR*  m_psz;
};


#define THROW_ON_FALSE(b)               \
    if (!b)                             \
        throw(WBEM_E_FAILED);

// if client calcelled, stop and return successfully
#define THROW_ON_ERROR(hr)              \
    if (hr != ERROR_SUCCESS)            \
        throw(hr == WBEM_E_CALL_CANCELLED ? WBEM_NO_ERROR : hr);

#define THROW_E_ON_ERROR(hr, pmbp)      \
    if (hr != ERROR_SUCCESS)            \
    {                                   \
        CUtils obj;                     \
        obj.Throw_Exception(hr, pmbp);  \
    }


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\localui\diskmonitor\sadiskevent.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      SADiskEvent.cpp
//
//  Description:
//      description-for-module
//
//  [Header File:]
//      SADiskEvent.h
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>

#include <wbemidl.h>
#include <satrace.h>

#include "SADiskEvent.h"
#include <oahelp.inl>
#include <SAEventComm.h>

const WCHAR SA_DISKEVENTPROVIDER_DISKCOUNTER_NAME[] =
        L"\\PhysicalDisk(_Total#0)\\Disk Transfers/sec";

const WCHAR SA_SADEVMONITOR_KEYPATH [] = 
                        L"SOFTWARE\\Microsoft\\ServerAppliance\\DeviceMonitor";

const WCHAR SA_SADISKMONITOR_QUERYINTERVAL[] = L"DiskQueryInterval";
                        
//static DWORD g_dwDiskTimeInterval = 1000;
const DWORD DEFAULTQUERYINTERVAL = 1000;



//////////////////////////////////////////////////////////////////////////////
//
//  CSADiskEvent::CSADiskEvent
//
//  Description:
//      Class constructor.
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
CSADiskEvent::CSADiskEvent()
{

    m_cRef = 0;
    m_lStatus = Pending;
    m_dwDiskTimeInterval = 1000;

    m_hThread = NULL;

    m_pNs = NULL;
    m_pSink = NULL;
    m_pEventClassDef = NULL;

    m_hqryQuery = NULL;
    m_hcntCounter = NULL;

    m_hQueryInterval = NULL;
}


//////////////////////////////////////////////////////////////////////////////
//
//  CSADiskEvent::~CSADiskEvent
//
//  Description:
//      Class deconstructor.
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
CSADiskEvent::~CSADiskEvent()
{
    if( m_hqryQuery )
    {
        PdhCloseQuery( m_hqryQuery );
    }

    if (m_hThread)
    {
        CloseHandle(m_hThread);
    }

    if( m_hQueryInterval != NULL )
    {
        ::RegCloseKey( m_hQueryInterval );
    }

    if (m_pNs)
    {
        m_pNs->Release();
    }

    if (m_pSink)
    {
        m_pSink->Release();
    }

    if (m_pEventClassDef)
    {
        m_pEventClassDef->Release();        
    }
}


//////////////////////////////////////////////////////////////////////////////
//
//  CSADiskEvent::QueryInterface
//
//  Description:
//      An method implement of IUnkown interface.
//
//  Arguments:
//        [in] riid        Identifier of the requested interface
//        [out ppv        Address of output variable that receives the 
//                        interface pointer requested in iid
//
//    Returns:
//        NOERROR            if the interface is supported
//        E_NOINTERFACE    if not
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CSADiskEvent::QueryInterface(
    IN    REFIID riid, 
    OUT    LPVOID * ppv
    )
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IWbemEventProvider==riid)
    {
        *ppv = (IWbemEventProvider *) this;
        AddRef();
        return NOERROR;
    }

    if (IID_IWbemProviderInit==riid)
    {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}



//////////////////////////////////////////////////////////////////////////////
//
//  CSADiskEvent::AddRef
//
//  Description:
//      increments the reference count for an interface on an object.
//
//    Returns:
//        The new reference count.
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
ULONG 
CSADiskEvent::AddRef()
{
    return ++m_cRef;
}



//////////////////////////////////////////////////////////////////////////////
//
//  CSADiskEvent::Release
//
//  Description:
//      decrements the reference count for an interface on an object.
//
//    Returns:
//        The new reference count.
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
ULONG 
CSADiskEvent::Release()
{
    if (0 != --m_cRef)
    {
        return m_cRef;
    }

    //
    // If here, we are shutting down.
    // 
    m_lStatus = PendingStop;

    return 0;
}


//////////////////////////////////////////////////////////////////////////////
//
//  CSADiskEvent::ProvideEvents
//
//  Description:
//      Called by Windows Management to begin delivery of our events.
//
//  Arguments:
//        [in] pSinkIn    Pointer to the object sink to which we 
//                        will deliver its events
//             lFlagsIn    Reserved. It must be zero.
//
//    Returns:
//        WBEM_NO_ERROR    Received the sink, and it will begin delivery 
//                        of events
//        WBEM_E_FAILED    Failed.
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

HRESULT 
CSADiskEvent::ProvideEvents( 
    IN IWbemObjectSink __RPC_FAR *pSinkIn,
    IN long lFlagsIn
    )
{
    //
    // Copy the sink.
    //
    m_pSink = pSinkIn;
    m_pSink->AddRef();

    //
    // Open registry key of alertemail settings.
    //
    ULONG   ulReturn;
    ulReturn = ::RegOpenKey( 
                    HKEY_LOCAL_MACHINE,
                    SA_SADEVMONITOR_KEYPATH,
                    &m_hQueryInterval 
                    );
    if( ulReturn == ERROR_SUCCESS )
    {
        DWORD dwDataSize = sizeof( DWORD );

        ulReturn = ::RegQueryValueEx( 
                            m_hQueryInterval,
                            SA_SADISKMONITOR_QUERYINTERVAL,
                            NULL,
                            NULL,
                            reinterpret_cast<PBYTE>(&m_dwDiskTimeInterval),
                            &dwDataSize 
                            );

        if( ( ulReturn != ERROR_SUCCESS ) ||
            ( m_dwDiskTimeInterval < DEFAULTQUERYINTERVAL ) )
        {
            SATraceString( 
            "CSADiskEvent::ProvideEvents QueryValue failed" 
            );

            m_dwDiskTimeInterval = DEFAULTQUERYINTERVAL;
        }
    }
    else
    {
        SATraceString( 
        "CSADiskEvent::ProvideEvents OpenKey failed" 
        );

        m_hQueryInterval = NULL;
    }

    //
    // Create the event thread.
    //
    DWORD dwTID;
    m_hThread = CreateThread(
        0,
        0,
        CSADiskEvent::EventThread,
        this,
        0,
        &dwTID
        );

    if( m_hThread == NULL )
    {
        SATraceString( 
            "CSADiskEvent::ProvideEvents CreateThread failed" 
            );

        return WBEM_E_FAILED;
    }

    //
    // Wait for provider to be 'ready'.
    //
    while (m_lStatus != Running)
    {
        Sleep( 1000 );
    }

    return WBEM_NO_ERROR;
}


//////////////////////////////////////////////////////////////////////////////
//
//    [static]
//  CSADiskEvent::EventThread
//
//  Description:
//      The event thread start routine.
//
//  Arguments:
//        [in] pArg    
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
DWORD 
WINAPI CSADiskEvent::EventThread(
    IN LPVOID pArg
    )
{
    //
    // Make transition to the per-instance method.
    //
    ((CSADiskEvent *)pArg)->InstanceThread();
    return 0;
}


//////////////////////////////////////////////////////////////////////////////
//
//  CSADiskEvent::InstanceThread
//
//  Description:
//      Called by EventThread to detect disk active.
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
void 
CSADiskEvent::InstanceThread()
{
    PDH_STATUS                pdhStatus;
    PDH_FMT_COUNTERVALUE    pdhFmt_CounterValue;

    m_lStatus = Running;
        
    while (m_lStatus == Running)
    {
        //
        // Polling performance data with time interval.
        //
        Sleep( m_dwDiskTimeInterval );    

        //
        //    Collect the query data before geting counter value.
        //
        pdhStatus = PdhCollectQueryData( m_hqryQuery );

        if( ERROR_SUCCESS == pdhStatus )
        {
            //
            // Get the counter value formatted by PDH.    
            //
            pdhStatus = PdhGetFormattedCounterValue( 
                                        m_hcntCounter,
                                        PDH_FMT_LONG,
                                        NULL,
                                        &pdhFmt_CounterValue 
                                        );

            if( ERROR_SUCCESS == pdhStatus )
            {
                if( pdhFmt_CounterValue.longValue != 0 )
                {
                    //
                    // Some disk operations appear during time interval.
                    //
                    NotifyDiskEvent( 
                        SA_DISK_DISPLAY_TRANSMITING, 
                        SA_RESOURCEEVENT_DEFAULT_CURRENTSTATE 
                        );
                }
                else
                {
                    //
                    // No work on the disk.
                    //
                    NotifyDiskEvent( 
                        SA_DISK_DISPLAY_IDLE, 
                        SA_RESOURCEEVENT_DEFAULT_CURRENTSTATE 
                        );
                } // pdhFmt_CounterValue.longValue != 0 

            }//if( ERROR_SUCCESS == pdhStatus )
            else
            {
                //
                // System is busy wait a moment.
                //
                Sleep( m_dwDiskTimeInterval );

                SATraceString( 
                    "CSADiskEvent::InstanceThread GetValue failed" 
                     );
                
            } //else
        }
    }
    
    //
    // When we get to here, we are no longer interested in the
    // provider and Release() has long since returned.
    m_lStatus = Stopped;

    delete this;
}



//////////////////////////////////////////////////////////////////////////////
//
//  CSADiskEvent::NotifyDiskEvent
//
//  Description:
//      Called by InstanceThread to begin delivery of our events.
//
//  Arguments:
//        [in] lDisplayInformationIDIn  Resource ID for the disk event.
//             lCurrentStateIn           Reserved.    
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
VOID
CSADiskEvent::NotifyDiskEvent( 
    LONG    lDisplayInformationIDIn,
    LONG    lCurrentStateIn
    )
{
    //
    // Generate a new event object.
    //
    IWbemClassObject *pEvt = 0;

    CBSTR bstrUniqueName   = CBSTR(SA_RESOURCEEVENT_UNIQUENAME);
    CBSTR bstrDisplayInfo  = CBSTR(SA_RESOURCEEVENT_DISPLAYINFORMATION);
    CBSTR bstrCurrentState = CBSTR(SA_RESOURCEEVENT_CURRENTSTATE);

    if ( ((BSTR)bstrUniqueName == NULL) ||
         ((BSTR)bstrDisplayInfo == NULL) ||
         ((BSTR)bstrCurrentState == NULL) )
    {
        SATraceString(" SADiskMonitor:CSADiskEvent::NotifyDiskEvent failed on memory allocation ");
        return;
    }

    HRESULT hRes = m_pEventClassDef->SpawnInstance( 0, &pEvt );
    if ( hRes != 0 )
    {
        SATraceString( 
            "CSADiskEvent::NotifyDiskEvent SpawnInstance failed" 
             );
        return;
    }        

    CVARIANT cvUniqueName( SA_DISK_EVENT ); 
    pEvt->Put( 
        bstrUniqueName, 
        0, 
        cvUniqueName, 
        0 
        );        

    CVARIANT cvDisplayInformationID( lDisplayInformationIDIn );
    pEvt->Put( 
        bstrDisplayInfo, 
        0, 
        cvDisplayInformationID, 
        0 
        );        

    CVARIANT cvCount( lCurrentStateIn );
    pEvt->Put(
        bstrCurrentState, 
        0, 
        cvCount, 
        0
        );        

    //
    // Deliver the event to CIMOM.
    //
    hRes = m_pSink->Indicate(1, &pEvt);
    
    if ( FAILED( hRes ) )
    {
        SATraceString( 
            "CSADiskEvent::NotifyDiskEvent Indicate failed" 
             );
    }

    pEvt->Release();                    
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSADiskEvent::Initialize
//
//  Description:
//      Inherite from IWbemProviderInit,called by Windows Management to 
//        initialize a provider and deem it ready to receive client requests.
//
//  Arguments:
//        [in] pszUserIn
//             lFlagsIn             
//             pszNamespaceIn
//             pszLocaleIn
//             pNamespaceIn
//             pCtxIn    
//             pInitSinkIn
//    
//    Returns:
//            WBEM_S_NO_ERROR 
//            WBEM_E_FAILED
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
HRESULT 
CSADiskEvent::Initialize( 
            LPWSTR    pszUserIn,
            LONG    lFlagsIn,
            LPWSTR    pszNamespaceIn,
            LPWSTR    pszLocaleIn,
            IWbemServices __RPC_FAR *    pNamespaceIn,
            IWbemContext __RPC_FAR *    pCtxIn,
            IWbemProviderInitSink __RPC_FAR *    pInitSinkIn
            )
{
    // We don't care about most of the incoming parameters in this
    // simple sample.  However, we will save the namespace pointer
    // and get our event class definition.

    m_pNs = pNamespaceIn;
    m_pNs->AddRef();    

    //
    // Grab the class definition for the event.
    // 
    IWbemClassObject *pObj = 0;
    CBSTR bstrClassName = CBSTR(SA_RESOURCEEVENT_CLASSNAME);
    if ( (BSTR)bstrClassName == NULL )
    {
        SATraceString(" SADiskMonitor:CSADiskEvent::Initialize failed on memory allocation ");
        return E_OUTOFMEMORY;
    }

    HRESULT hRes = m_pNs->GetObject(
        bstrClassName,          
        0,                          
        pCtxIn,  
        &pObj,
        0
        );

    if ( hRes != 0 )
    {
        SATraceString( 
            "CSADiskEvent::Initialize GetObject failed" 
            );
        return WBEM_E_FAILED;
    }

    m_pEventClassDef = pObj;
    
    //
    // Tell CIMOM that we're up and running.
    //
    if( InitDiskQueryContext() )
    {
        pInitSinkIn->SetStatus(WBEM_S_INITIALIZED,0);
        return WBEM_NO_ERROR;
    }

    SATraceString( 
        "CSADiskEvent::Initialize InitDiskQueryContext failed" 
         );

    pInitSinkIn->SetStatus(WBEM_E_FAILED ,0);
    return WBEM_E_FAILED; 
}            


//////////////////////////////////////////////////////////////////////////////
//
//  CSADiskEvent::InitDiskQueryContext
//
//  Description:
//      Called by Initialize to initial physicaldisk counter.
//
//  Arguments:
//    
//    Returns:
//            TRUE    Succeed in retrieving disk counter.
//            FALSE    Failed
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
BOOL
CSADiskEvent::InitDiskQueryContext()
{
    PDH_STATUS    pdhStatus;

    //
    // Open a query handle of PDH.
    //
    pdhStatus = PdhOpenQuery( NULL, 0, &m_hqryQuery );

    if( ERROR_SUCCESS == pdhStatus )
    {
        //
        //    Add the specified counter we want to our query handle.
        //
        pdhStatus = PdhAddCounter( m_hqryQuery,              
                                    SA_DISKEVENTPROVIDER_DISKCOUNTER_NAME,
                                    0,           
                                    &m_hcntCounter ); 
    }

    return ( ERROR_SUCCESS == pdhStatus );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\localui\diskmonitor\diskmonitor.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      DiskMonitor.cpp
//
//  Description:
//      description-for-module
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>
#include <time.h>
#include <locale.h>

#include <wbemidl.h>
#include <initguid.h>

#include "SAEventFactory.h"
#include "SADiskEvent.h"

static HINSTANCE    g_hInstance;

LONG        g_cObj = 0;
LONG        g_cLock= 0;

//////////////////////////////////////////////////////////////////////////////
//
//  DllMain
//
//  Description:
//        Entry point of the module.
//
//  Arguments:
//        [in]    hinstDLLIn
//                dwReasonIn
//                lpReservedIn
//
//    Returns:
//        TRUE    
//        FALSE    
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

BOOL 
WINAPI 
DllMain(
    HINSTANCE hinstDLLIn,
    DWORD dwReasonIn,
    LPVOID lpReservedIn
    )
{
    if ( dwReasonIn == DLL_PROCESS_ATTACH )
    {
        g_hInstance = hinstDLLIn;
        setlocale( LC_ALL, "" );    
    }
    else if ( dwReasonIn == DLL_PROCESS_DETACH )
    {
    }

    return TRUE;
}


//////////////////////////////////////////////////////////////////////////////
//
//  DllGetClassObject
//
//  Description:
//      Retrieves the class object from the module.
//
//  Arguments:
//        [in]    rclsidIn
//                riidIn
//        [out]    ppvOut
//
//    Return:
//        S_OK     
//        CLASS_E_CLASSNOTAVAILABLE     
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
extern "C"
HRESULT 
APIENTRY 
DllGetClassObject(
    REFCLSID rclsidIn,
    REFIID riidIn,
    LPVOID * ppvOut
    )
{
    HRESULT                    hr;
    CSAEventFactory *        pFactory;

    //
    //  Verify the caller is asking for our type of object.
    //
    if ( CLSID_DiskEventProvider != rclsidIn ) 
    {
        return E_FAIL;
    }

    //
    // Check that we can provide the interface.
    //
    if ( IID_IUnknown != riidIn && IID_IClassFactory != riidIn )
    {
        return E_NOINTERFACE;
    }

    //
    // Get a new class factory.
    //
    pFactory = new CSAEventFactory( rclsidIn );

    if ( !pFactory )
    {
        return E_OUTOFMEMORY;
    }

    //
    // Verify we can get an instance.
    //
    hr = pFactory->QueryInterface( riidIn, ppvOut );

    if ( FAILED( hr ) )
    {
        delete pFactory;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  DllCanUnloadNow
//
//  Description:
//      Retrieves the class object from the module.
//
//    Return:
//        SA_OK
//        SA_FALSE
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
extern "C"
HRESULT 
APIENTRY 
DllCanUnloadNow(void)
{
    SCODE sc = TRUE;

    if (g_cObj || g_cLock)
        sc = S_FALSE;

    return sc;
}

//////////////////////////////////////////////////////////////////////////////
//
//  DllRegisterServer
//
//  Description:
//        Standard OLE entry point for registering the server.
//
//  Returns:
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

extern "C"
HRESULT
APIENTRY 
DllRegisterServer(void)
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];

    //
    // Where are we?
    //
    DWORD dwResult = GetModuleFileNameW(g_hInstance, Path, 1023);
    if (0 == dwResult)
    {
        return (HRESULT_FROM_WIN32 (GetLastError ()));
    }
    Path[1023] = L'\0';

    //
    // Convert CLSID to string.
    //
    StringFromCLSID(CLSID_DiskEventProvider, &pGuidStr);
    swprintf(KeyPath, L"CLSID\\\\%s", pGuidStr);

    HKEY hKey;
    LONG lRes = RegCreateKeyW(HKEY_CLASSES_ROOT, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    wchar_t *pName = L"Microsoft Server Appliance Disk Monitor";
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, wcslen(pName) * 2 + 2);

    HKEY hSubkey;
    lRes = RegCreateKeyW(hKey, L"InprocServer32", &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, wcslen(Path) * 2 + 2);
    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//
//  DllUnregisterServer
//
//  Description:
//        Standard OLE entry point for unregistering the server.
//
//  Returns:
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

extern "C"
HRESULT 
APIENTRY 
DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];

    StringFromCLSID(CLSID_DiskEventProvider, &pGuidStr);
    swprintf(KeyPath, L"CLSID\\%s", pGuidStr);

    //
    // Delete InProcServer32 subkey.
    //
    LONG lRes = RegOpenKeyW(HKEY_CLASSES_ROOT, KeyPath, &hKey);
    if ( lRes )
    {
        return E_FAIL;
    }

    RegDeleteKeyW(hKey, L"InprocServer32");
    RegCloseKey(hKey);

    //
    // Delete CLSID GUID key.
    //
    lRes = RegOpenKeyW(HKEY_CLASSES_ROOT, L"CLSID", &hKey);
    if ( lRes )
    {
        return E_FAIL;
    }

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\localui\diskmonitor\sadiskevent.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      SADiskEvent.h
//
//  Description:
//      description-for-module
//
//  [Implementation Files:]
//      SADiskEvent.cpp
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

#include <Pdh.h>

//
// Define GUID
//
// {29D534E2-ADCA-45f8-B10C-00B286558C4B}
DEFINE_GUID(CLSID_DiskEventProvider, 
0x29d534e2, 0xadca, 0x45f8, 0xb1, 0xc, 0x0, 0xb2, 0x86, 0x55, 0x8c, 0x4b);

//////////////////////////////////////////////////////////////////////////////
//
//
//  class CSADiskEvent
//
//  Description:
//      class-description
//
//  History
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
class CSADiskEvent : 
    public IWbemEventProvider,    
    public IWbemProviderInit    
{

//
// Private data
//
private:

    IWbemServices       *m_pNs;
    IWbemObjectSink     *m_pSink;
    IWbemClassObject    *m_pEventClassDef;

    LONG                m_lStatus;
    ULONG               m_cRef;
    DWORD               m_dwDiskTimeInterval;

    HKEY                m_hQueryInterval;
    HANDLE              m_hThread;
    HQUERY                m_hqryQuery;
    HCOUNTER            m_hcntCounter;


    static DWORD WINAPI EventThread(LPVOID pArg);

    VOID InstanceThread();

    BOOL InitDiskQueryContext();
    
    VOID NotifyDiskEvent( 
        LONG    lDisplayInformationIDIn,
        LONG    lCurrentStateIn
        );

//
// Private data
//
public:

    enum { Pending, Running, PendingStop, Stopped };

    CSADiskEvent();
   ~CSADiskEvent();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // Inherited from IWbemEventProvider
    // =================================
    HRESULT STDMETHODCALLTYPE ProvideEvents( 
            IWbemObjectSink __RPC_FAR *pSinkIn,
            long lFlagsIn
            );

    //
    // Inherited from IWbemProviderInit
    // 
    HRESULT STDMETHODCALLTYPE Initialize( 
            LPWSTR        pszUserIn,
            LONG        lFlagsIn,
            LPWSTR        pszNamespaceIn,
            LPWSTR        pszLocaleIn,
            IWbemServices __RPC_FAR *            pNamespaceIn,
            IWbemContext __RPC_FAR *            pCtxIn,
            IWbemProviderInitSink __RPC_FAR *    pInitSinkIn
            );
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\localui\diskmonitor\saeventfactory.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      SAEventFactroy.h
//
//  Description:
//      description-for-module
//
//  [Implementation Files:]
//      SAEventFactroy.cpp
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

#pragma once

//////////////////////////////////////////////////////////////////////////////
//
//
//  class CSAEventFactory
//
//  Description:
//      class-description
//
//  History
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

class CSAEventFactory : 
    public IClassFactory    
{
//
// Private data
//
private:

    ULONG           m_cRef;
    CLSID           m_ClsId;
//
// Public data
//
public:

    //
    // Constructors & Destructors
    //

    CSAEventFactory(const CLSID & ClsId);
    ~CSAEventFactory();

    //
    // IUnknown members
    //
    STDMETHODIMP            QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG)    AddRef(void);
    STDMETHODIMP_(ULONG)    Release(void);

    //
    // IClassFactory members
    //
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP     LockServer(BOOL);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\localui\networkmonitor\networkmonitor.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      NetworkMonitor.cpp
//
//  Description:
//      Server appliance event provider - COM server implementations 
//
//  History:
//      1. lustar.li (Guogang Li), creation date in 7-DEC-2000
//
//  Notes:
//      
//
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>
#include <locale.h>

#include <debug.h>
#include <wbemidl.h>
#include <initguid.h>

#include "SACounter.h"
#include "SANetEvent.h"
#include "SAEventFactory.h"

static HINSTANCE g_hInstance=NULL;

//////////////////////////////////////////////////////////////////////////////
//++
//    Function:
//        DllMain
//
//  Description:
//      the entry of dll
//
//  Arguments:
//      [in]    HINSTANCE - module handle
//      [in]    DWORD     - reason for call
//      [in]    reserved 
//
//  Returns:    
//        BOOL -- sucess/failure
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

BOOL WINAPI
DllMain(
    /*[in]*/ HINSTANCE hInstance,
    /*[in]*/ DWORD dwReason,
    /*[in]*/ LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hInstance;
        setlocale(LC_ALL, "");
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  Function:   
//        DllGetClassObject
//
//  Description: 
//        Returns a class factory to create an object of the requested type
//
//  Arguments: 
//        [in]  REFCLSID  
//      [in]  REFIID    
//      [out] LPVOID -   class factory
//              
//
//  Returns:
//        HRESULT
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

extern "C" HRESULT APIENTRY 
DllGetClassObject(
    /*[in]*/    REFCLSID rclsid,
    /*[in]*/    REFIID riid,
    /*[out]*/    LPVOID * ppv
    )
{
    HRESULT         hr;

    CSAEventFactory *pEventFactory;
    TRACE(" SANetworkMonitor: DllGetClassObject be called");

    //
    //  Verify the caller
    //
    if (CLSID_SaNetEventProvider != rclsid) 
    {
        TRACE(" SANetworkMonitor: DllGetClassObject Failed<not match CLSID>");
        return E_FAIL;
    }

    //
    // Check the interface we can provided
    //
    if (IID_IUnknown != riid && IID_IClassFactory != riid)
    {
        TRACE(" SANetworkMonitor: DllGetClassObject Failed<no the interface>");
        return E_NOINTERFACE;
    }

    //
    // Get a new class factory
    //
    pEventFactory = new CSAEventFactory(rclsid);

    if (!pEventFactory)
    {
        TRACE(
            " SANetworkMonitor: DllGetClassObject Failed<new CSAEventFactory>"
            );
        return E_OUTOFMEMORY;
    }

    //
    // Get an instance according to the reqeryed intrerface
    //
    hr = pEventFactory->QueryInterface(riid, ppv);

    if (FAILED(hr))
    {
        TRACE(" SANetworkMonitor: DllGetClassObject Failed<QueryInterface");
        delete pEventFactory;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  Function:   
//        DllCanUnloadNow
//
//  Description: 
//        determine if the DLL can be unloaded
//
//  Arguments: 
//        NONE
//
//  Returns:
//        HRESULT
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

extern "C" HRESULT APIENTRY 
DllCanUnloadNow(
            void
            )
{
    SCODE sc = TRUE;

    if (CSACounter::GetLockCount() || CSACounter::GetObjectCount())
        sc = S_FALSE;

    return sc;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  Function:   
//        DllRegisterServer
//
//  Description: 
//        Standard OLE entry point for registering the server
//
//  Arguments: 
//        NONE
//
//  Returns:
//        HRESULT
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

extern "C" HRESULT APIENTRY 
DllRegisterServer(
            void
            )
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];

    //
    // First, get the file name of the module
    //
    DWORD dwResult = GetModuleFileNameW(g_hInstance, Path, 1023);
    if (0 == dwResult)
    {
        return (HRESULT_FROM_WIN32 (GetLastError ()));
    }
    Path[1023] = L'\0';

    // 
    // Convert CLSID to string
    //

    StringFromCLSID(CLSID_SaNetEventProvider, &pGuidStr);
    swprintf(KeyPath, L"CLSID\\%s", pGuidStr);

    HKEY hKey;
    LONG lRes = RegCreateKeyW(HKEY_CLASSES_ROOT, KeyPath, &hKey);
    if (lRes)
    {
        TRACE(" SANetworkMonitor: DllRegisterServer Failed<RegCreateKeyW>");
        return E_FAIL;
    }

    wchar_t *pName = L"Microsoft Server Appliance Network Monitor";
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, wcslen(pName) *
        2 + 2);

    HKEY hSubkey;
    lRes = RegCreateKeyW(hKey, L"InprocServer32", &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, wcslen(Path) *
        2 + 2);
    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, 
        (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  Function:   
//        DllUnregisterServer
//
//  Description: 
//        Standard OLE entry point for unregistering the server
//
//  Arguments: 
//        NONE
//
//  Returns:
//        HRESULT
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

extern "C" HRESULT APIENTRY
DllUnregisterServer(
                void
                )
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];

    StringFromCLSID(CLSID_SaNetEventProvider, &pGuidStr);
    swprintf(KeyPath, L"CLSID\\%s", pGuidStr);

    //
    // Delete InProcServer32 subkey.
    //
    LONG lRes = RegOpenKeyW(HKEY_CLASSES_ROOT, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, L"InprocServer32");
    RegCloseKey(hKey);

    //
    // Delete CLSID GUID key.
    //
    lRes = RegOpenKeyW(HKEY_CLASSES_ROOT, L"CLSID", &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\localui\diskmonitor\saeventfactory.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2000 Microsoft Corporation
//
//  Module Name:
//      SAEventFactory.cpp
//
//  Description:
//      description-for-module
//
//  [Header File:]
//      SAEventFactory.h
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////


#include <windows.h>
#include <stdio.h>

#include <wbemidl.h>
#include <initguid.h>

#include "SAEventFactory.h"
#include "SADiskEvent.h"

extern LONG g_cObj;
extern LONG g_cLock;

//////////////////////////////////////////////////////////////////////////////
//
//  CSAEventFactory::CSAEventFactory
//
//  Description:
//      Class constructor.
//
//  Arguments:
//        [in] ClsIdIn    
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

CSAEventFactory::CSAEventFactory(
    const CLSID    &    ClsIdIn 
    )
{
    m_cRef = 0;
    m_ClsId = ClsIdIn;

    InterlockedIncrement( &g_cObj );
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSAEventFactory::CSAEventFactory
//
//  Description:
//      Class deconstructor.
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////

CSAEventFactory::~CSAEventFactory()
{
    // nothing
    InterlockedDecrement( &g_cObj );
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSAEventFactory::QueryInterface
//
//  Description:
//      An method implement of IUnkown interface.
//
//  Arguments:
//        [in] riidIn        Identifier of the requested interface
//        [out ppvOut        Address of output variable that receives the 
//                        interface pointer requested in iid
//
//    Returns:
//        NOERROR            if the interface is supported
//        E_NOINTERFACE    if not
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CSAEventFactory::QueryInterface(
    REFIID        riidIn, 
    LPVOID *    ppvOut 
    )
{
    *ppvOut = NULL;

    if ( ( IID_IUnknown == riidIn ) 
        || ( IID_IClassFactory==riidIn ) )
    {
        *ppvOut = this;

        AddRef();
        return NOERROR;
    }

    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSAEventFactory::AddRef
//
//  Description:
//      increments the reference count for an interface on an object
//
//    Returns:
//        The new reference count.
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
ULONG 
CSAEventFactory::AddRef()
{
    return ++m_cRef;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSAEventFactory::Release
//
//  Description:
//      decrements the reference count for an interface on an object.
//
//    Returns:
//        The new reference count.
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
ULONG 
CSAEventFactory::Release()
{
    if (0 != --m_cRef)
    {
        return m_cRef;
    }

    delete this;
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSAEventFactory::CreateInstance
//
//  Description:
//      Instance creation.
//
//  Arguments:
//        [in]    riidIn        Reference to the identifier of the interface    
//        [out]    pUnkOuter    Pointer to whether object is or isn't part of 
//                            an aggregate
//                ppvObjOut    Address of output variable that receives the 
//                            interface pointer requested in riid
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CSAEventFactory::CreateInstance(
    LPUNKNOWN    pUnkOuter,
    REFIID        riidIn,
    LPVOID *    ppvObjOut
    )
{
    IUnknown* pObj = NULL;
    HRESULT  hr = E_OUTOFMEMORY;

    //
    //  Defaults
    //
    *ppvObjOut = NULL;

    //
    // We aren't supporting aggregation.
    //
    if ( pUnkOuter )
    {
        return CLASS_E_NOAGGREGATION;
    }

    if (m_ClsId == CLSID_DiskEventProvider)
    {
        pObj = (IWbemProviderInit *) new CSADiskEvent;
    }

    if ( pObj == NULL )
    {
        return hr;
    }

    //
    //  Initialize the object and verify that it can return the
    //  interface in question.
    //                                         
    hr = pObj->QueryInterface( riidIn, ppvObjOut );

    //
    // Kill the object if initial creation or Init failed.
    //
    if ( FAILED( hr ) )
    {
        delete pObj;
    }

    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//
//  CSAEventFactory::LockServer
//
//  Description:
//      Call by client to keep server in memory.
//
//  Arguments:
//        [in] fLockIn    //Increments or decrements the lock count
//
//  History:
//      Xing Jin (i-xingj) 06-Dec-2000
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CSAEventFactory::LockServer(
    BOOL    fLockIn
    )
{
    if ( fLockIn )
    {
        InterlockedIncrement( &g_cLock );
    }
    else
    {
        InterlockedDecrement( &g_cLock );
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\localui\networkmonitor\sacounter.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      SACounter.h
//
//    Implementation Files:
//        SACounter.cpp
//
//  Description:
//      Declare the class CSACounter used to manage the global variable 
//
//  History:
//      1. lustar.li (Guogang Li), creation date in 7-DEC-2000
//
//  Notes:
//      
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _SACOUNTER_H_
#define _SACOUNTER_H_

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CSACounter
//
//  Description:
//      The class is used to manage the global variable used by the COM
//
//  History:
//      1. lustar.li (Guogang Li), creation date in 7-DEC-2000
//--
//////////////////////////////////////////////////////////////////////////////

class CSACounter
{
private:
    //define lock counter and object counter
    static ULONG s_cLock;
    static ULONG s_cObject;
public:
    static ULONG GetLockCount(void);
    static ULONG GetObjectCount(void);
    static void  IncLockCount(void);
    static void  DecLockCount(void);
    static void  IncObjectCount(void);
    static void  DecObjectCount(void);
};

#endif //#ifndef _SACOUNTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\localui\networkmonitor\sacounter.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      SACounter.cpp
//
//  Description:
//      The implement file of class CSACounter 
//
//  History:
//      1. lustar.li (Guogang Li), creation date in 7-DEC-2000
//
//  Notes:
//      
//
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include "SACounter.h"

//
// initial data
//
ULONG CSACounter::s_cLock=0;
ULONG CSACounter::s_cObject=0;

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSACounter::GetLockCount
//
//  Description: 
//        get the lock num of server
//
//  Arguments: 
//        NONE
//
//  Returns:
//        ULONG -- lock num of server
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

ULONG 
CSACounter::GetLockCount(
                    void
                    )
{
    return s_cLock;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSACounter::GetLockCount
//
//  Description: 
//        get the refferance num of server object
//
//  Arguments: 
//        NONE
//
//  Returns:
//        ULONG -- refferance num of server object
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

ULONG 
CSACounter::GetObjectCount(
                        void
                        )
{
    return s_cObject;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSACounter::IncLockCount
//
//  Description: 
//        increase lock num of server
//
//  Arguments: 
//        NONE
//
//  Returns:
//        NONE
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

VOID
CSACounter::IncLockCount(
                    void
                    )
{
    InterlockedIncrement((LONG*)&s_cLock);
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSACounter::DecLockCount
//
//  Description: 
//        decrease lock num of server
//
//  Arguments: 
//        NONE
//
//  Returns:
//        NONE
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

VOID
CSACounter::DecLockCount(
                    void
                    )
{
    InterlockedDecrement((LONG*)&s_cLock);
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSACounter::IncObjectCount
//
//  Description: 
//        increase the refferance num of server object
//
//  Arguments: 
//        NONE
//
//  Returns:
//        NONE
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

VOID 
CSACounter::IncObjectCount(
                        void
                        )
{
    InterlockedIncrement((LONG*)&s_cObject);
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSACounter::DecObjectCount
//
//  Description: 
//        decrease the refferance num of server object
//
//  Arguments: 
//        NONE
//
//  Returns:
//        NONE
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

VOID
CSACounter::DecObjectCount(
                        void
                        )
{
    InterlockedDecrement((LONG*)&s_cObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\localui\networkmonitor\saeventfactory.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      SAEventFactory.h
//
//    Implementation Files:
//        SAEventFactroy.cpp
//
//  Description:
//      Declare the class CSAEventFactroy 
//
//  History:
//      1. lustar.li (Guogang Li), creation date in 7-DEC-2000
//
//  Notes:
//      
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _SAEVENTFACTORY_H_
#define _SAEVENTFACTORY_H_

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CSAEventFactory
//
//  Description:
//      The class factroy of net event provider 
//
//  History:
//      1. lustar.li (Guogang Li), creation date in 7-DEC-2000
//--
//////////////////////////////////////////////////////////////////////////////

class CSAEventFactory : 
    public IClassFactory
{
// 
// Private members
//
private:
    ULONG           m_cRef;
    CLSID           m_ClsId;

//
// Constructor and Destructor
//
public:
    CSAEventFactory(const CLSID & ClsId);
    ~CSAEventFactory();

//
// public methods
//
    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IClassFactory members
    //
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP     LockServer(BOOL);
};

#endif //#ifndef _SAEVENTFACTORY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\localui\networkmonitor\saeventfactory.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      SAEventFactory.cpp
//
//  Description:
//      implement the class CSAEventFactroy
//
//  History:
//      1. lustar.li (Guogang Li), creation date in 7-DEC-2000
//
//  Notes:
//      
//
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>
#include <time.h>
#include <locale.h>

#include <debug.h>
#include <wbemidl.h>

#include "SACounter.h"
#include "SANetEvent.h"
#include "SAEventFactory.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSAEventFactory::CSAEventFactory
//
//  Description: 
//        Constructor
//
//  Arguments: 
//        [in] CLSID - class id
//
//  Returns:
//        NONE
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

CSAEventFactory::CSAEventFactory(
                /*[in]*/ const CLSID & ClsId
                )
{
    m_cRef = 0;
    m_ClsId = ClsId;
    CSACounter::IncObjectCount();
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSAEventFactory::~CSAEventFactory
//
//  Description: 
//        Destructor
//
//  Arguments: 
//        NONE
//
//  Returns:
//        NONE
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

CSAEventFactory::~CSAEventFactory()
{
    // Decrease the number of object
    CSACounter::DecObjectCount();
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSANetEvent::QueryInterface
//
//  Description: 
//        access to interfaces on the object
//
//  Arguments: 
//        [in] REFIID  - Identifier of the requested interface
//        [out] LPVOID - Address of output variable that receives the 
//                     interface pointer requested in iid
//  Returns:
//        STDMETHODIMP - fail/success
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSAEventFactory::QueryInterface(
                    /*[in]*/  REFIID riid,
                    /*[out]*/ LPVOID * ppv
                    )
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
    {
        *ppv = this;
        AddRef();
        return NOERROR;
    }

    TRACE(" SANetworkMonitor: CSAEventFactory Failed<no interface>");
    return E_NOINTERFACE;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSAEventFactory::AddRef
//
//  Description: 
//        inc referrence to the object
//
//  Arguments: 
//        NONE
//
//  Returns:
//        ULONG - current refferrence number
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

ULONG 
CSAEventFactory::AddRef()
{
    return ++m_cRef;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSAEventFactory::Release
//
//  Description: 
//        Dereferrence to the object
//
//  Arguments: 
//        NONE
//
//  Returns:
//        ULONG - current refferrence number
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

ULONG 
CSAEventFactory::Release()
{
    if (0 != --m_cRef)
        return m_cRef;

    delete this;
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSAEventFactory::CreateInstance
//
//  Description: 
//        Creates an uninitialized object
//
//  Arguments: 
//        [in] LPUNKNOWN - is or isn't part of an aggregate
//        [in] REFIID    - Reference to the identifier of the interface
//        [out] LPVOID   - receives the interface pointer
//
//  Returns:
//        STDMETHODIMP
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP
CSAEventFactory::CreateInstance(
            /*in*/ LPUNKNOWN pUnkOuter,
            /*in*/ REFIID riid,
            /*in*/ LPVOID* ppvObj
            )
{
    IUnknown* pObj = NULL;
    HRESULT  hr = E_OUTOFMEMORY;

    //
    //  Defaults
    //
    *ppvObj=NULL;

    //
    // We aren't supporting aggregation.
    //
    if (pUnkOuter)
    {
        TRACE1(
            " SANetworkMonitor: CSAEventFactory::CreateInstance failed %d",
            CLASS_E_NOAGGREGATION
            );
        return CLASS_E_NOAGGREGATION;
    }

    if (m_ClsId == CLSID_SaNetEventProvider)
    {
        pObj = (IWbemProviderInit *) new CSANetEvent;
    }

    if (!pObj)
    {
          TRACE(
            " SANetworkMonitor: CSAEventFactory::CreateInstance failed    \
            <new CSANetEvent>"
            );
      return hr;
    }

    //
    //  Initialize the object and verify that it can return the
    //  interface in question.
    //                                         
    hr = pObj->QueryInterface(riid, ppvObj);

    //
    // Kill the object if initial creation or Init failed.
    //
    if (FAILED(hr))
    {
          TRACE(" SANetworkMonitor: CSAEventFactory::CreateInstance failed \
            <QueryInterface of CSANetEvent>");
        delete pObj;
    }
    
    return hr;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSAEventFactory::LockServer
//
//  Description: 
//        keep a server open in memory
//
//  Arguments: 
//        [in] BOOL - lock or not
//
//  Returns:
//        STDMETHODIMP
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP CSAEventFactory::LockServer(BOOL fLock)
{
    if (fLock)
        CSACounter::IncLockCount();
    else
        CSACounter::DecLockCount();

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\localui\networkmonitor\sanetevent.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      SANetEvent.h
//
//    Implementation Files:
//        SANetEvent.cpp
//
//  Description:
//      Declare the class CSANetEvent 
//
//  History:
//      1. lustar.li (Guogang Li), creation date in 7-DEC-2000
//
//  Notes:
//      
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _SANETEVENT_H_
#define _SANETEVENT_H_

#include "SAQueryNetInfo.h"

//
// Define Guid {9B4612B0-BB2F-4d24-A3DC-B354E4FF595C}
//

DEFINE_GUID(CLSID_SaNetEventProvider,
    0x9B4612B0, 0xBB2F, 0x4d24, 0xA3, 0xDC, 0xB3, 0x54, 0xE4, 0xFF,
    0x59, 0x5C);

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CSANetEvent
//
//  Description:
//      The class generates a new event and delivers it to sink 
//
//  History:
//      1. lustar.li (Guogang Li), creation date in 7-DEC-2000
//--
//////////////////////////////////////////////////////////////////////////////

class CSANetEvent :
    public IWbemEventProvider,
    public IWbemProviderInit
{
//
// Private data
//
private:
    int                 m_eStatus;
    ULONG               m_cRef;
    HANDLE              m_hThread;
    IWbemServices       *m_pNs;
    IWbemObjectSink     *m_pSink;
    IWbemClassObject    *m_pEventClassDef;
    CSAQueryNetInfo        *m_pQueryNetInfo;
            
//
// Public data
//
public:
    enum { Pending, Running, PendingStop, Stopped };

//
// Constructors & Destructors
//
public:
    CSANetEvent();
   ~CSANetEvent();

//
// Private methods
//
private:
    static DWORD WINAPI EventThread(LPVOID pArg);
    void InstanceThread();

//
// public methods
//
public:
    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // Inherited from IWbemEventProvider
    //
    HRESULT STDMETHODCALLTYPE ProvideEvents( 
            /* [in] */ IWbemObjectSink *pSink,
            /* [in] */ long lFlags
            );

    //
    // Inherited from IWbemProviderInit
    //
    HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices *pNamespace,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemProviderInitSink *pInitSink
            );
};

#endif    //_SANETEVENT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\localui\networkmonitor\sanetevent.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      SANetEvent.cpp
//
//  Description:
//      implement the class CSANetEvent 
//
//  History:
//      1. lustar.li (Guogang Li), creation date in 7-DEC-2000
//
//  Notes:
//      
//
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>

#include <debug.h>
#include <wbemidl.h>
#include <tchar.h>

#include "oahelp.inl"
#include "SAEventComm.h"
#include "SANetEvent.h"

//
// Define the registry information
//
#define SA_NETWOARKMONITOR_REGKEY        \
            _T("SOFTWARE\\Microsoft\\ServerAppliance\\DeviceMonitor")
#define SA_NETWORKMONITOR_QUEARY_INTERVAL    _T("NetworkQueryInterval")

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSANetEvent::CSANetEventt
//
//  Description: 
//        Constructor
//
//  Arguments: 
//        NONE
//
//  Returns:
//        NONE
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

CSANetEvent::CSANetEvent()
{
    m_cRef = 0;
    m_pNs = 0;
    m_pSink = 0;
    m_pEventClassDef = 0;
    m_eStatus = Pending;
    m_hThread = 0;
    m_pQueryNetInfo=NULL;
}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSANetEvent::~CSANetEventt
//
//  Description: 
//        Destructor
//
//  Arguments: 
//        NONE
//
//  Returns:
//        NONE
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

CSANetEvent::~CSANetEvent()
{
    if(m_pQueryNetInfo)
        delete m_pQueryNetInfo;

    if (m_hThread)
        CloseHandle(m_hThread);

    if (m_pNs)
        m_pNs->Release();

    if (m_pSink)
        m_pSink->Release();

    if (m_pEventClassDef)
        m_pEventClassDef->Release(); 
}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSANetEvent::QueryInterface
//
//  Description: 
//        access to interfaces on the object
//
//  Arguments: 
//        [in] REFIID  - Identifier of the requested interface
//        [out] LPVOID - Address of output variable that receives the 
//                     interface pointer requested in iid
//  Returns:
//        STDMETHODIMP - fail/success
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

STDMETHODIMP 
CSANetEvent::QueryInterface(
                /*[in]*/  REFIID riid,
                /*[out]*/ LPVOID * ppv
                )
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IWbemEventProvider==riid)
    {
        *ppv = (IWbemEventProvider *) this;
        AddRef();
        return NOERROR;
    }

    if (IID_IWbemProviderInit==riid)
    {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        return NOERROR;
    }
    
    TRACE(" SANetworkMonitor: CSANetEvent::QueryInterface failed \
            <no interface>");
    return E_NOINTERFACE;
}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSANetEvent::AddRef
//
//  Description: 
//        inc referrence to the object
//
//  Arguments: 
//        NONE
//
//  Returns:
//        ULONG - current refferrence number
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

ULONG 
CSANetEvent::AddRef()
{
    return ++m_cRef;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSANetEvent::Release
//
//  Description: 
//        Dereferrence to the object
//
//  Arguments: 
//        NONE
//
//  Returns:
//        ULONG - current refferrence number
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

ULONG
CSANetEvent::Release()
{
    if (0 != --m_cRef)
        return m_cRef;

    // 
    // event provider is shutting down.
    //
    m_eStatus = PendingStop;
    
    return 0;
}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSANetEvent::ProvideEvents
//
//  Description: 
//        signal an event provider to begin delivery of its events
//
//  Arguments: 
//        [in] IWbemObjectSink * - pointer to event sink
//        [in] long - Reserved, It must be zero
//
//  Returns:
//        HRESULT
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

HRESULT
CSANetEvent::ProvideEvents( 
    /*[in]*/ IWbemObjectSink *pSink,
    /*[in]*/ long lFlags
    )
{
    //
    // Copy the sink.
    //
    m_pSink = pSink;
    m_pSink->AddRef();

    //
    // Create the event generation thread.
    //
    DWORD dwTID;
    
    m_hThread = CreateThread(
        0,
        0,
        CSANetEvent::EventThread,
        this,
        0,
        &dwTID
        );

    if(!m_hThread)
    {
        TRACE(" SANetworkMonitor: CSANetEvent::ProvideEvents failed \
            <CreateThread>");
        return WBEM_E_FAILED;
    }
    //
    // Wait for provider to be 'ready'.
    //
    while (m_eStatus != Running)
        Sleep(100);

    return WBEM_NO_ERROR;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSANetEvent::EventThread
//
//  Description: 
//        the thread of generating and delivering event
//
//  Arguments: 
//        [in] LPVOID - the argument input to the thread
//
//  Returns:
//        DWORD - end status of status
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

DWORD WINAPI 
CSANetEvent::EventThread(
                /*[in]*/ LPVOID pArg
                )
{
    //
    // Make transition to the per-instance method.
    // 
    ((CSANetEvent *)pArg)->InstanceThread();
    return 0;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSANetEvent::InstanceThread
//
//  Description: 
//        the main proccesor of thread
//
//  Arguments: 
//        NONE
//
//  Returns:
//        NONE
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

void 
CSANetEvent::InstanceThread()
{
    m_eStatus = Running;
    CBSTR bstrUniqueName   = CBSTR(SA_RESOURCEEVENT_UNIQUENAME);
    CBSTR bstrDisplayInfo  = CBSTR(SA_RESOURCEEVENT_DISPLAYINFORMATION);
    CBSTR bstrCurrentState = CBSTR(SA_RESOURCEEVENT_CURRENTSTATE);

    if ( ((BSTR)bstrUniqueName == NULL) ||
         ((BSTR)bstrDisplayInfo == NULL) ||
         ((BSTR)bstrCurrentState == NULL) )
    {
        TRACE(" SANetworkMonitor:CSANetEvent::InstanceThread failed on memory allocation ");
        return;
    }
        
    while (m_eStatus == Running)
    {
        
        //
        // Spawn a new event object.
        // 
        IWbemClassObject *pEvt = 0;

        HRESULT hRes = m_pEventClassDef->SpawnInstance(0, &pEvt);
        if (hRes != 0)
            continue;
            
        //
        // Generate the network event.
        //
        CVARIANT vUniqueName(SA_NET_EVENT);
        pEvt->Put(
            bstrUniqueName,
            0,
            vUniqueName,
            0
            );


        CVARIANT vDisplayInformationID(
            (LONG)(m_pQueryNetInfo->GetDisplayInformation()));
        pEvt->Put(
            bstrDisplayInfo,
            0,
            vDisplayInformationID,
            0
            );
        
        CVARIANT vCurrentState((LONG)SA_RESOURCEEVENT_DEFAULT_CURRENTSTATE);
        pEvt->Put(
            bstrCurrentState,
            0,
            vCurrentState,
            0
            );

        //
        // Deliver the event to CIMOM.
        // 
        hRes = m_pSink->Indicate(1, &pEvt);
        
        if (FAILED (hRes))
        {
            //
            // If failed, ...
            //
            TRACE(" SANetworkMonitor: CSANetEvent::InstanceThread failed \
                <m_pSink->Indicate>");
        }

        pEvt->Release();                    
    }

    //
    // When we get to here, we are no longer interested in the
    // provider and Release() has long since returned.
    //
    m_eStatus = Stopped;
    delete this;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSANetEvent::Initialize
//
//  Description: 
//        initialize the event provider
//
//  Arguments: 
//        [in] LPWSTR - Pointer to the user name
//        [in] LONG - Reserved. It must be zero
//        [in] LPWSTR - Namespace name for which the provider is being 
//                    initialized
//        [in] LPWSTR - Locale name for which the provider is being initialized
//        [in] IWbemServices * - An IWbemServices pointer back into 
//                    Windows Management
//        [in] IWbemContext * - An IWbemContext pointer associated 
//                    with initialization
//        [in] IWbemProviderInitSink * - report initialization status
//
//  Returns:
//        HRESULT
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

HRESULT 
CSANetEvent::Initialize( 
            /* [in] */ LPWSTR pszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR pszNamespace,
            /* [in] */ LPWSTR pszLocale,
            /* [in] */ IWbemServices *pNamespace,
            /* [in] */ IWbemContext *pCtx,
            /* [in] */ IWbemProviderInitSink *pInitSink
            )
{
    HKEY hKey;
    UINT uiQueryInterval;
    DWORD dwRegType = REG_DWORD;
    DWORD dwRegSize = sizeof(DWORD);
    //
    // We don't care about most of the incoming parameters in this
    // simple sample.  However, we will save the namespace pointer
    // and get our event class definition.
    //
    m_pNs = pNamespace;
    m_pNs->AddRef();    

    //
    // Grab the class definition for the event.
    //
    IWbemClassObject *pObj = 0;
    CBSTR bstrClassName = CBSTR(SA_RESOURCEEVENT_CLASSNAME);

    if ( (BSTR)bstrClassName == NULL)
    {
        TRACE(" SANetworkMonitor:CSANetEvent::Initialize failed on memory allocation ");
        return E_OUTOFMEMORY;
    }


    HRESULT hRes = m_pNs->GetObject(
        bstrClassName,          
        0,                          
        pCtx,  
        &pObj,
        0
        );

    if (hRes != 0)
    {
        return WBEM_E_FAILED;
    }

    m_pEventClassDef = pObj;

    //
    // From registry get the interval of query network
    //
    LONG lRes = RegOpenKey(
                    HKEY_LOCAL_MACHINE, 
                    SA_NETWOARKMONITOR_REGKEY,
                    &hKey);
    if (lRes)
    {
        TRACE(" SANetworkMonitor: CSANetEvent::Initialize failed \
            <RegOpenKey>");
        //
        // Create the Key
        //
        lRes = RegCreateKey(
                    HKEY_LOCAL_MACHINE,
                    SA_NETWOARKMONITOR_REGKEY,
                    &hKey);
        if(lRes)
        {
            TRACE(" SANetworkMonitor: CSANetEvent::Initialize failed \
                <RegCreateKey>");
            return WBEM_E_FAILED;
        }
    }
    lRes = RegQueryValueEx(
                        hKey,
                        SA_NETWORKMONITOR_QUEARY_INTERVAL,
                        NULL,
                        &dwRegType,
                        (LPBYTE)&uiQueryInterval,
                        &dwRegSize);
    if(lRes)
    {
        TRACE(" SANetworkMonitor: CSANetEvent::Initialize failed \
            <RegQueryValueEx>");
        uiQueryInterval = 1000;
        lRes = RegSetValueEx(
                        hKey,
                        SA_NETWORKMONITOR_QUEARY_INTERVAL,
                        NULL,
                        REG_DWORD,
                        (LPBYTE)&uiQueryInterval,
                        sizeof(DWORD));
        if(lRes)
        {
            TRACE(" SANetworkMonitor: CSANetEvent::Initialize failed \
                <RegSetValueEx>");
            RegCloseKey(hKey);
            return WBEM_E_FAILED;
        }
    }
    
    RegCloseKey(hKey);

    //
    // Initial m_pQueryNetInfo
    //
    m_pQueryNetInfo = NULL;
    m_pQueryNetInfo = new CSAQueryNetInfo(m_pNs, uiQueryInterval);
    if( (m_pQueryNetInfo == NULL) || (!m_pQueryNetInfo->Initialize()) )
    {
        if (m_pQueryNetInfo)
        {
            delete m_pQueryNetInfo;
        }

        pObj->Release();
        
        TRACE(" SANetworkMonitor: CSANetEvent::Initialize failed \
            <Init CSAQueryNetInfo>");
        return WBEM_E_FAILED;
    }

    //
    // Tell CIMOM that we're up and running.
    // 
    pInitSink->SetStatus(WBEM_S_INITIALIZED,0);
    
    return WBEM_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\localui\networkmonitor\saquerynetinfo.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      SAQueryNetInfo.cpp
//
//  Description:
//      implement the class CSAQueryNetInfo
//
//  History:
//      1. lustar.li (Guogang Li), creation date in 7-DEC-2000
//
//  Notes:
//      
//
//////////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <stdio.h>

#include <debug.h>
#include <wbemidl.h>

#include <SAEventcomm.h>
#include <oahelp.inl>
#include "SAQueryNetInfo.h"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSAQueryNetInfo::CSAQueryNetInfo
//
//  Description: 
//        Constructor
//
//  Arguments: 
//        [in] IWbemServices * - pointer to IWbemServices
//        [in] UINT - the interval of generate event
//
//  Returns:
//        NONE
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

CSAQueryNetInfo::CSAQueryNetInfo(
        /*[in]*/ IWbemServices * pNS,
        /*[in]*/ UINT uiInterval
        )
{
    m_uiQueryInterval = uiInterval;
    m_bLinkCable = TRUE;
    m_bFirstQuery = TRUE;
    m_nPacketsSent = 0;
    m_nPacketsCurrentSent = 0;
    m_nPacketsReceived = 0;
    m_nPacketsCurrentReceived = 0;
    m_pNs = pNS;
    m_pWmiNs = NULL;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSAQueryNetInfo::~CSAQueryNetInfo
//
//  Description: 
//        Destructor
//
//  Arguments: 
//        NONE
//
//  Returns:
//        NONE
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

CSAQueryNetInfo::~CSAQueryNetInfo()
{
    if(m_pWmiNs)
        m_pWmiNs->Release();
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSAQueryNetInfo::GetDisplayInformation
//
//  Description: 
//        return the display information ID
//
//  Arguments: 
//        NONE
//
//  Returns:
//        UINT
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

UINT 
CSAQueryNetInfo::GetDisplayInformation()
{
    //
    // Generate an event one second
    //
    Sleep(m_uiQueryInterval);

    //
    // Get network information
    //
    if(!GetNetConnection()||!GetNetInfo())
            return SA_NET_DISPLAY_IDLE;

    //
    // first query
    //
    if(m_bFirstQuery)
    {
        m_bFirstQuery=!m_bFirstQuery;
        return SA_NET_DISPLAY_IDLE;
    }

    if(!m_bLinkCable)
    {
        return SA_NET_DISPLAY_NO_CABLE;
    }
    else if(m_nPacketsCurrentReceived||m_nPacketsCurrentSent)
    {
        return SA_NET_DISPLAY_TRANSMITING;
    }
    else
        return SA_NET_DISPLAY_IDLE;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSAQueryNetInfo::GetNetInfo
//
//  Description: 
//        get net info from wmi
//
//  Arguments: 
//        NONE
//
//  Returns:
//        BOOL
//
//  History:    lustar.li    Created     12/7/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

BOOL 
CSAQueryNetInfo::GetNetInfo()
{
    
    HRESULT        hr;
    VARIANT        vVal;
    ULONG uReturned;
    UINT uiPacketsSent = 0;
    UINT uiPacketsReceived = 0;
    IEnumWbemClassObject *pEnum = NULL;
    IWbemClassObject *pPerfInst  = NULL;

    CBSTR bstrClassName = CBSTR(SANETCLASSNAME);
    CBSTR bstrPropName1 = CBSTR(SANETRECEIVEPACKET);
    CBSTR bstrPropName2 = CBSTR(SANETSENDPACKET);

    if ( ((BSTR)bstrClassName == NULL) ||
         ((BSTR)bstrPropName1 == NULL) ||
         ((BSTR)bstrPropName2 == NULL) )
    {
        TRACE(" SANetworkMonitor: CSAQueryNetInfo::GetNetInfo failed on memory allocation ");
        return FALSE;
    }

    //
    // Create the object enumerator to net transfer
    //
    hr = m_pNs->CreateInstanceEnum( bstrClassName,
                                    WBEM_FLAG_SHALLOW,
                                    NULL,
                                    &pEnum );
    if(hr == WBEM_NO_ERROR)
    {
        while ( pEnum->Next( INFINITE,
                         1,
                         &pPerfInst,
                         &uReturned ) == WBEM_NO_ERROR )
        {

            //
            // Get the property of "PacketsReceivedUnicastPersec"
            //
            if ( ( pPerfInst->Get( bstrPropName1, 
                                   0L, 
                                   &vVal, 
                                   NULL, NULL ) ) != WBEM_NO_ERROR ) 
            {
                pPerfInst->Release( );
                pEnum->Release();
                TRACE(" SANetworkMonitor: CSAQueryNetInfo::GetNetInfo failed \
                        <Get PacketsReceivedUnicastPersec>");
                return FALSE;
            }
                    
            uiPacketsReceived+=vVal.uintVal;
            
            //
            // Get the property of "PacketsSentUnicastPersec"
            //
            VariantInit(&vVal);

            if ( ( pPerfInst->Get( bstrPropName2, 
                                   0L, 
                                   &vVal, 
                                   NULL, NULL ) ) != WBEM_NO_ERROR ) 
            {
                pPerfInst->Release( );
                pEnum->Release();
                TRACE(" SANetworkMonitor: CSAQueryNetInfo::GetNetInfo failed \
                        <Get PacketsSentUnicastPersec>");
                return FALSE;
            }
                    
            uiPacketsSent+=vVal.uintVal;

            pPerfInst->Release( );
        }
    }
    else
    {
        TRACE(" SANetworkMonitor: CSAQueryNetInfo::GetNetInfo failed \
                <Create the object enumerator>");
        return FALSE;
    }
    pEnum->Release();
    //
    // update the data in this class
    //
    m_nPacketsCurrentReceived = uiPacketsReceived-m_nPacketsReceived;
    m_nPacketsReceived = uiPacketsReceived;

    m_nPacketsCurrentSent = uiPacketsSent-m_nPacketsSent;
    m_nPacketsSent = uiPacketsSent;
    
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSAQueryNetInfo::Initialize()
//
//  Description: 
//        complete the initialize of the class
//
//  Arguments: 
//        NONE
//
//  Returns:
//        BOOL
//
//  History:    lustar.li    Created     12/8/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

BOOL 
CSAQueryNetInfo::Initialize()
{
    HRESULT hr;
    IWbemLocator    *pIWbemLocator  = NULL;
    IWbemServices    *pIWbemServices = NULL;

    if(!m_pNs)
    {
        TRACE(" SANetworkMonitor: CSAQueryNetInfo::Initialize failed \
                <Namespace is NULL>");
        return FALSE;
    }

    CBSTR bstrNameSpace = CBSTR(SAWMINAMESPACE);
    if ((BSTR)bstrNameSpace == NULL)
    {
        TRACE(" SANetworkMonitor: CSAQueryNetInfo::Initialize failed on memory allocation ");
        return FALSE;
    }

    if ( CoCreateInstance( CLSID_WbemAdministrativeLocator,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IWbemLocator,
                           (LPVOID *) &pIWbemLocator ) == S_OK )
    {
        hr = pIWbemLocator->ConnectServer( bstrNameSpace,
                                           NULL,
                                           NULL,
                                           0L,
                                           0L,
                                           NULL,
                                           NULL,
                                           &m_pWmiNs );
        if(hr!=WBEM_S_NO_ERROR)
        {
            pIWbemLocator->Release();
            TRACE(" SANetworkMonitor: CSAQueryNetInfo::Initialize failed \
                <cannot connect server>");
            return FALSE;
        }
    }
    else
    {
        TRACE(" SANetworkMonitor: CSAQueryNetInfo::Initialize failed \
            <CoCreateInstance fail>");
        return FALSE;
    }

    pIWbemLocator->Release();
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  method:   
//        CSAQueryNetInfo::GetNetConnection()
//
//  Description: 
//        get the net connection status
//
//  Arguments: 
//        NONE
//
//  Returns:
//        BOOL
//
//  History:    lustar.li    Created     12/8/2000
//
//--
//////////////////////////////////////////////////////////////////////////////

BOOL 
CSAQueryNetInfo::GetNetConnection()
{
    HRESULT        hr;
    VARIANT        vVal;
    ULONG uReturned;
    IEnumWbemClassObject *pEnum = NULL;
    IWbemClassObject *pPerfInst  = NULL;

    m_bLinkCable=TRUE;

    CBSTR bstrClassName = CBSTR(SAMEDIACLASSNAME);
    CBSTR bstrPropName = CBSTR(SAMEDIACONNECTSTATUS);

    if ( ((BSTR)bstrClassName == NULL) || ((BSTR)bstrPropName == NULL) )
    {
        TRACE(" SANetworkMonitor: CSAQueryNetInfo::GetNetConnection failed on memory allocation ");
        return FALSE;
    }

    //
    // Query the status of network connection
    //
    hr = m_pWmiNs->CreateInstanceEnum( bstrClassName,
                                             WBEM_FLAG_SHALLOW,
                                             NULL,
                                             &pEnum );
    if(hr == WBEM_NO_ERROR)
    {
        while ( pEnum->Next( INFINITE,
                         1,
                         &pPerfInst,
                         &uReturned ) == WBEM_NO_ERROR )
        {
            //
            // Get the property of "NdisMediaConnectStatus"
            //
            if ( ( pPerfInst->Get( bstrPropName, 
                                   0L, 
                                   &vVal, 
                                   NULL, NULL ) ) != WBEM_NO_ERROR ) 
            {
                pPerfInst->Release( );
                pEnum->Release();
                TRACE(" SANetworkMonitor: CSAQueryNetInfo::GetNetConnection \
                    failed <Get NdisMediaConnectStatus>");
                return FALSE;
            }

            pPerfInst->Release( );
            if(vVal.uintVal)
            {
                m_bLinkCable = FALSE;
                break;
            }
            else
            {
                continue;
            }
        }
    }
    else
    {
        TRACE(" SANetworkMonitor: CSAQueryNetInfo::GetNetConnection failed \
            <CreateInstanceEnum>");
        return FALSE;
    }
    
    pEnum->Release();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\localui\networkmonitor\saquerynetinfo.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (C) 1999-2001 Microsoft Corporation
//
//  Module Name:
//      SAQueryNetInfo.h
//
//    Implementation Files:
//        SAQueryNetInfo.cpp
//
//  Description:
//      Declare the class CSANetEvent
//
//  History:
//      1. lustar.li (Guogang Li), creation date in 7-DEC-2000
//
//  Notes:
//      
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _SAQUERYNETINFO_H_
#define _SAQUERYNETINFO_H_

#define SAWMINAMESPACE            L"\\\\.\\root\\WMI"

#define SANETCLASSNAME            L"Win32_PerfRawData_Tcpip_NetworkInterface"
#define SANETRECEIVEPACKET        L"PacketsReceivedUnicastPersec"
#define SANETSENDPACKET            L"PacketsSentUnicastPersec"

#define SAMEDIACLASSNAME        L"MSNdis_MediaConnectStatus"
#define SAMEDIACONNECTSTATUS    L"NdisMediaConnectStatus"

//////////////////////////////////////////////////////////////////////////////
//++
//
//  class CSAQueryNetInfo
//
//  Description:
//      The class is used to get net info from wmi
//
//  History:
//      1. lustar.li (Guogang Li), creation date in 7-DEC-2000
//--
//////////////////////////////////////////////////////////////////////////////

class CSAQueryNetInfo  
{
//
// Private member
//
private:
    UINT m_uiQueryInterval;        // the interval of query

    BOOL m_bLinkCable;            // have cable?
    BOOL m_bFirstQuery;            // is first query net information ?

    //
    // Describe the sent packets
    //
    UINT m_nPacketsSent;
    UINT m_nPacketsCurrentSent;
    
    //
    // Describe the received packets
    //
    UINT m_nPacketsReceived;
    UINT m_nPacketsCurrentReceived;

    IWbemServices   *m_pNs;        // pointer to namespace
    IWbemServices   *m_pWmiNs;    // pointer to \root\wmi namespace

//
// Constructor and destructor
//
public:
    CSAQueryNetInfo(
        IWbemServices * pNS,
        UINT uiInterval = 1000
        );
    virtual ~CSAQueryNetInfo();

//
// Private methods
//
private:
    BOOL GetNetConnection();
    BOOL GetNetInfo();

//
// Public methods 
//
public:
    BOOL Initialize();
    UINT GetDisplayInformation();
};

#endif //#ifndef _SAQUERYNETINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\network\mssanic\mediastate.cpp ===
// MediaState.cpp : Implementation of CMediaState

//
//
//
//
#include "stdafx.h"

#include "MSSANic.h"
#include "MediaState.h"
#include "lm.h"
#include "subauth.h"
#include "ndispnp.h"

VOID  RtlInitUnicodeString( PUNICODE_STRING DestinationString, PCWSTR SourceString OPTIONAL );

#define DEVICE_PREFIX_W     L"\\Device\\"

/////////////////////////////////////////////////////////////////////////////
// CMediaState

STDMETHODIMP CMediaState::InterfaceSupportsErrorInfo(REFIID riid)
{
    static const IID* arr[] = 
    {
        &IID_IMediaState
    };
    for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
    {
        if (InlineIsEqualGUID(*arr[i],riid))
            return S_OK;
    }
    return S_FALSE;
}

    
//////////////////////////////////////////////////////////////////////////////
//
//  CMediaState::IsConnected
//
//  Description:
//
//  Arguments:
//      [in] bstrGUID        The Device GUID 
//
//    Returns:
//        TRUE                 if the device is connected
//        FALSE                if not
//
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CMediaState::IsConnected(BSTR bstrGUID, VARIANT_BOOL *fConnected)
{

    HRESULT hr = S_OK;

    try
    {

        WCHAR Device[512], *pDevice;
        ULONG Len;
        UNICODE_STRING NdisDevice;
        NIC_STATISTICS NdisStats;

        *fConnected = VARIANT_FALSE;
    
        //
        // First convert LPSTR to LPWSTR
        //
        if( NULL == bstrGUID )
        {
            hr = E_FAIL;
            throw hr;
        }
        //
        // Format the device path.
        //
        int cchWritten = _snwprintf(Device,
                                    sizeof(Device) / sizeof(Device[0]),
                                    L"%s%s",
                                    DEVICE_PREFIX_W,
                                    bstrGUID);
        if( 0 > cchWritten || sizeof(Device) / sizeof(Device[0]) <= cchWritten )
        {
            hr = E_FAIL;
            throw hr;
        }

        ZeroMemory( &NdisStats, sizeof(NdisStats) );
        NdisStats.Size = sizeof( NdisStats );

        RtlInitUnicodeString(&NdisDevice, Device);

        //
        // NdisQueryStatistics is an undocumented API that returns the status of the device
        //
        
        if( FALSE == NdisQueryStatistics(&NdisDevice, &NdisStats) ) 
        {
            ULONG Error;
        
            //
            // Could not get statistics.. use default answer.
            //

            Error = GetLastError();
            if( ERROR_NOT_READY == Error ) 
            {
                *fConnected = VARIANT_FALSE;
                hr = S_OK;
                throw hr;
            }
        
            hr = E_FAIL;
            throw hr;;
        }

        if( NdisStats.MediaState == MEDIA_STATE_DISCONNECTED ) 
        {
            *fConnected = VARIANT_FALSE;
        } else if( NdisStats.MediaState == MEDIA_STATE_CONNECTED ) 
        {
            *fConnected = VARIANT_TRUE;
        }
        else 
        {
            //
            // unknown media state? fail request
            //
            hr = E_FAIL;
            throw hr;
        }    

    }
    catch(...)
    {
    }

    return hr;
}



//////////////////////////////////////////////////////////////////////////////
//
//Routine Description:
//
//    The RtlInitUnicodeString function initializes an NT counted
//    unicode string.  The DestinationString is initialized to point to
//    the SourceString and the Length and MaximumLength fields of
//    DestinationString are initialized to the length of the SourceString,
//    which is zero if SourceString is not specified.
//
//Arguments:
//
//    DestinationString - Pointer to the counted string to initialize
//
//    SourceString - Optional pointer to a null terminated unicode string that
//        the counted string is to point to.
//
//
//Return Value:
//
//    None.
//
//////////////////////////////////////////////////////////////////////////////

VOID RtlInitUnicodeString( PUNICODE_STRING DestinationString, PCWSTR SourceString OPTIONAL )
{
    ULONG Length;

    DestinationString->Buffer = (PWSTR)SourceString;
    Length = wcslen( SourceString ) * sizeof( WCHAR );
    DestinationString->Length = (USHORT)Length;
    DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\network\mssanic\nicinfo.cpp ===
// NicInfo.cpp: implementation of the CNicInfo class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "NicInfo.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CNicInfo::CNicInfo()
{

}

CNicInfo::~CNicInfo()
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\network\mssanic\mediastate.h ===
// MediaState.h : Declaration of the CMediaState

#ifndef __MEDIASTATE_H_
#define __MEDIASTATE_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CMediaState
class ATL_NO_VTABLE CMediaState : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CMediaState, &CLSID_MediaState>,
    public ISupportErrorInfo,
    public IDispatchImpl<IMediaState, &IID_IMediaState, &LIBID_MSSANICLib>
{
public:
    CMediaState()
    {
        m_pUnkMarshaler = NULL;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_MEDIASTATE)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMediaState)
    COM_INTERFACE_ENTRY(IMediaState)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(ISupportErrorInfo)
    COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

    HRESULT FinalConstruct()
    {
        return CoCreateFreeThreadedMarshaler(
            GetControllingUnknown(), &m_pUnkMarshaler.p);
    }

    void FinalRelease()
    {
        m_pUnkMarshaler.Release();
    }

    CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
    STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IMediaState
public:

    STDMETHOD(IsConnected)(BSTR bstrGUID, VARIANT_BOOL *pbRet);
};

#endif //__MEDIASTATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\network\mssanic\niciterator.h ===
// NicIterator.h: interface for the CNicIterator class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_NICITERATOR_H__D77EC672_6E63_4EB4_9AEC_4F1585532CC3__INCLUDED_)
#define AFX_NICITERATOR_H__D77EC672_6E63_4EB4_9AEC_4F1585532CC3__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CNicIterator  
{
public:
    CNicIterator();
    virtual ~CNicIterator();

private:
    void LoadNicInfo();

    vector<CNicInfo> m_vNicCards;
};

#endif // !defined(AFX_NICITERATOR_H__D77EC672_6E63_4EB4_9AEC_4F1585532CC3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\network\mssanic\niciterator.cpp ===
// NicIterator.cpp: implementation of the CNicIterator class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "NicIterator.h"

#include "Tracing.h"

//
// Constant data
//
WCHAR REGKEY_NETWORK[] = L"System\\CurrentControlSet\\Control\\Network";

//
// Private data structures
//
struct RegData {
    union {
        WCHAR wstrValue[1024];
        DWORD dwValue;
    }Contents;
};


//
// Private non-member functions
//
static bool FindNICAdaptersRegKey(wstring& wszNicAdaptersRegKey);




void CNicIterator::LoadNicInfo()
{
USES_CONVERSION;

    m_vNicInfo.clear();

    HKEY hkNicAdapters;

    wstring wstrNicAdaptersRegKey;

    if ( FindNICAdaptersRegKey( wstrNicAdaptersRegKey ))
    {


        if ( ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE, 
                                wstrNicAdaptersRegKey.c_str(), &hkNicAdapters ))
        {
            WCHAR wszName[1024];
            DWORD dwNicAdapterIndex = 0;

            while ( ERROR_SUCCESS == RegEnumKey( hkNicAdapters, dwNicAdapterIndex, wszName, sizeof(wszName)))
            {
                SATraceString(W2A(wszName));

                HKEY hkNics;
                DWORD dwNicIndex = 0;
                wstring wstrNics(wstrNicAdaptersRegKey);

                wstrNics.append(L"\\");
                wstrNics.append(wszName);
                wstrNics.append(L"\\Connection");

                SATraceString( W2A(wstrNics.c_str()) );

                if ( ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE, 
                                            wstrNics.c_str(), &hkNics ))
                {
                    DWORD dwRegType;
                    RegData regData;
                    DWORD dwSizeOfRegType = sizeof(regData);
                    DWORD dwSizeOfName = sizeof(wszName);

                    SATraceString("Enumerating values");

                    CNicInfo nicInfo;
                    nicInfo.wstrRegKey = wstrNics;
                    DWORD dwNicAttributes = 0;

                    while ( ERROR_SUCCESS == RegEnumValue( hkNics, 
                                                            dwNicIndex, 
                                                            wszName, 
                                                            &dwSizeOfName,
                                                            0,
                                                            &dwRegType,
                                                            (BYTE*)&regData,
                                                            &dwSizeOfRegType))
                    {                                
                        if ( dwRegType == REG_SZ )
                        {
                            if ( lstrcmpi(L"PnpInstanceID", wszName) == 0 )
                            {
                                nicInfo.wstrPNPInstanceID = regData.Contents.wstrValue;
                                dwNicAttributes++;
                            }
                            else if ( lstrcmpi(L"Name", wszName) == 0 )
                            {
                                nicInfo.wstrName = regData.Contents.wstrValue;
                                dwNicAttributes++;
                            }
                        }
                        dwNicIndex++;
                    }
                    if ( dwNicAttributes >= 2 )
                    {
                        m_vNicInfo.push_back(nicInfo);
                    }

                    RegCloseKey( hkNics );
                }
                dwNicAdapterIndex++;
            } // while RegEnumKey ( hkNicAdapters..)
            RegCloseKey(hkNicAdapters);
        }
    }

    return;
}



static bool FindNICAdaptersRegKey(wstring& wszNicAdaptersRegKey)
{
    HKEY hk;
    bool bRc = false;

    if ( ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_NETWORK, &hk ))
    {
        DWORD dwIndex = 0;
        WCHAR wszName[1024];
        while ( ERROR_SUCCESS == RegEnumKey( hk, dwIndex, wszName, sizeof(wszName)))
        {

            WCHAR wszValue[1024];
            LONG lSizeOfValue = sizeof(wszValue);
            
            //
            // Check the value of this key
            //
            if ( ERROR_SUCCESS == RegQueryValue( hk, wszName, wszValue, &lSizeOfValue)
                && lstrcmpi(L"Network Adapters", wszValue) == 0 )
            {
                //
                // Found the Network Adapters reg key
                //
                wstring wstrNicAdapters(REGKEY_NETWORK);

                wstrNicAdapters.append(L"\\");
                wstrNicAdapters.append(wszName);

                wszNicAdaptersRegKey = wstrNicAdapters;
                bRc = true;
            }

            //
            // Next enumeration element
            dwIndex++;
        }
        RegCloseKey(hk);
    }

    return bRc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\network\mssanic\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\network\mssanic\mssanic.cpp ===
// MSSANic.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f MSSANicps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "MSSANic.h"

#include "MSSANic_i.c"
#include "NicName.h"
#include "Mediastate.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_NicName, CNicName)
OBJECT_ENTRY(CLSID_MediaState, CMediaState )
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
    _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\network\mssanic\nicinfo.h ===
#ifndef NicInfo_Included
#define NicInfo_Included

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <string>
using namespace std;

//+------------------------------------------------------------------
//
// Class:        CNicInfo
//
// Synopsis:    Thin wrapper to maintain state and storage info
//                for user friendly NIC name.
//
//                The W2K Win32_NetworkAdapter WMI provider does not
//                provide access to the user friendly NIC name. This
//                class provides access to that attribute for use with
//                the Microsoft Network Attached Storage (NAS) 
//                Appliance product.
//
// History:        JKountz        08/19/2000    Created
//
//+------------------------------------------------------------------
class CNicInfo  
{
public:
    CNicInfo();
    virtual ~CNicInfo();

    //
    // Reg key
    //
    wstring m_wstrRegKey;

    //
    // Win32_NetworkAdapter.PNPDeviceID
    //
    wstring m_wstrPNPDeviceID;

    //
    // User friendly name
    //
    wstring m_wstrName;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\network\mssanic\nicname.h ===
#ifndef __NICNAME_H_
#define __NICNAME_H_

#include "resource.h"       // main symbols
#include "NicInfo.h"
#include <vector>
using namespace std;

class ATL_NO_VTABLE CNicName : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CNicName, &CLSID_NicName>,
    public IDispatchImpl<INicName, &IID_INicName, &LIBID_MSSANICLib>
{
public:
    CNicName();

DECLARE_REGISTRY_RESOURCEID(IDR_NICNAME)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CNicName)
    COM_INTERFACE_ENTRY(INicName)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// INicName
public:
    STDMETHOD(Set)(/*[in]*/ BSTR bstrPnpDeviceID, BSTR bstrName);
    STDMETHOD(Get)(/*[in]*/ BSTR bstrPnpDeviceID, /*[out,retval]*/ BSTR* pbstrFriendlyName);

private:
    DWORD Store(CNicInfo& rNicInfo);
    void LoadNicInfo();
    vector<CNicInfo> m_vNicInfo;
};

#endif //__NICNAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\network\mssanic\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by MSSANic.rc
//
#define IDS_PROJNAME                    100
#define IDR_NICNAME                     101
#define IDR_MEDIASTATE            102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\network\mssanic\tracing.h ===
#ifndef Tracing_Included
#define Tracing_Included


inline void SATraceString(const char* pcszMessage)
{
    FILE* hf = fopen("C:\\WINNT\\Tracing\\SANicName.log", "a");

    fprintf( hf, "%s\n", pcszMessage);
    fclose(hf);
}

inline void SATraceFailure(const char* pcszMessage, DWORD dwError)
{
    FILE* hf = fopen("C:\\WINNT\\Tracing\\SANicName.log", "a");

    fprintf( hf, "%s   (Win32 Error: %ld)\n", pcszMessage, dwError);
    fclose(hf);
    
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\network\mssanic\nicname.cpp ===
// NicName.cpp : Implementation of CNicName
#include "stdafx.h"
#include "MSSANic.h"
#include "NicName.h"

#include "Tracing.h"
//
// Constant data
//
const WCHAR REGKEY_NETWORK[] = L"SYSTEM\\CurrentControlSet\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}";
const DWORD MAX_REGKEY_VALUE = 1024;

//
// Private data structures
//
struct RegData {
	union {
		WCHAR wstrValue[MAX_REGKEY_VALUE];
		DWORD dwValue;
	}Contents;
};


//
// Private non-member functions
//
static bool FindNICAdaptersRegKey(wstring& wszNicAdaptersRegKey);



//+-----------------------------------------------------------------------
//
// Method:		Constructor
//
// Synopsis:	Construct the CNicName object
//
// History:		JKountz	08/19/2000	Created
//+-----------------------------------------------------------------------
CNicName::CNicName()
{
	//
	// Load the user friendly Nic information from
	// the registry.
	//
	LoadNicInfo();
}


//+-----------------------------------------------------------------------
//
// Method:		Get
//
// Synopsis:	Get the user friendly name for the specified Nic card.
//
// Arguments:	IN bstrPnpDeviceID  Plug and Play Device ID for the Nic
//									card we are lookup up.
//
//				OUT bstrName		Receives the user friendly name for
//									the specified Nic.
//
// History:		JKountz	08/19/2000	Created
//+-----------------------------------------------------------------------
STDMETHODIMP CNicName::Get(BSTR bstrPnpDeviceID, BSTR *pbstrName)
{
	try
	{
		bool bFound = false;
		vector<CNicInfo>::iterator it;
		wstring wstrPNPDeviceID(bstrPnpDeviceID);

		//
		// Search the list of NIC
		//
		for(it = m_vNicInfo.begin(); it != m_vNicInfo.end(); it++)
		{
			//
			// Does the PnP Device ID match?
			//
			if ( 0 == lstrcmpi( wstrPNPDeviceID.c_str(),
						(*it).m_wstrPNPDeviceID.c_str()))
			{
				*pbstrName = ::SysAllocString((*it).m_wstrName.c_str());
                
				bFound = true;
			}
		}

		//
		// Provide a reasonable alternative if not match was found
		//
		if ( !bFound )
		{
			//
			// BUGBUG: Probably should localize this
			//
			*pbstrName = ::SysAllocString(L"Local Network Connection");
		}

	}

	catch(...)
	{

	}

	return S_OK;
}


//+-----------------------------------------------------------------------
//
// Method:		Set
//
// Synopsis:	Set the user friendly name for the specified Nic card.
//
// Arguments:	IN bstrPnpDeviceID  Plug and Play Device ID for the Nic
//									card we are lookup up.
//
//				IN bstrName			The user friendly name for the 
//									specified Nic.
//
// History:		JKountz	08/19/2000	Created
//+-----------------------------------------------------------------------
STDMETHODIMP CNicName::Set(BSTR bstrPnpDeviceID, BSTR bstrName)
{

	//
	// Default return code is invalid PNP Device ID
	//
	HRESULT hr = E_INVALIDARG;

	try
	{

		vector<CNicInfo>::iterator it;
		wstring wstrPNPDeviceID(bstrPnpDeviceID);

		//
		// Search the list of NIC
		//
		for(it = m_vNicInfo.begin(); it != m_vNicInfo.end(); it++)
		{
			//
			// Does the PnP Device ID match?
			//
			if ( 0 == lstrcmpi( wstrPNPDeviceID.c_str(),
						(*it).m_wstrPNPDeviceID.c_str()))
			{
				(*it).m_wstrName = bstrName;
				if ( ERROR_SUCCESS == Store(*it))
				{
					hr = S_OK;
				}
			}
		}
	}
	catch(...)
	{

	}

	return hr;
}


//+-----------------------------------------------------------------------
//
// Method:		LoadNicInfo
//
// Synopsis:	Preload the Nic information. We enumerate through the 
//				registry looking for all Nic's. For each Nic we create
//				an instance of CNicInfo and store it in a vector
//				class variable. See CNicInfo for more information.
//
// History:		JKountz	08/19/2000	Created
//+-----------------------------------------------------------------------
void CNicName::LoadNicInfo()
{

	//
	// Clear the list of Nic's
	//
	m_vNicInfo.clear();

	//
	// Locate the Network Adapters REG key. All the Nic's
	// are listed under this key.
	//
	HKEY hkNicAdapters;
	wstring wstrNicAdaptersRegKey(REGKEY_NETWORK);
	
	//
	// Open the Network Adapters REG key
	//
	if ( ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE, 
							wstrNicAdaptersRegKey.c_str(), &hkNicAdapters ))
	{
		//
		// Enumerate all the Nic's
		//
		WCHAR wszName[1024];
		DWORD dwNicAdapterIndex = 0;
		while ( ERROR_SUCCESS == RegEnumKey( hkNicAdapters, dwNicAdapterIndex, wszName, (sizeof wszName)/(sizeof wszName[0])))
		{
			HKEY hkNics;
			DWORD dwNicIndex = 0;
			wstring wstrNics(wstrNicAdaptersRegKey);

            wstrNics.append(L"\\");
			wstrNics.append(wszName);
			wstrNics.append(L"\\Connection");

			//
			// Open the Connection sub key. This is where the Pnp Device ID
			// and user friendly name are stored.
			//
			if ( ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE, 
										wstrNics.c_str(), &hkNics ))
			{
				DWORD dwRegType;
				RegData regData;
				DWORD dwSizeOfRegType = sizeof(regData);
				DWORD dwSizeOfName = (sizeof wszName)/(sizeof wszName[0]);

				CNicInfo nicInfo;
				nicInfo.m_wstrRegKey = wstrNics;
				DWORD dwNicAttributes = 0;

				//
				// Enumerate all the values under Connection.
				// We are looking for PNPDeviceID and Name which
				// are both REG_SZ types.
				//
				while ( ERROR_SUCCESS == RegEnumValue( hkNics, 
														dwNicIndex, 
														wszName, 
														&dwSizeOfName,
														0,
														&dwRegType,
														(BYTE*)&regData,
														&dwSizeOfRegType))
				{								
					if ( dwRegType == REG_SZ )
					{
						//
						// Found the PNP Device ID
						//
						if ( lstrcmpi(L"PnpInstanceID", wszName) == 0 )
						{
							nicInfo.m_wstrPNPDeviceID = regData.Contents.wstrValue;
							dwNicAttributes++;
						}

						//
						// Found the user friendly name
						//
						else if ( lstrcmpi(L"Name", wszName) == 0 )
						{
							nicInfo.m_wstrName = regData.Contents.wstrValue;
							dwNicAttributes++;
						}

					}
					dwNicIndex++;
					dwSizeOfRegType = sizeof(regData);
				}

				//
				// Did we find both the Pnp Device ID and user friendly name?
				//
				if ( dwNicAttributes >= 2 )
				{
					// Save them
					m_vNicInfo.push_back(nicInfo);
				}

				RegCloseKey( hkNics );
			}
			dwNicAdapterIndex++;
		} // while RegEnumKey ( hkNicAdapters..)
		RegCloseKey(hkNicAdapters);
	}

	return;
}


//+-----------------------------------------------------------------------
//
// Method:		FindNICAdaptersRegKey
//
// Synopsis:	Locate the Network Adapters REG key. All the Nic info
//				we need is stored under this key. It is located
//				below System\CurrentControlSet\Control\Network
//
// History:		JKountz	08/19/2000	Created
//+-----------------------------------------------------------------------
static bool FindNICAdaptersRegKey(wstring& wszNicAdaptersRegKey)
{
	HKEY hk;
	bool bRc = false;

	if ( ERROR_SUCCESS == RegOpenKey( HKEY_LOCAL_MACHINE, REGKEY_NETWORK, &hk ))
	{
		DWORD dwIndex = 0;
		WCHAR wszName[1024];
		while ( ERROR_SUCCESS == RegEnumKey( hk, dwIndex, wszName, (sizeof wszName)/(sizeof wszName[0])))
		{

			WCHAR wszValue[1024];
			LONG lSizeOfValue = sizeof(wszValue);
			
			//
			// Check the value of this key, we need a value of: Network Adapters
			//
			if ( ERROR_SUCCESS == RegQueryValue( hk, wszName, wszValue, &lSizeOfValue)
				&& lstrcmpi(L"Network Adapters", wszValue) == 0 )
			{
				//
				// Found it
				//
				wstring wstrNicAdapters(REGKEY_NETWORK);

				wstrNicAdapters.append(L"\\");
				wstrNicAdapters.append(wszName);

				wszNicAdaptersRegKey = wstrNicAdapters;
				bRc = true;
			}

			//
			// Next enumeration element
			dwIndex++;
		}
		RegCloseKey(hk);
	}

	return bRc;

}


//+-----------------------------------------------------------------------
//
// Method:		Store
//
// Synopsis:	Store changes to the user friendly Nic name.
//
// Arguments:	IN CNicInfo	 which contains the changed state
//				that needs to be stored. We use the m_wstrRegKey
//				member of CNicInfo to locate the Nic card that
//				needs to be updated.
//
// History:		JKountz	08/19/2000	Created
//+-----------------------------------------------------------------------
DWORD CNicName::Store(CNicInfo &rNicInfo)
{
	DWORD dwRc;
	
	HKEY hkNic;

	dwRc = RegOpenKey( HKEY_LOCAL_MACHINE, 
				rNicInfo.m_wstrRegKey.c_str(), &hkNic );

	if ( ERROR_SUCCESS == dwRc)
	{
		DWORD dwNameLen;

		dwNameLen = sizeof(WCHAR)*(lstrlen(rNicInfo.m_wstrName.c_str()) + 1);

		dwRc = RegSetValueEx(hkNic,
					L"Name",
					0,
					REG_SZ,
					(BYTE*)(rNicInfo.m_wstrName.c_str()),
					dwNameLen);

		RegCloseKey(hkNic);

	}

	if ( ERROR_SUCCESS != dwRc )
	{
		SATraceFailure( "CNicName::Store", dwRc );
	}
	return dwRc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\network\mssanic\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__C2205A99_294F_4ABE_8076_BD2B57FB3EE6__INCLUDED_)
#define AFX_STDAFX_H__C2205A99_294F_4ABE_8076_BD2B57FB3EE6__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

DEFINE_GUID( IID_IMediaState,0xF073520E,0x123D,0x4181,0x96,0xDE,0x55,0xF5,0x45,0xE2,0x6C,0x1E );


DEFINE_GUID( CLSID_MediaState,0xE1C7C840,0xB951,0x4403,0xBD,0x7C,0x5E,0x80,0xA8,0x55,0x25,0x5B);

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C2205A99_294F_4ABE_8076_BD2B57FB3EE6__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\openfiles\openfilescomp\account.h ===
//+-------------------------------------------------------------------
//
// Copyright (C) 1995, Microsoft Corporation.
//
//  File:        account.hxx
//
//  Contents:    class encapsulating NT security user account.
//
//  Classes:     CAccount
//
//  History:     Nov-93        Created         DaveMont
//
//--------------------------------------------------------------------
#ifndef _ACCOUNT_H
#define _ACCOUNT_H

#include "openfilesdef.h"

//+-------------------------------------------------------------------
//
//  Class:      CAccount
//
//  Purpose:    encapsulation of NT Account, this class actually interfaces
//              with the NT security authority to get SIDs for usernames and
//              vis-versa.
//
//--------------------------------------------------------------------
class CAccount
{
public:

    CAccount(WCHAR *Name, WCHAR *System);
    CAccount(SID *pSid, WCHAR *System);

   ~CAccount();

    ULONG GetAccountSid(SID **psid);
    ULONG GetAccountName(WCHAR **name);
    ULONG GetAccountDomain(WCHAR **domain);


private:

    BOOL        _fsid        ;
    SID        *_psid        ;
    WCHAR      *_system      ;
    WCHAR      *_name        ;
    WCHAR      *_domain      ;
};

#endif // __ACCOUNT__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\openfiles\openfilescomp\dumpsec.h ===
//+-------------------------------------------------------------------
//
// Copyright (C) 1995, Microsoft Corporation.
//
//  File:        DUMPSEC.hxx
//
//  Contents:    class encapsulating file security.
//
//  Classes:     CDumpSecurity
//
//  History:     Nov-93        Created         DaveMont
//
//--------------------------------------------------------------------
#ifndef __DUMPSEC__
#define __DUMPSEC__

#include "openfilesdef.h"



VOID * Add2Ptr(VOID *pv, ULONG cb);

//+-------------------------------------------------------------------
//
//  Class:      CDumpSecurity
//
//  Purpose:    encapsulation of NT File security descriptor with functions
//              to get SIDs and iterate through the ACES in the DACL.
//
//--------------------------------------------------------------------
class CDumpSecurity
{
public:

	CDumpSecurity(BYTE	*psd);
    
   ~CDumpSecurity();

ULONG Init();
ULONG GetSDOwner(SID **psid);
ULONG GetSDGroup(SID **pgsid);
VOID  ResetAce(SID *psid);
LONG  GetNextAce(ACE_HEADER **paceh);

private:

    BYTE       * _psd        ;
    ACL        * _pdacl      ;
    ACE_HEADER * _pah        ;
    SID        * _psid       ;
    ULONG        _cacethissid;  // a dinosaur from the cretaceous
};

#endif // __DUMPSEC__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\openfiles\openfilescomp\asptlb.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Mon Nov 03 15:43:09 1997
 */
/* Compiler settings for asp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef ___asptlb_h__
#define ___asptlb_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IStringList_FWD_DEFINED__
#define __IStringList_FWD_DEFINED__
typedef interface IStringList IStringList;
#endif 	/* __IStringList_FWD_DEFINED__ */


#ifndef __IRequestDictionary_FWD_DEFINED__
#define __IRequestDictionary_FWD_DEFINED__
typedef interface IRequestDictionary IRequestDictionary;
#endif 	/* __IRequestDictionary_FWD_DEFINED__ */


#ifndef __IRequest_FWD_DEFINED__
#define __IRequest_FWD_DEFINED__
typedef interface IRequest IRequest;
#endif 	/* __IRequest_FWD_DEFINED__ */


#ifndef __Request_FWD_DEFINED__
#define __Request_FWD_DEFINED__

#ifdef __cplusplus
typedef class Request Request;
#else
typedef struct Request Request;
#endif /* __cplusplus */

#endif 	/* __Request_FWD_DEFINED__ */


#ifndef __IReadCookie_FWD_DEFINED__
#define __IReadCookie_FWD_DEFINED__
typedef interface IReadCookie IReadCookie;
#endif 	/* __IReadCookie_FWD_DEFINED__ */


#ifndef __IWriteCookie_FWD_DEFINED__
#define __IWriteCookie_FWD_DEFINED__
typedef interface IWriteCookie IWriteCookie;
#endif 	/* __IWriteCookie_FWD_DEFINED__ */


#ifndef __IResponse_FWD_DEFINED__
#define __IResponse_FWD_DEFINED__
typedef interface IResponse IResponse;
#endif 	/* __IResponse_FWD_DEFINED__ */


#ifndef __Response_FWD_DEFINED__
#define __Response_FWD_DEFINED__

#ifdef __cplusplus
typedef class Response Response;
#else
typedef struct Response Response;
#endif /* __cplusplus */

#endif 	/* __Response_FWD_DEFINED__ */


#ifndef __IVariantDictionary_FWD_DEFINED__
#define __IVariantDictionary_FWD_DEFINED__
typedef interface IVariantDictionary IVariantDictionary;
#endif 	/* __IVariantDictionary_FWD_DEFINED__ */


#ifndef __ISessionObject_FWD_DEFINED__
#define __ISessionObject_FWD_DEFINED__
typedef interface ISessionObject ISessionObject;
#endif 	/* __ISessionObject_FWD_DEFINED__ */


#ifndef __Session_FWD_DEFINED__
#define __Session_FWD_DEFINED__

#ifdef __cplusplus
typedef class Session Session;
#else
typedef struct Session Session;
#endif /* __cplusplus */

#endif 	/* __Session_FWD_DEFINED__ */


#ifndef __IApplicationObject_FWD_DEFINED__
#define __IApplicationObject_FWD_DEFINED__
typedef interface IApplicationObject IApplicationObject;
#endif 	/* __IApplicationObject_FWD_DEFINED__ */


#ifndef __Application_FWD_DEFINED__
#define __Application_FWD_DEFINED__

#ifdef __cplusplus
typedef class Application Application;
#else
typedef struct Application Application;
#endif /* __cplusplus */

#endif 	/* __Application_FWD_DEFINED__ */


#ifndef __IServer_FWD_DEFINED__
#define __IServer_FWD_DEFINED__
typedef interface IServer IServer;
#endif 	/* __IServer_FWD_DEFINED__ */


#ifndef __Server_FWD_DEFINED__
#define __Server_FWD_DEFINED__

#ifdef __cplusplus
typedef class Server Server;
#else
typedef struct Server Server;
#endif /* __cplusplus */

#endif 	/* __Server_FWD_DEFINED__ */


#ifndef __IScriptingContext_FWD_DEFINED__
#define __IScriptingContext_FWD_DEFINED__
typedef interface IScriptingContext IScriptingContext;
#endif 	/* __IScriptingContext_FWD_DEFINED__ */


#ifndef __ScriptingContext_FWD_DEFINED__
#define __ScriptingContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class ScriptingContext ScriptingContext;
#else
typedef struct ScriptingContext ScriptingContext;
#endif /* __cplusplus */

#endif 	/* __ScriptingContext_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __ASPTypeLibrary_LIBRARY_DEFINED__
#define __ASPTypeLibrary_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ASPTypeLibrary
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 



DEFINE_GUID(LIBID_ASPTypeLibrary,0xD97A6DA0,0xA85C,0x11cf,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#ifndef __IStringList_INTERFACE_DEFINED__
#define __IStringList_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IStringList
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IStringList,0xD97A6DA0,0xA85D,0x11cf,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A85D-11cf-83AE-00A0C90C2BD8")
    IStringList : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT i,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStringListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStringList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStringList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IStringList __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IStringList __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IStringList __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IStringList __RPC_FAR * This,
            /* [in][optional] */ VARIANT i,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IStringListVtbl;

    interface IStringList
    {
        CONST_VTBL struct IStringListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStringList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStringList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStringList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStringList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IStringList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IStringList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IStringList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IStringList_get_Item(This,i,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,i,pVariantReturn)

#define IStringList_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IStringList_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get_Item_Proxy( 
    IStringList __RPC_FAR * This,
    /* [in][optional] */ VARIANT i,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IStringList_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get_Count_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IStringList_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get__NewEnum_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IStringList_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStringList_INTERFACE_DEFINED__ */


#ifndef __IRequestDictionary_INTERFACE_DEFINED__
#define __IRequestDictionary_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRequestDictionary
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IRequestDictionary,0xD97A6DA0,0xA85F,0x11df,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A85F-11df-83AE-00A0C90C2BD8")
    IRequestDictionary : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequestDictionary __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequestDictionary __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequestDictionary __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IRequestDictionary __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IRequestDictionary __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        END_INTERFACE
    } IRequestDictionaryVtbl;

    interface IRequestDictionary
    {
        CONST_VTBL struct IRequestDictionaryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequestDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequestDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequestDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequestDictionary_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequestDictionary_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRequestDictionary_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRequestDictionary_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRequestDictionary_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IRequestDictionary_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#define IRequestDictionary_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IRequestDictionary_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Item_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [in][optional] */ VARIANT Var,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IRequestDictionary_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get__NewEnum_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IRequestDictionary_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Count_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IRequestDictionary_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Key_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IRequestDictionary_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequestDictionary_INTERFACE_DEFINED__ */


#ifndef __IRequest_INTERFACE_DEFINED__
#define __IRequest_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRequest
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IRequest,0xD97A6DA0,0xA861,0x11cf,0x93,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A861-11cf-93AE-00A0C90C2BD8")
    IRequest : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_QueryString( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Form( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [hidden][propget] */ HRESULT STDMETHODCALLTYPE get_Body( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ServerVariables( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ClientCertificate( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_TotalBytes( 
            /* [retval][out] */ long __RPC_FAR *pcbTotal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BinaryRead( 
            /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequest __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequest __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequest __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IRequest __RPC_FAR * This,
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_QueryString )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Form )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [hidden][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Body )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServerVariables )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ClientCertificate )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Cookies )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TotalBytes )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcbTotal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BinaryRead )( 
            IRequest __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn);
        
        END_INTERFACE
    } IRequestVtbl;

    interface IRequest
    {
        CONST_VTBL struct IRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRequest_get_Item(This,bstrVar,ppObjReturn)	\
    (This)->lpVtbl -> get_Item(This,bstrVar,ppObjReturn)

#define IRequest_get_QueryString(This,ppDictReturn)	\
    (This)->lpVtbl -> get_QueryString(This,ppDictReturn)

#define IRequest_get_Form(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Form(This,ppDictReturn)

#define IRequest_get_Body(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Body(This,ppDictReturn)

#define IRequest_get_ServerVariables(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ServerVariables(This,ppDictReturn)

#define IRequest_get_ClientCertificate(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ClientCertificate(This,ppDictReturn)

#define IRequest_get_Cookies(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Cookies(This,ppDictReturn)

#define IRequest_get_TotalBytes(This,pcbTotal)	\
    (This)->lpVtbl -> get_TotalBytes(This,pcbTotal)

#define IRequest_BinaryRead(This,pvarCountToRead,pvarReturn)	\
    (This)->lpVtbl -> BinaryRead(This,pvarCountToRead,pvarReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Item_Proxy( 
    IRequest __RPC_FAR * This,
    /* [in] */ BSTR bstrVar,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);


void __RPC_STUB IRequest_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_QueryString_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_QueryString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Form_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Form_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Body_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Body_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_ServerVariables_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ServerVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_ClientCertificate_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ClientCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Cookies_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_TotalBytes_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcbTotal);


void __RPC_STUB IRequest_get_TotalBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRequest_BinaryRead_Proxy( 
    IRequest __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn);


void __RPC_STUB IRequest_BinaryRead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequest_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Request,0x920c25d0,0x25d9,0x11d0,0xa5,0x5f,0x00,0xa0,0xc9,0x0c,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("920c25d0-25d9-11d0-a55f-00a0c90c2091")
Request;
#endif

#ifndef __IReadCookie_INTERFACE_DEFINED__
#define __IReadCookie_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReadCookie
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IReadCookie,0x71EAF260,0x0CE0,0x11D0,0xA5,0x3E,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71EAF260-0CE0-11D0-A53E-00A0C90C2091")
    IReadCookie : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasKeys( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReadCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReadCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReadCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReadCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IReadCookie __RPC_FAR * This,
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasKeys )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        END_INTERFACE
    } IReadCookieVtbl;

    interface IReadCookie
    {
        CONST_VTBL struct IReadCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReadCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReadCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReadCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReadCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReadCookie_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReadCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReadCookie_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReadCookie_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IReadCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IReadCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#define IReadCookie_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IReadCookie_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Item_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [in][optional] */ VARIANT Var,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IReadCookie_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_HasKeys_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);


void __RPC_STUB IReadCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get__NewEnum_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IReadCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Count_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IReadCookie_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Key_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IReadCookie_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReadCookie_INTERFACE_DEFINED__ */


#ifndef __IWriteCookie_INTERFACE_DEFINED__
#define __IWriteCookie_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWriteCookie
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IWriteCookie,0xD97A6DA0,0xA862,0x11cf,0x84,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A862-11cf-84AE-00A0C90C2BD8")
    IWriteCookie : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in][optional] */ VARIANT key,
            /* [in] */ BSTR bstrValue) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Expires( 
            /* [in] */ DATE dtExpires) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Domain( 
            /* [in] */ BSTR bstrDomain) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ BSTR bstrPath) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Secure( 
            /* [in] */ VARIANT_BOOL fSecure) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasKeys( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWriteCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWriteCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWriteCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWriteCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Item )( 
            IWriteCookie __RPC_FAR * This,
            /* [in][optional] */ VARIANT key,
            /* [in] */ BSTR bstrValue);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Expires )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DATE dtExpires);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Domain )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR bstrDomain);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Path )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR bstrPath);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Secure )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fSecure);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasKeys )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IWriteCookieVtbl;

    interface IWriteCookie
    {
        CONST_VTBL struct IWriteCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWriteCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWriteCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWriteCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWriteCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWriteCookie_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWriteCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWriteCookie_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWriteCookie_put_Item(This,key,bstrValue)	\
    (This)->lpVtbl -> put_Item(This,key,bstrValue)

#define IWriteCookie_put_Expires(This,dtExpires)	\
    (This)->lpVtbl -> put_Expires(This,dtExpires)

#define IWriteCookie_put_Domain(This,bstrDomain)	\
    (This)->lpVtbl -> put_Domain(This,bstrDomain)

#define IWriteCookie_put_Path(This,bstrPath)	\
    (This)->lpVtbl -> put_Path(This,bstrPath)

#define IWriteCookie_put_Secure(This,fSecure)	\
    (This)->lpVtbl -> put_Secure(This,fSecure)

#define IWriteCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IWriteCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Item_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in][optional] */ VARIANT key,
    /* [in] */ BSTR bstrValue);


void __RPC_STUB IWriteCookie_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Expires_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ DATE dtExpires);


void __RPC_STUB IWriteCookie_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Domain_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR bstrDomain);


void __RPC_STUB IWriteCookie_put_Domain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Path_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR bstrPath);


void __RPC_STUB IWriteCookie_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Secure_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fSecure);


void __RPC_STUB IWriteCookie_put_Secure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IWriteCookie_get_HasKeys_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);


void __RPC_STUB IWriteCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWriteCookie_get__NewEnum_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IWriteCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWriteCookie_INTERFACE_DEFINED__ */


#ifndef __IResponse_INTERFACE_DEFINED__
#define __IResponse_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IResponse
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IResponse,0xD97A6DA0,0xA864,0x11cf,0x83,0xBE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A864-11cf-83BE-00A0C90C2BD8")
    IResponse : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Buffer( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Buffer( 
            /* [in] */ VARIANT_BOOL fIsBuffering) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ContentType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ContentType( 
            /* [in] */ BSTR bstrContentType) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Expires( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Expires( 
            /* [in] */ long lExpiresMinutes) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ExpiresAbsolute( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ExpiresAbsolute( 
            /* [in] */ DATE dtExpires) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Status( 
            /* [in] */ BSTR bstrStatus) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddHeader( 
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppendToLog( 
            /* [in] */ BSTR bstrLogEntry) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BinaryWrite( 
            /* [in] */ VARIANT varInput) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Redirect( 
            /* [in] */ BSTR bstrURL) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ VARIANT varText) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE WriteBlock( 
            /* [in] */ short iBlockNumber) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsClientConnected( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CharSet( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CharSet( 
            /* [in] */ BSTR bstrCharSet) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Pics( 
            /* [in] */ BSTR bstrHeaderValue) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CacheControl( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CacheControl( 
            /* [in] */ BSTR bstrCacheControl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResponseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResponse __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResponse __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IResponse __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IResponse __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IResponse __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fIsBuffering);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrContentType);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Expires )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Expires )( 
            IResponse __RPC_FAR * This,
            /* [in] */ long lExpiresMinutes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [in] */ DATE dtExpires);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Cookies )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Status )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrStatus);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddHeader )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendToLog )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrLogEntry);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BinaryWrite )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varInput);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Flush )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redirect )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrURL);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varText);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteBlock )( 
            IResponse __RPC_FAR * This,
            /* [in] */ short iBlockNumber);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsClientConnected )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CharSet )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CharSet )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrCharSet);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pics )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CacheControl )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CacheControl )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrCacheControl);
        
        END_INTERFACE
    } IResponseVtbl;

    interface IResponse
    {
        CONST_VTBL struct IResponseVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResponse_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResponse_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResponse_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResponse_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IResponse_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IResponse_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IResponse_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IResponse_get_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> get_Buffer(This,fIsBuffering)

#define IResponse_put_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> put_Buffer(This,fIsBuffering)

#define IResponse_get_ContentType(This,pbstrContentTypeRet)	\
    (This)->lpVtbl -> get_ContentType(This,pbstrContentTypeRet)

#define IResponse_put_ContentType(This,bstrContentType)	\
    (This)->lpVtbl -> put_ContentType(This,bstrContentType)

#define IResponse_get_Expires(This,pvarExpiresMinutesRet)	\
    (This)->lpVtbl -> get_Expires(This,pvarExpiresMinutesRet)

#define IResponse_put_Expires(This,lExpiresMinutes)	\
    (This)->lpVtbl -> put_Expires(This,lExpiresMinutes)

#define IResponse_get_ExpiresAbsolute(This,pvarExpiresRet)	\
    (This)->lpVtbl -> get_ExpiresAbsolute(This,pvarExpiresRet)

#define IResponse_put_ExpiresAbsolute(This,dtExpires)	\
    (This)->lpVtbl -> put_ExpiresAbsolute(This,dtExpires)

#define IResponse_get_Cookies(This,ppCookies)	\
    (This)->lpVtbl -> get_Cookies(This,ppCookies)

#define IResponse_get_Status(This,pbstrStatusRet)	\
    (This)->lpVtbl -> get_Status(This,pbstrStatusRet)

#define IResponse_put_Status(This,bstrStatus)	\
    (This)->lpVtbl -> put_Status(This,bstrStatus)

#define IResponse_Add(This,bstrHeaderValue,bstrHeaderName)	\
    (This)->lpVtbl -> Add(This,bstrHeaderValue,bstrHeaderName)

#define IResponse_AddHeader(This,bstrHeaderName,bstrHeaderValue)	\
    (This)->lpVtbl -> AddHeader(This,bstrHeaderName,bstrHeaderValue)

#define IResponse_AppendToLog(This,bstrLogEntry)	\
    (This)->lpVtbl -> AppendToLog(This,bstrLogEntry)

#define IResponse_BinaryWrite(This,varInput)	\
    (This)->lpVtbl -> BinaryWrite(This,varInput)

#define IResponse_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IResponse_End(This)	\
    (This)->lpVtbl -> End(This)

#define IResponse_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#define IResponse_Redirect(This,bstrURL)	\
    (This)->lpVtbl -> Redirect(This,bstrURL)

#define IResponse_Write(This,varText)	\
    (This)->lpVtbl -> Write(This,varText)

#define IResponse_WriteBlock(This,iBlockNumber)	\
    (This)->lpVtbl -> WriteBlock(This,iBlockNumber)

#define IResponse_IsClientConnected(This,pfIsClientConnected)	\
    (This)->lpVtbl -> IsClientConnected(This,pfIsClientConnected)

#define IResponse_get_CharSet(This,pbstrCharSetRet)	\
    (This)->lpVtbl -> get_CharSet(This,pbstrCharSetRet)

#define IResponse_put_CharSet(This,bstrCharSet)	\
    (This)->lpVtbl -> put_CharSet(This,bstrCharSet)

#define IResponse_Pics(This,bstrHeaderValue)	\
    (This)->lpVtbl -> Pics(This,bstrHeaderValue)

#define IResponse_get_CacheControl(This,pbstrCacheControl)	\
    (This)->lpVtbl -> get_CacheControl(This,pbstrCacheControl)

#define IResponse_put_CacheControl(This,bstrCacheControl)	\
    (This)->lpVtbl -> put_CacheControl(This,bstrCacheControl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering);


void __RPC_STUB IResponse_get_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fIsBuffering);


void __RPC_STUB IResponse_put_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);


void __RPC_STUB IResponse_get_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrContentType);


void __RPC_STUB IResponse_put_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);


void __RPC_STUB IResponse_get_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ long lExpiresMinutes);


void __RPC_STUB IResponse_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);


void __RPC_STUB IResponse_get_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ DATE dtExpires);


void __RPC_STUB IResponse_put_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_get_Cookies_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);


void __RPC_STUB IResponse_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);


void __RPC_STUB IResponse_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrStatus);


void __RPC_STUB IResponse_put_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IResponse_Add_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderValue,
    /* [in] */ BSTR bstrHeaderName);


void __RPC_STUB IResponse_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_AddHeader_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderName,
    /* [in] */ BSTR bstrHeaderValue);


void __RPC_STUB IResponse_AddHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_AppendToLog_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrLogEntry);


void __RPC_STUB IResponse_AppendToLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_BinaryWrite_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varInput);


void __RPC_STUB IResponse_BinaryWrite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Clear_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_End_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Flush_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Redirect_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrURL);


void __RPC_STUB IResponse_Redirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Write_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varText);


void __RPC_STUB IResponse_Write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IResponse_WriteBlock_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ short iBlockNumber);


void __RPC_STUB IResponse_WriteBlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_IsClientConnected_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected);


void __RPC_STUB IResponse_IsClientConnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_CharSet_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet);


void __RPC_STUB IResponse_get_CharSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_CharSet_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrCharSet);


void __RPC_STUB IResponse_put_CharSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Pics_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderValue);


void __RPC_STUB IResponse_Pics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_CacheControl_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl);


void __RPC_STUB IResponse_get_CacheControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_CacheControl_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrCacheControl);


void __RPC_STUB IResponse_put_CacheControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResponse_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Response,0x46E19BA0,0x25DD,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("46E19BA0-25DD-11D0-A55F-00A0C90C2091")
Response;
#endif

#ifndef __IVariantDictionary_INTERFACE_DEFINED__
#define __IVariantDictionary_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IVariantDictionary
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IVariantDictionary,0x4a7deb90,0xb069,0x11d0,0xb3,0x73,0x00,0xa0,0xc9,0x0c,0x2b,0xd8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a7deb90-b069-11d0-b373-00a0c90c2bd8")
    IVariantDictionary : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Item( 
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVariantDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVariantDictionary __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVariantDictionary __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVariantDictionary __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IVariantDictionary __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IVariantDictionary __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IVariantDictionaryVtbl;

    interface IVariantDictionary
    {
        CONST_VTBL struct IVariantDictionaryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVariantDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVariantDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVariantDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVariantDictionary_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVariantDictionary_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVariantDictionary_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVariantDictionary_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVariantDictionary_get_Item(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Item(This,VarKey,pvar)

#define IVariantDictionary_put_Item(This,VarKey,var)	\
    (This)->lpVtbl -> put_Item(This,VarKey,var)

#define IVariantDictionary_putref_Item(This,VarKey,var)	\
    (This)->lpVtbl -> putref_Item(This,VarKey,var)

#define IVariantDictionary_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#define IVariantDictionary_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IVariantDictionary_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IVariantDictionary_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_put_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [in] */ VARIANT var);


void __RPC_STUB IVariantDictionary_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_putref_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [in] */ VARIANT var);


void __RPC_STUB IVariantDictionary_putref_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Key_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IVariantDictionary_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Count_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IVariantDictionary_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get__NewEnum_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IVariantDictionary_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVariantDictionary_INTERFACE_DEFINED__ */


#ifndef __ISessionObject_INTERFACE_DEFINED__
#define __ISessionObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISessionObject
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][oleautomation][dual][uuid] */ 



DEFINE_GUID(IID_ISessionObject,0xD97A6DA0,0xA865,0x11cf,0x83,0xAF,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A865-11cf-83AF-00A0C90C2BD8")
    ISessionObject : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SessionID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Timeout( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Timeout( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Abandon( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CodePage( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CodePage( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LCID( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LCID( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StaticObjects( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Contents( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISessionObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISessionObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISessionObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISessionObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SessionID )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abandon )( 
            ISessionObject __RPC_FAR * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CodePage )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CodePage )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LCID )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LCID )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StaticObjects )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contents )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } ISessionObjectVtbl;

    interface ISessionObject
    {
        CONST_VTBL struct ISessionObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISessionObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISessionObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISessionObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISessionObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISessionObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISessionObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISessionObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISessionObject_get_SessionID(This,pbstrRet)	\
    (This)->lpVtbl -> get_SessionID(This,pbstrRet)

#define ISessionObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define ISessionObject_put_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,var)

#define ISessionObject_putref_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,var)

#define ISessionObject_get_Timeout(This,plvar)	\
    (This)->lpVtbl -> get_Timeout(This,plvar)

#define ISessionObject_put_Timeout(This,lvar)	\
    (This)->lpVtbl -> put_Timeout(This,lvar)

#define ISessionObject_Abandon(This)	\
    (This)->lpVtbl -> Abandon(This)

#define ISessionObject_get_CodePage(This,plvar)	\
    (This)->lpVtbl -> get_CodePage(This,plvar)

#define ISessionObject_put_CodePage(This,lvar)	\
    (This)->lpVtbl -> put_CodePage(This,lvar)

#define ISessionObject_get_LCID(This,plvar)	\
    (This)->lpVtbl -> get_LCID(This,plvar)

#define ISessionObject_put_LCID(This,lvar)	\
    (This)->lpVtbl -> put_LCID(This,lvar)

#define ISessionObject_get_StaticObjects(This,ppTaggedObjects)	\
    (This)->lpVtbl -> get_StaticObjects(This,ppTaggedObjects)

#define ISessionObject_get_Contents(This,ppProperties)	\
    (This)->lpVtbl -> get_Contents(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_SessionID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);


void __RPC_STUB ISessionObject_get_SessionID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB ISessionObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB ISessionObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_putref_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB ISessionObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISessionObject_Abandon_Proxy( 
    ISessionObject __RPC_FAR * This);


void __RPC_STUB ISessionObject_Abandon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_CodePage_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_CodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_CodePage_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_CodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_LCID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_LCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_LCID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_LCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_StaticObjects_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects);


void __RPC_STUB ISessionObject_get_StaticObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Contents_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ISessionObject_get_Contents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISessionObject_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Session,0x509F8F20,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("509F8F20-25DE-11D0-A55F-00A0C90C2091")
Session;
#endif

#ifndef __IApplicationObject_INTERFACE_DEFINED__
#define __IApplicationObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IApplicationObject
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IApplicationObject,0xD97A6DA0,0xA866,0x11cf,0x83,0xAE,0x10,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A866-11cf-83AE-10A0C90C2BD8")
    IApplicationObject : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Lock( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnLock( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StaticObjects( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Contents( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IApplicationObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IApplicationObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IApplicationObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Lock )( 
            IApplicationObject __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnLock )( 
            IApplicationObject __RPC_FAR * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StaticObjects )( 
            IApplicationObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contents )( 
            IApplicationObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } IApplicationObjectVtbl;

    interface IApplicationObject
    {
        CONST_VTBL struct IApplicationObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IApplicationObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IApplicationObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IApplicationObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IApplicationObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IApplicationObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IApplicationObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IApplicationObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define IApplicationObject_put_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,var)

#define IApplicationObject_putref_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,var)

#define IApplicationObject_Lock(This)	\
    (This)->lpVtbl -> Lock(This)

#define IApplicationObject_UnLock(This)	\
    (This)->lpVtbl -> UnLock(This)

#define IApplicationObject_get_StaticObjects(This,ppProperties)	\
    (This)->lpVtbl -> get_StaticObjects(This,ppProperties)

#define IApplicationObject_get_Contents(This,ppProperties)	\
    (This)->lpVtbl -> get_Contents(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IApplicationObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_put_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB IApplicationObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_putref_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB IApplicationObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IApplicationObject_Lock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IApplicationObject_UnLock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_UnLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_StaticObjects_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB IApplicationObject_get_StaticObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_Contents_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB IApplicationObject_get_Contents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IApplicationObject_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Application,0x7C3BAF00,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("7C3BAF00-25DE-11D0-A55F-00A0C90C2091")
Application;
#endif

#ifndef __IServer_INTERFACE_DEFINED__
#define __IServer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IServer
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IServer,0xD97A6DA0,0xA867,0x11cf,0x83,0xAE,0x01,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A867-11cf-83AE-01A0C90C2BD8")
    IServer : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ScriptTimeout( 
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ScriptTimeout( 
            /* [in] */ long lTimeoutSeconds) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateObject( 
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE HTMLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapPath( 
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE URLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE URLPathEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IServer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IServer __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IServer __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [in] */ long lTimeoutSeconds);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateObject )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HTMLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapPath )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *URLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *URLPathEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        END_INTERFACE
    } IServerVtbl;

    interface IServer
    {
        CONST_VTBL struct IServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IServer_get_ScriptTimeout(This,plTimeoutSeconds)	\
    (This)->lpVtbl -> get_ScriptTimeout(This,plTimeoutSeconds)

#define IServer_put_ScriptTimeout(This,lTimeoutSeconds)	\
    (This)->lpVtbl -> put_ScriptTimeout(This,lTimeoutSeconds)

#define IServer_CreateObject(This,bstrProgID,ppDispObject)	\
    (This)->lpVtbl -> CreateObject(This,bstrProgID,ppDispObject)

#define IServer_HTMLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> HTMLEncode(This,bstrIn,pbstrEncoded)

#define IServer_MapPath(This,bstrLogicalPath,pbstrPhysicalPath)	\
    (This)->lpVtbl -> MapPath(This,bstrLogicalPath,pbstrPhysicalPath)

#define IServer_URLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> URLEncode(This,bstrIn,pbstrEncoded)

#define IServer_URLPathEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> URLPathEncode(This,bstrIn,pbstrEncoded)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IServer_get_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);


void __RPC_STUB IServer_get_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IServer_put_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ long lTimeoutSeconds);


void __RPC_STUB IServer_put_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_CreateObject_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrProgID,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);


void __RPC_STUB IServer_CreateObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_HTMLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_HTMLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_MapPath_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrLogicalPath,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);


void __RPC_STUB IServer_MapPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_URLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_URLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_URLPathEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_URLPathEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServer_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Server,0xA506D160,0x25E0,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("A506D160-25E0-11D0-A55F-00A0C90C2091")
Server;
#endif

#ifndef __IScriptingContext_INTERFACE_DEFINED__
#define __IScriptingContext_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IScriptingContext
 * at Mon Nov 03 15:43:09 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IScriptingContext,0xD97A6DA0,0xA868,0x11cf,0x83,0xAE,0x00,0xB0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A868-11cf-83AE-00B0C90C2BD8")
    IScriptingContext : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Request( 
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Response( 
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Server( 
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScriptingContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScriptingContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScriptingContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IScriptingContext __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Request )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Response )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Server )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);
        
        END_INTERFACE
    } IScriptingContextVtbl;

    interface IScriptingContext
    {
        CONST_VTBL struct IScriptingContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScriptingContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScriptingContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScriptingContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScriptingContext_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IScriptingContext_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IScriptingContext_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IScriptingContext_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IScriptingContext_get_Request(This,ppRequest)	\
    (This)->lpVtbl -> get_Request(This,ppRequest)

#define IScriptingContext_get_Response(This,ppResponse)	\
    (This)->lpVtbl -> get_Response(This,ppResponse)

#define IScriptingContext_get_Server(This,ppServer)	\
    (This)->lpVtbl -> get_Server(This,ppServer)

#define IScriptingContext_get_Session(This,ppSession)	\
    (This)->lpVtbl -> get_Session(This,ppSession)

#define IScriptingContext_get_Application(This,ppApplication)	\
    (This)->lpVtbl -> get_Application(This,ppApplication)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Request_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);


void __RPC_STUB IScriptingContext_get_Request_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Response_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);


void __RPC_STUB IScriptingContext_get_Response_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Server_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);


void __RPC_STUB IScriptingContext_get_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Session_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);


void __RPC_STUB IScriptingContext_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Application_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);


void __RPC_STUB IScriptingContext_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScriptingContext_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_ScriptingContext,0xD97A6DA0,0xA868,0x11cf,0x83,0xAE,0x11,0xB0,0xC9,0x0C,0x2B,0xD8);

#ifdef __cplusplus

class DECLSPEC_UUID("D97A6DA0-A868-11cf-83AE-11B0C90C2BD8")
ScriptingContext;
#endif
#endif /* __ASPTypeLibrary_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\openfiles\openfilescomp\openf.cpp ===
// OpenF.cpp : Implementation of COpenF


/***************************************************************************************

Copyright information					: Microsoft Corp. 1981-1999. All rights reserved
File Name								: OpenF.cpp
Created By								: A.V. Kiran Kumar
Date of Creation (dd/mm/yy) 			: 13/02/01
Version Number							: 0.1

Brief Description 	: This file implements COpenF. This file is intended to
					  have the functionality for getting the list of open files.

***************************************************************************************/ 

#include "stdafx.h"
#include "OpenFiles.h"
#include "OpenF.h"

/////////////////////////////////////////////////////////////////////////////
// COpenF

// ***************************************************************************
//
//  Name			   : getOpenFiles
//
//  Synopsis		   : This function gets the list of open files.
//	     
//  Parameters		   : VARIANT*(out, retval) pOpenFiles - List of open files
//
//  Return Type		   : DWORD
//
//  
// ***************************************************************************

STDMETHODIMP COpenF::getOpenFiles(VARIANT *pOpenFiles)
{

    DWORD dwEntriesRead = 0;// Receives the total number of openfiles

    DWORD dwTotalEntries = 0;//Receives the total number of entries read

    DWORD dwResumeHandle = 0;//Contains a resume handle which is used to 
                             //continue an existing file search. 

    LPFILE_INFO_3 pFileInfo3_1 = NULL;// LPFILE_INFO_3  structure contains the 
                                      // pertinent information about files. 

    DWORD dwError = 0; 

	DWORD dwRetval = S_OK;

	DWORD dwCount = 0;//Count which indicates the number of openfiles
    
	LPFILE_INFO_3 dummyPtr = NULL;


	//Get information about some or all open files on a server
    dwError = NetFileEnum(	NULL,
							NULL,
							NULL,
							FILE_INFO_3,	
							(LPBYTE*)&pFileInfo3_1, 
							MAX_PREFERRED_LENGTH, 
							&dwEntriesRead,	
							&dwTotalEntries,
							NULL );

	if(dwError == ERROR_ACCESS_DENIED || dwError == ERROR_NOT_ENOUGH_MEMORY) 
		return dwError; // The user does not have access to the requested information.

	//Get the count of OpenFiles on Macinthosh machine
	DWORD dwMacCount = 0;
	if ( dwError = GetMacOpenFileCount(&dwMacCount) )
		dwRetval = dwError;

	//Get the count of OpenFiles on Netware machine
	DWORD dwNwCount = 0;
	if ( dwError = GetNwOpenFileCount(&dwNwCount) )
		dwRetval = dwError;

	//Fill the safearray bounds structure with the dimensions of the safe array. The lower bound
	//is 0 and the number of rows is dwTotalEntries and number of columns is 3
	pSab[0].lLbound = 0;
	pSab[0].cElements = dwTotalEntries + dwMacCount + dwNwCount;

	pSab[1].lLbound = 0;
	pSab[1].cElements = 3;

	//Create the safe array descriptor, allocate and initialize the data for the array
	pSa = SafeArrayCreate( VT_VARIANT, 2, pSab ); 
	
	if(pSa == NULL)
		return ERROR_NOT_ENOUGH_MEMORY;

	//Enumerate all the openfiles
	do
	{
		//Some more files are to be enumerated get them by calling NetFileEnum again
		dwError = NetFileEnum( NULL, NULL, NULL, FILE_INFO_3,
                      (LPBYTE*)&pFileInfo3_1,
                       MAX_PREFERRED_LENGTH,
                       &dwEntriesRead,
                       &dwTotalEntries,
                       (unsigned long*)&dwResumeHandle );

		if(dwError == ERROR_ACCESS_DENIED || dwError == ERROR_NOT_ENOUGH_MEMORY)
			return dwError;


		dummyPtr = pFileInfo3_1; 

		// Get the open files once NetFileEnum is successully called
		if( dwError == NERR_Success || dwError == ERROR_MORE_DATA )
		{
			for ( DWORD dwFile = 0; dwFile < dwEntriesRead; dwFile++, pFileInfo3_1++ )
			{
				BSTR userName;
				BSTR openMode;
				BSTR pathName;
				VARIANT vuserName;
				VARIANT vopenMode;
				VARIANT vpathName;

				// Accessed By
				if(lstrlen(pFileInfo3_1->fi3_username))
					userName = (BSTR)pFileInfo3_1->fi3_username;
				else
					userName = L"NOT_AVAILABLE"; //User name is not available

				// Checks for  open file mode
				const DWORD READWRITE = PERM_FILE_READ | PERM_FILE_WRITE;
				const DWORD READCREATE = PERM_FILE_READ | PERM_FILE_CREATE;
				const DWORD WRITECREATE = PERM_FILE_WRITE | PERM_FILE_CREATE;

				switch(pFileInfo3_1->fi3_permissions)
				{
				case PERM_FILE_READ:
					openMode = L"READ";
					break;

				case PERM_FILE_WRITE:
					openMode = L"WRITE";
					break;

				case PERM_FILE_CREATE:
					openMode = L"CREATE";
					break;

				case READWRITE:
					openMode = L"READ+WRITE";
					break;

				case READCREATE:
					openMode = L"READ+CREATE";
					break;

				case WRITECREATE:
					openMode = L"WRITE+CREATE";
					break;
				default:
					openMode = L"NOACCESS";
				}

				//Get the filename from the structure
				pathName = (BSTR)pFileInfo3_1->fi3_pathname;

				//Initialize the row index and column index at which filename is to be stored in the Safearray
				long index[2] = {dwCount, 0};

				VariantInit( &vpathName );	//Initialize the variant
				vpathName.vt = VT_BSTR;		//Data type to be stored is BSTR
				vpathName.bstrVal = SysAllocString(pathName);

				//Store the filename in Safearray
				HRESULT hr;
				hr = SafeArrayPutElement( pSa, index, &vpathName );
				if( FAILED(hr) )
					return hr;

				//Store username in the second column 
				index[ 1 ] = 1;
				
				VariantInit( &vuserName );
				vuserName.vt = VT_BSTR;
				vuserName.bstrVal = SysAllocString(userName);

				//Store the username in the safearray
				hr = SafeArrayPutElement( pSa, index, &vuserName );
				if( FAILED(hr) )
					return hr;
				
				//Store OpenMode in the third column 
				index[ 1 ] = 2;

				VariantInit( &vopenMode );
				vopenMode.vt = VT_BSTR;
				vopenMode.bstrVal = SysAllocString(openMode);

				//Store the OpenMode in the safearray
				hr = SafeArrayPutElement( pSa, index, &vopenMode );
				if( FAILED(hr) )
					return hr;

				//Clear all the variants that are initilized
				VariantClear(&vuserName);
				VariantClear(&vopenMode);
				VariantClear(&vpathName);

				dwCount++;
			}// End for loop
		}
		// Free the block allocated for retrieving the OpenFile info
		if( dummyPtr !=NULL)
		{
			NetApiBufferFree( dummyPtr ); 
			pFileInfo3_1 = NULL;
		}

	} while ( dwError == ERROR_MORE_DATA );

	//Get the list of Open Files on Macinthosh OS
	if( dwMacCount > 0 )
	{
		if ( dwError = GetMacOpenF(pSa, dwTotalEntries ) )
			dwRetval = dwError;
	}

	//Get the list of Open Files on Netware OS
	if( dwNwCount > 0 )
	{
		if ( dwError = GetNwOpenF(pSa, dwTotalEntries + dwMacCount ) )
			dwRetval = dwError;
	}

	//Return the safe array to the calling function
	VariantInit( pOpenFiles );
	pOpenFiles->vt = VT_VARIANT | VT_ARRAY;
	pOpenFiles->parray = pSa;

	return dwRetval;
}

// ***************************************************************************
//
//  Name			   : GetMacOpenF
//
//  Synopsis		   : This function gets the list of open files on Machinthosh OS.
//	     
//  Parameters		   : SAFEARRAY* (out, retval) - List of open files
//					   : DWORD dwIndex Safe array Index
//
//  Return Type		   : DWORD
//
//  
// ***************************************************************************

DWORD COpenF::GetMacOpenF(SAFEARRAY *pSa, DWORD dwIndex)
{
    DWORD dwEntriesRead = 0;// Receives the count of elements

    DWORD dwTotalEntries = 0;//Receives the total number of entries

    DWORD hEnumHandle = 0;//Contains a resume handle which is used to 
                             //continue an existing file search. 

	AFP_FILE_INFO* pfileinfo = NULL;	// Structure contains the 
										// pertinent information about files

    HRESULT hr = S_OK;

    NET_API_STATUS retval = NERR_Success;

	DWORD ulSFMServerConnection = 0;

    DWORD retval_connect = 0;

	LPWSTR ServerName = NULL;

	retval_connect = AfpAdminConnect(
					ServerName,
					&ulSFMServerConnection );

	if(retval_connect)
		return retval_connect;
	
	DWORD dwCount = dwIndex;

	DWORD retval_FileEnum;

	//Enumerate all the openfiles
	do
	{
		//Some more files are to be enumerated get them by calling AfpAdminFileEnum again
		retval_FileEnum =	AfpAdminFileEnum(
									ulSFMServerConnection,
									(PBYTE*)&pfileinfo,
									(DWORD)-1L,
									&dwEntriesRead,
									&dwTotalEntries,
									&hEnumHandle );

		if( retval_FileEnum == ERROR_ACCESS_DENIED || retval_FileEnum == ERROR_NOT_ENOUGH_MEMORY ) 
			return retval_FileEnum; // The user does not have access to the requested information.

		AFP_FILE_INFO* dummyPtr = pfileinfo;

		// Get the open files once NetFileEnum is successully called
		if( retval_FileEnum == NERR_Success || retval_FileEnum == ERROR_MORE_DATA )
		{

			for ( DWORD dwFile = 0; dwFile < dwEntriesRead; dwFile++, pfileinfo++ )
			{
				BSTR userName;
				BSTR openMode;
				BSTR pathName;
				VARIANT vuserName;
				VARIANT vopenMode;
				VARIANT vpathName;

				// Accessed By
				if(lstrlen(pfileinfo->afpfile_username))
					userName = (BSTR)pfileinfo->afpfile_username;
				else
					userName = L"NOT_AVAILABLE"; //User name is not available

				// Checks for  open file mode
				const DWORD READWRITE = PERM_FILE_READ | PERM_FILE_WRITE;
				const DWORD READCREATE = PERM_FILE_READ | PERM_FILE_CREATE;
				const DWORD WRITECREATE = PERM_FILE_WRITE | PERM_FILE_CREATE;

				switch(pfileinfo->afpfile_open_mode)
				{
				case PERM_FILE_READ:
					openMode = L"READ";
					break;

				case PERM_FILE_WRITE:
					openMode = L"WRITE";
					break;

				case PERM_FILE_CREATE:
					openMode = L"CREATE";
					break;

				case READWRITE:
					openMode = L"READ+WRITE";
					break;

				case READCREATE:
					openMode = L"READ+CREATE";
					break;

				case WRITECREATE:
					openMode = L"WRITE+CREATE";
					break;
				default:
					openMode = L"NOACCESS";
				}

				//Get the filename from the structure
				pathName = (BSTR)pfileinfo->afpfile_path;

				//Initialize the row index and column index filename to be stored in the Safearray
				long index[2] = {dwCount, 0};

				VariantInit( &vpathName );	//Initialize the variant
				vpathName.vt = VT_BSTR;		//Data type to be stored is BSTR
				vpathName.bstrVal = SysAllocString(pathName);

				//Store the filename in Safearray
				hr = SafeArrayPutElement( pSa, index, &vpathName );
				if( FAILED(hr) )
					return hr;

				//Store filename in the second column
				index[ 1 ] = 1;
				
				VariantInit( &vuserName );
				vuserName.vt = VT_BSTR;
				vuserName.bstrVal = SysAllocString(userName);

				//Store the username in the safearray
				hr = SafeArrayPutElement( pSa, index, &vuserName );
				if( FAILED(hr) )
					return hr;

				//Store OpenMode in the third column
				index[ 1 ] = 2;

				VariantInit( &vopenMode );
				vopenMode.vt = VT_BSTR;
				vopenMode.bstrVal = SysAllocString(openMode);

				//Store the OpenMode in the safearray
				hr = SafeArrayPutElement( pSa, index, &vopenMode );
				if( FAILED(hr) )
					return hr;

				//Clear all the variants that are initilized
				VariantClear(&vuserName);
				VariantClear(&vopenMode);
				VariantClear(&vpathName);

				dwCount++;
			}// End for loop
		}
		// Free the block allocated for retrieving the OpenFile info
		if( dummyPtr !=NULL)
		{
			NetApiBufferFree( dummyPtr ); 
			pfileinfo = NULL;
		}

	} while ( retval_FileEnum == ERROR_MORE_DATA );

	return 0;
}

// ***************************************************************************
//
//  Name			   : GetMacOpenFileCount
//
//  Synopsis		   : This function gets the count of open files on Machinthosh OS.
//	     
//  Parameters		   : DWORD dwIndex Safe array Index
//
//  Return Type		   : DWORD
//
//  
// ***************************************************************************

DWORD COpenF::GetMacOpenFileCount(LPDWORD lpdwCount)
{
    DWORD dwEntriesRead = 0;// Receives the count of elements

    DWORD dwTotalEntries = 0;//Receives the total number of entries

	AFP_FILE_INFO* pfileinfo = NULL;	// Structure contains the 
										// identification number and other 
										// pertinent information about files

    HRESULT hr = S_OK;

    NET_API_STATUS retval = NERR_Success;

	DWORD ulSFMServerConnection = 0;

	hMacModule = ::LoadLibrary (_TEXT("sfmapi.dll"));

	if(hMacModule==NULL)
		return ERROR_DLL_INIT_FAILED;	
	
	AfpAdminConnect = (CONNECTPROC)::GetProcAddress (hMacModule,"AfpAdminConnect");
	if(AfpAdminConnect==NULL)
		return ERROR_DLL_INIT_FAILED;
	
    DWORD retval_connect = AfpAdminConnect(
							NULL,
							&ulSFMServerConnection );

	if(retval_connect!=0)
		return retval_connect;
	
	AfpAdminFileEnum = (FILEENUMPROCMAC)::GetProcAddress (hMacModule,"AfpAdminFileEnum");

	if(AfpAdminFileEnum==NULL)
		return ERROR_DLL_INIT_FAILED;
	
	//Get information about some or all open files on a server
	DWORD retval_FileEnum =	AfpAdminFileEnum(
											ulSFMServerConnection,
											(PBYTE*)&pfileinfo,
											(DWORD)-1L,
											&dwEntriesRead,
											&dwTotalEntries,
											NULL );

	if( retval_FileEnum == ERROR_ACCESS_DENIED || retval_FileEnum == ERROR_NOT_ENOUGH_MEMORY ) 
		return retval_FileEnum; // The user does not have access to the requested information.

	*lpdwCount = dwTotalEntries;

	if( pfileinfo !=NULL)
	{
		NetApiBufferFree( pfileinfo ); 
		pfileinfo = NULL;
	}
	return 0;
}

// ***************************************************************************
//
//  Name			   : GetNwOpenFileCount
//
//  Synopsis		   : This function gets the count of open files on Netware OS.
//	     
//  Parameters		   : DWORD dwIndex Safe array Index
//
//  Return Type		   : DWORD
//
//  
// ***************************************************************************

DWORD COpenF::GetNwOpenFileCount(LPDWORD lpdwCount)
{

    DWORD dwEntriesRead = 0;// Receives the count of elements

    FPNWFILEINFO* pfileinfo = NULL;	// FPNWFILEINFO  structure contains the 
                                    // identification number and other 
                                    // pertinent information about files, 
                                    // devices, and pipes.

    NET_API_STATUS retval = NERR_Success;

    DWORD dwError = 0;//Contains return value for "NetFileEnum" function

	DWORD dwCount = 0;//Count which indicates the number of openfiles

    *lpdwCount = 0;  //Initialize the count to zero

	hNwModule = ::LoadLibrary (_TEXT("FPNWCLNT.DLL"));

	if(hNwModule==NULL)
		return ERROR_DLL_INIT_FAILED;
	
	FpnwFileEnum = (FILEENUMPROC)::GetProcAddress (hNwModule,"FpnwFileEnum");
	if(FpnwFileEnum==NULL)
		return ERROR_DLL_INIT_FAILED;

	do
	{
		//Get information about some or all open files on a server
		retval = FpnwFileEnum(
							NULL,
							1,
							NULL,
							(PBYTE*)&pfileinfo,
							&dwEntriesRead,
							NULL );

		if( retval == ERROR_ACCESS_DENIED || retval == ERROR_NOT_ENOUGH_MEMORY ) 
			return retval; // The user does not have access to the requested information.

		*lpdwCount += dwEntriesRead;

	}while( retval == ERROR_MORE_DATA ); 

	if( pfileinfo !=NULL)
	{
		NetApiBufferFree( pfileinfo ); 
		pfileinfo = NULL;
	}
	return 0;
}

// ***************************************************************************
//
//  Name			   : GetNwOpenF
//
//  Synopsis		   : This function gets the list of open files on Netware OS.
//	     
//  Parameters		   : SAFEARRAY* (out, retval) - List of open files
//					   : DWORD dwIndex Safe array Index
//
//  Return Type		   : DWORD
//
//  
// ***************************************************************************

DWORD COpenF::GetNwOpenF(SAFEARRAY *pSa, DWORD dwIndex)
{
    DWORD dwEntriesRead = 0;// Receives the count of elements

    DWORD hEnumHandle = 0;//Contains a resume handle which is used to 
                             //continue an existing file search. 

    FPNWFILEINFO* pfileinfo = NULL;	// FPNWFILEINFO  structure contains the 
                                    // pertinent information about files. 

    HRESULT hr = S_OK;

    NET_API_STATUS retval = NERR_Success;

	DWORD dwCount = dwIndex;

	//Enumerate all the openfiles
	do
	{
		//Some more files are to be enumerated get them by calling NetFileEnum again
		retval = FpnwFileEnum(
							NULL,
							1,
							NULL,
							(PBYTE*)&pfileinfo,
							&dwEntriesRead,
							NULL );

		if( retval == ERROR_ACCESS_DENIED || retval == ERROR_NOT_ENOUGH_MEMORY ) 
			return retval; // The user does not have access to the requested information.

		FPNWFILEINFO* dummyPtr = pfileinfo;

		// Get the open files once NetFileEnum is successully called
		if( retval == NERR_Success || retval == ERROR_MORE_DATA )
		{
			for ( DWORD dwFile = 0; dwFile < dwEntriesRead; dwFile++, pfileinfo++ )
			{
				BSTR userName;
				BSTR openMode;
				BSTR pathName;
				VARIANT vuserName;
				VARIANT vopenMode;
				VARIANT vpathName;

				// Accessed By
				if(lstrlen(pfileinfo->lpUserName))
					userName = (BSTR)pfileinfo->lpUserName;
				else
					userName = L"NOT_AVAILABLE"; //User name is not available

				// Checks for  open file mode
				const DWORD READWRITE = FPNWFILE_PERM_READ | FPNWFILE_PERM_WRITE;
				const DWORD READCREATE = FPNWFILE_PERM_READ | FPNWFILE_PERM_CREATE;
				const DWORD WRITECREATE = FPNWFILE_PERM_WRITE | FPNWFILE_PERM_CREATE;

				switch(pfileinfo->dwPermissions)
				{
				case FPNWFILE_PERM_READ:
					openMode = L"READ";
					break;

				case FPNWFILE_PERM_WRITE:
					openMode = L"WRITE";
					break;

				case FPNWFILE_PERM_CREATE:
					openMode = L"CREATE";
					break;

				case READWRITE:
					openMode = L"READ+WRITE";
					break;

				case READCREATE:
					openMode = L"READ+CREATE";
					break;

				case WRITECREATE:
					openMode = L"WRITE+CREATE";
					break;
				default:
					openMode = L"NOACCESS";
				}
				
				//Get the filename from the structure
				pathName = (BSTR)pfileinfo->lpPathName;

				//Initialize the row index and column index filename to be stored in the Safearray
				long index[2] = {dwCount, 0};

				VariantInit( &vpathName );	//Initialize the variant
				vpathName.vt = VT_BSTR;		//Data type to be stored is BSTR
				vpathName.bstrVal = SysAllocString(pathName);

				//Store the filename in Safearray
				hr = SafeArrayPutElement( pSa, index, &vpathName );
				if( FAILED(hr) )
					return hr;

				//Store filename in the second column
				index[ 1 ] = 1;
				
				VariantInit( &vuserName );
				vuserName.vt = VT_BSTR;
				vuserName.bstrVal = SysAllocString(userName);

				//Store the username in the safearray
				hr = SafeArrayPutElement( pSa, index, &vuserName );
				if( FAILED(hr) )
					return hr;

				//Store OpenMode in the third column
				index[ 1 ] = 2;

				VariantInit( &vopenMode );
				vopenMode.vt = VT_BSTR;
				vopenMode.bstrVal = SysAllocString(openMode);

				//Store the OpenMode in the safearray
				hr = SafeArrayPutElement( pSa, index, &vopenMode );
				if( FAILED(hr) )
					return hr;

				//Clear all the variants that are initilized
				VariantClear(&vuserName);
				VariantClear(&vopenMode);
				VariantClear(&vpathName);

				dwCount++;
			}// End for loop
		}

		// Free the block allocated for retrieving the OpenFile info
		if( dummyPtr !=NULL)
		{
			NetApiBufferFree( dummyPtr ); 
			pfileinfo = NULL;
		}

	}while( retval == ERROR_MORE_DATA ); 

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\openfiles\openfilescomp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\openfiles\openfilescomp\openf.h ===
// OpenF.h : Declaration of the COpenF


#ifndef __OPENF_H_
#define __OPENF_H_

#include "resource.h"       // main symbols
#include <asptlb.h>         // Active Server Pages Definitions
#include "OpenFilesDef.h"

/////////////////////////////////////////////////////////////////////////////
// COpenF
class ATL_NO_VTABLE COpenF : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<COpenF, &CLSID_OpenF>,
	public IDispatchImpl<IOpenF, &IID_IOpenF, &LIBID_OPENFILESLib>
{
public:
	COpenF()
	{ 
		hNwModule = NULL;
		hMacModule = NULL;
		FpnwFileEnum = NULL;
		AfpAdminConnect = NULL;
		AfpAdminFileEnum = NULL;
	}

	~COpenF()
	{
		if(hNwModule!=NULL)
			::FreeLibrary (hNwModule);

		if(hMacModule!=NULL)
			::FreeLibrary (hMacModule);
	}

public:

DECLARE_REGISTRY_RESOURCEID(IDR_OPENF)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(COpenF)
	COM_INTERFACE_ENTRY(IOpenF)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IOpenF
public:

	STDMETHOD(getOpenFiles)(/*[out, retval]*/ VARIANT *pOpenFiles);

private:
	SAFEARRAYBOUND pSab[2];
	SAFEARRAY* pSa;
	HMODULE hMacModule;
	HMODULE hNwModule;
	FILEENUMPROC FpnwFileEnum;
	CONNECTPROC AfpAdminConnect; 
	FILEENUMPROCMAC AfpAdminFileEnum;

protected:
	DWORD GetNwOpenF( SAFEARRAY* pSa, DWORD dwIndex );
	DWORD GetNwOpenFileCount( LPDWORD lpdwCount  );
	DWORD GetMacOpenF(SAFEARRAY *  psa, DWORD dwIndex);
	DWORD GetMacOpenFileCount(LPDWORD count);
};



#endif //__OPENF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\openfiles\openfilescomp\openfiles.cpp ===
// OpenFiles.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f OpenFilesps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "OpenFiles.h"

#include "OpenFiles_i.c"
#include "OpenF.h"
#include "shareinfo.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_OpenF, COpenF)
OBJECT_ENTRY(CLSID_ShareInfo, CShareInfo)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_OPENFILESLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\openfiles\openfilescomp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OpenFiles.rc
//
#define IDS_PROJNAME                    100
#define IDR_OPENF                       101
#define IDR_NWSHARE                     102
#define IDR_NWSHARESCOLL                103
#define IDR_NWCOMP                      104
#define IDR_SHAREINFO                   105

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\openfiles\openfilescomp\shareinfo.cpp ===
// ShareInfo.cpp : Implementation of CShareInfo
#include "stdafx.h"
#include "openfiles.h"
#include "ShareInfo.h"
#include <Lm.h>
#include <lmapibuf.h>

#define SA_CIFS_CACHE_DISABLE			0x00000030
#define SA_CIFS_CACHE_MANUAL_DOCS		0x00000000
#define SA_CIFS_CACHE_AUTO_PROGRAMS		0x00000020
#define SA_CIFS_CACHE_AUTO_DOCS			0x00000010


  

/////////////////////////////////////////////////////////////////////////////
// CShareInfo

STDMETHODIMP CShareInfo::InterfaceSupportsErrorInfo(REFIID riid)
{
	static const IID* arr[] = 
	{
		&IID_IShareInfo
	};
	for (int i=0; i < sizeof(arr) / sizeof(arr[0]); i++)
	{
		if (InlineIsEqualGUID(*arr[i],riid))
			return S_OK;
	}
	return S_FALSE;
}



STDMETHODIMP CShareInfo::SetShareInfo( BSTR bstrShareName, DWORD dwCache )
{
	HRESULT hr = S_OK;

	try
	{
		if ( !bstrShareName )
		{
			hr = E_FAIL;
			throw hr;
		}

		if (! ( dwCache == SA_CIFS_CACHE_DISABLE  ||
				dwCache == SA_CIFS_CACHE_MANUAL_DOCS ||
				dwCache == SA_CIFS_CACHE_AUTO_PROGRAMS ||
				dwCache == SA_CIFS_CACHE_AUTO_DOCS  ))
		{
			hr = E_FAIL;
			throw hr;
		}


		TCHAR FAR *        pBuffer;
		DWORD cacheable;
		PSHARE_INFO_1005	s1005;
		USHORT maxLen;

		

		ZeroMemory( &s1005, sizeof(s1005) );


		if(  NetShareGetInfo(NULL,
								   bstrShareName,
								   1005,
								   (LPBYTE*)&s1005)) 
		{
			hr = E_FAIL;
			throw hr;
		}


		s1005->shi1005_flags = dwCache;

		if(  (USHORT)NetShareSetInfo( NULL,
										   bstrShareName,
										   1005,
										   (LPBYTE)s1005,
											NULL )) 
		{
			 hr = E_FAIL;
			 throw hr;
		}


		NetApiBufferFree( s1005 );

	}
	catch(...)
	{
	}

	return S_OK;


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\openfiles\openfilescomp\shareinfo.h ===
// ShareInfo.h : Declaration of the CShareInfo

#ifndef __SHAREINFO_H_
#define __SHAREINFO_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CShareInfo
class ATL_NO_VTABLE CShareInfo : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CShareInfo, &CLSID_ShareInfo>,
	public ISupportErrorInfo,
	public IDispatchImpl<IShareInfo, &IID_IShareInfo, &LIBID_OPENFILESLib>
{
public:
	CShareInfo()
	{
		m_pUnkMarshaler = NULL;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SHAREINFO)
DECLARE_GET_CONTROLLING_UNKNOWN()

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CShareInfo)
	COM_INTERFACE_ENTRY(IShareInfo)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
	COM_INTERFACE_ENTRY_AGGREGATE(IID_IMarshal, m_pUnkMarshaler.p)
END_COM_MAP()

	HRESULT FinalConstruct()
	{
		return CoCreateFreeThreadedMarshaler(
			GetControllingUnknown(), &m_pUnkMarshaler.p);
	}

	void FinalRelease()
	{
		m_pUnkMarshaler.Release();
	}

	CComPtr<IUnknown> m_pUnkMarshaler;

// ISupportsErrorInfo
	STDMETHOD(InterfaceSupportsErrorInfo)(REFIID riid);

// IShareInfo
public:
	STDMETHOD( SetShareInfo )( BSTR bstrShareName, DWORD dwCache );
};

#endif //__SHAREINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\openfiles\openfilescomp\secdesc.h ===
#ifndef _SECDESC_H
#define _SECDESC_H

#include "openfilesdef.h"
#include "account.h"




//+-------------------------------------------------------------------------
//
//  Class:     FastAllocator
//
//  Synopsis:  takes in a buffer, buffer size, and needed size, and either
//             uses the buffer, or allocates a new one for the size
//             and of course destroys it in the dtor
//
//--------------------------------------------------------------------------
class FastAllocator
{
public:

    inline FastAllocator(VOID *buf, LONG bufsize);
    inline ~FastAllocator();

    inline VOID *GetBuf(LONG neededsize);

private:

    VOID *_statbuf;
    VOID *_allocatedbuf;
    LONG  _statbufsize;
    BOOL  _allocated;
};

FastAllocator::FastAllocator(VOID *buf, LONG bufsize)
    :_statbuf(buf),
     _statbufsize(bufsize),
     _allocated(FALSE)
{
}

FastAllocator::~FastAllocator()
{
    if (_allocated)
        delete _allocatedbuf;
}

VOID *FastAllocator::GetBuf(LONG neededsize)
{
    if (neededsize > _statbufsize)
    {
       _allocatedbuf = (VOID *)new BYTE[neededsize];
       if (_allocatedbuf)
           _allocated = TRUE;
    } else
    {
        _allocatedbuf = _statbuf;
    }
    return(_allocatedbuf);
}




typedef struct _USER_ACESSINFO
{
    CAccount *pAcc;
    BYTE byAceType;
	DWORD dwAccessMask;
} USER_ACESSINFO;

class CSecDesc
{
public:
	CSecDesc(BYTE *psd);
	HRESULT Init();
	HRESULT AddUserAccess(LPWSTR szUser, LPWSTR szDomain, BYTE byAceType, DWORD dwAccessMask);
	HRESULT GetSecDescAndSize(BYTE **ppsd);

private:
	BYTE *m_psd;
	ULONG m_ulNumAces;
	USER_ACESSINFO m_UserAcessInfo[MAX_ACES];
	
	HRESULT NewDefaultDescriptor( OUT PSECURITY_DESCRIPTOR  *ppsd );
	ULONG GetAclSize(ULONG *caclsize);
	ULONG BuildAcl(ACL **pnewdacl);
	ULONG AllocateNewAcl(ACL **ppnewdacl, ULONG caclsize);
	ULONG SetAllowedAce(ACL *dacl, ACCESS_MASK mask, SID *psid);
	ULONG SetDeniedAce(ACL *dacl, ACCESS_MASK mask, SID *psid);
	ULONG FillNewAcl(ACL *pnewdacl);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\openfiles\openfilescomp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__994798EF_4CDA_4C0C_A6B0_ED62F74C1C86__INCLUDED_)
#define AFX_STDAFX_H__994798EF_4CDA_4C0C_A6B0_ED62F74C1C86__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <crtdbg.h>
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

DEFINE_GUID ( IID_IShareInfo,0xCDB96FC3,0x79C4,0x46CD,0x84,0x09,0x93,0x9D,0x02,0x3F,0x87,0x94);


DEFINE_GUID( CLSID_ShareInfo,0x76837C5E,0x10CA,0x40C4,0x8F,0xFF,0x2F,0xCD,0x15,0x57,0x21,0x65);


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__994798EF_4CDA_4C0C_A6B0_ED62F74C1C86__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\openfiles\openfilescomp\openfilesdef.h ===
#ifndef _OPENFILES_DEF_H
#define _OPENFILES_DEF_H

#include <windows.h>
#include <winperf.h>
#include <lmcons.h>
#include <lmerr.h>
#include <dbghelp.h>
#include <psapi.h>
#include <tchar.h>
#include <Winbase.h>
#include <lm.h>
#include <Lmserver.h>
#include <winerror.h>
#include <time.h>
#include <tchar.h>
#include <stdio.h>
#include <crtdbg.h>
#include <atlbase.h>


#define MAX_ACES	64
#define ALLOWED_ACE 0
#define DENIED_ACE 1

#define ACCESS_READ_PERM		0x1200A9
#define ACCESS_CHANGE_PERM		0x1301BF
#define ACCESS_FULL_PERM		0x1F01FF
#define ACCESS_UNKNOWN_PERM		0x0

#define STR_READ		_TEXT("R")
#define STR_CHANGE		_TEXT("C")
#define STR_FULL		_TEXT("F")

// To handle all exceptions
#define ONFAILTHROWERROR(hr) \
{	\
	if (FAILED(hr)) \
		throw _com_issue_error(hr); \
}

#define FPNWCLNTDLL _TEXT("FPNWCLNT.DLL")


inline DWORD GetAccessMask(LPWSTR lpAccessStr)
{
	if(!lstrcmpi(lpAccessStr, STR_READ))
		return ACCESS_READ_PERM;
	else if(!lstrcmpi(lpAccessStr, STR_CHANGE))
		return ACCESS_CHANGE_PERM;
	else if(!lstrcmpi(lpAccessStr, STR_FULL))
		return ACCESS_FULL_PERM;
	else
		return ACCESS_UNKNOWN_PERM;
}
/****************  structures and prototypes for nw shares ************/

#define FPNWVOL_TYPE_DISKTREE 0
#define NERR_Success 0

#define FPNWFILE_PERM_READ	0x01
#define FPNWFILE_PERM_WRITE	0x02
#define FPNWFILE_PERM_CREATE 0x04
#define FILE_INFO_3 0x03

/*
DWORD
FpnwFileEnum(
	IN LPWSTR pServerName OPTIONAL,
	IN DWORD  dwLevel,
	IN LPWSTR pPathName OPTIONAL,
	OUT LPBYTE *ppFileInfo,
	OUT PDWORD pEntriesRead,
	IN OUT PDWORD resumeHandle OPTIONAL
);
*/

/*
DWORD
FpnwVolumeEnum(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    OUT LPBYTE *ppVolumeInfo,
    OUT PDWORD pEntriesRead,
    IN OUT PDWORD resumeHandle OPTIONAL
);
*/

/*
DWORD
FpnwVolumeGetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    OUT LPBYTE *ppVolumeInfo
);*/

/*
DWORD
FpnwVolumeSetInfo(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName,
    IN  DWORD  dwLevel,
    IN  LPBYTE pVolumeInfo
);
*/

/*DWORD
FpnwVolumeAdd(
    IN  LPWSTR pServerName OPTIONAL,
    IN  DWORD  dwLevel,
    IN  LPBYTE pVolumeInfo
)*/

/*
DWORD
FpnwVolumeDel(
    IN  LPWSTR pServerName OPTIONAL,
    IN  LPWSTR pVolumeName
);
*/

typedef DWORD   (WINAPI *FILEENUMPROC) (LPWSTR,DWORD,LPWSTR,PBYTE*,PDWORD,PDWORD);
typedef  DWORD  (WINAPI *VOLUMEENUMPROC) (LPWSTR,DWORD,LPBYTE*,PDWORD,PDWORD);
typedef  DWORD  (WINAPI *VOLUMEGETINFOPROC) (LPWSTR,LPWSTR,DWORD,LPBYTE*);
typedef	 DWORD  (WINAPI *VOLUMESETINFOPROC) (LPWSTR,LPWSTR,DWORD,LPBYTE);
typedef	 DWORD  (WINAPI *VOLUMEADDPROC) (LPWSTR,DWORD,LPBYTE);
typedef  DWORD  (WINAPI *VOLUMEDELPROC) (LPTSTR,LPTSTR);

typedef enum _FPNW_API_INDEX
{
  FPNW_VOLUME_ENUM = 0,
  FPNW_FILE_ENUM,
  FPNW_API_BUFFER_FREE,
  FPNW_VOLUME_DEL,
  FPNW_VOLUME_ADD,
  FPNW_FILE_CLOSE,
  FPNW_VOLUME_GET_INFO,
  FPNW_VOLUME_SET_INFO
}FPNW_API_INDEX;

//
//  This is the level 1 structure for FpnwVolumeAdd, FpnwVolumeDel, FpnwVolumeEnum,
//  FpnwVolumeGetInfo, & FpnwVolumeSetInfo.
//

typedef struct _FPNWVolumeInfo
{
    LPWSTR    lpVolumeName;           // Name of the volume
    DWORD     dwType;                 // Specifics of the volume. FPNWVOL_TYPE_???
    DWORD     dwMaxUses;              // Maximum number of connections that are
                                      // allowed to the volume
    DWORD     dwCurrentUses;          // Current number of connections to the volume
    LPWSTR    lpPath;                 // Path of the volume

} FPNWVOLUMEINFO, *PFPNWVOLUMEINFO;


//
//  This is the level 2 structure for FpnwVolumeAdd, FpnwVolumeDel, FpnwVolumeEnum,
//  FpnwVolumeGetInfo, & FpnwVolumeSetInfo.
//  Note that this is not supported on the FPNW beta.
//

typedef struct _FPNWVolumeInfo_2
{
    LPWSTR    lpVolumeName;           // Name of the volume
    DWORD     dwType;                 // Specifics of the volume. FPNWVOL_TYPE_???
    DWORD     dwMaxUses;              // Maximum number of connections that are
                                      // allowed to the volume
    DWORD     dwCurrentUses;          // Current number of connections to the volume
    LPWSTR    lpPath;                 // Path of the volume

    DWORD     dwFileSecurityDescriptorLength; // reserved, this is calculated
    PSECURITY_DESCRIPTOR FileSecurityDescriptor;

} FPNWVOLUMEINFO_2, *PFPNWVOLUMEINFO_2;

// fpnwapi.h
typedef  struct _FPNWFileInfo
{
    DWORD     dwFileId;               // File identification number
    LPWSTR    lpPathName;             // Full path name of this file
    LPWSTR    lpVolumeName;           // Volume name this file is on
    DWORD     dwPermissions;          // Permission mask: FPNWFILE_PERM_READ,
                                      //                  FPNWFILE_PERM_WRITE,
                                      //                  FPNWFILE_PERM_CREATE...
    DWORD     dwLocks;                // Number of locks on this file
    LPWSTR    lpUserName;             // The name of the user that established the
                                      // connection and opened the file
    BYTE WkstaAddress[12];      // The workstation address which opened the file
    DWORD     dwAddressType;          // Address type: IP, IPX

} FPNWFILEINFO, *PFPNWFILEINFO;

/******************  end structures and prototypes for nw shares ********************/

/****************** structures and prototypes for apple talk ***********************/

typedef DWORD (WINAPI *CONNECTPROC) (LPWSTR,DWORD*);
typedef DWORD (WINAPI *FILEENUMPROCMAC) (DWORD,PBYTE*,DWORD,LPDWORD,LPDWORD,LPDWORD);

typedef struct _AFP_FILE_INFO
{
	DWORD	afpfile_id;					// Id of the open file fork
	DWORD	afpfile_open_mode;			// Mode in which file is opened
	DWORD	afpfile_num_locks;			// Number of locks on the file
	DWORD	afpfile_fork_type;			// Fork type
	LPWSTR	afpfile_username;			// File opened by this user. max UNLEN
	LPWSTR	afpfile_path;				// Absolute canonical path to the file

} AFP_FILE_INFO, *PAFP_FILE_INFO;

// Used as RPC binding handle to server
typedef DWORD	AFP_SERVER_HANDLE;
typedef DWORD	*PAFP_SERVER_HANDLE;

/****************** end structures and prototypes for apple talk ***********************/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\saconfig\oemconfig\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//    oemconfigdll.pch will be the pre-compiled header
//    stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\saconfig\oemconfig\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__B69448FA_0C53_43ED_997B_18345F04870F__INCLUDED_)
#define AFX_STDAFX_H__B69448FA_0C53_43ED_997B_18345F04870F__INCLUDED_

//#if _MSC_VER > 1000
//#pragma once
//#endif // _MSC_VER > 1000


// Insert your headers here
//#define WIN32_LEAN_AND_MEAN        // Exclude rarely-used stuff from Windows headers


#include <windows.h>
#include <wbemidl.h>
#include <atlbase.h>
#include <atlconv.h>
#include <objbase.h>
#include <satrace.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B69448FA_0C53_43ED_997B_18345F04870F__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\saconfig\saconfig\saconfig.h ===
//////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      saconfig.h
//
//  Description:
//      CSAConfig class declaration
//
//  Author:
//      Alp Onalan  Created: Oct 6 2000
//
//////////////////////////////////////////////////////////////////////////


#if !defined(AFX_SACONFIG_H__E6445EED_84C7_48B8_940D_D67F4023CD32__INCLUDED_)
#define AFX_SACONFIG_H__E6445EED_84C7_48B8_940D_D67F4023CD32__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <debug.h>
#include <iostream.h>
#include <windows.h>
#include <winbase.h>
#include <atlbase.h>
#include <atlconv.h>
#include <oleauto.h>
#include <comdef.h>

#include <lm.h>
#include <satrace.h>
#include <setupapi.h>
#include <AppSrvcs.h>
#include "saconfigcommon.h"

class CSAConfig  
{
public:
    CSAConfig();
    virtual ~CSAConfig();
private:
    bool IsDefaultHostname();
    bool IsDefaultAdminPassword();

    bool IsFloppyPresent();
    bool DoConfigFromFloppy();
    bool ParseConfigFile();
     HRESULT SARaiseAlert();
    
    bool DoConfigFromRegistry(bool fDoHostname, bool fDoAdminPassword);
    bool ReadRegistryKeys();

    BOOL SetHostname(WCHAR *wszHostname);
    BOOL SetAdminPassword(WCHAR *wszAdminPassword);

private:
    WCHAR m_wszCurrentHostname[MAX_COMPUTERNAME_LENGTH];

    WCHAR m_wszHostname[MAX_COMPUTERNAME_LENGTH]; //winnt limit
    WCHAR m_wszAdminPassword[LM20_PWLEN];         //winnt limit

//TODO: Create another class for all registry read configuration
//        make registry related methods part of that class - better encapsulation
    WCHAR m_wszOEMDllName[NAMELENGTH];
    WCHAR m_wszOEMFunctionName[NAMELENGTH];
    WCHAR m_wszNetConfigDllName[NAMELENGTH];
    WCHAR m_wszDefaultAdminPassword[LM20_PWLEN];
    WCHAR m_wszDefaultHostname[MAX_COMPUTERNAME_LENGTH]; //winnt limit

    BOOL m_fInfKeyPresent[NUMINFKEY];
    
    WCHAR m_wszInfConfigTable [NUMINFKEY][NAMELENGTH];
    
    HINF m_hConfigFile;
        

public:
    LPSTR GetHostname();
    bool DoConfig(bool fDoHostname, bool fDoAdminPassword);
    
    
};

#endif // !defined(AFX_SACONFIG_H__E6445EED_84C7_48B8_940D_D67F4023CD32__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\saconfig\saconfig\saconfig.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      saconfig.cpp
//
//  Description:
//      Implementation of CSAConfig class.
//
//  Author:
//      Alp Onalan  Created: Oct 6 2000
//
//////////////////////////////////////////////////////////////////////////


#include "SAConfig.h"
#include "SAConfigCommon.h"
#include <sahelper.h>

void MakeStringHostnameCompliant(WCHAR *m_wszHostname);

//++---------------------------------------------------------------------------
//
//  Function:   CSAConfig
//
//  Synopsis:   Constructor for CSAConfig. Initializes class variables.
//
//  Arguments:  None
//
//  Returns:    None
//
//  History:    AlpOn      Created Oct 6 2000
//
//
//-----------------------------------------------------------------------------
CSAConfig::CSAConfig()
    :m_hConfigFile(NULL)
{
    //TODO: set hostname/password to defaults here, this maybe read from reg.
    m_wszAdminPassword[0]=L'\0';
    m_wszHostname[0]=L'\0';
    m_wszCurrentHostname[0]=L'\0';
    m_wszOEMDllName[0]=L'\0';
    m_wszOEMFunctionName[0]=L'\0';
    m_wszNetConfigDllName[0]=L'\0';
    m_wszDefaultAdminPassword[0]=L'\0';
    m_wszDefaultHostname[0]=L'\0';    
    

    for(int i=0;i<NUMINFKEY;i++)
        m_fInfKeyPresent[i]=FALSE;

}

//++---------------------------------------------------------------------------
//
//  Function:   ~CSAConfig
//
//  Synopsis:   Destructor for CSAConfig. Cleanup code.
//
//  Arguments:  None
//
//  Returns:    None
//
//  History:    AlpOn      Created Oct 6 2000
//
//
//-----------------------------------------------------------------------------

CSAConfig::~CSAConfig()
{

    CloseHandle(m_hConfigFile);
}

//++---------------------------------------------------------------------------
//
//  Function:   IsDefaultHostname()
//
//  Synopsis:  Checks to see if current hostname is same with the defaulthostname regkey
//            in the registry
//
//  Arguments:  None
//
//  Returns:    true if it is default, false otherwise
//
//  History:    AlpOn      Created Oct 6 2000
//
//
//-----------------------------------------------------------------------------

bool CSAConfig::IsDefaultHostname()
{
    bool fIsDefault=true;
    BOOL fSuccess=TRUE;
    WCHAR *wszHostname=new WCHAR[MAX_COMPUTERNAME_LENGTH];
    DWORD dwSize=MAX_COMPUTERNAME_LENGTH;

    do
    {
        //
        //If we have not set the hostname in saconfig before, get the hostname of the box...
        //
        if(0==lstrcmp(m_wszCurrentHostname,L"")) //currently we have not set a hostname
        {
            fSuccess=GetComputerNameEx(ComputerNamePhysicalDnsHostname,wszHostname,&dwSize);
            SATracePrintf("IsDefaultHostname: GetComputerNameEx - hostname: %ls",wszHostname);
            if (FALSE==fSuccess)
            {
                SATracePrintf("IsDefaultHostname:Unable to GetComputerNameEx, getlasterr:%x",GetLastError());
                break; //fIsDefault=true;could not read anything, assume it is default
            }
            if(0!=lstrcmpi(wszHostname,m_wszDefaultHostname))
            {
                SATracePrintf("IsDefaultHostname: Gethostname: NOT default hostname: %ls, defaultname:%ls",wszHostname,m_wszDefaultHostname);
                fIsDefault=false;
                break;
            }
            break;
        }
        if(0!=lstrcmpi(m_wszCurrentHostname,m_wszDefaultHostname))
        {
            SATracePrintf("IsDefaultHostname: NOT default currenthostname: %ls, defaultname:%ls",m_wszCurrentHostname,m_wszDefaultHostname);
            fIsDefault=false;
            break;
         }
    }while(false);

    delete []wszHostname;
    return fIsDefault;
}

bool CSAConfig::IsDefaultAdminPassword()
{
    bool fIsDefault=false;
    //
    //Implementation depends on rearm algorithm
    //can't really get the admin pass, use default adminpass and use 
    //an api that requires admin privilidges. if succeeds -return true, else false.
    //
    return fIsDefault;
}

//++---------------------------------------------------------------------------
//
//  Function:   IsFloppyPresent
//
//  Synopsis:  Checks to see if a floppy is inserted into the drive
//
//  Arguments:  None
//
//  Returns:    None
//
//  History:    AlpOn      Created Oct 6 2000
//
//-----------------------------------------------------------------------------
bool CSAConfig::IsFloppyPresent()
{
    bool fIsPresent=true;
    HANDLE hDrive=NULL;

    hDrive = CreateFile(
                    WSZ_DRIVENAME,
                    GENERIC_READ | GENERIC_WRITE,
                    FILE_SHARE_READ|FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );
    
    if ( hDrive == INVALID_HANDLE_VALUE )
    {
        SATracePrintf("IsFloppyPresent : no floppy getlasterror: %x", GetLastError());
        fIsPresent=false;
    }
    
    CloseHandle(hDrive);
     
    return fIsPresent;
}

//++---------------------------------------------------------------------------
//
//  Function:   DoConfig
//
//  Synopsis:  Called by main to do the actual configuration. This is the main configuration
//            routine that routes the configuration to different functions.
//
//  Arguments: 
//             fDoHostname -      Command line parameter passed in from main. 
//                                Set hostname if fDoHostname=true
//             fDoAdminPassword - Command line parameter passed in from main.
//                                Set admin passwd if fDoAdminPassword=true
//
//
//  Returns:    true/false  based on success
//
//  History:    AlpOn      Created Oct 6 2000
//
//
//-----------------------------------------------------------------------------
bool CSAConfig::DoConfig(bool fDoHostname,bool fDoAdminPassword)
{
    bool fRes=true;

    //
    //Read all the configuration settings for SAConfig from the registry
    //
    if (!ReadRegistryKeys())
    {
        fRes=false;
        SATraceString("DoConfigFromRegistry::ReadRegistryKeys failed");
    }

    if(true==IsFloppyPresent())
    {
        DoConfigFromFloppy();
    }
    
    if(/*IsDefaultAdminPassword() ||*/ IsDefaultHostname())
    {
        fRes=DoConfigFromRegistry(fDoHostname,fDoAdminPassword);
    }
    return fRes;

}

//++---------------------------------------------------------------------------
//
//  Function:   SARaiseAlert
//
//  Synopsis:  Called by ParseConfigFile to raise alert if the inf file is invalid.
//
//  Arguments: None
//
//  Returns:   HRESULT 
//
//  History:    AlpOn      Created Oct 6 2000
//
//
//-----------------------------------------------------------------------------
HRESULT CSAConfig::SARaiseAlert()
{
    DWORD                     dwAlertType=SA_ALERT_TYPE_ATTENTION;
    DWORD                    dwAlertId=0; //= SA_INITIALCONFIG_INFERROR; // from the resource dll header file
    _bstr_t                    bstrAlertLog(L"saconfigmsg.dll");//RESOURCE_DLL_NAME);
    _bstr_t                 bstrAlertSource(L"");
    _variant_t                 varReplacementStrings;
    _variant_t                 varRawData;
    LONG                     lCookie;


    HRESULT hrRet=S_OK;

    CoInitialize(NULL);
    do
    {
        CComPtr<IApplianceServices> pAppSrvcs;
              hrRet = CoCreateInstance(CLSID_ApplianceServices,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IApplianceServices,
                          (void**)&pAppSrvcs);
        
        if (FAILED(hrRet))
          {
            SATracePrintf("CSAConfig::RaiseAlert failed in CoCreateInstance %X ", hrRet);
            break;
        }

         
        hrRet = pAppSrvcs->Initialize();
        if (FAILED(hrRet))
           {
            SATracePrintf("CSAConfig::RaiseAlert failed in Initialize %X ", hrRet);
            break;
        }
            
        hrRet = pAppSrvcs->RaiseAlert(dwAlertType, 
                                    dwAlertId,
                                    bstrAlertLog, 
                                    bstrAlertSource, 
                                    SA_ALERT_DURATION_ETERNAL,        
                                    &varReplacementStrings,    
                                    &varRawData,      
                                    &lCookie);

    }while(false);

    CoUninitialize();
    return hrRet;    
}

//++---------------------------------------------------------------------------
//
//  Function:   DoConfigFromFloppy
//
//  Synopsis:  Called by DoConfig, if IsFloppyPresent returns true.
//            This function calls ParseConfigfile if an inf file is present on the floppy.
//
//  Arguments: 
//            None
//
//  Returns:    true/false  based on success
//
//  History:    AlpOn      Created Oct 6 2000
//
//
//-----------------------------------------------------------------------------
bool CSAConfig::DoConfigFromFloppy()
{
    bool fReturn=true;
    
    do
    {
        m_hConfigFile=SetupOpenInfFile(
                              WSZ_CONFIGFILENAME, 
                              0, // the class of the INF file
                              INF_STYLE_WIN4, 
                              NULL  
                              );


        if ( m_hConfigFile == INVALID_HANDLE_VALUE )
        {
            SATracePrintf("DoConfigFromFloppy, invalid config file handle, file is not there? %x", GetLastError());
            fReturn=false;
            SARaiseAlert();
            break;
          }

        if( false == ParseConfigFile())
        {
            SATraceString("DoConfigFromFloppy, parser returning false, invalid file format");
            fReturn=false;
            SARaiseAlert(); //inf file is invalid, raise alert here
            break;
        }
    }while(false);

    return fReturn;

}

//++---------------------------------------------------------------------------
//
//  Function:   ParseConfigFile
//
//  Synopsis:  Parses the inf file and calls the machine configuration functions
//
//  Arguments: 
//            None
//  Returns:   true/false  based on success
//
//  History:    AlpOn      Created Oct 6 2000
//
//
//-----------------------------------------------------------------------------
bool CSAConfig::ParseConfigFile()
{
    HRESULT hrRet;

    bool fParseOK=true;
    
    INFCONTEXT infContext;

    
    for (int i=0;i<NUMINFKEY;i++)
    {
        //
        //Parse the inf file, hold the configuration info in a table
        //Track which keys are set in inf file in a boolean table
        //TODO: Do error handling for following 2 api calls
        //
        
        m_fInfKeyPresent[i]=SetupFindFirstLine(
                        m_hConfigFile,      // handle to an INF file
                        INF_SECTION_SACONFIG,      // section in which to find a line
                        INF_KEYS[i],          // optional, key to search for
                        &infContext  // context of the found line
                        );

        SetupGetStringField (&infContext, 1, m_wszInfConfigTable[i], NAMELENGTH, NULL);
        SATracePrintf("Reading %ls from inf file as %ls ",INF_KEYS[i],m_wszInfConfigTable[i]);

    }


    //
    //we need to have at least one of these settings to proceed
    //
    if(FALSE==(m_fInfKeyPresent[SAHOSTNAME]||m_fInfKeyPresent[ADMINPASSWD]||
        m_fInfKeyPresent[IPNUM]||m_fInfKeyPresent[SUBNETMASK]||m_fInfKeyPresent[DEFAULTGATEWAY]))
    {
        fParseOK=false;
        goto cleanup;
    }


    //
    //If either of the network settings are present, it should be all of them or none of them
    //
    if(m_fInfKeyPresent[IPNUM]||m_fInfKeyPresent[SUBNETMASK]||m_fInfKeyPresent[DEFAULTGATEWAY])
    {
        if(!(m_fInfKeyPresent[IPNUM]&&m_fInfKeyPresent[SUBNETMASK]&&m_fInfKeyPresent[DEFAULTGATEWAY]))
        {
            fParseOK=false;
            goto cleanup;
        }
    }


    if(m_fInfKeyPresent[SAHOSTNAME])
    {
        //wcscpy(m_wszHostname,m_wszInfConfigTable[SAHOSTNAME]);
        SetHostname(m_wszInfConfigTable[SAHOSTNAME]);
    }

    if(m_fInfKeyPresent[ADMINPASSWD])
    {
       // wcscpy(m_wszAdminPassword,m_wszInfConfigTable[ADMINPASSWD]);
        SetAdminPassword(m_wszInfConfigTable[ADMINPASSWD]);
    }

    
    
    hrRet=CoInitialize(NULL);

    do
    {

        if (FAILED(hrRet))
          {
            SATracePrintf("Failed to initialize com libraries %X ", hrRet);
            break;
        }

        CComPtr<ISAHelper> pSAHelper;

        hrRet = CoCreateInstance(CLSID_SAHelper,
                               NULL,
                               CLSCTX_INPROC_SERVER,
                               IID_ISAHelper,
                               (void**)&pSAHelper);
        
        if (FAILED(hrRet))
          {
            SATracePrintf("Failed to instantiate SAHelper is SAHelper.dll registered? %X ", hrRet);
            break;
        }

        hrRet = pSAHelper->SetStaticIp(W2BSTR(m_wszInfConfigTable[IPNUM]), 
                                    W2BSTR(m_wszInfConfigTable[SUBNETMASK]),
                                    W2BSTR(m_wszInfConfigTable[DEFAULTGATEWAY]));

        if (FAILED(hrRet))
        {
            SATracePrintf("SetStaticIp failed %X ", hrRet);
            break;
        }
        
    }while(false);

    CoUninitialize();
    
cleanup:
    return fParseOK;

}


//++---------------------------------------------------------------------------
//
//  Function:   SetHostname
//
//  Synopsis:  Sets the machines physical hostname
//
//  Arguments: 
//            wszHostname - hostname to be set
//
//  Returns:   TRUE/FALSE  Success/failure
//
//  History:    AlpOn      Created Oct 6 2000
//
//
//-----------------------------------------------------------------------------
BOOL CSAConfig::SetHostname(WCHAR *wszHostname)
{
    //check for NULL string
    BOOL fSuccess=true;
    fSuccess = SetComputerNameEx(ComputerNamePhysicalDnsHostname, wszHostname);
    if (false==fSuccess)
    {
        SATracePrintf("SetHostName::Unable to set hostname,getlasterr:%x",GetLastError());
    }
    else
    {
        //
        //name change succeeded. set the current hostname string
        //the reason is that the hostname that is set does not apply until next boot, so we need to track
        //our changes
        //
        wcscpy(m_wszCurrentHostname,wszHostname);
    }
    return fSuccess;
}


//++---------------------------------------------------------------------------
//
//  Function:   SetAdminPassword
//
//  Synopsis:  Sets the admin password
//
//  Arguments: 
//            wszAdminPassword - password to be set
//
//  Returns:   TRUE/FALSE  Success/failure
//
//  History:    AlpOn      Created Oct 6 2000
//
//
//-----------------------------------------------------------------------------
BOOL CSAConfig::SetAdminPassword(WCHAR *wszAdminPassword)
{
    //check for NULL string
    BOOL fSuccess= true;
    USER_INFO_1003  pi1003;
    NET_API_STATUS  nas;
    
    pi1003.usri1003_password = wszAdminPassword;

    nas = NetUserSetInfo(
                NULL,  // use current computer
                WSZ_USERNAME,      // Administrator
                1003,           // info level
                (LPBYTE)&pi1003,     // new info
                NULL
                );

    if (nas!= NERR_Success)
    {
        SATracePrintf("SetAdminPassword:Could not set the administrator password! retVal=%x",nas);
        fSuccess=false;
    }

    return fSuccess;
}



//++---------------------------------------------------------------------------
//
//  Function:  ReadRegistryKeys
//
//  Synopsis:  Reads the configuration info from registry
//
//  Arguments: 
//            None
//
//  Returns:   TRUE/FALSE  Success/failure
//
//  History:    AlpOn      Created Oct 6 2000
//
//
//-----------------------------------------------------------------------------
bool CSAConfig::ReadRegistryKeys()
{

    bool fRes=true;
    DWORD dwSize=0;
    CRegKey hConfigKey;
    LONG lRes=0;

    do{
        lRes=hConfigKey.Open(HKEY_LOCAL_MACHINE,
                        REGKEY_SACONFIG,
                        KEY_READ);

        if(lRes!=ERROR_SUCCESS)
        {
        //    cout << "Unable to open saconfig regkey\n";
            SATracePrintf("Unable to open saconfig regkey, lRes= %x", lRes);
            fRes=false;
            break;
        }
        

        //TODO:check the string sizes returned from registry calls
        //TODO:add tracelog stuff
        

        lRes=hConfigKey.QueryValue(NULL,REGSTR_VAL_HOSTNAMEPREFIX,&dwSize);
        lRes=hConfigKey.QueryValue(m_wszHostname,REGSTR_VAL_HOSTNAMEPREFIX,&dwSize);
        if(lRes!=ERROR_SUCCESS)
        {
            SATracePrintf("Unable to query hostnameprefix regkey lRes= %x",lRes);
            //cout << "Unable to read hostnameprefix regkey\n";
            fRes=false;
            break;
        }

        if(lstrlen(m_wszHostname) > MAX_COMPUTERNAME_LENGTH)
        {
            SATracePrintf("Computer name prefix in registry is larger than max allowable hostname length: %x",lstrlen(m_wszHostname));
            fRes=false;
            break;
        }
    
        lRes=hConfigKey.QueryValue(NULL,REGSTR_VAL_ADMINPASSPREFIX,&dwSize);
        lRes=hConfigKey.QueryValue(m_wszAdminPassword,REGSTR_VAL_ADMINPASSPREFIX,&dwSize);
        if(lRes!=ERROR_SUCCESS)
        {
            SATracePrintf("Unable to query adminprefix regkey lRes= %x",lRes);
            fRes=false;
            break;
        }

        lRes=hConfigKey.QueryValue(NULL,REGSTR_VAL_OEMDLLNAME,&dwSize);
        lRes=hConfigKey.QueryValue(m_wszOEMDllName,REGSTR_VAL_OEMDLLNAME,&dwSize);
        SATracePrintf("ReadRegistryKeys: reading  oemdllname as = %ls", m_wszOEMDllName);
        if(lRes!=ERROR_SUCCESS)
        {
            SATracePrintf("Unable to query oemdllname regkey lRes= %x",lRes);
            fRes=false;
            break;
        }

        lRes=hConfigKey.QueryValue(NULL,REGSTR_VAL_DEFAULTHOSTNAME,&dwSize);
        lRes=hConfigKey.QueryValue(m_wszDefaultHostname,REGSTR_VAL_DEFAULTHOSTNAME,&dwSize);
        if(lRes!=ERROR_SUCCESS)
        {
            SATracePrintf("Unable to query default hostaname regkey lRes= %x",lRes);
            fRes=false;
            break;
        }

        lRes=hConfigKey.QueryValue(NULL,REGSTR_VAL_DEFAULTADMINPASS,&dwSize);
        lRes=hConfigKey.QueryValue(m_wszDefaultAdminPassword,REGSTR_VAL_DEFAULTADMINPASS,&dwSize);
        if(lRes!=ERROR_SUCCESS)
        {
            SATracePrintf("Unable to query default adminpass regkey lRes= %x",lRes);
            fRes=false;
            break;
        }


    }while(false);
    
    if(hConfigKey.m_hKey)
    {
        hConfigKey.Close();
    }
    return fRes;
}


//++---------------------------------------------------------------------------
//
//  Function:  DoConfigFromRegistry
//
//  Synopsis:  When an inf file is not present we do the configuration via the oemconfigdll.dll
//
//  Arguments: 
//            fDoHostname      - Set hostname
//            fDoAdminPassword - Set admin password 
//
//  Returns:   TRUE/FALSE  Success/failure
//
//  History:    AlpOn      Created Oct 6 2000
//
//
//-----------------------------------------------------------------------------
bool CSAConfig::DoConfigFromRegistry(bool fDoHostname, bool fDoAdminPassword)
{
    bool fRes=true;
    HINSTANCE hInstance=NULL;

    WCHAR *wszUniqueSuffix=new WCHAR[NAMELENGTH];
    WCHAR *wszHostSuffix=new WCHAR[NAMELENGTH];
    WCHAR *wszPasswdSuffix=new WCHAR[NAMELENGTH];

    do
    {

        hInstance=LoadLibrary(m_wszOEMDllName);
        if(NULL==hInstance)
        {
            fRes=false;
            SATracePrintf("DoConfigFromRegistry: Unable to load DLL! Dllname= %ls getlasterr: %x", m_wszOEMDllName, GetLastError()); 
            break;
        }

        typedef HRESULT (GetUniqueSuffix)(WCHAR *);
        GetUniqueSuffix *pGetUniqueSuffix=NULL;
        pGetUniqueSuffix=(GetUniqueSuffix*)::GetProcAddress(hInstance,"GetUniqueSuffix");
        if(NULL==pGetUniqueSuffix)
        {
            fRes=false;
            DWORD dwTemp=GetLastError();
            SATracePrintf("DoConfigFromRegistry: GetProcaddress failed %x",dwTemp);
            break;
        }


        HRESULT hRes=(*pGetUniqueSuffix)(wszUniqueSuffix);
        if(S_OK!=hRes)
        {
            fRes=false;
            SATraceString("GetUniqueAddress failed");
            break;
        }
        
        //
        //Do not modify the string returned, save copies of it for hostname and passwd
        //
        wcscpy(wszHostSuffix,wszUniqueSuffix);
        SATracePrintf("wszHostSuffix: %ls ", wszHostSuffix);
        wcscpy(wszPasswdSuffix,wszUniqueSuffix);         
        SATracePrintf("wszPasswdSuffix: %ls ", wszPasswdSuffix);

        //
        //This is for the command line case,  -hostname, -adminpass
        //
        if(true==fDoHostname)
        {
            MakeStringHostnameCompliant(m_wszHostname);
            MakeStringHostnameCompliant(wszHostSuffix);
            if ((lstrlen(m_wszHostname) + lstrlen(wszHostSuffix)) > MAX_COMPUTERNAME_LENGTH)
            {
                fRes=false;
                //cout << "Hostname string length is greater than MAX_COMPUTERNAME_LENGTH";
                SATraceString("DOConfigFromRegistry::Hostname length is > MAX_COMPUTERNAME_LENGTH");
                SATracePrintf("DOConfigFromRegistry::m_wszHostname = %ls wszUniqueSuffix = %ls",m_wszHostname,wszUniqueSuffix);
                break;
            }

            wcscat(m_wszHostname,wszHostSuffix);
            if(!SetHostname(m_wszHostname))
            {
                fRes=false;
                SATraceString("DoConfigFromRegistry:SetHostname() failed");
            }
        }

        if(true==fDoAdminPassword)
        {
            if ((lstrlen(m_wszAdminPassword) + lstrlen(wszPasswdSuffix)) > LM20_PWLEN )
            {
                fRes=false;
                SATraceString("DOConfigFromRegistry::Password length is > LM20_PWLEN.Too big");
                break;
            }
            wcscat(m_wszAdminPassword,wszPasswdSuffix);
            if(!SetAdminPassword(m_wszAdminPassword))
            {
                fRes=false;
                SATraceString("DoConfigFromRegistry::Failed to set admin password");
                break;
            }
        }
    }while(false);

    if(hInstance)
    {
        FreeLibrary(hInstance);
    }
    
    delete []wszUniqueSuffix;
    delete []wszHostSuffix;
    delete []wszPasswdSuffix;

    return fRes;
}



//++---------------------------------------------------------------------------
//
//  Function:  MakeStringHostnameCompliant
//
//  Synopsis:  Makes a string compliant with hostname rules before setting the hostname
//
//  Arguments: 
//            IN/OUT 
//wszHostname - hostname to be set
//
//  Returns:   TRUE/FALSE  Success/failure
//
//  History:    AlpOn      Created Oct 6 2000
//
//
//-----------------------------------------------------------------------------
void MakeStringHostnameCompliant(WCHAR *m_wszHostname)
{
    WCHAR *wszTemp=m_wszHostname;
    //
    //ISSUE: Check allowable char set again,also some chars are illegal as first char
    //

    while(*wszTemp)
    { 
        if(
           ((L'a'<= *wszTemp) && (*wszTemp <= L'z')) ||
           ((L'A'<= *wszTemp) && (*wszTemp <= L'Z')) ||
           ((L'0'<= *wszTemp) && (*wszTemp <= L'9')) ||
            (L'-'== *wszTemp)     ||
            (L'_'== *wszTemp)
           )
        {
            *m_wszHostname = *wszTemp;
            m_wszHostname++;
            wszTemp++;
        }
        else
            wszTemp++;
    }
    *m_wszHostname=L'\0';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\selfsigncert\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SelfSignCert.rc
//
#define IDS_PROJNAME                    100
#define IDS_SELFSIGNCERT_DESC           101
#define IDR_SelfSignCert                102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\selfsigncert\src\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\saconfig\oemconfig\oemconfigdll.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      oemconfigdll.cpp
//
//  Description:
//      Implementation of GetUniqueSuffix function 
//           which returns a unique suffix to the caller
//
//  Author:
//      Alp Onalan  Created: Oct 6 2000
//
//////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "..\saconfig\saconfigcommon.h"
#include <atlimpl.cpp>

const WCHAR REGSTR_VAL_WMICLASSNAME[]=L"WMIClassName";
const WCHAR REGSTR_VAL_WMIPROPERTYNAME[]=L"WMIPropertyName";

const WCHAR WSZ_NAMESPACE[]=L"\\\\.\\root\\cimv2";

#define BLOCKSIZE (32 * sizeof(WCHAR))
#define CVTBUFSIZE (309+40) /* # of digits in max. dp value + slop  (this size stolen from cvt.h in c runtime library) */

bool GetWMISettings(WCHAR *wszWMIClassName,WCHAR *wszWMIPropertyName)
{

    bool fRes=true;
    DWORD dwSize=0;
    CRegKey hConfigKey;
    LONG lRes=0;


    do{
        lRes=hConfigKey.Open(HKEY_LOCAL_MACHINE,
                        REGKEY_SACONFIG,
                        KEY_READ);

        if(lRes!=ERROR_SUCCESS)
        {
            SATracePrintf("Unable to open saconfig regkey, lRes= %x", lRes);
            fRes=false;
            break;
        }

        lRes=hConfigKey.QueryValue(NULL,REGSTR_VAL_WMICLASSNAME,&dwSize);
        lRes=hConfigKey.QueryValue(wszWMIClassName,REGSTR_VAL_WMICLASSNAME,&dwSize);
        if(lRes!=ERROR_SUCCESS)
        {
            SATracePrintf("Unable to query WMIClassName regkey lRes= %x",lRes);
              fRes=false;
            break;
        }

        lRes=hConfigKey.QueryValue(NULL,REGSTR_VAL_WMIPROPERTYNAME,&dwSize);
        lRes=hConfigKey.QueryValue(wszWMIPropertyName,REGSTR_VAL_WMIPROPERTYNAME,&dwSize);

        if(lRes!=ERROR_SUCCESS)
        {
            SATracePrintf("Unable to query WMIPropertyName regkey lRes= %x",lRes);
               fRes=false;
            break;
        }
    }while(false);

    if(hConfigKey.m_hKey)
    {
        hConfigKey.Close();
    }

    return fRes;
}

STDAPI GetUniqueSuffix (WCHAR *wszUniqueSuffix)
{
    WCHAR *wszWMIClassName=new WCHAR[NAMELENGTH];
    WCHAR *wszWMIPropertyName=new WCHAR[NAMELENGTH];
    
    SATraceString("OEMDLL::GetUniqueSuffix called");
    
    HRESULT hRes=S_OK;
    hRes=CoInitialize(NULL);
    do
    {
        if(false==GetWMISettings(wszWMIClassName,wszWMIPropertyName))
        {
            SATracePrintf("OEMDLL::GetUniqueSuffix: GetWMISettings failed %x", hRes);
            break;
        }

        if(hRes!=S_OK)
        {
           // break;
        }
    
        hRes = CoInitializeSecurity( NULL, -1, NULL, NULL,
                                 RPC_C_AUTHN_LEVEL_PKT_PRIVACY, 
                                 RPC_C_IMP_LEVEL_IDENTIFY, 
                                 NULL, EOAC_NONE, 0);
        if(hRes!=S_OK)
        {
            SATracePrintf("OEMDLL::GetUniqueSuffix: CoInitializeSecurity failed, hRes= %x,getlasterr= %x", hRes,GetLastError());
            //break;
        }

        //
        // Create an instance of the WbemLocator interface.
        //
        CComPtr<IWbemLocator> pIWbemLocator;
        hRes=CoCreateInstance(CLSID_WbemLocator,
            NULL,
            CLSCTX_INPROC_SERVER,
            IID_IWbemLocator,
            (LPVOID *) &pIWbemLocator);
            
        if(FAILED(hRes))
        {
            SATracePrintf("OEMDLL::GetUniqueSuffix: CoCreatInstance(IWbemLocator) failed, hRes= %x,getlasterr= %x", hRes,GetLastError());
            break;
        }

        //
        // Using the locator, connect to CIMOM in the given namespace.
        //
        BSTR bstrNamespace = SysAllocString(WSZ_NAMESPACE);

        CComPtr<IWbemServices> pIWbemServices;
        hRes=pIWbemLocator->ConnectServer(bstrNamespace,
                                    NULL,   //using current account
                                    NULL,    //using current password
                                    0L,        // locale
                                    0L,        // securityFlags
                                    NULL,    // authority (domain for NTLM)
                                    NULL,    // context
                                    &pIWbemServices);
        SysFreeString(bstrNamespace);

        if(hRes!=WBEM_S_NO_ERROR)
        {
            SATracePrintf("OEMDLL::GetUniqueSuffix: ConnectServer failed, hRes= %x,getlasterr= %x", hRes,GetLastError());

            break;
        }
            
        //
        //Create an enumeration of the object(s)
        //
        BSTR bstrClassName;
        bstrClassName = SysAllocString(wszWMIClassName);
        CComPtr<IEnumWbemClassObject> pEnum;
        hRes = pIWbemServices->CreateInstanceEnum(bstrClassName, 
                                         WBEM_FLAG_SHALLOW, 
                                         NULL, 
                                         &pEnum);
        SysFreeString(bstrClassName);
    
        if (hRes!=WBEM_S_NO_ERROR)
        {
            SATracePrintf("OEMDLL::GetUniqueSuffix:CreateInstanceEnum failed, hRes= %x,getlasterr= %x", hRes,GetLastError());

            break;
        }


        //
        // Pull the object from the enumeration (there's only one)
        //
        ULONG uReturned = 1;
        CComPtr<IWbemClassObject> pWin32BIOS;
        hRes=pEnum -> Next( WBEM_INFINITE,   // timeout value - this one is blocking
                       1,               // return just one object
                       &pWin32BIOS,        // pointer to the object
                       &uReturned);     // number obtained: one or zero

        if (hRes!=WBEM_S_NO_ERROR)
        {
            SATracePrintf("OEMDLL::GetUniqueSuffix:pEnum->Next  failed, hRes= %x,getlasterr= %x", hRes,GetLastError());

            break;
        }
        
        VARIANT varSerialNumber;
        VariantInit(&varSerialNumber);
        //
        // Get the desired property from the object
        //
        hRes = pWin32BIOS->Get(wszWMIPropertyName, 0L, &varSerialNumber, NULL, NULL);

        if (hRes!=WBEM_S_NO_ERROR)
        {
            SATracePrintf("OEMDLL::GetUniqueSuffix:pWin32BIOS->Get failed, hRes= %x,getlasterr= %x", hRes,GetLastError());
            break;
        }
    
        //ValueToString(&varSerialNumber,&wszUniqueSuffix);

        if( VT_BSTR != V_VT(&varSerialNumber))
        {
            SATraceString("OEMDLL:WMI property is not CIM_STRING.Currently other types are not supported");
            break;
        }
        BSTR bstrSerialNumber=SysAllocString(V_BSTR(&varSerialNumber));
        wcscpy(wszUniqueSuffix,bstrSerialNumber);

        SysFreeString(bstrSerialNumber);
        VariantClear(&varSerialNumber);
            
         
    }while(false);

    CoUninitialize();
    return hRes;
}


BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
                     )
{
    SATraceString("OEMConfigdll.dll loaded");
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\saconfig\saconfig\saconfigcommon.h ===
#ifndef _SACONFIGCOMMON_H_
#define _SACONFIGCOMMON_H_

const WCHAR REGKEY_SACONFIG[] =L"SOFTWARE\\Microsoft\\ServerAppliance\\SAConfig";

const WCHAR REGSTR_VAL_OEMDLLNAME[]=L"OEMDllName";
const WCHAR REGSTR_VAL_OEMFUNCTIONNAME[]=L"OEMFunctionName";

const WCHAR REGSTR_VAL_HOSTNAMEPREFIX[] =L"HostnamePrefix";
const WCHAR REGSTR_VAL_DEFAULTHOSTNAME[] =L"DefaultHostname";

const WCHAR REGSTR_VAL_ADMINPASSPREFIX[] =L"AdminPasswordPrefix";
const WCHAR REGSTR_VAL_DEFAULTADMINPASS[] =L"DefaultAdminPassword";

const WCHAR REGSTR_VAL_NETWORKCONFIGDLL[]=L"NetworkConfigDll";

const WCHAR WSZ_USERNAME[]=L"Administrator";
const WCHAR WSZ_DRIVENAME[]=L"\\\\.\\a:";

const WCHAR WSZ_CONFIGFILENAME[]=L"a:\\SAConfig.inf";
const WCHAR INF_SECTION_SACONFIG[]=L"saconfig";
//const WCHAR INF_KEY_SAHOSTNAME[]=L"hostname";
//const WCHAR INF_KEY_SAIPNUM[]=L"ipnum";
//const WCHAR INF_KEY_SASUBNETMASK[]=L"subnetmask";
//const WCHAR INF_KEY_SAGW[]=L"defaultgateway";
//const WCHAR INF_KEY_SADNS[]=L"domainnameserver";
//const WCHAR INF_KEY_SATIMEZONE[]=L"timezone";
//const WCHAR INF_KEY_SAADMINPASSWD[]=L"adminpasswd";


#define NAMELENGTH 128

#define NUMINFKEY 6

enum g_InfKeyEnum
{
    SAHOSTNAME,
    IPNUM,
    SUBNETMASK,
    DEFAULTGATEWAY,
    DOMAINNAMESERVER,
    ADMINPASSWD,
    TIMEZONE
};

const WCHAR INF_KEYS[][NAMELENGTH]={
    {L"sahostname"}, 
    {L"ipnum"},
    {L"subnetmask"},
    {L"defaultgateway"},
    {L"domainnameserver"},
    {L"adminpasswd"},
    {L"timezone"}
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\selfsigncert\src\selfsigncert.cpp ===
// SelfSignCert.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SelfSignCertps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <wbemidl.h>
#include <iads.h>
#include <iadmw.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include "SelfSignCert.h"

#include "SelfSignCert_i.c"
#include "SelfSignCert1.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SelfSignCert, CSelfSignCert)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
//        _Module.Init(ObjectMap, hInstance, &LIBID_SELFSIGNCERTLib);
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\selfsigncert\src\selfsigncert1.h ===
// SelfSignCert1.h: Definition of the SelfSignCert class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_SELFSIGNCERT1_H__9DA527B5_BFCF_4039_AF4C_D4B18324838B__INCLUDED_)
#define AFX_SELFSIGNCERT1_H__9DA527B5_BFCF_4039_AF4C_D4B18324838B__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols
#include <wincrypt.h>


/////////////////////////////////////////////////////////////////////////////
// SelfSignCert

class ATL_NO_VTABLE CSelfSignCert : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IApplianceTask, &IID_IApplianceTask, &LIBID_SELFSIGNCERTLib>, 
    public CComCoClass<CSelfSignCert,&CLSID_SelfSignCert>
{
public:
    CSelfSignCert() {}
BEGIN_COM_MAP(CSelfSignCert)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IApplianceTask)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_SelfSignCert)

DECLARE_PROTECT_FINAL_CONSTRUCT()
// 
public:
    //
    // IApplianceTask
    //
    STDMETHOD(OnTaskExecute)(
                     /*[in]*/ IUnknown* pTaskContext
                            );

    STDMETHOD(OnTaskComplete)(
                      /*[in]*/ IUnknown* pTaskContext, 
                      /*[in]*/ LONG      lTaskResult
                             );    
private:

    HRESULT ParseTaskParameter(
                                IUnknown *pTaskContext
                              );

    HRESULT RaiseNewCertificateAlert();

    HRESULT SelfSignCertificate( 
                                 LPWSTR pstrApplianceName,
                                 LPWSTR pstrApplianceFullDnsName 
                               );

    BOOL    GetApplianceName( 
                              LPWSTR* pstrComputerName,
                              COMPUTER_NAME_FORMAT NameType
                            );

    BOOL    FindSSCInStor(     
                           LPWSTR          pstrApplianceName,
                           LPWSTR          pstrSubjectName,
                           HCERTSTORE      hStore,
                           CERT_NAME_BLOB  *pCertNameBlob,
                           PCCERT_CONTEXT  &pcCertCxt
                         );

    HRESULT SaveHashToMetabase( PBYTE pbHashSHA1  );

    HRESULT GetWebSiteID(
                         LPCWSTR wszWebSiteName,
                         BSTR* pbstrWebSiteID 
                         );

    HRESULT BindCertToSite(
                           LPCWSTR wszSiteName, 
                           PBYTE pbHashSHA1
                           );

    HRESULT SetSSLCertHashProperty( BSTR bstrMetaPath,
                                    PBYTE pbHashSHA1 );

    HRESULT    SetSSLStoreNameProperty( BSTR bstrADSIPath );

};

#endif // !defined(AFX_SELFSIGNCERT1_H__9DA527B5_BFCF_4039_AF4C_D4B18324838B__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\saconfig\saconfig\saconfigmain.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 1999-2000 Microsoft Corporation
//
//  Module Name:
//      saconfigmain.cpp
//
//  Description:
//      Main module implementation for initial appliance configuration
//
//  Author:
//      Alp Onalan  Created: Oct 6 2000
//
//////////////////////////////////////////////////////////////////////////



#include "SAConfig.h"
//#include "SAConfigCommon.h"

const int NUMSWITCH=4;

enum g_switches
{
    HELP,
    HOSTNAME,
    ADMINPASSWORD,
    RESTART
};


bool g_rgSwitch[NUMSWITCH]=
{
    FALSE,FALSE,FALSE,FALSE
};

void helpUsage()
{
    wprintf(L" Usage: saconfig {-hostname|-adminpass|-restart} \n");
    wprintf(L"         -hostname: set the hostname of the machine \n");
    wprintf(L"         -adminpass:set the admin password of the machine \n");
    wprintf(L"         -restart:restart the machine \n");
}

bool ParseCommandLine(int argc, char *argv[])
{
    bool hRes=true;
    int nArg=0;

    #if 0
    if (argc < 2) 
    {
        helpUsage();
        hRes=false;
        return hRes;  
    }
    #endif
    
    //parse arguments
    for(nArg=1;nArg < argc;nArg++)
    {
        if (!strcmp(argv[nArg], "-h") || !strcmp(argv[nArg], "-?")) 
        {
            g_rgSwitch[HELP]=TRUE;
            helpUsage();
            hRes=false; // i.e. there's nothing todo, print help, return.
            return hRes;
        }

        if (!strcmp(argv[nArg], "-hostname")) 
        {
            g_rgSwitch[HOSTNAME]=TRUE;
            continue;
        }    
        
        if (!strcmp(argv[nArg], "-adminpass")) 
        {
            g_rgSwitch[ADMINPASSWORD]=TRUE;
            continue;
        }    

        if (!strcmp(argv[nArg], "-restart")) 
        {
            g_rgSwitch[RESTART]=TRUE;
            continue;
        }    
        //
        //if it is not the first arg too, then it is an invalid switch
        //
        //TODO, adjust the flow path for floppy configuration
        #if 0
        if (0!=nArg)
        {
        //    cout << "\n Invalid switch";
            helpUsage();
            hRes=false;
            return hRes;
        }
        #endif
    }
    return hRes; // true 
}

HRESULT RebootMachine()
{
    HANDLE hToken; 
    TOKEN_PRIVILEGES tkp; 
 
    // Get a token for this process. 
 
    if (!OpenProcessToken(GetCurrentProcess(), 
            TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken)) 
    {
        SATracePrintf("RebootMachine:OpenProcessToken failed, getlasterr:%x",GetLastError());
        return E_FAIL;
    }

    // Get the LUID for the shutdown privilege. 
 
    LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, 
            &tkp.Privileges[0].Luid); 
 
    tkp.PrivilegeCount = 1;  // one privilege to set    
    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 
 
    // Get the shutdown privilege for this process. 
 
    AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, 
            (PTOKEN_PRIVILEGES)NULL, 0); 
 
    //ExitWindows(0,0);
    if(InitiateSystemShutdown(NULL,NULL,0,true,true))
        return S_OK;
    else
    {
        SATracePrintf("Unable to restart the system,getlasterr: %x", GetLastError());
        return E_FAIL;
    }
}

int __cdecl main(int argc, char *argv[])
{

    CSAConfig gAppliance;

    if(ParseCommandLine(argc,argv))
    {
        gAppliance.DoConfig(g_rgSwitch[HOSTNAME],g_rgSwitch[ADMINPASSWORD]);
    }
    if(g_rgSwitch[RESTART])
    {
        RebootMachine(); // need to check the return val??? 
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\selfsigncert\src\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__4EACF485_8D0F_413B_ADC9_0BA9C208BCC4__INCLUDED_)
#define AFX_STDAFX_H__4EACF485_8D0F_413B_ADC9_0BA9C208BCC4__INCLUDED_

#pragma once


#define _ATL_APARTMENT_THREADED
#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <satrace.h>
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4EACF485_8D0F_413B_ADC9_0BA9C208BCC4__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\setdatetime\datetimemsg\makefile.inc ===
DateTimeMsg.rc: msg00001.bin

DateTimeMsg.h msg00001.bin: DateTimeMsg.mc
    mc -v DateTimeMsg.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\setdatetime\source\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\selfsigncert\src\selfsigncert1.cpp ===
// SelfSignCert1.cpp : Implementation of CSelfSignCertApp and DLL registration.

#include "stdafx.h"
#include "SelfSignCert.h"
#include "SelfSignCert1.h"
#include <selfsigncertmsg.h>

#include <Aclapi.h>
#include <activeds.h>
#include <appliancetask.h>
#include <taskctx.h>
#include <appsrvcs.h>


#include <stdlib.h>
#include <stdio.h>

#include <wincrypt.h>

#include <lmaccess.h>
#include <lmapibuf.h>
#include <aclapi.h>
#include <lmerr.h>
#include <iadmw.h>
#include <iiscnfg.h>
#include <iads.h>
#include <wbemidl.h>
#include <wbemcli.h>
#include <wbemprov.h>
#include <string>



#define SHA1SIZE 20
#define PROP_SSL_CERT_HASH  5506

const WCHAR    ADSI_PATH[] =  L"IIS://LOCALHOST/W3SVC/";
const WCHAR    META_PATH[] =  L"/LM/W3SVC/";

//Names of the secure sites
LPCWSTR ADMIN_SITE_NAME = L"Administration";
LPCWSTR SHARES_SITE_NAME= L"Shares";

LPCWSTR WEBFRAMEWORK_KEY = L"SOFTWARE\\Microsoft\\ServerAppliance\\WebFramework";
LPCWSTR SITE_VALUE_SUFFIX = L"SiteID";

//
// Alert source information
//
const WCHAR    ALERT_LOG_NAME[] = L"selfsigncertmsg.dll";
const WCHAR    ALERT_SOURCE []  = L"selfsigncertmsg.dll";
                
//
// Various strings used in the program
//
const WCHAR SZ_METHOD_NAME[] = L"MethodName";
const WCHAR SZ_STORE_NAME_W[] = L"MY";
const WCHAR SZ_PROPERTY_STORE_NAME[] = L"SSLStoreName";
const WCHAR SZ_APPLIANCE_INITIALIZATION_TASK []=L"ApplianceInitializationTask";
const WCHAR SZ_APPLIANCE_EVERYBOOT_TASK []=L"EveryBootTask";

const WCHAR SZ_SUBJECT_NAME[] = L"cn=%s";

const WCHAR SZ_KEYCONTAINER_NAME[] = L"SELFSIGN_DEFAULT_CONTAINER";

const WORD  MAXAPPLIANCEDNSNAME = 127;


//////////////////////////////////////////////////////////////////////////////
//
// Function:  CSelfSignCert::OnTaskComplete
//
// Synopsis:  
//
// Arguments: pTaskContext - The TaskContext object contains the method name
//                                and parameters as name value pairs
//
// Returns:   HRESULT
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CSelfSignCert::OnTaskComplete(IUnknown *pTaskContext, 
                                LONG lTaskResult)
{
    SATracePrintf( "OnTaskComplete" );
    return S_OK;
}

///////////////////////////////////////////////////////////////////////////////
//
// Function: CSelfSignCert::OnTaskExecute
//
// Synopsis:  This function is the entry point for AppMgr.
//
// Arguments: pTaskContext - The TaskContext object contains the method name
//                                and parameters as name value pairs
//
// Returns:   HRESULT
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CSelfSignCert::OnTaskExecute(IUnknown *pTaskContext)
{
    HRESULT hr = E_FAIL;
    LPWSTR  pstrApplianceName = NULL;
    LPWSTR  pstrApplianceFullDnsName = NULL; 
    DWORD   dwReturn;

    SATraceString( "OnTaskExecute" );

    do
    {
        hr = ParseTaskParameter( pTaskContext ); 
        if( FAILED( hr ) )
        {
            SATraceString( "Failed ParseTaskParameter" );
            break;
        }

        if ( !GetApplianceName( &pstrApplianceName, ComputerNameDnsHostname ) )
        {
            SATraceString( "Failed ParseTaskParameter" );
            break;
        }

        if ( !GetApplianceName( &pstrApplianceFullDnsName, ComputerNameDnsFullyQualified ) )
        {
            SATraceString( "Failed ParseTaskParameter" );
            break;
        }

        hr = SelfSignCertificate( pstrApplianceName, pstrApplianceFullDnsName );
    }
    while( FALSE );

    if( pstrApplianceName )
    {
        free( pstrApplianceName );
    }

    if( pstrApplianceFullDnsName )
    {
        free( pstrApplianceFullDnsName );
    }

    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Function: CSelfSignCert::ParseTaskParameter
//
// Synopsis:  This function is used to parse the method name.
//
// Arguments: pTaskContext - The TaskContext object contains the method name
//                                and parameters as name value pairs
//
// Returns:   HRESULT
//
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CSelfSignCert::ParseTaskParameter(IUnknown *pTaskContext)
{
    CComVariant varValue;
     CComPtr<ITaskContext> pTaskParameter;
    CComVariant varLangID;

    SATraceString( "ParseTaskParameter" );

    HRESULT hrRet = E_INVALIDARG;

    try
    {
        do
        {
            if(NULL == pTaskContext)
            {
                SATraceString( "ParseTaskParameter 1" );
                break;
            }
            
            //
            // Get ITaskContext interface
            //
            hrRet = pTaskContext->QueryInterface(IID_ITaskContext,
                                              (void **)&pTaskParameter);
            if(FAILED(hrRet))
            {
                SATraceString( "ParseTaskParameter 2" );
                break;
            }

            CComBSTR bstrMethodName  (SZ_METHOD_NAME);
            if (NULL == bstrMethodName.m_str)
            {
                SATraceString("CSelfSignCert::ParseTaskParamter failed to allocate memory for bstrMethodName");
                hrRet = E_OUTOFMEMORY;
                break;
            }

            //
            // Get method name of the task.
            //
            hrRet = pTaskParameter->GetParameter(
                                            bstrMethodName,
                                            &varValue
                                            );
            if ( FAILED( hrRet ) )
            {
                SATraceString( "ParseTaskParameter 3" );
                break;
            }

            //
            // Check variant type.
            //
            if ( V_VT( &varValue ) != VT_BSTR )
            {
                SATraceString( "ParseTaskParameter 4" );
                break;
            }

            //if ( lstrcmp( V_BSTR(&varValue), SZ_APPLIANCE_EVERYBOOT_TASK ) == 0 )
            //{
            //    hrRet=S_OK;
            //}

            //
            // Check if it's the appliance initialization task.
            //
            if ( lstrcmp( V_BSTR(&varValue), SZ_APPLIANCE_INITIALIZATION_TASK ) == 0 )
            {
                hrRet=S_OK;
            }
        }
        while(false);
    }
    catch(...)
    {
        SATraceString( "ParseTaskParameter 8" );
        hrRet=E_FAIL;
    }

    return hrRet;
}

///////////////////////////////////////////////////////////////////////////////
//
// Function: CSelfSignCert::RaiseNewCertificateAlert
//
// Synopsis:  This function is called to raise certificate alert.
//
// Returns:   HRESULT
//
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CSelfSignCert::RaiseNewCertificateAlert()
{
    DWORD             dwAlertType = SA_ALERT_TYPE_MALFUNCTION;
    DWORD           dwAlertID = SA_SSC_ALERT_TITLE;
    HRESULT            hrRet = E_FAIL;
    CComVariant     varReplacementStrings;
    CComVariant     varRawData;
    LONG             lCookie;

    SATraceString( "RaiseNewCertificateAlert" );

    CComPtr<IApplianceServices>    pAppSrvcs;

    try
    {
        do
        {
            //
            // Get instance of appsrvcs 
            //
            hrRet = CoCreateInstance(CLSID_ApplianceServices,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IApplianceServices,
                                    (void**)&pAppSrvcs);
            if (FAILED(hrRet))
            {
                break;
            }

            //
            // Initialize() is called prior to using other component services.
            //Performscomponent initialization operations.
            //
            hrRet = pAppSrvcs->Initialize(); 
            if (FAILED(hrRet))
            {
                break;
            }

            CComBSTR bstrAlertLogName (ALERT_LOG_NAME);
            if (NULL == bstrAlertLogName.m_str)
            {
                hrRet = E_OUTOFMEMORY;
                break;
            }

            CComBSTR bstrAlertSource (ALERT_SOURCE);
            if (NULL == bstrAlertSource.m_str)
            {
                hrRet = E_OUTOFMEMORY;
                break;
            }


            //
            // Raise certificate alert.
            //
            hrRet = pAppSrvcs->RaiseAlertEx(
                                        dwAlertType, 
                                        dwAlertID,
                                        bstrAlertLogName, 
                                        bstrAlertSource, 
                                        SA_ALERT_DURATION_ETERNAL,
                                        &varReplacementStrings,    
                                        &varRawData,  
                                        SA_ALERT_FLAG_PERSISTENT,
                                        &lCookie
                                        );
        }
        while(false);
    }
    catch(...)
    {
        hrRet=E_FAIL;
    }

    return hrRet;
}

///////////////////////////////////////////////////////////////////////////////
//
// Function: CSelfSignCert::RaiseNewCertificateAlert
//
// Synopsis:  This function is called to get current appliance name.
//
// Arguments: [in][out] pstrComputerName - Appliance name as NetBios
//
// Returns:   BOOL
//
///////////////////////////////////////////////////////////////////////////////
BOOL
CSelfSignCert::GetApplianceName(
    LPWSTR* pstrComputerName,
    COMPUTER_NAME_FORMAT NameType
    )
{
    BOOL    bReturn = FALSE;
    DWORD   dwSize = 0;
    DWORD   dwCount = 1;

    do
    {
        if( *pstrComputerName != NULL )
        {
            ::free( *pstrComputerName );
        }
        
        dwSize = MAXAPPLIANCEDNSNAME * dwCount;

        *pstrComputerName = ( LPWSTR ) ::malloc( sizeof(WCHAR) * dwSize );
        if( *pstrComputerName == NULL )
        {
            SATraceString( 
                "CSelfSignCert::GetApplianceName malloc failed" 
                );
            break;
        }

        //
        // Get local computer name.
        //
        bReturn = GetComputerNameEx( 
                                NameType,
                                *pstrComputerName,
                                &dwSize                
                                );

        dwCount <<= 1;
    }
    while( !bReturn && 
           ERROR_MORE_DATA == ::GetLastError() &&
           dwCount < 8 
           );

    return bReturn;
}


///////////////////////////////////////////////////////////////////////////////
//
// Function: CSelfSignCert::SelfSignCertificate
//
// Synopsis:  This function is called to create self-sign certificate if it is
//            not exist and import it into system store.
//
// Arguments: [in] pstrComputerName - Appliance name as NetBios
//
// Returns:   HRESULT
//
///////////////////////////////////////////////////////////////////////////////
HRESULT 
CSelfSignCert::SelfSignCertificate( 
    LPWSTR pstrApplianceName, 
    LPWSTR pstrApplianceFullDnsName 
    )
{
    SATraceString("Entering CSelfSignCert::SelfSignCertificate");

    DWORD           cbData = 0;
    DWORD           cbEncoded=0;
    BYTE*           pbData = NULL;
    PBYTE           pbEncoded=NULL;

    HRESULT         hr = E_FAIL;
    HCRYPTKEY       hKey=NULL;
    HCERTSTORE      hStore=NULL;
    HCRYPTPROV      hProv=NULL;

    CERT_NAME_BLOB      CertNameBlob;
    CERT_EXTENSION      rgcertExt[2];
    CERT_EXTENSIONS     certExts;
    CERT_ENHKEY_USAGE   certEKU;
    CRYPT_KEY_PROV_INFO KeyProvInfo;
    PCCERT_CONTEXT      pcCertCxt = NULL;

    LPSTR           lpEKU = szOID_PKIX_KP_SERVER_AUTH;
    LPTSTR          lpContainerName = L"SELFSIGN_DEFAULT_CONTAINER";
    WCHAR           pstrSubjectName[MAXAPPLIANCEDNSNAME +4];
    CRYPT_ALGORITHM_IDENTIFIER  SigAlg;

    //
    // Subject name as cn=ApplianceName
    //    
    //
    INT iRetCount = ::_snwprintf (pstrSubjectName, MAXAPPLIANCEDNSNAME +3,SZ_SUBJECT_NAME, pstrApplianceFullDnsName);
    if (iRetCount < 0)
    {   
        SATraceString ("SelfSignCertificate method failed on swprintf");
        return (hr);
    }
    pstrSubjectName [MAXAPPLIANCEDNSNAME +3] = L'\0';

    do
    {
        //Fill in the size of memory required for pbData in cbData
        if ( !CertStrToName (  X509_ASN_ENCODING, 
                               pstrSubjectName, 
                               CERT_OID_NAME_STR, 
                               NULL, NULL, 
                               &cbData, NULL ) ) 
        {
            SATraceString( "CertStrToName failed" );
            break;
        }

        pbData = ( BYTE* ) LocalAlloc( LPTR, cbData );

        // Convert a NULL-terminated X500 string to an encoded certificate name
        // and store it in pbData
        if ( !CertStrToName ( X509_ASN_ENCODING, 
                              pstrSubjectName, 
                              CERT_OID_NAME_STR, 
                              NULL, pbData, 
                              &cbData, NULL ) ) 
        { 
            SATraceString( "CertStrToName failed 2" );
            break;
        }
        
        CertNameBlob.cbData = cbData;
        CertNameBlob.pbData = pbData;

        //
        // Open personal certificate store on local machine
        //
        hStore = ::CertOpenStore( CERT_STORE_PROV_SYSTEM, 
                                  0, NULL, 
                                  CERT_SYSTEM_STORE_LOCAL_MACHINE, 
                                  SZ_STORE_NAME_W );
        if (!hStore) 
        {
            SATraceString( "CertOpenStore failed" );
            break;
        }


       //
        // Find if there is a self-sign certificate in the store.
        //
        if( FindSSCInStor( pstrApplianceFullDnsName, pstrSubjectName, hStore, &CertNameBlob, pcCertCxt ) )
        {
            SATraceString( "SSC exists" );
        }
        else 
        {
            SATraceString( "Create a new self-sign certificate");

            certEKU.cUsageIdentifier = 1;
            certEKU.rgpszUsageIdentifier = &lpEKU;

            //
            // Encode certEKU 
            //
            if( !CryptEncodeObjectEx( X509_ASN_ENCODING, 
                                    szOID_ENHANCED_KEY_USAGE, 
                                    &certEKU, 
                                    CRYPT_ENCODE_ALLOC_FLAG, 
                                    NULL, 
                                    &pbEncoded, 
                                    &cbEncoded ) ) 
            {
                SATraceString( "CryptEncodeObjectEx failed" );
                break;
            }

            rgcertExt[0].pszObjId = szOID_ENHANCED_KEY_USAGE;
            rgcertExt[0].fCritical = FALSE;
            rgcertExt[0].Value.cbData= cbEncoded;
            rgcertExt[0].Value.pbData = pbEncoded;

            CERT_ALT_NAME_ENTRY rgcane[2];

            rgcane[0].dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
            rgcane[0].pwszDNSName = pstrApplianceFullDnsName;

            rgcane[1].dwAltNameChoice = CERT_ALT_NAME_DNS_NAME;
            rgcane[1].pwszDNSName = pstrApplianceName;

            CERT_ALT_NAME_INFO cani;

            cani.cAltEntry = 2;
            cani.rgAltEntry = rgcane;

            if( !CryptEncodeObjectEx( X509_ASN_ENCODING,
                                    szOID_SUBJECT_ALT_NAME2,
                                    &cani,
                                    CRYPT_ENCODE_ALLOC_FLAG,
                                    NULL,
                                    &pbEncoded,
                                    &cbEncoded ) )
            {
                SATraceString( "CryptEncodeObjectEx failed" );
                break;
            }

            rgcertExt[1].pszObjId = szOID_SUBJECT_ALT_NAME2;
            rgcertExt[1].fCritical = FALSE;
            rgcertExt[1].Value.cbData= cbEncoded;
            rgcertExt[1].Value.pbData = pbEncoded;

            certExts.cExtension = 2;
            certExts.rgExtension = rgcertExt;
        
            memset( &KeyProvInfo, 0, sizeof( CRYPT_KEY_PROV_INFO ));
            KeyProvInfo.pwszContainerName = lpContainerName; 
            KeyProvInfo.pwszProvName      = MS_ENHANCED_PROV;
            KeyProvInfo.dwProvType        = PROV_RSA_FULL; 
            KeyProvInfo.dwKeySpec         = AT_KEYEXCHANGE; //needed for SSL
            KeyProvInfo.dwFlags = CRYPT_MACHINE_KEYSET;

            if ( !CryptAcquireContext(&hProv, 
                                    lpContainerName, 
                                    MS_ENHANCED_PROV,    
                                    PROV_RSA_FULL, 
                                    CRYPT_MACHINE_KEYSET) ) 
            {
                if (!CryptAcquireContext(&hProv, 
                                        lpContainerName, 
                                        MS_ENHANCED_PROV, 
                                        PROV_RSA_FULL, 
                                        CRYPT_MACHINE_KEYSET | CRYPT_NEWKEYSET)) 
                {
                    SATraceString( "CryptAcquireContext failed" );
                    break;
                }
            }
            
            //
            // we have the keyset, now make sure we have the key gen'ed
            //
            if ( !CryptGetUserKey( hProv, AT_KEYEXCHANGE, &hKey) ) 
            {
                SATraceString( "Doesn't exist so gen it" );
                //
                // doesn't exist so gen it                        
                //
                if( !CryptGenKey( hProv, AT_KEYEXCHANGE, CRYPT_EXPORTABLE, &hKey) ) 
                {

                    SATraceString( "CryptGenKey failed" );
                    break;
                }
            }

            memset(&SigAlg, 0, sizeof(SigAlg));
            SigAlg.pszObjId = szOID_RSA_MD5RSA;


            //
            // Create the self-sign certificate now.
            //
            pcCertCxt = CertCreateSelfSignCertificate( 
                                                    hProv, 
                                                    &CertNameBlob, 
                                                    0, 
                                                    &KeyProvInfo, 
                                                    &SigAlg,
                                                    NULL,
                                                    NULL, 
                                                    &certExts
                                                    );
            if ( !pcCertCxt ) 
            { 

                SATraceString( "CertCreateSelfSignCertificate failed" );
                break;
            }

            //
            // Add it to personal store.
            //    
            if ( !CertAddCertificateContextToStore( hStore, pcCertCxt, CERT_STORE_ADD_ALWAYS, NULL ) ) 
            {
                SATraceString( "CertAddCertificateContextToStore" );
                break;
            }

            if ( !CertCloseStore( hStore, CERT_CLOSE_STORE_FORCE_FLAG ) ) 
            {
                SATraceString( "CertAddCertificateContextToStore" );
                break;
            }

            //
            // Open root store.
            //
            hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM, 
                                    0, 
                                    NULL, 
                                    CERT_SYSTEM_STORE_LOCAL_MACHINE, 
                                    TEXT("ROOT")
                                    );
            if (!hStore) 
            {
                SATraceString( "CertOpenStore ROOT" );
                break;
            }

            if (!CertAddCertificateContextToStore(hStore, pcCertCxt, CERT_STORE_ADD_ALWAYS, NULL)) 
            {
                SATraceString( "CertAddCertificateContextToStore ROOT" );
                break;
            }

            //
            // Now we have a self-sign certificate, raise alert to notify
            // user to install it.
            //
            hr = RaiseNewCertificateAlert();
        }

        SATraceString("Assign the certificate to the Administration site");

        //Variables used to assign the certificate to the metabase
        BYTE pbHashSHA1[SHA1SIZE];
        ULONG cbHashSHA1=SHA1SIZE;
        if (!CertGetCertificateContextProperty(pcCertCxt, 
                                               CERT_HASH_PROP_ID, 
                                               pbHashSHA1, 
                                               &cbHashSHA1))
        {
            SATraceString("CertGetCertificateContextProperty failed");
            break;
        }


        if( FAILED( SaveHashToMetabase( pbHashSHA1 ) ) )
        {
            SATraceString("SaveHashToMetabase failed");
            break;
        }
  
        hr = S_OK;

    }
    while( FALSE );
    
    if ( pbEncoded ) 
        LocalFree(pbEncoded);


    //
    // free the certificate context ...
    //
    if (pcCertCxt)
    {
        CertFreeCertificateContext( pcCertCxt );
    }

    //
    // ... and close the store
    //
    if ( hStore ) 
    {
        CertCloseStore( hStore, CERT_CLOSE_STORE_FORCE_FLAG );
    }

    SATraceString("Exiting CSelfSignCert::SelfSignCertificate");
    return hr;
}

///////////////////////////////////////////////////////////////////////////////
//
// Function: CSelfSignCert::FindSSCInStor
//
// Synopsis:  This function is called to check if one more self-sign certificate
//            exist in personal store.
//
// Arguments: [in] pstrComputerName - Appliance name as NetBios
//            [in] pstrSubjectName  - SubjectName of certificate
//            [in] hStore           - Handle of personal store 
//            [in] pCertNameBlob    - Pointer of CERT_NAME_BLOB
//            [out] pcCertCxt       - If certificate is found, will hold its context
//
// Returns:   BOOL
//
///////////////////////////////////////////////////////////////////////////////
BOOL
CSelfSignCert::FindSSCInStor( 
    LPWSTR          pstrApplianceName,
    LPWSTR          pstrSubjectName,
    HCERTSTORE      hStore,
    CERT_NAME_BLOB  *pCertNameBlob,
    PCCERT_CONTEXT  &pcCertCxt 
    )
{
    BOOL    bFind = FALSE;
    DWORD   dwStrReturn;
    DWORD   dwStrLeng;
    LPTSTR  pstrIssuerName;
    PCCERT_CONTEXT  pcPreCxt = NULL;
    pcCertCxt = NULL;
    
    //
    // Enum all certificate with subject name.
    //
    while( pcCertCxt = ::CertFindCertificateInStore(
                                            hStore,
                                            X509_ASN_ENCODING ,
                                            0,
                                            CERT_FIND_SUBJECT_NAME,
                                            pCertNameBlob,
                                            pcPreCxt 
                                            ) )
    {
        dwStrReturn = ::CertNameToStr( X509_ASN_ENCODING,
                                     &(pcCertCxt->pCertInfo->Issuer),
                                     CERT_SIMPLE_NAME_STR,
                                     NULL,
                                     0 );
        pstrIssuerName = (LPTSTR) malloc( (dwStrReturn + 1) * sizeof(WCHAR) );
        if( pstrIssuerName == NULL )
        {
           SATraceString( "FindSSCInStor out of memory" );
           return FALSE;
        }

        //
        // Convert issuer name to string as simple name
        //
        ::CertNameToStr( X509_ASN_ENCODING,
                         &(pcCertCxt->pCertInfo->Issuer),
                         CERT_SIMPLE_NAME_STR,
                         pstrIssuerName,
                         dwStrReturn );
                         
        //
        // If the issuer and subject is equal, it's a self-sign certificate. 
        //                 
        if( 0 == lstrcmp( pstrApplianceName, pstrIssuerName ) )
        {
            bFind = TRUE;
            //
            // we don't free the cert context here, as we need it 
            // in the caller - MKarki (04/30/2002)
            //
            // ::CertFreeCertificateContext( pcCertCxt );
            free( pstrIssuerName );
            break;
        }

        free( pstrIssuerName );
        pcPreCxt = pcCertCxt;
    }

    return bFind;
}



///////////////////////////////////////////////////////////////////////////////
//
// Function: CSelfSignCert::BindCertToSite
//
// Synopsis:  This function is used to save the Certificate properties to metabase
//            for the given site
//
// Arguments: IN wszSiteName - Site to bind the certificate to
//                    ie. Administration or Shares
//            IN pbHashSHA1 - Certificate Hash
//
// Returns:   HRESULT
//
///////////////////////////////////////////////////////////////////////////////

HRESULT CSelfSignCert::BindCertToSite(LPCWSTR wszSiteName, PBYTE pbHashSHA1)
{
    HRESULT hr = S_OK;
    BSTR bstrWebSiteID = NULL;
    SATracePrintf("BindCertToSite: Bind certificate to %ws site", wszSiteName);

    do 
    {
        //Get the web site ID
        hr = GetWebSiteID( wszSiteName, &bstrWebSiteID );
        if ( FAILED( hr ) )
        {
            SATraceString("BindCertToSite: Could not find site. ");
            break;
        }
        
        CComBSTR bstrADSIPath;
        bstrADSIPath += CComBSTR(ADSI_PATH);
        bstrADSIPath += CComBSTR( bstrWebSiteID ) ;
        SATracePrintf("ADSIPath = %ws", bstrADSIPath);

        CComBSTR bstrMetaPath;
        bstrMetaPath += CComBSTR(META_PATH);
        bstrMetaPath += CComBSTR( bstrWebSiteID ) ;
        SATracePrintf("MetaPath = %ws", bstrMetaPath);

        //
        // SSLCertHash property of IISWebServer
        //

        hr = SetSSLCertHashProperty( bstrMetaPath, pbHashSHA1 );
        if ( FAILED( hr ) )
        {
            SATraceString("SetSSLCertHashProperty failed");
            break;
        }

        // SSLStoreName property of IISWebServer
        hr = SetSSLStoreNameProperty( bstrADSIPath );
        if ( FAILED( hr ) )
        {
            SATraceString("SetSSLStoreNameProperty failed");
            break;
        }
        SATraceString("Successfully assigned the certificate to the site");

    } while (false);

    if ( bstrWebSiteID )
        SysFreeString( bstrWebSiteID );

    return hr;
}
///////////////////////////////////////////////////////////////////////////////
//
// Function: CSelfSignCert::SaveHashToMetabase
//
// Synopsis:  This function is used to save the Certificate properties to metabase
//            for each of the secure sites used by the SAK
//
// Arguments: IN pbHashSHA1 - Certificate Hash
//
// Returns:   HRESULT
//
///////////////////////////////////////////////////////////////////////////////

HRESULT CSelfSignCert::SaveHashToMetabase( PBYTE pbHashSHA1  )
{
    SATraceString("Entering CSelfSignCert::SaveHashToMetabase");

    HRESULT hr = S_OK;

    try
    {
        //
        // Bind the certificate to the Admin site
        //
        hr = BindCertToSite(ADMIN_SITE_NAME, pbHashSHA1);
        if ( FAILED( hr ) )
        {
            SATraceString("Failed to bind the Administration site certificate");
        }

        //
        // Bind the certificate to the Shares site
        //
        hr = BindCertToSite(SHARES_SITE_NAME, pbHashSHA1);
        if ( FAILED( hr ) )
        {
            SATraceString("Failed to bind the Shares site certificate");
        }

    }
    catch(...)
    {
    }

    SATraceString("Exiting CSelfSignCert::SaveHashToMetabase");
    return hr; 
}

///////////////////////////////////////////////////////////////////////////////
//
// Function: CSelfSignCert::GetWebSiteID
//
// Synopsis:  This function is used to retrieve the web site ID for the given 
//              web site.  It looks in the registry under the key
//              HKLM\Software\Microsoft\ServerAppliance\WebFramework\
//              and the value <SiteName>SiteID (ie. AdministrationSiteID)
//
// Arguments: IN  wszWebSiteName - Name of the web site to find. (Administration or Shares)
//            OUT pbstrWebSiteID - returns web site ID
//
// Returns:   HRESULT
//
///////////////////////////////////////////////////////////////////////////////

HRESULT  CSelfSignCert::GetWebSiteID(LPCWSTR wszWebSiteName, BSTR* pbstrWebSiteID )
{
    SATracePrintf("Entering CSelfSignCert::GetWebSiteID for %ws", wszWebSiteName);

    *pbstrWebSiteID = NULL;
    HRESULT hr = S_OK;
    HKEY hOpenKey = NULL;
    //Use the std namespace from <string> for using wstring
    using namespace std;
    wstring wsWebSiteValue(wszWebSiteName);
    wsWebSiteValue += SITE_VALUE_SUFFIX;

    do
    {
        //
        // Open the key
        //
        if (ERROR_SUCCESS != RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                                           WEBFRAMEWORK_KEY, 
                                           0, KEY_READ, &hOpenKey))
        {
            SATraceString("Could not find the WebFramework registry key");
            hr = E_FAIL;
            break;
        }

        //
        // Check the type of the value
        //
        DWORD dwType;
        DWORD dwDataSize = 0;
        if (ERROR_SUCCESS != RegQueryValueExW(hOpenKey, // handle to key
                                                wsWebSiteValue.data(),  // value name
                                                NULL,       // reserved
                                                &dwType,    // Type of registry entry (ie. DWORD or SZ)
                                                NULL,       // data buffer
                                                &dwDataSize))//size of data buffer
        {
            SATracePrintf("Could not find the registry value: %ws", wsWebSiteValue.data());
            hr = E_FAIL;
            break;
        }

        // Check to make sure that the registry entry is type REG_DWORD,
        // then read it into the return value
        if (REG_DWORD != dwType)
        {
            SATracePrintf("Registry value not of type REG_DWORD");
            hr = E_FAIL;
            break;
        }

        DWORD dwSiteID;
        //Look up the value and insert it into the return string
        if (ERROR_SUCCESS != RegQueryValueExW(hOpenKey, 
                                                wsWebSiteValue.data(), 
                                                NULL, 
                                                &dwType,
                                                (LPBYTE)&dwSiteID, 
                                                &dwDataSize))
        {
            SATracePrintf("Failed to retrieve data in %ws", wsWebSiteValue.data());
            hr = E_FAIL;
            break;
        }

        //Convert the ID to a string
        WCHAR wszSiteID[33];//Longest possible string in conversion is 33 characters
        _ltow(dwSiteID, wszSiteID, 10);
        *pbstrWebSiteID = SysAllocString( wszSiteID );
        
    } while (false);

    if (hOpenKey != NULL)
    {
        RegCloseKey(hOpenKey);
    }
    SATraceString("Exiting CSelfSignCert::GetWebSiteID");
    return hr;
}
///////////////////////////////////////////////////////////////////////////////
//
// Function: CSelfSignCert::SetSSLCertHashProperty
//
// Synopsis:  This function is used to set the SSLCertHash Property.
//
// Arguments: bstrMetaPath - MetaPath used to set the value
//            pbHashSHA1   - Certificate Hash
//
// Returns:   HRESULT
//
///////////////////////////////////////////////////////////////////////////////

HRESULT CSelfSignCert::SetSSLCertHashProperty( BSTR bstrMetaPath,  PBYTE pbHashSHA1 )
{

    SATraceString("Entering CSelfSignCert::SetSSLCertHashProperty");

    METADATA_HANDLE MetaHandle = NULL; 
    CComPtr <IMSAdminBase> pIMeta; 

    METADATA_RECORD RecordCertHash;
    ZeroMemory ((PVOID) &RecordCertHash, sizeof (METADATA_RECORD));
    
    HRESULT hr = S_OK;

    hr = CoCreateInstance( CLSID_MSAdminBase,
                                        NULL,
                                        CLSCTX_ALL, 
                                        IID_IMSAdminBase,
                                        (void **) &pIMeta); 
 
    if ( FAILED( hr ) ) 
    {
        SATraceString("SetSSLCertHashProperty - CoCreateInstance failed");
        return E_FAIL; 
    }
 
    // Get a handle to the Web service. 
    // MetaPath is of the form "/LM/W3SVC/1"
    hr = pIMeta->OpenKey( METADATA_MASTER_ROOT_HANDLE, bstrMetaPath , METADATA_PERMISSION_WRITE, 20, &MetaHandle); 
    if (FAILED(hr))
    {
        SATracePrintf("SetSSLCertHashProperty - Could not open key. %ws", bstrMetaPath);
    }

    if (SUCCEEDED( hr ))
    { 
        SATracePrintf("SetSSLCertHashProperty - OpenKey succeeded");

        // certhash value
          RecordCertHash.dwMDAttributes=0;
        RecordCertHash.dwMDIdentifier=PROP_SSL_CERT_HASH;
        RecordCertHash.dwMDUserType = 1; 
        RecordCertHash.dwMDDataType = BINARY_METADATA; 
        RecordCertHash.dwMDDataLen = SHA1SIZE; 
        RecordCertHash.pbMDData = NULL;
        RecordCertHash.pbMDData = (PBYTE) new BYTE[RecordCertHash.dwMDDataLen];
        if ( !RecordCertHash.pbMDData )
            goto SAError;
        memcpy( RecordCertHash.pbMDData, pbHashSHA1, RecordCertHash.dwMDDataLen );

        // Setting the SSLCertHash property of IISWebServer object
        hr = pIMeta->SetData( MetaHandle,
                                 _TEXT(""),
                                &RecordCertHash );

        if ( FAILED( hr ) )
            goto SAError;

        // Release the handle. 
        if ( MetaHandle != NULL )
        {
            pIMeta->CloseKey( MetaHandle ); 
            MetaHandle = NULL;
        }
        
        // Save Data
        hr = pIMeta->SaveData();
        if ( FAILED( hr) )
            goto SAError;
    }     

SAError:

    // Release the handle. 
    if ( MetaHandle != NULL )
    {
        pIMeta->CloseKey( MetaHandle ); 
    }


    if ( RecordCertHash.pbMDData )
    {
        delete [] RecordCertHash.pbMDData;
    }

    SATraceString("Exiting CSelfSignCert::SetSSLCertHashProperty");
    return hr;


}


///////////////////////////////////////////////////////////////////////////////
//
// Function: CSelfSignCert::SetSSLStoreNameProperty
//
// Synopsis:  This function is used to set the SSLStoreName property
//
// Arguments: bstrADSIPath - ADSI path used to set the property
//
// Returns:   HRESULT
//
///////////////////////////////////////////////////////////////////////////////

HRESULT    CSelfSignCert::SetSSLStoreNameProperty( BSTR bstrADSIPath )
{
    SATraceString("Entering CSelfSignCert::SetSSLStoreNameProperty");

    HRESULT hr = S_OK;
    IADs *pADs=NULL;

    // AdsPath is of the form "IIS://LOCALHOST/W3SVC/1"

    hr = ADsGetObject( bstrADSIPath, IID_IADs, (void**) &pADs );

    if ( SUCCEEDED(hr) )
    {
        SATraceString("CSelfSignCert::SetSSLStoreNameProperty - ADsGetObject successful");
        VARIANT var;
        VariantInit(&var);


        CComBSTR bstrPropertyStoreName (SZ_PROPERTY_STORE_NAME);
        if (NULL == bstrPropertyStoreName.m_str)
        {
            SATraceString("CSelfSignCert::SetSSLStoreNameProperty failed to allocate memory for bstrPropertyStoreName");
            hr = E_OUTOFMEMORY;
        }
        else
        {
            // Setting the SSLStoreName property of IISWebServer object
            V_BSTR(&var) = SysAllocString( SZ_STORE_NAME_W );
            V_VT(&var) = VT_BSTR;
            hr = pADs->Put(bstrPropertyStoreName, var );
            if ( SUCCEEDED(hr) )
                hr = pADs->SetInfo();
            pADs->Release();
        }
    }
    SATraceString("Exiting CSelfSignCert::SetSSLStoreNameProperty");
    return hr;
 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\setdatetime\source\datetime.h ===
// DateTime.h : Declaration of the CDateTime

#ifndef __DATETIME_H_
#define __DATETIME_H_

#include "resource.h"       // main symbols


//
// Tasks that are supports by this COM Server
//
typedef enum 
{
    NONE_FOUND,
    SET_DATE_TIME,
    SET_TIME_ZONE,
    RAISE_SETDATETIME_ALERT
} SET_DATE_TIME_TASK_TYPE;


#define TZNAME_SIZE            128
#define TZDISPLAYZ            128

//
//  Registry info goes in this structure.
//
typedef struct tagTZINFO
{
    struct tagTZINFO *next;
    TCHAR            szDisplayName[TZDISPLAYZ];
    TCHAR            szStandardName[TZNAME_SIZE];
    TCHAR            szDaylightName[TZNAME_SIZE];
    LONG             Bias;
    LONG             StandardBias;
    LONG             DaylightBias;
    SYSTEMTIME       StandardDate;
    SYSTEMTIME       DaylightDate;

} TZINFO, *PTZINFO;



/////////////////////////////////////////////////////////////////////////////
// CDateTime
class ATL_NO_VTABLE CDateTime : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CDateTime, &CLSID_DateTime>,
    public IDispatchImpl<IApplianceTask, &IID_IApplianceTask, &LIBID_SETDATETIMELib>
{
public:
    CDateTime()
    {
        ZeroMemory(&m_OldDateTime, sizeof(SYSTEMTIME));
        ZeroMemory(&m_OldTimeZoneInformation, sizeof(TIME_ZONE_INFORMATION));
    }


DECLARE_REGISTRY_RESOURCEID(IDR_DATETIME)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDateTime)
    COM_INTERFACE_ENTRY(IApplianceTask)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()


    //
    // IApplianceTask
    //

    STDMETHOD(OnTaskExecute)(
                     /*[in]*/ IUnknown* pTaskContext
                            );

    STDMETHOD(OnTaskComplete)(
                      /*[in]*/ IUnknown* pTaskContext, 
                      /*[in]*/ LONG      lTaskResult
                             );    

private:
    
    SYSTEMTIME                m_OldDateTime;
    TIME_ZONE_INFORMATION    m_OldTimeZoneInformation;
    BOOL                    m_OldEnableDayLightSaving;

    
    
    SET_DATE_TIME_TASK_TYPE     GetMethodName(IN ITaskContext *pTaskParameter);

    //
    // Functions to raise the Set Date/Time alert
    //
    STDMETHODIMP     RaiseSetDateTimeAlert(void);
    BOOL             ShouldRaiseDateTimeAlert(void);
    BOOL             DoNotRaiseDateTimeAlert(void);
    BOOL             ClearDateTimeAlert(void);

    //
    // Functions for Setting Date/Time
    //
    STDMETHODIMP GetSetDateTimeParameters(IN ITaskContext  *pTaskContext, 
                                            OUT SYSTEMTIME    *pLocalTime);

    STDMETHODIMP SetDateTime(IN ITaskContext  *pTaskContext);

    STDMETHODIMP RollbackSetDateTime(IN ITaskContext  *pTaskContext);
    
    
    
    //
    // Functions for Setting Time Zone information
    //
    STDMETHODIMP GetSetTimeZoneParameters(IN ITaskContext *pTaskContext, 
                                            OUT LPTSTR   *lpStandardTimeZoneName,
                                            OUT BOOL     *pbEnableDayLightSavings);

    STDMETHODIMP SetTimeZone(IN ITaskContext *pTaskContext);

    STDMETHODIMP RollbackSetTimeZone(IN ITaskContext *pTaskContext);

    
    //
    // Helper function for get/set Time Zone information
    //
    BOOL ReadZoneData(PTZINFO zone, HKEY key, LPCTSTR keyname);

    int ReadTimezones(PTZINFO *list);

    void AddZoneToList(PTZINFO *list, PTZINFO zone);

    void FreeTimezoneList(PTZINFO *list);

    void SetTheTimezone(BOOL bAutoMagicTimeChange, PTZINFO ptzi);

    void SetAllowLocalTimeChange(BOOL fAllow);

    BOOL GetAllowLocalTimeChange(void);
    
};

#endif //__DATETIME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\setdatetime\source\datetime.cpp ===
// DateTime.cpp : Implementation of CDateTime
#include "stdafx.h"
#include <regstr.h>
#include <comdef.h>
#include <comutil.h>
#include "SetDateTime.h"
#include "debug.h"

#include "appliancetask.h"
#include "taskctx.h"
#include "DateTime.h"


#include "appsrvcs.h"
#include "appmgrobjs.h"
#include "..\datetimemsg\datetimemsg.h"

//
//  Registry location for Time Zone information.
//
TCHAR c_szTimeZones[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones");

//
//  Time Zone data value keys.
//
TCHAR c_szTZDisplayName[]  = TEXT("Display");
TCHAR c_szTZStandardName[] = TEXT("Std");
TCHAR c_szTZDaylightName[] = TEXT("Dlt");
TCHAR c_szTZI[]            = TEXT("TZI");



#define PARAM_DATE_DAY                    TEXT("Day")
#define PARAM_DATE_MONTH                TEXT("Month")
#define PARAM_DATE_YEAR                    TEXT("Year")
#define PARAM_TIME_HOUR                    TEXT("Hour")
#define PARAM_TIME_MINUTE                TEXT("Minute")
#define    PARAM_TIMEZONE_STANDARDTIME        TEXT("StandardName")
#define    PARAM_DAYLIGHT_ENABLE            TEXT("EnableDayLight")    

#define ALERT_LOG_NAME                     TEXT("MSSAKitComm")
#define ALERT_SOURCE                     TEXT("")
#define    REGKEY_SA_DATETIME                TEXT("Software\\Microsoft\\ServerAppliance\\DateTime")
#define    REGSTR_VAL_DATETIME_RAISEALERT    TEXT("RaiseAlert")


/////////////////////////////////////////////////////////////////////////////
// CDateTime

STDMETHODIMP CDateTime::OnTaskExecute(IUnknown *pTaskContext)
{
    HRESULT      hr;
    ITaskContext *pTaskParameters = NULL;
    SET_DATE_TIME_TASK_TYPE sdtChoice;

    ASSERT(pTaskContext);  

    TRACE(("CDateTime::OnTaskExecute"));

    hr = pTaskContext->QueryInterface(IID_ITaskContext,
                                      (void **)&pTaskParameters);

	if (S_OK != hr)
    {
        return hr;
    }

    //
    // Check which Task is being executed and call that method
    //
    sdtChoice = GetMethodName(pTaskParameters);
    switch (sdtChoice)
    {
        case SET_DATE_TIME:
            hr = SetDateTime(pTaskParameters);
            TRACE1(("SetDateTime returned %X"), hr);
            break;

        case SET_TIME_ZONE:
            hr = SetTimeZone(pTaskParameters);
            TRACE1(("SetTimeZone returned %X"), hr);
            break;

        case RAISE_SETDATETIME_ALERT:
            //
            // Alert will be raised on OnTaskComplete
            //
            hr = S_OK;
            TRACE(("RaiseSetDateTimeAlert method called"));
            break;
        
        default:
             TRACE(("GetMethodName() failed to get method name in OnTaskExecute"));
             hr = E_INVALIDARG;
             break;
    }

    
    pTaskParameters->Release();
    TRACE1("CDateTime::OnTaskExecute returning %X", hr);
    return hr;
}



STDMETHODIMP CDateTime::OnTaskComplete(IUnknown *pTaskContext, LONG lTaskResult)
{

    HRESULT      hr = E_FAIL;
    ITaskContext *pTaskParameters = NULL;
    SET_DATE_TIME_TASK_TYPE sdtChoice;

    ASSERT(pTaskContext);  

    TRACE(("CDateTime::OnTaskComplete"));

    
    hr = pTaskContext->QueryInterface(IID_ITaskContext,
                                      (void **)&pTaskParameters);

	if (S_OK != hr)
    {
        return hr;
    }

    //
    // Check which Task is being executed and call that method
    //
    sdtChoice = GetMethodName(pTaskParameters);
    switch (sdtChoice)
    {
        case SET_DATE_TIME:
            if (lTaskResult == SA_TASK_RESULT_COMMIT)
            {
                  //
                  // Clear any existing DateTime alert and
                  // do not raise the datetime alert on subsequent boots
                  //
                 ClearDateTimeAlert();
                DoNotRaiseDateTimeAlert();
                 TRACE("No rollback in OnTaskComplete");
                hr = S_OK;
            }
            else
            {
                 hr = RollbackSetDateTime(pTaskParameters);
                TRACE1(("RollbackSetDateTime returned %X"), hr);
            }
            break;
            

        case SET_TIME_ZONE:
            if (lTaskResult == SA_TASK_RESULT_COMMIT)
            {
                  //
                  // Clear any existing DateTime alert and
                  // do not raise the datetime alert on subsequent boots
                  //
                 ClearDateTimeAlert();
                DoNotRaiseDateTimeAlert();
                  TRACE("No rollback in OnTaskComplete");
                hr = S_OK;
            }
              else
            {
                  hr = RollbackSetTimeZone(pTaskParameters);
                TRACE1(("RollbackSetTimeZone returned %X"), hr);
            }
            break;
            

          case RAISE_SETDATETIME_ALERT:
            if (lTaskResult == SA_TASK_RESULT_COMMIT)
            {
                if (TRUE == ShouldRaiseDateTimeAlert())
                {
                    hr = RaiseSetDateTimeAlert();
                    if (FAILED(hr))
                    {
                        TRACE1(("RaiseSetDateTimeAlert returned %X"), hr);
                    }
                }
                else
                {
                    TRACE("No need to raise the datetime alert");
                }
            }
              else
            {
                   //
                // Do nothing on Commit failure
                //
                hr = S_OK;
            }
            break;


       default:
             TRACE(("GetMethodName() failed to get method name in OnTaskComplete"));
             hr = E_INVALIDARG;
             break;
    }

    
    pTaskParameters->Release();
    TRACE1("CDateTime::OnTaskComplete returning %X", hr);
    return hr;
}



//
// Cut-n-paste from User Management code
//
SET_DATE_TIME_TASK_TYPE CDateTime::GetMethodName(IN ITaskContext *pTaskParameter)
{
    BSTR bstrParamName = SysAllocString(TEXT("MethodName"));
    HRESULT hr;
    VARIANT varValue;
    SET_DATE_TIME_TASK_TYPE sdtChoice = NONE_FOUND;


    ASSERT(pTaskParameter);
    
    
    hr = pTaskParameter->GetParameter(bstrParamName,
                                      &varValue);

    if (FAILED(hr))
    {
        TRACE1(("GetParameter failed in CDateTime::GetMethodName %X"),
                        hr);
    }

    if (V_VT(&varValue) != VT_BSTR)
    {
        TRACE1(("Non-strint(%X) parameter received in GetParameter in CSAUserTasks::GetMethodName"), V_VT(&varValue));
        hr = E_INVALIDARG;
        goto End;
    }

    if (lstrcmp(V_BSTR(&varValue), SET_DATE_TIME_TASK) == 0)
    {
        sdtChoice = SET_DATE_TIME;
        goto End;
    }

    if (lstrcmp(V_BSTR(&varValue), SET_TIME_ZONE_TASK) == 0)
    {
        sdtChoice = SET_TIME_ZONE;
        goto End;
    }

    if (lstrcmp(V_BSTR(&varValue), APPLIANCE_INITIALIZATION_TASK) == 0)
    {
        sdtChoice = RAISE_SETDATETIME_ALERT;
        goto End;
    }


End:
    VariantClear(&varValue);
    SysFreeString(bstrParamName);
    
    if (FAILED(hr))
    {
        sdtChoice = NONE_FOUND;
    }

    return sdtChoice;
}






STDMETHODIMP CDateTime::GetSetDateTimeParameters(IN ITaskContext  *pTaskContext, 
                                                    OUT SYSTEMTIME    *pLocalTime)
{
    BSTR bstrParamDateDay = SysAllocString(PARAM_DATE_DAY);
    BSTR bstrParamDateMonth = SysAllocString(PARAM_DATE_MONTH);
    BSTR bstrParamDateYear = SysAllocString(PARAM_DATE_YEAR);
    BSTR bstrParamTimeHour = SysAllocString(PARAM_TIME_HOUR);
    BSTR bstrParamTimeMinute = SysAllocString(PARAM_TIME_MINUTE);
    HRESULT hr;
    VARIANT varValue;

    
    ASSERT(pTaskContext);  

    
    //
    // Clear the LocalTime Structure
    //
    ZeroMemory(pLocalTime, sizeof(SYSTEMTIME));

    
    //
    // Retrieve Day from TaskContext
    //
    VariantClear(&varValue);
    hr = pTaskContext->GetParameter(bstrParamDateDay,
                                    &varValue);
    TRACE2(("GetParameter %ws returned  in CDateTime::GetSetDateTimeParameters\
                %X"), PARAM_DATE_DAY, hr);

    if (V_VT(&varValue) != VT_BSTR)
    {
        TRACE2(("Non-string(%X) parameter received for %ws in GetParameter \
                    in CDateTime:GetSetDateTime"), \
                    V_VT(&varValue), PARAM_DATE_DAY);
        hr = E_INVALIDARG;
        goto End;
    }
    pLocalTime->wDay = (WORD)_ttoi(V_BSTR(&varValue));

    
    //
    // Retrieve Month from TaskContext
    //
    VariantClear(&varValue);
    hr = pTaskContext->GetParameter(bstrParamDateMonth,
                                    &varValue);
    TRACE2(("GetParameter %ws returned  in CDateTime::GetSetDateTimeParameters\
                %X"), PARAM_DATE_MONTH, hr);

    if (V_VT(&varValue) != VT_BSTR)
    {
        TRACE2(("Non-string(%X) parameter received for %ws in GetParameter \
                    in CDateTime:GetSetDateTime"), \
                    V_VT(&varValue), PARAM_DATE_MONTH);
        hr = E_INVALIDARG;
        goto End;
    }
    pLocalTime->wMonth = (WORD) _ttoi(V_BSTR(&varValue));;
    
    
    //
    // Retrieve Year from TaskContext
    //
    VariantClear(&varValue);
    hr = pTaskContext->GetParameter(bstrParamDateYear,
                                    &varValue);
    TRACE2(("GetParameter %ws returned  in CDateTime::GetSetDateTimeParameters\
                %X"), PARAM_DATE_YEAR, hr);

    if (V_VT(&varValue) != VT_BSTR)
    {
        TRACE2(("Non-string(%X) parameter received for %ws in GetParameter \
                    in CDateTime:GetSetDateTime"), \
                    V_VT(&varValue), PARAM_DATE_YEAR);
        hr = E_INVALIDARG;
        goto End;
    }
    pLocalTime->wYear = (WORD) _ttoi(V_BSTR(&varValue));

    
    
    //
    // Retrieve Hour from TaskContext
    //
    VariantClear(&varValue);
    hr = pTaskContext->GetParameter(bstrParamTimeHour,
                                    &varValue);
    TRACE2(("GetParameter %ws returned  in CDateTime::GetSetDateTimeParameters\
                %X"), PARAM_TIME_HOUR, hr);

    if (V_VT(&varValue) != VT_BSTR)
    {
        TRACE2(("Non-string(%X) parameter received for %ws in GetParameter \
                    in CDateTime:GetSetDateTime"), \
                    V_VT(&varValue), PARAM_TIME_HOUR);
        hr = E_INVALIDARG;
        goto End;
    }
    pLocalTime->wHour = (WORD) _ttoi(V_BSTR(&varValue));

    
    //
    // Retrieve Minute from TaskContext
    //
    VariantClear(&varValue);
    hr = pTaskContext->GetParameter(bstrParamTimeMinute,
                                    &varValue);
    TRACE2(("GetParameter %ws returned  in CDateTime::GetSetDateTimeParameters\
                %X"), PARAM_TIME_MINUTE, hr);

    if (V_VT(&varValue) != VT_BSTR)
    {
        TRACE2(("Non-string(%X) parameter received for %ws in GetParameter \
                    in CDateTime:GetSetDateTime"), \
                    V_VT(&varValue), PARAM_TIME_MINUTE);
        hr = E_INVALIDARG;
        goto End;
    }
    pLocalTime->wMinute = (WORD) _ttoi(V_BSTR(&varValue));


    hr = S_OK;


End:
    VariantClear(&varValue);
    SysFreeString(bstrParamDateDay); 
    SysFreeString(bstrParamDateMonth); 
    SysFreeString(bstrParamDateYear); 
    SysFreeString(bstrParamTimeHour); 
    SysFreeString(bstrParamTimeMinute); 
    return hr;
}




STDMETHODIMP CDateTime::SetDateTime(IN ITaskContext  *pTaskContext)
{
    SYSTEMTIME LocalTime;
    HRESULT hr;

    ASSERT(pTaskContext);  

    
    ZeroMemory(&LocalTime, sizeof(SYSTEMTIME));


    hr = GetSetDateTimeParameters(pTaskContext, &LocalTime);
    if (S_OK != hr)
    {
        return hr;
    }

    //
    // Save the current date/time - in case this operation has to be rolled back
    //
    ZeroMemory(&m_OldDateTime, sizeof(SYSTEMTIME));
    GetLocalTime(&m_OldDateTime);

    //
    // Set the new date/time
    // Note that Windows NT uses the Daylight Saving Time setting of the 
    // current time, not the new time we are setting. Therefore, calling 
    // SetLocalTime again, now that the Daylight Saving Time setting is set 
    // for the new time, will guarantee the correct result. 
    //
    if (TRUE == SetLocalTime(&LocalTime))
    {
        if (TRUE == SetLocalTime(&LocalTime))
        {
            //
            // Successful set the new date/time
            //
            return S_OK;
        }
    }


    //
    // if we got here, one of the SetLocalTime calls must have failed
    // We should restore the time here the old time here since
    // we will not get called on TaskComplete  method
    // We will lose may be a second or two - tough luck!
    //
    hr = HRESULT_FROM_WIN32(GetLastError());
    TRACE1(("SetDateTime failed to set the new time %X"), hr);
    

    if (TRUE == SetLocalTime(&m_OldDateTime))
    {
        if (TRUE == SetLocalTime(&m_OldDateTime))
        {
            //
            // Successful restored the old date/time
            // Return the old error code back to AppMgr, since the attempt 
            // to set new time had failed
            //
            TRACE("SetDateTime has restored the old time");
            return hr;
        }
    }


    //
    // If we got here, the time to restore to old time has failed!!
    // There is not much we can do :-(
    //
    TRACE1(("SetDateTime failed to set restore the old time %X"), HRESULT_FROM_WIN32(GetLastError()));


    return hr;
}

 



STDMETHODIMP CDateTime::GetSetTimeZoneParameters(IN ITaskContext *pTaskContext, 
                                                    OUT LPTSTR   *lpStandardTimeZoneName,
                                                    OUT BOOL     *pbEnableDayLightSavings)
{
    
    BSTR bstrParamTimeZoneName = SysAllocString(PARAM_TIMEZONE_STANDARDTIME);
    BSTR bstrParamEnableDayLightSavings = SysAllocString(PARAM_DAYLIGHT_ENABLE);
    HRESULT hr;
    VARIANT varValue;
    LPTSTR  szEnableDayLight = NULL;
    HANDLE     hProcessHeap = NULL;


    ASSERT(pTaskContext);
    ASSERT(lpStandardTimeZoneName);
    ASSERT(pbEnableDayLightSavings);
    

    TRACE("Enter GetSetTimeZoneParameters");

    (*lpStandardTimeZoneName) = NULL;
    
    //
    // Retrieve Standard Time Zone name from TaskContext
    //
    VariantClear(&varValue);
    hr = pTaskContext->GetParameter(bstrParamTimeZoneName,
                                    &varValue);
    TRACE2("GetParameter %ws returned  in CDateTime::GetSetTimeZoneParameters "
                "%X", PARAM_TIMEZONE_STANDARDTIME, hr);

    if (V_VT(&varValue) != VT_BSTR)
    {
        TRACE2("Non-string(%X) parameter received for %ws in GetParameter "
                    "in CDateTime:GetSetTimeZoneParameters", 
                    V_VT(&varValue), PARAM_TIMEZONE_STANDARDTIME);
        hr = E_INVALIDARG;
        goto End;
    }
    
    hProcessHeap = GetProcessHeap();
    if (NULL == hProcessHeap)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto End;
    }


    *lpStandardTimeZoneName = (LPTSTR) HeapAlloc(hProcessHeap, 0,
                                                    ((lstrlen(V_BSTR(&varValue)) + 1) * sizeof(TCHAR)));
     if (NULL == *lpStandardTimeZoneName)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto End;
    }
    lstrcpy(*lpStandardTimeZoneName, V_BSTR(&varValue));

    
    //
    // Retrieve EnableDayLightSavings flag from TaskContext
    //
    VariantClear(&varValue);
    hr = pTaskContext->GetParameter(bstrParamEnableDayLightSavings,
                                    &varValue);
    TRACE2(("GetParameter %ws returned  in CDateTime::GetSetTimeZoneParameters\
                %X"), PARAM_DAYLIGHT_ENABLE, hr);

    if (V_VT(&varValue) != VT_BSTR)
    {
        TRACE2(("Non-string(%X) parameter received for %ws in GetParameter \
                    in CDateTime:GetSetTimeZoneParameters"), \
                    V_VT(&varValue), PARAM_DAYLIGHT_ENABLE);
        hr = E_INVALIDARG;
        goto End;
    }
    //
    // TODO: Convert String value to WORD
    //
    szEnableDayLight = V_BSTR(&varValue);
    *pbEnableDayLightSavings = ((szEnableDayLight[0] == L'y') || (szEnableDayLight[0] == L'Y')) ? TRUE : FALSE;

    hr = S_OK;


End:
    VariantClear(&varValue);
    SysFreeString(bstrParamTimeZoneName); 
    SysFreeString(bstrParamEnableDayLightSavings); 
    if (S_OK != hr)
    {
        if (NULL != *lpStandardTimeZoneName)
        {
            HeapFree(hProcessHeap, 0, *lpStandardTimeZoneName);
            *lpStandardTimeZoneName = NULL;
        }
    }

    TRACE1("Leave GetSetTimeZoneParameters, %x", hr);

    return hr;
}




STDMETHODIMP CDateTime::SetTimeZone(IN ITaskContext  *pTaskContext)
{
    BOOL bEnableDayLightSaving;
    LPTSTR lpTimeZoneStandardName = NULL;
    HRESULT hr;
    PTZINFO pTimeZoneInfoList = NULL;
    PTZINFO pTimeZone = NULL;
    int iCount;


    ASSERT(pTaskContext);  

    TRACE("Enter SetTimeZone");
    
    hr = GetSetTimeZoneParameters(pTaskContext, 
                                    &lpTimeZoneStandardName,
                                    &bEnableDayLightSaving);

    if (S_OK != hr)
    {
        goto CleanupAndExit;
    }

    //
    // Save the current timezone information - in case this operation 
    // has to be rolled back
    //
    ZeroMemory(&m_OldTimeZoneInformation, sizeof(TIME_ZONE_INFORMATION));
    GetTimeZoneInformation(&m_OldTimeZoneInformation);
    m_OldEnableDayLightSaving = GetAllowLocalTimeChange();
    
    
    //
    // Read the list of possible timezones from the registry
    //
    iCount = ReadTimezones(&pTimeZoneInfoList);
    if (0 >= iCount)
    {
        hr = E_FAIL;
        TRACE1(("SetTimeZone failed to enumerate time zones %X"), hr);
        goto CleanupAndExit;
    }


    //
    // Search for the specified Time Zone
    //
    for (pTimeZone = pTimeZoneInfoList; pTimeZone; pTimeZone = pTimeZone->next)
    {
        if (0 == lstrcmpi(pTimeZone->szStandardName, lpTimeZoneStandardName))
        {
            break;
        }
    }

    
    if (NULL != pTimeZone)
    {
        SetTheTimezone(bEnableDayLightSaving, pTimeZone);
        hr = S_OK;
    }
    else
    {
        //
        // if we got here, there were no matches for the input Time Zone
        //
        hr = E_FAIL;
        TRACE1(("SetDateTime:: There were no TimeZone matching the input %X"), hr);
    }
    


CleanupAndExit:
    
    if (NULL != lpTimeZoneStandardName)
    {
        HeapFree(GetProcessHeap(), 0, lpTimeZoneStandardName);
    }
    
    FreeTimezoneList(&pTimeZoneInfoList);

    TRACE1("Leave SetTimeZone, %x", hr);

    return hr;
}




STDMETHODIMP CDateTime::RollbackSetTimeZone(IN ITaskContext  *pTaskContext)
{
    HRESULT hr = S_OK;

 
    ASSERT(pTaskContext); 
    
    //
    // Set the Time Zone and Enable Daylight savings to previous values
    //
    if (FALSE == SetTimeZoneInformation(&m_OldTimeZoneInformation))
    {
        //
        // There is not much we can do !!
        //
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    SetAllowLocalTimeChange(m_OldEnableDayLightSaving);
    
    
    return hr;
}



STDMETHODIMP CDateTime::RollbackSetDateTime(IN ITaskContext  *pTaskContext)
{
    HRESULT hr = S_OK;

 
    ASSERT(pTaskContext); 
    
    //
    // Set the Date/Time to previous values 
    // We could have lost sometime in between - but this is the best we can do
    //

    //
    // Note that Windows NT uses the Daylight Saving Time setting of the 
    // current time, not the new time we are setting. Therefore, calling 
    // SetLocalTime again, now that the Daylight Saving Time setting is set 
    // for the new time, will guarantee the correct result. 
    //
    if (TRUE == SetLocalTime(&m_OldDateTime))
    {
        if (TRUE == SetLocalTime(&m_OldDateTime))
        {
            //
            // Success
            //
            return S_OK;
        }
    }

    //
    // If we got here, the SetLocalTime call(s) must have failed
    // Unfortunately, there is not much we can do !!
    //
    hr = HRESULT_FROM_WIN32(GetLastError());
    
    return hr;
}


////////////////////////////////////////////////////////////////////////////
//
//  ReadZoneData
//
//  Reads the data for a time zone from the registry.
//
////////////////////////////////////////////////////////////////////////////

BOOL CDateTime::ReadZoneData(PTZINFO zone, HKEY key, LPCTSTR keyname)
{
    DWORD len;

    len = sizeof(zone->szDisplayName);

    if (RegQueryValueEx(key,
                         c_szTZDisplayName,
                         0,
                         NULL,
                         (LPBYTE)zone->szDisplayName,
                         &len ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    //
    //  Under NT, the keyname is the "Standard" name.  Values stored
    //  under the keyname contain the other strings and binary info
    //  related to the time zone.  Every time zone must have a standard
    //  name, therefore, we save registry space by using the Standard
    //  name as the subkey name under the "Time Zones" key.
    //
    len = sizeof(zone->szStandardName);

    if (RegQueryValueEx(key,
                         c_szTZStandardName,
                         0,
                         NULL,
                         (LPBYTE)zone->szStandardName,
                         &len ) != ERROR_SUCCESS)
    {
        //
        //  Use keyname if can't get StandardName value.
        //
        lstrcpyn(zone->szStandardName,
                  keyname,
                  sizeof(zone->szStandardName) );
    }

    len = sizeof(zone->szDaylightName);

    if (RegQueryValueEx(key,
                         c_szTZDaylightName,
                         0,
                         NULL,
                         (LPBYTE)zone->szDaylightName,
                         &len ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    len = sizeof(zone->Bias) +
          sizeof(zone->StandardBias) +
          sizeof(zone->DaylightBias) +
          sizeof(zone->StandardDate) +
          sizeof(zone->DaylightDate);

    if (RegQueryValueEx(key,
                         c_szTZI,
                         0,
                         NULL,
                         (LPBYTE)&zone->Bias,
                         &len ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  AddZoneToList
//
//  Inserts a new time zone into a list, sorted by bias and then name.
//
////////////////////////////////////////////////////////////////////////////

void CDateTime::AddZoneToList(PTZINFO *list,
                                PTZINFO zone)
{
    if (*list)
    {
        PTZINFO curr = *list;
        PTZINFO next = NULL;

        //
        // Go to end of the list
        //
        while (curr && curr->next)
        {
            curr = curr->next;
            next = curr->next;
        }

        if (curr)
        {
            curr->next = zone;
        }
    
        if (zone)
        {
            zone->next = NULL;
        }

    }
    else
    {
        *list = zone;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeTimezoneList
//
//  Frees all time zones in the passed list, setting the head to NULL.
//
////////////////////////////////////////////////////////////////////////////

void CDateTime::FreeTimezoneList(PTZINFO *list)
{
    while (*list)
    {
        PTZINFO next = (*list)->next;

        LocalFree((HANDLE)*list);

        *list = next;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ReadTimezones
//
//  Reads the time zone information from the registry.
//  Returns num read, -1 on failure.
//
////////////////////////////////////////////////////////////////////////////

int CDateTime::ReadTimezones(PTZINFO *list)
{
    HKEY key = NULL;
    int count = -1;

    *list = NULL;

    if (RegOpenKey( HKEY_LOCAL_MACHINE,
                    c_szTimeZones,
                    &key ) == ERROR_SUCCESS)
    {
        TCHAR name[TZNAME_SIZE];
        PTZINFO zone = NULL;
        int i;

        count = 0;

        for (i = 0;
             RegEnumKey(key, i, name, TZNAME_SIZE) == ERROR_SUCCESS;
             i++)
        {
            HKEY subkey = NULL;

            if (!zone &&
                ((zone = (PTZINFO)LocalAlloc(LPTR, sizeof(TZINFO))) == NULL))
            {
                zone = *list;
                *list = NULL;
                count = -1;
                break;
            }

            zone->next = NULL;

            if (RegOpenKey(key, name, &subkey) == ERROR_SUCCESS)
            {
                //
                //  Each sub key name under the Time Zones key is the
                //  "Standard" name for the Time Zone.
                //
                lstrcpyn(zone->szStandardName, name, TZNAME_SIZE);

                if (ReadZoneData(zone, subkey, name))
                {
                    AddZoneToList(list, zone);
                    zone = NULL;
                    count++;
                }

                RegCloseKey(subkey);
            }
        }

        FreeTimezoneList(&zone);
        RegCloseKey(key);
    }

    return (count);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetAllowLocalTimeChange
//
////////////////////////////////////////////////////////////////////////////

TCHAR c_szRegPathTZControl[] = REGSTR_PATH_TIMEZONE;
TCHAR c_szRegValDisableTZUpdate[] = REGSTR_VAL_TZNOAUTOTIME;

BOOL CDateTime::GetAllowLocalTimeChange(void)
{
    //
    //  Assume allowed until we see a disallow flag.
    //
    BOOL result = TRUE;
    HKEY key;

    if (RegOpenKey( HKEY_LOCAL_MACHINE,
                    c_szRegPathTZControl,
                    &key ) == ERROR_SUCCESS)
    {
        //
        //  Assume no disallow flag until we see one.
        //
        DWORD value = 0;
        DWORD dwlen = sizeof(value);
        DWORD type;

        if ((RegQueryValueEx( key,
                              c_szRegValDisableTZUpdate,
                              NULL,
                              &type,
                              (LPBYTE)&value,
                              &dwlen ) == ERROR_SUCCESS) &&
            ((type == REG_DWORD) || (type == REG_BINARY)) &&
            (dwlen == sizeof(value)) && value)
        {
            //
            //  Okay, we have a nonzero value, it is either:
            //
            //  1) 0xFFFFFFFF
            //      this is set in an inf file for first boot to prevent
            //      the base from performing any cutovers during setup.
            //
            //  2) some other value
            //      this signifies that the user actualy disabled cutovers
            //     *return that local time changes are disabled
            //
            if (value != 0xFFFFFFFF)
            {
                result = FALSE;
            }
        }

        RegCloseKey(key);
    }

    return (result);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetAllowLocalTimeChange
//
////////////////////////////////////////////////////////////////////////////

void CDateTime::SetAllowLocalTimeChange(BOOL fAllow)
{
    HKEY key = NULL;

    if (fAllow)
    {
        //
        //  Remove the disallow flag from the registry if it exists.
        //
        if (RegOpenKey( HKEY_LOCAL_MACHINE,
                        c_szRegPathTZControl,
                        &key ) == ERROR_SUCCESS)
        {
            RegDeleteValue(key, c_szRegValDisableTZUpdate);
        }
    }
    else
    {
        //
        //  Add/set the nonzero disallow flag.
        //
        if (RegCreateKey( HKEY_LOCAL_MACHINE,
                          c_szRegPathTZControl,
                          &key ) == ERROR_SUCCESS)
        {
            DWORD value = 1;

            RegSetValueEx( key,
                           (LPCTSTR)c_szRegValDisableTZUpdate,
                           0UL,
                           REG_DWORD,
                           (LPBYTE)&value,
                           sizeof(value) );
        }
    }

    if (key)
    {
        RegCloseKey(key);
    }
}



////////////////////////////////////////////////////////////////////////////
//
//  SetTheTimezone
//
//  Apply the time zone selection.
//
////////////////////////////////////////////////////////////////////////////

void CDateTime::SetTheTimezone(BOOL bAutoMagicTimeChange, PTZINFO ptzi)
{
    
    TIME_ZONE_INFORMATION tzi;

    if (!ptzi)
    {
        return;
    }

    tzi.Bias = ptzi->Bias;

    if ((bAutoMagicTimeChange == 0) ||
        (ptzi->StandardDate.wMonth == 0))
    {
        //
        //  Standard Only.
        //
        tzi.StandardBias = ptzi->StandardBias;
        tzi.DaylightBias = ptzi->StandardBias;
        tzi.StandardDate = ptzi->StandardDate;
        tzi.DaylightDate = ptzi->StandardDate;

        lstrcpy(tzi.StandardName, ptzi->szStandardName);
        lstrcpy(tzi.DaylightName, ptzi->szStandardName);
    }
    else
    {
        //
        //  Automatically adjust for Daylight Saving Time.
        //
        tzi.StandardBias = ptzi->StandardBias;
        tzi.DaylightBias = ptzi->DaylightBias;
        tzi.StandardDate = ptzi->StandardDate;
        tzi.DaylightDate = ptzi->DaylightDate;

        lstrcpy(tzi.StandardName, ptzi->szStandardName);
        lstrcpy(tzi.DaylightName, ptzi->szDaylightName);
    }

    SetAllowLocalTimeChange(bAutoMagicTimeChange);

    SetTimeZoneInformation(&tzi);
}



STDMETHODIMP CDateTime::RaiseSetDateTimeAlert(void)
{
    CComPtr<IApplianceServices>    pAppSrvcs = NULL;
    DWORD                         dwAlertType = SA_ALERT_TYPE_ATTENTION;
    DWORD                        dwAlertId = SA_DATETIME_NOT_CONFIGURED_ALERT;
    HRESULT                        hr = E_FAIL;
    _bstr_t                        bstrAlertLog(ALERT_LOG_NAME);
    _bstr_t                     bstrAlertSource(ALERT_SOURCE);
    _variant_t                     varReplacementStrings;
    _variant_t                     varRawData;
    LONG                         lCookie;

    
    SATraceFunction("RaiseSetDateTimeAlert");

    hr = CoCreateInstance(CLSID_ApplianceServices,
                            NULL,
                            CLSCTX_INPROC_SERVER       ,
                            IID_IApplianceServices,
                            (void**)&pAppSrvcs);
    if (FAILED(hr))
    {
        ASSERTMSG(FALSE, L"RaiseSetDateTimeAlert failed at CoCreateInstance");
        TRACE1("RaiseSetDateTimeAlert failed at CoCreateInstance, %x", hr);
        goto End;
    }

    ASSERT(pAppSrvcs);
    hr = pAppSrvcs->Initialize(); 
    if (FAILED(hr))
    {
        ASSERTMSG(FALSE, L"RaiseSetDateTimeAlert failed at pAppSrvcs->Initialize");
        TRACE1("RaiseSetDateTimeAlert failed at pAppSrvcs->Initialize, %x", hr);
        goto End;
    }


    hr = pAppSrvcs->RaiseAlert(dwAlertType, 
                                dwAlertId,
                                bstrAlertLog, 
                                bstrAlertSource, 
                                SA_ALERT_DURATION_ETERNAL,
                                &varReplacementStrings,    
                                &varRawData,      
                                &lCookie);

    if (FAILED(hr))
    {
        ASSERTMSG(FALSE, TEXT("RaiseSetDateTimeAlert failed at pAppSrvcs->RaiseAlert"));
        TRACE1("RaiseSetDateTimeAlert failed at pAppSrvcs->RaiseAlert, %x", hr);
    }


End:
    return hr;

}



BOOL CDateTime::DoNotRaiseDateTimeAlert(void)
{
    LONG     lReturnValue;
    HKEY    hKey = NULL;
    DWORD    dwDisposition, dwRaiseDateTimeAlert = 0;
    BOOL    bReturnCode = FALSE;

    SATraceFunction("DoNotRaiseDateTimeAlert");
    
    //
    // Write Settings to registry
    //
    lReturnValue =  RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                    REGKEY_SA_DATETIME,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_ALL_ACCESS,
                                    NULL,
                                    &hKey,
                                    &dwDisposition);
    if (lReturnValue != ERROR_SUCCESS)
    {
        TRACE1("RegCreateKeyEx failed with %X", lReturnValue);
        goto End;
    }

    //
    // Set RaiseAlert value to 0
    //
    dwRaiseDateTimeAlert = 0;
    lReturnValue = RegSetValueEx(hKey,
                                    REGSTR_VAL_DATETIME_RAISEALERT,
                                    0,
                                    REG_DWORD,
                                    (LPBYTE) &dwRaiseDateTimeAlert,
                                    sizeof(DWORD));
    if (lReturnValue != ERROR_SUCCESS)
    {
        TRACE2("RegSetValueEx of %ws failed with %X", REGSTR_VAL_DATETIME_RAISEALERT, lReturnValue);
        goto End;
    }
    else
    {
        bReturnCode = TRUE;
    }


End:
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    return bReturnCode;

}





BOOL CDateTime::ShouldRaiseDateTimeAlert(void)
{
    LONG     lReturnValue;
    HKEY    hKey = NULL;
    DWORD    dwSize, dwType, dwRaiseDateTimeAlert = 0;
    BOOL    bReturnCode = TRUE;

    SATraceFunction("ShouldRaiseDateTimeAlert");
    
    //
    // Open HKLM\Software\Microsoft\ServerAppliance\DateTime reg key
    //
    lReturnValue = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                    REGKEY_SA_DATETIME, 
                                    0, 
                                    KEY_READ, 
                                    &hKey);

    if (lReturnValue != ERROR_SUCCESS)
    {
        TRACE1("RegOpenKeyEx failed with %X", lReturnValue);
        goto End;
    }

    //
    // Read the RaiseAlert reg key
    //
    dwSize = sizeof(DWORD);
    lReturnValue = RegQueryValueEx(hKey,
                                    REGSTR_VAL_DATETIME_RAISEALERT,
                                    0,
                                    &dwType,
                                    (LPBYTE) &dwRaiseDateTimeAlert,
                                    &dwSize);
    if (lReturnValue != ERROR_SUCCESS)
    {
        TRACE2("RegQueryValueEx of %ws failed with %X", REGSTR_VAL_DATETIME_RAISEALERT, lReturnValue);
        goto End;
    }

    if (0 == dwRaiseDateTimeAlert)
    {
        bReturnCode = FALSE;
    }


End:
    if (NULL != hKey)
    {
        RegCloseKey(hKey);
    }
    return bReturnCode;
}




BOOL CDateTime::ClearDateTimeAlert(void)
{
    CComPtr<IApplianceServices>    pAppSrvcs = NULL;
    HRESULT                        hr = E_FAIL;
    _bstr_t                        bstrAlertLog(ALERT_LOG_NAME);
    BOOL                        bReturnCode = FALSE;
    
    
    SATraceFunction("ClearDateTimeAlert");

    hr = CoCreateInstance(CLSID_ApplianceServices,
                            NULL,
                            CLSCTX_INPROC_SERVER       ,
                            IID_IApplianceServices,
                            (void**)&pAppSrvcs);
    if (FAILED(hr))
    {
        ASSERTMSG(FALSE, L"ClearDateTimeAlert failed at CoCreateInstance");
        TRACE1("ClearDateTimeAlert failed at CoCreateInstance, %x", hr);
        goto End;
    }

    ASSERT(pAppSrvcs);
    hr = pAppSrvcs->Initialize(); 
    if (FAILED(hr))
    {
        ASSERTMSG(FALSE, L"ClearDateTimeAlert failed at pAppSrvcs->Initialize");
        TRACE1("ClearDateTimeAlert failed at pAppSrvcs->Initialize, %x", hr);
        goto End;
    }


    hr = pAppSrvcs->ClearAlertAll(SA_DATETIME_NOT_CONFIGURED_ALERT,    
                                    bstrAlertLog);

    //
    // DISP_E_MEMBERNOTFOUND means that there were no matching alerts
    //
    if ((hr != DISP_E_MEMBERNOTFOUND) && (FAILED(hr)))
    {
        ASSERTMSG(FALSE, TEXT("ClearDateTimeAlert failed at pAppSrvcs->RaiseAlert"));
        TRACE1("ClearDateTimeAlert failed at pAppSrvcs->RaiseAlert, %x", hr);
    }
    else
    {
        bReturnCode = TRUE;
    }


End:
    return bReturnCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\setdatetime\source\setdatetime.cpp ===
// SetDateTime.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SetDateTimeps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SetDateTime.h"

#include "appliancetask.h"
#include "taskctx.h"
#include "SetDateTime_i.c"
#include "DateTime.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DateTime, CDateTime)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\shutdown\task\resource.h ===
#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#define IDS_SAShutdownTask                   100
#define IDR_SAShutdownTask                   101

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\shutdown\task\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

//#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
//#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\setdatetime\source\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SetDateTime.rc
//
#define IDS_PROJNAME                    100
#define IDR_DATETIME                    101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\setdatetime\source\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__F1E0DC13_D1E4_11D2_84FC_0080C7227EA1__INCLUDED_)
#define AFX_STDAFX_H__F1E0DC13_D1E4_11D2_84FC_0080C7227EA1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED
#undef _ATL_NO_DEBUG_CRT


#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F1E0DC13_D1E4_11D2_84FC_0080C7227EA1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\shutdown\support\taskshutdown\taskshutdown.cpp ===
/******************************************************************
   Copyright (C) 2001 Microsoft Corporation.  All rights reserved.

   Author -- H.K. Sivasubramanian(siva.sub@wipro.com)
	
   TaskShutDown.CPP -- Shutdown and Restart of a system
 
   Description: 
   Shuts down or restarts a system depending on the command line parameter
  
  
******************************************************************/

#include <windows.h>
#include <comdef.h>
#include <stdio.h>
#include <tchar.h>

#include "appsrvcs.h"
#include "taskctx.h"
#include <iostream>
#include <string>
using namespace std;

// Release the object once done with it
#define SAFEIRELEASE(pIObj) \
if (pIObj) \
{ \
	pIObj->Release(); \
	pIObj = NULL; \
}

// To handle all exceptions
#define ONFAILTHROWERROR(hr) \
{	\
	if (FAILED(hr)) \
		throw _com_error(hr); \
}


// 84DA8800-CB46-11D2-BF23-00105A1F3461
const CLSID CLSID_TaskContext = { 0x84DA8800, 0xCB46, 0x11D2, { 0xBF, 0x23, 0x00, 0x10, 0x5A, 0x1F, 0x34, 0x61 } };

// ----
const CLSID IID_ITaskContext = { 0x96C637B0, 0xB8DE, 0x11D2, { 0xA9, 0x1C, 0x00, 0xAA, 0x00, 0xA7, 0x1D, 0xCA } };

// 1BF00631-CB9E-11D2-90C3-00AA00A71DCA
const CLSID CLSID_ApplianceServices = { 0x1BF00631, 0xCB9E, 0x11D2, { 0x90, 0xC3, 0x00, 0xAA, 0x00, 0xA7, 0x1D, 0xCA } };

// 408B0460-B8E5-11D2-A91C-00AA00A71DCA
const CLSID IID_IApplianceServices = { 0x408B0460, 0xB8E5, 0x11D2, { 0xA9, 0x1C, 0x00, 0xAA, 0x00, 0xA7, 0x1D, 0xCA } };



#define NULL_STRING		 L"\0"

extern "C"
int __cdecl wmain(int argc, wchar_t *argv[])
{
	// Checking whether the necessary command line arguments are supplied
	if (argc == 2)
	{
		HRESULT								hr				= S_OK; 

		// Interface pointer to the ITaskContext interface
		ITaskContext			*pITContext		= NULL;

		// Interface pointer to the IApplianceServices interface
		IApplianceServices		*pIASvcs		= NULL;

		BSTR			         bstrParam		= NULL;

		try
		{
			VARIANT	    	         vPowerOff, vValue;
			VariantInit(&vPowerOff);
			VariantInit(&vValue);
			
			///////////////////////////////////////////////////////////////////
			// Call CoInitialize to initialize the COM library and then
			// CoCreateInstance to get the ITaskContext object
			// CoCreateInstance to get the IApplianceServices object
			///////////////////////////////////////////////////////////////////
			hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
			ONFAILTHROWERROR(hr);
			
			// Creates a single uninitialized object of ITaskContext. 
			hr = CoCreateInstance(CLSID_TaskContext,
								  NULL,
								  CLSCTX_INPROC_SERVER,
								  IID_ITaskContext,
								  (void **) &pITContext);

			// Exception handling
			ONFAILTHROWERROR(hr);

			// Creates a single uninitialized object of IApplianceServices
			hr = CoCreateInstance(CLSID_ApplianceServices,
								  NULL,
								  CLSCTX_INPROC_SERVER,
								  IID_IApplianceServices,
								  (void **) &pIASvcs);
			// Exception handling
			ONFAILTHROWERROR(hr);


			///////////////////////////////////////////////////////////////////
			// Call IApplianceServices::Initialize and then 
			// IApplianceServices::ExecuteTaskAsync to execute Shutdown method
			///////////////////////////////////////////////////////////////////
			vPowerOff.vt = VT_BSTR;

			wstring wsOption(argv[1]);
			wstring wsShutdown(L"SHUTDOWN");
			wstring wsRestart(L"RESTART");
			
			if( _wcsicmp(wsOption.c_str(), wsShutdown.c_str()) == 0 )
			{
		  	    cout << "Invoking Shutdown Task" << endl;
				vPowerOff.bstrVal = ::SysAllocString(L"1");
			}
			else
			{
			  if( _wcsicmp(wsOption.c_str(),wsRestart.c_str()) == 0 )
			  {
		  	    cout << "Invoking Restart Task" << endl;
				  vPowerOff.bstrVal = ::SysAllocString(L"0");;
			  }
			  else
			  {
			  	  cout << "Unrecognized option: " << (const char*)_bstr_t(argv[1]) << endl;
			  	  exit(-1);
			  }
			}

			
			// Set the 'Method Name'
			bstrParam = ::SysAllocString(L"Method Name");
			vValue.vt = VT_BSTR;
			vValue.bstrVal = ::SysAllocString(L"ShutDownAppliance");
			hr = pITContext->SetParameter(bstrParam, &vValue);
			ONFAILTHROWERROR(hr);
			::SysFreeString(bstrParam);
			VariantClear(&vValue);


			// Set the 'Sleep Duration'
			bstrParam = ::SysAllocString(L"SleepDuration");
			vValue.vt = VT_I4;
			// Sleep time is '17 seconds
			vValue.lVal = 17000; 
			hr = pITContext->SetParameter(bstrParam, &vValue);
			ONFAILTHROWERROR(hr);
			::SysFreeString(bstrParam);
			VariantClear(&vValue);

			// Set the 'PowerOff'
			bstrParam = ::SysAllocString(L"PowerOff");
			hr = pITContext->SetParameter(bstrParam, &vPowerOff);
			ONFAILTHROWERROR(hr);
			::SysFreeString(bstrParam);
			VariantClear(&vPowerOff);

			// Initialize the Applicance Services object
			hr = pIASvcs->Initialize();
			ONFAILTHROWERROR(hr);

			// ExecuteTaskAsync
			bstrParam = ::SysAllocString(L"ApplianceShutdownTask");
			hr = pIASvcs->ExecuteTaskAsync(bstrParam, pITContext);
			ONFAILTHROWERROR(hr);
			::SysFreeString(bstrParam);
			
			SAFEIRELEASE(pITContext);
			SAFEIRELEASE(pIASvcs);
		}
		catch(_com_error& e)
		{
			wprintf(L"ERROR:\n\tCode = 0x%x\n\tDescription = %s\n", e.Error(), 
						(LPWSTR) e.Description());
			::SysFreeString(bstrParam);
			SAFEIRELEASE(pITContext);
			SAFEIRELEASE(pIASvcs);

		}
	}
	else
	{
		wprintf(L"ERROR: Invalid Usage.\nUSAGE: taskshutdown.exe <RESTART|SHUTDOWN>\n");
	}
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\shutdown\task\powrprof.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1996
*
*  TITLE:       POWRPROF.H
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        17 Oct, 1996
*
*  DESCRIPTION:
*
*   Declarations and definitions for the user power management profile
*   maintenance library.
*
*******************************************************************************/

// Debug definitions used by power management UI.
#ifdef DEBUG

void CDECL DebugPrintA(LPCSTR pszFmt, ...);

#define DebugPrint               DebugPrintA

#else  // DEBUG

#define DebugPrint        1 ? (void)0 : (void)

#endif // DEBUG

// Define the following to debug batmeter on machines with no battery support.
//#define SIM_BATTERY 1

#define CURRENT_REVISION 1

#define STRSIZE(psz) ((lstrlen(psz) + 1) * sizeof(TCHAR))

#define MAX_NAME_LEN  32    // Max length of name in characters.
#define MAX_NAME_SIZE (MAX_NAME_LEN +1) * sizeof(TCHAR)

#define MAX_DESC_LEN  512   // Max length of description in characters.
#define MAX_DESC_SIZE (MAX_DESC_LEN +1) * sizeof(TCHAR)

#define SEMAPHORE_TIMEOUT  10000

#define NUM_DEC_DIGITS 10+1+1       // 10 digits + NUll and sign.
#define SIZE_DEC_DIGITS (10+1+1) * sizeof(TCHAR)

// Registry storage structures for the GLOBAL_POWER_POLICY data. There are two
// structures, GLOBAL_MACHINE_POWER_POLICY and GLOBAL_USER_POWER_POLICY. the
// GLOBAL_MACHINE_POWER_POLICY stores per machine data for which there is no UI.
// GLOBAL_USER_POWER_POLICY stores the per user data.

typedef struct _GLOBAL_MACHINE_POWER_POLICY{
    ULONG                   Revision;
    SYSTEM_POWER_STATE      LidOpenWakeAc;
    SYSTEM_POWER_STATE      LidOpenWakeDc;
    ULONG                   BroadcastCapacityResolution;
} GLOBAL_MACHINE_POWER_POLICY, *PGLOBAL_MACHINE_POWER_POLICY;

typedef struct _GLOBAL_USER_POWER_POLICY{
    ULONG                   Revision;
    POWER_ACTION_POLICY     PowerButtonAc;
    POWER_ACTION_POLICY     PowerButtonDc;
    POWER_ACTION_POLICY     SleepButtonAc;
    POWER_ACTION_POLICY     SleepButtonDc;
    POWER_ACTION_POLICY     LidCloseAc;
    POWER_ACTION_POLICY     LidCloseDc;
    SYSTEM_POWER_LEVEL      DischargePolicy[NUM_DISCHARGE_POLICIES];
    ULONG                   GlobalFlags;
} GLOBAL_USER_POWER_POLICY, *PGLOBAL_USER_POWER_POLICY;

// Structure to manage global power policies at the user level. This structure
// contains data which is common across all power policy profiles.

typedef struct _GLOBAL_POWER_POLICY{
    GLOBAL_USER_POWER_POLICY    user;
    GLOBAL_MACHINE_POWER_POLICY mach;
} GLOBAL_POWER_POLICY, *PGLOBAL_POWER_POLICY;


// Registry storage structures for the POWER_POLICY data. There are two
// structures, MACHINE_POWER_POLICY and USER_POWER_POLICY. the
// MACHINE_POWER_POLICY stores per machine data for which there is no UI.
// USER_POWER_POLICY stores the per user data.

typedef struct _MACHINE_POWER_POLICY{
    ULONG                   Revision;       // 1

    // meaning of power action "sleep"
    SYSTEM_POWER_STATE      MinSleepAc;
    SYSTEM_POWER_STATE      MinSleepDc;
    SYSTEM_POWER_STATE      ReducedLatencySleepAc;
    SYSTEM_POWER_STATE      ReducedLatencySleepDc;

    // parameters for dozing
    ULONG                   DozeTimeoutAc;
    ULONG                   DozeTimeoutDc;
    ULONG                   DozeS4TimeoutAc;
    ULONG                   DozeS4TimeoutDc;

    // processor policies
    UCHAR                   MinThrottleAc;
    UCHAR                   MinThrottleDc;
    UCHAR                   pad1[2];
    POWER_ACTION_POLICY     OverThrottledAc;
    POWER_ACTION_POLICY     OverThrottledDc;

} MACHINE_POWER_POLICY, *PMACHINE_POWER_POLICY;

typedef struct _USER_POWER_POLICY{
    ULONG                   Revision;       // 1


    // "system idle" detection
    POWER_ACTION_POLICY     IdleAc;
    POWER_ACTION_POLICY     IdleDc;
    ULONG                   IdleTimeoutAc;
    ULONG                   IdleTimeoutDc;
    UCHAR                   IdleSensitivityAc;
    UCHAR                   IdleSensitivityDc;
    UCHAR                   pad1[2];

    // meaning of power action "sleep"
    SYSTEM_POWER_STATE      MaxSleepAc;
    SYSTEM_POWER_STATE      MaxSleepDc;

    // For future use
    ULONG                   Reserved[2];

    // video policies
    ULONG                   VideoTimeoutAc;
    ULONG                   VideoTimeoutDc;

    // hard disk policies
    ULONG                   SpindownTimeoutAc;
    ULONG                   SpindownTimeoutDc;

    // processor policies
    BOOLEAN                 OptimizeForPowerAc;
    BOOLEAN                 OptimizeForPowerDc;
    UCHAR                   FanThrottleToleranceAc;
    UCHAR                   FanThrottleToleranceDc;
    UCHAR                   ForcedThrottleAc;
    UCHAR                   ForcedThrottleDc;

} USER_POWER_POLICY, *PUSER_POWER_POLICY;

// Structure to manage power policies at the user level. This structure
// contains data which is unique across power policy profiles.

typedef struct _POWER_POLICY{
    USER_POWER_POLICY       user;
    MACHINE_POWER_POLICY    mach;
} POWER_POLICY, *PPOWER_POLICY;


// Constants for GlobalFlags

#define EnableSysTrayBatteryMeter   0x01
#define EnableMultiBatteryDisplay   0x02
#define EnablePasswordLogon         0x04
#define EnableWakeOnRing            0x08
#define EnableVideoDimDisplay       0x10

// This constant is passed as a uiID to WritePwrScheme.
#define NEWSCHEME (UINT)-1

// Prototype for EnumPwrSchemes callback proceedures.

typedef BOOLEAN (CALLBACK* PWRSCHEMESENUMPROC)(UINT, DWORD, LPTSTR, DWORD, LPTSTR, PPOWER_POLICY, LPARAM);
typedef BOOLEAN (CALLBACK* PFNNTINITIATEPWRACTION)(POWER_ACTION, SYSTEM_POWER_STATE, ULONG, BOOLEAN);

// Public function prototypes

BOOLEAN  GetPwrDiskSpindownRange(PUINT, PUINT);
BOOLEAN  EnumPwrSchemes(PWRSCHEMESENUMPROC, LPARAM);
BOOLEAN  ReadGlobalPwrPolicy(PGLOBAL_POWER_POLICY);
BOOLEAN  WritePwrScheme(PUINT, LPTSTR, LPTSTR, PPOWER_POLICY);
BOOLEAN  WriteGlobalPwrPolicy(PGLOBAL_POWER_POLICY);
BOOLEAN  DeletePwrScheme(UINT);
BOOLEAN  GetActivePwrScheme(PUINT);
BOOLEAN  SetActivePwrScheme(UINT, PGLOBAL_POWER_POLICY, PPOWER_POLICY);
BOOLEAN  GetPwrCapabilities(PSYSTEM_POWER_CAPABILITIES);
BOOLEAN  IsPwrSuspendAllowed(VOID);
BOOLEAN  IsPwrHibernateAllowed(VOID);
BOOLEAN  IsPwrShutdownAllowed(VOID);
BOOLEAN  IsAdminOverrideActive(PADMINISTRATOR_POWER_POLICY);
NTSTATUS CallNtPowerInformation(POWER_INFORMATION_LEVEL, PVOID, ULONG, PVOID, ULONG);
BOOLEAN  SetSuspendState(BOOLEAN, BOOLEAN, BOOLEAN);
BOOLEAN  GetCurrentPowerPolicies(PGLOBAL_POWER_POLICY, PPOWER_POLICY);
BOOLEAN  CanUserWritePwrScheme(VOID);

void CDECL DebugPrintA(LPCSTR pszFmt, ...);


void WINAPI LoadCurrentPwrScheme(HWND hwnd, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow);
void WINAPI MergeLegacyPwrScheme(HWND hwnd, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow);

// Private function prototypes implemented in powrprof.c
BOOLEAN ValidatePowerPolicies(PGLOBAL_POWER_POLICY, PPOWER_POLICY);
BOOLEAN ValidateSystemPolicies(PSYSTEM_POWER_POLICY, PSYSTEM_POWER_POLICY);
BOOLEAN GetCurrentSystemPowerPolicies(PSYSTEM_POWER_POLICY, PSYSTEM_POWER_POLICY);
BOOLEAN ReadPwrScheme(UINT, PPOWER_POLICY);
BOOLEAN MyStrToInt(LPCTSTR, PINT);
BOOLEAN RegistryInit(PUINT);
HANDLE  MyCreateSemaphore(LPCTSTR);

NTSTATUS CallNtSetValidateAcDc(BOOLEAN, PVOID, PVOID, PVOID, PVOID);

#ifdef WINNT
DWORD SetPrivilegeAttribute(LPCTSTR, DWORD, LPDWORD);
VOID  InitAdmin(PADMINISTRATOR_POWER_POLICY papp);
#endif

#ifdef DEBUG
VOID ReadOptionalDebugSettings(VOID);
#endif

// Private function prototypes implemented in reghelp.c:
BOOLEAN OpenCurrentUser(PHKEY phKey);
BOOLEAN CloseCurrentUser(HKEY hKey);
BOOLEAN OpenMachineUserKeys(LPTSTR, LPTSTR, PHKEY, PHKEY);
BOOLEAN TakeRegSemaphore(VOID);
BOOLEAN WritePwrPolicyEx(LPTSTR, LPTSTR, PUINT, LPTSTR, LPTSTR, LPVOID, DWORD, LPVOID, DWORD);
BOOLEAN ReadPwrPolicyEx(LPTSTR, LPTSTR, LPTSTR, LPTSTR, LPDWORD, LPVOID, DWORD, LPVOID, DWORD);
BOOLEAN ReadWritePowerValue(HKEY, LPTSTR, LPTSTR, LPTSTR, LPDWORD, BOOLEAN, BOOLEAN);
BOOLEAN ReadPowerValueOptional(HKEY, LPTSTR, LPTSTR, LPTSTR, LPDWORD);
BOOLEAN ReadPowerIntOptional(HKEY, LPTSTR, LPTSTR, PINT);
BOOLEAN CreatePowerValue(HKEY, LPCTSTR, LPCTSTR, LPCTSTR);

// Private function prototypes implemented in merge.c
BOOLEAN MergePolicies(PUSER_POWER_POLICY, PMACHINE_POWER_POLICY, PPOWER_POLICY);
BOOLEAN SplitPolicies(PPOWER_POLICY, PUSER_POWER_POLICY, PMACHINE_POWER_POLICY);
BOOLEAN MergeGlobalPolicies(PGLOBAL_USER_POWER_POLICY, PGLOBAL_MACHINE_POWER_POLICY, PGLOBAL_POWER_POLICY);
BOOLEAN SplitGlobalPolicies(PGLOBAL_POWER_POLICY, PGLOBAL_USER_POWER_POLICY, PGLOBAL_MACHINE_POWER_POLICY);
BOOLEAN MergeToSystemPowerPolicies(PGLOBAL_POWER_POLICY, PPOWER_POLICY, PSYSTEM_POWER_POLICY, PSYSTEM_POWER_POLICY);
BOOLEAN SplitFromSystemPowerPolicies(PSYSTEM_POWER_POLICY, PSYSTEM_POWER_POLICY, PGLOBAL_POWER_POLICY, PPOWER_POLICY);

// Private function prototypes implemented in debug.c
#ifdef DEBUG
void DumpPowerActionPolicy(LPSTR, PPOWER_ACTION_POLICY);
void DumpSystemPowerLevel(LPSTR, PSYSTEM_POWER_LEVEL);
void DumpSystemPowerPolicy(LPSTR, PSYSTEM_POWER_POLICY);
void DumpSystemPowerCapabilities(LPSTR, PSYSTEM_POWER_CAPABILITIES);
void DifSystemPowerPolicies(LPSTR, PSYSTEM_POWER_POLICY, PSYSTEM_POWER_POLICY);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\shutdown\task\shutdowntask.cpp ===
#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "shutdowntask.h"

#include "appliancetask.h"
#include "taskctx.h"
#include "shutdowntask_i.c"
#include "worker.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SAShutdownTask, CWorker)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object but not type library
    return _Module.RegisterServer(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\shutdown\task\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__56BC53D5_96DB_11D1_BF3F_000000000000__INCLUDED_)
#define AFX_STDAFX_H__56BC53D5_96DB_11D1_BF3F_000000000000__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef STRICT
#define STRICT
#endif

#if !defined(_WIN64) && !defined(_WIN32_WINNT)
#define _WIN32_WINNT 0x0400
#endif
//#define _ATL_APARTMENT_THREADED

#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
#include "shutdowntask.h"
#include "comdef.h"

#include <satrace.h>


#endif // !defined(AFX_STDAFX_H__56BC53D5_96DB_11D1_BF3F_000000000000__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\usergroup\usersinitialalert\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\shutdown\task\worker.h ===
//#--------------------------------------------------------------
//
//  File:       worker.h
//
//  Synopsis:   This file holds the declarations of the
//                SAShutdownTask COM class
//
//
//  History:     10/11/2000 
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//#--------------------------------------------------------------
#ifndef __WORKER_H_
#define __WORKER_H_

#include "resource.h"       // main symbols
#include "taskctx.h"
#include "appsrvcs.h"

class ATL_NO_VTABLE CWorker: 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CWorker, &CLSID_SAShutdownTask>,
    public IDispatchImpl<IApplianceTask, &IID_IApplianceTask, &LIBID_ShutdownTaskLib>
{
public:

    CWorker() {}

    ~CWorker() {}

DECLARE_REGISTRY_RESOURCEID(IDR_SAShutdownTask)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CWorker)
    COM_INTERFACE_ENTRY(IApplianceTask)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

    //
    // IApplianceTask interface methods
    //
    STDMETHOD(OnTaskExecute)(
                     /*[in]*/ IUnknown* pTaskContext
                            );

    STDMETHOD(OnTaskComplete)(
                      /*[in]*/ IUnknown* pTaskContext, 
                      /*[in]*/ LONG      lTaskResult
                             );    
private:

    typedef enum
    {
        NO_TASK,
        SHUTDOWN

    }    SA_TASK, *PSA_TASK;   

    // 
    //
    // supporting methods for the tasks;
    //
    HRESULT GetMethodName(
                /*[in]*/ ITaskContext *pTaskParameter,
                /*[out]*/   PSA_TASK  pTaskName
                );
    //
    // method to carry out the shutdown
    //
    HRESULT InitTask (
                /*[in]*/    ITaskContext *pTaskParameter
                );

    //
    // method to check if the caller wants a power off
    //
    BOOL IsRebootRequested (
                /*[in]*/    ITaskContext *pTaskParameter
                );

    //
    // method to obtain the sleep time
    //
    DWORD GetSleepDuration  (
                /*[in]*/    ITaskContext *pTaskParameter
                );
    //
    //    method to give shutdown priviledges to this process
    //
   bool SetShutdownPrivilege(void);

};

#endif //_WORKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\shutdown\task\worker.cpp ===
//#--------------------------------------------------------------
//
//  File:        worker.cpp
//
//  Synopsis:   Implementation of CWorker class methods
//
//
//  History:    
//
//    Copyright (C) 1999-2000 Microsoft Corporation
//    All rights reserved.
//
//----------------------------------------------------------------
#ifdef __cplusplus
    extern "C" {
#endif

#include "nt.h"
#include "ntrtl.h"
#include "nturtl.h"
#include "windows.h"
#include "ntpoapi.h"

#ifdef __cplusplus
}

#endif
#include "shutdowntask.h"
#include "stdafx.h"
#include "worker.h"
#include "appmgrobjs.h"

//
// string constants here
//
const WCHAR METHOD_NAME_STRING [] = L"MethodName";

const WCHAR POWER_OFF_STRING [] = L"PowerOff";

const WCHAR SLEEP_DURATION_STRING [] = L"SleepDuration";

const WCHAR SHUTDOWN_TASK_STRING [] = L"ApplianceShutdownTask";

//++--------------------------------------------------------------
//
//  Function:   OnTaskComplete
//
//  Synopsis:   This is the IApplianceTask interface method 
//
//  Arguments:  [in]    
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Created     06/06/2000
//
//  Called By: 
//
//----------------------------------------------------------------
STDMETHODIMP 
CWorker::OnTaskComplete(
        /*[in]*/    IUnknown *pTaskContext, 
        /*[in]*/    LONG lTaskResult
        )
{
    CSATraceFunc objTrace ("CWorker::OnTaskComplete");

    _ASSERT(pTaskContext);  

    HRESULT      hr = S_OK;
    try
    {
        do
        {
            if (NULL == pTaskContext)
            {
                SATraceString (
                    "ShutdownTask-OnTaskComplete passed invalid parameter"
                    );
                hr = E_POINTER;
                break;
            }
        
            //
            //
            // Do nothing on Commit
            //
            if (lTaskResult == SA_TASK_RESULT_COMMIT)
            {
                SATraceString (
                    "ShutdownTask-OnTaskComplete-No rollback in OnTaskComplete"
                    );
                    break;
            }

            CComPtr <ITaskContext> pTaskParameters;
            //
            // get the task parameters from the context
            //
            hr = pTaskContext->QueryInterface(
                                    IID_ITaskContext,
                                    (PVOID*)&pTaskParameters
                                    );
            if (FAILED (hr))
            {
                SATracePrintf (
                    "ShutdownTask-OnTaskComplete failed to query "
                    " TaskContext:%x",
                     hr
                    );
                break;
            }
    

            SA_TASK eTask = NO_TASK;
            //
            // Check which Task is being executed and call that method
            //
            hr = GetMethodName(pTaskParameters, &eTask);
            if (FAILED (hr)) {break;}
    
            //
            // initiate the appropriate task now
            //
            switch (eTask)
            {
            case SHUTDOWN:
                hr = InitTask (pTaskParameters);
                break;

            default:
                SATracePrintf (
                    "ShutdownTask-OnTaskComplete passed unknown task type:%d",
                    eTask
                    );
                hr = E_INVALIDARG;
                break;
            }
        }
        while (false);
    }
    catch (...)
    {
        SATraceString (
            "ShutdownTask-OnTaskComplete caught unknown exception"
            );
        hr = E_FAIL;
    }

    return (hr);

}   // end of CWorker::OnTaskComplete method

//++--------------------------------------------------------------
//
//  Function:   OnTaskExecute
//
//  Synopsis:   This is the IApplianceTask interface method 
//
//  Arguments:  [in]    
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Created     06/06/2000
//
//  Called By: 
//
//----------------------------------------------------------------
STDMETHODIMP 
CWorker::OnTaskExecute (
    /*[in]*/ IUnknown *pTaskContext
    )
{
    CSATraceFunc objTrace ("ShutdownTask::OnTaskExecute");

    _ASSERT (pTaskContext);  

    HRESULT hr = S_OK;
    try
    {
        do
        {
            if (NULL == pTaskContext)
            {
                SATraceString (
                    "ShutdownTask-OnTaskExecute passed invalid parameter"
                    );
                hr = E_POINTER;
                break;
            }

            CComPtr <ITaskContext> pTaskParameters;
            //
            // get the task parameters from the context
            //
            hr = pTaskContext->QueryInterface(
                                    IID_ITaskContext,
                                    (PVOID*)&pTaskParameters
                                    );
            if (FAILED (hr))
            {
                SATracePrintf (
                    "ShutdownTask-OnTaskExecute failed to query "
                    " TaskContext:%x",
                     hr
                    );
                break;
            }
    

            SA_TASK eTask = NO_TASK;
            //
            // Check which Task is being executed and call that method
            //
            hr = GetMethodName(pTaskParameters, &eTask);
            if (FAILED (hr)) {break;}
    
            //
            // initiate the appropriate task now
            //
            switch (eTask)
            {
            case SHUTDOWN:
                hr = InitTask (pTaskParameters);
                break;

            default:
                SATracePrintf (
                    "ShutdownTask-OnTaskExecute passed unknown task type:%d",
                    eTask
                    );
                hr = E_INVALIDARG;
                break;
            }
        }
        while (false);
    }
    catch (...)
    {
        SATraceString (
            "ShutdownTask-OnTaskExecute caught unknown exception"
            );
        hr = E_FAIL;
    }

    return (hr);

}   // end of CWorker::OnTaskExecute method

//++--------------------------------------------------------------
//
//  Function:   GetMethodName
//
//  Synopsis:   This is the CUpdateTask private method to obtain
//              the method that the user wants to execute
//
//  Arguments:  [in]  ITaskContext* - task context
//              [out] PSA_TASK - task to execute
//
//  Returns:    HRESULT
//
//  History:    
//
//  Called By: 
//
//----------------------------------------------------------------
HRESULT
CWorker::GetMethodName (
    /*[in]*/    ITaskContext *pTaskParameter,
    /*[out]*/   PSA_TASK    peTask
    )
{
    CSATraceFunc objTraceFunc ("CWorker:GetMethodName");

    _ASSERT(pTaskParameter && peTask);
    
    HRESULT hr = S_OK;
    try
    {
        do
        {
            CComVariant vtValue;
            CComBSTR    bstrParamName (METHOD_NAME_STRING);
            //
            // get the methodname parameter out of the Context
            //
            hr = pTaskParameter->GetParameter(
                                bstrParamName,
                                &vtValue
                                );
            if (FAILED(hr))
            {
                SATracePrintf (
                  "Shutdown Task failed on ITaskParameter::GetParameter "
                   "with error:%x",
                   hr
                );
                break;
            }

            if (V_VT(&vtValue) != VT_BSTR)
            {
                SATracePrintf (
                    "Shutdown Task did not receive a string parameter "
                    " for method name:%d", 
                    V_VT(&vtValue)
                    );
                hr = E_INVALIDARG;
                break;
            }

            //
            // check the task now
            //
            if (0 == ::_wcsicmp (V_BSTR (&vtValue), SHUTDOWN_TASK_STRING))
            {
                *peTask = SHUTDOWN;
            }
            else
            {
                SATracePrintf (
                    "Shutdown Task was requested an unknown task:%ws",
                     V_BSTR (&vtValue)
                    );
                hr = E_INVALIDARG;  
                break;
            }

            //
            // succeeded
            //
        }
        while (false);

    }
    catch (...)
    {
        SATraceString (
            "Shutdown Task caught unknown exception in GetMethodName"
            );
        hr = E_FAIL;
    }
    
    if (FAILED(hr)) {*peTask = NO_TASK;}

    return (hr);

}   //  end of CWorker::GetMethodName method

//++--------------------------------------------------------------
//
//  Function:   IsRebootRequested
//
//  Synopsis:   This is the CUpdateTask private method to check
//                if a reboot is requested
//
//  Arguments:  [in]  ITaskContext* - task context
//
//  Returns:    BOOL - true (reboot)/false (shutdown)
//
//  History:    
//
//  Called By: 
//
//----------------------------------------------------------------
BOOL 
CWorker::IsRebootRequested (
    /*[in]*/    ITaskContext *pTaskParameter
    )
{
      CSATraceFunc objTraceFunc ("CWorker::IsRebootRequested");

    _ASSERT (pTaskParameter);

    HRESULT hr = S_OK;
    BOOL bReboot = TRUE;

    try
    {
        do
        {
            CComVariant vtValue;
            CComBSTR    bstrParamName (POWER_OFF_STRING);
            //
            // get the parameter out of the Context
            //
	        hr = pTaskParameter->GetParameter(
                                bstrParamName,
                                &vtValue
                                );
            if (FAILED(hr))
            {
                SATracePrintf (
                  "Shutdown Task failed on ITaskParameter::IsRebootRequested "
                   "with error:%x",
                   hr
                );
                break;
            }

            if (V_VT(&vtValue) != VT_BSTR)
            {
                SATracePrintf (
                    "Shutdown Task did not receive a string parameter "
                    " for method name:%d", 
                    V_VT(&vtValue)
                    );
                hr = E_INVALIDARG;
                break;
            }

            //
            // check the task now
            //
			if (0 == ::_wcsicmp (V_BSTR (&vtValue), L"0"))
            {
            	bReboot = TRUE;
                SATraceString ("Shutdown Task requestd a REBOOT");
            }
            else
            {
            	  bReboot = FALSE;
                SATraceString ("Shutdown Task requested a SHUTDOWN");
            }

            //
            // succeeded
            //
        }
        while (false);

    }
    catch (...)
    {
        SATraceString (
            "Shutdown Task caught unknown exception in IsRebootRequested"
            );
    }
    
    return (bReboot);

}   //  end of CWorker::IsRbootRequested method

//++--------------------------------------------------------------
//
//  Function:   GetSleepDuration
//
//  Synopsis:   This is the CUpdateTask private method to
//                obtain the Sleep duration requested by the caller
//
//  Arguments:  [in]  ITaskContext* - task context
//
//  Returns:    DWORD - Sleep Duration in milliseconds
//
//  History:    
//
//  Called By: 
//
//----------------------------------------------------------------
DWORD
CWorker::GetSleepDuration (
    /*[in]*/    ITaskContext *pTaskParameter
    )
{
    CSATraceFunc objTraceFunc ("CWorker::GetSleepDuration");

    _ASSERT (pTaskParameter);

    HRESULT hr = S_OK;
    DWORD   dwSleepDuration = 0;

    try
    {
        do
        {
            CComVariant vtValue;
            CComBSTR    bstrParamName (SLEEP_DURATION_STRING);
            //
            // get the parameter out of the Context
            //
            hr = pTaskParameter->GetParameter(
                                bstrParamName,
                                &vtValue
                                );
            if (FAILED(hr))
            {
                SATracePrintf (
                  "Shutdown Task failed on ITaskParameter::GetSleepDuration "
                   "with error:%x",
                   hr
                );
                break;
            }

            if     (V_VT(&vtValue) == VT_I4)
            {
                dwSleepDuration = V_I4 (&vtValue);
            }
            else if (V_VT (&vtValue) == VT_I2)
            {
                   dwSleepDuration = V_I2 (&vtValue);
            }
            else if (V_VT (&vtValue) == VT_UI4)
            {
                   dwSleepDuration = V_UI4 (&vtValue);
            }
            else if (V_VT (&vtValue) == VT_UI2)
            {
                   dwSleepDuration = V_UI2 (&vtValue);
            }
            else if (V_VT (&vtValue) == VT_R8)
            {
                dwSleepDuration = (DWORD) V_R8 (&vtValue);
            }
            else
            {
                SATracePrintf (
                    "Shutdown Task did not receive a integer parameter "
                    " for power off:%d", 
                    V_VT(&vtValue)
                    );
                hr = E_INVALIDARG;
                break;
            }

            SATracePrintf (
                "Shutdown task found sleep duration requested:%d millisecs",
                dwSleepDuration
                );
        }
        while (false);

    }
    catch (...)
    {
        SATraceString (
            "Shutdown Task caught unknown exception in GetSleepDuration"
            );
    }
    
    return (dwSleepDuration);

}   //  end of CWorker::IsPowerOffRequired method

//++--------------------------------------------------------------
//
//  Function:   InitTask
//
//  Synopsis:   This is the CWorker private method which
//              is responsible for carrying out the shutdown 
//
//  Arguments:  [in]  ITaskContext*
//
//  Returns:    HRESULT
//
//  History:    MKarki      06/06/2000    Created
//
//  Called By:  OnTaskComplete/OnTaskExecute methods of IApplianceTask 
//              interface
//
//----------------------------------------------------------------
HRESULT
CWorker::InitTask (
    /*[in]*/    ITaskContext *pTaskParameter
    )
{
    CSATraceFunc objTrace ("CWorker::InitTask");

    _ASSERT (pTaskParameter);

    HRESULT hr = S_OK;
    try
    {
        do
        {
            //
            // Sleep for the time requested
            //
            Sleep (GetSleepDuration (pTaskParameter));

            //
            // set the shutdown privilege now
            //
            SetShutdownPrivilege ();
            
            //
            // now do the required operation - shutdown or reboot
            //
	     BOOL bSuccess = InitiateSystemShutdown(
  								NULL,      // this machine
  								NULL,      // no message
  								0,		// no wait 
  								TRUE,     // force app close option
  							       IsRebootRequested (pTaskParameter)  // reboot option
								);
            if (!bSuccess)
            {
                SATraceFailure ("CWorker::InitTask::InitiateSystemShutdown", GetLastError());
                break;
            }
                
            //
            // suceess
            //
        }
        while (false);
    }
    catch  (...)
    {
        SATraceString (
            "Shutdown Task failed while doing shutdown "
            "with unknown exception"
            );
    }

    return (hr);

}   //  end of CWorker::InitTask method


//++--------------------------------------------------------------
//
//  Function:   SetShutdownPrivilege
//
//  Synopsis:   This is the CWorker private method which
//              is responsible for giving process SE_SHUTDOWN_NAME 
//                priviledge
//
//
//  Arguments:  none
//
//  Returns:    bool - yes/now
//
//  History:    MKarki      06/06/2000    Created
//
//  Called By:  OnTaskComplete/OnTaskExecute methods of IApplianceTask 
//              interface
//
//----------------------------------------------------------------

bool
CWorker::SetShutdownPrivilege(void)
{

    CSATraceFunc objTrace ("CWorker::SetShutdownPrivilege");

    bool   bReturn = false;
    HANDLE hProcessToken = NULL;

    do
    {

        //
        // Open the process token
        //
        BOOL  bRetVal = OpenProcessToken(
                           GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                           &hProcessToken
                             );
        if (!bRetVal)
        {
            SATraceFailure (
                "CWorker::SetShutdownPrivilege::OpenProcessToken", GetLastError ()
                );
            break;
        }

        //
        // build the privileges structure
        //
        TOKEN_PRIVILEGES tokPriv;
        tokPriv.PrivilegeCount = 1;
        tokPriv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        //
        // get the LUID of the shutdown privilege
        //
        bRetVal =  LookupPrivilegeValue( 
                                   NULL, 
                                   SE_SHUTDOWN_NAME , 
                                   &tokPriv.Privileges[0].Luid    
                                   );
        if (!bRetVal)                    
        {
            SATraceFailure (
                "CWorker::SetShutdownPriviledge::LookupPrivilegeValue", GetLastError ()
                );
            break;
        }

        //
        // adjust the process token privileges
        //
        bRetVal = AdjustTokenPrivileges(
                                   hProcessToken,    
                                   FALSE,             
                                   &tokPriv,          
                                   0,                
                                   NULL,             
                                   NULL              
                                 );
        if (!bRetVal)                    
        {
            SATraceFailure (
                "CWorker::SetShutdownPriviledge::AdjustTokenPrivileges", GetLastError ()
                );
            break;
        }

        //
        // success
        //
        bRetVal = true;
    }
    while (false);

    //
    // resource cleanup
    //
    if (hProcessToken)
    {
        CloseHandle (hProcessToken);
    }
    
   return bReturn;

}    // end of CWorker::SetShutdownPrivilege method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\usergroup\usersinitialalert\cusersinitialalert.cpp ===
// CUsersInitialAlert.cpp : Implementation of CUsersInitialAlertApp and DLL registration.

#include "stdafx.h"
#include "UsersInitialAlert.h"
#include "CUsersInitialAlert.h"
#include <usermsg.h>

#include <activeds.h>
#include <appliancetask.h>
#include <taskctx.h>
#include <appsrvcs.h>

//
// Alert source information
//
const WCHAR    ALERT_LOG_NAME[] = L"MSSAKitComm";
const WCHAR    ALERT_SOURCE []  = L"usermsg.dll";
                
//
// Various strings used in the program
//
const WCHAR SZ_METHOD_NAME[] = L"MethodName";
const WCHAR SZ_APPLIANCE_INITIALIZATION_TASK []=L"ApplianceInitializationTask";

const WCHAR SZ_WINNT_PATH[]     = L"WinNT://";
const WCHAR SZ_GUESTUSER_NAME[] = L"/Guest";

const WORD  MAXAPPLIANCEDNSNAME = 127;

//////////////////////////////////////////////////////////////////////////////
//
// Function:  CUsersInitialAlert::OnTaskComplete
//
// Synopsis:  
//
// Arguments: pTaskContext - The TaskContext object contains the method name
//                                and parameters as name value pairs
//
// Returns:   HRESULT
//
//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CUsersInitialAlert::OnTaskComplete(IUnknown *pTaskContext, 
                                LONG lTaskResult)
{
    HRESULT hrRet = E_FAIL;
    LPWSTR  pstrApplianceName = NULL;
    VARIANT_BOOL bIsDisabled;

    CComPtr<IADsUser> pUser;

    do
    {
        hrRet = ParseTaskParameter( pTaskContext ); 
        if( FAILED( hrRet ) )
        {
            break;
        }

        if ( lTaskResult == SA_TASK_RESULT_COMMIT )
        {
            if( FALSE == GetApplianceName( &pstrApplianceName ) )
            {
                SATraceString( 
                    "AlertEmail:Initialize GetApplianceName failed" 
                    );
                break;
            }
            
            CComBSTR bstrADSPath;

            bstrADSPath.Append( SZ_WINNT_PATH );
            bstrADSPath += CComBSTR( pstrApplianceName );
            bstrADSPath += CComBSTR( SZ_GUESTUSER_NAME );

            hrRet = ADsGetObject( bstrADSPath, IID_IADsUser, (void**)&pUser );
            if( FAILED( hrRet ) )
            {
                break;
            }

            hrRet = pUser->get_AccountDisabled( &bIsDisabled );
            if( FAILED( hrRet ) )
            {
                break;
            }

            if( !bIsDisabled )
            {
                hrRet = RaiseUsersInitialAlert();
            }
        }
        else
        {
            //
            // Do nothing on Commit failure
            //
            hrRet = S_OK;
        }
    }
    while( false );

    if( pstrApplianceName != NULL )
    {
        ::free( pstrApplianceName );
    }

    return hrRet;
}

///////////////////////////////////////////////////////////////////////////////
//
// Function: CUsersInitialAlert::OnTaskExecute
//
// Synopsis:  This function is the entry point for AppMgr.
//
// Arguments: pTaskContext - The TaskContext object contains the method name
//                                and parameters as name value pairs
//
// Returns:   HRESULT
//
///////////////////////////////////////////////////////////////////////////////
STDMETHODIMP 
CUsersInitialAlert::OnTaskExecute(IUnknown *pTaskContext)
{
    return ParseTaskParameter(pTaskContext);
}

HRESULT 
CUsersInitialAlert::ParseTaskParameter(IUnknown *pTaskContext)
{
    CComVariant varValue;
     CComPtr<ITaskContext> pTaskParameter;

    HRESULT hrRet = E_INVALIDARG;

    try
    {
        do
        {
            if(NULL == pTaskContext)
            {
                break;
            }
            
            hrRet = pTaskContext->QueryInterface(IID_ITaskContext,
                                              (void **)&pTaskParameter);
            if(FAILED(hrRet))
            {
                break;
            }

            hrRet = pTaskParameter->GetParameter(
                                            CComBSTR(SZ_METHOD_NAME),
                                            &varValue
                                            );
            if ( FAILED( hrRet ) )
            {
                break;
            }

            if ( V_VT( &varValue ) != VT_BSTR )
            {
                break;
            }

            if ( lstrcmp( V_BSTR(&varValue), SZ_APPLIANCE_INITIALIZATION_TASK ) == 0 )
            {
                hrRet=S_OK;
            }
        }
        while(false);
    }
    catch(...)
    {
        hrRet=E_FAIL;
    }

    return hrRet;
}

HRESULT 
CUsersInitialAlert::RaiseUsersInitialAlert()
{
    DWORD             dwAlertType = SA_ALERT_TYPE_ATTENTION;
    DWORD            dwAlertId = L_GUESTUSER_ENABLED;
    HRESULT            hrRet = E_FAIL;
    CComVariant     varReplacementStrings;
    CComVariant     varRawData;
    LONG             lCookie;

    CComPtr<IApplianceServices>    pAppSrvcs;

    try
    {
        do
        {
            hrRet = CoCreateInstance(CLSID_ApplianceServices,
                                    NULL,
                                    CLSCTX_INPROC_SERVER,
                                    IID_IApplianceServices,
                                    (void**)&pAppSrvcs);
            if (FAILED(hrRet))
            {
                break;
            }

            //
            // Initialize() is called prior to using other component services.
            //Performscomponent initialization operations.
            //
            hrRet = pAppSrvcs->Initialize(); 
            if (FAILED(hrRet))
            {
                break;
            }

            hrRet = pAppSrvcs->RaiseAlert(
                                        dwAlertType, 
                                        dwAlertId,
                                        CComBSTR(ALERT_LOG_NAME), 
                                        CComBSTR(ALERT_SOURCE), 
                                        SA_ALERT_DURATION_ETERNAL,
                                        &varReplacementStrings,    
                                        &varRawData,      
                                        &lCookie
                                        );
        }
        while(false);
    }
    catch(...)
    {
        hrRet=E_FAIL;
    }

    return hrRet;
}

BOOL
CUsersInitialAlert::GetApplianceName(
    LPWSTR* pstrComputerName
    )
{
    BOOL    bReturn = FALSE;
    DWORD   dwSize = 0;
    DWORD   dwCount = 1;

    do
    {
        if( *pstrComputerName != NULL )
        {
            ::free( *pstrComputerName );
        }
        
        dwSize = MAXAPPLIANCEDNSNAME * dwCount;

        *pstrComputerName = ( LPWSTR ) ::malloc( sizeof(WCHAR) * dwSize );
        if( *pstrComputerName == NULL )
        {
            SATraceString( 
                "AlertEmail:GetApplianceName malloc failed" 
                );
            break;
        }

        //
        // Get local computer name.
        //
        bReturn = ::GetComputerNameEx( 
                                ComputerNameDnsFullyQualified, 
                                *pstrComputerName,
                                &dwSize                
                                );

        dwCount <<= 1;
    }
    while( !bReturn && 
           ERROR_MORE_DATA == ::GetLastError() &&
           dwCount < 8 
           );

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\usergroup\usersinitialalert\cusersinitialalert.h ===
// CUsersInitialAlert.h: Definition of the UsersInitialAlert class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_CUSERSINITIALALERT_H__FDCDC88B_1549_4341_BA20_54D6B2D657A5__INCLUDED_)
#define AFX_CUSERSINITIALALERT_H__FDCDC88B_1549_4341_BA20_54D6B2D657A5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols
#include "taskctx.h"
#include "comdef.h"

/////////////////////////////////////////////////////////////////////////////
// UsersInitialAlert

class ATL_NO_VTABLE CUsersInitialAlert : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CUsersInitialAlert,&CLSID_UsersInitialAlert>,
    public IDispatchImpl<IApplianceTask, &IID_IApplianceTask, &LIBID_USERSINITIALALERTLib> 
{
public:
    CUsersInitialAlert() {}
BEGIN_COM_MAP(CUsersInitialAlert)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IApplianceTask)
END_COM_MAP()

DECLARE_REGISTRY_RESOURCEID(IDR_UsersInitialAlert)

DECLARE_PROTECT_FINAL_CONSTRUCT()
// 
public:
    //
    // IApplianceTask
    //
    STDMETHOD(OnTaskExecute)(
                     /*[in]*/ IUnknown* pTaskContext
                            );

    STDMETHOD(OnTaskComplete)(
                      /*[in]*/ IUnknown* pTaskContext, 
                      /*[in]*/ LONG      lTaskResult
                             );    

private:

    HRESULT ParseTaskParameter(
                      /*[in]*/ IUnknown *pTaskParameter
                               );
    
    HRESULT RaiseUsersInitialAlert();
    
    BOOL GetApplianceName(
                     /*[in]*/ LPWSTR* pstrComputerName
                          );

};

#endif // !defined(AFX_CUSERSINITIALALERT_H__FDCDC88B_1549_4341_BA20_54D6B2D657A5__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\usergroup\usersinitialalert\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by UsersInitialAlert.rc
//
#define IDS_PROJNAME                    100
#define IDS_USERSINITIALALERT_DESC      101
#define IDR_UsersInitialAlert           102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\usergroup\usersinitialalert\usersinitialalert.cpp ===
// UsersInitialAlert.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f UsersInitialAlertps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "UsersInitialAlert.h"

#include "UsersInitialAlert_i.c"
#include "CUsersInitialAlert.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_UsersInitialAlert, CUsersInitialAlert)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\plugins\usergroup\usersinitialalert\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__26CEEEB0_A514_4520_AF4E_E5C03CDC5BAF__INCLUDED_)
#define AFX_STDAFX_H__26CEEEB0_A514_4520_AF4E_E5C03CDC5BAF__INCLUDED_

#pragma once

#define _ATL_APARTMENT_THREADED
#undef _ATL_NO_DEBUG_CRT

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

#include <satrace.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__26CEEEB0_A514_4520_AF4E_E5C03CDC5BAF__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\setup\sasetupca\dll.cpp ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    dll.cpp

Abstract:

    Routines that interface this dll to the system, such as
    the dll entry point.

Author:

    Jaime Sasson (jaimes) 12-Apr-2002

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop



BOOL
WINAPI
DllMain(
    HINSTANCE ModuleHandle,
    DWORD     Reason,
    PVOID     Reserved
    )

/*++

Routine Description:

    Dll entry point.

Arguments:

Return Value:

--*/

{
    switch(Reason) {

    case DLL_PROCESS_ATTACH:
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\setup\sasetupca\precomp.h ===
#include "sasetupca.h"

#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\setup\sasetupca\sasetupca.h ===
#include <windows.h>

#ifdef  __cplusplus
extern "C" {
    #include <stdio.h>
    }   /* ... extern "C" */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\setup\sasetupca\sasetupca.cpp ===
//---------------------------------------------------------------
//
//  File:       SASetupCA.cpp
//
//  Synopsis:   This is the implementation of the custom actions in Server Appliance
//				setup.    
//
//
//  History:     03/29/2001 AlpOn  Created 
//
//    Copyright (C) 2000-2001 Microsoft Corporation
//    All rights reserved.
//


// SASetupCA.cpp : Defines the entry point for the DLL application.
//


#include "stdafx.h"
#include <winsvc.h>

const char REG_APPEND[]="append";

//
//private methods declared here
//
HRESULT
StartNTService (
		/*[in]*/	PSTR	pwszServiceName
		);

HRESULT
StopNTService (
		/*[in]*/	PSTR	pwszServiceName
		);

//++---------------------------------------------------------------------------
//
//  Function:   ChangeRegistry
//
//  Synopsis:   Function that gets called by SAkit setup to do custom operations 
//				on registry
//  Arguments:  szRegKeyName,  - name of the regkey to be opened
//				szRegValueName - name of the value to be operated on
//				szRegAction    - desired action on the registry (e.g. append)
//				szKeyValue     - new value to be used for the reg key value during the operation
				
//  Returns:    HRESULT - success/failure
//
//  History:    AlpOn      Created     03/29/01
//
//  Called By;  Server Appliance Kit setup
//
//-----------------------------------------------------------------------------

STDAPI ChangeRegistry(char *szRegKeyName, 
					  char *szRegValueName,
					  char *szRegAction, 
					  char *szKeyValue)
{
	
	HRESULT hReturn=S_OK;
    DWORD dwSize=0;
    CRegKey hKey;
	LONG lRes=0;
	char *szKeyValueRead=NULL;
	char *szRegKeyNewValue=NULL;
	
	SATracePrintf("ChangeRegistry called with: szRegKeyName:%s,szRegValueName:%s,szRegAction:%s,szKeyValue:%s",
		szRegKeyName,szRegValueName,szRegAction,szKeyValue);

    do{
		lRes=hKey.Open(HKEY_LOCAL_MACHINE,
					   szRegKeyName,
					   KEY_ALL_ACCESS );

		if(lRes!=ERROR_SUCCESS)
		{
			SATracePrintf("Regkey open - hKey.Open failed , lRes= %x Key=%s", lRes, szRegKeyName);
			hReturn=E_FAIL;
			break;
		}

		//open registry key, get size and read the value
        lRes=hKey.QueryValue(NULL,szRegValueName,&dwSize);
		szKeyValueRead=new char[dwSize];
    	lRes=hKey.QueryValue(szKeyValueRead,szRegValueName,&dwSize);
    	
		if(lRes!=ERROR_SUCCESS)
    	{
    	    SATracePrintf("Unable to query regkey hKey.QueryValue failed lRes= %x valuename= %s",lRes, szKeyValueRead);
			hReturn=E_FAIL;
      		break;
    	}

		if(0==strcmpi(szRegAction,REG_APPEND))
		{
			SATracePrintf("ChangeRegistry called with append param");
			int size=(strlen(szKeyValueRead) + strlen(szKeyValue))+2;
			szRegKeyNewValue=new char[size];
			szRegKeyNewValue[0]='\0';
			strcat(szRegKeyNewValue,szKeyValueRead);
			strcat(szRegKeyNewValue," ");
			strcat(szRegKeyNewValue,szKeyValue);
			lRes=hKey.SetValue(szRegKeyNewValue, szRegValueName);

			if(lRes!=ERROR_SUCCESS)
    		{
    			SATracePrintf("Unable set regkey hKey.SetValue failed lRes= %x",lRes);
				hReturn=E_FAIL;
      			break;
    		}
		}


	}while(false);

	if(hKey.m_hKey)
	{
		hKey.Close();
	}

	delete []szKeyValueRead;
	delete []szRegKeyNewValue;
	return hReturn;
}


BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    return TRUE;
}


//++---------------------------------------------------------------------------
//
//  Function:   ConfigureService
//
//  Synopsis:   API that gets called by SAkit setup to configure an
//				NT Service
//  Arguments:  
//				[in] PSTR	-	Service Name (preferably short name)
//				[in] DWORD	-   Config Type (start or stop supported)
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Created     04/05/2001
//
//  Called By;  Server Appliance Kit setup
//
//-----------------------------------------------------------------------------

STDAPI ConfigureService (
		/*[in]*/	PSTR	pszServiceName,
		/*[in]*/	DWORD   dwControlCode
		)
{
	HRESULT hr = S_OK;

	CSATraceFunc objTraceFunc  ("ConfigureService");

	try
	{
	
		if (NULL == pszServiceName)
		{
			SATraceString ("SASetup-ConfigureService passed in invalid argument");
			hr = E_INVALIDARG;
			return (hr);
		}

		//
		// carry out the required action
		//
		switch (dwControlCode)
		{
		case 0:
			//
			// stop NT Service
			//
			hr = StopNTService (pszServiceName);
			break;
		
		case 1:
			//
			// start NT Service
			//
			hr = StartNTService (pszServiceName);
			break;
		default:
			//
			// unknown control code passed in
			//
			SATracePrintf (
				"SASetup-ConfigureService passed in incorrect control code:%d",
				dwControlCode
				);
			hr = E_FAIL;
			break;
		}
	}
	catch (...)
	{
		SATraceString ("SASetup-ConfigureService caught unhandled exception");
		hr = E_FAIL;
	}
	
	return (hr);

}	//	end of ConfigureService API

//++---------------------------------------------------------------------------
//
//  Function:   StartNTService
//
//  Synopsis:   Method that Starts an NT Service
//  Arguments:  
//				[in] PSTR	-	Service Name (preferably short name)
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Created     04/05/2001
//
//  Called By;  ConfigureService () API
//
//-----------------------------------------------------------------------------
HRESULT
StartNTService (
		/*[in]*/	PSTR	pszServiceName
		) 
{
	CSATraceFunc objTraceFunc ("StartNTService");
	
	HRESULT hr = S_OK;

	SC_HANDLE	hServiceManager = NULL;
	SC_HANDLE 	hService = NULL;

	do
	{
		if (NULL == pszServiceName)
		{
			SATraceString ("SASetup-StartNTService passed in invalid argument");
			hr = E_INVALIDARG;
			break;
		}

		//
		// open the Service Control Manager
		//
		hServiceManager = OpenSCManager (
									NULL, 
									NULL, 
									SC_MANAGER_ALL_ACCESS
									);
		if (NULL == hServiceManager)
		{
			SATraceFailure ("SASetup-StartNTService::OpenSCManager", GetLastError ());
			hr = E_FAIL;
			break;
		}

		//
		// open the NT Service
		//
		hService = OpenService (
						hServiceManager, 
						pszServiceName, 
						SERVICE_ALL_ACCESS
						);
		if (NULL == hService)
		{
			SATraceFailure ("SASetup-StartNTService::OpenService", GetLastError ());
			hr = E_FAIL;
			break;
		}

		//
		// start the service now
		//
		BOOL bRetVal = StartService (
								hService, 
								0, 
								NULL
								);
		if (FALSE == bRetVal) 
		{
			DWORD dwError = GetLastError ();
			//
			// its OK if the service is already running
			//
			if (ERROR_SERVICE_ALREADY_RUNNING != dwError)
			{
				SATraceFailure ("SASetup-StartNTService::StartService", dwError);
				hr = E_FAIL;
				break;
			}
		}
	}
	while (false);
	
	//
	// cleanup now
	//

	if (hService)
	{
		CloseServiceHandle(hService);
	}

	if (hServiceManager)
	{
		CloseServiceHandle(hServiceManager);
	}


	return (hr);

}	//	end of StartNTService method


//++---------------------------------------------------------------------------
//
//  Function:   StopNTService
//
//  Synopsis:   Method that stops an NT Service
//  Arguments:  
//				[in] PWCHAR	-	Service Name (preferably short name)
//
//  Returns:    HRESULT - success/failure
//
//  History:    MKarki      Created     04/05/2001
//
//  Called By;  ConfigureService () API
//
//-----------------------------------------------------------------------------
HRESULT
StopNTService (
		/*[in]*/	PSTR	pszServiceName
		) 
{
	CSATraceFunc objTraceFunc ("StopNTService");

	HRESULT hr = S_OK;

	SC_HANDLE	hServiceManager = NULL;
	SC_HANDLE 	hService = NULL;

	do
	{
		if (NULL == pszServiceName)
		{
			SATraceString ("SASetup-StopNTService passed in invalid argument");
			hr = E_INVALIDARG;
			break;
		}

		//
		// open the Service Control Manager
		//
		hServiceManager = OpenSCManager (
									NULL, 
									NULL, 
									SC_MANAGER_ALL_ACCESS
									);
		if (NULL == hServiceManager)
		{
			SATraceFailure ("SASetup-StopNTService::OpenSCManager", GetLastError ());
			hr = E_FAIL;
			break;
		}

		//
		// open the NT Service
		//
		hService = OpenService (
						hServiceManager, 
						pszServiceName, 
						SERVICE_ALL_ACCESS
						);
		if (NULL == hService)
		{
			SATraceFailure ("SASetup-StopNTService::OpenService", GetLastError ());
			hr = E_FAIL;
			break;
		}

		SERVICE_STATUS ServiceStatus;
		//
		// stop the service now
		//
		BOOL bRetVal = ControlService (
								hService, 
								SERVICE_CONTROL_STOP, 
								&ServiceStatus
								);
		if (FALSE == bRetVal) 
		{
			DWORD dwError = GetLastError ();
			//
			// its OK if the service is already stopped
			//
			if (ERROR_SERVICE_NOT_ACTIVE != dwError)
			{
				SATraceFailure ("SASetup-StopNTService::ControlService", dwError);
				hr = E_FAIL;
				break;
			}
		}
	}
	while (false);
	
	//
	// cleanup now
	//

	if (hService)
	{
		CloseServiceHandle(hService);
	}

	if (hServiceManager)
	{
		CloseServiceHandle(hServiceManager);
	}


	return (hr);

}	//	end of StopNTService method
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\setup\sasetupca\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__E140DD13_934B_4A7C_86AE_43C0EC7F851E__INCLUDED_)
#define AFX_STDAFX_H__E140DD13_934B_4A7C_86AE_43C0EC7F851E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here

#include <windows.h>
#include <atlbase.h>
#include <atlconv.h>
#include <objbase.h>
#include <satrace.h>
#include <string.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__E140DD13_934B_4A7C_86AE_43C0EC7F851E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\setup\sasetupca\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	SASetupCA.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sanorun\sanorun.h ===
// The following ifdef block is the standard way of creating macros which make exporting 
// from a DLL simpler. All files within this DLL are compiled with the SANORUN_EXPORTS
// symbol defined on the command line. this symbol should not be defined on any project
// that uses this DLL. This way any other project whose source files include this file see 
// SANORUN_API functions as being imported from a DLL, wheras this DLL sees symbols
// defined with this macro as being exported.
#define SANORUN_API __declspec(dllexport)


SANORUN_API DWORD OcEntry(
	LPCVOID ComponentId,//[in]
	LPCVOID SubcomponentId,//[in]
	UINT Function,//[in]
	UINT Param1,//[in]
	PVOID Param2//[in,out]
	);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sanorun\sanorun.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  sanorun.cpp
//
//  Description:
//
//      If Setup is running unattended, look in the answer file to see if
//      ServerWelcome is in the GuiUnattended section.  
//      Delete the appropriate Reg value if "ServerWelcome = No".
//
//      On the Blade SKU, this will delete SaInstall.exe from the Run key
//      so that the SAK will not be installed by default.
//
//  Header File:
//      sanorun.h
//
//  History:
//      travisn   18-JAN-2002    Created
//////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "sanorun.h"
#include "setupapi.h"
#include "ocmanage.h"


//
// Variable that stores between setup phases whether or not 
// ServerWelcome = No.  This is set during OC_INIT_COMPONENT and evaluated
// during OC_COMPLETE_INSTALLATION.
//
BOOL g_bServerWelcomeIsOff = FALSE;

//
// The path to the Run key
//
LPCWSTR RUN_KEY = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run";

//
// The value where sainstall.exe is found in the Run key
//
LPCWSTR SAINSTALL_VALUE = L"SAInstall";

//
// Section in the answer file to find ServerWelcome
//
LPCWSTR GUI_UNATTEND = L"GuiUnattended";

//
// Key that defines ServerWelcome
//
LPCWSTR SERVER_WELCOME = L"ServerWelcome";

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DllMain
//
//  Description:
//     Entry point to load the DLL
//--
//////////////////////////////////////////////////////////////////////////////
BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
					 )
{
    switch (ul_reason_for_call)
	{
		case DLL_PROCESS_ATTACH:
		case DLL_THREAD_ATTACH:
		case DLL_THREAD_DETACH:
		case DLL_PROCESS_DETACH:
			break;
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  DeleteRegValue
//
//  Description:
//     Deletes the given value wsValue from the given key wsKey in HKLM.
//
//  Returns:
//     HRESULT indicating if the value was successfully deleted.  If it did
//     not exist, E_FAIL is returned.
//
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT DeleteRegValue(LPCWSTR wsKey, LPCWSTR wsValue)
{

    //Open the Run key
    HKEY hOpenKey;
    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, wsKey, 0, KEY_WRITE, &hOpenKey) != ERROR_SUCCESS)
    {
        //Could not open the Run key
        return E_FAIL;
    }

    //Delete the value
    LRESULT lRes;
    lRes = RegDeleteValueW(hOpenKey, wsValue); 
    RegCloseKey(hOpenKey);
    
    if (lRes == ERROR_SUCCESS)
    {
        //Deleted the SAInstall value from the Run key
        return S_OK;
    }
    else
    {
        //SAInstall value not found--Could not delete from Run key
       return E_FAIL;
    }

}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  ServerWelcomeIsOff
//
//  Description:
//      Attempts to open the answer file and find if "ServerWelcome = No"
//      is present.
// 
//  Parameter:
//      pInitComponent [in]  Pointer to information about the setup
//
//  Returns:
//      If "ServerWelcome = No" is found, returns TRUE
//      Otherwise, returns FALSE (ie. the answer file cannot be opened, 
//      "ServerWelcome = Anything Else", or ServerWelcome is not found).
//
//--
//////////////////////////////////////////////////////////////////////////////
BOOL ServerWelcomeIsOff(PSETUP_INIT_COMPONENT pInitComponent)
{
    //By default, the ServerWelcome is on
    BOOL bWelcomeOff = FALSE;

    do 
    {
        //
        // Get a handle to the answer file
        //
        HINF hUnattendFile = pInitComponent->HelperRoutines.GetInfHandle(
                                INFINDEX_UNATTENDED, 
                                pInitComponent->HelperRoutines.OcManagerContext
                                );

        if (hUnattendFile == INVALID_HANDLE_VALUE || hUnattendFile == NULL)
        {
            break;
        }

        //
        // Retrieve the ServerWelcome key from the answer file
        //
        INFCONTEXT Context;
        if (!SetupFindFirstLine(hUnattendFile, GUI_UNATTEND, SERVER_WELCOME, &Context))
            break;

        //
        // Retrieve the value for the ServerWelcome key
        //
        WCHAR wsValue[MAX_PATH];
        if (!SetupGetStringField(&Context, 1, wsValue, MAX_PATH, NULL))
            break;

        //
        // Check to see if ServerWelcome = No
        //
        if (_wcsicmp(wsValue, L"No") != 0)
            break;

        //
        // ServerWelcome = No, so return true
        //
        bWelcomeOff = TRUE;

    } while (FALSE);

    return bWelcomeOff;
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  OcEntry
//
//  Description:
//      Entry point that Setup calls to allow this component to initialize
//      itself.  The only stage where this component takes action is
//      during OC_INIT_COMPONENT.  If the setup is unattended, remove
//      SaInstall.exe from the Run key if "ServerWelcome = No" is found
//      in the answer file.
//
//  Returns:
//      DWORD depending on the stage.  Usually 0 indicates success
//
//--
//////////////////////////////////////////////////////////////////////////////
SANORUN_API DWORD OcEntry(
	IN LPCVOID ComponentId,
	IN LPCVOID SubcomponentId,
	IN UINT Function,
	IN UINT Param1,
	IN OUT PVOID Param2
	)
{
    DWORD rValue = 0;//Default return signaling success
    try 
    {
        //Declare variables used in the switch statement
        PSETUP_INIT_COMPONENT pInitComponent = NULL;

        switch (Function)
        {
        case OC_PREINITIALIZE:
            rValue = OCFLAG_UNICODE;
            break;

        case OC_INIT_COMPONENT:
            //
            // OC_INIT_COMPONENT is where we detect if ServerWelcome = No,
            // which will be used in a later phase of setup.
            // Param2 contains all the information we need from setup
            //

            pInitComponent = (PSETUP_INIT_COMPONENT)Param2;
            if (pInitComponent == NULL)
            {
                break;
            }
            
            //
            // Check if the OperationFlags include SETUPOP_BATCH, which means that
            // the unattendedFile is valid
            //
            if (((pInitComponent -> SetupData.OperationFlags) & SETUPOP_BATCH) == 0)
            {
                break;
            }

            //
            // If Setup is running unattended, look in the answer file to see if
            // ServerWelcome is in the GuiUnattended section.  
            //
            if (ServerWelcomeIsOff(pInitComponent))
            {
                g_bServerWelcomeIsOff = TRUE;
            }

            break;

        case OC_SET_LANGUAGE:
            rValue = TRUE;//Supports all languages
            break;

        case OC_CALC_DISK_SPACE:
        case OC_QUEUE_FILE_OPS:
        case OC_ABOUT_TO_COMMIT_QUEUE:
            rValue = NO_ERROR;
            break;

        case OC_COMPLETE_INSTALLATION:
            //
            // Perform the work corresponding to ServerWelcome = No.
            // Remove SaInstall.exe from the Run key on the Blade SKU.
            //
            if (g_bServerWelcomeIsOff)
            {
                HRESULT hr = DeleteRegValue(RUN_KEY, SAINSTALL_VALUE);
            }
            rValue = NO_ERROR;
            break;

        default:
            //case OC_QUERY_IMAGE:
            //case OC_REQUEST_PAGES:
            //case OC_QUERY_SKIP_PAGE:
            //case OC_QUERY_CHANGE_SEL_STATE:
            //case OC_QUERY_STEP_COUNT:
            //case OC_CLEANUP:
            //case OC_NEED_MEDIA:
            break;

        }
    }
    catch (...)
    {
        //Unexpected Exception
    }

    return rValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sanorun\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	sanorun.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sawebinstall\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	SAWebInstall.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\setup\sasetupca\websiteroot.cpp ===
/*++

Copyright (c) 2002 Microsoft Corporation

Module Name:

    wsroot.cpp

Abstract:

    This module contains the functions that create a default path for web sites root.

Author:

    Jaime Sasson (jaimes) 12-apr-2002

Revision History:


--*/

#include "precomp.h"
#pragma hdrstop
#include <msi.h>

//
//  Global strings (global to this module)
//
PTSTR   szServerAppliancePath = TEXT("Software\\Microsoft\\ServerAppliance");
PTSTR   szWebSiteRoot = TEXT("WebSiteRoot");


DWORD __stdcall
RemoveDefaultWebSiteRoot(MSIHANDLE hInstall
    )

/*++

Routine Description:

    Routine to delete the default path for the web sites root from the registry, under
    HKLM\SOFTWARE\Microsoft\ServerAppliance.

Arguments:

    Handle to the msi, which is not used.


Return value:

    Win32 error indicating outcome.

--*/
{
    DWORD   Error;
    HKEY    Key;

    //
    //  Open the ServerAppliance key
    //
    Error = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                          szServerAppliancePath,
                          0,
                          KEY_SET_VALUE,
                          &Key );

    if( Error == ERROR_SUCCESS ) {
        Error = RegDeleteValue( Key,
                                szWebSiteRoot );
        if( Error != ERROR_SUCCESS ) {
#if 0
            printf("RegDeleteValue() failed. Error = %d", Error);
#endif
        }
        RegCloseKey( Key );

    } else {
#if 0
        printf("RegOpenKeyEx() failed. Error = %d", Error);
#endif
    }

    return( Error );
}


DWORD
SaveDefaultRoot(
    IN TCHAR DriveLetter
    )

/*++

Routine Description:

    Routine to save the default path for the web sites root in the registry, under
    HKLM\SOFTWARE\Microsoft\ServerAppliance.

Arguments:

    Drive letter - Default drive where the web sites are created.


Return value:

    Win32 error indicating outcome.

--*/
{
    DWORD   Error;
    HKEY    Key;
    TCHAR   RootPath[] = TEXT("?:\\Websites");

    if( !DriveLetter ) {
        return( ERROR_INVALID_PARAMETER );
    }

    RootPath[0] = DriveLetter;

    //
    //  Open the ServerAppliance key if it doesn't exist yet
    //
    Error = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                            szServerAppliancePath,
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_SET_VALUE,
                            NULL,
                            &Key,
                            NULL );

    if( Error == ERROR_SUCCESS ) {
        Error = RegSetValueEx( Key,
                               szWebSiteRoot,
                               0,
                               REG_SZ,
                               (PBYTE)RootPath,
                               (lstrlen( RootPath ) + 1) * sizeof(TCHAR) );
        if( Error != ERROR_SUCCESS ) {
#if 0
            printf("RegSetValueEx() failed. Error = %d", Error);
#endif
        }
        RegCloseKey( Key );

    } else {
#if 0
        printf("RegCreateKeyEx() failed. Error = %d", Error);
#endif
    }

    return( Error );
}


BOOL
IsDriveNTFS(
    IN TCHAR Drive
    )

/*++

Routine Description:

    Determine whether a drive is formatted with the NTFS.


Arguments:

    Drive - supplies drive letter to check.

Return Value:

    Boolean value indicating whether the drive is NTFS.

--*/

{
    TCHAR   DriveName[] = TEXT("?:\\");
    TCHAR   Filesystem[256];
    TCHAR   VolumeName[MAX_PATH];
    DWORD   SerialNumber;
    DWORD   MaxComponent;
    DWORD   Flags;
    BOOL    b;
    PTSTR   szNtfs = TEXT("NTFS");

    DriveName[0] = Drive;

    b = GetVolumeInformation( DriveName,
                              VolumeName,
                              sizeof(VolumeName) / sizeof(TCHAR),
                              &SerialNumber,
                              &MaxComponent,
                              &Flags,
                              Filesystem,
                              sizeof(Filesystem) / sizeof(TCHAR) );

    if(!b || !lstrcmpi(Filesystem,szNtfs)) {
        return( TRUE );
    }

    return( FALSE );
}


DWORD __stdcall
SetupDefaultWebSiteRoot(MSIHANDLE hInstall
    )

/*++

Routine Description:

    This function creates a default path for websites, and saves it in the registry.


Arguments:

    Handle to the msi, which is not used.

Return Value:

    Win32 error indicating the outcome of the operation.

--*/
{
    DWORD   Error;
    TCHAR   i;
    TCHAR   DriveName[] = TEXT("?:\\");
    TCHAR   TargetDriveLetter = TEXT('\0');
    TCHAR   WinDir[ MAX_PATH + 1 ];
    UINT    n;

    //
    //  Find out where the OS is installed.
    //  If GetWindowsDirectory fails, the WinDir will be an empty string.
    //
    WinDir[0] = TEXT('\0');
    n = GetWindowsDirectory( WinDir, sizeof(WinDir)/sizeof(TCHAR) );

    //
    //  Find an NTFS partition on a non-removable drive that doesn't contain the OS
    //
    for(i = TEXT('A'); i <= TEXT('Z'); i++) {
        DriveName[0] = i;
        if( (GetDriveType(DriveName) == DRIVE_FIXED) &&
            (WinDir[0] != i) &&
            IsDriveNTFS(i) ) {
            TargetDriveLetter = i;
            break;
        }
    }

    if( !TargetDriveLetter ) {
        //
        //  If we were unable to find such a drive, then take the boot partition as the default drive.
        //  But if we failed to retrieve where the OS is installed, then assume drive C.
        //
        TargetDriveLetter = (WinDir[0])? WinDir[0] : TEXT('C');
    }
    Error = SaveDefaultRoot(TargetDriveLetter);

#if 0
    if( Error != ERROR_SUCCESS ) {
        printf("SaveDefaultDriveLetter() failed. Error = %d \n", Error);
    }
    printf("Drive selected is %lc \n", TargetDriveLetter);
#endif
    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sawebinstall\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__0599CE33_6217_43B6_9A8B_1AF91CD515A8__INCLUDED_)
#define AFX_STDAFX_H__0599CE33_6217_43B6_9A8B_1AF91CD515A8__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include <stdio.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__0599CE33_6217_43B6_9A8B_1AF91CD515A8__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sawebinstall\resource.h ===
#define IDS_SHORTCUT_NAME         106
#define IDS_SHORTCUT_DESCRIPTION  107
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sak\setup\sasetupca\shortcut.cpp ===
//#--------------------------------------------------------------
//
//  File:        shortcut.cpp
//
//  Synopsis:   Implementation the custom action to add/remove the 
//                   "Remote Administration Tools" to/from the start menu
//
//    Copyright (C) Microsoft Corporation.  All rights reserved.
//
//----------------------------------------------------------------
#include "precomp.h"
#include <satrace.h>
#include <msi.h>
#include <string>
#include <shlobj.h>
#include <shellapi.h>
#include <shortcutresource.h>

#undef _ATL_NO_DEBUG_CRT
#include <atlbase.h>

//
// Web Interface for Remote Administration
// Manage a Web or file server using a Web browser interface
//

using namespace std;

//
// Constants for creating a shortcut to the Administration site
//
WCHAR SHORTCUT_EXT [] = L".lnk";

WCHAR SECURELAUNCH_PATH [] = L"\\ServerAppliance\\SecureLaunch.vbs";

WCHAR WSCRIPT_PATH[]  = L"\\wscript.exe";

//
// note - the following is just a file name and does not need to be localized
//
WCHAR SHORTCUT_FILE_NAME [] = L"Remote Administration Tools";

WCHAR RESOURCE_FILE_NAME [] = L"\\sainstall.dll";

WCHAR SYSTEM_32_PATH [] = L"%systemroot%\\system32";
//++--------------------------------------------------------------
//
//  Function:   CreateSAKShortcut
//
//  Synopsis:   This is export function to add "Remote Administration Tools" shortcut
//                   to the start menu
//
//  Arguments: 
//              [in]    HANDLE - handle passed in by MSI
//
//  Returns:    DWORD - success/failure
//
//  History:    MKarki      Created    12/04/2002
//
//----------------------------------------------------------------
DWORD __stdcall 
CreateSAKShortcut (
        /*[in]*/    MSIHANDLE hInstall
        )
{
    CSATraceFunc objTraceFunc ("CreateSAKShortCut");
    
    DWORD dwRetVal = -1; 

    do
    {
          
        //
        // Get the path to %System32%
        //
        WCHAR pwsSystemPath[MAX_PATH+1];
        HRESULT hr = SHGetFolderPath(
                                NULL, 
                                CSIDL_SYSTEM, 
                                NULL, 
                                SHGFP_TYPE_CURRENT, 
                                pwsSystemPath);
        if (FAILED(hr))
        {
            SATracePrintf ("SHGetFolderPath failed getting the System32 path with error:%x", hr);
            OutputDebugString (L"SHGetFolderPath failed getting the System32 path with error\n");
            break;
        }

        //
        // Construct the path to wscript.exe
        //
        wstring wsWScriptPath(pwsSystemPath);
        wsWScriptPath += WSCRIPT_PATH;
        
        SATracePrintf ("WScript Path = %ws", wsWScriptPath.data());
      

        //
        // Construct the path to SecureLaunch.vbs
        //
        wstring wsLaunchPath(pwsSystemPath);
        wsLaunchPath += SECURELAUNCH_PATH;

        SATracePrintf ("Secure Launch Path = %ws", wsLaunchPath.data());

        //
        //Construct the path where the shortcut will be stored in the Startup folder
        //

        //
        //Get the path to the Administrators Tools folder
        //
        WCHAR pwsStartMenuPath[MAX_PATH+1];
        hr = SHGetFolderPath(NULL, 
                             CSIDL_COMMON_ADMINTOOLS, 
                             NULL, 
                             SHGFP_TYPE_CURRENT, 
                             pwsStartMenuPath);
        if (FAILED(hr))
        {
            SATracePrintf ("SHGetFolderPath failed getting the Start Menu path with error:%x", hr);
            OutputDebugString (L"SHGetFolderPath failed getting the System32 path with error");
            break;
        }

        wstring wsPathLink(pwsStartMenuPath);
        wsPathLink += L"\\";
        wsPathLink += SHORTCUT_FILE_NAME;
        wsPathLink += SHORTCUT_EXT;

        SATracePrintf(" PathLink = %ws", wsPathLink.data());

        //
        // Now that the shortcut information has been constructed, 
        // create the shortcut object.
        //
        CComPtr <IShellLink> psl;

        //
        // Get a pointer to the IShellLink interface. 
        //
        hr = CoCreateInstance (
                            CLSID_ShellLink,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IShellLink,
                            (LPVOID *)&psl);

        if (FAILED(hr)) 
        { 
            SATracePrintf ("ShellLink CoCreateInstance Failed with error:%x",hr);
            OutputDebugString (L"ShellLink CoCreateInstance Failed");
            break;
        }

        WCHAR wszShortcutResourceID [MAX_PATH +1];
        _itow (IDS_SAK_SHORTCUT_DESCRIPTION, wszShortcutResourceID, 10);

        wstring wsShortcutDescription  (L"@");
        wsShortcutDescription += pwsSystemPath;
        wsShortcutDescription += RESOURCE_FILE_NAME;
        wsShortcutDescription += L",-";
        wsShortcutDescription += wszShortcutResourceID;

        SATracePrintf ("ShortCut Description:%ws", wsShortcutDescription.data ());
        
        //
        // Set the information for the shortcut 
        //
        psl->SetPath(wsWScriptPath.data()); 
        psl->SetArguments(wsLaunchPath.data()); 
        psl->SetDescription(wsShortcutDescription.data ());

        //
        // the following really doesn't get the icon - because there is no icon in this DLL
        // it is too late to add an icon for .NET Server
        //
        psl->SetIconLocation(L"sasetupca.dll", 0);

        SATraceString ("Saving shortcut to file");

        //
        // Query IShellLink for the IPersistFile interface for saving the 
        // shortcut in persistent storage. 
        //
        CComPtr <IPersistFile> ppf;
        hr = psl->QueryInterface(
                                IID_IPersistFile, 
                                (LPVOID*)&ppf
                                ); 
        if (FAILED(hr)) 
        {
            SATracePrintf ("QueryInterface failed for IPersistFile with error:%x",hr);
            OutputDebugString (L"QueryInterface failed for IPersistFile\n");
            break;
        }

        SATraceString ("Pointer to IPersistFile retrieved");

        //
        // Save the link by calling IPersistFile::Save. 
        //
        hr = ppf->Save(wsPathLink.data(), TRUE); 
        if (FAILED(hr))
        {
            SATracePrintf  ("Failed to save shortcut with error:%x", hr);
            OutputDebugString (L"Failed to save shortcut\n");
            break;
        }

        SATraceString ("Successfully saved shortcut");
        OutputDebugString (L"Successfully saved shortcut");

        wstring wsLocalizedFileNameResource (SYSTEM_32_PATH);
        wsLocalizedFileNameResource += RESOURCE_FILE_NAME;
        //
        // set the localized name of the shortcut
        //
        hr = SHSetLocalizedName (
                            (LPWSTR) wsPathLink.data (),
                            wsLocalizedFileNameResource.data (),
                            IDS_SAK_SHORTCUT_NAME
                            );
        if (FAILED (hr))
        {
                SATracePrintf  ("Failed on SHSetLocalizedFilaName with error:%x", hr);
                OutputDebugString (L"Failed on SHSetLocalizedFilaName");
                break;
        }

        SATraceString ("Successfully created shortcut");
        OutputDebugString (L"Successfully created shortcut");

        //
        // done creating the shortcut
        //
        dwRetVal = ERROR_SUCCESS;
        
    } 
    while (false);

    return (dwRetVal);
    
}   // end of CreateSAKShortcut function

//++--------------------------------------------------------------
//
//  Function:   RemoveSAKShortcut
//
//  Synopsis:   This is export function to remove "Remote Administration Tools" shortcut
//                   to the start menu
//
//  Arguments: 
//              [in]    HANDLE - handle passed in by MSI
//
//  Returns:    DWORD - success/failure
//
//  History:    MKarki      Created    12/04/2002
//
//----------------------------------------------------------------
DWORD __stdcall 
RemoveSAKShortcut (
        /*[in]*/    MSIHANDLE hInstall
        )
{

    CSATraceFunc objTraceFunc ("RemoveSAKShortcut");

    DWORD dwRetVal = -1;

    do
    {
        //
        //Construct the path where the shortcut will be stored in the Startup folder
        //

        //
        //Get the path to the Administrators Tools folder
        //
        WCHAR pwsStartMenuPath[MAX_PATH +1];
        HRESULT hr = SHGetFolderPath(NULL, 
                             CSIDL_COMMON_ADMINTOOLS, 
                             NULL, 
                             SHGFP_TYPE_CURRENT, 
                             pwsStartMenuPath);
        if (FAILED(hr))
        {
            SATracePrintf ("SHGetFolderPath failed getting the Start Menu path with error:%x", hr);
            break;
        }

        wstring wsPathLink(pwsStartMenuPath);
        wsPathLink += L"\\";
        wsPathLink += SHORTCUT_FILE_NAME;
        wsPathLink += SHORTCUT_EXT;
        SATracePrintf("   PathLink = %ws", wsPathLink.data());

        //
        // delete the shortcut now - 
        //
        BOOL bRetVal = DeleteFile (wsPathLink.data ());
        if (FALSE == bRetVal)
        {
            SATracePrintf ("Failed to Delete File with error:%x", GetLastError ());
            break;
        }

        //
        // success
        //
        dwRetVal = ERROR_SUCCESS;
    }
    while (false);
      
    return (dwRetVal);
    
}   // end of RemoveSAKShortcut function
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sanorun\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__087E5CD9_29E1_4177_B152_95976195B54D__INCLUDED_)
#define AFX_STDAFX_H__087E5CD9_29E1_4177_B152_95976195B54D__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


// Insert your headers here
//#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers

#include <windows.h>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__087E5CD9_29E1_4177_B152_95976195B54D__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\sakit\sawebinstall\sawebinstall.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
//  Copyright (c) 2001 Microsoft Corporation
//
//  Module Name:
//      SAWebInstall.cpp
//
//  Description:
//      Defines the entry point for the client application to 
//      install WebBlade for the SAK, using the SAInstall.dll
//
//  Documentation:
//      SaInstall2.2.doc
//
//  History:
//      travisn   23-JUL-2001    Created
//      travisn    2-AUG-2001    Modified to better follow coding standards
//      travisn   20-AUG-2001    Added command line options and first boot actions
//      travisn    1-NOV-2001    Place a link to Admin site in Startup menu
//      travisn   23-JAN-2002    Modify shortcut to launch Admin site
//
//////////////////////////////////////////////////////////////////////////////

#include <crtdbg.h>
#include <atlbase.h>
#include <Rtutils.h>
#include <shellapi.h>
#include <shlobj.h>
#include <string>
#include "resource.h"

#include "sainstallcom.h"
#include "sainstallcom_i.c"

//
// Constants for creating a shortcut to the Administration site
//
LPCWSTR STR_IEXPLORE_KEY = L"Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IEXPLORE.EXE";
LPCWSTR STR_SHORTCUT_EXT = L".lnk";
LPCWSTR STR_SECURELAUNCH_PATH = L"\\ServerAppliance\\SecureLaunch.vbs";
LPCWSTR STR_WSCRIPT_PATH = L"\\wscript.exe";

// Log file name
LPCTSTR SA_INSTALL_NAME = L"SaInstExe";

// Log file handle
DWORD dwLogHandle;

// Error reporting string
const char *UNRECOGNIZED_PARAMETER = " Unrecognized parameter: ";

//
// The key and value to delete after a successful install on the Blade SKU
//
LPCWSTR RUN_KEY = L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run";
LPCWSTR SAINSTALL_VALUE = L"SAInstall";


//////////////////////////////////////////////////////////////////////////////
//++
//
//  Trace
//
//  Description:
//      Utility function to simplify file logging
//
//  history
//      travisn   17-AUG-2001  Created
//--
//////////////////////////////////////////////////////////////////////////////
void Trace(LPCTSTR str)
{
    if (dwLogHandle != INVALID_TRACEID)
    {
        //Write the error to the log file
        TracePrintf(dwLogHandle, str);
    }
}

//////////////////////////////////////////////////////////////////////////////
//++
//
// CreateAndOpenAdminLink 
//
// Description:
//   Uses the Shell's IShellLink and IPersistFile interfaces 
//   to create and store a shortcut to the Administration web site. 
//   Then it opens the shortcut to launch the site.
//
//  history
//      travisn   1-NOV-2001  Created
//      travisn  23-JAN-2002  Modified shortcut to point to SecureLaunch.vbs
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT CreateAndOpenAdminLink() 
{ 
    Trace(L"   Entering CreateAndOpenAdminLink");
    HRESULT hr = E_FAIL; 

    do
    {
        using namespace std;

        //
        // Get the path to %System32%
        //
        WCHAR pwsSystemPath[MAX_PATH+1];
        hr = SHGetFolderPath(NULL, 
                             CSIDL_SYSTEM, 
                             NULL, 
                             SHGFP_TYPE_CURRENT, 
                             pwsSystemPath);
        if (FAILED(hr))
        {
            Trace(L"   SHGetFolderPath failed getting the System32 path");
            break;
        }

        //
        // Construct the path to wscript.exe
        //
        wstring wsWScriptPath(pwsSystemPath);
        wsWScriptPath += STR_WSCRIPT_PATH;
        TracePrintf(dwLogHandle, L"   WScript Path = %ws", wsWScriptPath.data());

        //
        // Construct the path to SecureLaunch.vbs
        //
        wstring wsLaunchPath(pwsSystemPath);
        wsLaunchPath += STR_SECURELAUNCH_PATH;
        TracePrintf(dwLogHandle, L"   Secure Launch Path = %ws", wsLaunchPath.data());

        //
        // Get the path of Internet Explorer from the registry to use its icon 
        //
        LONG retVal;
        HKEY hOpenKey;
        retVal = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                               STR_IEXPLORE_KEY, 
                               0, KEY_READ, 
                               &hOpenKey);

        if (retVal != ERROR_SUCCESS)
        {
            Trace(L"   Could not open registry key for IExplore.exe");
            break;
        }

        WCHAR pwsIExplorePath[MAX_PATH];
        DWORD nStrLength = sizeof(pwsIExplorePath);
        retVal = RegQueryValueEx(hOpenKey, 
                                 NULL, NULL, NULL, 
                                 (LPBYTE)pwsIExplorePath, 
                                 &nStrLength);

        RegCloseKey(hOpenKey);
        if (retVal != ERROR_SUCCESS)
        {
            Trace(L"   Could not open registry value for IExplore.exe");
            break;
        }
        TracePrintf(dwLogHandle, L"   IExplore Path = %ws", pwsIExplorePath);

        //
        //Construct the path where the shortcut will be stored in the Startup folder
        //

        //Get the path to the All Users Startup folder
        WCHAR pwsStartMenuPath[MAX_PATH+1];
        hr = SHGetFolderPath(NULL, 
                             CSIDL_STARTUP, 
                             NULL, 
                             SHGFP_TYPE_CURRENT, 
                             pwsStartMenuPath);
        if (FAILED(hr))
        {
            Trace(L"   SHGetFolderPath failed getting the Start Menu path");
            break;
        }

        //Load the shortcut name from a resource
        WCHAR pwsShortcutName[MAX_PATH+1];
        if (0 == LoadString(NULL, IDS_SHORTCUT_NAME, pwsShortcutName, MAX_PATH))
        {
            Trace(L"   LoadString IDS_SHORTCUT_NAME failed");
            break;
        }

        wstring wsPathLink(pwsStartMenuPath);
        wsPathLink += L"\\";
        wsPathLink += pwsShortcutName;
        wsPathLink += STR_SHORTCUT_EXT;
        TracePrintf(dwLogHandle, L"   PathLink = %ws", wsPathLink.data());

        //
        // Now that the shortcut information has been constructed, 
        // create the shortcut object.
        //
        CComPtr <IShellLink> psl;
     
        // Get a pointer to the IShellLink interface. 
        hr = CoCreateInstance(CLSID_ShellLink,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IShellLink,
                            (LPVOID *)&psl);

        if (FAILED(hr)) 
        { 
            Trace(L"   ShellLink CoCreateInstance Failed");
            break;
        }

        //Load the shortcut description 
        WCHAR pwsShortcutDescription[MAX_PATH+1];
        if (0 == LoadString(NULL, IDS_SHORTCUT_DESCRIPTION, pwsShortcutDescription, MAX_PATH))
        {
            Trace(L"   LoadString IDS_SHORTCUT_DESCRIPTION failed");
            break;
        }

        //
        // Set the information for the shortcut 
        //
        psl->SetPath(wsWScriptPath.data()); 
        psl->SetArguments(wsLaunchPath.data()); 
        psl->SetDescription(pwsShortcutDescription);
        psl->SetIconLocation(pwsIExplorePath, 0);//Use Internet Explorer's icon

        Trace(L"    Save shortcut to file");
        // Query IShellLink for the IPersistFile interface for saving the 
        // shortcut in persistent storage. 
        CComPtr <IPersistFile> ppf;
        hr = psl->QueryInterface(IID_IPersistFile, 
                                (LPVOID*)&ppf); 

        if (FAILED(hr)) 
        {
            break;
        }

        Trace(L"    Pointer to IPersistFile retrieved");
        // Save the link by calling IPersistFile::Save. 
        hr = ppf->Save(wsPathLink.data(), TRUE); 

        if (FAILED(hr))
        {
            Trace(L"    Failed to save shortcut");
            break;
        }

        Trace(L"    Successfully saved shortcut");
        hr = S_OK;
        
        //
        //Launch the admin web site in a browser
        //

        HINSTANCE hi;
        hi = ShellExecuteW(
            0,        //HWND hwnd, 
            L"open",  //LPCTSTR lpOperation,
            wsPathLink.data(),//LPCTSTR lpFile, 
            L"",      //LPCTSTR lpParameters, 
            L"",      //LPCTSTR lpDirectory,
            SW_SHOW); //INT nShowCmd

        //A return value > 32 indicates the call was successful
        if ((int) hi > 32)
        {
            Trace(L"   Launched the Admin site in a browser successfully");
        }
        else
        {
            Trace(L"   Could not launch the Admin site in a browser");
        }

    } while (false);

    Trace(L"   Exiting CreateAndOpenAdminLink");
    return hr; 
} 


//////////////////////////////////////////////////////////////////////////////
//++
//
//  SuccessfulInstallActions
//
//  Description:
//      If the install was successful on the Blade SKU, this function
//      is called to open the Administration web page in a browser,
//      and delete the SAInstall value from the Run key so that
//      this installation will not be called automatically again.
//
//  history
//      travisn   21-AUG-2001  Created
//--
//////////////////////////////////////////////////////////////////////////////
void SuccessfulInstallActions()
{
    Trace(L"  Entering SuccessfulInstallActions");

    //
    // Create a shortcut to the admin web site in the Startup menu
    //
    // CreateAndOpenAdminLink();

    //
    // Clear HKLM\Software\Microsoft\Windows\CurrentVersion\Run 
    //
    
    //Open the Run key
    HKEY hOpenKey;
    RegOpenKeyExW(HKEY_LOCAL_MACHINE, RUN_KEY, 0, KEY_WRITE, &hOpenKey);

    //Delete the SAInstall value
    LRESULT lRes;
    lRes = RegDeleteValue(hOpenKey, SAINSTALL_VALUE); 
    
    //
    // If RegOpenKeyEx failed, RegDeleteValue will fail, so just detect the 
    // error at the end of both operations
    //
    if (lRes == ERROR_SUCCESS)
    {
        Trace(L"   Deleted the SAInstall value from the Run key");
    }
    else
    {
        Trace(L"   SAInstall value not found--Could not delete from Run key");
    }
    RegCloseKey(hOpenKey);

    Trace(L"  Exiting SuccessfulInstallActions");
}

//////////////////////////////////////////////////////////////////////////////
//++
//
//  Install
//
//  Description:
//    Installs a Server Appliance solution (NAS or WEB) by
//    calling SaInstall.dll
//
//  history
//      travisn  23-JUL-2001  Created
//      travisn   2-AUG-2001  Some comments added
//      travisn  21-AUG-2001  Added tracing
//--
//////////////////////////////////////////////////////////////////////////////
HRESULT Install(const SA_TYPE installType, //[in] WEB or NAS
             const BOOL bInstall,//[in] Whether to call SAInstall or SAUninstall
             const BOOL bFirstBoot)//[in]
{
	Trace(L"Entering Install");

    HRESULT hr = S_OK;
    //String where results from calling the installation are stored
    BSTR bstrError = NULL;

    do 
    {
		
		CComPtr <ISaInstall> pSaInstall;
		//	
        // open the COM interface to the mof compiler object
		//
        hr = CoCreateInstance(
            				CLSID_SaInstall,
            				NULL,
            				CLSCTX_INPROC_SERVER,
            				IID_ISaInstall,
            				(LPVOID *)&pSaInstall);
      	if (FAILED (hr))
      	{
            Trace(L"  CoCreateInstance failed");
            break;
        }

        if (!bInstall)
        {   //
            // Uninstall the SAK
            //
            Trace(L"  Calling SaUninstall");
            
            hr = pSaInstall -> SAUninstall(installType, 
                                    &bstrError);
            
            if (FAILED(hr))
            {
                Trace(L"  SaUninstall Failed:");
                Trace(bstrError);
            }
            else if (hr == S_OK)
            {
                Trace(L"  SaUninstall was successful");
            }
            else //if (hr == S_FALSE)
            {
                Trace(L"  SaUninstall aborted since the SA type is not installed");
            }
        }
	    else
        {
            //
            // Check to see if the SAK is already installed
            //
            VARIANT_BOOL bInstalled;
            hr = pSaInstall -> SAAlreadyInstalled(installType, &bInstalled);

            if (FAILED(hr))
            {
                Trace(L"  Call to SAAlreadyInstalled failed");
                break;
            }

            if (!bInstalled)
            {
                //
                // Install the SAK
                //
                Trace(L"  Calling SaInstall");
                BSTR bstrCDName(L"");

                hr = pSaInstall -> SAInstall(
                        installType,      //[in] NAS or WEB
                        bstrCDName,       //[in]
                        VARIANT_TRUE,     //[in] display error dialogs
                        VARIANT_FALSE,    //[in] unattended
                        &bstrError);      //[out]

                Trace(bstrError);
                if (SUCCEEDED(hr))
                {
                    Trace(L"  Completed SaInstall successfully");
                    bInstalled = VARIANT_TRUE;
                }
                else
                {
                    Trace(L"  SaInstall failed");
                    break;
                }
            }
            
            //
            // If the install was successful and it's the first boot,
            // perform the appropriate actions.
            //
            if (bFirstBoot && bInstalled)
            {
                SuccessfulInstallActions();
            }
        }
    }
    while (false);

    SysFreeString(bstrError);
    Trace(L"Exiting Install");
    return hr;
}


//////////////////////////////////////////////////////////////////////////////
//++
//
//  WinMain
//
//  Description:
//    Main entry point to install the WEB Server Appliance
//
//  history
//      travisn   10-AUG-2001  Some comments added
//      travisn   20-AUG-2001  Added command-line and logging
//--
//////////////////////////////////////////////////////////////////////////////
int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    //Get a handle on the log file
    dwLogHandle = TraceRegister(SA_INSTALL_NAME);
    
    HRESULT hr = S_OK;
    do
    {   
        //Initialize the COM object
        if (FAILED(CoInitialize(NULL))) 
        {
            hr = E_FAIL;
            Trace(L"Could not create COM object (SaInstall.dll)");
            break;
        }

        //Install or uninstall an appliance
        hr = Install(WEB,   //[in] SAK Type to install
                     TRUE, //[in] Flag whether to install or uninstall
                     TRUE);//[in] Always first boot
           
        //Uninitialize the COM object in the dll
        CoUninitialize();  
    }
    while (false);

    //Release the log file resources
    TraceDeregister(dwLogHandle);
   
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\include\assertwithstack.h ===
//----------------------------------------------------------------------------- 
// Copyright (c) Microsoft Corporation. All rights reserved.
//----------------------------------------------------------------------------- 

#pragma once

#ifdef ASSERT_WITH_STACK
#ifndef _WIN64

#include <windows.h>
#include <imagehlp.h>
#include <crtdbg.h>

//
//--- Constants ---------------------------------------------------------------
//

const UINT cchMaxAssertModuleLen = 12;
const UINT cchMaxAssertSymbolLen = 257;
const UINT cfrMaxAssertStackLevels = 20;
const UINT cchMaxAssertExprLen = 257;

const UINT cchMaxAssertStackLevelStringLen = 
    (2 * 8) + cchMaxAssertModuleLen + cchMaxAssertSymbolLen + 12;
    // 2 addresses of at most 8 char, module, symbol, and the extra chars:
    // 0x<address>: <module>! <symbol> + 0x<offset>\n

//
//--- Prototypes --------------------------------------------------------------
//

/****************************************************************************
* MagicDeinit *
*-------------*
*   Description:  
*       Cleans up for the symbol loading code. Should be called before
*       exiting in order to free the dynamically loaded imagehlp.dll
****************************************************************************/
void MagicDeinit(void);

/****************************************************************************
* GetStringFromStackLevels *
*--------------------------*
*   Description:  
*       Retrieves a string from the stack frame. If more than one frame, they
*       are separated by newlines. Each fram appears in this format:
*
*           0x<address>: <module>! <symbol> + 0x<offset>
****************************************************************************/
void GetStringFromStackLevels(UINT ifrStart, UINT cfrTotal, CHAR *pszString);

/****************************************************************************
* GetAddrFromStackLevel *
*-----------------------*
*   Description:  
*       Retrieves the address of the next instruction to be executed on a
*       particular stack frame.
*
*   Return:
*       The address as a DWORD.
****************************************************************************/
DWORD GetAddrFromStackLevel(UINT ifrStart);

/****************************************************************************
* GetStringFromAddr *
*-------------------*
*   Description:  
*       Builds a string from an address in the format:
*
*           0x<address>: <module>! <symbol> + 0x<offset>
****************************************************************************/
void GetStringFromAddr(DWORD dwAddr, TCHAR *szString);

//
//--- _ASSERTE replacement ----------------------------------------------------
//

/****************************************************************************
* _ASSERTE *
*----------*
*   Description:  
*       A replacement for the CRT runtime's version of _ASSERTE that also
*       includes stack information in the assert.
****************************************************************************/
#undef _ASSERTE
#define _ASSERTE(expr) \
        do \
        { \
            if (!(expr)) \
            { \
                char *pszExprWithStack = \
                    (char*)_alloca( \
                        cchMaxAssertStackLevelStringLen * \
                            cfrMaxAssertStackLevels + cchMaxAssertExprLen + 50 + 1); \
                strcpy(pszExprWithStack, #expr); \
                strcat(pszExprWithStack, "\n\n"); \
                GetStringFromStackLevels(0, 10, pszExprWithStack + strlen(pszExprWithStack)); \
                strcat(pszExprWithStack, "\n"); \
                SYSTEMTIME sysTime; \
                GetLocalTime(&sysTime); \
                CHAR pszDateTime[50]; \
                sprintf(pszDateTime, "\n%d.%d.%d %02d:%02d:%02d", \
                                     sysTime.wMonth,sysTime.wDay,sysTime.wYear, \
                                     sysTime.wHour,sysTime.wMinute,sysTime.wSecond); \
                strcat(pszExprWithStack, pszDateTime); \
                if (1 == _CrtDbgReport(_CRT_ASSERT, \
                                       __FILE__, \
                                       __LINE__, \
                                       NULL, pszExprWithStack)) \
                    _CrtDbgBreak(); \
            } \
        } while (0) \

#endif // _WIN64
#endif // ASSERT_WITH_STACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\common.inc ===
!if "$(SPEECH_ROOT)"==""
!error SPEECH_ROOT should be defined in makefile
!endif

INCLUDES        = $(INCLUDES);$(SPEECH_ROOT)\common\include;$(SPEECH_ROOT)\sapi\include;$(SPEECH_ROOT)\setup\installer;$(SPEECH_ROOT)\common\spcommon\$(O);$(SPEECH_ROOT)\sapi\include\$(O)

386_STDCALL=0
USE_LIBCMT=1

# ****** "FINAL" should be defined only for golden builds ******
C_DEFINES       = $(C_DEFINES) -DFINAL

# ****** Automation

C_DEFINES = $(C_DEFINES) -DSAPI_AUTOMATION

!if defined(USE_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!else
# Insure that we will work on Win 95
CHICAGO_PROJECT   = 1
CHICAGO_PRODUCT   = 1
NO_NTDLL          = 1
!endif

CHECKED_ALT_DIR=1

!if "$(_BUILDTYPE)" == "fre"
FREEBUILD=1
!else
FREEBUILD=0
DEBUG_CRTS         = 1
!endif

#
# Default location for libc*.lib
#

CRT_LIB_PATH = $(SDK_LIB_PATH)

#
# Additional compiler flags
#

!if "$(BUILD_PRODUCT)" == "NT"
WIN32_WINNT_VERSION=0x500
WIN32_IE_VERSION   =0x0500
WIN32_DEFINE= -D_WIN32_WINDOWS=0x500 -D_WIN32_WINNT=0x0500
C_DEFINES          =$(C_DEFINES) -DSTRICT -DWIN32 -D_WIN32
!if !$(FREEBUILD)
C_DEFINES          = $(C_DEFINES) -D_DEBUG -DDEBUG
MSC_OPTIMIZATION   = /Odi
!endif
ATL_VER            = 30
USE_STATIC_ATL     = 1
!else

!if !$(FREEBUILD)
C_DEFINES          = $(C_DEFINES) -D_DEBUG -DDEBUG
DEBUG_CRTS         = 1
NTDEBUG            = ntsd
NTDEBUGTYPE        = windbg
!endif

USE_PDB            = 1
USE_PDB_TO_COMPILE = 1

#
# Additional linker flags
#

LINKER_FLAGS    = $(LINKER_FLAGS) -map

#
# Get all maps and syms
#

USE_MAPSYM = 1
!endif		# BUILD_PRODUCT != NT

# Make warnings equivalent to errors

#
# Special IceCap flags
#

!if defined(SPG_BUILD_ICECAP)
CRT_LIB_PATH     = $(SPEECH_ROOT)\sr\extlibs\bbt
LINKER_FLAGS     = $(LINKER_FLAGS) /debugtype:cv,fixup
USER_C_FLAGS     = $(USER_C_FLAGS) /DICECAP /FI$(SPEECH_ROOT)\sr\include\when.h /FI$(SPEECH_ROOT)\sr\include\_icecap.h
!endif

!if !defined(MSC_WARNING_LEVEL)
MSC_WARNING_LEVEL= /W3
!endif
MSC_WARNING_LEVEL= $(MSC_WARNING_LEVEL) /WX
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\include\commonlx.h ===
/*******************************************************************************
* CommonLx.h
*   This is the header file for the defines and constants used by sapi lexicon
*   and the tools
*
*  Owner: yunusm                                                Date: 07/01/99
*
*  Copyright (c) 1999 Microsoft Corporation. All Rights Reserved.
*******************************************************************************/

#pragma once

//--- Includes -----------------------------------------------------------------

#include <stdio.h>
#include "sapi.h"
#include "spddkhlp.h"

// Phone converter defines for the SpPhoneConverter class
const static DWORD g_dwMaxLenPhone = 7; // Maximum number of unicode characters in phone string
const static DWORD g_dwMaxLenId = 3;    // Maximum number of ids that can be run together per phone string.
                                            // This number is 1 for SAPI converters but SR, TTS use this to encode one string into several ids
                                            // using in the form "aa 01235678".

// The following defines used by the compression code for Lookup/Vendor lexicons
#define MAXTOTALCBSIZE     9  // = CBSIZE + MAXELEMENTSIZE
#define MAXELEMENTSIZE     5  // = greater of (LTSINDEXSIZE, POSSIZE)
#define CBSIZE             4  // = LASTINFOFLAGSIZE + WORDINFOTYPESIZE
#define LASTINFOFLAGSIZE   1
#define WORDINFOTYPESIZE   3
#define LTSINDEXSIZE       4
#define POSSIZE            5 // a maximum of 32 parts of speech

typedef enum tagSPLexWordInfoType
{
   ePRON = 1,
   ePOS = 2
} SPLEXWORDINFOTYPE;

/*
Control block layout

struct CB
{
   BYTE fLast : LASTINFOFLAGSIZE; // Is this the last Word Information piece
   BYTE WordInfoType : WORDINFOTYPESIZE;  // Allow for 8 types
};
*/

typedef struct tagLookupLexInfo
{
   GUID  guidValidationId;
   GUID  guidLexiconId;
   LANGID LangID;
   WORD  wReserved;
   DWORD nNumberWords;
   DWORD nNumberProns;
   DWORD nMaxWordInfoLen;
   DWORD nLengthHashTable;
   DWORD nBitsPerHashEntry;
   DWORD nCompressedBlockBits;
   DWORD nWordCBSize;
   DWORD nPronCBSize;
   DWORD nPosCBSize;
} LOOKUPLEXINFO, *PLOOKUPLEXINFO;

typedef struct tagLtsLexInfo
{
   GUID        guidValidationId;
   GUID        guidLexiconId;
   LANGID      LangID;
} LTSLEXINFO, *PLTSLEXINFO;

// The following two typedefs used in Japanese and Chinese phone converters

typedef struct SYLDIC 
{
    char *pKey;
    WCHAR *pString;
} SYLDIC;

typedef struct SYLDICW 
{
    WCHAR *pwKey;
    char *pString;
} SYLDICW;

//--- Validation functions ----------------------------------------------------

inline BOOL SpIsBadLexType(DWORD dwFlag)
{
    if (dwFlag != eLEXTYPE_USER &&
        dwFlag != eLEXTYPE_APP &&
        !(dwFlag >= eLEXTYPE_PRIVATE1 && dwFlag <= eLEXTYPE_PRIVATE20))
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

inline BOOL SPIsBadPartOfSpeech(SPPARTOFSPEECH ePartOfSpeech)
{
    SPPARTOFSPEECH eMask = (SPPARTOFSPEECH)~0xfff;
    SPPARTOFSPEECH ePOS = (SPPARTOFSPEECH)(ePartOfSpeech & eMask);
    if (ePartOfSpeech != SPPS_NotOverriden &&
        ePartOfSpeech != SPPS_Unknown &&
        ePOS != SPPS_Noun &&
        ePOS != SPPS_Verb &&
        ePOS != SPPS_Modifier &&
        ePOS != SPPS_Function &&
        ePOS != SPPS_Interjection)
    {
        return TRUE;
    }
    return FALSE;
}


inline BOOL SPIsBadLexWord(const WCHAR *pszWord)
{
    return (SPIsBadStringPtr(pszWord) || !*pszWord || wcslen(pszWord) >= SP_MAX_WORD_LENGTH);
}


inline BOOL SPIsBadLexPronunciation(CComPtr<ISpPhoneConverter> spPhoneConv, const WCHAR *pszPronunciation)
{
    HRESULT hr = S_OK;
    WCHAR szPhone[SP_MAX_PRON_LENGTH * (g_dwMaxLenPhone + 1)]; // we will not fail for lack of space

    if (SPIsBadStringPtr(pszPronunciation) || !*pszPronunciation ||
        (wcslen(pszPronunciation) >= SP_MAX_PRON_LENGTH))
    {
        return TRUE;
    }
    if (spPhoneConv)
    {
        hr = spPhoneConv->IdToPhone(pszPronunciation, szPhone);
    }
    return (FAILED(hr));
}


inline BOOL SPIsBadWordPronunciationList(SPWORDPRONUNCIATIONLIST *pWordPronunciationList)
{
    return (SPIsBadWritePtr(pWordPronunciationList, sizeof(SPWORDPRONUNCIATIONLIST)) ||
            SPIsBadWritePtr(pWordPronunciationList->pvBuffer, pWordPronunciationList->ulSize));
}


inline BOOL SPIsBadWordList(SPWORDLIST *pWordList)
{
    return (SPIsBadWritePtr(pWordList, sizeof(SPWORDLIST)) ||
            SPIsBadWritePtr(pWordList->pvBuffer, pWordList->ulSize));
}

inline HRESULT SPCopyPhoneString(const WCHAR *pszSource, WCHAR *pszTarget)
{
	HRESULT hr = S_OK;

	if (SPIsBadWritePtr(pszTarget, (wcslen(pszSource) + 1) * sizeof(WCHAR)))
    {
		hr = E_INVALIDARG;
    }
	else
    {
		wcscpy(pszTarget, pszSource);
    }
	return hr;
}

/*****************************************************************************
* GetWordHashValue *
*------------------*
*
*   Description:
*       Hash function for the Word hash tables. This hash function tries to create
*       a word hash value very dependant on the word text. The mean collison rate
*       on hash tables populated with this hash function is 1 per word access. This
*       result was when collisions were resolved using linear probing when
*       populating the hash table. Using non-linear probing might yield an even lower
*       mean collision rate.
*
*   Return:
*       hash value
**********************************************************************YUNUSM*/
inline DWORD GetWordHashValue(PCWSTR pwszWord,         // word string
                              DWORD nLengthHash        // length of hash table
                              )
{
   DWORD dHash = *pwszWord++;
   
   WCHAR c;
   WCHAR cPrev = (WCHAR)dHash;

   for (; *pwszWord; pwszWord++)
   {
      c = *pwszWord;
      dHash += ((c << (cPrev & 0x1F)) + (cPrev << (c & 0x1F)));

      cPrev = c;
   }
   return (((dHash << 16) - dHash) % nLengthHash);
}

/*******************************************************************************
* ReallocSPWORDPRONList *
*-----------------------*
*   Description:
*       Grow a SPWORDPRONUNCIATIONLIST if necessary 
*
*   Return: 
*       S_OK
*       E_OUTOFMEMORY
/**************************************************************** YUNUSM ******/
inline HRESULT ReallocSPWORDPRONList(SPWORDPRONUNCIATIONLIST *pSPList,   // buffer to grow
                                     DWORD dwSize                        // length to grow to
                                     )
{
    SPDBG_FUNC("ReallocSPWORDPRONList");

    HRESULT hr = S_OK;
    if (pSPList->ulSize < dwSize)
    {
        BYTE *p = (BYTE *)CoTaskMemRealloc(pSPList->pvBuffer, dwSize);
        if (!p)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pSPList->pvBuffer = p;
            pSPList->pFirstWordPronunciation = (SPWORDPRONUNCIATION *)p;
            pSPList->ulSize = dwSize;
        }
    }
    else
    {
        pSPList->pFirstWordPronunciation = (SPWORDPRONUNCIATION *)(pSPList->pvBuffer);
    }
    return hr;
}

/*******************************************************************************
* ReallocSPWORDList *
*-----------------------*
*   Description:
*       Grow a SPWORDLIST if necessary 
*
*   Return: 
*       S_OK
*       E_OUTOFMEMORY
/**************************************************************** YUNUSM ******/
inline HRESULT ReallocSPWORDList(SPWORDLIST *pSPList,   // buffer to grow
                                 DWORD dwSize           // length to grow to
                                 )
{
    SPDBG_FUNC("ReallocSPWORDList");

    HRESULT hr = S_OK;
    if (pSPList->ulSize < dwSize)
    {
        BYTE *p = (BYTE *)CoTaskMemRealloc(pSPList->pvBuffer, dwSize);
        if (!p)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            pSPList->pvBuffer = p;
            pSPList->pFirstWord = (SPWORD *)p;
            pSPList->ulSize = dwSize;
        }
    }
    else
    {
        pSPList->pFirstWord = (SPWORD *)(pSPList->pvBuffer);
    }
    return hr;
}

inline size_t PronSize(const WCHAR * const pwszPron)
{
    // NB - SPWORDPRONUNCIATION struct size includes space for one SPPHONEID

    const size_t cb = sizeof(SPWORDPRONUNCIATION) + (wcslen(pwszPron) * sizeof(SPPHONEID));

    return (cb + sizeof(void *) - 1) & ~(sizeof(void *) - 1);
}


inline size_t WordSize(const WCHAR * const pwszWord)
{
    // SPWORD struct size with the aligned word size

    const size_t cb = sizeof(SPWORD) + ((wcslen(pwszWord) + 1) * sizeof(WCHAR));

    return (cb + sizeof(void *) - 1) & ~(sizeof(void *) - 1);
}

/*******************************************************************************
* CreateNextPronunciation *
*-------------------------*
*   Description:
*       Returns a pointer to the location in the pronunciation array
*       where the next pronunciation in the list should start.
*       This function should be used only when creating the list.
*       Once the list is created, access the next pronunciation 
*       through the ->pNextWordPronunciation member.
*
/**************************************************************** PACOGG ******/
inline SPWORDPRONUNCIATION* CreateNextPronunciation(SPWORDPRONUNCIATION *pSpPron)
{
    return (SPWORDPRONUNCIATION *)((BYTE *)pSpPron + PronSize(pSpPron->szPronunciation));
}

//--- End of File -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\include\assertwithstack.cpp ===
//----------------------------------------------------------------------------- 
// Copyright (c) Microsoft Corporation. All rights reserved.
//----------------------------------------------------------------------------- 

#ifdef ASSERT_WITH_STACK
#ifndef _WIN64

#include "AssertWithStack.h"

//
//--- Macros ------------------------------------------------------------------
//

#define COUNT_OF(x)    (sizeof(x) / sizeof(x[0]))

//
// Types and Constants --------------------------------------------------------
//

struct __SYMBOL_INFO
{
    DWORD       dwOffset;
    char        achModule[cchMaxAssertModuleLen];
    char        achSymbol[cchMaxAssertSymbolLen];
};

//--- Function Pointers to APIs in IMAGEHLP.DLL. Loaded dynamically. ---------

typedef LPAPI_VERSION (__stdcall *pfnImgHlp_ImagehlpApiVersionEx)(
    LPAPI_VERSION AppVersion
    );

typedef BOOL (__stdcall *pfnImgHlp_StackWalk)(
    DWORD                             MachineType,
    HANDLE                            hProcess,
    HANDLE                            hThread,
    LPSTACKFRAME                      StackFrame,
    LPVOID                            ContextRecord,
    PREAD_PROCESS_MEMORY_ROUTINE      ReadMemoryRoutine,
    PFUNCTION_TABLE_ACCESS_ROUTINE    FunctionTableAccessRoutine,
    PGET_MODULE_BASE_ROUTINE          GetModuleBaseRoutine,
    PTRANSLATE_ADDRESS_ROUTINE        TranslateAddress
    );

typedef BOOL (__stdcall *pfnImgHlp_SymGetModuleInfo)(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PIMAGEHLP_MODULE    ModuleInfo
    );

typedef LPVOID (__stdcall *pfnImgHlp_SymFunctionTableAccess)(
    HANDLE  hProcess,
    DWORD   AddrBase
    );

typedef BOOL (__stdcall *pfnImgHlp_SymGetSymFromAddr)(
    IN  HANDLE              hProcess,
    IN  DWORD               dwAddr,
    OUT PDWORD              pdwDisplacement,
    OUT PIMAGEHLP_SYMBOL    Symbol
    );

typedef BOOL (__stdcall *pfnImgHlp_SymInitialize)(
    IN HANDLE   hProcess,
    IN LPSTR    UserSearchPath,
    IN BOOL     fInvadeProcess
    );

typedef BOOL (__stdcall *pfnImgHlp_SymUnDName)(
    IN  PIMAGEHLP_SYMBOL sym,               // Symbol to undecorate
    OUT LPSTR            UnDecName,         // Buffer to store undecorated name in
    IN  DWORD            UnDecNameLength    // Size of the buffer
    );

typedef BOOL (__stdcall *pfnImgHlp_SymLoadModule)(
    IN  HANDLE          hProcess,
    IN  HANDLE          hFile,
    IN  PSTR            ImageName,
    IN  PSTR            ModuleName,
    IN  DWORD           BaseOfDll,
    IN  DWORD           SizeOfDll
    );

struct IMGHLPFN_LOAD
{
    LPSTR   pszFnName;
    LPVOID * ppvfn;
};

//
// Globals --------------------------------------------------------------------
//

static BOOL      g_fLoadedImageHlp = FALSE;          // set to true on success
static BOOL      g_fLoadedImageHlpFailed = FALSE;    // set to true on failure
static HINSTANCE g_hinstImageHlp   = NULL;
static HANDLE    g_hProcess = NULL;

pfnImgHlp_ImagehlpApiVersionEx    _ImagehlpApiVersionEx;
pfnImgHlp_StackWalk               _StackWalk;
pfnImgHlp_SymGetModuleInfo        _SymGetModuleInfo;
pfnImgHlp_SymFunctionTableAccess  _SymFunctionTableAccess;
pfnImgHlp_SymGetSymFromAddr       _SymGetSymFromAddr;
pfnImgHlp_SymInitialize           _SymInitialize;
pfnImgHlp_SymUnDName              _SymUnDName;
pfnImgHlp_SymLoadModule           _SymLoadModule;

IMGHLPFN_LOAD ailFuncList[] =
{
    { "ImagehlpApiVersionEx",   (LPVOID*)&_ImagehlpApiVersionEx },
    { "StackWalk",              (LPVOID*)&_StackWalk },
    { "SymGetModuleInfo",       (LPVOID*)&_SymGetModuleInfo },
    { "SymFunctionTableAccess", (LPVOID*)&_SymFunctionTableAccess },
    { "SymGetSymFromAddr",      (LPVOID*)&_SymGetSymFromAddr },
    { "SymInitialize",          (LPVOID*)&_SymInitialize },
    { "SymUnDName",             (LPVOID*)&_SymUnDName },
    { "SymLoadModule",          (LPVOID*)&_SymLoadModule },
};

//
//--- Forward declarations ----------------------------------------------------
//

static int Dummy1();
static int Dummy2();

/****************************************************************************
* Dummy1 *
*--------*
*   Description:  
*       A placeholder function used to determine if addresses being retrieved
*       are for functions in this compilation unit or not.
*
*       WARNING!! This function must be the first function in this
*       compilation unit
****************************************************************************/
static int Dummy1()
{
    return 1;
}

/****************************************************************************
* IsWin95 *
*---------*
*   Description:  
*       Are we running on Win95 or not. Some of the logic contained here
*       differs on Windows 9x.
*
*   Return:
*   TRUE - If we're running on a Win 9x platform
*   FALSE - If we're running on a non-Win 9x platform
****************************************************************************/
static BOOL IsWin95()
{
    return GetVersion() & 0x80000000;
}

/****************************************************************************
* MagicInit *
*-----------*
*   Description:  
*       Initializes the symbol loading code. Currently called (if necessary)
*       at the beginning of each method that might need ImageHelp to be
*       loaded.
****************************************************************************/
void MagicInit()
{
    if (g_fLoadedImageHlp || g_fLoadedImageHlpFailed)
    {
        return;
    }

    g_hProcess = GetCurrentProcess();
    
    //
    // Try to load imagehlp.dll
    //
    g_hinstImageHlp = LoadLibraryA("imagehlp.dll");
    _ASSERT(g_hinstImageHlp);

    if (NULL == g_hinstImageHlp)
    {
        g_fLoadedImageHlpFailed = TRUE;
        return;
    }

    //
    // Try to get the API entrypoints in imagehlp.dll
    //
    for (int i = 0; i < COUNT_OF(ailFuncList); i++)
    {
        *(ailFuncList[i].ppvfn) = GetProcAddress(
                g_hinstImageHlp, 
                ailFuncList[i].pszFnName);
        _ASSERT(*(ailFuncList[i].ppvfn));
        
        if (!*(ailFuncList[i].ppvfn))
        {
            g_fLoadedImageHlpFailed = TRUE;
            return;
        }
    }

    API_VERSION AppVersion = { 4, 0, API_VERSION_NUMBER, 0 };
    LPAPI_VERSION papiver = _ImagehlpApiVersionEx(&AppVersion);

    //
    // We assume any version 4 or greater is OK.
    //
    _ASSERT(papiver->Revision >= 4);
    if (papiver->Revision < 4)
    {
        g_fLoadedImageHlpFailed = TRUE;
        return;
    }

    g_fLoadedImageHlp = TRUE;
    
    //
    // Initialize imagehlp.dll
    //
    _SymInitialize(g_hProcess, NULL, FALSE);

    return;
}


/****************************************************************************
* FillSymbolInfo *
*----------------*
*   Description:  
*       Fills in a __SYMBOL_INFO structure
****************************************************************************/
void FillSymbolInfo
(
__SYMBOL_INFO *psi,
DWORD dwAddr
)
{
    if (!g_fLoadedImageHlp)
    {
        return;
    }

    _ASSERT(psi);
    memset(psi, 0, sizeof(__SYMBOL_INFO));

    IMAGEHLP_MODULE  mi;
    mi.SizeOfStruct = sizeof(mi);
    
    if (!_SymGetModuleInfo(g_hProcess, dwAddr, &mi))
    {
        strncpy(psi->achModule, "<no module>", sizeof(psi->achModule)-1);
    }
    else
    {
        strncpy(psi->achModule, mi.ModuleName, sizeof(psi->achModule)-1);
        strupr(psi->achModule);
    }

    CHAR rgchUndec[256];
    CHAR * pszSymbol = NULL;

    // Name field of IMAGEHLP_SYMBOL is dynamically sized.
    // Pad with space for 255 characters.
    union
    {
        CHAR rgchSymbol[sizeof(IMAGEHLP_SYMBOL) + 255];
        IMAGEHLP_SYMBOL  sym;
    };

    __try
    {
        sym.SizeOfStruct = sizeof(IMAGEHLP_SYMBOL);
        sym.Address = dwAddr;
        sym.MaxNameLength = 255;

        if (_SymGetSymFromAddr(g_hProcess, dwAddr, &psi->dwOffset, &sym))
        {
            pszSymbol = sym.Name;

            if (_SymUnDName(&sym, rgchUndec, COUNT_OF(rgchUndec)-1))
            {
                pszSymbol = rgchUndec;
            }
        }
        else
        {
            pszSymbol = "<no symbol>";
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        pszSymbol = "<EX: no symbol>";
        psi->dwOffset = dwAddr - mi.BaseOfImage;
    }

    strncpy(psi->achSymbol, pszSymbol, COUNT_OF(psi->achSymbol)-1);
}

/****************************************************************************
* FunctionTableAccess *
*---------------------*
*   Description:  
*       Helper for imagehlp's StackWalk API.
****************************************************************************/
LPVOID __stdcall FunctionTableAccess
(
HANDLE hProcess,
DWORD dwPCAddr
)
{
    return _SymFunctionTableAccess( hProcess, dwPCAddr );
}

/****************************************************************************
* GetModuleBase *
*---------------*
*   Description:  
*       Helper for imagehlp's StackWalk API. Retrieves the base address of 
*       the module containing the giving virtual address.
*
*       NOTE: If the module information for the given module hasnot yet been
*       loaded, then it is loaded on this call.
*
*   Return:
*       Base virtual address where the module containing ReturnAddress is
*       loaded, or 0 if the address cannot be determined.
****************************************************************************/
DWORD __stdcall GetModuleBase
(
HANDLE hProcess,
DWORD dwAddr
)
{
    IMAGEHLP_MODULE ModuleInfo;
    ModuleInfo.SizeOfStruct = sizeof(ModuleInfo);
    
    if (_SymGetModuleInfo(hProcess, dwAddr, &ModuleInfo))
    {
        return ModuleInfo.BaseOfImage;
    }
    else
    {
        MEMORY_BASIC_INFORMATION mbi;
        
        if (VirtualQueryEx(hProcess, (LPVOID)dwAddr, &mbi, sizeof(mbi)))
        {
            if (IsWin95() || (mbi.Type & MEM_IMAGE))
            {
                char achFile[MAX_PATH] = {0};
                DWORD cch;
                
                cch = GetModuleFileNameA(
                        (HINSTANCE)mbi.AllocationBase,
                        achFile,
                        MAX_PATH);

                // Ignore the return code since we can't do anything with it.
                _SymLoadModule(
                    hProcess,
                    NULL,
                    ((cch) ? achFile : NULL),
                    NULL,
                    (DWORD)mbi.AllocationBase,
                    0);

                return (DWORD)mbi.AllocationBase;
            }
        }
    }

    return 0;
}


/****************************************************************************
* GetStackBacktrace *
*-------------------*
*   Description:  
*       Gets a stacktrace of the current stack, including symbols.
*
*   Return:
*       The number of elements actually retrieved.
****************************************************************************/
UINT GetStackBacktrace
(
UINT ifrStart,          // How many stack elements to skip before starting.
UINT cfrTotal,          // How many elements to trace after starting.
DWORD *pdwEip,          // Array to be filled with stack addresses.
__SYMBOL_INFO *psiSymbols // This array is filled with symbol information.
                        // It should be big enough to hold cfrTotal elts.
                        // If NULL, no symbol information is stored.
)
{
    DWORD * pdw = pdwEip;
    __SYMBOL_INFO * psi = psiSymbols;

    MagicInit();

    memset(pdwEip, 0, cfrTotal * sizeof(DWORD));

    if (psiSymbols)
    {
        memset(psiSymbols, 0, cfrTotal * sizeof(__SYMBOL_INFO));
    }

    if (!g_fLoadedImageHlp)
    {
        return 0;
    }

    HANDLE hThread;
    hThread = GetCurrentThread();

    CONTEXT context;
    context.ContextFlags = CONTEXT_FULL;

    if (GetThreadContext(hThread, &context))
    {
        STACKFRAME stkfrm;
        memset(&stkfrm, 0, sizeof(STACKFRAME));

        stkfrm.AddrPC.Mode      = AddrModeFlat;

        DWORD dwMachType;

#if defined(_M_IX86)
        dwMachType              = IMAGE_FILE_MACHINE_I386;
        stkfrm.AddrPC.Offset    = context.Eip;  // Program Counter

        stkfrm.AddrStack.Offset = context.Esp;  // Stack Pointer
        stkfrm.AddrStack.Mode   = AddrModeFlat;
        stkfrm.AddrFrame.Offset = context.Ebp;  // Frame Pointer
        stkfrm.AddrFrame.Mode   = AddrModeFlat;
#elif defined(_M_MRX000)
        dwMachType              = IMAGE_FILE_MACHINE_R4000;
        stkfrm.AddrPC.Offset    = context.Fir;  // Program Counter
#elif defined(_M_ALPHA)
        dwMachType              = IMAGE_FILE_MACHINE_ALPHA;
        stkfrm.AddrPC.Offset    = (unsigned long) context.Fir;  // Program Counter
#elif defined(_M_PPC)
        dwMachType              = IMAGE_FILE_MACHINE_POWERPC;
        stkfrm.AddrPC.Offset    = context.Iar;  // Program Counter
#elif
#error("Unknown Target Machine");
#endif

        // Ignore this function (GetStackBackTrace)
        ifrStart += 1;

        for (UINT i = 0; i < ifrStart + cfrTotal; i++)
        {
            if (!_StackWalk(dwMachType,
                            g_hProcess,
                            hThread,
                            &stkfrm,
                            &context,
                            NULL,
                            FunctionTableAccess,
                            GetModuleBase,
                            NULL))
            {
                break;
            }
            if (i >= ifrStart &&
                ((void*)stkfrm.AddrPC.Offset < (void*)Dummy1 ||
                (void*)stkfrm.AddrPC.Offset > (void*)Dummy2))
            {
                *pdw++ = stkfrm.AddrPC.Offset;

                if (psi)
                {
                    FillSymbolInfo(psi++, stkfrm.AddrPC.Offset);
                }   
            }
        }
    }

    return pdw - pdwEip;
}


/****************************************************************************
* GetStringFromSymbolInfo *
*-------------------------*
*   Description:  
*       Actually prints the info into the string for the symbol.
****************************************************************************/
void GetStringFromSymbolInfo
(
DWORD dwAddr,
__SYMBOL_INFO *psi,   // @parm Pointer to __SYMBOL_INFO. Can be NULL.
CHAR *pszString     // @parm Place to put string.
)
{
    _ASSERT(pszString);

    // <module>! <symbol> + 0x<offset> 0x<addr>\n

    if (psi)
    {
        wsprintfA(pszString,
                 "%s! %s + 0x%X (0x%08X)",
                 (psi->achModule[0]) ? psi->achModule : "<no module>",
                 (psi->achSymbol[0]) ? psi->achSymbol : "<no symbol>",
                 psi->dwOffset,
                 dwAddr);
    }
    else
    {
        wsprintfA(pszString, "<symbols not available> (0x%08X)", dwAddr);
    }

    _ASSERT(strlen(pszString) < cchMaxAssertStackLevelStringLen);
}

/****************************************************************************
* GetStringFromStackLevels *
*--------------------------*
*   Description:  
*       Retrieves a string from the stack frame. If more than one frame, they
*       are separated by newlines
****************************************************************************/
void GetStringFromStackLevels
(
UINT ifrStart,      // @parm How many stack elements to skip before starting.
UINT cfrTotal,      // @parm How many elements to trace after starting.
                    //  Can't be more than cfrMaxAssertStackLevels.
CHAR *pszString     // @parm Place to put string.
                    //  Max size will be cchMaxAssertStackLevelStringLen * cfrTotal.
)
{
    _ASSERT(pszString);
    _ASSERT(cfrTotal < cfrMaxAssertStackLevels);

    *pszString = '\0';

    if (cfrTotal == 0)
    {
        return;
    }

    DWORD rgdwStackAddrs[cfrMaxAssertStackLevels];
    __SYMBOL_INFO rgsi[cfrMaxAssertStackLevels];

    // Ignore this function (GetStringFromStackLevels)
    ifrStart += 1;

    UINT uiRetrieved =
            GetStackBacktrace(ifrStart, cfrTotal, rgdwStackAddrs, rgsi);

    // First level
    CHAR aszLevel[cchMaxAssertStackLevelStringLen];
    GetStringFromSymbolInfo(rgdwStackAddrs[0], &rgsi[0], aszLevel);
    strcpy(pszString, aszLevel);

    // Additional levels
    for (UINT i = 1; i < uiRetrieved; ++i)
    {
        strcat(pszString, "\n");
        GetStringFromSymbolInfo(rgdwStackAddrs[i],
                        &rgsi[i], aszLevel);
        strcat(pszString, aszLevel);
    }

    _ASSERT(strlen(pszString) <= cchMaxAssertStackLevelStringLen * cfrTotal);
}


/****************************************************************************
* GetAddrFromStackLevel *
*-----------------------*
*   Description:  
*       Retrieves the address of the next instruction to be executed on a
*       particular stack frame.
*
*   Return:
*       The address of the next instruction,
*       0 if there's an error.
****************************************************************************/
DWORD GetAddrFromStackLevel
(
UINT ifrStart       // How many stack elements to skip before starting.
)
{
    MagicInit();

    if (!g_fLoadedImageHlp)
    {
        return 0;
    }

    HANDLE hThread;
    hThread  = GetCurrentThread();

    CONTEXT context;
    context.ContextFlags = CONTEXT_FULL;

    if (GetThreadContext(hThread, &context))
    {
        STACKFRAME stkfrm;
        memset(&stkfrm, 0, sizeof(STACKFRAME));

        stkfrm.AddrPC.Mode      = AddrModeFlat;

        DWORD dwMachType;
        
#if defined(_M_IX86)
        dwMachType              = IMAGE_FILE_MACHINE_I386;
        stkfrm.AddrPC.Offset    = context.Eip;  // Program Counter

        stkfrm.AddrStack.Offset = context.Esp;  // Stack Pointer
        stkfrm.AddrStack.Mode   = AddrModeFlat;
        stkfrm.AddrFrame.Offset = context.Ebp;  // Frame Pointer
        stkfrm.AddrFrame.Mode   = AddrModeFlat;
#elif defined(_M_MRX000)
        dwMachType              = IMAGE_FILE_MACHINE_R4000;
        stkfrm.AddrPC.Offset    = context.Fir;  // Program Counter
#elif defined(_M_ALPHA)
        dwMachType              = IMAGE_FILE_MACHINE_ALPHA;
        stkfrm.AddrPC.Offset    = (unsigned long) context.Fir;  // Program Counter
#elif defined(_M_PPC)
        dwMachType              = IMAGE_FILE_MACHINE_POWERPC;
        stkfrm.AddrPC.Offset    = context.Iar;  // Program Counter
#elif
#error("Unknown Target Machine");
#endif

        // Ignore this function (GetStackBackTrace) and the one below
        ifrStart += 2;

        for (UINT i = 0; i < ifrStart; i++)
        {
            if (!_StackWalk(dwMachType,
                            g_hProcess,
                            hThread,
                            &stkfrm,
                            &context,
                            NULL,
                            FunctionTableAccess,
                            GetModuleBase,
                            NULL))
            {
                break;
            }
        }

        return stkfrm.AddrPC.Offset;
    }

    return 0;
}


/****************************************************************************
* GetStringFromAddr *
*-------------------*
*   Description:  
*       Returns a string from an address.
****************************************************************************/
void GetStringFromAddr
(
DWORD dwAddr,
CHAR *szString // Place to put string.
               // Buffer must hold at least cchMaxAssertStackLevelStringLen.
)
{
    _ASSERT(szString);

    __SYMBOL_INFO si;
    FillSymbolInfo(&si, dwAddr);

    wsprintfA(szString,
             "%s! %s + 0x%X (0x%08X)",
             (si.achModule[0]) ? si.achModule : "<no module>",
             (si.achSymbol[0]) ? si.achSymbol : "<no symbol>",
             si.dwOffset,
             dwAddr);
}

/****************************************************************************
* MagicDeinit *
*-------------*
*   Description:  
*       Cleans up for the symbol loading code. Should be called before exit
*       to free the dynamically loaded imagehlp.dll.
****************************************************************************/
void MagicDeinit(void)
{
    if (g_hinstImageHlp)
    {
        FreeLibrary(g_hinstImageHlp);

        g_hinstImageHlp   = NULL;
        g_fLoadedImageHlp = FALSE;
    }
}

static int Dummy2()
{
    return 2;
}

#endif // _WIN64
#endif // ASSERT_WITH_STACK
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\include\sapiarray.h ===
/*******************************************************************************
* SapiArray.h *
*------------*
*   Description:
*       This is the header file for SAPI internal array stuff.
*
*   Copyright 1998-2000 Microsoft Corporation All Rights Reserved.
*
*******************************************************************************/

#ifndef SPDebug_h
#include <SPDebug.h>
#endif

template <class T>
HRESULT CopyAndExpandArray(T ** ppArraySrc, ULONG CurSize, T ** ppArrayDest, ULONG NewSize, BOOL fZeroMem = true)
{
    T * pNew = new T[NewSize];

    if (pNew && ( CurSize < NewSize ))
    {
        if (CurSize)
        {
            memcpy(pNew, *ppArraySrc, sizeof(T) * CurSize);
        }
        if (fZeroMem)
        {
            memset(pNew + CurSize, 0, sizeof(T) * (NewSize - CurSize));
        }
        *ppArrayDest = pNew;
        return S_OK;
    }
    else if( pNew )
    {
        if( CurSize )
        {
            memcpy( pNew, *ppArraySrc, sizeof(T) * NewSize );
        }
        else if( fZeroMem )
        {
            memset( pNew , 0, sizeof(T) * NewSize );
        }
        *ppArrayDest = pNew;
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

template <class T>
HRESULT ReallocateArray(T ** ppArray, ULONG CurSize, ULONG NewSize, BOOL fZeroMem = true)
{
    T * pNew = new T[NewSize];
    SPDBG_ASSERT(CurSize <= NewSize);
    if (pNew)
    {
        if (CurSize)
        {
            memcpy(pNew, *ppArray, sizeof(T) * CurSize);
        }
        if (fZeroMem)
        {
            memset(pNew + CurSize, 0, sizeof(T) * (NewSize - CurSize));
        }
        delete[] *ppArray;
        *ppArray = pNew;
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}

template <class T>
HRESULT AllocateArray(T ** ppArray, ULONG Size, BOOL fZeroMem = true)
{
    SPDBG_ASSERT(*ppArray == NULL);
    *ppArray = new T[Size];
    if (*ppArray)
    {
        if (fZeroMem)
        {
            memset(*ppArray, 0, sizeof(T) * Size);
        }
        return S_OK;
    }
    else
    {
        return E_OUTOFMEMORY;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\include\sapisvrver.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 *      version.h is created on the fly from verhead.bat and vertail.h,     *
 *      with the current version numbers inserted in between                *
 *                                                                          *
 ****************************************************************************/

#ifndef VER_H
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <winver.h>
#endif
#include <windows.h>
#define VER_FILETYPE                VFT_APP
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "SAPISVR 5"
#define VER_INTERNALNAME_STR        "SAPISVR5"

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* the following values should be modified by the official      */
/* builder for each build                                       */
/*--------------------------------------------------------------*/

#include "currver.inc"


#define OFFICIAL                    1
#define FINAL                       1

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#if _DEBUG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS32
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\include\spsapiserverhelper.inl ===
/****************************************************************************
* SpSapiServerHelper.inl *
*------------------------*
*   Include file with definition and implementation of some of the 
*   SpSapiServer functions
***************************************************************** BeckyW ***/

#define SERVER_IS_ALIVE_EVENT_NAME      _T("SapiServerIsAlive")
#define SERVER_IS_ALIVE_EVENT_TIMEOUT   30000

HRESULT SpCreateIsServerAliveEvent(HANDLE * phevent)
{
    SPDBG_FUNC("SpCreateIsServerAliveEvent");
    HRESULT hr = S_OK;

    *phevent = CreateEvent(NULL, TRUE, FALSE, SERVER_IS_ALIVE_EVENT_NAME);
    if (*phevent == NULL)
    {
        hr = SpHrFromLastWin32Error();
        SPDBG_ASSERT(FAILED(hr));
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}   /* SpCreateIsServerAliveEvent */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\include\sapiver.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 *      version.h is created on the fly from verhead.bat and vertail.h,     *
 *      with the current version numbers inserted in between                *
 *                                                                          *
 ****************************************************************************/

#ifndef VER_H
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <winver.h>
#endif
#include <windows.h>
#define VER_FILETYPE                VFT_DLL
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#ifndef VER_FILEDESCRIPTION_STR
#define VER_FILEDESCRIPTION_STR     "SAPI 5"
#endif
#ifndef VER_INTERNALNAME_STR
#define VER_INTERNALNAME_STR        "SAPI5"
#endif

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* this include file is generated by the build process to       */
/* reflect the current build number                             */
/*--------------------------------------------------------------*/

#include "currver.inc"

#define OFFICIAL                    1
#define FINAL                       1

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifdef _DEBUG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS32
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft\256 Windows(TM) Operating System\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\include\spautoobjectlock.h ===
#pragma once

#ifdef __ATLCOM_H__     //--- Only enable these if ATL is being used

class CSPAutoObjectLock
{
  protected:
    CComObjectRootEx<CComMultiThreadModel>* m_pObject;

  public:
    CSPAutoObjectLock(CComObjectRootEx<CComMultiThreadModel> * const pobject)
    {
        m_pObject = pobject;
        m_pObject->Lock();
    };

    ~CSPAutoObjectLock() {
        m_pObject->Unlock();
    };
};

#define SPAUTO_OBJ_LOCK CSPAutoObjectLock lck(this)
#define SPAUTO_OBJ_LOCK_OBJECT( t ) CSPAutoObjectLock lck##__LINE__(t)

#endif // __ATLCOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\include\spsatellite.h ===
/****************************************************************************
*
*   satellite.h
*
*       Support for satellite resource DLLs.
*
*   Owner: cthrash
*
*   Copyright  1999-2000 Microsoft Corporation All Rights Reserved.
*
*****************************************************************************/
#pragma once

//--- Includes --------------------------------------------------------------

#include <sphelper.h>

//--- Forward and External Declarations -------------------------------------

//--- TypeDef and Enumeration Declarations ----------------------------------

//--- Constants -------------------------------------------------------------

//--- Class, Struct and Union Definitions -----------------------------------

class CSpSatelliteDLL
{
    private:

        enum LoadState_t
        {
            LoadState_NotChecked,
            LoadState_Loaded,
            LoadState_NotFound  
        };

#pragma pack(push, LANGANDCODEPAGE, 2)
        struct LangAndCodePage_t
        {
            WORD wLanguage;
            WORD wCodePage;
        };
#pragma pack(pop, LANGANDCODEPAGE)

    private:

        LoadState_t m_eLoadState;
        HINSTANCE   m_hinstRes;   // cached so FreeLibrary can be called;

    public:

        CSpSatelliteDLL() { m_eLoadState = LoadState_NotChecked; m_hinstRes = 0; }
        ~CSpSatelliteDLL() { if (m_hinstRes) { FreeLibrary(m_hinstRes); } }

    public:

        BOOL Checked() const { return LoadState_NotChecked != m_eLoadState; }
        
    public:

        HINSTANCE Load(
            HINSTANCE hinstModule,      // [in] Instance handle of core DLL
            LPCTSTR lpszSatelliteName)  // [in] Satellite DLL name
        {
            HINSTANCE   hinstRes = hinstModule;
            LANGID      langidUI = SpGetUserDefaultUILanguage();
            LANGID      langidModule = 0;
            TCHAR       achPath[MAX_PATH];
            DWORD       cch = GetModuleFileName(hinstModule, achPath, sp_countof(achPath));

            if (cch)
            {
                //
                // First check the locale of the module;
                // If it's the same as the UI, assume it contains language-appropriate resources
                //

                DWORD dwHandle;
                DWORD dwVerInfoSize = GetFileVersionInfoSize(achPath, &dwHandle);

                if (dwVerInfoSize)
                {
                    void * lpBuffer = malloc(dwVerInfoSize);

                    if (lpBuffer)
                    {
                        if (GetFileVersionInfo(achPath, dwHandle, dwVerInfoSize, lpBuffer))
                        {
                            LangAndCodePage_t *pLangAndCodePage;
                            UINT cch;

                            if (VerQueryValue(lpBuffer, TEXT("\\VarFileInfo\\Translation"), (LPVOID *)&pLangAndCodePage, &cch) && cch)
                            {
                                // pay attention only to first entry

                                langidModule = (LANGID)pLangAndCodePage->wLanguage;                        
                            }
                        }

                        free(lpBuffer);
                    }
                }

                //
                // If the languages don't match, look for a resource DLL
                //

                if (langidUI != langidModule)
                {
                    DWORD cchDir;
                    HINSTANCE hinst;

                    // Look for {path}\{lcid}\{dll-name}

                    while (cch && achPath[--cch] != TEXT('\\'));

                    hinst = CheckDLL(achPath, achPath + cch + 1, langidUI, lpszSatelliteName);

                    if (hinst)
                    {
                        hinstRes = hinst; // Found!
                    }
                    else
                    {
                        //
                        // Couldn't find for specified UI langid; try default/netural sublangs.
                        //

                        if (SUBLANGID(langidUI) != SUBLANG_DEFAULT)
                        {
                            hinst = CheckDLL(achPath, achPath + cch + 1, MAKELANGID(PRIMARYLANGID(langidUI), SUBLANG_DEFAULT), lpszSatelliteName);
                        }

                        if (hinst)
                        {
                            hinstRes = hinst; // Found for SUBLANG_DEFAULT!
                        }
                        else if (SUBLANGID(langidUI) != SUBLANG_NEUTRAL)
                        {
                            hinst = CheckDLL(achPath, achPath + cch + 1, MAKELANGID(PRIMARYLANGID(langidUI), SUBLANG_NEUTRAL), lpszSatelliteName);

                            if (hinst)
                            {
                                hinstRes = hinst; // Found for SUBLANG_NEUTRAL!
                            }
                        }
                    }
                }
            }

            if (hinstModule != hinstRes)
            {
                m_hinstRes = hinstRes; // Cache it so the dtor can call FreeLibrary
            }
            
            return hinstRes;
        }

        HINSTANCE Detach(void)
        {
            HINSTANCE hinstRes = m_hinstRes;
            m_hinstRes = NULL;
            return hinstRes;
        }

    private:

        //
        // Check if satellite DLL exist for a particular LANGID
        //
        
        HINSTANCE CheckDLL(
            TCHAR * achPath,            // [in] Complete path of module
            TCHAR * pchDir,             // [in] Path to directory of module (including backslash)
            LANGID langid,              // [in] Language of Satellite DLL
            LPCTSTR lpszSatelliteName)  // [in] Satellite DLL name
        {
            TCHAR * pchSubDir;

            size_t cch;

            // TODO: Verify that the versions are in sync with core DLL?
            
            _itot(langid, pchDir, 10);

            pchSubDir = pchDir + _tcslen(pchDir);

            *pchSubDir++ = TEXT('\\');

            _tcscpy(pchSubDir, lpszSatelliteName);

            return LoadLibrary(achPath);
        }

};

//--- Function Declarations -------------------------------------------------

//--- Inline Function Definitions -------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\include\spautocritseclock.h ===
#pragma once

#ifdef __ATLCOM_H__     //--- Only enable these if ATL is being used

class CSPAutoCritSecLock
{
  protected:
    CComAutoCriticalSection* m_pSec;

  public:
    CSPAutoCritSecLock(CComAutoCriticalSection* pSec)
    {
        m_pSec = pSec;
        m_pSec->Lock();
    };

    ~CSPAutoCritSecLock()
    {
        m_pSec->Unlock();
    };
};

#define SPAUTO_SEC_LOCK( s ) CSPAutoCritSecLock lck##__LINE__(s);

#endif // __ATLCOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\include\sphash.h ===
/****************************************************************************
*	SPHash.h
*       This is modified from sr/include/hash_n.h to minimize dependencies on
*       application specific headers.  
*
*	Owner: bohsu
*	Copyright 2000 Microsoft Corporation All Rights Reserved.
*****************************************************************************/
#pragma once

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN		// Exclude rarely-used stuff from Windows headers
#endif

//--- Includes --------------------------------------------------------------
#include <windows.h>
#include <math.h>
#include <crtdbg.h>
#ifdef _DEBUG
#include <stdio.h>
#endif _DEBUG

//--- Forward and External Declarations -------------------------------------

//--- TypeDef and Enumeration Declarations ----------------------------------

//--- Constants -------------------------------------------------------------

//--- Class, Struct and Union Definitions -----------------------------------

/***********************************************************************
* CSPHash Class
*   This is a templated hash table class.  Note that the base CSPHash class 
*   does not allocate or free the Keys and Values.  To define a hash class
*   that manages its Keys and Values, derive a subclass an overload Add() 
*   and ...
*****************************************************************bohsu*/
template<class KEY, class VALUE>
class CSPHash
{
public:
    // Constructor
    CSPHash(
        VALUE   ValueNIL = NULL,                // Value representing NIL
        UINT32  uInitialSize = 0);              // Initial hash table size

    // Destructor
    virtual ~CSPHash();

    // Returns number of (Key, Value) entries used in the hash table.
    inline UINT32 GetNumEntries(void) const { return m_uNumEntriesUsed; }

    // Returns the next entry starting at the given index.  Set puIndex = 0 for the first entry.
    VALUE GetNextEntry(
        UINT32 *puIndex,                        // Index to start looking for the next entry
        KEY    *pKey = NULL) const;             // [out] Key of the next entry found

    // Resets the content hash table.
    virtual void Reset(void);

    // Adds a (Key, Value) entry to the hash table.
    HRESULT Add(
        KEY     Key,                            // Key to add
        VALUE   Val);                           // Value associated with the Key

    // Lookup a Value based on the Key.  If not found, ValueNIL is returned.
    VALUE Lookup(
        KEY     Key) const;                     // Key to lookup

#ifdef _DEBUG
    // Dumps the hash table statistics to file handle.
    void    DumpStat(
        FILE       *hFile = NULL,               // Output file handle.  NULL -> DebugWindow
        const char *strHeader = NULL) const;    // Trace header
#endif _DEBUG

protected:
    // Data structure containing (Key, Value) pair
    struct ENTRY
    {
        KEY     Key;
        VALUE   Value;
    };

    // Find the index corresponding to the given Key.
    int FindIndex(
        KEY     Key) const;                     // Key to search for

    static UINT32 NextPrime(UINT32 Val);

protected:
    //---------------------------------------------------------------
    //--- The following functions can be overloaded by subclasses ---
    //---------------------------------------------------------------
    //  If Destroy*() is overloaded, you MUST overload the destructor with:
    //      virtual ~CSPDerivedHash() { Reset(); }
    //  Calling Reset() in the base class destructor has no effect because 
    //  the derived subclass will have been destroyed already by the time it
    //  gets to the base class destructor.  Thus, the correct DestroyKey() and
    //  DestroyValue() will never be called.

    // Hash function mapping the Key to a UINT32 index.
    virtual UINT32 HashKey(KEY Key) const          { return (UINT32)Key; }

    // Compare if two Keys are equal.
    virtual bool   AreKeysEqual(KEY Key1, KEY Key2) const { return Key1 == Key2; }

    // Hash function used to determine the skip count.
    virtual UINT32 HashKey2(KEY Key) const         { return 1; }

    // Overload if a deep copy of the Key needs to be made in Add().
    virtual KEY    CopyKey(KEY Key) const          { return Key; }

    // Overload if a deep copy of the Key needs to be made in Add().
    virtual VALUE  CopyValue(VALUE Value) const    { return Value;  }

    // Overload if the Key needs to be destroyed.
    virtual void   DestroyKey(KEY Key) const       { }

    // Overload if the Value needs to be destroyed.
    virtual void   DestroyValue(VALUE Value) const { }

    //------------------------
    //--- Member Variables ---
    //------------------------
protected:
    ENTRY  *m_aTable;                           // Hash table containing (Key, Value) pairs
    VALUE   m_ValueNIL;                         // Value representing NIL
    UINT32  m_uNumEntries;                      // Current size of hash table
    UINT32  m_uNumEntriesInit;                  // Initial size of hash table
    UINT32  m_uNumEntriesUsed;                  // Current number of entries used in hash table

#ifdef _DEBUG
    UINT32  m_uAccess;                          // Number of times a Key is looked up
    UINT32  m_uSearch;                          // Number of times a entry in the table is searched
    UINT32  m_uRegrow;                          // Number of times the hash table regrew
#endif _DEBUG
};


/***********************************************************************
* CSPStringHashW Class
*   CSPStringHashW is a hash of UNICODE strings to VALUEs.  The UNICODE string
*   is treated as a constant.  It is neither copied during Add() nor deleted
*   during destructor.  Likewise, VALUE is treated as a simple data type and
*   is neither copied nor destroyed.  If the application wants the class to 
*   manage its own copy of the string key or VALUE, derive a subclass and 
*   overload Copy*() and/or Destroy().
*****************************************************************bohsu*/
template<class VALUE> class CSPStringHashW : public CSPHash<const WCHAR *, VALUE> 
{ 
protected:
    UINT32 StringHashW(const WCHAR *wcsKey, UINT32 uPrime) const
    {
        UINT32  uHashIndex = 0;
	    for(const WCHAR *pwch = wcsKey; *pwch != NULL; pwch++)
            uHashIndex = uHashIndex * uPrime + *pwch;
        return uHashIndex;
    }

    //--- Overloaded functions ---
protected:
    virtual UINT32 HashKey(const WCHAR* wcsKey) const  { return StringHashW(wcsKey, 65599); }
    virtual UINT32 HashKey2(const WCHAR* wcsKey) const { return StringHashW(wcsKey, 257); }
    virtual bool AreKeysEqual(const WCHAR* wcsKey1, const WCHAR* wcsKey2) const
    { 
        return wcscmp(wcsKey1, wcsKey2) == 0; 
    }
};
 
/***********************************************************************
* CSPGUIDHash Class
*   CSPGUIDHash is a hash of GUIDs to VALUEs.  The GUID pointer is treated 
*   as a constant.  It is neither copied during Add() nor deleted
*   during destructor.  Likewise, VALUE is treated as a simple data type and
*   is neither copied nor destroyed.  If the application wants the class to 
*   manage its own copy of the GUID key or VALUE, derive a subclass and 
*   overload Copy*() and/or Destroy().
*****************************************************************bohsu*/
template<class VALUE> class CSPGUIDHash : public CSPHash<const GUID *, VALUE> 
{ 
    //--- Overloaded functions ---
protected:
    virtual UINT32 HashKey(const GUID *pguidKey) const  { return pguidKey->Data1; }
    virtual UINT32 HashKey2(const GUID *pguidKey) const { return pguidKey->Data2; }
    virtual bool AreKeysEqual(const GUID *pguidKey1, const GUID *pguidKey2) const
    { 
        // It is annoying that operator== for GUIDs return int (BOOL) instead of bool.
        return (*pguidKey1 == *pguidKey2) != 0; 
    }
};

//--- Function Declarations -------------------------------------------------

//--- Inline Function Definitions -------------------------------------------

/**********************************************************************
* CSPHash::CSPHash *
*------------------*
*	Description:  
*       Constructor.
****************************************************************bohsu*/
template<class KEY, class VALUE>
CSPHash<KEY, VALUE>::CSPHash(
    VALUE   ValueNIL,                       // Value representing NIL
    UINT32  uInitialSize)                   // Initial hash table size
{
    m_ValueNIL        = ValueNIL;
    m_aTable          = 0;
    m_uNumEntries     = 0;
    m_uNumEntriesInit = uInitialSize;       // Estimated final number of entries to be stored.
    m_uNumEntriesUsed = 0;

#ifdef _DEBUG
    m_uAccess = 0;
    m_uSearch = 0;
    m_uRegrow = 0;
#endif _DEBUG
}

/**********************************************************************
* CSPHash::~CSPHash *
*-------------------*
*	Description:  
*       Destructor.  This does not free KEY and VALUE.
*       If Destroy*() is overloaded, call Reset() in the subclass destructor.
****************************************************************bohsu*/
template<class KEY, class VALUE>
CSPHash<KEY, VALUE>::~CSPHash()
{
    delete [] m_aTable;
}

/**********************************************************************
* CSPHash::GetNextEntry *
*-----------------------*
*	Description:  
*       Returns the next entry starting at the given index.  Set puIndex = 0 for the first entry.
****************************************************************bohsu*/
template<class KEY, class VALUE>
VALUE CSPHash<KEY, VALUE>::GetNextEntry(
    UINT32 *puIndex,                        // Index to start looking for the next entry
    KEY    *pKey) const                     // [out] Key of the next entry found
{
    while (*puIndex < m_uNumEntries)
    {
        if (m_aTable[*puIndex].Value != m_ValueNIL)
        {
            if(pKey) *pKey = m_aTable[*puIndex].Key;
            return m_aTable[(*puIndex)++].Value;
        }
        ++*puIndex;
    }
    return m_ValueNIL;
}

/**********************************************************************
* CSPHash::Reset *
*----------------*
*	Description:  
*       Resets the content hash table.
****************************************************************bohsu*/
template<class KEY, class VALUE>
void CSPHash<KEY, VALUE>::Reset()
{
    for (UINT32 i=0; i < m_uNumEntries; i++)
    {
        if(m_aTable[i].Value != m_ValueNIL)
        {
            DestroyKey(m_aTable[i].Key);
            DestroyValue(m_aTable[i].Value);
            m_aTable[i].Value = m_ValueNIL;
        }
    }
    
    m_uNumEntriesUsed = 0;
#ifdef _DEBUG
    m_uAccess = m_uSearch = m_uRegrow = 0;    
#endif _DEBUG
}

/**********************************************************************
* CSPHash::Add *
*--------------*
*	Description:  
*       Adds a (Key, Value) entry to the hash table.
****************************************************************bohsu*/
template<class KEY, class VALUE>
HRESULT CSPHash<KEY, VALUE>::Add(
    KEY     Key,                            // Key to add
    VALUE   Val)                            // Value associated with the Key
{
    int ientry;

    // Implementation uses Val==m_ValueNIL to detect empty entries.
    _ASSERTE(Val != m_ValueNIL);

    // Grow if allowed and we're more than half full.
    // (Also handles initial alloc)
    if (m_uNumEntriesUsed * 2 >= m_uNumEntries)
    {
        /* half-full, too crowded ==> regrow */
        ENTRY * oldtable = m_aTable;
        UINT32 oldentry = m_uNumEntries;
        UINT32 prime = NextPrime(max(m_uNumEntriesUsed * 3 + 17, m_uNumEntriesInit));

#ifdef _DEBUG
        m_uRegrow++;
#endif _DEBUG

        // Alloc new table.
        m_aTable = new ENTRY[prime];
        if (m_aTable == NULL)
        {
            m_aTable = oldtable;
            return E_OUTOFMEMORY;
        }

        for (UINT32 i=0; i < prime; i++)
        {
            m_aTable[i].Value = m_ValueNIL;
        }

        m_uNumEntries = prime;

        for (i = 0; i < oldentry; i++)
        {
            if (oldtable[i].Value != m_ValueNIL)
            {
                ientry = FindIndex(oldtable[i].Key);
                _ASSERTE(ientry >= 0 && m_aTable[ientry].Value == m_ValueNIL);
                m_aTable[ientry] = oldtable[i];
            }
        }
        delete [] oldtable;
    }

    // Find out where this element should end up.
    ientry = FindIndex(Key);
    if (ientry < 0)
        return E_FAIL;  // Too full

    if (m_aTable[ientry].Value == m_ValueNIL)
    {
        // Not already there.  Add it.
        m_aTable[ientry].Key = CopyKey(Key);
        m_aTable[ientry].Value = CopyValue(Val);

        m_uNumEntriesUsed++;
    }
    else
    {
        return S_FALSE; // It was already there.
    }

    return S_OK;
}

/**********************************************************************
* CSPHash::Lookup *
*-----------------*
*	Description:  
*       Lookup a Value based on the Key.  If not found, ValueNIL is returned.
****************************************************************bohsu*/
template<class KEY, class VALUE>
VALUE CSPHash<KEY, VALUE>::Lookup(
    KEY     Key) const                      // Key to lookup
{
    int ientry = FindIndex(Key);
    if (ientry < 0)
        return m_ValueNIL;

    return m_aTable[ientry].Value;
}

#ifdef _DEBUG
/**********************************************************************
* CSPHash::DumpStat *
*-------------------*
*	Description:  
*       Dumps the hash table statistics to file handle.
****************************************************************bohsu*/
template<class KEY, class VALUE>
void CSPHash<KEY, VALUE>::DumpStat(
    FILE       *hFile,                      // Output file handle.
    const char *strHeader) const            // Trace header
{
    if(hFile == NULL)
    {
        char buf[100];

        sprintf(buf, "(%s) hash statistics:\n", strHeader ? strHeader : "");
        OutputDebugString(buf);
        sprintf(buf, "load=%d/%d = %.3g, regrow = %d\n", m_uNumEntriesUsed, m_uNumEntries,
               (m_uNumEntries == 0) ? 0 : (float)m_uNumEntriesUsed/(float)m_uNumEntries, m_uRegrow);
        OutputDebugString(buf);
        sprintf(buf, "access %d/%d = %g\n\n", m_uSearch, m_uAccess,
               (m_uAccess == 0) ? 0 :
               (float) m_uSearch / (float) m_uAccess);
        OutputDebugString(buf);
    }
    else
    {
        fprintf(hFile, "(%s) hash statistics:\n", strHeader ? strHeader : "");
        fprintf(hFile, "load=%d/%d = %.3g, regrow = %d\n", m_uNumEntriesUsed, m_uNumEntries,
               (m_uNumEntries == 0) ? 0 : (float)m_uNumEntriesUsed/(float)m_uNumEntries, m_uRegrow);
        fprintf(hFile, "access %d/%d = %g\n\n", m_uSearch, m_uAccess,
               (m_uAccess == 0) ? 0 :
               (float) m_uSearch / (float) m_uAccess);
    }
}
#endif _DEBUG

/**********************************************************************
* CSPHash::FindIndex *
*--------------------*
*	Description:  
*       Find the index corresponding to the given Key.
****************************************************************bohsu*/
template<class KEY, class VALUE>
int CSPHash<KEY, VALUE>::FindIndex(
    KEY     Key) const
{
#ifdef _DEBUG
    // Hack: Violate const declaration for statistics member variables
    const_cast<CSPHash *>(this)->m_uAccess++;
#endif _DEBUG

    if (m_uNumEntries == 0)
        return -1;

    UINT32 start = HashKey(Key) % m_uNumEntries;
    UINT32 index = start;

    UINT32 skip = 0;

    do
    {
#ifdef _DEBUG
        // Hack: Violate const declaration for statistics member variables
        const_cast<CSPHash *>(this)->m_uSearch++;
#endif _DEBUG

        // Not in table; return index where it should be placed.
        if (m_aTable[index].Value == m_ValueNIL)
            return index;

        if (AreKeysEqual(m_aTable[index].Key, Key))
            return index;

        if (skip == 0)
        {
            skip = HashKey2(Key);

            // Limit skip amount to non-zero and less than hash table size.
            // Since m_uNumEntries is prime, they are relatively prime and so we're guaranteed
            // to visit every bucket.
            if (m_uNumEntries > 1)
                skip = skip % (m_uNumEntries - 1) + 1;
        }

        index += skip;
        if (index >= m_uNumEntries)
            index -= m_uNumEntries;
    } while (index != start);

    _ASSERTE(m_uNumEntriesUsed == m_uNumEntries);
    return -1; /* all full and not found */
}

/**********************************************************************
* CSPHash::NextPrime *
*--------------------*
*	Description:  
*	    Return a prime number greater than or equal to Val.
*       If overflow occurs, return 0.
*
*   To Do: This function can be optimized significantly.
****************************************************************bohsu*/
template<class KEY, class VALUE>
UINT32 CSPHash<KEY, VALUE>::NextPrime(UINT32 Val) 
{
    UINT32      maxFactor;
    UINT32      i;
    
    if (Val < 2) return 2;                          // the smallest prime number    
    while(Val < 0xFFFFFFFF) 
    {        
        maxFactor = (UINT32) sqrt ((double) Val);   // Is Val a prime number?
        
        for (i = 2; i <= maxFactor; i++)            // Is i a factor of Val?
            if (Val % i == 0) break;
            
        if (i > maxFactor) return (Val);            
        Val++;
    };
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\include\sptrycritsec.h ===
class CTryableCriticalSection
{
    public:

        CTryableCriticalSection();
        ~CTryableCriticalSection();

    public:

        void Lock();
        void Unlock();
        BOOL TryLock();

    private:

        BOOL TryLockPrivate(BOOL fTakeAlways);

    private:

        CRITICAL_SECTION    m_csInner;
        CRITICAL_SECTION    m_csOuter;
        LONG                m_cRefs;
};

inline CTryableCriticalSection::CTryableCriticalSection()
{
    InitializeCriticalSection(&m_csInner);
    InitializeCriticalSection(&m_csOuter);
    m_cRefs = 0;
}

inline CTryableCriticalSection::~CTryableCriticalSection()
{
    DeleteCriticalSection(&m_csOuter);
    DeleteCriticalSection(&m_csInner);
}

inline void CTryableCriticalSection::Lock()
{
    TryLockPrivate(TRUE);
}

inline void CTryableCriticalSection::Unlock()
{
    LeaveCriticalSection(&m_csInner);

    InterlockedDecrement(&m_cRefs);
}

inline BOOL CTryableCriticalSection::TryLock()
{
    return TryLockPrivate(FALSE);
}

inline BOOL CTryableCriticalSection::TryLockPrivate(BOOL fTakeAlways)
{
    BOOL fLocked = FALSE;
    
    EnterCriticalSection(&m_csOuter);

    if (fTakeAlways || !m_cRefs)
    {
        fLocked = TRUE;
        InterlockedIncrement(&m_cRefs);

        EnterCriticalSection(&m_csInner);
    }

    LeaveCriticalSection(&m_csOuter);

    return fLocked;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\include\spunicode.h ===
/*******************************************************************************
* SPUnicode.H *
*--------------*
*   Description:
*       This is the header file for core helper functions implementation.
*       It is internal to Microsoft and is NOT shipped with the SDK since
*       many of the functions contatined in this file have not been fully
*       tested and therefore should not be exposed in the SDK.    
*-------------------------------------------------------------------------------
*   Copyright (c) Microsoft Corporation. All rights reserved.
*******************************************************************************/


#ifndef __SPUNICODE_H__
#define __SPUNICODE_H__

#ifndef SPHelper_h
#include <sphelper.h>
#endif

template <const int i = MAX_PATH>
class CSpToAnsiString
{
private:
    CHAR *  m_pStr;
    CHAR    m_aString[i];
public:
    CSpToAnsiString(const WCHAR * psz)
    {
        if (psz)
        {
            m_pStr = m_aString;
            ::WideCharToMultiByte(CP_ACP, 0, psz, -1, m_aString, i, NULL, NULL);
        }
        else
        {
            m_pStr = NULL;
        }
    }
    operator CHAR *() { return m_pStr; }
    CHAR * operator =(const WCHAR * psz)
    {
        if (psz)
        {
            m_pStr = m_aString;
            ::WideCharToMultiByte(CP_ACP, 0, psz, -1, m_aString, i, NULL, NULL);
        }
        else
        {
            m_pStr = NULL;
        }
        return m_pStr;
    }
};



#ifndef _WIN32_WCE

//
//  The compiler will automatically throw out the inline functions if _UNICODE is defined and simply
//  directly call the Win32 function.  Unfortunately, this requires two classes since simply defining
//  const m_bUnicodeSupport does not force the functions to be inlined when built with _UNICODE.
//
template <BOOL bUnicodeOnly>
class CSpUnicodeSupportT
{
    BOOL    m_bUnicodeSupport;
public:
    CSpUnicodeSupportT()
    {
        if (!bUnicodeOnly)
        {
            // On NT-based systems, we can always set this to true. 
            // Thus this whole file becomes a pass through and in post .Net Server branches has been removed.
            //m_bUnicodeSupport = ::IsWindowUnicode(::GetDesktopWindow());
            m_bUnicodeSupport = TRUE;
        }
    }
    CSpUnicodeSupportT(BOOL bUnicodeSupport)
    {
        if (bUnicodeOnly)
        {
            SPDBG_ASSERT(bUnicodeSupport);
        }
        else
        {
            m_bUnicodeSupport = bUnicodeSupport;
        }
    }
    BOOL UnicodeSystem(void) const 
    {
        if (bUnicodeOnly)
        {
            return TRUE;
        }
        else
        {
            return m_bUnicodeSupport; 
        }
    }
    HANDLE CreateFile(const WCHAR * lpFileName,      
                      DWORD dwDesiredAccess,       
                      DWORD dwShareMode,           
                      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                      DWORD dwCreationDisposition, 
                      DWORD dwFlagsAndAttributes,  
                      HANDLE hTemplateFile) const         
    {
        if (UnicodeSystem())
        {
            return ::CreateFileW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, 
                                 dwFlagsAndAttributes, hTemplateFile);
        }
        else
        {
            return ::CreateFileA(CSpToAnsiString<>(lpFileName), dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition, 
                                 dwFlagsAndAttributes, hTemplateFile);
        }
    }
    DWORD GetFullPathName(WCHAR *lpFileName,  // file name
                          DWORD nBufferLength, // size of path buffer
                          WCHAR *lpBuffer,     // path buffer
                          WCHAR **lpFilePart   // address of file name in path
                          )
    {
        if (UnicodeSystem())
        {
            return ::GetFullPathNameW(lpFileName, nBufferLength, lpBuffer, lpFilePart);
        }
        else
        {
            CHAR szTemp[MAX_PATH];
            CHAR *szTempFilePart;
            DWORD tmp = ::GetFullPathNameA(CSpToAnsiString<>(lpFileName), sp_countof(szTemp), szTemp, &szTempFilePart);
            if (tmp)
            {
                tmp = ::MultiByteToWideChar(CP_ACP, 0, szTemp, -1, lpBuffer, nBufferLength);
                lpBuffer[tmp] = 0;
                *lpFilePart = lpBuffer + (szTempFilePart - szTemp);
            }
            return tmp;
        }
    }

    BOOL DeleteFile(LPCWSTR lpFileName)
    {
        if (UnicodeSystem())
        {
            return ::DeleteFileW(lpFileName);
        }
        else
        {
            return ::DeleteFileA(CSpToAnsiString<>(lpFileName));
        }
    }
    BOOL MoveFile(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
    {
        if (UnicodeSystem())
        {
            return ::MoveFileW(lpExistingFileName, lpNewFileName);
        }
        else
        {
            return ::MoveFileA(CSpToAnsiString<>(lpExistingFileName), CSpToAnsiString<>(lpNewFileName));
        }
    }
    BOOL CopyFile(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
    {
        if (UnicodeSystem())
        {
            return ::CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);
        }
        else
        {
            return ::CopyFileA(CSpToAnsiString<>(lpExistingFileName), CSpToAnsiString<>(lpNewFileName), bFailIfExists);
        }
    }
    BOOL CreateDirectory(const WCHAR * lpPathName,
                           LPSECURITY_ATTRIBUTES lpSecurityAttributes) const
    {
        if (UnicodeSystem())
        {
            return ::CreateDirectoryW(lpPathName, lpSecurityAttributes);
        }
        else
        {
            return ::CreateDirectoryA(CSpToAnsiString<>(lpPathName), lpSecurityAttributes);
        }
    }
    BOOL RemoveDirectory(const WCHAR * lpPathName) const
    {
        if (UnicodeSystem())
        {
            return ::RemoveDirectoryW(lpPathName);
        }
        else
        {
            return ::RemoveDirectoryA(CSpToAnsiString<>(lpPathName));
        }
    }
    HANDLE CreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect,
                             DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, const WCHAR *lpName)
    {
        if (UnicodeSystem())
        {
            return ::CreateFileMappingW(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, 
                                        dwMaximumSizeLow, lpName);
        }
        else
        {
            return ::CreateFileMappingA(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, 
                                        dwMaximumSizeLow, CSpToAnsiString<>(lpName));
        }
    }
    BOOL SetFileAttributes(LPCWSTR lpFileName, DWORD dwFileAttributes)
    {
        if (UnicodeSystem())
        {
            return ::SetFileAttributesW(lpFileName, dwFileAttributes);
        }
        else
        {
            return ::SetFileAttributesA(CSpToAnsiString<>(lpFileName), dwFileAttributes);
        }
    }
    DWORD GetFileAttributes(LPCWSTR lpFileName)
    {
        if (UnicodeSystem())
        {
            return ::GetFileAttributesW(lpFileName);
        }
        else
        {
            return ::GetFileAttributesA(CSpToAnsiString<>(lpFileName));
        }
    }
    LONG RegOpenKeyEx(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult) const
    {
        if (UnicodeSystem())
        {
            return ::RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);
        }
        else
        {
            return ::RegOpenKeyExA(hKey, CSpToAnsiString<>(lpSubKey), ulOptions, samDesired, phkResult);
        }
    }
    LONG RegCreateKeyEx(HKEY hk, LPCWSTR lpSubKey, DWORD dwReserved, LPCWSTR lpClass, DWORD dwOptions,
                        REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, 
                        LPDWORD lpdwDisposition) const
    {
        if (UnicodeSystem())
        {
            return ::RegCreateKeyExW(hk, lpSubKey, dwReserved, const_cast<WCHAR *>(lpClass), dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
        }
        else
        {
            return ::RegCreateKeyExA(hk, CSpToAnsiString<>(lpSubKey), dwReserved, CSpToAnsiString<>(lpClass), dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
        }
    }
    LONG RegDeleteKey(HKEY hKey, LPCWSTR lpSubKey) const
    {
        if (UnicodeSystem())
        {
            return ::RegDeleteKeyW(hKey, lpSubKey);
        }
        else
        {
            return ::RegDeleteKeyA(hKey, CSpToAnsiString<>(lpSubKey));
        }
    }
    LONG RegDeleteValue(HKEY hKey, LPCWSTR lpSubKey) const
    {
        if (UnicodeSystem())
        {
            return ::RegDeleteValueW(hKey, lpSubKey);
        }
        else
        {
            return ::RegDeleteValueA(hKey, CSpToAnsiString<>(lpSubKey));
        }
    }
    //
    //  Use RegQueryStringValue for strings.  Use this for binary data.
    //
    LONG RegQueryValueEx(HKEY hk, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData) const
    {
        if (UnicodeSystem())
        {
            return ::RegQueryValueExW(hk, lpValueName, NULL, lpType, lpData, lpcbData);
        }
        else
        {
            return ::RegQueryValueExA(hk, CSpToAnsiString<>(lpValueName), NULL, lpType, lpData, lpcbData);
        }
    }
    //
    //  NOTE:  The size parameter is in CHARACTERS!  Even though the registry API sizes are
    //         in bytes, this function uses character counts.
    //
    LONG RegQueryStringValue(HKEY hKey, LPCWSTR lpValueName, LPWSTR lpData, LPDWORD lpcchData) const
    {
        DWORD dwType;
        LONG rr;
        if (UnicodeSystem())
        {
            *lpcchData *= sizeof(WCHAR);
            rr = ::RegQueryValueExW(hKey, lpValueName, NULL, &dwType, (BYTE *)lpData, lpcchData);
            *lpcchData /= sizeof(WCHAR);
        }
        else
        {
            DWORD dwOrigCharCount = *lpcchData;
            char * pszScratch = lpData ? (char *)_alloca(dwOrigCharCount) : NULL;
            rr = ::RegQueryValueExA(hKey, CSpToAnsiString<>(lpValueName), NULL, &dwType, (BYTE *)pszScratch, lpcchData);
            if (lpData)
            {
                if (rr == ERROR_SUCCESS)
                {
                    DWORD dwReturnedChars = *lpcchData;
                    *lpcchData = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, dwReturnedChars, lpData, dwOrigCharCount);
                    if (*lpcchData == 0)
                    {
                        rr = ::GetLastError();
                        *lpcchData = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, dwReturnedChars, NULL, 0);
                    }
                }
            }
        }
        if (rr == ERROR_SUCCESS && dwType == REG_MULTI_SZ && lpData && *lpcchData)
        {
            // This is used by Whistler setup to overcome string size limits for REG_SZ.
            // Unfortunately, leaves a zero-byte inbetween concatenated strings.
            // Must remove these entries. Can do this in situ.
            LPWSTR lpTo   = lpData;
            LPWSTR lpFrom = lpData;
            while ( static_cast<UINT>(lpFrom-lpData) < ((*lpcchData)-1) )
            {
                if ( *lpFrom == 0 )
                {
                    lpFrom ++;
                }
                // This will copy the 2nd zero of a double null-terminated string.
                *lpTo = *lpFrom;
                lpTo ++;
                lpFrom ++;
            }
            if ( static_cast<UINT>(lpFrom-lpData) < (*lpcchData) )
            {
                // This will copy the final null-terminating byte of a single-zero terminated string.
                *lpTo = *lpFrom;
            }
            // Update character count to match new string including null-terminator.
            *lpcchData = static_cast<UINT>(lpTo-lpData) + 1;
        }
        SPDBG_ASSERT((rr != ERROR_SUCCESS) || (dwType == REG_SZ) || (dwType == REG_MULTI_SZ));
        return rr;
    }
    //
    //  NOTES: Size is in Characters for lpcchName.  Although this function uses RegEnumKeyEx, we chose to simply
    //         implement the ReqEnumKey functionality since the Ex functionality is not used
    //         by most programs (this saves a bunch of string conversion code).
    //
    LONG RegEnumKey(HKEY hk, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName) const
    {
        if (UnicodeSystem())
        {
            return ::RegEnumKeyExW(hk, dwIndex, lpName, lpcchName, NULL, NULL, NULL, NULL);
        }
        else
        {
            DWORD dwSize = *lpcchName;
            char * pszScratch = lpName ? (char *)_alloca(dwSize) : NULL;
            LONG rr = ::RegEnumKeyExA(hk, dwIndex, pszScratch, &dwSize, NULL, NULL, NULL, NULL);
            if (lpName)
            {
                if (rr == ERROR_SUCCESS)
                {
                    *lpcchName = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, -1, lpName, *lpcchName);
                    if (*lpcchName == 0)
                    {
                        *lpcchName = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, -1, NULL, 0);
                        rr = ::GetLastError();
                    }
                    *lpcchName *= sizeof(WCHAR);
                }
            }
            else
            {
                *lpcchName = dwSize;
            }
            return rr;
        }
    }
    //
    //  NOTES: Size is in Characters for lpcchName.  Although this function uses RegEnumValue
    //         it will only return the names, not the data.  cbValueName is the count of characters
    //
    LONG RegEnumValueName(HKEY hk, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName) const
    {
        if (UnicodeSystem())
        {
            return ::RegEnumValueW(hk, dwIndex, lpName, lpcchName, NULL, NULL, NULL, NULL);
        }
        else
        {
            DWORD dwSize = *lpcchName;
            char * pszScratch = lpName ? (char *)_alloca(dwSize) : NULL;
            LONG rr = ::RegEnumValueA(hk, dwIndex, pszScratch, &dwSize, NULL, NULL, NULL, NULL);
            if (lpName)
            {
                if (rr == ERROR_SUCCESS)
                {
                    *lpcchName = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, -1, lpName, *lpcchName);
                    if (*lpcchName == 0)
                    {
                        *lpcchName = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, -1, NULL, 0);
                        rr = ::GetLastError();
                    }
                    *lpcchName *= sizeof(WCHAR);
                }
            }
            else
            {
                *lpcchName = dwSize;
            }
            return rr;
        }
    }
    //
    //  Don't use this for strings.  Use RegSetStringValue instead.
    //
    LONG RegSetValueEx(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE * lpData, DWORD cbData) const
    {
        if (UnicodeSystem())
        {
            return ::RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData);
        }
        else
        {
            return ::RegSetValueExA(hKey, CSpToAnsiString<>(lpValueName), Reserved, dwType, lpData, cbData);
        }
    }
    LONG RegSetStringValue(HKEY hKey, LPCWSTR lpValueName, LPCWSTR lpData) const
    {
        LONG rr;
        DWORD dwSize = (wcslen(lpData)+1) * sizeof(WCHAR);
        if (UnicodeSystem())
        {
            rr = ::RegSetValueExW(hKey, lpValueName, NULL, REG_SZ, (const BYTE *)lpData, dwSize);
        }
        else
        {
            char * pszScratch = (char *)_alloca(dwSize);
            dwSize = ::WideCharToMultiByte(CP_ACP, 0, lpData, -1, pszScratch, dwSize, NULL, NULL);
            rr = ::RegSetValueExA(hKey, CSpToAnsiString<>(lpValueName), NULL, REG_SZ, (BYTE *)pszScratch, dwSize);
        }
        return rr;
    }
    HANDLE CreateEvent(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName) const
    {
        if (UnicodeSystem())
        {
            return ::CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpName);
        }
        else
        {
            return ::CreateEventA(lpEventAttributes, bManualReset, bInitialState, CSpToAnsiString<>(lpName)); 
        }
    }
    HANDLE CreateMutex(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName) const
    {
        if (UnicodeSystem())
        {
            return ::CreateMutexW(lpMutexAttributes, bInitialOwner, lpName);
        }
        else
        {
            return ::CreateMutexA(lpMutexAttributes, bInitialOwner, CSpToAnsiString<>(lpName)); 
        }
    }
    int LoadString(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBuffer) const
    {
        if (bUnicodeOnly)   // NOTE:  If the DLL is built ANSI then use ANSI load!
        {
            return ::LoadStringW(hInstance, uID, lpBuffer, nBuffer);
        }
        else
        {
            char * pszScratch = (char *)_alloca(nBuffer * 2);
            int r = ::LoadStringA(hInstance, uID, pszScratch, nBuffer * 2);
            if (r)
            {
                r = ::MultiByteToWideChar(CP_ACP, 0, pszScratch, -1, lpBuffer, nBuffer);
            }
            else
            {
                *lpBuffer = 0;
            }
            return r;
        }
    }
    HMODULE LoadLibrary( LPCWSTR lpLibFileName )
    {
        if ( UnicodeSystem() )
        {
            return ::LoadLibraryW( lpLibFileName );
        }
        else
        {
            return ::LoadLibraryA( CSpToAnsiString<>(lpLibFileName) );
        }
    }
    HMODULE LoadLibraryEx(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
    {
        if (UnicodeSystem())
        {
            return ::LoadLibraryExW(lpLibFileName, hFile, dwFlags);
        }
        else
        {
            return ::LoadLibraryExA(CSpToAnsiString<>(lpLibFileName), hFile, dwFlags);
        }
    }
    HRSRC FindResourceEx(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage)
    {
        if (UnicodeSystem())
        {
            return ::FindResourceExW(hModule, lpType, lpName, wLanguage);
        }
        else
        {
            return ::FindResourceExA(hModule,
                                     HIWORD(lpType) ? CSpToAnsiString<>(lpType) : (const CHAR *) lpType,
                                     HIWORD(lpName) ? CSpToAnsiString<>(lpName) : (const CHAR *) lpName,
                                     wLanguage);
        }
    }
    DWORD GetModuleFileName(HMODULE hModule, LPWSTR lpFileName, DWORD nSize) const
    {
        if (UnicodeSystem())
        {
            return ::GetModuleFileNameW(hModule, lpFileName, nSize);
        }
        else
        {
            CHAR szFileName[MAX_PATH];
            DWORD r = ::GetModuleFileNameA(hModule, szFileName, sp_countof(szFileName));
            if (r)
            {
                r = ::MultiByteToWideChar(CP_ACP, 0, szFileName, r, lpFileName, nSize - 1);
                lpFileName[r] = 0;
            }
            return r;
        }
    }
    UINT GetSystemDirectory( LPWSTR lpBuffer, UINT uSize )
    {
        if (UnicodeSystem())
        {
            return ::GetSystemDirectoryW( lpBuffer, uSize );
        }
        else
        {
            CHAR szSystemDirectory[ MAX_PATH ];
            DWORD r = ::GetSystemDirectoryA(szSystemDirectory, sp_countof( szSystemDirectory ));
            if ( r )
            {
                r = ::MultiByteToWideChar( CP_ACP, 0, szSystemDirectory, r, lpBuffer, uSize - 1 );
                lpBuffer[r] = 0;
            }
            return r;
        }
    }
    DWORD SearchPath( LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR *lpFilePart )
    {
        if (UnicodeSystem())
        {
            return ::SearchPathW( lpPath, lpFileName, lpExtension, nBufferLength, lpBuffer, lpFilePart );
        }
        else
        {
            CHAR szFoundFile[ MAX_PATH ];
            LPSTR lpaFilePart = NULL;
            LPSTR lpaPath = strdup( CSpToAnsiString<>(lpPath) );
            LPSTR lpaFileName = strdup( CSpToAnsiString<>(lpFileName) );

            DWORD r = ::SearchPathA( CSpToAnsiString<>(lpPath), CSpToAnsiString<>(lpFileName), 
                CSpToAnsiString<>(lpExtension), sp_countof( szFoundFile ), szFoundFile, &lpaFilePart );
            if ( r )
            {
                r = ::MultiByteToWideChar( CP_ACP, 0, szFoundFile, r, lpBuffer, nBufferLength - 1 );
                lpBuffer[r] = 0;
            }
            if ( r )
            {
                // Find out how many wide characters are in the file part
                int cchFilePartW = ::MultiByteToWideChar( CP_ACP, 0, lpaFilePart, 
                    strlen( szFoundFile ) - (lpaFilePart - szFoundFile),
                    NULL, 0 );
                *lpFilePart = lpBuffer + wcslen( lpBuffer ) - cchFilePartW;
            }

            if ( lpaPath )
            {
                free( lpaPath );
            }
            if ( lpaFileName )
            {
                free( lpaFileName );
            }

            return r;
        }
    }
    int CompareString(LCID Locale, DWORD dwCmpFlags, LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2)
    {
        if (UnicodeSystem())
        {
            return ::CompareStringW(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
        }
        else
        {
            return ::CompareStringA(Locale, dwCmpFlags, CSpToAnsiString<>(lpString1), cchCount1, 
                                    CSpToAnsiString<>(lpString2), cchCount2);
        }
    }

    BOOL SetWindowText( HWND hWnd, LPCWSTR lpString )
    {
        if ( UnicodeSystem() )
        {
            return ::SetWindowTextW( hWnd, lpString );
        }
        else
        {
            return ::SetWindowTextA( hWnd, CSpToAnsiString<>(lpString) );
        }
    }

    BOOL SetDlgItemText(HWND hDlg, int nIDDlgItem, LPCWSTR lpString )
    {
        if ( UnicodeSystem() )
        {
            return ::SetDlgItemTextW( hDlg, nIDDlgItem, lpString );
        }
        else
        {
            return ::SetDlgItemTextA( hDlg, nIDDlgItem, CSpToAnsiString<>(lpString) );
        }
    }

    int MessageBox( HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType )
    {
        if ( UnicodeSystem() )
        {
            return ::MessageBoxW( hWnd, lpText, lpCaption, uType );
        }
        else
        {
            return ::MessageBoxA( hWnd, CSpToAnsiString<>(lpText), 
                CSpToAnsiString<>(lpCaption), uType );
        }   
    }

    int GetLocaleInfo( LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData )
    {
        if ( UnicodeSystem() )
        {
            return ::GetLocaleInfoW( Locale, LCType, lpLCData, cchData );
        }
        else
        {
            int cchNeeded = ::GetLocaleInfoA( Locale, LCType, NULL, 0 );

            CHAR *pszLCData = new CHAR[ cchNeeded ];
            int r = ::GetLocaleInfoA( Locale, LCType, pszLCData, cchNeeded );
            if ( r ) 
            {
                if ( lpLCData )
                {
                    r = ::MultiByteToWideChar(CP_ACP, 0, pszLCData, r, lpLCData, cchData - 1);
                    lpLCData[r] = 0;
                }
                else
                {
                    // User wants to know how much space is needed
                    r = ::MultiByteToWideChar(CP_ACP, 0, pszLCData, r, NULL, 0 ) + 1;
                }
            }

            delete[] pszLCData;
            return r;
        }
    }

    int GetTimeFormat( LCID Locale, DWORD dwFlags, CONST SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime )
    {
        if ( UnicodeSystem() )
        {
            return ::GetTimeFormatW( Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime );
        }
        else
        {
            LPSTR lpaFormat = strdup( CSpToAnsiString<>(lpFormat) );

            int cchNeeded = ::GetTimeFormatA( Locale, dwFlags, lpTime, lpaFormat, NULL, 0 );

            CHAR *pszTime = new CHAR[ cchNeeded ];
            int r = ::GetTimeFormatA( Locale, dwFlags, lpTime, lpaFormat, pszTime, cchNeeded );
            if ( r ) 
            {
                if ( lpTimeStr )
                {
                    r = ::MultiByteToWideChar(CP_ACP, 0, pszTime, r, lpTimeStr, cchTime - 1);
                    lpTimeStr[r] = 0;
                }
                else
                {
                    // User wants to know how much space is needed
                    r = ::MultiByteToWideChar(CP_ACP, 0, pszTime, r, NULL, 0 ) + 1;
                }
            }

            delete[] pszTime;

            if ( lpaFormat )
            {
                free( lpaFormat );
            }

            return r;
        }
    }

    int GetNumberFormat( LCID Locale, DWORD dwFlags, LPCWSTR lpValue, CONST NUMBERFMTW *lpFormat,
        LPWSTR lpNumberStr, int cchNumber )
    {
        if ( UnicodeSystem() )
        {
            return ::GetNumberFormatW( Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber );
        }
        else
        {
            // Convert the NUMBERFMTW into a NUMBERFMTA
            NUMBERFMTA nmfmtA;
            nmfmtA.NumDigits = lpFormat->NumDigits;
            nmfmtA.LeadingZero = lpFormat->LeadingZero;
            nmfmtA.Grouping = lpFormat->Grouping;
            nmfmtA.NegativeOrder = lpFormat->NegativeOrder;
            nmfmtA.lpDecimalSep = strdup( CSpToAnsiString<>(lpFormat->lpDecimalSep) );
            nmfmtA.lpThousandSep = strdup( CSpToAnsiString<>(lpFormat->lpThousandSep) );

            LPSTR lpaValue = strdup( CSpToAnsiString<>(lpValue) );

            int cchNeeded = ::GetNumberFormatA( Locale, dwFlags, lpaValue, &nmfmtA, NULL, 0 );

            CHAR *pszNumber = new CHAR[ cchNeeded ];
            int r = ::GetNumberFormatA( Locale, dwFlags, lpaValue,
                &nmfmtA, pszNumber, cchNeeded );
            if ( r ) 
            {
                if ( lpNumberStr )
                {
                    r = ::MultiByteToWideChar(CP_ACP, 0, pszNumber, r, lpNumberStr, cchNumber - 1);
                    lpNumberStr[r] = 0;
                }
                else
                {
                    // User wants to know how much space is needed
                    r = ::MultiByteToWideChar(CP_ACP, 0, pszNumber, r, NULL, 0 ) + 1;
                }
            }

            delete[] pszNumber;

            if ( nmfmtA.lpDecimalSep )
            {
                free( nmfmtA.lpDecimalSep );
            }
            if ( nmfmtA.lpThousandSep )
            {
                free( nmfmtA.lpThousandSep );
            }
            if ( lpaValue )
            {
                free( lpaValue );
            }

            return r;
        }
    }

    int GetCurrencyFormat( LCID Locale, DWORD dwFlags, LPCWSTR lpValue, CONST CURRENCYFMTW *lpFormat, 
        LPWSTR lpCurrencyStr, int cchCurrency )
    {
        if ( UnicodeSystem() )
        {
            return ::GetCurrencyFormatW( Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, 
                cchCurrency );
        }
        else
        {
            // Convert the CURRENCYFMTW into a CURRENCYFMTA
            CURRENCYFMTA cyfmtA;
            cyfmtA.NumDigits = lpFormat->NumDigits;
            cyfmtA.LeadingZero = lpFormat->LeadingZero;
            cyfmtA.Grouping = lpFormat->Grouping;
            cyfmtA.NegativeOrder = lpFormat->NegativeOrder;
            cyfmtA.PositiveOrder = lpFormat->PositiveOrder;
            cyfmtA.lpDecimalSep = strdup( CSpToAnsiString<>(lpFormat->lpDecimalSep) );
            cyfmtA.lpThousandSep = strdup( CSpToAnsiString<>(lpFormat->lpThousandSep) );
            cyfmtA.lpCurrencySymbol = strdup( CSpToAnsiString<>(lpFormat->lpCurrencySymbol) );

            LPSTR lpaValue = strdup( CSpToAnsiString<>(lpValue) );

            int cchNeeded = ::GetCurrencyFormatA( Locale, dwFlags, lpaValue, &cyfmtA, NULL, 0 );

            CHAR *pszCurrency = new CHAR[ cchNeeded ];
            int r = ::GetCurrencyFormatA( Locale, dwFlags, lpaValue,
                &cyfmtA, pszCurrency, cchNeeded );
            if ( r ) 
            {
                if ( lpCurrencyStr )
                {
                    r = ::MultiByteToWideChar(CP_ACP, 0, pszCurrency, r, lpCurrencyStr, cchCurrency - 1);
                    lpCurrencyStr[r] = 0;
                }
                else
                {
                    // User wants to know how much space is needed
                    r = ::MultiByteToWideChar(CP_ACP, 0, pszCurrency, r, NULL, 0 ) + 1;
                }
            }
            delete[] pszCurrency;

            if ( cyfmtA.lpDecimalSep )
            {
                free( cyfmtA.lpDecimalSep );
            }
            if ( cyfmtA.lpThousandSep )
            {
                free( cyfmtA.lpThousandSep );
            }
            if ( cyfmtA.lpCurrencySymbol )
            {
                free( cyfmtA.lpCurrencySymbol );
            }
            if ( lpaValue )
            {
                free( lpaValue );
            }

            return r;
        }

    }
    
    LONG_PTR GetWindowLongPtr( HWND hWnd, int nIndex )
    {
        if ( UnicodeSystem() )
        {
            return ::GetWindowLongPtrW( hWnd, nIndex );
        }
        else
        {
            return ::GetWindowLongPtrA( hWnd, nIndex );
        }
    }

    LONG_PTR SetWindowLongPtr( HWND hWnd, int nIndex, LONG_PTR dwNewLong )
    {
        if ( UnicodeSystem() )
        {
            return ::SetWindowLongPtrW( hWnd, nIndex, dwNewLong );
        }
        else
        {
            return ::SetWindowLongPtrA( hWnd, nIndex, dwNewLong );
        }
    }

    INT_PTR DialogBoxParam( HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam )
    {
        if ( UnicodeSystem() )
        {
            return ::DialogBoxParamW( hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam );
        }
        else
        {
            return ::DialogBoxParamA( hInstance, (LPCTSTR) lpTemplateName, hWndParent, lpDialogFunc, dwInitParam );
        }
    }

    LRESULT SendDlgItemMessage(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam )
    {
        if ( UnicodeSystem() )
        {
            return ::SendDlgItemMessageW(hDlg, nIDDlgItem, Msg, wParam, lParam );
        }
        else
        {
            return ::SendDlgItemMessageA(hDlg, nIDDlgItem, Msg, wParam, lParam );
        }
    }

#ifdef __HTMLHELP_H__
    HWND WINAPI HtmlHelp( HWND hwndCaller, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData )
    {
        if ( UnicodeSystem() )
        {
            return ::HtmlHelpW( hwndCaller, pszFile, uCommand, dwData );
        }
        else
        {
            return ::HtmlHelpA( hwndCaller, CSpToAnsiString<> (pszFile), uCommand, dwData );
        }
    }
#endif  // __HTMLHELP_H__

    BOOL GetUserName(LPWSTR lpBuffer, LPDWORD pnSize)
    {
        if (UnicodeSystem())
        {
            return ::GetUserNameW(lpBuffer, pnSize);
        }
        else
        {
            DWORD cchWideCharBuff = *pnSize;
            CHAR * psz = (CHAR *)_alloca(cchWideCharBuff * sizeof(CHAR)); 
            BOOL fWorked = ::GetUserNameA(psz, pnSize);
            if (fWorked)
            {
                *pnSize = ::MultiByteToWideChar(CP_ACP, 0, psz, -1, lpBuffer, cchWideCharBuff);
                if (*pnSize == 0)
                {
                    fWorked = FALSE;
                    *pnSize = ::MultiByteToWideChar(CP_ACP, 0, psz, -1, NULL, 0);
                }
            }
            return fWorked;
        }
    }

#if defined(mmioOpen)
    HMMIO mmioOpen(LPCWSTR szFileName, LPMMIOINFO lpmmioinfo, DWORD dwOpenFlags) const
    {
        if (UnicodeSystem())
        {
            return ::mmioOpenW((WCHAR *)szFileName, lpmmioinfo, dwOpenFlags);
        }
        else
        {
            return ::mmioOpenA(CSpToAnsiString<>(szFileName), lpmmioinfo, dwOpenFlags);
        }
    }
    MMRESULT waveOutGetDevCaps(UINT uDeviceId, LPWAVEOUTCAPSW pwoc, UINT cbwoc) const
    {
        // Some drivers overwrite the WAVEINCAPS buffer by a DWORD. So they probably do it for
        // WAVEOUTCAPS too
        MMRESULT mmr = MMSYSERR_NOERROR;
        if (UnicodeSystem())
        {
            BYTE *pBuffer = new BYTE[sizeof(WAVEOUTCAPSW) + sizeof(DWORD)];
            WAVEOUTCAPSW *pwocw = reinterpret_cast<WAVEOUTCAPSW *>(pBuffer);
            if (pwocw)
            {
                mmr = ::waveOutGetDevCapsW(uDeviceId, pwocw, cbwoc);
                if (mmr == MMSYSERR_NOERROR)
                {
                    *pwoc = *pwocw;
                }
                delete [] pBuffer;
            }
            else
            {
                mmr = MMSYSERR_ERROR;
            }
        }
        else
        {
            BYTE *pBuffer = new BYTE[sizeof(WAVEOUTCAPSA) + sizeof(DWORD)];
            WAVEOUTCAPSA *pwoca = reinterpret_cast<WAVEOUTCAPSA *>(pBuffer);
            if (pwoca)
            {
                mmr = ::waveOutGetDevCapsA(uDeviceId, pwoca, sizeof(*pwoca));
                if (mmr == MMSYSERR_NOERROR)
                {
                    pwoc->wMid = pwoca->wMid;
                    pwoc->wPid = pwoca->wPid;
                    pwoc->vDriverVersion = pwoca->vDriverVersion;
                    pwoc->dwFormats = pwoca->dwFormats;
                    pwoc->wChannels = pwoca->wChannels;
                    pwoc->wReserved1 = pwoca->wReserved1;
                    pwoc->dwSupport = pwoca->dwSupport;
                    ::MultiByteToWideChar(CP_ACP, 0, pwoca->szPname, -1, pwoc->szPname, sp_countof(pwoc->szPname));
                }
                else
                {
                    mmr = MMSYSERR_ERROR;
                }
            }
            else
            {
                mmr = MMSYSERR_ERROR;
            }
        }
        return mmr;
    }
    MMRESULT waveInGetDevCaps(UINT uDeviceId, LPWAVEINCAPSW pwic, UINT cbwic) const
    {
        // Some drivers overwrite the WAVEINCAPS buffer by a DWORD
        MMRESULT mmr = MMSYSERR_NOERROR;
        if (UnicodeSystem())
        {
            BYTE *pBuffer = new BYTE[sizeof(WAVEINCAPSW) + sizeof(DWORD)];
            WAVEINCAPSW *pwicw = reinterpret_cast<WAVEINCAPSW *>(pBuffer);
            if (pwicw)
            {
                mmr = ::waveInGetDevCapsW(uDeviceId, pwicw, cbwic);
                if (mmr == MMSYSERR_NOERROR)
                {
                    *pwic = *pwicw;
                }
                delete [] pBuffer;
            }
            else
            {
                mmr = MMSYSERR_ERROR;
            }
        }
        else
        {
            BYTE *pBuffer = new BYTE[sizeof(WAVEINCAPSA) + sizeof(DWORD)];
            WAVEINCAPSA *pwica = reinterpret_cast<WAVEINCAPSA *>(pBuffer);
            if (pwica)
            {
                mmr = ::waveInGetDevCapsA(uDeviceId, pwica, sizeof(*pwica));
                if (mmr == MMSYSERR_NOERROR)
                {
                    pwic->wMid = pwica->wMid;
                    pwic->wPid = pwica->wPid;
                    pwic->vDriverVersion = pwica->vDriverVersion;
                    pwic->dwFormats = pwica->dwFormats;
                    pwic->wChannels = pwica->wChannels;
                    pwic->wReserved1 = pwica->wReserved1;
                    ::MultiByteToWideChar(CP_ACP, 0, pwica->szPname, -1, pwic->szPname, sp_countof(pwic->szPname));
                }
                delete [] pBuffer;
            }
            else
            {
                mmr = MMSYSERR_ERROR;
            }
        }
        return mmr;
    }
#endif  // defined(mmioOpen)
};

#ifdef _UNICODE
typedef CSpUnicodeSupportT<TRUE> CSpUnicodeSupport;
#else
typedef CSpUnicodeSupportT<FALSE> CSpUnicodeSupport;
#endif

#else //_WIN32_WCE

class CSpUnicodeSupport
{
public:
    HANDLE CreateFile(const WCHAR * lpFileName,      
                      DWORD dwDesiredAccess,       
                      DWORD dwShareMode,           
                      LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                      DWORD dwCreationDisposition, 
                      DWORD dwFlagsAndAttributes,  
                      HANDLE hTemplateFile) const         
    {
        return ::CreateFile(
                    lpFileName, 
                    dwDesiredAccess, 
                    dwShareMode, 
                    lpSecurityAttributes, 
                    dwCreationDisposition,                           
                    dwFlagsAndAttributes, 
                    hTemplateFile);
    }
    HANDLE CreateFileForMapping(const WCHAR * lpFileName,      
                                DWORD dwDesiredAccess,       
                                DWORD dwShareMode,           
                                LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                DWORD dwCreationDisposition, 
                                DWORD dwFlagsAndAttributes,  
                                HANDLE hTemplateFile) const         
    {
        return ::CreateFileForMappingW(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, dwCreationDisposition,
                                       dwFlagsAndAttributes, hTemplateFile);
    }
    DWORD GetFullPathName(WCHAR *lpFileName,  // file name
                          DWORD nBufferLength, // size of path buffer
                          WCHAR *lpBuffer,     // path buffer
                          WCHAR **lpFilePart   // address of file name in path
                          )
    {
        return ::GetFullPathName(lpFileName, nBufferLength, lpBuffer, lpFilePart);
    }
    BOOL DeleteFile(LPCWSTR lpFileName)
    {
        return ::DeleteFileW(lpFileName);
    }
    BOOL MoveFile(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName)
    {
        return ::MoveFileW(lpExistingFileName, lpNewFileName);
    }
    BOOL CopyFile(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists)
    {
        return ::CopyFileW(lpExistingFileName, lpNewFileName, bFailIfExists);
    }
    BOOL CreateDirectory(const WCHAR * lpPathName,
                           LPSECURITY_ATTRIBUTES lpSecurityAttributes) const
    {
        return ::CreateDirectoryW(lpPathName, lpSecurityAttributes);
    }
    BOOL RemoveDirectory(const WCHAR * lpPathName) const
    {
        return ::RemoveDirectoryW(lpPathName);
    }
    HANDLE CreateFileMapping(HANDLE hFile, LPSECURITY_ATTRIBUTES lpFileMappingAttributes, DWORD flProtect,
                             DWORD dwMaximumSizeHigh, DWORD dwMaximumSizeLow, const WCHAR *lpName)
    {
        return ::CreateFileMappingW(hFile, lpFileMappingAttributes, flProtect, dwMaximumSizeHigh, 
                                    dwMaximumSizeLow, lpName);
    }
    BOOL SetFileAttributes(LPCWSTR lpFileName, DWORD dwFileAttributes)
    {
        return ::SetFileAttributesW(lpFileName, dwFileAttributes);
    }
    DWORD GetFileAttributes(LPCWSTR lpFileName)
    {
        return ::GetFileAttributesW(lpFileName);
    }
    LONG RegOpenKeyEx(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult) const
    {
#ifdef _WIN32_WCE_BUG_10655
        BOOL bValid = (hKey != INVALID_HANDLE_VALUE) && phkResult;
        LONG lRet = ::RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);
        return (lRet == ERROR_INVALID_PARAMETER && bValid)? ERROR_FILE_NOT_FOUND : lRet; //WCE bug
#else
        return ::RegOpenKeyExW(hKey, lpSubKey, ulOptions, samDesired, phkResult);
#endif
    }
    LONG RegCreateKeyEx(HKEY hk, LPCWSTR lpSubKey, DWORD dwReserved, LPCWSTR lpClass, DWORD dwOptions,
                        REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, 
                        LPDWORD lpdwDisposition) const
    {
        return ::RegCreateKeyExW(hk, lpSubKey, dwReserved, (WCHAR *)lpClass, dwOptions, samDesired, lpSecurityAttributes, phkResult, lpdwDisposition);
    }
    LONG RegDeleteKey(HKEY hKey, LPCWSTR lpSubKey) const
    {
#ifdef _WIN32_WCE_BUG_10655
        BOOL bValid = (hKey != INVALID_HANDLE_VALUE) && lpSubKey;
        LONG lRet = ::RegDeleteKeyW(hKey, lpSubKey);
        return (lRet == ERROR_INVALID_PARAMETER && bValid)? ERROR_FILE_NOT_FOUND : lRet; //WCE bug
#else
        return ::RegDeleteKeyW(hKey, lpSubKey);
#endif
    }
    LONG RegDeleteValue(HKEY hKey, LPCWSTR lpSubKey) const
    {
#ifdef _WIN32_WCE_BUG_10655
        BOOL bValid = (hKey != INVALID_HANDLE_VALUE);
        LONG lRet = ::RegDeleteValueW(hKey, lpSubKey);
        return (lRet == ERROR_INVALID_PARAMETER && bValid)? ERROR_FILE_NOT_FOUND : lRet; //WCE bug
#else
        return ::RegDeleteValueW(hKey, lpSubKey);
#endif
    }
    LONG RegQueryValueEx(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData) const
    {
#ifdef _WIN32_WCE_BUG_10655
        BOOL bValid = (hKey != INVALID_HANDLE_VALUE) && ((lpData && lpcbData) || (!lpData && !lpcbData));
        LONG lRet = ::RegQueryValueExW(hKey, lpValueName, NULL, lpType, lpData, lpcbData);
        return (lRet == ERROR_INVALID_PARAMETER && bValid)? ERROR_FILE_NOT_FOUND : lRet; //WCE bug
#else
        return ::RegQueryValueExW(hKey, lpValueName, NULL, lpType, lpData, lpcbData);
#endif
    }
    //
    //  NOTE:  The size parameter is in CHARACTERS!  Even though the registry API sizes are
    //         in bytes, this function uses character counts.
    //
    LONG RegQueryStringValue(HKEY hKey, LPCWSTR lpValueName, LPWSTR lpData, LPDWORD lpcchData) const
    {
        DWORD dwType;
        *lpcchData *= sizeof(WCHAR);
#ifdef _WIN32_WCE_BUG_10655
        BOOL bValid = (hKey != INVALID_HANDLE_VALUE) && lpData;
#endif
        LONG lRet = ::RegQueryValueExW(hKey, lpValueName, NULL, &dwType, (BYTE *)lpData, lpcchData);
        *lpcchData /= sizeof(WCHAR);
#ifdef _WIN32_WCE_BUG_10655
        return (lRet == ERROR_INVALID_PARAMETER && bValid)? ERROR_FILE_NOT_FOUND : lRet; //WCE bug
#else
        return lRet;
#endif
    }
    //
    //  NOTES: Size is in bytes.  Although this function uses RegEnumKeyEx, we chose to simply
    //         implement the ReqEnumKey functionality since the Ex functionality is not used
    //         by most programs (this saves a bunch of string conversion code).
    //
    LONG RegEnumKey(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcbName) const
    {
#ifdef _WIN32_WCE_BUG_10655
        BOOL bValid = (hKey != INVALID_HANDLE_VALUE) && lpName && lpcbName;
        LONG lRet = ::RegEnumKeyExW(hKey, dwIndex, lpName, lpcbName, NULL, NULL, NULL, NULL);
        return (lRet == ERROR_INVALID_PARAMETER && bValid)? ERROR_FILE_NOT_FOUND : lRet; //WCE bug
#else
        return ::RegEnumKeyExW(hKey, dwIndex, lpName, lpcbName, NULL, NULL, NULL, NULL);
#endif
    }
    //
    //  NOTES: Size is in Characters for lpcchName.  Although this function uses RegEnumValue
    //         it will only return the names, not the data.  cbValueName is the count of characters
    //
    LONG RegEnumValueName(HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName) const
    {
#ifdef _WIN32_WCE_BUG_10655
        BOOL bValid = (hKey != INVALID_HANDLE_VALUE) && lpName && lpcchName;
        LONG lRet = ::RegEnumValueW(hKey, dwIndex, lpName, lpcchName, NULL, NULL, NULL, NULL);
        return (lRet == ERROR_INVALID_PARAMETER && bValid)? ERROR_FILE_NOT_FOUND : lRet; //WCE bug
#else
        return ::RegEnumValueW(hKey, dwIndex, lpName, lpcchName, NULL, NULL, NULL, NULL);
#endif
    }
    LONG RegSetValueEx(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE * lpData, DWORD cbData) const
    {
#ifdef _WIN32_WCE_BUG_10655
        BOOL bValid = (hKey != INVALID_HANDLE_VALUE) && lpData;
        LONG lRet = ::RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData);
        return (lRet == ERROR_INVALID_PARAMETER && bValid)? ERROR_FILE_NOT_FOUND : lRet; //WCE bug
#else
        return ::RegSetValueExW(hKey, lpValueName, Reserved, dwType, lpData, cbData);
#endif
    }
    LONG RegSetStringValue(HKEY hKey, LPCWSTR lpValueName, LPCWSTR lpData) const
    {
        DWORD dwSize = (wcslen(lpData)+1) * sizeof(WCHAR);
#ifdef _WIN32_WCE_BUG_10655
        BOOL bValid = (hKey != INVALID_HANDLE_VALUE) && lpData;
        LONG lRet = ::RegSetValueExW(hKey, lpValueName, NULL, REG_SZ, (const BYTE *)lpData, dwSize);
        return (lRet == ERROR_INVALID_PARAMETER && bValid)? ERROR_FILE_NOT_FOUND : lRet; //WCE bug
#else
        return ::RegSetValueExW(hKey, lpValueName, NULL, REG_SZ, (const BYTE *)lpData, dwSize);
#endif
    }
    HANDLE CreateEvent(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName) const
    {
        return ::CreateEventW(lpEventAttributes, bManualReset, bInitialState, lpName);
    }
    HANDLE CreateMutex(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName) const
    {
        return ::CreateMutexW(lpMutexAttributes, bInitialOwner, lpName);
    }
    int LoadString(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int nBuffer) const
    {
        return ::LoadStringW(hInstance, uID, lpBuffer, nBuffer);
    }
    HMODULE LoadLibrary(LPCWSTR lpLibFileName)
    {
        return ::LoadLibraryW(lpLibFileName);
    }
    HMODULE LoadLibraryEx(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags)
    {
        return ::LoadLibraryExW(lpLibFileName, hFile, dwFlags);
    }
    HRSRC FindResource(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType)
    {
        return ::FindResource(hModule, lpName, lpType);
    }
    DWORD GetModuleFileName(HMODULE hModule, LPWSTR lpFileName, DWORD nSize) const
    {
        return ::GetModuleFileNameW(hModule, lpFileName, nSize);
    }
// WCE does not support GetSystemDirectory
#if 0
    UINT GetSystemDirectory( LPWSTR lpBuffer, UINT uSize )
    {
        return ::GetSystemDirectoryW( lpBuffer, uSize );
    }
#endif
    int CompareString(LCID Locale, DWORD dwCmpFlags, LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2, int cchCount2)
    {
        return ::CompareStringW(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
    }
    BOOL SetWindowText( HWND hWnd, LPCWSTR lpString )
    {
        return ::SetWindowTextW( hWnd, lpString );
    }
    BOOL SetDlgItemText( HWND hDlg, int nIDDlgItem, LPCWSTR lpString )
    {
        return ::SetDlgItemTextW( hDlg, nIDDlgItem, lpString );
    }
    int MessageBox( HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType )
    {
        return ::MessageBoxW( hWnd, lpText, lpCaption, uType );
    }
    int GetLocaleInfo( LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData )
    {
        return ::GetLocaleInfoW( Locale, LCType, lpLCData, cchData );
    }
    int GetTimeFormat( LCID Locale, DWORD dwFlags, CONST SYSTEMTIME *lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime )
    {
        return ::GetTimeFormatW( Locale, dwFlags, lpTime, lpFormat, lpTimeStr, cchTime );
    }
    int GetNumberFormat( LCID Locale, DWORD dwFlags, LPCWSTR lpValue, CONST NUMBERFMTW *lpFormat,
        LPWSTR lpNumberStr, int cchNumber )
    {
        return ::GetNumberFormatW( Locale, dwFlags, lpValue, lpFormat, lpNumberStr, cchNumber );
    int GetCurrencyFormat( LCID Locale, DWORD dwFlags, LPCWSTR lpValue, CONST CURRENCYFMTW *lpFormat, 
        LPWSTR lpCurrencyStr, int cchCurrency )
    {
        return ::GetCurrencyFormatW( Locale, dwFlags, lpValue, lpFormat, lpCurrencyStr, cchCurrency );
    }
    LONG_PTR GetWindowLongPtr( HWND hWnd, int nIndex )
    {
        return ::GetWindowLongPtr( hWnd, nIndex );
    }
    LONG_PTR SetWindowLongPtr( HWND hWnd, int nIndex, LONG_PTR dwNewLong )
    {
        return ::SetWindowLongPtr( hWnd, nIndex, dwNewLong );
    }
    INT_PTR DialogBoxParamCE( HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam )
    {
        return ::DialogBoxParamW( hInstance, lpTemplateName, hWndParent, lpDialogFunc, dwInitParam );
    }
    LRESULT SendDlgItemMessage(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam )
    {
        return ::SendDlgItemMessageW(hDlg, nIDDlgItem, Msg, wParam, lParam );
    }

#ifdef __HTMLHELP_H__
    HWND WINAPI HtmlHelp( HWND hwndCaller, LPCWSTR pszFile, UINT uCommand, DWORD_PTR dwData )
    {
        return HtmlHelpW( hwndCaller, pszFile, uCommand, dwData );
    }
#endif  // __HTMLHELP_H__
    HMMIO mmioOpen(LPCWSTR szFileName, LPMMIOINFO lpmmioinfo, DWORD dwOpenFlags) const
    {
        return ::mmioOpenW((WCHAR *)szFileName, lpmmioinfo, dwOpenFlags);
    }
    MMRESULT waveOutGetDevCaps(UINT uDeviceId, LPWAVEOUTCAPS pwoc, UINT cbwoc) const
    {
        return ::waveOutGetDevCaps(uDeviceId, pwoc, cbwoc);
    }
    MMRESULT waveInGetDevCaps(UINT uDeviceId, LPWAVEINCAPS pwic, UINT cbwic) const
    {
        return ::waveInGetDevCaps(uDeviceId, pwic, cbwic);
    }
};

#endif


//
//  Assume a global named g_Unicode
//
extern CSpUnicodeSupport g_Unicode;


#endif      // Must be the last line of file. (#ifdef __SPUNICODE_H__)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\spcommon\ltscart.cpp ===
/*******************************************************************************
* LtsCart.cpp *
*----------*
*
*   ** WARNING **
*   CART code for LTS. This code was created in MS Research and LiJ owns
*   the algorithm. YunusM eliminated the private heap used by this code
*   and used the new and delete operators instead.
*
*   Created By: LIJ (MS Research)                           Date: 06/18/99
*   Current Owner: Fil
*
*   Copyright (C) 1999 Microsoft Corporation. All Rights Reserved
*******************************************************************************/

//--- Includes --------------------------------------------------------------

#include "StdAfx.h"
#include "LtsCart.h"

#pragma warning(disable : 4100)

/* the following are for exceptions: single letter and NULL output */
static const char *bogus_pron_1033 = "B OW G AH S P R AH N AH N S IY EY SH AH N";
static const char *bogus_pron_1041 = "N A N I"; // what?

static const char *single_letter_pron_1033[52] =
{
    "EY",
    "B IY",
    "S IY",
    "D IY",
    "IY",
    "EH F",
    "JH IY",
    "EY CH",
    "AY",
    "JH EY",
    "K EY",
    "EH L",
    "EH M",
    "EH N",
    "OW",
    "P IY",
    "K Y UW",
    "AA R",
    "EH S",
    "T IY",
    "Y UW",
    "V IY",
    "D AH B AX L Y UW",
    "EH K S",
    "W AY",
    "Z IY",
    //
    // PLURAL SPELLINGS
    //
    "EY Z",
    "B IY Z",
    "S IY Z",
    "D IY Z",
    "IY Z",
    "EH F S",
    "JH IY Z",
    "EY CH AX Z",
    "AY Z",
    "JH EY Z",
    "K EY Z",
    "EH L Z",
    "EH M Z",
    "EH N Z",
    "OW Z",
    "P IY Z",
    "K Y UW Z",
    "AA R Z",
    "EH S AX Z",
    "T IY Z",
    "Y UW Z",
    "V IY Z",
    "D AH B AX L Y UW Z",
    "EH K S AX Z",
    "W AY Z",
    "Z IY Z"
};
static const char *single_letter_pron_1041[52] =
{
    "EE",
    "B II",
    "SH II",
    "D II",
    "II",
    "E H U",
    "J II",
    "EE CH I",
    "A I",
    "J EE",
    "K EE",
    "E R U",
    "E M U",
    "E N U",
    "OO",
    "P II",
    "K Y UU",
    "AA R U",
    "E S U",
    "T II",
    "Y UU",
    "B U I",
    "D A B U R Y UU",
    "E STOP K U S U",
    "W A I",
    "Z E STOP T O",
    //
    // PLURAL SPELLINGS
    //
    "EE Z U",
    "B II Z U",
    "SH II Z U",
    "D II Z U",
    "II Z U",
    "E H U Z U",
    "J II Z U",
    "EE CH I Z U",
    "A I Z U",
    "J EE Z U",
    "K EE Z U",
    "E R U Z U",
    "E M U Z U",
    "E N U Z U",
    "OO Z U",
    "P II Z U",
    "K Y UU Z U",
    "AA R U Z U",
    "E S U Z U",
    "T II Z U",
    "Y UU Z U",
    "B U I Z U",
    "D A B U R Y UU Z U",
    "E STOP K U S U Z U",
    "W A I Z U",
    "Z E STOP T O Z U"
};


/*
* not worthwhile to use binary search with only about 30 entries
*/
static int symbol_to_id(LTS_SYMTAB *tab, char *sym)
{
    USES_CONVERSION;
    SPDBG_FUNC("symbol_to_id");

    int i;
    for (i = 0; i < tab->n_symbols; i++)
    {
        if (CSTR_EQUAL == CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT), NORM_IGNORECASE,
            A2T(tab->storage + tab->sym_idx[i]), -1, A2T(sym), -1))
        {
            return i;
        }
    }
    return NO_SYMBOL;
} // static int symbol_to_id(LTS_SYMTAB *tab, char *sym)


static char *id_to_symbol(LTS_SYMTAB *tab, int id)
{
    SPDBG_FUNC("id_to_symbol");

    if (id < 0 || id > tab->n_symbols)
    {
        return NULL;
    }
    else
    {
        return tab->storage + tab->sym_idx[id];
    }
} // static char *id_to_symbol(LTS_SYMTAB *tab, int id)


__inline void ODS (const char *format, ...)
{
#ifdef _DEBUG
    SPDBG_FUNC("ODS");

    va_list arglist;
    va_start (arglist, format);

    char buf[2048];
    _vsnprintf(buf, 2048, format, arglist);
    OutputDebugStringA(buf);

    va_end (arglist);
#endif
}

__inline int ans_simp_question (LTS_FEATURE *feat, SIMPLE_QUESTION question,
                                LTS_SAMPLE *sample)
{
    SPDBG_FUNC("ans_simp_question");

    SYMBOL id;
    int *phones = feat[question.questype].feature[question.feature];

    SAMPLE_GET_CONTEXT(sample, question.questype, question.context,
        question.offset, id);

    return (TST_BIT(phones, id) ? TRUE : FALSE);
} // __inline int ans_simp_question (LTS_FEATURE *feat, SIMPLE_QUESTION question,


static int product_eval (LTS_FEATURE *feat, char *term, LTS_SAMPLE *sample)
{
    SPDBG_FUNC("product_eval");

    int negate, result;
    SIMPLE_QUESTION ques;
    char *cptr;

    cptr = term;
    while (TRUE)
    {
        /* negation sign */
        if (*cptr == '~')
        {
            negate = TRUE;
            cptr++;
        }
        else
        {
            negate = FALSE;
        }

        if (!isdigit(*cptr))
        {
            //quit (-1, "Invalid product in product_eval\n");
            //      OutputDebugString("Invalid product in product_eval\n");
            return FALSE;
        }

        for (result = *cptr++ - '0'; isdigit (*cptr); cptr++)
        {
            result = result * 10 + (*cptr - '0');
        }

        QUES_DECODE(result, ques.questype, ques.context, ques.offset,
            ques.feature);
        if ((negate ^ ans_simp_question (feat, ques, sample)) == FALSE)
        {
            return FALSE;
        }

        if (*cptr == '\0')
        {
            break;
        }
        if (*cptr++ != '&')
        {
            //quit (-1, "product_eval:  syntax error in product term %s\n", term);
            /*
            char szTemp[512];

              sprintf(szTemp, "product_eval:  syntax error in product term %s\n", term);
              OutputDebugString(szTemp);
            */
            return FALSE;
        }
    }

    return TRUE;
} // static int product_eval (LTS_FEATURE *feat, char *term, LTS_SAMPLE *sample)


static int ans_comp_question(LTS_FEATURE *feat, char *prod,
                             LTS_SAMPLE *sample)
{
    SPDBG_FUNC("ans_comp_question");

    int i, num_products, limit;
    char *cptr, string[LONGEST_STR], *products[MAX_PRODUCTS];

    strcpy(string, prod);
    for (cptr = string, num_products = 1; *cptr != '\0'; cptr++)
    {
        if (*cptr == '|') num_products++;
    }

    if (num_products > MAX_PRODUCTS)
    {
        //quit(1, "please increase MAX_PRODUCTS up to %d at least\n", num_products);

        /*
        char szTemp[256];
        sprintf(szTemp, "please increase MAX_PRODUCTS up to %d at least\n", num_products);
        OutputDebugString(szTemp);
        */

        return FALSE;
    }

    for (i = 0, limit = num_products -1, cptr = string; ; i++)
    {
        products[i] = cptr++;
        if (i == limit)
        {
            break;
        }

        for (; *cptr != '|'; cptr++) {};
        *cptr++ = '\0';
    }

    for (i = 0; i < num_products; i++)
    {
        if (product_eval (feat, products[i], sample) == TRUE)
        {
            return TRUE;
        }
    }

    return FALSE;
} // static int ans_comp_question(LTS_FEATURE *feat, char *prod,


static T_NODE *find_leaf(LTS_FEATURE *feat, T_NODE *root, LTS_SAMPLE *sample)
{
    SPDBG_FUNC("find_leaf");

    if (!root->yes_child)
    {
        return root;
    }
    else if (ans_comp_question(feat, root->prod, sample))
    {
        return find_leaf(feat, root->yes_child, sample);
    }
    else
    {
        return find_leaf(feat, root->no_child, sample);
    }
} // static T_NODE *find_leaf(LTS_FEATURE *feat, T_NODE *root, LTS_SAMPLE *sample)


static int lts_product_eval (LTS_FEATURE *feat, LTS_PROD *term,
                             LTS_SAMPLE *sample, LTS_PROD **next)
{
    SPDBG_FUNC("lts_product_eval");

    int negate, result;
    SIMPLE_QUESTION ques;
    LTS_PROD *cptr = term;

    while (TRUE)
    {
        if ((*cptr) & PROD_NEG)
        {
            negate = TRUE;
            result = (*cptr) ^ PROD_NEG;
        }
        else
        {
            negate = FALSE;
            result = (*cptr);
        }

        QUES_DECODE(result, ques.questype, ques.context, ques.offset,
            ques.feature);
        if ((negate ^ ans_simp_question (feat, ques, sample)) == FALSE)
        {
            while (*cptr != PROD_TERM && *cptr != QUES_TERM)
            {
                cptr++;
            }
            if (*cptr == QUES_TERM)
            {
                *next = NULL;
            }
            else
            {
                *next = cptr + 1;
            }
            return FALSE;
        }

        cptr++;
        if (*cptr == QUES_TERM)
        {
            *next = NULL;
            break;
        }
        else if (*cptr == PROD_TERM)
        {
            *next = cptr + 1;
            break;
        }
    }

    return TRUE;
} // static int lts_product_eval (LTS_FEATURE *feat, LTS_PROD *term,


static int lts_ans_comp_question(LTS_TREE UNALIGNED *tree, LTS_FEATURE *feat,
                                 int idx, LTS_SAMPLE *sample)
{
    SPDBG_FUNC("lts_ans_comp_question");

    LTS_PROD *next, *term = (LTS_PROD *) ((char *) tree->p_prod + idx);

    while (TRUE)
    {
        if (lts_product_eval (feat, term, sample, &next) == TRUE)
        {
            return TRUE;
        }
        if (next == NULL)
        {
            break;
        }
        term = next;
    }

    return FALSE;
} // static int lts_ans_comp_question(LTS_TREE *tree, LTS_FEATURE *feat,


static LTS_NODE *lts_find_leaf(LTS_TREE UNALIGNED *tree, LTS_FEATURE *feat,
                               LTS_NODE *root, LTS_SAMPLE *sample)
{
    SPDBG_FUNC("lts_find_leaf");

    if (IS_LEAF_NODE(root))
    {
        return root;
    }
    else if (lts_ans_comp_question(tree, feat, ((LTS_NODE UNALIGNED *)root)->idx, sample))
    {
        return lts_find_leaf(tree, feat, root + ((LTS_NODE UNALIGNED *)root)->yes, sample);
    }
    else
    {
        return lts_find_leaf(tree, feat, root + ((LTS_NODE UNALIGNED *)root)->yes + 1, sample);
    }
} // static LTS_NODE *lts_find_leaf(LTS_TREE *tree, LTS_FEATURE *feat,


static LTS_DIST *lts_find_leaf_count(LTS_FOREST *l_forest, SYMBOL *pIn,
                                     SYMBOL *pOut)
{
    SPDBG_FUNC("lts_find_leaf_count");

    LTS_TREE UNALIGNED *tree = l_forest->tree[*pIn];
    LTS_NODE UNALIGNED *leaf;
    LTS_SAMPLE sample;

    /*
    * construct a sample in order to share all the code with training
    */
    sample.pIn = pIn;
    sample.pOut = pOut;

    /* *pOut cannot be NULL_SYMBOL_ID */
    *pOut = NULL_SYMBOL_ID + 1;

    leaf = lts_find_leaf(tree, l_forest->features, &(tree->nodes[0]), &sample);
    return (LTS_DIST *) ((char *)tree->p_dist + leaf->idx);
} // static LTS_DIST *lts_find_leaf_count(LTS_FOREST *l_forest, SYMBOL *pIn,

static LTS_OUT_RESULT *allocate_out_result(LTS_FOREST *l_forest)
{
    SPDBG_FUNC("allocate_out_result");

    LTS_OUT_RESULT *res = new LTS_OUT_RESULT;
    if (res)
    {
        res->out_strings = new LTS_OUT_STRING *[MAX_ALT_STRINGS];
        if (res->out_strings)
        {
            res->num_allocated_strings = MAX_ALT_STRINGS;
            res->num_strings = 0;
        }
        else
        {
            delete res;
            res = NULL;
        }
    }

    return res;
} // static LTS_OUT_RESULT *allocate_out_result(LTS_FOREST *l_forest)

static void free_out_result(LTS_FOREST *l_forest, LTS_OUT_RESULT *res)
{
    SPDBG_FUNC("free_out_result");

    int i;

    for (i = 0; i < res->num_strings; i++)
    {
        delete res->out_strings[i];
    }
    if (res->num_allocated_strings == MAX_ALT_STRINGS)
    {
        delete res->out_strings;
    }
    else
    {
        free(res->out_strings);  /* dirty */
    }

    delete res;
} // static void free_out_result(LTS_FOREST *l_forest, LTS_OUT_RESULT *res)


static bool reallocate_out_result(LTS_FOREST *l_forest, LTS_OUT_RESULT *res,
                                  int min)
{
    SPDBG_FUNC("reallocate_out_result");

    int s = res->num_allocated_strings, old_size = s;
    LTS_OUT_STRING **p;

    while (s < min)
        s += INC_ALT_STRINGS;
    p = res->out_strings;

    res->out_strings = (LTS_OUT_STRING **)
        calloc(s, sizeof(LTS_OUT_STRING *));
    if (!res->out_strings)
    {
        return false;
    }

    memcpy(res->out_strings, p, old_size * sizeof(LTS_OUT_STRING *));

    if (old_size == MAX_ALT_STRINGS)
    {
        delete p;
    }
    else
    {
        free(p);
    }

    res->num_allocated_strings = s;
    ODS("increased out_strings to %d in order to meet %d\n", s, min);

    return true;
} // static void reallocate_out_result(LTS_FOREST *l_forest, LTS_OUT_RESULT *res,


static bool grow_out_result(LTS_FOREST *l_forest, LTS_OUT_RESULT *res,
                            SYMBOL i, int count, float inv_sum,
                            LTS_OUT_RESULT *tmpRes)
{
    SPDBG_FUNC("grow_out_result");

    int j;

    if (res->num_strings + tmpRes->num_strings >= res->num_allocated_strings)
    {
        if (!reallocate_out_result(l_forest, res,
            res->num_strings + tmpRes->num_strings))
        {
            return false;
        }
    }
    for (j = 0; j < tmpRes->num_strings; j++)
    {
        SYMBOL *psrc = tmpRes->out_strings[j]->psym;
        SYMBOL *ptgt;
        res->out_strings[res->num_strings + j] = new LTS_OUT_STRING;
        if (!res->out_strings)
        {
            return false;
        }

        ptgt = res->out_strings[res->num_strings + j]->psym;
        *ptgt++ = i;
        while (*psrc != NULL_SYMBOL_ID)
        {
            *ptgt++ = *psrc++;
        }
        *ptgt++ = NULL_SYMBOL_ID;
        res->out_strings[res->num_strings + j]->prob = count * inv_sum *
            tmpRes->out_strings[j]->prob;
    }
    res->num_strings += tmpRes->num_strings;
    free_out_result(l_forest, tmpRes);

    return true;
} // static void grow_out_result(LTS_FOREST *l_forest, LTS_OUT_RESULT *res,


static LTS_OUT_RESULT *gen_one_output(LTS_FOREST *l_forest, int len,
                                      SYMBOL *input_id, int in_index,
                                      SYMBOL *output_id, float cutoff)
{
    SPDBG_FUNC("gen_one_output");

    SYMBOL out[SP_MAX_WORD_LENGTH], *pOut;
    LTS_OUT_RESULT *res = allocate_out_result(l_forest);
    if (!res)
    {
        return NULL;
    }

    int sum, i, dim;
    LTS_DIST UNALIGNED *pdf;
    LTS_PAIR UNALIGNED *l_pair, *lp;
    float cut, inv_sum;

    /*
    * copy output_id to local
    */
    SYMBOL *psrc = output_id - 1, *ptgt = out;
    while (*psrc != NULL_SYMBOL_ID) psrc--;
    while (psrc != output_id)
        *ptgt++ = *psrc++;
    pOut = ptgt;
    /* sanity check */
    if (pOut - out != in_index + 1)
    {
        // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        int *z=0;
        z[0]=z[1];
    }

    if (in_index == len - 1)
    {
        pdf = lts_find_leaf_count(l_forest, input_id + in_index, pOut);
        l_pair = &(pdf->p_pair);
        dim = pdf->c_dists;
        for (lp = l_pair, sum = 0, i = 0; i < dim; i++, lp++)
        {
            sum += lp->cnt;
        }
        SPDBG_ASSERT(sum > 0);
        inv_sum = 1.0f / sum;
        cut = cutoff * sum;
        for (lp = l_pair, i = 0; i < dim; i++, lp++)
        {
            if ((float)(lp->cnt) > cut)
            {
                res->out_strings[res->num_strings] = new LTS_OUT_STRING;
                if (NULL == res->out_strings[res->num_strings])
                {
                    return NULL;
                }
                res->out_strings[res->num_strings]->psym[0] = (SYMBOL) lp->id;
                res->out_strings[res->num_strings]->psym[1] = NULL_SYMBOL_ID;
                res->out_strings[res->num_strings]->prob = lp->cnt * inv_sum;
                res->num_strings++;
            } /* cut */
        }
    }
    else
    {
        LTS_OUT_RESULT *tmpRes;

        pdf = lts_find_leaf_count(l_forest, input_id + in_index, pOut);
        dim = pdf->c_dists;
        l_pair = &(pdf->p_pair);
        for (lp = l_pair, sum = 0, i = 0; i < dim; i++, lp++)
        {
            sum += lp->cnt;
        }
        SPDBG_ASSERT(sum > 0);

        inv_sum = 1.0f / sum;
        cut = cutoff * sum;
        for (lp = l_pair, i = 0; i < dim; i++, lp++)
        {
            if ((float)(lp->cnt) > cut)
            {
                SYMBOL *pTmpOut = pOut + 1;
                *pOut = (SYMBOL) lp->id;
                tmpRes = gen_one_output(l_forest, len, input_id, in_index + 1, pTmpOut, cutoff);
                if (!tmpRes)
                {
                    return NULL;
                }

                if (!grow_out_result(l_forest, res, (SYMBOL)(lp->id), lp->cnt,
                    inv_sum, tmpRes))
                {
                    return NULL;
                }
            }
        } /* i */
    } /* else */

    return res;
} // static LTS_OUT_RESULT *gen_one_output(LTS_FOREST *l_forest, int len,


static int comp_out_result_prob(const void *vp1, const void *vp2)
{
    SPDBG_FUNC("comp_out_result_prob");

    LTS_OUT_STRING **p1 = (LTS_OUT_STRING **) vp1,
        **p2 = (LTS_OUT_STRING **) vp2;

    if ((*p1)->prob > (*p2)->prob)
    {
        return -1;
    }
    else if ((*p1)->prob < (*p2)->prob)
    {
        return 1;
    }
    else
    {
        return 0;
    }
} // static int comp_out_result_prob(const void *vp1, const void *vp2)


static void lts_fill_out_buffer(LTS_FOREST *l_forest, LTS_OUT_RESULT *out,
                                char *word)
{
    SPDBG_FUNC("lts_fill_out_buffer");

    int i, j, n;
    float inv_sum, sum = 0.0f;
    char phnstr[LONGEST_STR];
    char *tmp;
    LTS_SYMTAB *tab = l_forest->symbols;

    if (out == NULL)
    {
        return;
    }

    if (word)
    {
        strcpy(l_forest->out.word, word);
    }
    else
    {
        l_forest->out.word[0] = 0;
    }

    /* normalize probabilities */
    for (i = 0; i < out->num_strings; i++)
    {
        sum += out->out_strings[i]->prob;
    }
    inv_sum = 1.0f / sum;
    for (i = 0; i < out->num_strings; i++)
    {
        out->out_strings[i]->prob *= inv_sum;
    }

    /*
    * sort them according to the prob field
    */
    qsort(out->out_strings, out->num_strings, sizeof(LTS_OUT_STRING *),
        &comp_out_result_prob);

    if (out->num_strings > MAX_OUTPUT_STRINGS - l_forest->out.num_prons)
    {
        n = MAX_OUTPUT_STRINGS - l_forest->out.num_prons;
        for (sum = 0.0f, i = 0; i < n; i++)
        {
            sum += out->out_strings[i]->prob;
        }
        inv_sum = 1.0f / sum;
        for (i = 0; i < n; i++)
        {
            out->out_strings[i]->prob *= inv_sum;
        }
    }
    else
    {
        n = out->num_strings;
    }

    for (j = l_forest->out.num_prons, i = 0; i < n; i++)
    {
        SYMBOL *p = out->out_strings[i]->psym;
        char *psrc, *ptgt;

        if (out->out_strings[i]->prob < MIN_OUT_PROB)
        {
            continue;
        }

        phnstr[0] = 0;
        l_forest->out.pron[j].prob = out->out_strings[i]->prob;

        while (*p != NULL_SYMBOL_ID)
        {
            tmp = id_to_symbol(&(tab[OUTPUT]), *p++);
            SPDBG_ASSERT(tmp);
            if (tmp)
            {
                strcat(phnstr, tmp);
                strcat(phnstr, " ");
            }
        }

        psrc = phnstr;
        ptgt = l_forest->out.pron[j].pstr;
        while (*psrc)
        {
            if (*psrc != '#' && *psrc != '_')
            {
                *ptgt++ = *psrc++;
            }
            else if (*psrc == '_')
            {
                *ptgt++ = ' ';
                psrc++;
            }
            else
            {
                psrc += 2; /* skip an extra space */
            }
            /* extreme case, truncate it */
            if (ptgt - l_forest->out.pron[j].pstr >= SP_MAX_PRON_LENGTH)
            {
                for (ptgt--; !isspace(*ptgt); ptgt--) {}; /* never output partial phone */
                ptgt++;
                break;
            }
        }
        // output could contain only '# '
        if (ptgt > l_forest->out.pron[j].pstr && *(ptgt - 1) == ' ')
        {
            *(ptgt - 1) = 0; /* remove the last space */
        }
        else
        {
            *ptgt = 0; /* shouldn't happen unless ptgt didn't move */
        }
        if (ptgt > l_forest->out.pron[j].pstr)
        {
            j++;
        }
    } /* i */

    if (j <= MAX_OUTPUT_STRINGS)
    {
        l_forest->out.num_prons = j;
    }
    else
    {
        l_forest->out.num_prons = MAX_OUTPUT_STRINGS; // should never happen
    }

    free_out_result(l_forest, out);
} // static void lts_fill_out_buffer(LTS_FOREST *l_forest, LTS_OUT_RESULT *out,


void assign_a_fixed_pron(LTS_OUTPUT *out, const char *pron, char *word)
{
    SPDBG_FUNC("assign_a_fixed_pron");

    out->num_prons = 1;
    strcpy(out->word, word);
    out->pron[0].prob = 1.0f;
    if (strlen(pron) < SP_MAX_PRON_LENGTH)
    {
        strcpy(out->pron[0].pstr, pron);
    }
    else
    {
        char *p;
        strncpy(out->pron[0].pstr, pron, SP_MAX_PRON_LENGTH);
        p = &(out->pron[0].pstr[SP_MAX_PRON_LENGTH - 1]);
        while (!isspace(*p))
        {
            p--; /* truncate the last partial phoneme */
        }
        *p = 0;
    }
} // void assign_a_fixed_pron(LTS_OUTPUT *out, char *pron, char *word)

inline BOOL IsCharInRangeA(int ch, int chMin, int chMax)
{
    return (unsigned)(ch - chMin) <= (unsigned)(chMax - chMin);
}

void assign_a_spelling_pron(LTS_OUTPUT *out, const char * single_letter_pron[52], char *word)
{
    SPDBG_FUNC("assign_a_spelling_pron");

    char *p;
    int cchPron = 0;

    strcpy(out->word, word);
    if (ispunct(*word))
    {
        p = word + 1;
    }
    else
    {
        p = word;
    }

    out->num_prons = 1;
    out->pron[0].prob = 1.0f;
    out->pron[0].pstr[0] = 0;

    char * pchPron = out->pron[0].pstr;

    while (*p)
    {
        int cPOffset = 0;   // 0 for single letter, 26 for plurals
        int c = *p++;

        // Lowercaseify, and skip over non-letters
        if (IsCharInRangeA(c, 'A', 'Z'))
        {
            c += 'a' - 'A';
        }
        else if (!IsCharInRangeA(c, 'a', 'z'))
        {
            continue;
        }

        // Check if the next two characters are 'S (apostrophe S).  Include the following cases: words ending in 's 'S s' S'
        // If they are we use a the plural pronunciation for the letter and skip over the letter and 'S
        if ((p[0] == '\'') && ((0 == p[1] && 's' == c) || 's' == p[1] || 'S' == p[1]))
        {
            cPOffset = 26;
            p += p[1] ? 1 : 0;         // skip 'S
        }

        //  Make sure the string isn't too long accounting for the new phone and seperator
        const char * const pchPronT = single_letter_pron[cPOffset + c - 'a'];
        const int cchPronT = strlen(pchPronT);

        if ((cchPron + 1 + cchPronT) < (SP_MAX_PRON_LENGTH - 1)) // +1 for separating space, -1 for terminating NUL
        {
            strcpy(pchPron + cchPron, pchPronT);

            cchPron += cchPronT;

            pchPron[cchPron++] = ' ';
        }
        else
        {
            break;
        }
    }

    if (cchPron)
    {
        pchPron[cchPron - 1] = 0; // trim trailing space char
    }
}


HRESULT LtscartGetPron(LTS_FOREST *l_forest, char *word, LTS_OUTPUT **ppLtsOutput)
{
    SPDBG_FUNC("LtscartGetPron");

    HRESULT hr = S_OK;
    LTS_OUT_RESULT *pres = NULL;
    char *p, *base;
    SYMBOL buffer[LONGEST_STR], *pbuf = buffer + 1;
    int len, id, hasvowel = 0, allcapital = 1;

    l_forest->out.num_prons = 0;
    buffer[0] = NULL_SYMBOL_ID;
    len = 0;


    if (word == NULL || (base = strtok(word, " \t\n")) == NULL)
    {
        assign_a_fixed_pron(&(l_forest->out), l_forest->bogus_pron, "NUL");
        *ppLtsOutput = &(l_forest->out);
        return S_FALSE;
    }
    else
    {
        base = strtok(word, " \t\n");
        if (ispunct(*base))
        {
            for (p = base; *p && ispunct(*p); p++) {};
        }
        else
        {
            p = base;
        }
    }

    char ach[2];
    ach[1] = 0;

    while (*p)
    {
        const int d = *p++;
        const int c = tolower(d);

        if (!hasvowel && (c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' || c == 'y'))
        {
            hasvowel = 1;
        }
        if (allcapital && d == c)
        {
            allcapital = 0;
        }

        ach[0] = (char)c;

        if ((id = symbol_to_id (&(l_forest->symbols[INPUT]), ach)) == NO_SYMBOL || id == NULL_SYMBOL_ID)
        {
            ODS("cannot find the symbol %c, skip!\n", c);
            continue;
        }

        pbuf[len++] = (SYMBOL) id;
    }

    pbuf[len] = NULL_SYMBOL_ID;
    if (len >= SP_MAX_WORD_LENGTH || len <= 0)
    {
        // fill in bogus pron below
    }
    else if (len == 1)
    {
        LTS_SYMTAB *tab = l_forest->symbols;
        char *p = id_to_symbol(&(tab[INPUT]), pbuf[0]);
        int c = tolower(p[0]);
        if (c >= 'a' && c <= 'z')
        {
            assign_a_fixed_pron(&(l_forest->out), l_forest->single_letter_pron[c - 'a'], word);
        }
    }
    else if (!hasvowel)
    {
        assign_a_spelling_pron(&(l_forest->out), l_forest->single_letter_pron, word);
    }
    else
    {
        if (allcapital)
        {
            assign_a_spelling_pron(&(l_forest->out), l_forest->single_letter_pron, word);
        }
        pres = gen_one_output(l_forest, len, pbuf, 0, pbuf, DEFAULT_PRUNE);
        if (!pres)
        {
            return E_OUTOFMEMORY;
        }

        lts_fill_out_buffer(l_forest, pres, word);
    }

    if (l_forest->out.num_prons == 0)
    {
        hr = S_FALSE;

        assign_a_fixed_pron(&(l_forest->out), l_forest->bogus_pron, word);
    }

    *ppLtsOutput = &(l_forest->out);

    SPDBG_RETURN(hr);
} /* LtscartGetPron */


LTS_FOREST *LtscartReadData (LCID lcid, PBYTE map_addr)
{
    SPDBG_FUNC("LtscartReadData");

    int i;
    LTS_FOREST *l_forest;
    LTS_SYMTAB *tab;
    LTS_FEATURE *feat;
    int output = 0;

    l_forest = (LTS_FOREST *) calloc(1, sizeof(LTS_FOREST));
    if (!l_forest)
    {
        return NULL;
    }

    if (lcid == 1033)
    {
        l_forest->bogus_pron = bogus_pron_1033;
        l_forest->single_letter_pron = single_letter_pron_1033;
    }
    else if (lcid == 1041)
    {
        l_forest->bogus_pron = bogus_pron_1041;
        l_forest->single_letter_pron = single_letter_pron_1041;
    }
    else
    {
        return NULL;
    }

    //read in the symbol table
    l_forest->symbols = (LTS_SYMTAB *) calloc(2, sizeof(LTS_SYMTAB));
    if (!l_forest->symbols)
    {
        return NULL;
    }

    tab = &(l_forest->symbols[INPUT]);
    CopyMemory(&(tab->n_symbols), map_addr + output, sizeof(int));
    output += sizeof(int);

    tab->sym_idx = (int *)(map_addr + output);
    output += tab->n_symbols * sizeof(int);

    CopyMemory(&(tab->n_bytes), map_addr + output, sizeof(int));
    output += sizeof(int);

    tab->storage = (char*)(map_addr + output);
    output += tab->n_bytes * sizeof(char);

    tab = &(l_forest->symbols[OUTPUT]);
    CopyMemory(&(tab->n_symbols), map_addr + output, sizeof(int));
    output += sizeof(int);

    tab->sym_idx = (int*)(map_addr + output);
    output += tab->n_symbols * sizeof(int);
    CopyMemory(&(tab->n_bytes), map_addr + output, sizeof(int));
    output += sizeof(int);

    tab->storage = (char*)(map_addr + output);
    output += tab->n_bytes * sizeof(char);

    // read in the feature vector
    l_forest->features = (LTS_FEATURE *) calloc(2, sizeof(LTS_FEATURE));
    if (!l_forest->features)
    {
        return NULL;
    }

    feat = &(l_forest->features[INPUT]);

    CopyMemory(&(feat->n_feat), map_addr + output, sizeof(int));
    output += sizeof(int);

    CopyMemory(&(feat->dim), map_addr + output, sizeof(int));
    output += sizeof(int);

    feat->feature = (int **) calloc(feat->n_feat, sizeof(int *));
    if (!feat->feature)
    {
        return NULL;
    }

    for (i = 0; i < feat->n_feat; i++)
    {
        feat->feature[i] = (int*)(map_addr + output);
        output += feat->dim * sizeof(int);
    }

    feat = &(l_forest->features[OUTPUT]);
    CopyMemory(&(feat->n_feat), map_addr + output, sizeof(int));
    output += sizeof(int);

    CopyMemory(&(feat->dim), map_addr + output, sizeof(int));
    output += sizeof(int);

    feat->feature = (int **) calloc(feat->n_feat, sizeof(int *));
    if (!feat->feature)
    {
        return NULL;
    }

    for (i = 0; i < feat->n_feat; i++)
    {
        feat->feature[i] = (int*)(map_addr + output);
        output += feat->dim * sizeof(int);
    }

    /*
    * read in the tree
    */
    l_forest->tree = (LTS_TREE **) calloc(l_forest->symbols[INPUT].n_symbols,
					   sizeof(LTS_TREE *));
    if (!l_forest->tree)
    {
        return NULL;
    }

    for (i = 1; i < l_forest->symbols[INPUT].n_symbols; i++)
    {
        LTS_TREE *l_root;
        l_forest->tree[i] = l_root = (LTS_TREE *) calloc(1, sizeof(LTS_TREE));
        if (!l_root)
        {
            return NULL;
        }

        CopyMemory(&(l_root->n_nodes), map_addr + output, sizeof(int));
        output += sizeof(int);

        l_root->nodes = (LTS_NODE*)(map_addr + output);
        output += l_root->n_nodes * sizeof(LTS_NODE);

        CopyMemory(&(l_root->size_dist), map_addr + output, sizeof(int));
        output += sizeof(int);

        l_root->p_dist = (LTS_DIST*)(map_addr + output);
        output += l_root->size_dist * sizeof(char);

        CopyMemory(&(l_root->size_prod), map_addr + output, sizeof(int));
        output += sizeof(int);

        if (l_root->size_prod > 0)
        {
            l_root->p_prod = (LTS_PROD*)(map_addr + output);
            output += l_root->size_prod * sizeof(char);
        }
    }

    return l_forest;
} // LTS_FOREST *LtscartReadData(char *forest_image, HANDLE *hFile1,


void LtscartFreeData(LTS_FOREST *l_forest)
{
    SPDBG_FUNC("LtscartFreeData");

    for (int i = 1; i < l_forest->symbols[INPUT].n_symbols; i++)
    {
        free(l_forest->tree[i]);
    }
    free(l_forest->tree);

    free(l_forest->features[INPUT].feature);
    free(l_forest->features[OUTPUT].feature);
    free(l_forest->features);

    free(l_forest->symbols);

    free(l_forest);
} // void LtscartFreeData(LTS_FOREST *l_forest, HANDLE m_hFile,
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\spcommon\ltslx.cpp ===
/*******************************************************************************
* LtsLx.cpp *
*--------------*
*       Implements the LTS lexicon object.
*
*  Owner: YUNUSM                                        Date: 06/18/99
*  Copyright (C) 1999 Microsoft Corporation. All Rights Reserved.
*******************************************************************************/

//--- Includes ----------------------------------------------------------------
#include "StdAfx.h"
#include "LtsLx.h"
#include <initguid.h>

//--- Globals -----------------------------------------------------------------
// CAUTION: This validation GUID also defined in the tool to build LTS lexicons
// {578EAD4E-330C-11d3-9C26-00C04F8EF87C}
DEFINE_GUID(guidLtsValidationId,
0x578ead4e, 0x330c, 0x11d3, 0x9c, 0x26, 0x0, 0xc0, 0x4f, 0x8e, 0xf8, 0x7c);

extern CSpUnicodeSupport   g_Unicode;

//--- Constructor, Initializer and Destructor functions ------------------------

/*******************************************************************************
* CLTSLexicon::CLTSLexicon *
*--------------------------*
*
*   Description:
*       Constructor
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
CLTSLexicon::CLTSLexicon(void)
{
    SPDBG_FUNC("CLTSLexicon::CLTSLexicon");
}

/*******************************************************************************
* CLTSLexicon::FinalConstruct *
*-----------------------------*
*
*   Description:
*       Initializes the CLTSLexicon object
*
*   Return:
*       S_OK
***************************************************************** YUNUSM ******/
HRESULT CLTSLexicon::FinalConstruct(void)
{
    SPDBG_FUNC("CLTSLexicon::FinalConstruct");

    NullMembers();

    return S_OK;
}


/*****************************************************************************
* CLTSLexicon::~CLTSLexicon *
*---------------------------*
*
*   Description:
*       Destructor
*
*   Return:
*       n/a
**********************************************************************YUNUSM*/
CLTSLexicon::~CLTSLexicon()
{
    SPDBG_FUNC("CLTSLexicon::~CLTSLexicon");

    CleanUp();
}

/*******************************************************************************
* CLTSLexicon::CleanUp *
*----------------------*
*
*   Description:
*       real destructor
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
void CLTSLexicon::CleanUp(void)
{
    SPDBG_FUNC("CLTSLexicon::CleanUp");

    if (m_pLtsData)
    {
        UnmapViewOfFile(m_pLtsData);
    }

    if (m_hLtsMap)
    {
        CloseHandle(m_hLtsMap);
    }

    if (m_hLtsFile)
    {
        CloseHandle(m_hLtsFile);
    }

    if (m_pLTSForest)
    {
        ::LtscartFreeData(m_pLTSForest);
    }

    NullMembers();
}

/*******************************************************************************
* CLTSLexicon::NullMembers *
*--------------------------*
*
*   Description:
*       null data
*
*   Return:
*       n/a
***************************************************************** YUNUSM ******/
void CLTSLexicon::NullMembers(void)
{
    SPDBG_FUNC("CLTSLexicon::NullMembers");

    m_fInit = false;
    m_cpObjectToken = NULL;
    m_pLtsData = NULL;
    m_hLtsMap = NULL;
    m_hLtsFile = NULL;
    m_pLTSForest = NULL;
    m_pLtsLexInfo = NULL;
    m_cpPhoneConv = NULL;
}

//--- ISpLexicon methods -------------------------------------------------------

/*******************************************************************************
* GetPronunciations *
*-------------------*
*
*   Description:
*       Gets the pronunciations and POSs of a word
*
*   Return:
*       E_POINTER
*       E_INVALIDARG
*       E_OUTOFMEMORY
*       S_OK
***************************************************************** YUNUSM ******/
STDMETHODIMP CLTSLexicon::GetPronunciations(const WCHAR * pwWord,                               // word
                                            LANGID LangID,                                      // LANGID of the word
                                            DWORD dwFlags,                                      // lextype
                                            SPWORDPRONUNCIATIONLIST * pWordPronunciationList    // buffer to return info in
                                            )
{
    USES_CONVERSION;
    SPDBG_FUNC("CLTSLexicon::GetPronunciations");

    HRESULT hr = S_OK;
    LANGID LangIDPassedIn = LangID;
    BOOL fBogusPron = FALSE;

    if (!pwWord || !pWordPronunciationList)
    {
       hr = E_POINTER;
    }
    if (SUCCEEDED(hr))
    {
        // Yuncj: Chinese SR is using English LTS, so bypass the gollowing test by replacing its LangID
        if ( 2052 == LangID )
        {
            LangID = 1033;
        }
        if (!m_fInit)
        {
            hr = SPERR_UNINITIALIZED;
        }
        else if (SPIsBadLexWord(pwWord) ||
                (LangID != m_pLtsLexInfo->LangID && LangID) ||
                SPIsBadWordPronunciationList(pWordPronunciationList))
        {
            hr = E_INVALIDARG;
        }
    }
    if (SUCCEEDED(hr) && LangID == 1041)
    {
        // Check if the string is all english chars - Japanese LTS handles only english strings
        char szWord[SP_MAX_WORD_LENGTH];
        strcpy(szWord, W2A(pwWord));
        _strlwr(szWord);

        for (int i = 0; szWord[i]; i++)
        {
            if ((szWord[i] < 'a' || szWord[i] > 'z') && (szWord[i] != '\''))
            {
                hr = SPERR_NOT_IN_LEX; // Not returning E_INVALIDARG here since that would be hard for app to interpret
                break;
            }
        }
    }
    char szWord[SP_MAX_WORD_LENGTH];
    if (SUCCEEDED(hr))
    {
        if (!WideCharToMultiByte (CP_ACP, 0, pwWord, -1, szWord, SP_MAX_WORD_LENGTH, NULL, NULL))
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    size_t cbPronsLen = 0;
    WCHAR aWordsProns[MAX_OUTPUT_STRINGS][SP_MAX_PRON_LENGTH];
    LTS_OUTPUT * pLTSOutput = NULL;
    int cProns = 0;

    ZeroMemory(aWordsProns, SP_MAX_PRON_LENGTH * MAX_OUTPUT_STRINGS * sizeof(WCHAR));
    if (SUCCEEDED(hr))
    {
        hr = LtscartGetPron(m_pLTSForest, szWord, &pLTSOutput);

        fBogusPron = S_FALSE == hr;

        if (SUCCEEDED(hr))
        {
            for (int i = 0; i < pLTSOutput->num_prons; i++)
            {
                HRESULT hrPhone = m_cpPhoneConv->PhoneToId(A2W(pLTSOutput->pron[i].pstr), aWordsProns[cProns]);

                if (SUCCEEDED(hrPhone))
                {
                    cbPronsLen += PronSize(aWordsProns[cProns]);
                    cProns++;
                }
            }
        }
    }
    if (SUCCEEDED(hr) && 0 == cProns)
    {
        hr = SPERR_NOT_IN_LEX;
    }
    if (SUCCEEDED(hr))
    {
        hr = ReallocSPWORDPRONList(pWordPronunciationList, cbPronsLen);
    }
    if (SUCCEEDED(hr))
    {
        SPWORDPRONUNCIATION *p = pWordPronunciationList->pFirstWordPronunciation;
        SPWORDPRONUNCIATION **ppNext = &pWordPronunciationList->pFirstWordPronunciation;

        for (int i = 0; i < cProns; i++)
        {
            p->ePartOfSpeech = SPPS_NotOverriden;
            wcscpy(p->szPronunciation, aWordsProns[i]);
            p->eLexiconType = (SPLEXICONTYPE)dwFlags;
            p->LangID = LangIDPassedIn;

            *ppNext = p;
            ppNext = &p->pNextWordPronunciation;

            p = CreateNextPronunciation(p);
        }

        *ppNext = NULL;
    }

    hr = SUCCEEDED(hr) ? (fBogusPron ? S_FALSE : S_OK) : hr;

    SPDBG_RETURN(hr);
}

STDMETHODIMP CLTSLexicon::AddPronunciation(const WCHAR *, LANGID, SPPARTOFSPEECH, const SPPHONEID *)
{
    return E_NOTIMPL;
}

STDMETHODIMP CLTSLexicon::RemovePronunciation(const WCHAR *, LANGID, SPPARTOFSPEECH, const SPPHONEID *)
{
    return E_NOTIMPL;
}

STDMETHODIMP CLTSLexicon::GetGeneration(DWORD *)
{
    return E_NOTIMPL;
}

STDMETHODIMP CLTSLexicon::GetGenerationChange(DWORD, DWORD*, SPWORDLIST *)
{
    return E_NOTIMPL;
}

STDMETHODIMP CLTSLexicon::GetWords(DWORD, DWORD *, DWORD *, SPWORDLIST *)
{
    return E_NOTIMPL;
}

//--- ISpObjectToken methods ---------------------------------------------------

STDMETHODIMP CLTSLexicon::GetObjectToken(ISpObjectToken **ppToken)
{
    return SpGenericGetObjectToken(ppToken, m_cpObjectToken);
}

/*****************************************************************************
* CLTSLexicon::SetObjectToken *
*-----------------------------*
*   Description:
*       Initializes the CLTSLexicon object
*
*   Return:
*       E_POINTER
*       E_INVALIDARG
*       GetLastError()
*       E_OUTOFMEMORY
*       S_OK
**********************************************************************YUNUSM*/
HRESULT CLTSLexicon::SetObjectToken(ISpObjectToken * pToken // token pointer
                                    )
{
    USES_CONVERSION;

    SPDBG_FUNC("CLTSLexicon::SetObjectToken");

    HRESULT hr = S_OK;
    WCHAR *pszLexFile = NULL;
    if (!pToken)
    {
        hr = E_POINTER;
    }
    if (SUCCEEDED(hr))
    {
        if (SPIsBadInterfacePtr(pToken))
        {
            hr = E_INVALIDARG;
        }
    }
    if (SUCCEEDED(hr))
    {
        CleanUp();
        hr = SpGenericSetObjectToken(pToken, m_cpObjectToken);
    }
    // Get the lts data file name
    if (SUCCEEDED(hr))
    {
        hr = m_cpObjectToken->GetStringValue(L"Datafile", &pszLexFile);
    }
    // Open the Lts lexicon file
    if (SUCCEEDED(hr))
    {
        m_hLtsFile = g_Unicode.CreateFile (pszLexFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                                           FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
        if (m_hLtsFile == INVALID_HANDLE_VALUE)
        {
            hr = SpHrFromLastWin32Error(); // bad input
        }
    }
    LTSLEXINFO LtsInfo;
    DWORD dwRead;
    if (SUCCEEDED(hr))
    {
        if (!ReadFile(m_hLtsFile, &LtsInfo, sizeof(LTSLEXINFO), &dwRead, NULL) || dwRead != sizeof(LTSLEXINFO))
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    if (SUCCEEDED(hr))
    {
        if (guidLtsValidationId != LtsInfo.guidValidationId ||
            (LtsInfo.LangID != 1033 && LtsInfo.LangID != 1041))
        {
            hr = E_INVALIDARG;
        }
    }
    /** WARNINIG **/
    // It is not recommended to do ReadFile/WriteFile and CreateFileMapping
    // on the same file handle. That is why we close the file handle and open it again and
    // create the map

    // Close the file and reopen since we have read from this file
    CloseHandle(m_hLtsFile);
    
    // Get the map name - We build the map name from the lexicon file name
	OLECHAR szMapName[_MAX_PATH];
	wcscpy(szMapName, pszLexFile);
    for( int i = 0; i < _MAX_PATH-1 && szMapName[i]; i++ )
    {
        if( szMapName[i] == '\\' )
        {
            // Change backslash to underscore
            szMapName[i] = '_';
        }
    }

    // Open the Lts lexicon file
    if (SUCCEEDED(hr))
    {
#ifdef _WIN32_WCE
        m_hLtsFile = g_Unicode.CreateFileForMappingW(pszLexFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
#else
        m_hLtsFile = g_Unicode.CreateFile(pszLexFile, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING,
                                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS, NULL);
#endif
        if (m_hLtsFile == INVALID_HANDLE_VALUE)
        {
            hr = SpHrFromLastWin32Error(); // bad input
        }
        ::CoTaskMemFree(pszLexFile);
    }
    // Map the Lts lexicon
    if (SUCCEEDED(hr))
    {
        m_hLtsMap = g_Unicode.CreateFileMapping(m_hLtsFile, NULL, PAGE_READONLY | SEC_COMMIT, 0 , 0, szMapName);
        if (!m_hLtsMap)
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    if (SUCCEEDED(hr))
    {
        m_pLtsData = (PBYTE) MapViewOfFile (m_hLtsMap, FILE_MAP_READ, 0, 0, 0);
        if (!m_pLtsData)
        {
            hr = SpHrFromLastWin32Error();
        }
    }
    if (SUCCEEDED(hr))
    {
        m_pLtsLexInfo = (LTSLEXINFO*)m_pLtsData;
    }
    DWORD nOffset = sizeof(LTSLEXINFO);
    // Create and init the converter object
    if (SUCCEEDED(hr))
    {
//        hr = SpCreatePhoneConverter(LtsInfo.LangID, L"Type=LTS", NULL, &m_cpPhoneConv);
        hr = SpCreateObjectFromSubToken(pToken, L"PhoneConverter", &m_cpPhoneConv);
    }
    if (SUCCEEDED(hr))
    {
        nOffset += strlen((char*)(m_pLtsData + nOffset)) + 1;
        m_pLTSForest = ::LtscartReadData(m_pLtsLexInfo->LangID, m_pLtsData + nOffset);
        if (!m_pLTSForest)
        {
            hr = E_OUTOFMEMORY;
        }
    }
    if (SUCCEEDED(hr))
    {
        m_fInit = true;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\spcommon\ltscart.h ===
#ifndef _LTS_CART_H
#define _LTS_CART_H

#include "CommonLx.h"

#define INPUT  0
#define OUTPUT 1
#define _LEFT   2
#define _RIGHT  3

#define OUTPUT_QUES_OFFSET 20000
#define RIGHT_QUES_OFFSET 10000
#define QUESTION_CODE_RANGE 1000

#define MAX_PRODUCTS 300

#define CLR_BIT(array, n)       ((array)[(n)/32] &= ~(1<<((n)%32)))
#define SET_BIT(array, n)       ((array)[(n)/32] |=  (1<<((n)%32)))
#define TST_BIT(array, n)       ((array)[(n)/32] &   (1<<((n)%32)))

#define LONGEST_STR 1024
#define NULL_SYMBOL_ID 0
#define NO_SYMBOL -1

typedef unsigned char SYMBOL;

typedef struct 
{
  int n_symbols;
  UNALIGNED int *sym_idx;
  int n_bytes;
  char *storage;
} LTS_SYMTAB;

typedef struct
{
  SYMBOL *pIn;
  SYMBOL *pOut;
} LTS_SAMPLE;

typedef struct 
{
  int n_feat;
  int dim;
  int **feature;
} LTS_FEATURE;

typedef struct t_node 
{
  float entropy_dec;
  int n_samples;
  int *count;
  char *prod;
  int index;
  struct t_node *yes_child;
  struct t_node *no_child;
} T_NODE;

#define NO_CHILD 0
#define IS_LEAF_NODE(x) ((x)->yes == NO_CHILD)
typedef struct 
{
  unsigned short yes;   /* index to yes child, no child will always follow */
  int idx;   /* index to prod (for internal) and dist (for leaf) */     
} LTS_NODE;

typedef struct 
{
  short id;
  short cnt;
} LTS_PAIR;

typedef struct 
{
  int c_dists;
  LTS_PAIR p_pair;
} LTS_DIST;

typedef unsigned short LTS_PROD;

#define PROD_NEG  0x8000
#define MAX_PROD  0x8ffc
#define PROD_TERM 0xfffe
#define QUES_TERM 0xffff

typedef struct 
{
  int n_nodes;
  LTS_NODE *nodes;
  LTS_DIST *p_dist;
  int size_dist;
  LTS_PROD *p_prod;
  int size_prod;
} LTS_TREE;

#define MAX_ALT_STRINGS 64
#define INC_ALT_STRINGS 32
#define MAX_OUTPUT_STRINGS 10
#define MIN_OUT_PROB 0.01f
#define DEFAULT_PRUNE 0.1f

typedef struct
{
  float prob;
  char  pstr[SP_MAX_PRON_LENGTH];
} LTS_OUT_PRON;

typedef struct
{
  int num_prons;
  char word[SP_MAX_WORD_LENGTH];
  LTS_OUT_PRON pron[MAX_OUTPUT_STRINGS];
} LTS_OUTPUT;

typedef struct
{
  float prob;
  SYMBOL psym[SP_MAX_WORD_LENGTH];
} LTS_OUT_STRING;

typedef struct outresult
{
  int num_strings;
  int num_allocated_strings;
  LTS_OUT_STRING **out_strings;
} LTS_OUT_RESULT;

typedef struct 
{
  LTS_SYMTAB *symbols;
  LTS_FEATURE *features;
  LTS_TREE **tree;
  LTS_OUTPUT out;
  const char *bogus_pron;
  const char **single_letter_pron;
} LTS_FOREST;

typedef struct simp_question
{
  char questype;
  char context;
  char offset;
  short feature;
} SIMPLE_QUESTION;

#define QUES_DECODE(code, questype, context, offset, feature) \
{ \
  int c = code; \
  if (c > OUTPUT_QUES_OFFSET) { \
    questype = OUTPUT; \
    c -= OUTPUT_QUES_OFFSET; \
  } \
  else \
    questype = INPUT; \
  if (c > RIGHT_QUES_OFFSET) { \
    context = _RIGHT; \
    c -= RIGHT_QUES_OFFSET; \
  } \
  else \
    context = _LEFT; \
  offset = c / QUESTION_CODE_RANGE; \
  feature = c % QUESTION_CODE_RANGE; \
}

#define SAMPLE_GET_CONTEXT(sample, questype, context, offset, id) { \
  SYMBOL *ps, i; \
  if ((questype) == INPUT) \
    ps = (sample)->pIn; \
  else \
    ps = (sample)->pOut; \
  if ((context) == _LEFT) { \
    for (i = 0; i < (offset) && *ps != NULL_SYMBOL_ID; i++, ps--); \
    id = *ps; \
  } \
  else { \
    for (i = 0; i < (offset) && *ps != NULL_SYMBOL_ID; i++, ps++); \
    id = *ps; \
  } \
}

#ifdef __cplusplus
extern "C" {
#endif
LTS_FOREST *LtscartReadData (LCID , PBYTE);
void LtscartFreeData (LTS_FOREST *l_forest);
HRESULT LtscartGetPron(LTS_FOREST *l_forest, char *word, LTS_OUTPUT **ppLtsOutput);
#ifdef __cplusplus
}
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\include\streamhlp.h ===
#pragma once

#include <spunicode.h>

/****************************************************************************
* SpGenericCopyTo *
*-----------------*
*   Description:
*       This function is used by stream implementations to implement the CopyTo method of IStream.
*       Note that the source stream is not parameter validated since it will be the "this" pointer
*       of the object that is calling this function.
*
*   Returns:
*
*****************************************************************************/
inline HRESULT SpGenericCopyTo(IStream * pSrc, IStream * pDest, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
    HRESULT hr = S_OK;
    if (::IsBadReadPtr(pDest, sizeof(*pDest)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        if ((pcbRead && ::IsBadWritePtr(pcbRead, sizeof(*pcbRead))) ||
            (pcbWritten && ::IsBadWritePtr(pcbWritten, sizeof(*pcbWritten))))
        {
            hr = E_POINTER;
        }
        else
        {
            BYTE aBuffer[0x1000];   // Do 4k reads
            while (cb.QuadPart)
            {
                ULONG cbThisRead = cb.QuadPart > sizeof(aBuffer) ? sizeof(aBuffer) : cb.LowPart;
                ULONG cbActuallyRead = 0;
                hr = pSrc->Read(aBuffer, cbThisRead, &cbActuallyRead);
                if (pcbRead)
                {
                    pcbRead->QuadPart += cbActuallyRead;
                }
                if (FAILED(hr) || cbActuallyRead == 0)
                {
                    break;
                }
                ULONG cbActuallyWritten = 0;
                hr = pDest->Write(aBuffer, cbActuallyRead, &cbActuallyWritten);
                if (pcbWritten)
                {
                    pcbWritten->QuadPart += cbActuallyWritten;
                }
                if (FAILED(hr))
                {
                    break;
                }
                cb.QuadPart -= cbActuallyRead;
            }
        }
    }
    return hr;
}


/****************************************************************************
* SPCreateStreamOnHGlobal *
*-------------------------*
*   Description:
*       Similar to CreateStreamOnHGlobal Win32 API, but allows a stream to be
*   created 
*
*   Returns:
*
*****************************************************************************/

inline HRESULT SPCreateStreamOnHGlobal(
                    HGLOBAL hGlobal,            //Memory handle for the stream object
                    BOOL fDeleteOnRelease,      //Whether to free memory when the object is released
                    REFGUID rguidFormatId,      //Format ID for stream
                    const WAVEFORMATEX * pwfex, //WaveFormatEx for stream
                    ISpStream ** ppStream)      //Address of variable to receive ISpStream pointer
{
    HRESULT hr;
    IStream * pMemStream;
    *ppStream = NULL;
    hr = ::CreateStreamOnHGlobal(hGlobal, fDeleteOnRelease, &pMemStream);
    if (SUCCEEDED(hr))
    {
        hr = ::CoCreateInstance(CLSID_SpStream, NULL, CLSCTX_ALL, __uuidof(*ppStream), (void **)ppStream);
        if (SUCCEEDED(hr))
        {
            hr = (*ppStream)->SetBaseStream(pMemStream, rguidFormatId, pwfex);
            if (FAILED(hr))
            {
                (*ppStream)->Release();
                *ppStream = NULL;
            }
        }
        pMemStream->Release();
    }
    return hr;
}



/****************************************************************************
* CSpFileStream *
*---------------*
*   Description:
*       This C++ class can be used by applications to turn a Win32 file into
*   a COM stream.  Usually it is easier to use the CLSD_SpStream implementation
*   than to use this class directly, but this class allows for more fine-grained
*   control over various attributes, such as security attributes.  You can also
*   use this class to create a stream from an existing file handle.  Note that
*   if you want to use this class on an existing Win32 file handle, you should
*   either "give ownership" of that handle to this class (and allow this class
*   to close the handle) or else you will need to use DuplicateHandle to create
*   a handle that can be closed by this class.
*
*   NOTE:
*       Upon creation of this class, the ref count is set to 1.
*
*****************************************************************************/

class CSpFileStream : public IStream
{
private:
    HANDLE      m_hFile;
    ULONG       m_ulRef;
public:
    CSpFileStream(HANDLE hFile) : m_hFile(hFile), m_ulRef(1) {}

    CSpFileStream(HRESULT * pHR, const TCHAR * pFileName, DWORD dwDesiredAccess = GENERIC_READ, DWORD dwShareMode = FILE_SHARE_READ, DWORD dwCreationDisposition = OPEN_EXISTING,
                  LPSECURITY_ATTRIBUTES lpSecurityAttrib = NULL, DWORD dwFlagsAndAttrib = 0, HANDLE hTemplate = NULL)
    {
        m_hFile = ::CreateFile(pFileName, dwDesiredAccess, dwShareMode, lpSecurityAttrib, dwCreationDisposition, dwFlagsAndAttrib, hTemplate);
        m_ulRef = 1;
        *pHR = (m_hFile != INVALID_HANDLE_VALUE) ? S_OK : SpHrFromLastWin32Error();
    }

#ifndef _UNICODE
    CSpFileStream(HRESULT * pHR, const WCHAR * pFileName, DWORD dwDesiredAccess = GENERIC_READ, DWORD dwShareMode = FILE_SHARE_READ, DWORD dwCreationDisposition = OPEN_EXISTING,
                  LPSECURITY_ATTRIBUTES lpSecurityAttrib = NULL, DWORD dwFlagsAndAttrib = 0, HANDLE hTemplate = NULL)
    {
        CSpUnicodeSupport Unicode;
        m_hFile = Unicode.CreateFile(pFileName, dwDesiredAccess, dwShareMode, lpSecurityAttrib, dwCreationDisposition, dwFlagsAndAttrib, hTemplate);
        m_ulRef = 1;
        *pHR = (m_hFile != INVALID_HANDLE_VALUE) ? S_OK : SpHrFromLastWin32Error();
    }
#endif

    ~CSpFileStream()
    {
        if (m_hFile != INVALID_HANDLE_VALUE)
        {
            ::CloseHandle(m_hFile);
        }
    }


    HANDLE FileHandle()
    {
        return m_hFile;
    }

    HRESULT Close(void)
    {
        HRESULT hr = S_OK;
        if (m_hFile != INVALID_HANDLE_VALUE)
        {
            if (!::CloseHandle(m_hFile))
            {
                hr = SpHrFromLastWin32Error();
            }
            m_hFile = INVALID_HANDLE_VALUE;
        }
        else
        {
            hr = SPERR_UNINITIALIZED;
        }
        return hr;
    }
            

    STDMETHODIMP QueryInterface(REFIID riid, void ** ppv)
    {
        if (riid == __uuidof(IStream) ||
            riid == IID_ISequentialStream ||
            riid == __uuidof(IUnknown))
        {
            *ppv = (IStream *)this;
            m_ulRef++;
            return S_OK;
        }
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++m_ulRef;
    }

    STDMETHODIMP_(ULONG) Release()
    {
        --m_ulRef;
        if (m_ulRef)
        {
            return m_ulRef;
        }
        delete this;
        return 0;
    }

    STDMETHODIMP Read(void * pv, ULONG cb, ULONG * pcbRead)
    {
        ULONG ulRead;
        if (::ReadFile(m_hFile, pv, cb, &ulRead, NULL))
        {
            if (pcbRead) *pcbRead = ulRead;
            return S_OK;
        }
        return SpHrFromLastWin32Error();
    }
    STDMETHODIMP Write(const void * pv, ULONG cb, ULONG * pcbWritten)
    {
        ULONG ulWritten;
        if (::WriteFile(m_hFile, pv, cb, &ulWritten, NULL))
        {
            if (pcbWritten) *pcbWritten = ulWritten;
            return S_OK;
        }
        return SpHrFromLastWin32Error();
    }

    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
    {
        long lMoveHigh = dlibMove.HighPart;
        DWORD dwNewPos = ::SetFilePointer(m_hFile, dlibMove.LowPart, &lMoveHigh, dwOrigin);
        if (dwNewPos == 0xFFFFFFFF && ::GetLastError() != NO_ERROR)
        {
            return SpHrFromLastWin32Error();
        }
        if (plibNewPosition)
        {
            plibNewPosition->LowPart = dwNewPos;
            plibNewPosition->HighPart = lMoveHigh;
        }
        return S_OK;
    }

    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize) 
    {
        HRESULT hr = S_OK;
        LARGE_INTEGER Move = {0};
        ULARGE_INTEGER Cur;
        hr = Seek(Move, STREAM_SEEK_CUR, &Cur);
        if (SUCCEEDED(hr))
        {
            LARGE_INTEGER li;
            li.QuadPart = libNewSize.QuadPart;
            hr = Seek(li, STREAM_SEEK_SET, NULL);
            if (SUCCEEDED(hr))
            {
                if (!::SetEndOfFile(m_hFile))
                {
                    hr = SpHrFromLastWin32Error();
                }
                li.QuadPart = Cur.QuadPart;
                Seek(li, STREAM_SEEK_SET, NULL);
            }
        }
        return hr;
    }
   
    STDMETHODIMP CopyTo(IStream *pStreamDest, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER __RPC_FAR *pcbWritten)
    {
        return SpGenericCopyTo(this, pStreamDest, cb, pcbRead, pcbWritten);
    }
        
    STDMETHODIMP Commit(DWORD /*grfCommitFlags*/)
    {
        return S_OK;    // Direct mode streams simply ignore this
    }
        
    STDMETHODIMP Revert(void) 
    {
        return S_OK;    // Direct mode streams simply ignore this
    }
        
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) 
    {
#ifndef _WIN32_WCE
        if (dwLockType != LOCK_WRITE && dwLockType != LOCK_EXCLUSIVE)
        {
            return STG_E_INVALIDFUNCTION;
        }
        DWORD dwFlags = LOCKFILE_FAIL_IMMEDIATELY;
        if (dwLockType == LOCK_EXCLUSIVE)
        {
            dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;
        }
        OVERLAPPED Overlapped;
        memset(&Overlapped, 0, sizeof(Overlapped));
        Overlapped.Offset = libOffset.LowPart;
        Overlapped.OffsetHigh = libOffset.HighPart;
        if (::LockFileEx(m_hFile, dwFlags, 0, cb.LowPart, cb.HighPart, &Overlapped))
        {
            return S_OK;
        }
        else
        {
            DWORD dwErr = ::GetLastError();
            if (dwErr == ERROR_LOCK_VIOLATION)
            {
                return STG_E_LOCKVIOLATION;
            }
            return SpHrFromWin32(dwErr);
        }
#else //  _WIN32_WCE
    return E_NOTIMPL;
#endif // _WIN32_WCE
    }
    
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
    {
#ifndef _WIN32_WCE
        if (dwLockType != LOCK_WRITE && dwLockType != LOCK_EXCLUSIVE)
        {
            return STG_E_INVALIDFUNCTION;
        }
        OVERLAPPED Overlapped;
        memset(&Overlapped, 0, sizeof(Overlapped));
        Overlapped.Offset = libOffset.LowPart;
        Overlapped.OffsetHigh = libOffset.HighPart;
        if (::UnlockFileEx(m_hFile, 0, cb.LowPart, cb.HighPart, &Overlapped))
        {
            return S_OK;
        }
        else
        {
            DWORD dwErr = ::GetLastError();
            if (dwErr == ERROR_LOCK_VIOLATION)
            {
                return STG_E_LOCKVIOLATION;
            }
            return SpHrFromWin32(dwErr);
        }
#else //  _WIN32_WCE
    return E_NOTIMPL;
#endif // _WIN32_WCE
    }
        
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag)
    {
        HRESULT hr = S_OK;
        if (grfStatFlag & (~STATFLAG_NONAME))
        {
            hr = E_INVALIDARG;
        }
        else
        {
            ZeroMemory(pstatstg, sizeof(*pstatstg));
            pstatstg->grfLocksSupported = LOCK_WRITE | LOCK_EXCLUSIVE;
            pstatstg->type = STGTY_STREAM;
            BY_HANDLE_FILE_INFORMATION fi;
            if (::GetFileInformationByHandle(m_hFile, &fi))
            {
                pstatstg->cbSize.LowPart = fi.nFileSizeLow;
                pstatstg->cbSize.HighPart = fi.nFileSizeHigh;
                pstatstg->mtime = fi.ftLastWriteTime;
                pstatstg->ctime = fi.ftCreationTime;
                pstatstg->atime = fi.ftLastAccessTime;
                // This implementation does not fill in the mode or the name.
            }
        }
        return hr;
    }
        
    STDMETHODIMP Clone(IStream ** ppstm)
    {
        HANDLE hDupFile;
#ifndef _WIN32_WCE
        HANDLE hProcess = ::GetCurrentProcess();
        if (::DuplicateHandle(hProcess, m_hFile, hProcess, &hDupFile, 0, TRUE, DUPLICATE_SAME_ACCESS))
        {
            *ppstm = new CSpFileStream(hDupFile);
            if (*ppstm)
            {
                return S_OK;
            }
            ::CloseHandle(hDupFile);
            return E_OUTOFMEMORY;
        }
        else
        {
            return SpHrFromLastWin32Error();
        }
#else   // _WIN32_WCE
        hDupFile = m_hFile;
        *ppstm = new CSpFileStream(hDupFile);
        if (*ppstm)
        {
            return S_OK;
        }
        return E_OUTOFMEMORY;
#endif  // _WIN32_WCE
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\spcommon\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\spcommon\makefile.inc ===
SelfRegister :
!if defined(MAKEDLL)
	regsvr32 /s $(O)\spcommon.dll
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\include\stringblob.h ===
/*******************************************************************************
* StringBlob.h *
*--------------*
*   Description:
*       This is the header file for the CStringBlob class used internally by SAPI.
*
*   Copyright 1998-2000 Microsoft Corporation All Rights Reserved.
*
*******************************************************************************/

#ifndef _STRINGBLOB_H_
#define _STRINGBLOB_H_ 1

#ifndef SPDebug_h
#include <SPDebug.h>
#endif

#include <math.h>

template <class XCHAR>
class CStringBlobT
{
    XCHAR *     m_pData;            // List of words, end-to-end
    ULONG       m_cchAllocated;     // Size of m_pData
    ULONG *     m_aichWords;        // Word index => offset in m_pData  [1] is index of start of second word
    ULONG       m_cwords;           // Number of words
    ULONG       m_cwordsAllocated;  // Size of m_aichWords
    ULONG *     m_aulBuckets;       // Hash table containing indices of words or 0 for empty buckets
    ULONG       m_cBuckets;         // Number of buckets in hash table

public:
    CStringBlobT()
    {
        m_pData = NULL;
        m_cchAllocated = 0;
        m_aichWords = NULL;
        m_cwords = 0;
        m_cwordsAllocated = 0;
        m_aulBuckets = NULL;
        m_cBuckets = 0;
    }

    ~CStringBlobT()
    {
        Clear();
    }

    void Detach(XCHAR **ppszWordList, ULONG *pulSize)
    {
        *ppszWordList = NULL;
        if (m_pData)
        {
            ULONG cchDesired = StringSize();
            ULONG cbSize = SerializeSize(); // byte count, ULONG multiple

            *ppszWordList = (XCHAR*)::CoTaskMemRealloc(m_pData, cbSize);
            if (*ppszWordList == NULL)
            {
                *ppszWordList = m_pData;
                cbSize = m_cchAllocated * sizeof(XCHAR);
            }
            m_pData = NULL;

            Clear();

            if (pulSize)
            {
                *pulSize = cbSize;
            }
        }
    }

    void Clear()
    {
        if (m_pData)
        {
            ::CoTaskMemFree(m_pData);
            m_pData = NULL;
        }
        m_cchAllocated = 0;

        free(m_aichWords);
        m_aichWords = NULL;
        m_cwordsAllocated = 0;
        m_cwords = 0;

        free(m_aulBuckets);
        m_aulBuckets = NULL;
        m_cBuckets = 0;
    }

    HRESULT InitFrom(const XCHAR * pszStringArray, ULONG cch)
    {
        SPDBG_ASSERT(m_pData == NULL);

        if (cch)
        {
            ULONG cbSize = (cch * sizeof(XCHAR) + 3) & ~3;
            m_pData = (XCHAR *)::CoTaskMemAlloc(cbSize);
            if (m_pData == NULL)
                return E_OUTOFMEMORY;
            m_cchAllocated = cch;

            SPDBG_ASSERT(pszStringArray[0] == 0);   // First string is always empty.

            // First pass to copy data and count strings.
            const XCHAR * pszPastEnd = pszStringArray + cch;
            const XCHAR * psz = pszStringArray;
            XCHAR * pszOut = m_pData;
            ULONG cwords = 0;

            while (psz < pszPastEnd)
            {
                if ((*pszOut++ = *psz++) == 0)
                    ++cwords;
            }

            m_aichWords = (ULONG *) malloc(sizeof(ULONG) * cwords);
            if (m_aichWords == NULL)
                return E_OUTOFMEMORY;
            m_cwordsAllocated = cwords;
            m_cwords = cwords - 1;  // Doesn't count leading 0

            HRESULT hr = SetHashSize(cwords * 2 + 1);
            if (FAILED(hr))
                return hr;

            // Second pass to fill in indices and hash table.
            psz = pszStringArray + 1;
            const WCHAR * pszWordStart = psz;
            ULONG ulID = 1;
            m_aichWords[0] = 1;
            while (psz < pszPastEnd)
            {
                if (*(psz++) == 0)
                {
                    SPDBG_ASSERT(ulID < m_cwordsAllocated);

                    m_aichWords[ulID] = (ULONG)(psz - pszStringArray); // can't have more than 4 million chars!
                
                    m_aulBuckets[FindIndex(pszWordStart)] = ulID;

                    pszWordStart = psz;
                    ++ulID;
                }
            }
        }

        return S_OK;
    }
    
    ULONG HashKey(const XCHAR * pszString, ULONG * pcchIncNull = NULL)
    {
        ULONG hash = 0;
        ULONG cchIncNull = 1;   // one for the NULL

	    for (const XCHAR * pch = pszString; *pch; ++pch, ++cchIncNull)
            hash = hash * 65599 + *pch;

        if (pcchIncNull)
            *pcchIncNull = cchIncNull;
        return hash;
    }

    // find index for string -- returns 0 if not found
    ULONG FindIndex(const XCHAR * psz)
    {
        SPDBG_ASSERT(psz);
        ULONG cchIncNull;
        ULONG start = HashKey(psz, &cchIncNull) % m_cBuckets;
        ULONG index = start;

        do
        {
            // Not in table; return index where it should be placed.
            if (m_aulBuckets[index] == 0)
                return index;

            // Compare length and if it matches compare full string.
            if (m_aichWords[m_aulBuckets[index]] - m_aichWords[m_aulBuckets[index] - 1] == cchIncNull &&
                IsEqual(m_aichWords[m_aulBuckets[index] - 1], psz))
            {
                // Found this word already in the table.
                return index;
            }

            if (++index >= m_cBuckets)
                index -= m_cBuckets;
        } while (index != start);

        SPDBG_ASSERT(m_cwords == m_cBuckets);   // Shouldn't ever get here

        return (ULONG) -1;
    }


    // Returns ID; use IndexFromId to recover string offset
    ULONG Find(const XCHAR * psz)
    {
        if (psz == NULL || m_cwords == 0)
            return 0;

        // Should always succeed in finding a bucket, since hash table is >2x larger than # of elements.
        ULONG   ibucket = FindIndex(psz);
        return m_aulBuckets[ibucket];    // May be 0 if not in table
    }


    ULONG primeNext(ULONG val)
    {
        if (val < 2)
            val = 2; /* the smallest prime number */

        for (;;)
        {
            /* Is val a prime number? */
            ULONG maxFactor = (ULONG) sqrt ((double) val);

            /* Is i a factor of val? */
            for (ULONG i = 2; i <= maxFactor; i++)
                if (val % i == 0)
                    break;

            if (i > maxFactor)
                return (val);

            val++;
        }
    }


    HRESULT SetHashSize(ULONG cbuckets)
    {
        if (cbuckets > m_cBuckets)
        {
            ULONG * oldtable = m_aulBuckets;
            ULONG oldentry = m_cBuckets;
            ULONG prime = primeNext(cbuckets);

            // Alloc new table.
            m_aulBuckets = (ULONG *) malloc(prime * sizeof(ULONG));
            if (m_aulBuckets == NULL)
            {
                m_aulBuckets = oldtable;
                return E_OUTOFMEMORY;
            }

            for (ULONG i=0; i < prime; i++)
            {
                m_aulBuckets[i] = 0;
            }

            m_cBuckets = prime;

            for (i = 0; i < oldentry; i++)
            {
                if (oldtable[i] != 0)
                {
                    ULONG ibucket = FindIndex(m_pData + m_aichWords[oldtable[i] - 1]);
                    m_aulBuckets[ibucket] = oldtable[i];
                }
            }

            free(oldtable);
        }

        return S_OK;
    }


    //
    //  The ID for a NULL string is always 0, the ID for subsequent strings is the
    //  index of the string + 1;
    //
    HRESULT Add(const XCHAR * psz, ULONG * pichOffset, ULONG *pulID = NULL)
    {
        ULONG   ID = 0;

        if (psz)
        {
            // Grow if we're more than half full.
            if (m_cwords * 2 >= m_cBuckets)
            {
                HRESULT hr = SetHashSize(m_cwords * 3 + 17);
                if (FAILED(hr))
                    return hr;
            }

            // Find out where this element should end up in hash table.
            ULONG ibucket = FindIndex(psz);

            if (m_aulBuckets[ibucket] == 0)
            {
                // Not found in hash table.  Append it to the end.

                // Grow ID=>index mapping array if necessary.
                if (m_cwords + 1 >= m_cwordsAllocated)  // 1 extra for init. zero
                {
                    void * pvNew = realloc(m_aichWords, sizeof(*m_aichWords) * (m_cwords + 100));
                    if (pvNew == NULL)
                        return E_OUTOFMEMORY;
                    m_aichWords = (ULONG *)pvNew;
                    m_cwordsAllocated = m_cwords + 100;
                    m_aichWords[0] = 1;
                }

                // Grow string storage if necessary.
                ULONG   cchIncNull = xcslen(psz);
                if (m_aichWords[m_cwords] + cchIncNull > m_cchAllocated)
                {
                    ULONG cbDesired = ((m_cchAllocated + cchIncNull) * sizeof(XCHAR) + 0x2003) & ~3;
                    void * pvNew = ::CoTaskMemRealloc(m_pData, cbDesired);
                    if (pvNew == NULL)
                    {
                        return E_OUTOFMEMORY;
                    }
                    m_pData = (XCHAR *)pvNew;

                    m_pData[0] = 0;
                    m_cchAllocated = cbDesired / sizeof(XCHAR);
                }
                memcpy(m_pData + m_aichWords[m_cwords], psz, cchIncNull * sizeof(XCHAR));

                ++m_cwords;

                m_aichWords[m_cwords] = m_aichWords[m_cwords - 1] + cchIncNull;

                // Fill in hash table entry with index of string.
                m_aulBuckets[ibucket] = m_cwords;

                ID = m_cwords;
            }
            else
            {
                // It was already there.
                ID = m_aulBuckets[ibucket];
            }
        }

        *pichOffset = ID ? m_aichWords[ID - 1] : 0;
        if (pulID)
        {
            *pulID = ID;
        }
        return S_OK;        
    }

    const ULONG GetNumItems() const
    {
        return m_cwords;
    }

    const XCHAR * String(ULONG ichOffset) const
    {
        return ichOffset ? m_pData + ichOffset : NULL;
    }

    static int xcscmp(const WCHAR * p0, const WCHAR * p1)
    {
        return wcscmp(p0, p1);
    }

    static int xcscmp(const char * p0, const char * p1)
    {
        return strcmp(p0, p1);
    }

    static int xcslen(const WCHAR * p)
    {
        return wcslen(p) + 1;
    }

    static int xcslen(const char * p)
    {
        return strlen(p) + 1;
    }

    BOOL IsEqual(ULONG ichOffset, const XCHAR * psz)
    {
        if (ichOffset)
        {
            return (psz ? (xcscmp(m_pData + ichOffset, psz) == 0) : FALSE);
        }
        else
        {
            return (psz == NULL);
        }
    }

    ULONG StringSize(void) const
    {
        return m_cwords ? m_aichWords[m_cwords] : 0;
    }

    ULONG IndexFromId(ULONG ulID) const
    {
        SPDBG_ASSERT(ulID <= m_cwords);
        if (ulID > 0)
        {
            return m_aichWords[ulID - 1];
        }
        return 0;
    }

    const XCHAR * Item(ULONG ulID) const
    {
        SPDBG_ASSERT(ulID <= m_cwords);
        if ((ulID < 1) || m_pData == NULL)
        {
            return NULL;
        }

        return m_pData + IndexFromId(ulID);
    }
    
    ULONG SerializeSize() const 
    {
        return (StringSize() * sizeof(XCHAR) + 3) & ~3;
    }

    const XCHAR * SerializeData()
    {
        ULONG cchWrite = StringSize();
        if (cchWrite)
        {
            const ULONG cb = cchWrite * sizeof(XCHAR);

            if (cb % 4)  // We know there's room since data is always DWORD aligned by
            {
                memset(m_pData + cchWrite, 0xcc, 4 - (cb & 3)); // Junk data so make sure it's not null
            }
        }
        return m_pData;
    }
};


typedef class CStringBlobT<WCHAR> CStringBlob;
typedef class CStringBlobT<WCHAR> CStringBlobW;
typedef class CStringBlobT<char>  CStringBlobA;

#endif  // _STRINGBLOB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\spcommon\ltslx.h ===
/*******************************************************************************
*   LTSLx.h
*       This is the header file for the CLTSLexicon class that implements
*       the Letter-To-Sound (LTS) lexicon
*   
*   Owner: yunusm                                               Date: 06/18/99
*   Copyright (C) 1998 Microsoft Corporation. All Rights Reserved.
*******************************************************************************/

#pragma once

//--- Includes -----------------------------------------------------------------

#include "LTSCart.h"
#include "resource.h"
#include "spcommon.h"

//--- Constants ---------------------------------------------------------------

static const DWORD g_dwMaxWordsInCombo = 10;

//--- Class, Struct and Union Definitions -------------------------------------

/*******************************************************************************
*
*   CLTSLexicon
*
****************************************************************** YUNUSM *****/
class ATL_NO_VTABLE CLTSLexicon : 
    public CComObjectRootEx<CComMultiThreadModel>,
    public CComCoClass<CLTSLexicon, &CLSID_SpLTSLexicon>,
    public ISpLexicon,
    public ISpObjectWithToken
{
//=== ATL Setup ===
public:
    DECLARE_REGISTRY_RESOURCEID(IDR_LTSLX)
    DECLARE_PROTECT_FINAL_CONSTRUCT()
    BEGIN_COM_MAP(CLTSLexicon)
        COM_INTERFACE_ENTRY(ISpLexicon)
        COM_INTERFACE_ENTRY(ISpObjectWithToken)
    END_COM_MAP()

//=== Methods ===
public:
    //--- Ctor, dtor, etc
    CLTSLexicon();
    ~CLTSLexicon();
    HRESULT FinalConstruct(void);

    //--- ISpObjectWithToken members
public:
    //--- ISpLexicon
    STDMETHODIMP GetPronunciations(const WCHAR * pwWord, LANGID LangID, DWORD dwFlags, SPWORDPRONUNCIATIONLIST * pWordPronunciationList);
    STDMETHODIMP AddPronunciation(const WCHAR * pwWord, LANGID LangID, SPPARTOFSPEECH ePartOfSpeech, const SPPHONEID * pszPronunciations);
    STDMETHODIMP RemovePronunciation(const WCHAR * pszWord, LANGID LangID, SPPARTOFSPEECH ePartOfSpeech, const SPPHONEID * pszPronunciation);
    STDMETHODIMP GetGeneration(DWORD *pdwGeneration);
    STDMETHODIMP GetGenerationChange(DWORD dwFlags, DWORD *pdwGeneration, SPWORDLIST *pWordList);
    STDMETHODIMP GetWords(DWORD dwFlags, DWORD *pdwGeneration, DWORD *pdwCookie, SPWORDLIST *pWordList);

    //--- ISpObjectWithToken
    STDMETHODIMP SetObjectToken(ISpObjectToken * pToken);
    STDMETHODIMP GetObjectToken(ISpObjectToken ** ppToken);

//=== Private methods ===
private:
    void CleanUp(void);
    void NullMembers(void);

//=== Private data ===
private:
    bool                 m_fInit;             // true if successfully inited
    CComPtr<ISpObjectToken> m_cpObjectToken;  // Token object
    LTSLEXINFO           *m_pLtsLexInfo;      // LTS lexicon header
    BYTE                 *m_pLtsData;         // lts file in memory
    HANDLE               m_hLtsMap;           // phone map
    HANDLE               m_hLtsFile;          // lts data file
    LTS_FOREST           *m_pLTSForest;       // lts rules
    CComPtr<ISpPhoneConverter> m_cpPhoneConv; // phone convertor
};  
    
//--- End of File -------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\spcommon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
//
#define IDR_LTSLX                       100
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\spcommon\spcommonver.h ===
/****************************************************************************
 *                                                                          *
 *      VERSION.H        -- Version information for internal builds         *
 *                                                                          *
 *      This file is only modified by the official builder to update the    *
 *      VERSION, VER_PRODUCTVERSION and VER_PRODUCTVERSION_STR values       *
 *                                                                          *
 *      version.h is created on the fly from verhead.bat and vertail.h,     *
 *      with the current version numbers inserted in between                *
 *                                                                          *
 ****************************************************************************/

#ifndef VER_H
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <winver.h>
#endif
#include <windows.h>
#define VER_FILETYPE                VFT_DLL
#define VER_FILESUBTYPE             VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR     "Microsoft Speech SR/TTS Common Library"
#define VER_INTERNALNAME_STR        "SPCOMMON"
#define VER_ORIGINALFILENAME_STR    "SPCOMMON.DLL"

/*--------------------------------------------------------------*/
/* the following entry should be phased out in favor of         */
/* VER_PRODUCTVERSION_STR, but is used in the shell today.      */
/*--------------------------------------------------------------*/


/*--------------------------------------------------------------*/
/* this include file is generated by the build process to       */
/* reflect the current build number                             */
/*--------------------------------------------------------------*/

#include "currver.inc"

#define OFFICIAL                    1
#define FINAL                       1

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#ifdef _DEBUG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is privatebuild */
#ifndef OFFICIAL
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is prerelease */
#ifndef FINAL
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_DOS_WINDOWS32
#define VER_FILEFLAGS               (VER_PRIVATEBUILD|VER_PRERELEASE|VER_DEBUG)

#define VER_COMPANYNAME_STR         "Microsoft Corporation\0"
#define VER_PRODUCTNAME_STR         "Microsoft Speech Engine\0"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation.\0"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\spcommon\spcommon.cpp ===
// Speech.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f Speechps.mk in the project directory.

#include "stdafx.h"
#include <SPDebug.h>
#include <initguid.h>
#include "resource.h"
#include "spcommon.h"
#include "spcommon_i.c"
#include "sapi_i.c"
#include "ltslx.h"
#include "AssertWithStack.cpp"

//--- Initialize static member of debug scope class

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SpLTSLexicon         , CLTSLexicon       )
END_OBJECT_MAP()


CSpUnicodeSupport   g_Unicode;

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

#ifdef _WIN32_WCE
extern "C" BOOL WINAPI DllMain(HANDLE hInstance, ULONG dwReason, LPVOID)
#else
extern "C" BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID)
#endif
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, (HINSTANCE)hInstance, &LIBID_LTSCommLib);
#ifdef _DEBUG
        // Turn on memory leak checking
        int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
        tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
        _CrtSetDbgFlag( tmpFlag );
#endif
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI
DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type
STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    #ifdef _DEBUG
    static BOOL fDoneOnce = FALSE;
    if (!fDoneOnce)
    {
        fDoneOnce = TRUE;
        SPDBG_DEBUG_CLIENT_ON_START();
    }
    #endif // _DEBUG

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI
DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI
DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\common\spcommon\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__96749368_3391_11D2_9EE3_00C04F797396__INCLUDED_)
#define AFX_STDAFX_H__96749368_3391_11D2_9EE3_00C04F797396__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

//#define _ATL_DEBUG_QI

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>
#include <spunicode.h>

#ifndef _WIN32_WCE
#pragma intrinsic( strcat, strlen, strcpy, memcpy )
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__96749368_3391_11D2_9EE3_00C04F797396__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\patch\include\atlbase.h ===
// This is a part of the Active Template Library.
// Copyright (C) 1996-1998 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Active Template Library Reference and related
// electronic documentation provided with the library.
// See these sources for detailed information regarding the
// Active Template Library product.

#ifndef __ATLBASE_H__
#define __ATLBASE_H__

#ifndef __cplusplus
	#error ATL requires C++ compilation (use a .cpp suffix)
#endif

#if defined(_WIN32_WCE) && (_WIN32_WCE < 200)
#error "ATL projects can only be compiled for Windows CE 2.0 or later."
#endif // _WIN32_WCE

#if defined(_WIN32_WCE)
#include "wceatl.h"
#define WCE_DEL /##/
#define WCE_INS
#define WCE_FCTN(fctn) wce_##fctn
#define WCE_IF(wce,base) wce
#define WCE_ATL_LIBNAME                WCE_FILENAME_1(atlce,_WIN32_WCE,.lib)
#define WCE_FILENAME_1(name, ver, ext) WCE_FILENAME_2(name, ver, ext)
#define WCE_FILENAME_2(name, ver, ext) #name #ver #ext
#else // _WIN32_WCE
#define _T(x) x
#define WCE_DEL
#define WCE_INS /##/
#define WCE_FCTN(fctn) fctn
#define WCE_IF(wce,base) base
#endif // _WIN32_WCE
#ifndef _ATL_NO_PRAGMA_WARNINGS
#pragma warning(disable: 4201) // nameless unions are part of C++
#pragma warning(disable: 4127) // constant expression
#pragma warning(disable: 4505) // unreferenced local function has been removed
#pragma warning(disable: 4512) // can't generate assignment operator (so what?)
#pragma warning(disable: 4514) // unreferenced inlines are common
#pragma warning(disable: 4103) // pragma pack
#pragma warning(disable: 4702) // unreachable code
#pragma warning(disable: 4237) // bool
#pragma warning(disable: 4710) // function couldn't be inlined
#pragma warning(disable: 4355) // 'this' : used in base member initializer list
#pragma warning(disable: 4097) // typedef name used as synonym for class-name
#pragma warning(disable: 4786) // identifier was truncated in the debug information
#endif //!_ATL_NO_PRAGMA_WARNINGS

#include <atldef.h>

#include <windows.h>
#include <winnls.h>
#include <ole2.h>

WCE_INS typedef GUID CATID;		// missed definition from comcat.h
WCE_DEL #include <comcat.h>
WCE_DEL #include <stddef.h>

#include <tchar.h>
#include <malloc.h>

#ifndef _ATL_NO_DEBUG_CRT
// Warning: if you define the above symbol, you will have
// to provide your own definition of the ATLASSERT(x) macro
// in order to compile ATL
	#include <crtdbg.h>
#endif

#include <olectl.h>
#include <winreg.h>
#include <atliface.h>

#ifdef _DEBUG
WCE_DEL #include <stdio.h>
#include <stdarg.h>
#endif

#include <atlconv.h>

WCE_DEL #include <shlwapi.h>

#pragma pack(push, _ATL_PACKING)

#if defined(_ATL_DLL)
#if defined(_WIN32_WCE)
	#pragma comment(lib, WCE_ATL_LIBNAME)
#else // _WIN32_WCE
	#pragma comment(lib, "atl.lib")
#endif // _WIN32_WCE
#endif
#if defined(_WIN32_WCE)
namespace ATL
{
	HRESULT wce_OleLoadFromStream ( LPSTREAM pStm, REFIID iidInterface, LPVOID FAR* ppvObj);
	HRESULT wce_OleSaveToStream ( LPPERSISTSTREAM pPStm, LPSTREAM pStm);
	HRESULT wce_ProgIDFromCLSID(REFCLSID clsid, LPOLESTR *lplpszProgID);
	HRESULT wce_CLSIDFromProgID(LPCOLESTR lpszProgID, LPCLSID pclsid);
	HRESULT wce_CreateStreamOnHGlobal(HGLOBAL hGlobal, BOOL fDeleteOnRelease, LPSTREAM *ppstm);
	int	wce_MulDiv(int nNumber, int nNumerator, int nDenominator);
} // namespace ATL

#endif // _WIN32_WCE

extern "C" const __declspec(selectany) GUID LIBID_ATLLib = {0x44EC0535,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) CLSID CLSID_Registrar = {0x44EC053A,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) IID IID_IRegistrar = {0x44EC053B,0x400F,0x11D0,{0x9D,0xCD,0x00,0xA0,0xC9,0x03,0x91,0xD3}};
extern "C" const __declspec(selectany) IID IID_IAxWinHostWindow = {0xb6ea2050,0x48a,0x11d1,{0x82,0xb9,0x0,0xc0,0x4f,0xb9,0x94,0x2e}};
extern "C" const __declspec(selectany) IID IID_IAxWinAmbientDispatch = {0xb6ea2051,0x48a,0x11d1,{0x82,0xb9,0x0,0xc0,0x4f,0xb9,0x94,0x2e}};
WCE_DEL extern "C" const __declspec(selectany) IID IID_IInternalConnection = {0x72AD0770,0x6A9F,0x11d1,{0xBC,0xEC,0x00,0x60,0x08,0x8F,0x44,0x4E}};
WCE_DEL extern "C" const __declspec(selectany) IID IID_IDocHostUIHandlerDispatch = {0x425B5AF0,0x65F1,0x11d1,{0x96,0x11,0x00,0x00,0xF8,0x1E,0x0D,0x0D}};

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

struct _ATL_CATMAP_ENTRY
{
   int iType;
   const CATID* pcatid;
};

#define _ATL_CATMAP_ENTRY_END 0
#define _ATL_CATMAP_ENTRY_IMPLEMENTED 1
#define _ATL_CATMAP_ENTRY_REQUIRED 2

typedef HRESULT (WINAPI _ATL_CREATORFUNC)(void* pv, REFIID riid, LPVOID* ppv);
typedef HRESULT (WINAPI _ATL_CREATORARGFUNC)(void* pv, REFIID riid, LPVOID* ppv, DWORD dw);
typedef HRESULT (WINAPI _ATL_MODULEFUNC)(DWORD dw);
typedef LPCTSTR (WINAPI _ATL_DESCRIPTIONFUNC)();
typedef const struct _ATL_CATMAP_ENTRY* (_ATL_CATMAPFUNC)();
typedef void (__stdcall _ATL_TERMFUNC)(DWORD dw);

struct _ATL_TERMFUNC_ELEM
{
	_ATL_TERMFUNC* pFunc;
	DWORD dw;
	_ATL_TERMFUNC_ELEM* pNext;
};

struct _ATL_OBJMAP_ENTRY
{
	const CLSID* pclsid;
	HRESULT (WINAPI *pfnUpdateRegistry)(BOOL bRegister);
	_ATL_CREATORFUNC* pfnGetClassObject;
	_ATL_CREATORFUNC* pfnCreateInstance;
	IUnknown* pCF;
	DWORD dwRegister;
	_ATL_DESCRIPTIONFUNC* pfnGetObjectDescription;
	_ATL_CATMAPFUNC* pfnGetCategoryMap;
#if !defined(_WIN32_WCE)
	HRESULT WINAPI RevokeClassObject()
	{
		return CoRevokeClassObject(dwRegister);
	}
	HRESULT WINAPI RegisterClassObject(DWORD dwClsContext, DWORD dwFlags)
	{
		IUnknown* p = NULL;
		if (pfnGetClassObject == NULL)
			return S_OK;
		HRESULT hRes = pfnGetClassObject(pfnCreateInstance, IID_IUnknown, (LPVOID*) &p);
		if (SUCCEEDED(hRes))
			hRes = CoRegisterClassObject(*pclsid, p, dwClsContext, dwFlags, &dwRegister);
		if (p != NULL)
			p->Release();
		return hRes;
	}
#endif // _WIN32_WCE
// Added in ATL 3.0
	void (WINAPI *pfnObjectMain)(bool bStarting);
};

struct _ATL_REGMAP_ENTRY
{
	LPCOLESTR     szKey;
	LPCOLESTR     szData;
};

struct _AtlCreateWndData
{
	void* m_pThis;
	DWORD m_dwThreadID;
	_AtlCreateWndData* m_pNext;
};

struct _ATL_MODULE
{
// Attributes
public:
	UINT cbSize;
	HINSTANCE m_hInst;
	HINSTANCE m_hInstResource;
	HINSTANCE m_hInstTypeLib;
	_ATL_OBJMAP_ENTRY* m_pObjMap;
	LONG m_nLockCnt;
	HANDLE m_hHeap;
	union
	{
		CRITICAL_SECTION m_csTypeInfoHolder;
		CRITICAL_SECTION m_csStaticDataInit;
	};
	CRITICAL_SECTION m_csWindowCreate;
	CRITICAL_SECTION m_csObjMap;
// Original Size = 100
// Stuff added in ATL 3.0
	DWORD dwAtlBuildVer;
	_AtlCreateWndData* m_pCreateWndList;
	bool m_bDestroyHeap;
	GUID* pguidVer;
	DWORD m_dwHeaps;	// Number of heaps we have (-1)
	HANDLE* m_phHeaps;
	int m_nHeap;		// Which heap to choose from
	_ATL_TERMFUNC_ELEM* m_pTermFuncs;
};

const int _nAtlModuleVer1Size = 100;

//This define makes debugging asserts easier.
#define _ATL_SIMPLEMAPENTRY ((_ATL_CREATORARGFUNC*)1)

struct _ATL_INTMAP_ENTRY
{
	const IID* piid;       // the interface id (IID)
	DWORD dw;
	_ATL_CREATORARGFUNC* pFunc; //NULL:end, 1:offset, n:ptr
};

/////////////////////////////////////////////////////////////////////////////
// QI Support

ATLAPI AtlInternalQueryInterface(void* pThis,
	const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject);

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp);
ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid);

/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

WCE_DEL ATLAPI AtlFreeMarshalStream(IStream* pStream);
WCE_DEL ATLAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream);
WCE_DEL ATLAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk);

WCE_DEL ATLAPI_(BOOL) AtlWaitWithMessageLoop(HANDLE hEvent);

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

ATLAPI AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw);
ATLAPI AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw);

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLAPI AtlSetErrorInfo(const CLSID& clsid, LPCOLESTR lpszDesc,
	DWORD dwHelpID, LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes,
	HINSTANCE hInst);

/////////////////////////////////////////////////////////////////////////////
// Module

WCE_DEL ATLAPI AtlModuleRegisterClassObjects(_ATL_MODULE* pM, DWORD dwClsContext, DWORD dwFlags);
WCE_DEL ATLAPI AtlModuleRevokeClassObjects(_ATL_MODULE* pM);
ATLAPI AtlModuleGetClassObject(_ATL_MODULE* pM, REFCLSID rclsid, REFIID riid, LPVOID* ppv);
ATLAPI AtlModuleRegisterServer(_ATL_MODULE* pM, BOOL bRegTypeLib, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUnregisterServer(_ATL_MODULE* pM, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUnregisterServerEx(_ATL_MODULE* pM, BOOL bUnRegTypeLib, const CLSID* pCLSID = NULL);
ATLAPI AtlModuleUpdateRegistryFromResourceD(_ATL_MODULE*pM, LPCOLESTR lpszRes,
	BOOL bRegister, struct _ATL_REGMAP_ENTRY* pMapEntries, IRegistrar* pReg = NULL);
ATLAPI AtlModuleRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex);
ATLAPI AtlModuleUnRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex);
ATLAPI AtlModuleLoadTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex, BSTR* pbstrPath, ITypeLib** ppTypeLib);

ATLAPI AtlModuleInit(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* p, HINSTANCE h);
ATLAPI AtlModuleTerm(_ATL_MODULE* pM);
ATLAPI_(DWORD) AtlGetVersion(void* pReserved);
ATLAPI_(void) AtlModuleAddCreateWndData(_ATL_MODULE* pM, _AtlCreateWndData* pData, void* pObject);
ATLAPI_(void*) AtlModuleExtractCreateWndData(_ATL_MODULE* pM);
ATLAPI AtlModuleAddTermFunc(_ATL_MODULE* pM, _ATL_TERMFUNC* pFunc, DWORD dw);


#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

namespace ATL
{

enum atlTraceFlags
{
	// Application defined categories
	atlTraceUser 		= 0x00000001,
	atlTraceUser2 		= 0x00000002,
	atlTraceUser3 		= 0x00000004,
	atlTraceUser4 		= 0x00000008,
	// ATL defined categories
	atlTraceGeneral		= 0x00000020,
	atlTraceCOM 		= 0x00000040,
	atlTraceQI		= 0x00000080,
	atlTraceRegistrar	= 0x00000100,
	atlTraceRefcount	= 0x00000200,
	atlTraceWindowing	= 0x00000400,
	atlTraceControls	= 0x00000800,
	atlTraceHosting		= 0x00001000,
	atlTraceDBClient	= 0x00002000,
	atlTraceDBProvider	= 0x00004000,
	atlTraceSnapin		= 0x00008000,
	atlTraceNotImpl		= 0x00010000,
};

#ifndef ATL_TRACE_CATEGORY
#define ATL_TRACE_CATEGORY 0xFFFFFFFF
#endif

#ifdef _DEBUG

#ifndef ATL_TRACE_LEVEL
#define ATL_TRACE_LEVEL 0
#endif

#if !defined(_WIN32_WCE)
inline void _cdecl AtlTrace(LPCSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	char szBuffer[512];

	nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
	ATLASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

	OutputDebugStringA(szBuffer);
	va_end(args);
}
inline void _cdecl AtlTrace2(DWORD category, UINT level, LPCSTR lpszFormat, ...)
{
	if (category & ATL_TRACE_CATEGORY && level <= ATL_TRACE_LEVEL)
	{
		va_list args;
		va_start(args, lpszFormat);

		int nBuf;
		char szBuffer[512];

		nBuf = _vsnprintf(szBuffer, sizeof(szBuffer), lpszFormat, args);
		ATLASSERT(nBuf < sizeof(szBuffer)); //Output truncated as it was > sizeof(szBuffer)

		OutputDebugStringA("ATL: ");
		OutputDebugStringA(szBuffer);
		va_end(args);
	}
}
#endif // _WIN32_WCE
#ifndef OLE2ANSI
inline void _cdecl AtlTrace(LPCWSTR lpszFormat, ...)
{
	va_list args;
	va_start(args, lpszFormat);

	int nBuf;
	WCHAR szBuffer[512];

#if defined(_WIN32_WCE)
	nBuf = _vstprintf(szBuffer, lpszFormat, args);
#else // _WIN32_WCE
	nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(WCHAR), lpszFormat, args);
#endif // _WIN32_WCE
	ATLASSERT(nBuf < sizeof(szBuffer));//Output truncated as it was > sizeof(szBuffer)

	OutputDebugStringW(szBuffer);
	va_end(args);
}
inline void _cdecl AtlTrace2(DWORD category, UINT level, LPCWSTR lpszFormat, ...)
{
	if (category & ATL_TRACE_CATEGORY && level <= ATL_TRACE_LEVEL)
	{
		va_list args;
		va_start(args, lpszFormat);

		int nBuf;
		WCHAR szBuffer[512];

#if defined(_WIN32_WCE)
		nBuf = _vstprintf(szBuffer, lpszFormat, args);
#else // _WIN32_WCE
		nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer) / sizeof(WCHAR), lpszFormat, args);
#endif // _WIN32_WCE
		ATLASSERT(nBuf < sizeof(szBuffer));//Output truncated as it was > sizeof(szBuffer)

		OutputDebugStringW(L"ATL: ");
		OutputDebugStringW(szBuffer);
		va_end(args);
	}
}
#endif //!OLE2ANSI


#ifndef ATLTRACE
#define ATLTRACE            AtlTrace
#define ATLTRACE2           AtlTrace2
#endif
#define ATLTRACENOTIMPL(funcname)   ATLTRACE2(atlTraceNotImpl, 2, _T("ATL: %s not implemented.\n"), funcname); return E_NOTIMPL
#else // !DEBUG
inline void _cdecl AtlTrace(LPCSTR , ...){}
inline void _cdecl AtlTrace2(DWORD, UINT, LPCSTR , ...){}
#ifndef OLE2ANSI
inline void _cdecl AtlTrace(LPCWSTR , ...){}
inline void _cdecl AtlTrace2(DWORD, UINT, LPCWSTR , ...){}
#endif //OLE2ANSI
#ifndef ATLTRACE
#define ATLTRACE            1 ? (void)0 : AtlTrace
#define ATLTRACE2			1 ? (void)0 : AtlTrace2
#endif //ATLTRACE
#define ATLTRACENOTIMPL(funcname)   return E_NOTIMPL
#endif //_DEBUG





/////////////////////////////////////////////////////////////////////////////
// Win32 libraries

#ifndef _ATL_NO_FORCE_LIBS
#if defined(_WIN32_WCE)
	#pragma comment(lib, "coredll.lib")
	#pragma comment(lib, "commctrl.lib")
	#pragma comment(lib, "uuid.lib")
	#if defined(_WIN32_WCE_EMULATION) && (_WIN32_WCE < 210) 
		#pragma comment(lib, "ole32m.lib")
		#pragma comment(lib, "oleautm.lib")
	#else
		#pragma comment(lib, "ole32.lib")
		#pragma comment(lib, "oleaut32.lib")
	#endif // _WIN32_WCE_EMULATION
	#if (_WIN32_WCE > 200)	
		#pragma comment(lib, "corelibc.lib")
		#pragma comment(linker, "/nodefaultlib:libc.lib")
		#pragma comment(linker, "/nodefaultlib:libcd.lib")
		#pragma comment(linker, "/nodefaultlib:libcmt.lib")
		#pragma comment(linker, "/nodefaultlib:libcmtd.lib")
		#pragma comment(linker, "/nodefaultlib:oldnames.lib")
	#else // _WIN32_WCE > 200
		#if defined(_DEBUG)
			#pragma comment(lib, "libcmtd.lib")
			#pragma comment(linker, "/nodefaultlib:corelibc.lib")
		#else
			#pragma comment(lib, "libcmt.lib")
			#pragma comment(linker, "/nodefaultlib:corelibc.lib")
		#endif
	#endif // _WIN32_WCE > 200
#else                            // Win32
	#pragma comment(lib, "kernel32.lib")
	#pragma comment(lib, "user32.lib")
	#pragma comment(lib, "olepro32.lib")
	#pragma comment(lib, "advapi32.lib")
	#pragma comment(lib, "ole32.lib")
	#pragma comment(lib, "oleaut32.lib")
	#pragma comment(lib, "uuid.lib")
#endif // _WIN32_WCE
#endif // _ATL_NO_FORCE_LIBS

static HRESULT AtlSetChildSite(IUnknown* punkChild, IUnknown* punkParent)
{
	if (punkChild == NULL)
		return E_POINTER;

	HRESULT hr;
	IObjectWithSite* pChildSite = NULL;
	hr = punkChild->QueryInterface(IID_IObjectWithSite, (void**)&pChildSite);
	if (SUCCEEDED(hr) && pChildSite != NULL)
	{
		hr = pChildSite->SetSite(punkParent);
		pChildSite->Release();
	}
	return hr;
}

template <class T>
class _NoAddRefReleaseOnCComPtr : public T
{
	private:
		STDMETHOD_(ULONG, AddRef)()=0;
		STDMETHOD_(ULONG, Release)()=0;
};

template <class T>
class CComPtr
{
public:
	typedef T _PtrClass;
	CComPtr()
	{
		p=NULL;
	}
	CComPtr(T* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComPtr(const CComPtr<T>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	~CComPtr()
	{
		if (p)
			p->Release();
	}
	void Release()
	{
		IUnknown* pTemp = p;
		if (pTemp)
		{
			p = NULL;
			pTemp->Release();
		}
	}
	operator T*() const
	{
		return (T*)p;
	}
	T& operator*() const
	{
		ATLASSERT(p!=NULL);
		return *p; 
	}
	//The assert on operator& usually indicates a bug.  If this is really
	//what is needed, however, take the address of the p member explicitly.
	T** operator&()
	{
		ATLASSERT(p==NULL);
		return &p; 
	}
	_NoAddRefReleaseOnCComPtr<T>* operator->() const
	{
		ATLASSERT(p!=NULL);
		return (_NoAddRefReleaseOnCComPtr<T>*)p;
	}
	T* operator=(T* lp)
	{
		return (T*)AtlComPtrAssign((IUnknown**)&p, lp);
	}
	T* operator=(const CComPtr<T>& lp)
	{
		return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
	}
	bool operator!() const
	{
		return (p == NULL);
	}
	bool operator<(T* pT) const
	{
		return p < pT;
	}
	bool operator==(T* pT) const
	{
		return p == pT;
	}
	// Compare two objects for equivalence
	bool IsEqualObject(IUnknown* pOther)
	{
		if (p == NULL && pOther == NULL)
			return true; // They are both NULL objects

		if (p == NULL || pOther == NULL)
			return false; // One is NULL the other is not

		CComPtr<IUnknown> punk1;
		CComPtr<IUnknown> punk2;
		p->QueryInterface(IID_IUnknown, (void**)&punk1);
		pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
		return punk1 == punk2;
	}
	void Attach(T* p2)
	{
		if (p)
			p->Release();
		p = p2;
	}
	T* Detach()
	{
		T* pt = p;
		p = NULL;
		return pt;
	}
	HRESULT CopyTo(T** ppT)
	{
		ATLASSERT(ppT != NULL);
		if (ppT == NULL)
			return E_POINTER;
		*ppT = p;
		if (p)
			p->AddRef();
		return S_OK;
	}
	HRESULT SetSite(IUnknown* punkParent)
	{
		return AtlSetChildSite(p, punkParent);
	}
	HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
	{
		return AtlAdvise(p, pUnk, iid, pdw);
	}
	HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		ATLASSERT(p == NULL);
		return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
	}
	HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		CLSID clsid;
		HRESULT hr = WCE_FCTN(CLSIDFromProgID)(szProgID, &clsid);
		ATLASSERT(p == NULL);
		if (SUCCEEDED(hr))
			hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
		return hr;
	}
#if 1//!defined(_WIN32_WCE)
// WinCE: our compilers don't support this kind of overloaded templated function
	template <class Q>
	HRESULT QueryInterface(Q** pp) const
	{
		ATLASSERT(pp != NULL && *pp == NULL);
		return p->QueryInterface(__uuidof(Q), (void**)pp);
	}
#endif // _WIN32_WCE
	T* p;
};


template <class T, const IID* piid = &__uuidof(T)>
class CComQIPtr
{
public:
	typedef T _PtrClass;
	CComQIPtr()
	{
		p=NULL;
	}
	CComQIPtr(T* lp)
	{
		if ((p = lp) != NULL)
			p->AddRef();
	}
	CComQIPtr(const CComQIPtr<T,piid>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	CComQIPtr(IUnknown* lp)
	{
		p=NULL;
		if (lp != NULL)
			lp->QueryInterface(*piid, (void **)&p);
	}
	~CComQIPtr()
	{
		if (p)
			p->Release();
	}
	void Release()
	{
		IUnknown* pTemp = p;
		if (pTemp)
		{
			p = NULL;
			pTemp->Release();
		}
	}
	operator T*() const
	{
		return p;
	}
	T& operator*() const
	{
		ATLASSERT(p!=NULL); return *p;
	}
	//The assert on operator& usually indicates a bug.  If this is really
	//what is needed, however, take the address of the p member explicitly.
	T** operator&()
	{
		ATLASSERT(p==NULL);
		return &p;
	}
	_NoAddRefReleaseOnCComPtr<T>* operator->() const
	{
		ATLASSERT(p!=NULL);
		return (_NoAddRefReleaseOnCComPtr<T>*)p;
	}
	T* operator=(T* lp)
	{
		return (T*)AtlComPtrAssign((IUnknown**)&p, lp);
	}
	T* operator=(const CComQIPtr<T,piid>& lp)
	{
		return (T*)AtlComPtrAssign((IUnknown**)&p, lp.p);
	}
	T* operator=(IUnknown* lp)
	{
		return (T*)AtlComQIPtrAssign((IUnknown**)&p, lp, *piid);
	}
	bool operator!() const
	{
		return (p == NULL);
	}
	bool operator<(T* pT) const
	{
		return p < pT;
	}
	bool operator==(T* pT) const
	{
		return p == pT;
	}
	// Compare two objects for equivalence
	bool IsEqualObject(IUnknown* pOther)
	{
		if (p == NULL && pOther == NULL)
			return true; // They are both NULL objects

		if (p == NULL || pOther == NULL)
			return false; // One is NULL the other is not

		CComPtr<IUnknown> punk1;
		CComPtr<IUnknown> punk2;
		p->QueryInterface(IID_IUnknown, (void**)&punk1);
		pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
		return punk1 == punk2;
	}
	void Attach(T* p2)
	{
		if (p)
			p->Release();
		p = p2;
	}
	T* Detach()
	{
		T* pt = p;
		p = NULL;
		return pt;
	}
	HRESULT CopyTo(T** ppT)
	{
		ATLASSERT(ppT != NULL);
		if (ppT == NULL)
			return E_POINTER;
		*ppT = p;
		if (p)
			p->AddRef();
		return S_OK;
	}
	HRESULT SetSite(IUnknown* punkParent)
	{
		return AtlSetChildSite(p, punkParent);
	}
	HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
	{
		return AtlAdvise(p, pUnk, iid, pdw);
	}
	HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		ATLASSERT(p == NULL);
		return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
	}
	HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		CLSID clsid;
		HRESULT hr = WCE_FCTN(CLSIDFromProgID)(szProgID, &clsid);
		ATLASSERT(p == NULL);
		if (SUCCEEDED(hr))
			hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
		return hr;
	}
	template <class Q>
	HRESULT QueryInterface(Q** pp)
	{
		ATLASSERT(pp != NULL && *pp == NULL);
		return p->QueryInterface(__uuidof(Q), (void**)pp);
	}
	T* p;
};

//Specialization to make it work
template<>
class CComQIPtr<IUnknown, &IID_IUnknown>
{
public:
	typedef IUnknown _PtrClass;
	CComQIPtr()
	{
		p=NULL;
	}
	CComQIPtr(IUnknown* lp)
	{
		//Actually do a QI to get identity
		p=NULL;
		if (lp != NULL)
			lp->QueryInterface(IID_IUnknown, (void **)&p);
	}
	CComQIPtr(const CComQIPtr<IUnknown,&IID_IUnknown>& lp)
	{
		if ((p = lp.p) != NULL)
			p->AddRef();
	}
	~CComQIPtr()
	{
		if (p)
			p->Release();
	}
	void Release()
	{
		IUnknown* pTemp = p;
		if (pTemp)
		{
			p = NULL;
			pTemp->Release();
		}
	}
	operator IUnknown*() const
	{
		return p;
	}
	IUnknown& operator*() const
	{
		ATLASSERT(p!=NULL);
		return *p;
	}
	//The assert on operator& usually indicates a bug.  If this is really
	//what is needed, however, take the address of the p member explicitly.
	IUnknown** operator&()
	{
		ATLASSERT(p==NULL);
		return &p;
	}
	_NoAddRefReleaseOnCComPtr<T>* operator->() const
	{
		ATLASSERT(p!=NULL);
		return (_NoAddRefReleaseOnCComPtr<T>*)p;
	}
	IUnknown* operator=(IUnknown* lp)
	{
		//Actually do a QI to get identity
		return (IUnknown*)AtlComQIPtrAssign((IUnknown**)&p, lp, IID_IUnknown);
	}
	IUnknown* operator=(const CComQIPtr<IUnknown,&IID_IUnknown>& lp)
	{
		return (IUnknown*)AtlComPtrAssign((IUnknown**)&p, lp.p);
	}
	bool operator!() const
	{
		return (p == NULL);
	}
	bool operator<(IUnknown* pT) const
	{
		return p < pT;
	}
	bool operator==(IUnknown* pT) const
	{
		return p == pT;
	}
	// Compare two objects for equivalence
	bool IsEqualObject(IUnknown* pOther)
	{
		if (p == NULL && pOther == NULL)
			return true; // They are both NULL objects

		if (p == NULL || pOther == NULL)
			return false; // One is NULL the other is not

		CComPtr<IUnknown> punk1;
		CComPtr<IUnknown> punk2;
		p->QueryInterface(IID_IUnknown, (void**)&punk1);
		pOther->QueryInterface(IID_IUnknown, (void**)&punk2);
		return punk1 == punk2;
	}
	IUnknown* Detach()
	{
		IUnknown* pt = p;
		p = NULL;
		return pt;
	}
	HRESULT CopyTo(T** ppT)
	{
		ATLASSERT(ppT != NULL);
		if (ppT == NULL)
			return E_POINTER;
		*ppT = p;
		if (p)
			p->AddRef();
		return S_OK;
	}
	HRESULT SetSite(IUnknown* punkParent)
	{
		return AtlSetChildSite(p, punkParent);
	}
	HRESULT Advise(IUnknown* pUnk, const IID& iid, LPDWORD pdw)
	{
		return AtlAdvise(p, pUnk, iid, pdw);
	}
	HRESULT CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		ATLASSERT(p == NULL);
		return ::CoCreateInstance(rclsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
	}
	HRESULT CoCreateInstance(LPCOLESTR szProgID, LPUNKNOWN pUnkOuter = NULL, DWORD dwClsContext = CLSCTX_ALL)
	{
		CLSID clsid;
		HRESULT hr = WCE_FCTN(CLSIDFromProgID)(szProgID, &clsid);
		ATLASSERT(p == NULL);
		if (SUCCEEDED(hr))
			hr = ::CoCreateInstance(clsid, pUnkOuter, dwClsContext, __uuidof(T), (void**)&p);
		return hr;
	}
	template <class Q>
	HRESULT QueryInterface(Q** pp)
	{
		ATLASSERT(pp != NULL && *pp == NULL);
		return p->QueryInterface(__uuidof(Q), (void**)pp);
	}
	IUnknown* p;
};

#define com_cast CComQIPtr

/////////////////////////////////////////////////////////////
// Class to Adapt CComBSTR and CComPtr for use with STL containers
// the syntax to use it is 
// std::vector< CAdapt <CComBSTR> > vect;

template <class T>
class CAdapt
{
public:
	CAdapt()
	{
	}
	CAdapt(const T& rSrc)
	{
		m_T = rSrc;
	}

	CAdapt(const CAdapt& rSrCA)
	{
		m_T = rSrCA.m_T;
	}

	CAdapt& operator=(const T& rSrc)
	{
		m_T = rSrc;
		return *this;
	}
	bool operator<(const T& rSrc) const
	{
		return m_T < rSrc;
	}
	bool operator==(const T& rSrc) const
	{
		return m_T == rSrc;
	}
	operator T&()
	{
		return m_T;
	}

	operator const T&() const
	{
		return m_T;
	}

	T m_T;
};

/////////////////////////////////////////////////////////////////////////////
// GUID comparison

inline BOOL InlineIsEqualGUID(REFGUID rguid1, REFGUID rguid2)
{
   return (
	  ((PLONG) &rguid1)[0] == ((PLONG) &rguid2)[0] &&
	  ((PLONG) &rguid1)[1] == ((PLONG) &rguid2)[1] &&
	  ((PLONG) &rguid1)[2] == ((PLONG) &rguid2)[2] &&
	  ((PLONG) &rguid1)[3] == ((PLONG) &rguid2)[3]);
}

inline BOOL InlineIsEqualUnknown(REFGUID rguid1)
{
   return (
	  ((PLONG) &rguid1)[0] == 0 &&
	  ((PLONG) &rguid1)[1] == 0 &&
#ifdef _ATL_BYTESWAP
	  ((PLONG) &rguid1)[2] == 0xC0000000 &&
	  ((PLONG) &rguid1)[3] == 0x00000046);
#else
	  ((PLONG) &rguid1)[2] == 0x000000C0 &&
	  ((PLONG) &rguid1)[3] == 0x46000000);
#endif
}

/////////////////////////////////////////////////////////////////////////////
// Threading Model Support


class CComCriticalSection
{
public:
	void Lock() {EnterCriticalSection(&m_sec);}
	void Unlock() {LeaveCriticalSection(&m_sec);}
	void Init() {InitializeCriticalSection(&m_sec);}
	void Term() {DeleteCriticalSection(&m_sec);}
	CRITICAL_SECTION m_sec;
};

class CComAutoCriticalSection
{
public:
	void Lock() {EnterCriticalSection(&m_sec);}
	void Unlock() {LeaveCriticalSection(&m_sec);}
	CComAutoCriticalSection() {InitializeCriticalSection(&m_sec);}
	~CComAutoCriticalSection() {DeleteCriticalSection(&m_sec);}
	CRITICAL_SECTION m_sec;
};

class CComFakeCriticalSection
{
public:
	void Lock() {}
	void Unlock() {}
	void Init() {}
	void Term() {}
};


class CComMultiThreadModelNoCS
{
public:
	static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
	static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
	typedef CComFakeCriticalSection AutoCriticalSection;
	typedef CComFakeCriticalSection CriticalSection;
	typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};



class CComMultiThreadModel
{
public:
	static ULONG WINAPI Increment(LPLONG p) {return InterlockedIncrement(p);}
	static ULONG WINAPI Decrement(LPLONG p) {return InterlockedDecrement(p);}
	typedef CComAutoCriticalSection AutoCriticalSection;
	typedef CComCriticalSection CriticalSection;
	typedef CComMultiThreadModelNoCS ThreadModelNoCS;
};

class CComSingleThreadModel
{
public:
	static ULONG WINAPI Increment(LPLONG p) {return ++(*p);}
	static ULONG WINAPI Decrement(LPLONG p) {return --(*p);}
	typedef CComFakeCriticalSection AutoCriticalSection;
	typedef CComFakeCriticalSection CriticalSection;
	typedef CComSingleThreadModel ThreadModelNoCS;
};



#if defined(_ATL_SINGLE_THREADED)
	typedef CComSingleThreadModel CComObjectThreadModel;
	typedef CComSingleThreadModel CComGlobalsThreadModel;
#elif defined(_ATL_APARTMENT_THREADED)
	typedef CComSingleThreadModel CComObjectThreadModel;
	typedef CComMultiThreadModel CComGlobalsThreadModel;
#else
	typedef CComMultiThreadModel CComObjectThreadModel;
	typedef CComMultiThreadModel CComGlobalsThreadModel;
#endif

/////////////////////////////////////////////////////////////////////////////
// CComModule

#define THREADFLAGS_APARTMENT 0x1
#define THREADFLAGS_BOTH 0x2
#define AUTPRXFLAG 0x4

HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr);

#ifdef _ATL_DEBUG_INTERFACES
struct _QIThunk
{
	STDMETHOD(QueryInterface)(REFIID iid, void** pp)
	{
		ATLASSERT(m_dwRef >= 0);
		return pUnk->QueryInterface(iid, pp);
	}
	STDMETHOD_(ULONG, AddRef)()
	{
		if (bBreak)
			DebugBreak();
		pUnk->AddRef();
		return InternalAddRef();
	}
	ULONG InternalAddRef()
	{
		if (bBreak)
			DebugBreak();
		ATLASSERT(m_dwRef >= 0);
		long l = InterlockedIncrement(&m_dwRef);
		ATLTRACE(_T("%d> "), m_dwRef);
		AtlDumpIID(iid, lpszClassName, S_OK);
		if (l > m_dwMaxRef)
			m_dwMaxRef = l;
		return l;
	}
	STDMETHOD_(ULONG, Release)();

	STDMETHOD(f3)();
	STDMETHOD(f4)();
	STDMETHOD(f5)();
	STDMETHOD(f6)();
	STDMETHOD(f7)();
	STDMETHOD(f8)();
	STDMETHOD(f9)();
	STDMETHOD(f10)();
	STDMETHOD(f11)();
	STDMETHOD(f12)();
	STDMETHOD(f13)();
	STDMETHOD(f14)();
	STDMETHOD(f15)();
	STDMETHOD(f16)();
	STDMETHOD(f17)();
	STDMETHOD(f18)();
	STDMETHOD(f19)();
	STDMETHOD(f20)();
	STDMETHOD(f21)();
	STDMETHOD(f22)();
	STDMETHOD(f23)();
	STDMETHOD(f24)();
	STDMETHOD(f25)();
	STDMETHOD(f26)();
	STDMETHOD(f27)();
	STDMETHOD(f28)();
	STDMETHOD(f29)();
	STDMETHOD(f30)();
	STDMETHOD(f31)();
	STDMETHOD(f32)();
	STDMETHOD(f33)();
	STDMETHOD(f34)();
	STDMETHOD(f35)();
	STDMETHOD(f36)();
	STDMETHOD(f37)();
	STDMETHOD(f38)();
	STDMETHOD(f39)();
	STDMETHOD(f40)();
	STDMETHOD(f41)();
	STDMETHOD(f42)();
	STDMETHOD(f43)();
	STDMETHOD(f44)();
	STDMETHOD(f45)();
	STDMETHOD(f46)();
	STDMETHOD(f47)();
	STDMETHOD(f48)();
	STDMETHOD(f49)();
	STDMETHOD(f50)();
	STDMETHOD(f51)();
	STDMETHOD(f52)();
	STDMETHOD(f53)();
	STDMETHOD(f54)();
	STDMETHOD(f55)();
	STDMETHOD(f56)();
	STDMETHOD(f57)();
	STDMETHOD(f58)();
	STDMETHOD(f59)();
	STDMETHOD(f60)();
	STDMETHOD(f61)();
	STDMETHOD(f62)();
	STDMETHOD(f63)();
	STDMETHOD(f64)();
	STDMETHOD(f65)();
	STDMETHOD(f66)();
	STDMETHOD(f67)();
	STDMETHOD(f68)();
	STDMETHOD(f69)();
	STDMETHOD(f70)();
	STDMETHOD(f71)();
	STDMETHOD(f72)();
	STDMETHOD(f73)();
	STDMETHOD(f74)();
	STDMETHOD(f75)();
	STDMETHOD(f76)();
	STDMETHOD(f77)();
	STDMETHOD(f78)();
	STDMETHOD(f79)();
	STDMETHOD(f80)();
	STDMETHOD(f81)();
	STDMETHOD(f82)();
	STDMETHOD(f83)();
	STDMETHOD(f84)();
	STDMETHOD(f85)();
	STDMETHOD(f86)();
	STDMETHOD(f87)();
	STDMETHOD(f88)();
	STDMETHOD(f89)();
	STDMETHOD(f90)();
	STDMETHOD(f91)();
	STDMETHOD(f92)();
	STDMETHOD(f93)();
	STDMETHOD(f94)();
	STDMETHOD(f95)();
	STDMETHOD(f96)();
	STDMETHOD(f97)();
	STDMETHOD(f98)();
	STDMETHOD(f99)();
	STDMETHOD(f100)();
	STDMETHOD(f101)();
	STDMETHOD(f102)();
	STDMETHOD(f103)();
	STDMETHOD(f104)();
	STDMETHOD(f105)();
	STDMETHOD(f106)();
	STDMETHOD(f107)();
	STDMETHOD(f108)();
	STDMETHOD(f109)();
	STDMETHOD(f110)();
	STDMETHOD(f111)();
	STDMETHOD(f112)();
	STDMETHOD(f113)();
	STDMETHOD(f114)();
	STDMETHOD(f115)();
	STDMETHOD(f116)();
	STDMETHOD(f117)();
	STDMETHOD(f118)();
	STDMETHOD(f119)();
	STDMETHOD(f120)();
	STDMETHOD(f121)();
	STDMETHOD(f122)();
	STDMETHOD(f123)();
	STDMETHOD(f124)();
	STDMETHOD(f125)();
	STDMETHOD(f126)();
	STDMETHOD(f127)();
	STDMETHOD(f128)();
	STDMETHOD(f129)();
	STDMETHOD(f130)();
	STDMETHOD(f131)();
	STDMETHOD(f132)();
	STDMETHOD(f133)();
	STDMETHOD(f134)();
	STDMETHOD(f135)();
	STDMETHOD(f136)();
	STDMETHOD(f137)();
	STDMETHOD(f138)();
	STDMETHOD(f139)();
	STDMETHOD(f140)();
	STDMETHOD(f141)();
	STDMETHOD(f142)();
	STDMETHOD(f143)();
	STDMETHOD(f144)();
	STDMETHOD(f145)();
	STDMETHOD(f146)();
	STDMETHOD(f147)();
	STDMETHOD(f148)();
	STDMETHOD(f149)();
	STDMETHOD(f150)();
	STDMETHOD(f151)();
	STDMETHOD(f152)();
	STDMETHOD(f153)();
	STDMETHOD(f154)();
	STDMETHOD(f155)();
	STDMETHOD(f156)();
	STDMETHOD(f157)();
	STDMETHOD(f158)();
	STDMETHOD(f159)();
	STDMETHOD(f160)();
	STDMETHOD(f161)();
	STDMETHOD(f162)();
	STDMETHOD(f163)();
	STDMETHOD(f164)();
	STDMETHOD(f165)();
	STDMETHOD(f166)();
	STDMETHOD(f167)();
	STDMETHOD(f168)();
	STDMETHOD(f169)();
	STDMETHOD(f170)();
	STDMETHOD(f171)();
	STDMETHOD(f172)();
	STDMETHOD(f173)();
	STDMETHOD(f174)();
	STDMETHOD(f175)();
	STDMETHOD(f176)();
	STDMETHOD(f177)();
	STDMETHOD(f178)();
	STDMETHOD(f179)();
	STDMETHOD(f180)();
	STDMETHOD(f181)();
	STDMETHOD(f182)();
	STDMETHOD(f183)();
	STDMETHOD(f184)();
	STDMETHOD(f185)();
	STDMETHOD(f186)();
	STDMETHOD(f187)();
	STDMETHOD(f188)();
	STDMETHOD(f189)();
	STDMETHOD(f190)();
	STDMETHOD(f191)();
	STDMETHOD(f192)();
	STDMETHOD(f193)();
	STDMETHOD(f194)();
	STDMETHOD(f195)();
	STDMETHOD(f196)();
	STDMETHOD(f197)();
	STDMETHOD(f198)();
	STDMETHOD(f199)();
	STDMETHOD(f200)();
	STDMETHOD(f201)();
	STDMETHOD(f202)();
	STDMETHOD(f203)();
	STDMETHOD(f204)();
	STDMETHOD(f205)();
	STDMETHOD(f206)();
	STDMETHOD(f207)();
	STDMETHOD(f208)();
	STDMETHOD(f209)();
	STDMETHOD(f210)();
	STDMETHOD(f211)();
	STDMETHOD(f212)();
	STDMETHOD(f213)();
	STDMETHOD(f214)();
	STDMETHOD(f215)();
	STDMETHOD(f216)();
	STDMETHOD(f217)();
	STDMETHOD(f218)();
	STDMETHOD(f219)();
	STDMETHOD(f220)();
	STDMETHOD(f221)();
	STDMETHOD(f222)();
	STDMETHOD(f223)();
	STDMETHOD(f224)();
	STDMETHOD(f225)();
	STDMETHOD(f226)();
	STDMETHOD(f227)();
	STDMETHOD(f228)();
	STDMETHOD(f229)();
	STDMETHOD(f230)();
	STDMETHOD(f231)();
	STDMETHOD(f232)();
	STDMETHOD(f233)();
	STDMETHOD(f234)();
	STDMETHOD(f235)();
	STDMETHOD(f236)();
	STDMETHOD(f237)();
	STDMETHOD(f238)();
	STDMETHOD(f239)();
	STDMETHOD(f240)();
	STDMETHOD(f241)();
	STDMETHOD(f242)();
	STDMETHOD(f243)();
	STDMETHOD(f244)();
	STDMETHOD(f245)();
	STDMETHOD(f246)();
	STDMETHOD(f247)();
	STDMETHOD(f248)();
	STDMETHOD(f249)();
	STDMETHOD(f250)();
	STDMETHOD(f251)();
	STDMETHOD(f252)();
	STDMETHOD(f253)();
	STDMETHOD(f254)();
	STDMETHOD(f255)();
	STDMETHOD(f256)();
	STDMETHOD(f257)();
	STDMETHOD(f258)();
	STDMETHOD(f259)();
	STDMETHOD(f260)();
	STDMETHOD(f261)();
	STDMETHOD(f262)();
	STDMETHOD(f263)();
	STDMETHOD(f264)();
	STDMETHOD(f265)();
	STDMETHOD(f266)();
	STDMETHOD(f267)();
	STDMETHOD(f268)();
	STDMETHOD(f269)();
	STDMETHOD(f270)();
	STDMETHOD(f271)();
	STDMETHOD(f272)();
	STDMETHOD(f273)();
	STDMETHOD(f274)();
	STDMETHOD(f275)();
	STDMETHOD(f276)();
	STDMETHOD(f277)();
	STDMETHOD(f278)();
	STDMETHOD(f279)();
	STDMETHOD(f280)();
	STDMETHOD(f281)();
	STDMETHOD(f282)();
	STDMETHOD(f283)();
	STDMETHOD(f284)();
	STDMETHOD(f285)();
	STDMETHOD(f286)();
	STDMETHOD(f287)();
	STDMETHOD(f288)();
	STDMETHOD(f289)();
	STDMETHOD(f290)();
	STDMETHOD(f291)();
	STDMETHOD(f292)();
	STDMETHOD(f293)();
	STDMETHOD(f294)();
	STDMETHOD(f295)();
	STDMETHOD(f296)();
	STDMETHOD(f297)();
	STDMETHOD(f298)();
	STDMETHOD(f299)();
	STDMETHOD(f300)();
	STDMETHOD(f301)();
	STDMETHOD(f302)();
	STDMETHOD(f303)();
	STDMETHOD(f304)();
	STDMETHOD(f305)();
	STDMETHOD(f306)();
	STDMETHOD(f307)();
	STDMETHOD(f308)();
	STDMETHOD(f309)();
	STDMETHOD(f310)();
	STDMETHOD(f311)();
	STDMETHOD(f312)();
	STDMETHOD(f313)();
	STDMETHOD(f314)();
	STDMETHOD(f315)();
	STDMETHOD(f316)();
	STDMETHOD(f317)();
	STDMETHOD(f318)();
	STDMETHOD(f319)();
	STDMETHOD(f320)();
	STDMETHOD(f321)();
	STDMETHOD(f322)();
	STDMETHOD(f323)();
	STDMETHOD(f324)();
	STDMETHOD(f325)();
	STDMETHOD(f326)();
	STDMETHOD(f327)();
	STDMETHOD(f328)();
	STDMETHOD(f329)();
	STDMETHOD(f330)();
	STDMETHOD(f331)();
	STDMETHOD(f332)();
	STDMETHOD(f333)();
	STDMETHOD(f334)();
	STDMETHOD(f335)();
	STDMETHOD(f336)();
	STDMETHOD(f337)();
	STDMETHOD(f338)();
	STDMETHOD(f339)();
	STDMETHOD(f340)();
	STDMETHOD(f341)();
	STDMETHOD(f342)();
	STDMETHOD(f343)();
	STDMETHOD(f344)();
	STDMETHOD(f345)();
	STDMETHOD(f346)();
	STDMETHOD(f347)();
	STDMETHOD(f348)();
	STDMETHOD(f349)();
	STDMETHOD(f350)();
	STDMETHOD(f351)();
	STDMETHOD(f352)();
	STDMETHOD(f353)();
	STDMETHOD(f354)();
	STDMETHOD(f355)();
	STDMETHOD(f356)();
	STDMETHOD(f357)();
	STDMETHOD(f358)();
	STDMETHOD(f359)();
	STDMETHOD(f360)();
	STDMETHOD(f361)();
	STDMETHOD(f362)();
	STDMETHOD(f363)();
	STDMETHOD(f364)();
	STDMETHOD(f365)();
	STDMETHOD(f366)();
	STDMETHOD(f367)();
	STDMETHOD(f368)();
	STDMETHOD(f369)();
	STDMETHOD(f370)();
	STDMETHOD(f371)();
	STDMETHOD(f372)();
	STDMETHOD(f373)();
	STDMETHOD(f374)();
	STDMETHOD(f375)();
	STDMETHOD(f376)();
	STDMETHOD(f377)();
	STDMETHOD(f378)();
	STDMETHOD(f379)();
	STDMETHOD(f380)();
	STDMETHOD(f381)();
	STDMETHOD(f382)();
	STDMETHOD(f383)();
	STDMETHOD(f384)();
	STDMETHOD(f385)();
	STDMETHOD(f386)();
	STDMETHOD(f387)();
	STDMETHOD(f388)();
	STDMETHOD(f389)();
	STDMETHOD(f390)();
	STDMETHOD(f391)();
	STDMETHOD(f392)();
	STDMETHOD(f393)();
	STDMETHOD(f394)();
	STDMETHOD(f395)();
	STDMETHOD(f396)();
	STDMETHOD(f397)();
	STDMETHOD(f398)();
	STDMETHOD(f399)();
	STDMETHOD(f400)();
	STDMETHOD(f401)();
	STDMETHOD(f402)();
	STDMETHOD(f403)();
	STDMETHOD(f404)();
	STDMETHOD(f405)();
	STDMETHOD(f406)();
	STDMETHOD(f407)();
	STDMETHOD(f408)();
	STDMETHOD(f409)();
	STDMETHOD(f410)();
	STDMETHOD(f411)();
	STDMETHOD(f412)();
	STDMETHOD(f413)();
	STDMETHOD(f414)();
	STDMETHOD(f415)();
	STDMETHOD(f416)();
	STDMETHOD(f417)();
	STDMETHOD(f418)();
	STDMETHOD(f419)();
	STDMETHOD(f420)();
	STDMETHOD(f421)();
	STDMETHOD(f422)();
	STDMETHOD(f423)();
	STDMETHOD(f424)();
	STDMETHOD(f425)();
	STDMETHOD(f426)();
	STDMETHOD(f427)();
	STDMETHOD(f428)();
	STDMETHOD(f429)();
	STDMETHOD(f430)();
	STDMETHOD(f431)();
	STDMETHOD(f432)();
	STDMETHOD(f433)();
	STDMETHOD(f434)();
	STDMETHOD(f435)();
	STDMETHOD(f436)();
	STDMETHOD(f437)();
	STDMETHOD(f438)();
	STDMETHOD(f439)();
	STDMETHOD(f440)();
	STDMETHOD(f441)();
	STDMETHOD(f442)();
	STDMETHOD(f443)();
	STDMETHOD(f444)();
	STDMETHOD(f445)();
	STDMETHOD(f446)();
	STDMETHOD(f447)();
	STDMETHOD(f448)();
	STDMETHOD(f449)();
	STDMETHOD(f450)();
	STDMETHOD(f451)();
	STDMETHOD(f452)();
	STDMETHOD(f453)();
	STDMETHOD(f454)();
	STDMETHOD(f455)();
	STDMETHOD(f456)();
	STDMETHOD(f457)();
	STDMETHOD(f458)();
	STDMETHOD(f459)();
	STDMETHOD(f460)();
	STDMETHOD(f461)();
	STDMETHOD(f462)();
	STDMETHOD(f463)();
	STDMETHOD(f464)();
	STDMETHOD(f465)();
	STDMETHOD(f466)();
	STDMETHOD(f467)();
	STDMETHOD(f468)();
	STDMETHOD(f469)();
	STDMETHOD(f470)();
	STDMETHOD(f471)();
	STDMETHOD(f472)();
	STDMETHOD(f473)();
	STDMETHOD(f474)();
	STDMETHOD(f475)();
	STDMETHOD(f476)();
	STDMETHOD(f477)();
	STDMETHOD(f478)();
	STDMETHOD(f479)();
	STDMETHOD(f480)();
	STDMETHOD(f481)();
	STDMETHOD(f482)();
	STDMETHOD(f483)();
	STDMETHOD(f484)();
	STDMETHOD(f485)();
	STDMETHOD(f486)();
	STDMETHOD(f487)();
	STDMETHOD(f488)();
	STDMETHOD(f489)();
	STDMETHOD(f490)();
	STDMETHOD(f491)();
	STDMETHOD(f492)();
	STDMETHOD(f493)();
	STDMETHOD(f494)();
	STDMETHOD(f495)();
	STDMETHOD(f496)();
	STDMETHOD(f497)();
	STDMETHOD(f498)();
	STDMETHOD(f499)();
	STDMETHOD(f500)();
	STDMETHOD(f501)();
	STDMETHOD(f502)();
	STDMETHOD(f503)();
	STDMETHOD(f504)();
	STDMETHOD(f505)();
	STDMETHOD(f506)();
	STDMETHOD(f507)();
	STDMETHOD(f508)();
	STDMETHOD(f509)();
	STDMETHOD(f510)();
	STDMETHOD(f511)();
	STDMETHOD(f512)();
	STDMETHOD(f513)();
	STDMETHOD(f514)();
	STDMETHOD(f515)();
	STDMETHOD(f516)();
	STDMETHOD(f517)();
	STDMETHOD(f518)();
	STDMETHOD(f519)();
	STDMETHOD(f520)();
	STDMETHOD(f521)();
	STDMETHOD(f522)();
	STDMETHOD(f523)();
	STDMETHOD(f524)();
	STDMETHOD(f525)();
	STDMETHOD(f526)();
	STDMETHOD(f527)();
	STDMETHOD(f528)();
	STDMETHOD(f529)();
	STDMETHOD(f530)();
	STDMETHOD(f531)();
	STDMETHOD(f532)();
	STDMETHOD(f533)();
	STDMETHOD(f534)();
	STDMETHOD(f535)();
	STDMETHOD(f536)();
	STDMETHOD(f537)();
	STDMETHOD(f538)();
	STDMETHOD(f539)();
	STDMETHOD(f540)();
	STDMETHOD(f541)();
	STDMETHOD(f542)();
	STDMETHOD(f543)();
	STDMETHOD(f544)();
	STDMETHOD(f545)();
	STDMETHOD(f546)();
	STDMETHOD(f547)();
	STDMETHOD(f548)();
	STDMETHOD(f549)();
	STDMETHOD(f550)();
	STDMETHOD(f551)();
	STDMETHOD(f552)();
	STDMETHOD(f553)();
	STDMETHOD(f554)();
	STDMETHOD(f555)();
	STDMETHOD(f556)();
	STDMETHOD(f557)();
	STDMETHOD(f558)();
	STDMETHOD(f559)();
	STDMETHOD(f560)();
	STDMETHOD(f561)();
	STDMETHOD(f562)();
	STDMETHOD(f563)();
	STDMETHOD(f564)();
	STDMETHOD(f565)();
	STDMETHOD(f566)();
	STDMETHOD(f567)();
	STDMETHOD(f568)();
	STDMETHOD(f569)();
	STDMETHOD(f570)();
	STDMETHOD(f571)();
	STDMETHOD(f572)();
	STDMETHOD(f573)();
	STDMETHOD(f574)();
	STDMETHOD(f575)();
	STDMETHOD(f576)();
	STDMETHOD(f577)();
	STDMETHOD(f578)();
	STDMETHOD(f579)();
	STDMETHOD(f580)();
	STDMETHOD(f581)();
	STDMETHOD(f582)();
	STDMETHOD(f583)();
	STDMETHOD(f584)();
	STDMETHOD(f585)();
	STDMETHOD(f586)();
	STDMETHOD(f587)();
	STDMETHOD(f588)();
	STDMETHOD(f589)();
	STDMETHOD(f590)();
	STDMETHOD(f591)();
	STDMETHOD(f592)();
	STDMETHOD(f593)();
	STDMETHOD(f594)();
	STDMETHOD(f595)();
	STDMETHOD(f596)();
	STDMETHOD(f597)();
	STDMETHOD(f598)();
	STDMETHOD(f599)();
	STDMETHOD(f600)();
	STDMETHOD(f601)();
	STDMETHOD(f602)();
	STDMETHOD(f603)();
	STDMETHOD(f604)();
	STDMETHOD(f605)();
	STDMETHOD(f606)();
	STDMETHOD(f607)();
	STDMETHOD(f608)();
	STDMETHOD(f609)();
	STDMETHOD(f610)();
	STDMETHOD(f611)();
	STDMETHOD(f612)();
	STDMETHOD(f613)();
	STDMETHOD(f614)();
	STDMETHOD(f615)();
	STDMETHOD(f616)();
	STDMETHOD(f617)();
	STDMETHOD(f618)();
	STDMETHOD(f619)();
	STDMETHOD(f620)();
	STDMETHOD(f621)();
	STDMETHOD(f622)();
	STDMETHOD(f623)();
	STDMETHOD(f624)();
	STDMETHOD(f625)();
	STDMETHOD(f626)();
	STDMETHOD(f627)();
	STDMETHOD(f628)();
	STDMETHOD(f629)();
	STDMETHOD(f630)();
	STDMETHOD(f631)();
	STDMETHOD(f632)();
	STDMETHOD(f633)();
	STDMETHOD(f634)();
	STDMETHOD(f635)();
	STDMETHOD(f636)();
	STDMETHOD(f637)();
	STDMETHOD(f638)();
	STDMETHOD(f639)();
	STDMETHOD(f640)();
	STDMETHOD(f641)();
	STDMETHOD(f642)();
	STDMETHOD(f643)();
	STDMETHOD(f644)();
	STDMETHOD(f645)();
	STDMETHOD(f646)();
	STDMETHOD(f647)();
	STDMETHOD(f648)();
	STDMETHOD(f649)();
	STDMETHOD(f650)();
	STDMETHOD(f651)();
	STDMETHOD(f652)();
	STDMETHOD(f653)();
	STDMETHOD(f654)();
	STDMETHOD(f655)();
	STDMETHOD(f656)();
	STDMETHOD(f657)();
	STDMETHOD(f658)();
	STDMETHOD(f659)();
	STDMETHOD(f660)();
	STDMETHOD(f661)();
	STDMETHOD(f662)();
	STDMETHOD(f663)();
	STDMETHOD(f664)();
	STDMETHOD(f665)();
	STDMETHOD(f666)();
	STDMETHOD(f667)();
	STDMETHOD(f668)();
	STDMETHOD(f669)();
	STDMETHOD(f670)();
	STDMETHOD(f671)();
	STDMETHOD(f672)();
	STDMETHOD(f673)();
	STDMETHOD(f674)();
	STDMETHOD(f675)();
	STDMETHOD(f676)();
	STDMETHOD(f677)();
	STDMETHOD(f678)();
	STDMETHOD(f679)();
	STDMETHOD(f680)();
	STDMETHOD(f681)();
	STDMETHOD(f682)();
	STDMETHOD(f683)();
	STDMETHOD(f684)();
	STDMETHOD(f685)();
	STDMETHOD(f686)();
	STDMETHOD(f687)();
	STDMETHOD(f688)();
	STDMETHOD(f689)();
	STDMETHOD(f690)();
	STDMETHOD(f691)();
	STDMETHOD(f692)();
	STDMETHOD(f693)();
	STDMETHOD(f694)();
	STDMETHOD(f695)();
	STDMETHOD(f696)();
	STDMETHOD(f697)();
	STDMETHOD(f698)();
	STDMETHOD(f699)();
	STDMETHOD(f700)();
	STDMETHOD(f701)();
	STDMETHOD(f702)();
	STDMETHOD(f703)();
	STDMETHOD(f704)();
	STDMETHOD(f705)();
	STDMETHOD(f706)();
	STDMETHOD(f707)();
	STDMETHOD(f708)();
	STDMETHOD(f709)();
	STDMETHOD(f710)();
	STDMETHOD(f711)();
	STDMETHOD(f712)();
	STDMETHOD(f713)();
	STDMETHOD(f714)();
	STDMETHOD(f715)();
	STDMETHOD(f716)();
	STDMETHOD(f717)();
	STDMETHOD(f718)();
	STDMETHOD(f719)();
	STDMETHOD(f720)();
	STDMETHOD(f721)();
	STDMETHOD(f722)();
	STDMETHOD(f723)();
	STDMETHOD(f724)();
	STDMETHOD(f725)();
	STDMETHOD(f726)();
	STDMETHOD(f727)();
	STDMETHOD(f728)();
	STDMETHOD(f729)();
	STDMETHOD(f730)();
	STDMETHOD(f731)();
	STDMETHOD(f732)();
	STDMETHOD(f733)();
	STDMETHOD(f734)();
	STDMETHOD(f735)();
	STDMETHOD(f736)();
	STDMETHOD(f737)();
	STDMETHOD(f738)();
	STDMETHOD(f739)();
	STDMETHOD(f740)();
	STDMETHOD(f741)();
	STDMETHOD(f742)();
	STDMETHOD(f743)();
	STDMETHOD(f744)();
	STDMETHOD(f745)();
	STDMETHOD(f746)();
	STDMETHOD(f747)();
	STDMETHOD(f748)();
	STDMETHOD(f749)();
	STDMETHOD(f750)();
	STDMETHOD(f751)();
	STDMETHOD(f752)();
	STDMETHOD(f753)();
	STDMETHOD(f754)();
	STDMETHOD(f755)();
	STDMETHOD(f756)();
	STDMETHOD(f757)();
	STDMETHOD(f758)();
	STDMETHOD(f759)();
	STDMETHOD(f760)();
	STDMETHOD(f761)();
	STDMETHOD(f762)();
	STDMETHOD(f763)();
	STDMETHOD(f764)();
	STDMETHOD(f765)();
	STDMETHOD(f766)();
	STDMETHOD(f767)();
	STDMETHOD(f768)();
	STDMETHOD(f769)();
	STDMETHOD(f770)();
	STDMETHOD(f771)();
	STDMETHOD(f772)();
	STDMETHOD(f773)();
	STDMETHOD(f774)();
	STDMETHOD(f775)();
	STDMETHOD(f776)();
	STDMETHOD(f777)();
	STDMETHOD(f778)();
	STDMETHOD(f779)();
	STDMETHOD(f780)();
	STDMETHOD(f781)();
	STDMETHOD(f782)();
	STDMETHOD(f783)();
	STDMETHOD(f784)();
	STDMETHOD(f785)();
	STDMETHOD(f786)();
	STDMETHOD(f787)();
	STDMETHOD(f788)();
	STDMETHOD(f789)();
	STDMETHOD(f790)();
	STDMETHOD(f791)();
	STDMETHOD(f792)();
	STDMETHOD(f793)();
	STDMETHOD(f794)();
	STDMETHOD(f795)();
	STDMETHOD(f796)();
	STDMETHOD(f797)();
	STDMETHOD(f798)();
	STDMETHOD(f799)();
	STDMETHOD(f800)();
	STDMETHOD(f801)();
	STDMETHOD(f802)();
	STDMETHOD(f803)();
	STDMETHOD(f804)();
	STDMETHOD(f805)();
	STDMETHOD(f806)();
	STDMETHOD(f807)();
	STDMETHOD(f808)();
	STDMETHOD(f809)();
	STDMETHOD(f810)();
	STDMETHOD(f811)();
	STDMETHOD(f812)();
	STDMETHOD(f813)();
	STDMETHOD(f814)();
	STDMETHOD(f815)();
	STDMETHOD(f816)();
	STDMETHOD(f817)();
	STDMETHOD(f818)();
	STDMETHOD(f819)();
	STDMETHOD(f820)();
	STDMETHOD(f821)();
	STDMETHOD(f822)();
	STDMETHOD(f823)();
	STDMETHOD(f824)();
	STDMETHOD(f825)();
	STDMETHOD(f826)();
	STDMETHOD(f827)();
	STDMETHOD(f828)();
	STDMETHOD(f829)();
	STDMETHOD(f830)();
	STDMETHOD(f831)();
	STDMETHOD(f832)();
	STDMETHOD(f833)();
	STDMETHOD(f834)();
	STDMETHOD(f835)();
	STDMETHOD(f836)();
	STDMETHOD(f837)();
	STDMETHOD(f838)();
	STDMETHOD(f839)();
	STDMETHOD(f840)();
	STDMETHOD(f841)();
	STDMETHOD(f842)();
	STDMETHOD(f843)();
	STDMETHOD(f844)();
	STDMETHOD(f845)();
	STDMETHOD(f846)();
	STDMETHOD(f847)();
	STDMETHOD(f848)();
	STDMETHOD(f849)();
	STDMETHOD(f850)();
	STDMETHOD(f851)();
	STDMETHOD(f852)();
	STDMETHOD(f853)();
	STDMETHOD(f854)();
	STDMETHOD(f855)();
	STDMETHOD(f856)();
	STDMETHOD(f857)();
	STDMETHOD(f858)();
	STDMETHOD(f859)();
	STDMETHOD(f860)();
	STDMETHOD(f861)();
	STDMETHOD(f862)();
	STDMETHOD(f863)();
	STDMETHOD(f864)();
	STDMETHOD(f865)();
	STDMETHOD(f866)();
	STDMETHOD(f867)();
	STDMETHOD(f868)();
	STDMETHOD(f869)();
	STDMETHOD(f870)();
	STDMETHOD(f871)();
	STDMETHOD(f872)();
	STDMETHOD(f873)();
	STDMETHOD(f874)();
	STDMETHOD(f875)();
	STDMETHOD(f876)();
	STDMETHOD(f877)();
	STDMETHOD(f878)();
	STDMETHOD(f879)();
	STDMETHOD(f880)();
	STDMETHOD(f881)();
	STDMETHOD(f882)();
	STDMETHOD(f883)();
	STDMETHOD(f884)();
	STDMETHOD(f885)();
	STDMETHOD(f886)();
	STDMETHOD(f887)();
	STDMETHOD(f888)();
	STDMETHOD(f889)();
	STDMETHOD(f890)();
	STDMETHOD(f891)();
	STDMETHOD(f892)();
	STDMETHOD(f893)();
	STDMETHOD(f894)();
	STDMETHOD(f895)();
	STDMETHOD(f896)();
	STDMETHOD(f897)();
	STDMETHOD(f898)();
	STDMETHOD(f899)();
	STDMETHOD(f900)();
	STDMETHOD(f901)();
	STDMETHOD(f902)();
	STDMETHOD(f903)();
	STDMETHOD(f904)();
	STDMETHOD(f905)();
	STDMETHOD(f906)();
	STDMETHOD(f907)();
	STDMETHOD(f908)();
	STDMETHOD(f909)();
	STDMETHOD(f910)();
	STDMETHOD(f911)();
	STDMETHOD(f912)();
	STDMETHOD(f913)();
	STDMETHOD(f914)();
	STDMETHOD(f915)();
	STDMETHOD(f916)();
	STDMETHOD(f917)();
	STDMETHOD(f918)();
	STDMETHOD(f919)();
	STDMETHOD(f920)();
	STDMETHOD(f921)();
	STDMETHOD(f922)();
	STDMETHOD(f923)();
	STDMETHOD(f924)();
	STDMETHOD(f925)();
	STDMETHOD(f926)();
	STDMETHOD(f927)();
	STDMETHOD(f928)();
	STDMETHOD(f929)();
	STDMETHOD(f930)();
	STDMETHOD(f931)();
	STDMETHOD(f932)();
	STDMETHOD(f933)();
	STDMETHOD(f934)();
	STDMETHOD(f935)();
	STDMETHOD(f936)();
	STDMETHOD(f937)();
	STDMETHOD(f938)();
	STDMETHOD(f939)();
	STDMETHOD(f940)();
	STDMETHOD(f941)();
	STDMETHOD(f942)();
	STDMETHOD(f943)();
	STDMETHOD(f944)();
	STDMETHOD(f945)();
	STDMETHOD(f946)();
	STDMETHOD(f947)();
	STDMETHOD(f948)();
	STDMETHOD(f949)();
	STDMETHOD(f950)();
	STDMETHOD(f951)();
	STDMETHOD(f952)();
	STDMETHOD(f953)();
	STDMETHOD(f954)();
	STDMETHOD(f955)();
	STDMETHOD(f956)();
	STDMETHOD(f957)();
	STDMETHOD(f958)();
	STDMETHOD(f959)();
	STDMETHOD(f960)();
	STDMETHOD(f961)();
	STDMETHOD(f962)();
	STDMETHOD(f963)();
	STDMETHOD(f964)();
	STDMETHOD(f965)();
	STDMETHOD(f966)();
	STDMETHOD(f967)();
	STDMETHOD(f968)();
	STDMETHOD(f969)();
	STDMETHOD(f970)();
	STDMETHOD(f971)();
	STDMETHOD(f972)();
	STDMETHOD(f973)();
	STDMETHOD(f974)();
	STDMETHOD(f975)();
	STDMETHOD(f976)();
	STDMETHOD(f977)();
	STDMETHOD(f978)();
	STDMETHOD(f979)();
	STDMETHOD(f980)();
	STDMETHOD(f981)();
	STDMETHOD(f982)();
	STDMETHOD(f983)();
	STDMETHOD(f984)();
	STDMETHOD(f985)();
	STDMETHOD(f986)();
	STDMETHOD(f987)();
	STDMETHOD(f988)();
	STDMETHOD(f989)();
	STDMETHOD(f990)();
	STDMETHOD(f991)();
	STDMETHOD(f992)();
	STDMETHOD(f993)();
	STDMETHOD(f994)();
	STDMETHOD(f995)();
	STDMETHOD(f996)();
	STDMETHOD(f997)();
	STDMETHOD(f998)();
	STDMETHOD(f999)();
	STDMETHOD(f1000)();
	STDMETHOD(f1001)();
	STDMETHOD(f1002)();
	STDMETHOD(f1003)();
	STDMETHOD(f1004)();
	STDMETHOD(f1005)();
	STDMETHOD(f1006)();
	STDMETHOD(f1007)();
	STDMETHOD(f1008)();
	STDMETHOD(f1009)();
	STDMETHOD(f1010)();
	STDMETHOD(f1011)();
	STDMETHOD(f1012)();
	STDMETHOD(f1013)();
	STDMETHOD(f1014)();
	STDMETHOD(f1015)();
	STDMETHOD(f1016)();
	STDMETHOD(f1017)();
	STDMETHOD(f1018)();
	STDMETHOD(f1019)();
	STDMETHOD(f1020)();
	STDMETHOD(f1021)();
	STDMETHOD(f1022)();
	STDMETHOD(f1023)();
	STDMETHOD(f1024)();
	_QIThunk(IUnknown* pOrig, LPCTSTR p, const IID& i, UINT n, bool b)
	{
		lpszClassName = p;
		iid = i;
		nIndex = n;
		m_dwRef = 0;
		m_dwMaxRef = 0;
		pUnk = pOrig;
		bBreak = b;
		bNonAddRefThunk = false;
	}
	IUnknown* pUnk;
	long m_dwRef;
	long m_dwMaxRef;
	LPCTSTR lpszClassName;
	IID iid;
	UINT nIndex;
	bool bBreak;
	bool bNonAddRefThunk;
	void Dump()
	{
		TCHAR buf[256];
		if (m_dwRef != 0)
		{
			wsprintf(buf, _T("INTERFACE LEAK: RefCount = %d, MaxRefCount = %d, {Allocation = %d} "), m_dwRef, m_dwMaxRef, nIndex);
			OutputDebugString(buf);
			AtlDumpIID(iid, lpszClassName, S_OK);
		}
		else
		{
			wsprintf(buf, _T("NonAddRef Thunk LEAK: {Allocation = %d}\n"), nIndex);
			OutputDebugString(buf);
		}
	}
};
#endif


/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap

template <class T>
class CSimpleArray
{
public:
	T* m_aT;
	int m_nSize;
	int m_nAllocSize;

// Construction/destruction
	CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{ }

	~CSimpleArray()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(T& t)
	{
		if(m_nSize == m_nAllocSize)
		{
			T* aT;
			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
			aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
			if(aT == NULL)
				return FALSE;
			m_nAllocSize = nNewAllocSize;
			m_aT = aT;
		}
		m_nSize++;
		SetAtIndex(m_nSize - 1, t);
		return TRUE;
	}
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(int nIndex)
	{
		if(nIndex != (m_nSize - 1))
		{
#if (_WIN32_WCE == 200)
			if(m_aT[nIndex] != NULL)
				delete m_aT[nIndex];
#else // _WIN32_WCE
			m_aT[nIndex].~T();
#endif // _WIN32_WCE
			memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
		}
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aT != NULL)
		{
			for(int i = 0; i < m_nSize; i++)
#if (_WIN32_WCE == 200)
				if(m_aT[i] != NULL)
					delete m_aT[i];
#else // _WIN32_WCE
				m_aT[i].~T();
#endif // _WIN32_WCE
			free(m_aT);
			m_aT = NULL;
		}
		m_nSize = 0;
		m_nAllocSize = 0;
	}
	T& operator[] (int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aT[nIndex];
	}
	T* GetData() const
	{
		return m_aT;
	}

// Implementation
	class Wrapper
	{
	public:
		Wrapper(T& _t) : t(_t)
		{
		}
		template <class _Ty>
		void *operator new(size_t, _Ty* p)
		{
			return p;
		}
		T t;
	};
	void SetAtIndex(int nIndex, T& t)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		new(&m_aT[nIndex]) Wrapper(t);
	}
	int Find(T& t) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};

// for arrays of simple types
template <class T>
class CSimpleValArray : public CSimpleArray< T >
{
public:
	BOOL Add(T t)
	{
		return CSimpleArray< T >::Add(t);
	}
	BOOL Remove(T t)
	{
		return CSimpleArray< T >::Remove(t);
	}
	T operator[] (int nIndex) const
	{
		return CSimpleArray< T >::operator[](nIndex);
	}
};


// intended for small number of simple types or pointers
template <class TKey, class TVal>
class CSimpleMap
{
public:
	TKey* m_aKey;
	TVal* m_aVal;
	int m_nSize;

// Construction/destruction
	CSimpleMap() : m_aKey(NULL), m_aVal(NULL), m_nSize(0)
	{ }

	~CSimpleMap()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(TKey key, TVal val)
	{
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize + 1) * sizeof(TKey));
		if(pKey == NULL)
			return FALSE;
		m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize + 1) * sizeof(TVal));
		if(pVal == NULL)
			return FALSE;
		m_aVal = pVal;
		m_nSize++;
		SetAtIndex(m_nSize - 1, key, val);
		return TRUE;
	}
	BOOL Remove(TKey key)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		if(nIndex != (m_nSize - 1))
		{
#if (_WIN32_WCE == 200)
			if(m_aKey[nIndex] != NULL)
				delete m_aKey[nIndex];
			if(m_aVal[nIndex] != NULL)
				delete m_aVal[nIndex];
#else // _WIN32_WCE
			m_aKey[nIndex].~TKey();
			m_aVal[nIndex].~TVal();
#endif // _WIN32_WCE
			memmove((void*)&m_aKey[nIndex], (void*)&m_aKey[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TKey));
			memmove((void*)&m_aVal[nIndex], (void*)&m_aVal[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(TVal));
		}
		TKey* pKey;
		pKey = (TKey*)realloc(m_aKey, (m_nSize - 1) * sizeof(TKey));
		if(pKey != NULL || m_nSize == 1)
			m_aKey = pKey;
		TVal* pVal;
		pVal = (TVal*)realloc(m_aVal, (m_nSize - 1) * sizeof(TVal));
		if(pVal != NULL || m_nSize == 1)
			m_aVal = pVal;
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aKey != NULL)
		{
			for(int i = 0; i < m_nSize; i++)
			{
#if (_WIN32_WCE == 200)
			if(m_aKey[i] != NULL)
				delete m_aKey[nIndex];
			if(m_aVal[i] != NULL)
				delete m_aVal[nIndex];
#else // _WIN32_WCE
				m_aKey[i].~TKey();
				m_aVal[i].~TVal();
#endif // _WIN32_WCE
			}
			free(m_aKey);
			m_aKey = NULL;
		}
		if(m_aVal != NULL)
		{
			free(m_aVal);
			m_aVal = NULL;
		}

		m_nSize = 0;
	}
	BOOL SetAt(TKey key, TVal val)
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return FALSE;
		SetAtIndex(nIndex, key, val);
		return TRUE;
	}
	TVal Lookup(TKey key) const
	{
		int nIndex = FindKey(key);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetValueAt(nIndex);
	}
	TKey ReverseLookup(TVal val) const
	{
		int nIndex = FindVal(val);
		if(nIndex == -1)
			return NULL;	// must be able to convert
		return GetKeyAt(nIndex);
	}
	TKey& GetKeyAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aKey[nIndex];
	}
	TVal& GetValueAt(int nIndex) const
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aVal[nIndex];
	}

// Implementation

	template <typename T>
	class Wrapper
	{
	public:
		Wrapper(T& _t) : t(_t)
		{
		}
		template <typename _Ty>
		void *operator new(size_t, _Ty* p)
		{
			return p;
		}
		T t;
	};
	void SetAtIndex(int nIndex, TKey& key, TVal& val)
	{
		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);
		new(&m_aKey[nIndex]) Wrapper<TKey>(key);
		new(&m_aVal[nIndex]) Wrapper<TVal>(val);
	}
	int FindKey(TKey& key) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aKey[i] == key)
				return i;
		}
		return -1;	// not found
	}
	int FindVal(TVal& val) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aVal[i] == val)
				return i;
		}
		return -1;	// not found
	}
};


class CComModule;
__declspec(selectany) CComModule* _pModule=NULL;

// {B62F5910-6528-11d1-9611-0000F81E0D0D}
_declspec(selectany) GUID GUID_ATLVer30 = { 0xb62f5910, 0x6528, 0x11d1, { 0x96, 0x11, 0x0, 0x0, 0xf8, 0x1e, 0xd, 0xd } };

class CComModule : public _ATL_MODULE
{
// Operations
public:
	static GUID m_libid;
#ifdef _ATL_DEBUG_INTERFACES
	UINT m_nIndexQI;
	UINT m_nIndexBreakAt;
	CSimpleArray<_QIThunk*>* m_paThunks;
#endif // _ATL_DEBUG_INTERFACES

	void AddCreateWndData(_AtlCreateWndData* pData, void* pObject)
	{
		AtlModuleAddCreateWndData(this, pData, pObject);
	}
	void* ExtractCreateWndData()
	{
		return AtlModuleExtractCreateWndData(this);
	}

	HRESULT Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid = NULL)
	{
		pguidVer = &GUID_ATLVer30;
		_pModule = this;
		cbSize = sizeof(_ATL_MODULE);
		dwAtlBuildVer = _ATL_VER;
		AtlModuleInit(this, p, h);
		if (plibid != NULL)
			memcpy((void*)&m_libid, plibid, sizeof(GUID));
#ifdef _ATL_MIN_CRT
		// Create a base heap
		m_hHeap = HeapCreate(0, 0, 0);

#ifndef _ATL_NO_MP_HEAP
		SYSTEM_INFO si;
		GetSystemInfo(&si);
		if (si.dwNumberOfProcessors > 1)
		{
			DWORD dwHeaps = si.dwNumberOfProcessors * 2;
			m_dwHeaps = 0xFFFFFFFF;
			for (int bits=0; bits<32; bits++)
			{
				if (dwHeaps & 0x80000000)
					break;
				dwHeaps <<= 1;
				m_dwHeaps >>= 1;
			}
			m_dwHeaps >>= 1;

			// Allocate more heaps for each processor
			m_phHeaps = (HANDLE*) HeapAlloc(m_hHeap, _ATL_HEAPFLAGS, sizeof(HANDLE) * (m_dwHeaps + 1));
			for (DWORD i=0; i<=m_dwHeaps; i++)
				m_phHeaps[i] = HeapCreate(0, 0, 0);
		}
		else
#endif
		{
			m_phHeaps = NULL;
			m_dwHeaps = 0;
		}
#endif
#ifdef _ATL_DEBUG_INTERFACES
		m_nIndexQI = 0;
		m_nIndexBreakAt = 0;
		m_paThunks = NULL;
		ATLTRY(m_paThunks = new CSimpleArray<_QIThunk*>);
		if (m_paThunks == NULL)
			return E_OUTOFMEMORY;
#endif // _ATL_DEBUG_INTERFACES
		return S_OK;
	}
#ifdef _ATL_DEBUG_INTERFACES
	HRESULT AddThunk(IUnknown** pp, LPCTSTR lpsz, REFIID iid)
	{
		if ((pp == NULL) || (*pp == NULL))
			return E_POINTER;
		IUnknown* p = *pp;
		_QIThunk* pThunk = NULL;
		EnterCriticalSection(&m_csObjMap);
		// Check if exists already for identity
		if (InlineIsEqualUnknown(iid))
		{
			for (int i=0; i<m_paThunks->GetSize(); i++)
			{
				if (m_paThunks->operator[](i)->pUnk == p)
				{
					m_paThunks->operator[](i)->InternalAddRef();
					pThunk = m_paThunks->operator[](i);
					break;
				}
			}
		}
		if (pThunk == NULL)
		{
			++m_nIndexQI;
			if (m_nIndexBreakAt == m_nIndexQI)
				DebugBreak();
			ATLTRY(pThunk = new _QIThunk(p, lpsz, iid, m_nIndexQI, (m_nIndexBreakAt == m_nIndexQI)));
			if (pThunk == NULL)
				return E_OUTOFMEMORY;
			pThunk->InternalAddRef();
			m_paThunks->Add(pThunk);
		}
		LeaveCriticalSection(&m_csObjMap);
		*pp = (IUnknown*)pThunk;
		return S_OK;
	}
	HRESULT AddNonAddRefThunk(IUnknown* p, LPCTSTR lpsz, IUnknown** ppThunkRet)
	{
		_QIThunk* pThunk = NULL;
		EnterCriticalSection(&m_csObjMap);
		// Check if exists already for identity
		for (int i=0; i<m_paThunks->GetSize(); i++)
		{
			if (m_paThunks->operator[](i)->pUnk == p)
			{
				m_paThunks->operator[](i)->bNonAddRefThunk = true;
				pThunk = m_paThunks->operator[](i);
				break;
			}
		}
		if (pThunk == NULL)
		{
			++m_nIndexQI;
			if (m_nIndexBreakAt == m_nIndexQI)
				DebugBreak();
			ATLTRY(pThunk = new _QIThunk(p, lpsz, IID_IUnknown, m_nIndexQI, (m_nIndexBreakAt == m_nIndexQI)));
			if (pThunk == NULL)
			{
				*ppThunkRet = NULL;
				return E_OUTOFMEMORY;
			}
			pThunk->bNonAddRefThunk = true;
			m_paThunks->Add(pThunk);
		}
		LeaveCriticalSection(&m_csObjMap);
		*ppThunkRet = (IUnknown*)pThunk;
		return S_OK;;
	}
	void DeleteNonAddRefThunk(IUnknown* pUnk)
	{
		EnterCriticalSection(&m_csObjMap);
		for (int i=0; i<m_paThunks->GetSize(); i++)
		{
			if (m_paThunks->operator[](i)->pUnk == pUnk)
			{
				delete m_paThunks->operator[](i);
				m_paThunks->RemoveAt(i);
				break;
			}
		}
		LeaveCriticalSection(&m_csObjMap);
	}
	void DeleteThunk(_QIThunk* p)
	{
		EnterCriticalSection(&m_csObjMap);
		int nIndex = m_paThunks->Find(p);
		if (nIndex != -1)
		{
			delete m_paThunks->operator[](nIndex);
			m_paThunks->RemoveAt(nIndex);
		}
		LeaveCriticalSection(&m_csObjMap);
	}
	bool DumpLeakedThunks()
	{
		bool b = false;
		for (int i=0; i<m_paThunks->GetSize(); i++)
		{
			b = true;
			m_paThunks->operator[](i)->Dump();
			delete m_paThunks->operator[](i);
		}
		m_paThunks->RemoveAll();
		return b;
	}
#endif // _ATL_DEBUG_INTERFACES
	void Term()
	{
#ifdef _ATL_DEBUG_INTERFACES
		m_bDestroyHeap = false; // prevent heap from going away
		AtlModuleTerm(this);
		DumpLeakedThunks();
		delete m_paThunks;
#ifndef _ATL_NO_MP_HEAP
		if (m_phHeaps != NULL)
		{
			for (DWORD i = 0; i <= m_dwHeaps; i++)
				HeapDestroy(m_phHeaps[i]);
		}
#endif
		if (m_hHeap != NULL)
			HeapDestroy(m_hHeap);
#else
		AtlModuleTerm(this);
#endif // _ATL_DEBUG_INTERFACES
	}

	HRESULT AddTermFunc(_ATL_TERMFUNC* pFunc, DWORD dw)
	{
		return AtlModuleAddTermFunc(this, pFunc, dw);
	}

	LONG Lock()
	{
		return CComGlobalsThreadModel::Increment(&m_nLockCnt);
	}
	LONG Unlock()
	{
		return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
	}
	LONG GetLockCount()
	{
		return m_nLockCnt;
	}

	HINSTANCE GetModuleInstance() {return m_hInst;}
	HINSTANCE GetResourceInstance() {return m_hInstResource;}
	HINSTANCE GetTypeLibInstance() {return m_hInstTypeLib;}

	// Registry support (helpers)
	HRESULT RegisterTypeLib()
	{
		return AtlModuleRegisterTypeLib(this, NULL);
	}
	HRESULT RegisterTypeLib(LPCTSTR lpszIndex)
	{
		USES_CONVERSION;
		return AtlModuleRegisterTypeLib(this, T2COLE(lpszIndex));
	}
	HRESULT UnRegisterTypeLib()
	{
		return AtlModuleUnRegisterTypeLib(this, NULL);
	}
	HRESULT UnRegisterTypeLib(LPCTSTR lpszIndex)
	{
		USES_CONVERSION;
		return AtlModuleUnRegisterTypeLib(this, T2COLE(lpszIndex));
	}
	HRESULT RegisterServer(BOOL bRegTypeLib = FALSE, const CLSID* pCLSID = NULL)
	{
		return AtlModuleRegisterServer(this, bRegTypeLib, pCLSID);
	}

	HRESULT UnregisterServer(const CLSID* pCLSID = NULL)
	{
		return AtlModuleUnregisterServer(this, pCLSID);
	}
	HRESULT UnregisterServer(BOOL bUnRegTypeLib, const CLSID* pCLSID = NULL)
	{
		return AtlModuleUnregisterServerEx(this, bUnRegTypeLib, pCLSID);
	}

	// Resource-based Registration
	HRESULT WINAPI UpdateRegistryFromResourceD(LPCTSTR lpszRes, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL)
	{
		USES_CONVERSION;
		return AtlModuleUpdateRegistryFromResourceD(this, T2COLE(lpszRes), bRegister,
			pMapEntries);
	}
	HRESULT WINAPI UpdateRegistryFromResourceD(UINT nResID, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL)
	{
		return AtlModuleUpdateRegistryFromResourceD(this,
			(LPCOLESTR)MAKEINTRESOURCE(nResID), bRegister, pMapEntries);
	}

#ifdef _ATL_STATIC_REGISTRY
	// Statically linking to Registry Ponent
	HRESULT WINAPI UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
	HRESULT WINAPI UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
		struct _ATL_REGMAP_ENTRY* pMapEntries = NULL);
#endif

	// Standard Registration
	HRESULT WINAPI UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
		LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister);
	HRESULT WINAPI RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
		LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags);
	HRESULT WINAPI UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
		LPCTSTR lpszVerIndProgID);

	// Register/Revoke All Class Factories with the OS (EXE only)
#if !defined(_WIN32_WCE)
	HRESULT RegisterClassObjects(DWORD dwClsContext, DWORD dwFlags)
	{
		return AtlModuleRegisterClassObjects(this, dwClsContext, dwFlags);
	}
	HRESULT RevokeClassObjects()
	{
		return AtlModuleRevokeClassObjects(this);
	}
#endif // _WIN32_WCE

	// Obtain a Class Factory (DLL only)
	HRESULT GetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
	{
		return AtlModuleGetClassObject(this, rclsid, riid, ppv);
	}

	// Only used in CComAutoThreadModule
	HRESULT CreateInstance(void* /*pfnCreateInstance*/, REFIID /*riid*/, void** /*ppvObj*/)
	{
		ATLASSERT(FALSE);
		return E_NOTIMPL;
	}
	static HRESULT RegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc);

	static void ReplaceSingleQuote(LPOLESTR lpDest, LPCOLESTR lp)
	{
		while (*lp)
		{
			*lpDest++ = *lp;
			if (*lp == OLESTR('\''))
				*lpDest++ = *lp;
			lp++;
		}
		*lpDest = NULL;
	}
};

#ifdef _ATL_DEBUG_INTERFACES
inline ULONG _QIThunk::Release()
{
	if (bBreak)
		DebugBreak();
	ATLASSERT(m_dwRef > 0);
	ULONG l = InterlockedDecrement(&m_dwRef);
	ATLTRACE(_T("%d< "), m_dwRef);
	AtlDumpIID(iid, lpszClassName, S_OK);
	pUnk->Release();
	if (l == 0 && !bNonAddRefThunk)
		_pModule->DeleteThunk(this);
	return l;
}
inline static void atlBadThunkCall()
{
	ATLASSERT(FALSE && "Call through deleted thunk");
}
#define IMPL_THUNK(n)\
__declspec(naked) inline HRESULT _QIThunk::f##n()\
{\
	__asm mov eax, [esp+4]\
	__asm cmp dword ptr [eax+8], 0\
	__asm jg goodref\
	__asm call atlBadThunkCall\
	__asm goodref:\
	__asm mov eax, [esp+4]\
	__asm mov eax, dword ptr [eax+4]\
	__asm mov [esp+4], eax\
	__asm mov eax, dword ptr [eax]\
	__asm mov eax, dword ptr [eax+4*n]\
	__asm jmp eax\
}

IMPL_THUNK(3)
IMPL_THUNK(4)
IMPL_THUNK(5)
IMPL_THUNK(6)
IMPL_THUNK(7)
IMPL_THUNK(8)
IMPL_THUNK(9)
IMPL_THUNK(10)
IMPL_THUNK(11)
IMPL_THUNK(12)
IMPL_THUNK(13)
IMPL_THUNK(14)
IMPL_THUNK(15)
IMPL_THUNK(16)
IMPL_THUNK(17)
IMPL_THUNK(18)
IMPL_THUNK(19)
IMPL_THUNK(20)
IMPL_THUNK(21)
IMPL_THUNK(22)
IMPL_THUNK(23)
IMPL_THUNK(24)
IMPL_THUNK(25)
IMPL_THUNK(26)
IMPL_THUNK(27)
IMPL_THUNK(28)
IMPL_THUNK(29)
IMPL_THUNK(30)
IMPL_THUNK(31)
IMPL_THUNK(32)
IMPL_THUNK(33)
IMPL_THUNK(34)
IMPL_THUNK(35)
IMPL_THUNK(36)
IMPL_THUNK(37)
IMPL_THUNK(38)
IMPL_THUNK(39)
IMPL_THUNK(40)
IMPL_THUNK(41)
IMPL_THUNK(42)
IMPL_THUNK(43)
IMPL_THUNK(44)
IMPL_THUNK(45)
IMPL_THUNK(46)
IMPL_THUNK(47)
IMPL_THUNK(48)
IMPL_THUNK(49)
IMPL_THUNK(50)
IMPL_THUNK(51)
IMPL_THUNK(52)
IMPL_THUNK(53)
IMPL_THUNK(54)
IMPL_THUNK(55)
IMPL_THUNK(56)
IMPL_THUNK(57)
IMPL_THUNK(58)
IMPL_THUNK(59)
IMPL_THUNK(60)
IMPL_THUNK(61)
IMPL_THUNK(62)
IMPL_THUNK(63)
IMPL_THUNK(64)
IMPL_THUNK(65)
IMPL_THUNK(66)
IMPL_THUNK(67)
IMPL_THUNK(68)
IMPL_THUNK(69)
IMPL_THUNK(70)
IMPL_THUNK(71)
IMPL_THUNK(72)
IMPL_THUNK(73)
IMPL_THUNK(74)
IMPL_THUNK(75)
IMPL_THUNK(76)
IMPL_THUNK(77)
IMPL_THUNK(78)
IMPL_THUNK(79)
IMPL_THUNK(80)
IMPL_THUNK(81)
IMPL_THUNK(82)
IMPL_THUNK(83)
IMPL_THUNK(84)
IMPL_THUNK(85)
IMPL_THUNK(86)
IMPL_THUNK(87)
IMPL_THUNK(88)
IMPL_THUNK(89)
IMPL_THUNK(90)
IMPL_THUNK(91)
IMPL_THUNK(92)
IMPL_THUNK(93)
IMPL_THUNK(94)
IMPL_THUNK(95)
IMPL_THUNK(96)
IMPL_THUNK(97)
IMPL_THUNK(98)
IMPL_THUNK(99)
IMPL_THUNK(100)
IMPL_THUNK(101)
IMPL_THUNK(102)
IMPL_THUNK(103)
IMPL_THUNK(104)
IMPL_THUNK(105)
IMPL_THUNK(106)
IMPL_THUNK(107)
IMPL_THUNK(108)
IMPL_THUNK(109)
IMPL_THUNK(110)
IMPL_THUNK(111)
IMPL_THUNK(112)
IMPL_THUNK(113)
IMPL_THUNK(114)
IMPL_THUNK(115)
IMPL_THUNK(116)
IMPL_THUNK(117)
IMPL_THUNK(118)
IMPL_THUNK(119)
IMPL_THUNK(120)
IMPL_THUNK(121)
IMPL_THUNK(122)
IMPL_THUNK(123)
IMPL_THUNK(124)
IMPL_THUNK(125)
IMPL_THUNK(126)
IMPL_THUNK(127)
IMPL_THUNK(128)
IMPL_THUNK(129)
IMPL_THUNK(130)
IMPL_THUNK(131)
IMPL_THUNK(132)
IMPL_THUNK(133)
IMPL_THUNK(134)
IMPL_THUNK(135)
IMPL_THUNK(136)
IMPL_THUNK(137)
IMPL_THUNK(138)
IMPL_THUNK(139)
IMPL_THUNK(140)
IMPL_THUNK(141)
IMPL_THUNK(142)
IMPL_THUNK(143)
IMPL_THUNK(144)
IMPL_THUNK(145)
IMPL_THUNK(146)
IMPL_THUNK(147)
IMPL_THUNK(148)
IMPL_THUNK(149)
IMPL_THUNK(150)
IMPL_THUNK(151)
IMPL_THUNK(152)
IMPL_THUNK(153)
IMPL_THUNK(154)
IMPL_THUNK(155)
IMPL_THUNK(156)
IMPL_THUNK(157)
IMPL_THUNK(158)
IMPL_THUNK(159)
IMPL_THUNK(160)
IMPL_THUNK(161)
IMPL_THUNK(162)
IMPL_THUNK(163)
IMPL_THUNK(164)
IMPL_THUNK(165)
IMPL_THUNK(166)
IMPL_THUNK(167)
IMPL_THUNK(168)
IMPL_THUNK(169)
IMPL_THUNK(170)
IMPL_THUNK(171)
IMPL_THUNK(172)
IMPL_THUNK(173)
IMPL_THUNK(174)
IMPL_THUNK(175)
IMPL_THUNK(176)
IMPL_THUNK(177)
IMPL_THUNK(178)
IMPL_THUNK(179)
IMPL_THUNK(180)
IMPL_THUNK(181)
IMPL_THUNK(182)
IMPL_THUNK(183)
IMPL_THUNK(184)
IMPL_THUNK(185)
IMPL_THUNK(186)
IMPL_THUNK(187)
IMPL_THUNK(188)
IMPL_THUNK(189)
IMPL_THUNK(190)
IMPL_THUNK(191)
IMPL_THUNK(192)
IMPL_THUNK(193)
IMPL_THUNK(194)
IMPL_THUNK(195)
IMPL_THUNK(196)
IMPL_THUNK(197)
IMPL_THUNK(198)
IMPL_THUNK(199)
IMPL_THUNK(200)
IMPL_THUNK(201)
IMPL_THUNK(202)
IMPL_THUNK(203)
IMPL_THUNK(204)
IMPL_THUNK(205)
IMPL_THUNK(206)
IMPL_THUNK(207)
IMPL_THUNK(208)
IMPL_THUNK(209)
IMPL_THUNK(210)
IMPL_THUNK(211)
IMPL_THUNK(212)
IMPL_THUNK(213)
IMPL_THUNK(214)
IMPL_THUNK(215)
IMPL_THUNK(216)
IMPL_THUNK(217)
IMPL_THUNK(218)
IMPL_THUNK(219)
IMPL_THUNK(220)
IMPL_THUNK(221)
IMPL_THUNK(222)
IMPL_THUNK(223)
IMPL_THUNK(224)
IMPL_THUNK(225)
IMPL_THUNK(226)
IMPL_THUNK(227)
IMPL_THUNK(228)
IMPL_THUNK(229)
IMPL_THUNK(230)
IMPL_THUNK(231)
IMPL_THUNK(232)
IMPL_THUNK(233)
IMPL_THUNK(234)
IMPL_THUNK(235)
IMPL_THUNK(236)
IMPL_THUNK(237)
IMPL_THUNK(238)
IMPL_THUNK(239)
IMPL_THUNK(240)
IMPL_THUNK(241)
IMPL_THUNK(242)
IMPL_THUNK(243)
IMPL_THUNK(244)
IMPL_THUNK(245)
IMPL_THUNK(246)
IMPL_THUNK(247)
IMPL_THUNK(248)
IMPL_THUNK(249)
IMPL_THUNK(250)
IMPL_THUNK(251)
IMPL_THUNK(252)
IMPL_THUNK(253)
IMPL_THUNK(254)
IMPL_THUNK(255)
IMPL_THUNK(256)
IMPL_THUNK(257)
IMPL_THUNK(258)
IMPL_THUNK(259)
IMPL_THUNK(260)
IMPL_THUNK(261)
IMPL_THUNK(262)
IMPL_THUNK(263)
IMPL_THUNK(264)
IMPL_THUNK(265)
IMPL_THUNK(266)
IMPL_THUNK(267)
IMPL_THUNK(268)
IMPL_THUNK(269)
IMPL_THUNK(270)
IMPL_THUNK(271)
IMPL_THUNK(272)
IMPL_THUNK(273)
IMPL_THUNK(274)
IMPL_THUNK(275)
IMPL_THUNK(276)
IMPL_THUNK(277)
IMPL_THUNK(278)
IMPL_THUNK(279)
IMPL_THUNK(280)
IMPL_THUNK(281)
IMPL_THUNK(282)
IMPL_THUNK(283)
IMPL_THUNK(284)
IMPL_THUNK(285)
IMPL_THUNK(286)
IMPL_THUNK(287)
IMPL_THUNK(288)
IMPL_THUNK(289)
IMPL_THUNK(290)
IMPL_THUNK(291)
IMPL_THUNK(292)
IMPL_THUNK(293)
IMPL_THUNK(294)
IMPL_THUNK(295)
IMPL_THUNK(296)
IMPL_THUNK(297)
IMPL_THUNK(298)
IMPL_THUNK(299)
IMPL_THUNK(300)
IMPL_THUNK(301)
IMPL_THUNK(302)
IMPL_THUNK(303)
IMPL_THUNK(304)
IMPL_THUNK(305)
IMPL_THUNK(306)
IMPL_THUNK(307)
IMPL_THUNK(308)
IMPL_THUNK(309)
IMPL_THUNK(310)
IMPL_THUNK(311)
IMPL_THUNK(312)
IMPL_THUNK(313)
IMPL_THUNK(314)
IMPL_THUNK(315)
IMPL_THUNK(316)
IMPL_THUNK(317)
IMPL_THUNK(318)
IMPL_THUNK(319)
IMPL_THUNK(320)
IMPL_THUNK(321)
IMPL_THUNK(322)
IMPL_THUNK(323)
IMPL_THUNK(324)
IMPL_THUNK(325)
IMPL_THUNK(326)
IMPL_THUNK(327)
IMPL_THUNK(328)
IMPL_THUNK(329)
IMPL_THUNK(330)
IMPL_THUNK(331)
IMPL_THUNK(332)
IMPL_THUNK(333)
IMPL_THUNK(334)
IMPL_THUNK(335)
IMPL_THUNK(336)
IMPL_THUNK(337)
IMPL_THUNK(338)
IMPL_THUNK(339)
IMPL_THUNK(340)
IMPL_THUNK(341)
IMPL_THUNK(342)
IMPL_THUNK(343)
IMPL_THUNK(344)
IMPL_THUNK(345)
IMPL_THUNK(346)
IMPL_THUNK(347)
IMPL_THUNK(348)
IMPL_THUNK(349)
IMPL_THUNK(350)
IMPL_THUNK(351)
IMPL_THUNK(352)
IMPL_THUNK(353)
IMPL_THUNK(354)
IMPL_THUNK(355)
IMPL_THUNK(356)
IMPL_THUNK(357)
IMPL_THUNK(358)
IMPL_THUNK(359)
IMPL_THUNK(360)
IMPL_THUNK(361)
IMPL_THUNK(362)
IMPL_THUNK(363)
IMPL_THUNK(364)
IMPL_THUNK(365)
IMPL_THUNK(366)
IMPL_THUNK(367)
IMPL_THUNK(368)
IMPL_THUNK(369)
IMPL_THUNK(370)
IMPL_THUNK(371)
IMPL_THUNK(372)
IMPL_THUNK(373)
IMPL_THUNK(374)
IMPL_THUNK(375)
IMPL_THUNK(376)
IMPL_THUNK(377)
IMPL_THUNK(378)
IMPL_THUNK(379)
IMPL_THUNK(380)
IMPL_THUNK(381)
IMPL_THUNK(382)
IMPL_THUNK(383)
IMPL_THUNK(384)
IMPL_THUNK(385)
IMPL_THUNK(386)
IMPL_THUNK(387)
IMPL_THUNK(388)
IMPL_THUNK(389)
IMPL_THUNK(390)
IMPL_THUNK(391)
IMPL_THUNK(392)
IMPL_THUNK(393)
IMPL_THUNK(394)
IMPL_THUNK(395)
IMPL_THUNK(396)
IMPL_THUNK(397)
IMPL_THUNK(398)
IMPL_THUNK(399)
IMPL_THUNK(400)
IMPL_THUNK(401)
IMPL_THUNK(402)
IMPL_THUNK(403)
IMPL_THUNK(404)
IMPL_THUNK(405)
IMPL_THUNK(406)
IMPL_THUNK(407)
IMPL_THUNK(408)
IMPL_THUNK(409)
IMPL_THUNK(410)
IMPL_THUNK(411)
IMPL_THUNK(412)
IMPL_THUNK(413)
IMPL_THUNK(414)
IMPL_THUNK(415)
IMPL_THUNK(416)
IMPL_THUNK(417)
IMPL_THUNK(418)
IMPL_THUNK(419)
IMPL_THUNK(420)
IMPL_THUNK(421)
IMPL_THUNK(422)
IMPL_THUNK(423)
IMPL_THUNK(424)
IMPL_THUNK(425)
IMPL_THUNK(426)
IMPL_THUNK(427)
IMPL_THUNK(428)
IMPL_THUNK(429)
IMPL_THUNK(430)
IMPL_THUNK(431)
IMPL_THUNK(432)
IMPL_THUNK(433)
IMPL_THUNK(434)
IMPL_THUNK(435)
IMPL_THUNK(436)
IMPL_THUNK(437)
IMPL_THUNK(438)
IMPL_THUNK(439)
IMPL_THUNK(440)
IMPL_THUNK(441)
IMPL_THUNK(442)
IMPL_THUNK(443)
IMPL_THUNK(444)
IMPL_THUNK(445)
IMPL_THUNK(446)
IMPL_THUNK(447)
IMPL_THUNK(448)
IMPL_THUNK(449)
IMPL_THUNK(450)
IMPL_THUNK(451)
IMPL_THUNK(452)
IMPL_THUNK(453)
IMPL_THUNK(454)
IMPL_THUNK(455)
IMPL_THUNK(456)
IMPL_THUNK(457)
IMPL_THUNK(458)
IMPL_THUNK(459)
IMPL_THUNK(460)
IMPL_THUNK(461)
IMPL_THUNK(462)
IMPL_THUNK(463)
IMPL_THUNK(464)
IMPL_THUNK(465)
IMPL_THUNK(466)
IMPL_THUNK(467)
IMPL_THUNK(468)
IMPL_THUNK(469)
IMPL_THUNK(470)
IMPL_THUNK(471)
IMPL_THUNK(472)
IMPL_THUNK(473)
IMPL_THUNK(474)
IMPL_THUNK(475)
IMPL_THUNK(476)
IMPL_THUNK(477)
IMPL_THUNK(478)
IMPL_THUNK(479)
IMPL_THUNK(480)
IMPL_THUNK(481)
IMPL_THUNK(482)
IMPL_THUNK(483)
IMPL_THUNK(484)
IMPL_THUNK(485)
IMPL_THUNK(486)
IMPL_THUNK(487)
IMPL_THUNK(488)
IMPL_THUNK(489)
IMPL_THUNK(490)
IMPL_THUNK(491)
IMPL_THUNK(492)
IMPL_THUNK(493)
IMPL_THUNK(494)
IMPL_THUNK(495)
IMPL_THUNK(496)
IMPL_THUNK(497)
IMPL_THUNK(498)
IMPL_THUNK(499)
IMPL_THUNK(500)
IMPL_THUNK(501)
IMPL_THUNK(502)
IMPL_THUNK(503)
IMPL_THUNK(504)
IMPL_THUNK(505)
IMPL_THUNK(506)
IMPL_THUNK(507)
IMPL_THUNK(508)
IMPL_THUNK(509)
IMPL_THUNK(510)
IMPL_THUNK(511)
IMPL_THUNK(512)
IMPL_THUNK(513)
IMPL_THUNK(514)
IMPL_THUNK(515)
IMPL_THUNK(516)
IMPL_THUNK(517)
IMPL_THUNK(518)
IMPL_THUNK(519)
IMPL_THUNK(520)
IMPL_THUNK(521)
IMPL_THUNK(522)
IMPL_THUNK(523)
IMPL_THUNK(524)
IMPL_THUNK(525)
IMPL_THUNK(526)
IMPL_THUNK(527)
IMPL_THUNK(528)
IMPL_THUNK(529)
IMPL_THUNK(530)
IMPL_THUNK(531)
IMPL_THUNK(532)
IMPL_THUNK(533)
IMPL_THUNK(534)
IMPL_THUNK(535)
IMPL_THUNK(536)
IMPL_THUNK(537)
IMPL_THUNK(538)
IMPL_THUNK(539)
IMPL_THUNK(540)
IMPL_THUNK(541)
IMPL_THUNK(542)
IMPL_THUNK(543)
IMPL_THUNK(544)
IMPL_THUNK(545)
IMPL_THUNK(546)
IMPL_THUNK(547)
IMPL_THUNK(548)
IMPL_THUNK(549)
IMPL_THUNK(550)
IMPL_THUNK(551)
IMPL_THUNK(552)
IMPL_THUNK(553)
IMPL_THUNK(554)
IMPL_THUNK(555)
IMPL_THUNK(556)
IMPL_THUNK(557)
IMPL_THUNK(558)
IMPL_THUNK(559)
IMPL_THUNK(560)
IMPL_THUNK(561)
IMPL_THUNK(562)
IMPL_THUNK(563)
IMPL_THUNK(564)
IMPL_THUNK(565)
IMPL_THUNK(566)
IMPL_THUNK(567)
IMPL_THUNK(568)
IMPL_THUNK(569)
IMPL_THUNK(570)
IMPL_THUNK(571)
IMPL_THUNK(572)
IMPL_THUNK(573)
IMPL_THUNK(574)
IMPL_THUNK(575)
IMPL_THUNK(576)
IMPL_THUNK(577)
IMPL_THUNK(578)
IMPL_THUNK(579)
IMPL_THUNK(580)
IMPL_THUNK(581)
IMPL_THUNK(582)
IMPL_THUNK(583)
IMPL_THUNK(584)
IMPL_THUNK(585)
IMPL_THUNK(586)
IMPL_THUNK(587)
IMPL_THUNK(588)
IMPL_THUNK(589)
IMPL_THUNK(590)
IMPL_THUNK(591)
IMPL_THUNK(592)
IMPL_THUNK(593)
IMPL_THUNK(594)
IMPL_THUNK(595)
IMPL_THUNK(596)
IMPL_THUNK(597)
IMPL_THUNK(598)
IMPL_THUNK(599)
IMPL_THUNK(600)
IMPL_THUNK(601)
IMPL_THUNK(602)
IMPL_THUNK(603)
IMPL_THUNK(604)
IMPL_THUNK(605)
IMPL_THUNK(606)
IMPL_THUNK(607)
IMPL_THUNK(608)
IMPL_THUNK(609)
IMPL_THUNK(610)
IMPL_THUNK(611)
IMPL_THUNK(612)
IMPL_THUNK(613)
IMPL_THUNK(614)
IMPL_THUNK(615)
IMPL_THUNK(616)
IMPL_THUNK(617)
IMPL_THUNK(618)
IMPL_THUNK(619)
IMPL_THUNK(620)
IMPL_THUNK(621)
IMPL_THUNK(622)
IMPL_THUNK(623)
IMPL_THUNK(624)
IMPL_THUNK(625)
IMPL_THUNK(626)
IMPL_THUNK(627)
IMPL_THUNK(628)
IMPL_THUNK(629)
IMPL_THUNK(630)
IMPL_THUNK(631)
IMPL_THUNK(632)
IMPL_THUNK(633)
IMPL_THUNK(634)
IMPL_THUNK(635)
IMPL_THUNK(636)
IMPL_THUNK(637)
IMPL_THUNK(638)
IMPL_THUNK(639)
IMPL_THUNK(640)
IMPL_THUNK(641)
IMPL_THUNK(642)
IMPL_THUNK(643)
IMPL_THUNK(644)
IMPL_THUNK(645)
IMPL_THUNK(646)
IMPL_THUNK(647)
IMPL_THUNK(648)
IMPL_THUNK(649)
IMPL_THUNK(650)
IMPL_THUNK(651)
IMPL_THUNK(652)
IMPL_THUNK(653)
IMPL_THUNK(654)
IMPL_THUNK(655)
IMPL_THUNK(656)
IMPL_THUNK(657)
IMPL_THUNK(658)
IMPL_THUNK(659)
IMPL_THUNK(660)
IMPL_THUNK(661)
IMPL_THUNK(662)
IMPL_THUNK(663)
IMPL_THUNK(664)
IMPL_THUNK(665)
IMPL_THUNK(666)
IMPL_THUNK(667)
IMPL_THUNK(668)
IMPL_THUNK(669)
IMPL_THUNK(670)
IMPL_THUNK(671)
IMPL_THUNK(672)
IMPL_THUNK(673)
IMPL_THUNK(674)
IMPL_THUNK(675)
IMPL_THUNK(676)
IMPL_THUNK(677)
IMPL_THUNK(678)
IMPL_THUNK(679)
IMPL_THUNK(680)
IMPL_THUNK(681)
IMPL_THUNK(682)
IMPL_THUNK(683)
IMPL_THUNK(684)
IMPL_THUNK(685)
IMPL_THUNK(686)
IMPL_THUNK(687)
IMPL_THUNK(688)
IMPL_THUNK(689)
IMPL_THUNK(690)
IMPL_THUNK(691)
IMPL_THUNK(692)
IMPL_THUNK(693)
IMPL_THUNK(694)
IMPL_THUNK(695)
IMPL_THUNK(696)
IMPL_THUNK(697)
IMPL_THUNK(698)
IMPL_THUNK(699)
IMPL_THUNK(700)
IMPL_THUNK(701)
IMPL_THUNK(702)
IMPL_THUNK(703)
IMPL_THUNK(704)
IMPL_THUNK(705)
IMPL_THUNK(706)
IMPL_THUNK(707)
IMPL_THUNK(708)
IMPL_THUNK(709)
IMPL_THUNK(710)
IMPL_THUNK(711)
IMPL_THUNK(712)
IMPL_THUNK(713)
IMPL_THUNK(714)
IMPL_THUNK(715)
IMPL_THUNK(716)
IMPL_THUNK(717)
IMPL_THUNK(718)
IMPL_THUNK(719)
IMPL_THUNK(720)
IMPL_THUNK(721)
IMPL_THUNK(722)
IMPL_THUNK(723)
IMPL_THUNK(724)
IMPL_THUNK(725)
IMPL_THUNK(726)
IMPL_THUNK(727)
IMPL_THUNK(728)
IMPL_THUNK(729)
IMPL_THUNK(730)
IMPL_THUNK(731)
IMPL_THUNK(732)
IMPL_THUNK(733)
IMPL_THUNK(734)
IMPL_THUNK(735)
IMPL_THUNK(736)
IMPL_THUNK(737)
IMPL_THUNK(738)
IMPL_THUNK(739)
IMPL_THUNK(740)
IMPL_THUNK(741)
IMPL_THUNK(742)
IMPL_THUNK(743)
IMPL_THUNK(744)
IMPL_THUNK(745)
IMPL_THUNK(746)
IMPL_THUNK(747)
IMPL_THUNK(748)
IMPL_THUNK(749)
IMPL_THUNK(750)
IMPL_THUNK(751)
IMPL_THUNK(752)
IMPL_THUNK(753)
IMPL_THUNK(754)
IMPL_THUNK(755)
IMPL_THUNK(756)
IMPL_THUNK(757)
IMPL_THUNK(758)
IMPL_THUNK(759)
IMPL_THUNK(760)
IMPL_THUNK(761)
IMPL_THUNK(762)
IMPL_THUNK(763)
IMPL_THUNK(764)
IMPL_THUNK(765)
IMPL_THUNK(766)
IMPL_THUNK(767)
IMPL_THUNK(768)
IMPL_THUNK(769)
IMPL_THUNK(770)
IMPL_THUNK(771)
IMPL_THUNK(772)
IMPL_THUNK(773)
IMPL_THUNK(774)
IMPL_THUNK(775)
IMPL_THUNK(776)
IMPL_THUNK(777)
IMPL_THUNK(778)
IMPL_THUNK(779)
IMPL_THUNK(780)
IMPL_THUNK(781)
IMPL_THUNK(782)
IMPL_THUNK(783)
IMPL_THUNK(784)
IMPL_THUNK(785)
IMPL_THUNK(786)
IMPL_THUNK(787)
IMPL_THUNK(788)
IMPL_THUNK(789)
IMPL_THUNK(790)
IMPL_THUNK(791)
IMPL_THUNK(792)
IMPL_THUNK(793)
IMPL_THUNK(794)
IMPL_THUNK(795)
IMPL_THUNK(796)
IMPL_THUNK(797)
IMPL_THUNK(798)
IMPL_THUNK(799)
IMPL_THUNK(800)
IMPL_THUNK(801)
IMPL_THUNK(802)
IMPL_THUNK(803)
IMPL_THUNK(804)
IMPL_THUNK(805)
IMPL_THUNK(806)
IMPL_THUNK(807)
IMPL_THUNK(808)
IMPL_THUNK(809)
IMPL_THUNK(810)
IMPL_THUNK(811)
IMPL_THUNK(812)
IMPL_THUNK(813)
IMPL_THUNK(814)
IMPL_THUNK(815)
IMPL_THUNK(816)
IMPL_THUNK(817)
IMPL_THUNK(818)
IMPL_THUNK(819)
IMPL_THUNK(820)
IMPL_THUNK(821)
IMPL_THUNK(822)
IMPL_THUNK(823)
IMPL_THUNK(824)
IMPL_THUNK(825)
IMPL_THUNK(826)
IMPL_THUNK(827)
IMPL_THUNK(828)
IMPL_THUNK(829)
IMPL_THUNK(830)
IMPL_THUNK(831)
IMPL_THUNK(832)
IMPL_THUNK(833)
IMPL_THUNK(834)
IMPL_THUNK(835)
IMPL_THUNK(836)
IMPL_THUNK(837)
IMPL_THUNK(838)
IMPL_THUNK(839)
IMPL_THUNK(840)
IMPL_THUNK(841)
IMPL_THUNK(842)
IMPL_THUNK(843)
IMPL_THUNK(844)
IMPL_THUNK(845)
IMPL_THUNK(846)
IMPL_THUNK(847)
IMPL_THUNK(848)
IMPL_THUNK(849)
IMPL_THUNK(850)
IMPL_THUNK(851)
IMPL_THUNK(852)
IMPL_THUNK(853)
IMPL_THUNK(854)
IMPL_THUNK(855)
IMPL_THUNK(856)
IMPL_THUNK(857)
IMPL_THUNK(858)
IMPL_THUNK(859)
IMPL_THUNK(860)
IMPL_THUNK(861)
IMPL_THUNK(862)
IMPL_THUNK(863)
IMPL_THUNK(864)
IMPL_THUNK(865)
IMPL_THUNK(866)
IMPL_THUNK(867)
IMPL_THUNK(868)
IMPL_THUNK(869)
IMPL_THUNK(870)
IMPL_THUNK(871)
IMPL_THUNK(872)
IMPL_THUNK(873)
IMPL_THUNK(874)
IMPL_THUNK(875)
IMPL_THUNK(876)
IMPL_THUNK(877)
IMPL_THUNK(878)
IMPL_THUNK(879)
IMPL_THUNK(880)
IMPL_THUNK(881)
IMPL_THUNK(882)
IMPL_THUNK(883)
IMPL_THUNK(884)
IMPL_THUNK(885)
IMPL_THUNK(886)
IMPL_THUNK(887)
IMPL_THUNK(888)
IMPL_THUNK(889)
IMPL_THUNK(890)
IMPL_THUNK(891)
IMPL_THUNK(892)
IMPL_THUNK(893)
IMPL_THUNK(894)
IMPL_THUNK(895)
IMPL_THUNK(896)
IMPL_THUNK(897)
IMPL_THUNK(898)
IMPL_THUNK(899)
IMPL_THUNK(900)
IMPL_THUNK(901)
IMPL_THUNK(902)
IMPL_THUNK(903)
IMPL_THUNK(904)
IMPL_THUNK(905)
IMPL_THUNK(906)
IMPL_THUNK(907)
IMPL_THUNK(908)
IMPL_THUNK(909)
IMPL_THUNK(910)
IMPL_THUNK(911)
IMPL_THUNK(912)
IMPL_THUNK(913)
IMPL_THUNK(914)
IMPL_THUNK(915)
IMPL_THUNK(916)
IMPL_THUNK(917)
IMPL_THUNK(918)
IMPL_THUNK(919)
IMPL_THUNK(920)
IMPL_THUNK(921)
IMPL_THUNK(922)
IMPL_THUNK(923)
IMPL_THUNK(924)
IMPL_THUNK(925)
IMPL_THUNK(926)
IMPL_THUNK(927)
IMPL_THUNK(928)
IMPL_THUNK(929)
IMPL_THUNK(930)
IMPL_THUNK(931)
IMPL_THUNK(932)
IMPL_THUNK(933)
IMPL_THUNK(934)
IMPL_THUNK(935)
IMPL_THUNK(936)
IMPL_THUNK(937)
IMPL_THUNK(938)
IMPL_THUNK(939)
IMPL_THUNK(940)
IMPL_THUNK(941)
IMPL_THUNK(942)
IMPL_THUNK(943)
IMPL_THUNK(944)
IMPL_THUNK(945)
IMPL_THUNK(946)
IMPL_THUNK(947)
IMPL_THUNK(948)
IMPL_THUNK(949)
IMPL_THUNK(950)
IMPL_THUNK(951)
IMPL_THUNK(952)
IMPL_THUNK(953)
IMPL_THUNK(954)
IMPL_THUNK(955)
IMPL_THUNK(956)
IMPL_THUNK(957)
IMPL_THUNK(958)
IMPL_THUNK(959)
IMPL_THUNK(960)
IMPL_THUNK(961)
IMPL_THUNK(962)
IMPL_THUNK(963)
IMPL_THUNK(964)
IMPL_THUNK(965)
IMPL_THUNK(966)
IMPL_THUNK(967)
IMPL_THUNK(968)
IMPL_THUNK(969)
IMPL_THUNK(970)
IMPL_THUNK(971)
IMPL_THUNK(972)
IMPL_THUNK(973)
IMPL_THUNK(974)
IMPL_THUNK(975)
IMPL_THUNK(976)
IMPL_THUNK(977)
IMPL_THUNK(978)
IMPL_THUNK(979)
IMPL_THUNK(980)
IMPL_THUNK(981)
IMPL_THUNK(982)
IMPL_THUNK(983)
IMPL_THUNK(984)
IMPL_THUNK(985)
IMPL_THUNK(986)
IMPL_THUNK(987)
IMPL_THUNK(988)
IMPL_THUNK(989)
IMPL_THUNK(990)
IMPL_THUNK(991)
IMPL_THUNK(992)
IMPL_THUNK(993)
IMPL_THUNK(994)
IMPL_THUNK(995)
IMPL_THUNK(996)
IMPL_THUNK(997)
IMPL_THUNK(998)
IMPL_THUNK(999)
IMPL_THUNK(1000)
IMPL_THUNK(1001)
IMPL_THUNK(1002)
IMPL_THUNK(1003)
IMPL_THUNK(1004)
IMPL_THUNK(1005)
IMPL_THUNK(1006)
IMPL_THUNK(1007)
IMPL_THUNK(1008)
IMPL_THUNK(1009)
IMPL_THUNK(1010)
IMPL_THUNK(1011)
IMPL_THUNK(1012)
IMPL_THUNK(1013)
IMPL_THUNK(1014)
IMPL_THUNK(1015)
IMPL_THUNK(1016)
IMPL_THUNK(1017)
IMPL_THUNK(1018)
IMPL_THUNK(1019)
IMPL_THUNK(1020)
IMPL_THUNK(1021)
IMPL_THUNK(1022)
IMPL_THUNK(1023)
IMPL_THUNK(1024)

#endif

__declspec(selectany) GUID CComModule::m_libid = {0x0,0x0,0x0,{0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0}};

#ifdef _ATL_STATIC_REGISTRY
#define UpdateRegistryFromResource UpdateRegistryFromResourceS
#else
#define UpdateRegistryFromResource UpdateRegistryFromResourceD
#endif

/////////////////////////////////////////////////////////////////////////////////////////////
// Thread Pooling classes

class _AtlAptCreateObjData
{
public:
	_ATL_CREATORFUNC* pfnCreateInstance;
	const IID* piid;
	HANDLE hEvent;
	LPSTREAM pStream;
	HRESULT hRes;
};

class CComApartment
{
public:
	CComApartment()
	{
		m_nLockCnt = 0;
	}
	static UINT ATL_CREATE_OBJECT;
	static DWORD WINAPI _Apartment(void* pv)
	{
		return ((CComApartment*)pv)->Apartment();
	}
	DWORD Apartment()
	{
#if !defined(_WIN32_WCE)
		CoInitialize(NULL);
		MSG msg;
		while(GetMessage(&msg, 0, 0, 0))
		{
			if (msg.message == ATL_CREATE_OBJECT)
			{
				_AtlAptCreateObjData* pdata = (_AtlAptCreateObjData*)msg.lParam;
				IUnknown* pUnk = NULL;
				pdata->hRes = pdata->pfnCreateInstance(NULL, IID_IUnknown, (void**)&pUnk);
				if (SUCCEEDED(pdata->hRes))
					pdata->hRes = CoMarshalInterThreadInterfaceInStream(*pdata->piid, pUnk, &pdata->pStream);
				if (SUCCEEDED(pdata->hRes))
				{
					pUnk->Release();
					ATLTRACE2(atlTraceCOM, 2, _T("Object created on thread = %d\n"), GetCurrentThreadId());
				}
				SetEvent(pdata->hEvent);
			}
			DispatchMessage(&msg);
		}
		CoUninitialize();
#endif // _WIN32_WCE
		return 0;
	}
	LONG Lock() {return CComGlobalsThreadModel::Increment(&m_nLockCnt);}
	LONG Unlock(){return CComGlobalsThreadModel::Decrement(&m_nLockCnt);
	}
	LONG GetLockCount() {return m_nLockCnt;}

	DWORD m_dwThreadID;
	HANDLE m_hThread;
	LONG m_nLockCnt;
};

__declspec(selectany) UINT CComApartment::ATL_CREATE_OBJECT = 0;

class CComSimpleThreadAllocator
{
public:
	CComSimpleThreadAllocator()
	{
		m_nThread = 0;
	}
	int GetThread(CComApartment* /*pApt*/, int nThreads)
	{
		if (++m_nThread == nThreads)
			m_nThread = 0;
		return m_nThread;
	}
	int m_nThread;
};

template <class ThreadAllocator = CComSimpleThreadAllocator>
class CComAutoThreadModule : public CComModule
{
public:
	HRESULT Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, const GUID* plibid = NULL, int nThreads = GetDefaultThreads());
	~CComAutoThreadModule();
	HRESULT CreateInstance(void* pfnCreateInstance, REFIID riid, void** ppvObj);
	LONG Lock();
	LONG Unlock();
	DWORD dwThreadID;
	int m_nThreads;
	CComApartment* m_pApartments;
	ThreadAllocator m_Allocator;
	static int GetDefaultThreads()
	{
		SYSTEM_INFO si;
		GetSystemInfo(&si);
		return si.dwNumberOfProcessors * 4;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CComBSTR

class CComBSTR
{
public:
	BSTR m_str;
	CComBSTR()
	{
		m_str = NULL;
	}
	/*explicit*/ CComBSTR(int nSize)
	{
		m_str = ::SysAllocStringLen(NULL, nSize);
	}
	/*explicit*/ CComBSTR(int nSize, LPCOLESTR sz)
	{
		m_str = ::SysAllocStringLen(sz, nSize);
	}
	/*explicit*/ CComBSTR(LPCOLESTR pSrc)
	{
		m_str = ::SysAllocString(pSrc);
	}
	/*explicit*/ CComBSTR(const CComBSTR& src)
	{
		m_str = src.Copy();
	}
	/*explicit*/ CComBSTR(REFGUID src)
	{
		LPOLESTR szGuid;
		StringFromCLSID(src, &szGuid);
		m_str = ::SysAllocString(szGuid);
		CoTaskMemFree(szGuid);
	}
	CComBSTR& operator=(const CComBSTR& src)
	{
		if (m_str != src.m_str)
		{
			if (m_str)
				::SysFreeString(m_str);
			m_str = src.Copy();
		}
		return *this;
	}

	CComBSTR& operator=(LPCOLESTR pSrc)
	{
		::SysFreeString(m_str);
		m_str = ::SysAllocString(pSrc);
		return *this;
	}

	~CComBSTR()
	{
		::SysFreeString(m_str);
	}
	unsigned int Length() const
	{
		return (m_str == NULL)? 0 : SysStringLen(m_str);
	}
	operator BSTR() const
	{
		return m_str;
	}
	BSTR* operator&()
	{
		return &m_str;
	}
	BSTR Copy() const
	{
		return ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
	}
	HRESULT CopyTo(BSTR* pbstr)
	{
		ATLASSERT(pbstr != NULL);
		if (pbstr == NULL)
			return E_POINTER;
		*pbstr = ::SysAllocStringLen(m_str, ::SysStringLen(m_str));
		if (*pbstr == NULL)
			return E_OUTOFMEMORY;
		return S_OK;
	}
	void Attach(BSTR src)
	{
		ATLASSERT(m_str == NULL);
		m_str = src;
	}
	BSTR Detach()
	{
		BSTR s = m_str;
		m_str = NULL;
		return s;
	}
	void Empty()
	{
		::SysFreeString(m_str);
		m_str = NULL;
	}
	bool operator!() const
	{
		return (m_str == NULL);
	}
	HRESULT Append(const CComBSTR& bstrSrc)
	{
		return Append(bstrSrc.m_str, SysStringLen(bstrSrc.m_str));
	}
	HRESULT Append(LPCOLESTR lpsz)
	{
		return Append(lpsz, ocslen(lpsz));
	}
	// a BSTR is just a LPCOLESTR so we need a special version to signify
	// that we are appending a BSTR
	HRESULT AppendBSTR(BSTR p)
	{
		return Append(p, SysStringLen(p));
	}
	HRESULT Append(LPCOLESTR lpsz, int nLen)
	{
		int n1 = Length();
		BSTR b;
		b = ::SysAllocStringLen(NULL, n1+nLen);
		if (b == NULL)
			return E_OUTOFMEMORY;
		memcpy(b, m_str, n1*sizeof(OLECHAR));
		memcpy(b+n1, lpsz, nLen*sizeof(OLECHAR));
		b[n1+nLen] = NULL;
		SysFreeString(m_str);
		m_str = b;
		return S_OK;
	}
	HRESULT ToLower()
	{
		USES_CONVERSION;
		if (m_str != NULL)
		{
			LPTSTR psz = CharLower(OLE2T(m_str));
			if (psz == NULL)
				return E_OUTOFMEMORY;
			BSTR b = T2BSTR(psz);
			if (psz == NULL)
				return E_OUTOFMEMORY;
			SysFreeString(m_str);
			m_str = b;
		}
		return S_OK;
	}
	HRESULT ToUpper()
	{
		USES_CONVERSION;
		if (m_str != NULL)
		{
			LPTSTR psz = CharUpper(OLE2T(m_str));
			if (psz == NULL)
				return E_OUTOFMEMORY;
			BSTR b = T2BSTR(psz);
			if (psz == NULL)
				return E_OUTOFMEMORY;
			SysFreeString(m_str);
			m_str = b;
		}
		return S_OK;
	}
	bool LoadString(HINSTANCE hInst, UINT nID)
	{
		USES_CONVERSION;
		TCHAR sz[512];
		UINT nLen = ::LoadString(hInst, nID, sz, 512);
		ATLASSERT(nLen < 511);
		SysFreeString(m_str);
		m_str = (nLen != 0) ? SysAllocString(T2OLE(sz)) : NULL;
		return (nLen != 0);
	}
	bool LoadString(UINT nID)
	{
		return LoadString(_pModule->m_hInstResource, nID);
	}

	CComBSTR& operator+=(const CComBSTR& bstrSrc)
	{
		AppendBSTR(bstrSrc.m_str);
		return *this;
	}
	bool operator<(BSTR bstrSrc) const
	{
		if (bstrSrc == NULL && m_str == NULL)
			return false;
		if (bstrSrc != NULL && m_str != NULL)
			return wcscmp(m_str, bstrSrc) < 0;
		return m_str == NULL;
	}
	bool operator==(BSTR bstrSrc) const
	{
		if (bstrSrc == NULL && m_str == NULL)
			return true;
		if (bstrSrc != NULL && m_str != NULL)
			return wcscmp(m_str, bstrSrc) == 0;
		return false; 
	}
	bool operator<(LPCSTR pszSrc) const
	{
		if (pszSrc == NULL && m_str == NULL)
			return false;
		USES_CONVERSION;
		if (pszSrc != NULL && m_str != NULL)
			return wcscmp(m_str, A2W(pszSrc)) < 0;
		return m_str == NULL;
	}
	bool operator==(LPCSTR pszSrc) const
	{
		if (pszSrc == NULL && m_str == NULL)
			return true;
		USES_CONVERSION;
		if (pszSrc != NULL && m_str != NULL)
			return wcscmp(m_str, A2W(pszSrc)) == 0;
		return false; 
	}
#ifndef OLE2ANSI
	CComBSTR(LPCSTR pSrc)
	{
		m_str = A2WBSTR(pSrc);
	}

	CComBSTR(int nSize, LPCSTR sz)
	{
		m_str = A2WBSTR(sz, nSize);
	}

	void Append(LPCSTR lpsz)
	{
		USES_CONVERSION;
		LPCOLESTR lpo = A2COLE(lpsz);
		Append(lpo, ocslen(lpo));
	}

	CComBSTR& operator=(LPCSTR pSrc)
	{
		::SysFreeString(m_str);
		m_str = A2WBSTR(pSrc);
		return *this;
	}
#endif
	HRESULT WriteToStream(IStream* pStream)
	{
		ATLASSERT(pStream != NULL);
		ULONG cb;
		ULONG cbStrLen = m_str ? SysStringByteLen(m_str)+sizeof(OLECHAR) : 0;
		HRESULT hr = pStream->Write((void*) &cbStrLen, sizeof(cbStrLen), &cb);
		if (FAILED(hr))
			return hr;
		return cbStrLen ? pStream->Write((void*) m_str, cbStrLen, &cb) : S_OK;
	}
	HRESULT ReadFromStream(IStream* pStream)
	{
		ATLASSERT(pStream != NULL);
		ATLASSERT(m_str == NULL); // should be empty
		ULONG cbStrLen = 0;
		HRESULT hr = pStream->Read((void*) &cbStrLen, sizeof(cbStrLen), NULL);
		if ((hr == S_OK) && (cbStrLen != 0))
		{
			//subtract size for terminating NULL which we wrote out
			//since SysAllocStringByteLen overallocates for the NULL
			m_str = SysAllocStringByteLen(NULL, cbStrLen-sizeof(OLECHAR));
			if (m_str == NULL)
				hr = E_OUTOFMEMORY;
			else
				hr = pStream->Read((void*) m_str, cbStrLen, NULL);
		}
		if (hr == S_FALSE)
			hr = E_FAIL;
		return hr;
	}
};

/////////////////////////////////////////////////////////////////////////////
// CComVariant

class CComVariant : public tagVARIANT
{
// Constructors
public:
	CComVariant()
	{
		vt = VT_EMPTY;
	}
	~CComVariant()
	{
		Clear();
	}

	CComVariant(const VARIANT& varSrc)
	{
		vt = VT_EMPTY;
		InternalCopy(&varSrc);
	}

	CComVariant(const CComVariant& varSrc)
	{
		vt = VT_EMPTY;
		InternalCopy(&varSrc);
	}

	CComVariant(BSTR bstrSrc)
	{
		vt = VT_EMPTY;
		*this = bstrSrc;
	}
	CComVariant(LPCOLESTR lpszSrc)
	{
		vt = VT_EMPTY;
		*this = lpszSrc;
	}

#ifndef OLE2ANSI
	CComVariant(LPCSTR lpszSrc)
	{
		vt = VT_EMPTY;
		*this = lpszSrc;
	}
#endif

	CComVariant(bool bSrc)
	{
		vt = VT_BOOL;
#pragma warning(disable: 4310) // cast truncates constant value
		boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
#pragma warning(default: 4310) // cast truncates constant value
	}

	CComVariant(int nSrc)
	{
		vt = VT_I4;
		lVal = nSrc;
	}
	CComVariant(BYTE nSrc)
	{
		vt = VT_UI1;
		bVal = nSrc;
	}
	CComVariant(short nSrc)
	{
		vt = VT_I2;
		iVal = nSrc;
	}
	CComVariant(long nSrc, VARTYPE vtSrc = VT_I4)
	{
		ATLASSERT(vtSrc == VT_I4 || vtSrc == VT_ERROR);
		vt = vtSrc;
		lVal = nSrc;
	}
	CComVariant(float fltSrc)
	{
		vt = VT_R4;
		fltVal = fltSrc;
	}
	CComVariant(double dblSrc)
	{
		vt = VT_R8;
		dblVal = dblSrc;
	}
	CComVariant(CY cySrc)
	{
		vt = VT_CY;
		cyVal.Hi = cySrc.Hi;
		cyVal.Lo = cySrc.Lo;
	}
	CComVariant(IDispatch* pSrc)
	{
		vt = VT_DISPATCH;
		pdispVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (pdispVal != NULL)
			pdispVal->AddRef();
	}
	CComVariant(IUnknown* pSrc)
	{
		vt = VT_UNKNOWN;
		punkVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (punkVal != NULL)
			punkVal->AddRef();
	}

// Assignment Operators
public:
	CComVariant& operator=(const CComVariant& varSrc)
	{
		InternalCopy(&varSrc);
		return *this;
	}
	CComVariant& operator=(const VARIANT& varSrc)
	{
		InternalCopy(&varSrc);
		return *this;
	}

	CComVariant& operator=(BSTR bstrSrc)
	{
		InternalClear();
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(bstrSrc);
		if (bstrVal == NULL && bstrSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
		}
		return *this;
	}

	CComVariant& operator=(LPCOLESTR lpszSrc)
	{
		InternalClear();
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(lpszSrc);

		if (bstrVal == NULL && lpszSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
		}
		return *this;
	}

	#ifndef OLE2ANSI
	CComVariant& operator=(LPCSTR lpszSrc)
	{
		USES_CONVERSION;
		InternalClear();
		vt = VT_BSTR;
		bstrVal = ::SysAllocString(A2COLE(lpszSrc));

		if (bstrVal == NULL && lpszSrc != NULL)
		{
			vt = VT_ERROR;
			scode = E_OUTOFMEMORY;
		}
		return *this;
	}
	#endif

	CComVariant& operator=(bool bSrc)
	{
		if (vt != VT_BOOL)
		{
			InternalClear();
			vt = VT_BOOL;
		}
	#pragma warning(disable: 4310) // cast truncates constant value
		boolVal = bSrc ? VARIANT_TRUE : VARIANT_FALSE;
	#pragma warning(default: 4310) // cast truncates constant value
		return *this;
	}

	CComVariant& operator=(int nSrc)
	{
		if (vt != VT_I4)
		{
			InternalClear();
			vt = VT_I4;
		}
		lVal = nSrc;

		return *this;
	}

	CComVariant& operator=(BYTE nSrc)
	{
		if (vt != VT_UI1)
		{
			InternalClear();
			vt = VT_UI1;
		}
		bVal = nSrc;
		return *this;
	}

	CComVariant& operator=(short nSrc)
	{
		if (vt != VT_I2)
		{
			InternalClear();
			vt = VT_I2;
		}
		iVal = nSrc;
		return *this;
	}

	CComVariant& operator=(long nSrc)
	{
		if (vt != VT_I4)
		{
			InternalClear();
			vt = VT_I4;
		}
		lVal = nSrc;
		return *this;
	}

	CComVariant& operator=(float fltSrc)
	{
		if (vt != VT_R4)
		{
			InternalClear();
			vt = VT_R4;
		}
		fltVal = fltSrc;
		return *this;
	}

	CComVariant& operator=(double dblSrc)
	{
		if (vt != VT_R8)
		{
			InternalClear();
			vt = VT_R8;
		}
		dblVal = dblSrc;
		return *this;
	}

	CComVariant& operator=(CY cySrc)
	{
		if (vt != VT_CY)
		{
			InternalClear();
			vt = VT_CY;
		}
		cyVal.Hi = cySrc.Hi;
		cyVal.Lo = cySrc.Lo;
		return *this;
	}

	CComVariant& operator=(IDispatch* pSrc)
	{
		InternalClear();
		vt = VT_DISPATCH;
		pdispVal = pSrc;
		// Need to AddRef as VariantClear will Release
		if (pdispVal != NULL)
			pdispVal->AddRef();
		return *this;
	}

	CComVariant& operator=(IUnknown* pSrc)
	{
		InternalClear();
		vt = VT_UNKNOWN;
		punkVal = pSrc;

		// Need to AddRef as VariantClear will Release
		if (punkVal != NULL)
			punkVal->AddRef();
		return *this;
	}


// Comparison Operators
public:
	bool operator==(const VARIANT& varSrc) const
	{
		if (this == &varSrc)
			return true;

		// Variants not equal if types don't match
		if (vt != varSrc.vt)
			return false;

		// Check type specific values
		switch (vt)
		{
			case VT_EMPTY:
			case VT_NULL:
				return true;

			case VT_BOOL:
				return boolVal == varSrc.boolVal;

			case VT_UI1:
				return bVal == varSrc.bVal;

			case VT_I2:
				return iVal == varSrc.iVal;

			case VT_I4:
				return lVal == varSrc.lVal;

			case VT_R4:
				return fltVal == varSrc.fltVal;

			case VT_R8:
				return dblVal == varSrc.dblVal;

			case VT_BSTR:
				return (::SysStringByteLen(bstrVal) == ::SysStringByteLen(varSrc.bstrVal)) &&
						(::memcmp(bstrVal, varSrc.bstrVal, ::SysStringByteLen(bstrVal)) == 0);

			case VT_ERROR:
				return scode == varSrc.scode;

			case VT_DISPATCH:
				return pdispVal == varSrc.pdispVal;

			case VT_UNKNOWN:
				return punkVal == varSrc.punkVal;

			default:
				ATLASSERT(false);
				// fall through
		}

		return false;
	}
	bool operator!=(const VARIANT& varSrc) const {return !operator==(varSrc);}
WCE_DEL bool operator<(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT)==VARCMP_LT;}
WCE_DEL bool operator>(const VARIANT& varSrc) const {return VarCmp((VARIANT*)this, (VARIANT*)&varSrc, LOCALE_USER_DEFAULT)==VARCMP_GT;}

// Operations
public:
	HRESULT Clear() { return ::VariantClear(this); }
	HRESULT Copy(const VARIANT* pSrc) { return ::VariantCopy(this, const_cast<VARIANT*>(pSrc)); }
	HRESULT Attach(VARIANT* pSrc)
	{
		// Clear out the variant
		HRESULT hr = Clear();
		if (!FAILED(hr))
		{
			// Copy the contents and give control to CComVariant
			memcpy(this, pSrc, sizeof(VARIANT));
			pSrc->vt = VT_EMPTY;
			hr = S_OK;
		}
		return hr;
	}

	HRESULT Detach(VARIANT* pDest)
	{
		// Clear out the variant
		HRESULT hr = ::VariantClear(pDest);
		if (!FAILED(hr))
		{
			// Copy the contents and remove control from CComVariant
			memcpy(pDest, this, sizeof(VARIANT));
			vt = VT_EMPTY;
			hr = S_OK;
		}
		return hr;
	}

	HRESULT ChangeType(VARTYPE vtNew, const VARIANT* pSrc = NULL)
	{
		VARIANT* pVar = const_cast<VARIANT*>(pSrc);
		// Convert in place if pSrc is NULL
		if (pVar == NULL)
			pVar = this;
		// Do nothing if doing in place convert and vts not different
		return ::VariantChangeType(this, pVar, 0, vtNew);
	}

	HRESULT WriteToStream(IStream* pStream);
	HRESULT ReadFromStream(IStream* pStream);

// Implementation
public:
	HRESULT InternalClear()
	{
		HRESULT hr = Clear();
		ATLASSERT(SUCCEEDED(hr));
		if (FAILED(hr))
		{
			vt = VT_ERROR;
			scode = hr;
		}
		return hr;
	}

	void InternalCopy(const VARIANT* pSrc)
	{
		HRESULT hr = Copy(pSrc);
		if (FAILED(hr))
		{
			vt = VT_ERROR;
			scode = hr;
		}
	}
};

inline HRESULT CComVariant::WriteToStream(IStream* pStream)
{
	HRESULT hr = pStream->Write(&vt, sizeof(VARTYPE), NULL);
	if (FAILED(hr))
		return hr;

	int cbWrite = 0;
	switch (vt)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
		{
			CComPtr<IPersistStream> spStream;
			if (punkVal != NULL)
			{
				hr = punkVal->QueryInterface(IID_IPersistStream, (void**)&spStream);
				if (FAILED(hr))
					return hr;
			}
			if (spStream != NULL)
				return WCE_FCTN(OleSaveToStream)(spStream, pStream);
			else
				return WriteClassStm(pStream, CLSID_NULL);
		}
	case VT_UI1:
	case VT_I1:
		cbWrite = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbWrite = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbWrite = sizeof(long);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbWrite = sizeof(double);
		break;
	default:
		break;
	}
	if (cbWrite != 0)
		return pStream->Write((void*) &bVal, cbWrite, NULL);

	CComBSTR bstrWrite;
	CComVariant varBSTR;
	if (vt != VT_BSTR)
	{
		hr = VariantChangeType(&varBSTR, this, VARIANT_NOVALUEPROP, VT_BSTR);
		if (FAILED(hr))
			return hr;
		bstrWrite = varBSTR.bstrVal;
	}
	else
		bstrWrite = bstrVal;

	return bstrWrite.WriteToStream(pStream);
}

inline HRESULT CComVariant::ReadFromStream(IStream* pStream)
{
	ATLASSERT(pStream != NULL);
	HRESULT hr;
	hr = VariantClear(this);
	if (FAILED(hr))
		return hr;
	VARTYPE vtRead;
	hr = pStream->Read(&vtRead, sizeof(VARTYPE), NULL);
	if (hr == S_FALSE)
		hr = E_FAIL;
	if (FAILED(hr))
		return hr;

	vt = vtRead;
	int cbRead = 0;
	switch (vtRead)
	{
	case VT_UNKNOWN:
	case VT_DISPATCH:
		{
			punkVal = NULL;
			hr = WCE_FCTN(OleLoadFromStream)(pStream, (vtRead == VT_UNKNOWN) ? IID_IUnknown : IID_IDispatch, (void**)&punkVal);
			if (hr == REGDB_E_CLASSNOTREG)
				hr = S_OK;
			return S_OK;
		}
	case VT_UI1:
	case VT_I1:
		cbRead = sizeof(BYTE);
		break;
	case VT_I2:
	case VT_UI2:
	case VT_BOOL:
		cbRead = sizeof(short);
		break;
	case VT_I4:
	case VT_UI4:
	case VT_R4:
	case VT_INT:
	case VT_UINT:
	case VT_ERROR:
		cbRead = sizeof(long);
		break;
	case VT_R8:
	case VT_CY:
	case VT_DATE:
		cbRead = sizeof(double);
		break;
	default:
		break;
	}
	if (cbRead != 0)
	{
		hr = pStream->Read((void*) &bVal, cbRead, NULL);
		if (hr == S_FALSE)
			hr = E_FAIL;
		return hr;
	}
	CComBSTR bstrRead;

	hr = bstrRead.ReadFromStream(pStream);
	if (FAILED(hr))
		return hr;
	vt = VT_BSTR;
	bstrVal = bstrRead.Detach();
	if (vtRead != VT_BSTR)
		hr = ChangeType(vtRead);
	return hr;
}

/////////////////////////////////////////////////////////////////////////////
// CRegKey

class CRegKey
{
public:
	CRegKey();
	~CRegKey();

// Attributes
public:
	operator HKEY() const;
	HKEY m_hKey;

// Operations
public:
	LONG SetValue(DWORD dwValue, LPCTSTR lpszValueName);
	LONG QueryValue(DWORD& dwValue, LPCTSTR lpszValueName);
	LONG QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount);
	LONG SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

	LONG SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);
	static LONG WINAPI SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName,
		LPCTSTR lpszValue, LPCTSTR lpszValueName = NULL);

	LONG Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
		LPTSTR lpszClass = REG_NONE, DWORD dwOptions = REG_OPTION_NON_VOLATILE,
		REGSAM samDesired = KEY_ALL_ACCESS,
		LPSECURITY_ATTRIBUTES lpSecAttr = NULL,
		LPDWORD lpdwDisposition = NULL);
	LONG Open(HKEY hKeyParent, LPCTSTR lpszKeyName,
		REGSAM samDesired = KEY_ALL_ACCESS);
	LONG Close();
	HKEY Detach();
	void Attach(HKEY hKey);
	LONG DeleteSubKey(LPCTSTR lpszSubKey);
	LONG RecurseDeleteKey(LPCTSTR lpszKey);
	LONG DeleteValue(LPCTSTR lpszValue);
};

inline CRegKey::CRegKey()
{m_hKey = NULL;}

inline CRegKey::~CRegKey()
{Close();}

inline CRegKey::operator HKEY() const
{return m_hKey;}

inline HKEY CRegKey::Detach()
{
	HKEY hKey = m_hKey;
	m_hKey = NULL;
	return hKey;
}

inline void CRegKey::Attach(HKEY hKey)
{
	ATLASSERT(m_hKey == NULL);
	m_hKey = hKey;
}

inline LONG CRegKey::DeleteSubKey(LPCTSTR lpszSubKey)
{
	ATLASSERT(m_hKey != NULL);
	return RegDeleteKey(m_hKey, lpszSubKey);
}

inline LONG CRegKey::DeleteValue(LPCTSTR lpszValue)
{
	ATLASSERT(m_hKey != NULL);
	return RegDeleteValue(m_hKey, (LPTSTR)lpszValue);
}

inline LONG CRegKey::Close()
{
	LONG lRes = ERROR_SUCCESS;
	if (m_hKey != NULL)
	{
		lRes = RegCloseKey(m_hKey);
		m_hKey = NULL;
	}
	return lRes;
}

inline LONG CRegKey::Create(HKEY hKeyParent, LPCTSTR lpszKeyName,
	LPTSTR lpszClass, DWORD dwOptions, REGSAM samDesired,
	LPSECURITY_ATTRIBUTES lpSecAttr, LPDWORD lpdwDisposition)
{
	ATLASSERT(hKeyParent != NULL);
	DWORD dw;
	HKEY hKey = NULL;
	LONG lRes = RegCreateKeyEx(hKeyParent, lpszKeyName, 0,
		lpszClass, dwOptions, samDesired, lpSecAttr, &hKey, &dw);
	if (lpdwDisposition != NULL)
		*lpdwDisposition = dw;
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		m_hKey = hKey;
	}
	return lRes;
}

inline LONG CRegKey::Open(HKEY hKeyParent, LPCTSTR lpszKeyName, REGSAM samDesired)
{
	ATLASSERT(hKeyParent != NULL);
	HKEY hKey = NULL;
	LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);
	if (lRes == ERROR_SUCCESS)
	{
		lRes = Close();
		ATLASSERT(lRes == ERROR_SUCCESS);
		m_hKey = hKey;
	}
	return lRes;
}

inline LONG CRegKey::QueryValue(DWORD& dwValue, LPCTSTR lpszValueName)
{
	DWORD dwType = NULL;
	DWORD dwCount = sizeof(DWORD);
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)&dwValue, &dwCount);
	ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_DWORD));
	ATLASSERT((lRes!=ERROR_SUCCESS) || (dwCount == sizeof(DWORD)));
	return lRes;
}

inline LONG CRegKey::QueryValue(LPTSTR szValue, LPCTSTR lpszValueName, DWORD* pdwCount)
{
	ATLASSERT(pdwCount != NULL);
	DWORD dwType = NULL;
	LONG lRes = RegQueryValueEx(m_hKey, (LPTSTR)lpszValueName, NULL, &dwType,
		(LPBYTE)szValue, pdwCount);
	ATLASSERT((lRes!=ERROR_SUCCESS) || (dwType == REG_SZ) ||
			 (dwType == REG_MULTI_SZ) || (dwType == REG_EXPAND_SZ));
	return lRes;
}

inline LONG WINAPI CRegKey::SetValue(HKEY hKeyParent, LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	ATLASSERT(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(hKeyParent, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

inline LONG CRegKey::SetKeyValue(LPCTSTR lpszKeyName, LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	ATLASSERT(lpszValue != NULL);
	CRegKey key;
	LONG lRes = key.Create(m_hKey, lpszKeyName);
	if (lRes == ERROR_SUCCESS)
		lRes = key.SetValue(lpszValue, lpszValueName);
	return lRes;
}

inline LONG CRegKey::SetValue(DWORD dwValue, LPCTSTR lpszValueName)
{
	ATLASSERT(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_DWORD,
		(BYTE * const)&dwValue, sizeof(DWORD));
}

inline LONG CRegKey::SetValue(LPCTSTR lpszValue, LPCTSTR lpszValueName)
{
	ATLASSERT(lpszValue != NULL);
	ATLASSERT(m_hKey != NULL);
	return RegSetValueEx(m_hKey, lpszValueName, NULL, REG_SZ,
		(BYTE * const)lpszValue, (lstrlen(lpszValue)+1)*sizeof(TCHAR));
}

inline LONG CRegKey::RecurseDeleteKey(LPCTSTR lpszKey)
{
	CRegKey key;
	LONG lRes = key.Open(m_hKey, lpszKey, KEY_READ | KEY_WRITE);
	if (lRes != ERROR_SUCCESS)
		return lRes;
	FILETIME time;
	DWORD dwSize = 256;
	TCHAR szBuffer[256];
	while (RegEnumKeyEx(key.m_hKey, 0, szBuffer, &dwSize, NULL, NULL, NULL,
		&time)==ERROR_SUCCESS)
	{
		lRes = key.RecurseDeleteKey(szBuffer);
		if (lRes != ERROR_SUCCESS)
			return lRes;
		dwSize = 256;
	}
	key.Close();
	return DeleteSubKey(lpszKey);
}

inline HRESULT CComModule::RegisterProgID(LPCTSTR lpszCLSID, LPCTSTR lpszProgID, LPCTSTR lpszUserDesc)
{
	CRegKey keyProgID;
	LONG lRes = keyProgID.Create(HKEY_CLASSES_ROOT, lpszProgID, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ);
	if (lRes == ERROR_SUCCESS)
	{
		keyProgID.SetValue(lpszUserDesc);
		keyProgID.SetKeyValue(_T("CLSID"), lpszCLSID);
		return S_OK;
	}
	return HRESULT_FROM_WIN32(lRes);
}

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>

// Statically linking to Registry Ponent
inline HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(UINT nResID, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	USES_CONVERSION;
	ATL::CRegObject ro;
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(_pModule->GetModuleInstance(), szModule, _MAX_PATH);

   // Convert to short path to work around bug in NT4's CreateProcess
	WCE_DEL TCHAR szModuleShort[_MAX_PATH];
	WCE_DEL GetShortPathName(szModule, szModuleShort, _MAX_PATH);
	LPOLESTR pszModule = T2OLE(WCE_IF(szModule, szModuleShort));

	int nLen = ocslen(pszModule);
	LPOLESTR pszModuleQuote = (LPOLESTR)alloca((nLen*2+1)*sizeof(OLECHAR));
	ReplaceSingleQuote(pszModuleQuote, pszModule);
	ro.AddReplacement(OLESTR("Module"), pszModuleQuote);
	if (NULL != pMapEntries)
	{
		while (NULL != pMapEntries->szKey)
		{
			ATLASSERT(NULL != pMapEntries->szData);
			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
			pMapEntries++;
		}
	}

	LPCOLESTR szType = OLESTR("REGISTRY");
	return (bRegister) ? ro.ResourceRegister(pszModule, nResID, szType) :
			ro.ResourceUnregister(pszModule, nResID, szType);
}

inline HRESULT WINAPI CComModule::UpdateRegistryFromResourceS(LPCTSTR lpszRes, BOOL bRegister,
	struct _ATL_REGMAP_ENTRY* pMapEntries)
{
	USES_CONVERSION;
	ATL::CRegObject ro;
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(_pModule->GetModuleInstance(), szModule, _MAX_PATH);

   // Convert to short path to work around bug in NT4's CreateProcess
	WCE_DEL TCHAR szModuleShort[_MAX_PATH];
	WCE_DEL GetShortPathName(szModule, szModuleShort, _MAX_PATH);
	LPOLESTR pszModule = T2OLE(WCE_IF(szModule,szModuleShort));

	int nLen = ocslen(pszModule);
	LPOLESTR pszModuleQuote = (LPOLESTR)alloca((nLen*2+1)*sizeof(OLECHAR));
	ReplaceSingleQuote(pszModuleQuote, pszModule);
	ro.AddReplacement(OLESTR("Module"), pszModuleQuote);
	if (NULL != pMapEntries)
	{
		while (NULL != pMapEntries->szKey)
		{
			ATLASSERT(NULL != pMapEntries->szData);
			ro.AddReplacement(pMapEntries->szKey, pMapEntries->szData);
			pMapEntries++;
		}
	}

	LPCOLESTR szType = OLESTR("REGISTRY");
	LPCOLESTR pszRes = T2COLE(lpszRes);
	return (bRegister) ? ro.ResourceRegisterSz(pszModule, pszRes, szType) :
			ro.ResourceUnregisterSz(pszModule, pszRes, szType);
}
#endif //_ATL_STATIC_REGISTRY

inline HRESULT WINAPI CComModule::UpdateRegistryClass(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags, BOOL bRegister)
{
	if (bRegister)
	{
		return RegisterClassHelper(clsid, lpszProgID, lpszVerIndProgID, nDescID,
			dwFlags);
	}
	else
		return UnregisterClassHelper(clsid, lpszProgID, lpszVerIndProgID);
}

inline HRESULT WINAPI CComModule::RegisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID, UINT nDescID, DWORD dwFlags)
{
	static const TCHAR szProgID[] = _T("ProgID");
	static const TCHAR szVIProgID[] = _T("VersionIndependentProgID");
	static const TCHAR szLS32[] = _T("LocalServer32");
	static const TCHAR szIPS32[] = _T("InprocServer32");
	static const TCHAR szThreadingModel[] = _T("ThreadingModel");
	static const TCHAR szAUTPRX32[] = _T("AUTPRX32.DLL");
	static const TCHAR szApartment[] = _T("Apartment");
	static const TCHAR szBoth[] = _T("both");
	USES_CONVERSION;
	HRESULT hRes = S_OK;
	TCHAR szDesc[256];
	LoadString(m_hInst, nDescID, szDesc, 256);
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName(m_hInst, szModule, _MAX_PATH);

	LPOLESTR lpOleStr;
	StringFromCLSID(clsid, &lpOleStr);
	LPTSTR lpsz = OLE2T(lpOleStr);

	hRes = RegisterProgID(lpsz, lpszProgID, szDesc);
	if (hRes == S_OK)
		hRes = RegisterProgID(lpsz, lpszVerIndProgID, szDesc);
	LONG lRes = ERROR_SUCCESS;
	if (hRes == S_OK)
	{
		CRegKey key;
		lRes = key.Open(HKEY_CLASSES_ROOT, _T("CLSID"), KEY_READ);
		if (lRes == ERROR_SUCCESS)
		{
			lRes = key.Create(key, lpsz, REG_NONE, REG_OPTION_NON_VOLATILE, KEY_READ);
			if (lRes == ERROR_SUCCESS)
			{
				key.SetValue(szDesc);
				key.SetKeyValue(szProgID, lpszProgID);
				key.SetKeyValue(szVIProgID, lpszVerIndProgID);

#if !defined(_WIN32_WCE)
// WinCE: No out-of-proc servers.
				if ((m_hInst == NULL) || (m_hInst == GetModuleHandle(NULL))) // register as EXE
				{
					// Convert to short path to work around bug in NT4's CreateProcess
					TCHAR szModuleShort[_MAX_PATH];
					GetShortPathName(szModule, szModuleShort, _MAX_PATH);
					key.SetKeyValue(szLS32, szModuleShort);
				}
				else
#endif // _WIN32_WCE
				{
					key.SetKeyValue(szIPS32, (dwFlags & AUTPRXFLAG) ? szAUTPRX32 : szModule);
					LPCTSTR lpszModel = (dwFlags & THREADFLAGS_BOTH) ? szBoth :
						(dwFlags & THREADFLAGS_APARTMENT) ? szApartment : NULL;
					if (lpszModel != NULL)
						key.SetKeyValue(szIPS32, lpszModel, szThreadingModel);
				}
			}
		}
	}
	CoTaskMemFree(lpOleStr);
	if (lRes != ERROR_SUCCESS)
		hRes = HRESULT_FROM_WIN32(lRes);
	return hRes;
}

inline HRESULT WINAPI CComModule::UnregisterClassHelper(const CLSID& clsid, LPCTSTR lpszProgID,
	LPCTSTR lpszVerIndProgID)
{
	USES_CONVERSION;
	CRegKey key;

	key.Attach(HKEY_CLASSES_ROOT);
	if (lpszProgID != NULL && lstrcmpi(lpszProgID, _T("")))
		key.RecurseDeleteKey(lpszProgID);
	if (lpszVerIndProgID != NULL && lstrcmpi(lpszVerIndProgID, _T("")))
		key.RecurseDeleteKey(lpszVerIndProgID);
	LPOLESTR lpOleStr;
	StringFromCLSID(clsid, &lpOleStr);
	LPTSTR lpsz = OLE2T(lpOleStr);
	if (key.Open(key, _T("CLSID"), KEY_READ) == ERROR_SUCCESS)
		key.RecurseDeleteKey(lpsz);
	CoTaskMemFree(lpOleStr);
	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
// Large Block Allocation Helper - CVBufHelper & CVirtualBuffer


template <class T>
class CVBufHelper
{
public:
	virtual T* operator()(T* pCurrent) {return pCurrent;}
};

template <class T>
class CVirtualBuffer
{
protected:
	CVirtualBuffer() {}
	T* m_pBase;
	T* m_pCurrent;
	T* m_pTop;
	int m_nMaxElements;
public:
	CVirtualBuffer(int nMaxElements)
	{
		m_nMaxElements = nMaxElements;
		m_pBase = (T*) VirtualAlloc(NULL, sizeof(T) * nMaxElements,
			MEM_RESERVE, PAGE_READWRITE);
		m_pTop = m_pCurrent = m_pBase;
		// Commit first page - chances are this is all that will be used
		VirtualAlloc(m_pBase, sizeof(T), MEM_COMMIT, PAGE_READWRITE);
	}
	~CVirtualBuffer()
	{
		VirtualFree(m_pBase, 0, MEM_RELEASE);
	}
#if !defined(_WIN32_WCE)
	int Except(LPEXCEPTION_POINTERS lpEP)
	{
		EXCEPTION_RECORD* pExcept = lpEP->ExceptionRecord;
		if (pExcept->ExceptionCode != EXCEPTION_ACCESS_VIOLATION)
			return EXCEPTION_CONTINUE_SEARCH;
		BYTE* pAddress = (LPBYTE) pExcept->ExceptionInformation[1];
		VirtualAlloc(pAddress, ((BYTE*)m_pTop - (BYTE*)m_pBase), MEM_COMMIT, PAGE_READWRITE);
		return EXCEPTION_CONTINUE_EXECUTION;
	}
#endif // _WIN32_WCE
	void Seek(int nElement)
	{
		m_pCurrent = &m_pBase[nElement];
	}
	void SetAt(int nElement, const T& Element)
	{
		__try
		{
			T* p = &m_pBase[nElement]
			*p = Element;
			m_pTop = p > m_pTop ? p : m_pTop;
		}
		__except(Except(GetExceptionInformation()))
		{
		}

	}
	template <class Q>
	void WriteBulk(Q& helper)
	{
		__try
		{
			m_pCurrent = helper(m_pBase);
			m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
		}
		__except(Except(GetExceptionInformation()))
		{
		}
	}
	void Write(const T& Element)
	{
		__try
		{
			*m_pCurrent = Element;
			m_pCurrent++;
			m_pTop = m_pCurrent > m_pTop ? m_pCurrent : m_pTop;
		}
		__except(Except(GetExceptionInformation()))
		{
		}
	}
	T& Read()
	{
		return *m_pCurrent;
	}
	operator BSTR()
	{
		BSTR bstrTemp;
		__try
		{
			bstrTemp = SysAllocStringByteLen((char*) m_pBase,
				(UINT) ((BYTE*)m_pTop - (BYTE*)m_pBase));
		}
		__except(Except(GetExceptionInformation()))
		{
		}
		return bstrTemp;
	}
	const T& operator[](int nElement) const
	{
		return m_pBase[nElement];
	}
	operator T*()
	{
		return m_pBase;
	}
};

typedef CVirtualBuffer<BYTE> CVirtualBytes;


inline HRESULT WINAPI AtlDumpIID(REFIID iid, LPCTSTR pszClassName, HRESULT hr)
{
	if (atlTraceQI & ATL_TRACE_CATEGORY)
	{
		USES_CONVERSION;
		CRegKey key;
		TCHAR szName[100];
		DWORD dwType,dw = sizeof(szName);

		LPOLESTR pszGUID = NULL;
		StringFromCLSID(iid, &pszGUID);
		OutputDebugString(pszClassName);
		OutputDebugString(_T(" - "));

		// Attempt to find it in the interfaces section
		key.Open(HKEY_CLASSES_ROOT, _T("Interface"), KEY_READ);
		if (key.Open(key, OLE2T(pszGUID), KEY_READ) == S_OK)
		{
			*szName = 0;
			RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
			OutputDebugString(szName);
			goto cleanup;
		}
		// Attempt to find it in the clsid section
		key.Open(HKEY_CLASSES_ROOT, _T("CLSID"), KEY_READ);
		if (key.Open(key, OLE2T(pszGUID), KEY_READ) == S_OK)
		{
			*szName = 0;
			RegQueryValueEx(key.m_hKey, (LPTSTR)NULL, NULL, &dwType, (LPBYTE)szName, &dw);
			OutputDebugString(_T("(CLSID\?\?\?) "));
			OutputDebugString(szName);
			goto cleanup;
		}
		OutputDebugString(OLE2T(pszGUID));
	cleanup:
		if (hr != S_OK)
			OutputDebugString(_T(" - failed"));
		OutputDebugString(_T("\n"));
		CoTaskMemFree(pszGUID);
	}
	return hr;
}

#pragma pack(pop)

// WM_FORWARDMSG - used to forward a message to another window for processing
// WPARAM - DWORD dwUserData - defined by user
// LPARAM - LPMSG pMsg - a pointer to the MSG structure
// return value - 0 if the message was not processed, nonzero if it was
#define WM_FORWARDMSG		0x037F

}; //namespace ATL
using namespace ATL;

//only suck in definition if static linking
#ifndef _ATL_DLL_IMPL
#ifndef _ATL_DLL
#define _ATLBASE_IMPL
#endif
#endif

#endif // __ATLBASE_H__

//All exports go here
#ifdef _ATLBASE_IMPL

#ifndef _ATL_DLL_IMPL
namespace ATL
{
#endif

/////////////////////////////////////////////////////////////////////////////
// statics

static UINT WINAPI AtlGetDirLen(LPCOLESTR lpszPathName)
{
	ATLASSERT(lpszPathName != NULL);

	// always capture the complete file name including extension (if present)
	LPCOLESTR lpszTemp = lpszPathName;
	for (LPCOLESTR lpsz = lpszPathName; *lpsz != NULL; )
	{
		LPCOLESTR lp = CharNextO(lpsz);
		// remember last directory/drive separator
		if (*lpsz == OLESTR('\\') || *lpsz == OLESTR('/') || *lpsz == OLESTR(':'))
			lpszTemp = lp;
		lpsz = lp;
	}

	return lpszTemp-lpszPathName;
}

/////////////////////////////////////////////////////////////////////////////
// QI support

ATLINLINE ATLAPI AtlInternalQueryInterface(void* pThis,
	const _ATL_INTMAP_ENTRY* pEntries, REFIID iid, void** ppvObject)
{
	ATLASSERT(pThis != NULL);
	// First entry in the com map should be a simple map entry
	ATLASSERT(pEntries->pFunc == _ATL_SIMPLEMAPENTRY);
	if (ppvObject == NULL)
		return E_POINTER;
	*ppvObject = NULL;
	if (InlineIsEqualUnknown(iid)) // use first interface
	{
			IUnknown* pUnk = (IUnknown*)((int)pThis+pEntries->dw);
			pUnk->AddRef();
			*ppvObject = pUnk;
			return S_OK;
	}
	while (pEntries->pFunc != NULL)
	{
		BOOL bBlind = (pEntries->piid == NULL);
		if (bBlind || InlineIsEqualGUID(*(pEntries->piid), iid))
		{
			if (pEntries->pFunc == _ATL_SIMPLEMAPENTRY) //offset
			{
				ATLASSERT(!bBlind);
				IUnknown* pUnk = (IUnknown*)((int)pThis+pEntries->dw);
				pUnk->AddRef();
				*ppvObject = pUnk;
				return S_OK;
			}
			else //actual function call
			{
				HRESULT hRes = pEntries->pFunc(pThis,
					iid, ppvObject, pEntries->dw);
				if (hRes == S_OK || (!bBlind && FAILED(hRes)))
					return hRes;
			}
		}
		pEntries++;
	}
	return E_NOINTERFACE;
}

/////////////////////////////////////////////////////////////////////////////
// Smart Pointer helpers

ATLINLINE ATLAPI_(IUnknown*) AtlComPtrAssign(IUnknown** pp, IUnknown* lp)
{
	if (lp != NULL)
		lp->AddRef();
	if (*pp)
		(*pp)->Release();
	*pp = lp;
	return lp;
}

ATLINLINE ATLAPI_(IUnknown*) AtlComQIPtrAssign(IUnknown** pp, IUnknown* lp, REFIID riid)
{
	IUnknown* pTemp = *pp;
	*pp = NULL;
	if (lp != NULL)
		lp->QueryInterface(riid, (void**)pp);
	if (pTemp)
		pTemp->Release();
	return *pp;
}

#if !defined(_WIN32_WCE)
/////////////////////////////////////////////////////////////////////////////
// Inproc Marshaling helpers

//This API should be called from the same thread that called
//AtlMarshalPtrInProc
ATLINLINE ATLAPI AtlFreeMarshalStream(IStream* pStream)
{
	if (pStream != NULL)
	{
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStream->Seek(l, STREAM_SEEK_SET, NULL);
		CoReleaseMarshalData(pStream);
		pStream->Release();
	}
	return S_OK;
}

ATLINLINE ATLAPI AtlMarshalPtrInProc(IUnknown* pUnk, const IID& iid, IStream** ppStream)
{
	HRESULT hRes = CreateStreamOnHGlobal(NULL, TRUE, ppStream);
	if (SUCCEEDED(hRes))
	{
		hRes = CoMarshalInterface(*ppStream, iid,
			pUnk, MSHCTX_INPROC, NULL, MSHLFLAGS_TABLESTRONG);
		if (FAILED(hRes))
		{
			(*ppStream)->Release();
			*ppStream = NULL;
		}
	}
	return hRes;
}

ATLINLINE ATLAPI AtlUnmarshalPtr(IStream* pStream, const IID& iid, IUnknown** ppUnk)
{
	*ppUnk = NULL;
	HRESULT hRes = E_INVALIDARG;
	if (pStream != NULL)
	{
		LARGE_INTEGER l;
		l.QuadPart = 0;
		pStream->Seek(l, STREAM_SEEK_SET, NULL);
		hRes = CoUnmarshalInterface(pStream, iid, (void**)ppUnk);
	}
	return hRes;
}

ATLINLINE ATLAPI_(BOOL) AtlWaitWithMessageLoop(HANDLE hEvent)
{
	DWORD dwRet;
	MSG msg;

	while(1)
	{
		dwRet = MsgWaitForMultipleObjects(1, &hEvent, FALSE, INFINITE, QS_ALLINPUT);

		if (dwRet == WAIT_OBJECT_0)
			return TRUE;    // The event was signaled

		if (dwRet != WAIT_OBJECT_0 + 1)
			break;          // Something else happened

		// There is one or more window message available. Dispatch them
		while(PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
		{
			TranslateMessage(&msg);
			DispatchMessage(&msg);
			if (WaitForSingleObject(hEvent, 0) == WAIT_OBJECT_0)
				return TRUE; // Event is now signaled.
		}
	}
	return FALSE;
}
#endif // _WIN32_WCE

/////////////////////////////////////////////////////////////////////////////
// Connection Point Helpers

ATLINLINE ATLAPI AtlAdvise(IUnknown* pUnkCP, IUnknown* pUnk, const IID& iid, LPDWORD pdw)
{
	CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
	if (SUCCEEDED(hRes))
		hRes = pCP->Advise(pUnk, pdw);
	return hRes;
}

ATLINLINE ATLAPI AtlUnadvise(IUnknown* pUnkCP, const IID& iid, DWORD dw)
{
	CComPtr<IConnectionPointContainer> pCPC;
	CComPtr<IConnectionPoint> pCP;
	HRESULT hRes = pUnkCP->QueryInterface(IID_IConnectionPointContainer, (void**)&pCPC);
	if (SUCCEEDED(hRes))
		hRes = pCPC->FindConnectionPoint(iid, &pCP);
	if (SUCCEEDED(hRes))
		hRes = pCP->Unadvise(dw);
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// IDispatch Error handling

ATLINLINE ATLAPI AtlSetErrorInfo(const CLSID& clsid, LPCOLESTR lpszDesc, DWORD dwHelpID,
	LPCOLESTR lpszHelpFile, const IID& iid, HRESULT hRes, HINSTANCE hInst)
{
	USES_CONVERSION;
	TCHAR szDesc[1024];
	szDesc[0] = NULL;
	// For a valid HRESULT the id should be in the range [0x0200, 0xffff]
	if (HIWORD(lpszDesc) == 0) //id
	{
		UINT nID = LOWORD((DWORD)lpszDesc);
		ATLASSERT((nID >= 0x0200 && nID <= 0xffff) || hRes != 0);
		if (LoadString(hInst, nID, szDesc, 1024) == 0)
		{
			ATLASSERT(FALSE);
			lstrcpy(szDesc, _T("Unknown Error"));
		}
		lpszDesc = T2OLE(szDesc);
		if (hRes == 0)
			hRes = MAKE_HRESULT(3, FACILITY_ITF, nID);
	}

	CComPtr<ICreateErrorInfo> pICEI;
	if (SUCCEEDED(CreateErrorInfo(&pICEI)))
	{
		CComPtr<IErrorInfo> pErrorInfo;
		pICEI->SetGUID(iid);
		LPOLESTR lpsz;
		WCE_FCTN(ProgIDFromCLSID)(clsid, &lpsz);
		if (lpsz != NULL)
			pICEI->SetSource(lpsz);
		if (dwHelpID != 0 && lpszHelpFile != NULL)
		{
			pICEI->SetHelpContext(dwHelpID);
			pICEI->SetHelpFile(const_cast<LPOLESTR>(lpszHelpFile));
		}
		CoTaskMemFree(lpsz);
		pICEI->SetDescription((LPOLESTR)lpszDesc);
		if (SUCCEEDED(pICEI->QueryInterface(IID_IErrorInfo, (void**)&pErrorInfo)))
			SetErrorInfo(0, pErrorInfo);
	}
	return (hRes == 0) ? DISP_E_EXCEPTION : hRes;
}

/////////////////////////////////////////////////////////////////////////////
// Module

struct _ATL_MODULE20
{
// Attributes
public:
	UINT cbSize;
	HINSTANCE m_hInst;
	HINSTANCE m_hInstResource;
	HINSTANCE m_hInstTypeLib;
	_ATL_OBJMAP_ENTRY* m_pObjMap;
	LONG m_nLockCnt;
	HANDLE m_hHeap;
	CRITICAL_SECTION m_csTypeInfoHolder;
	CRITICAL_SECTION m_csWindowCreate;
	CRITICAL_SECTION m_csObjMap;
};

typedef _ATL_MODULE _ATL_MODULE30;

struct _ATL_OBJMAP_ENTRY20
{
	const CLSID* pclsid;
	HRESULT (WINAPI *pfnUpdateRegistry)(BOOL bRegister);
	_ATL_CREATORFUNC* pfnGetClassObject;
	_ATL_CREATORFUNC* pfnCreateInstance;
	IUnknown* pCF;
	DWORD dwRegister;
	_ATL_DESCRIPTIONFUNC* pfnGetObjectDescription;
};

typedef _ATL_OBJMAP_ENTRY _ATL_OBJMAP_ENTRY30;

inline _ATL_OBJMAP_ENTRY* _NextObjectMapEntry(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* pEntry)
{
	if (pM->cbSize == sizeof(_ATL_MODULE20))
		return (_ATL_OBJMAP_ENTRY*)(((BYTE*)pEntry) + sizeof(_ATL_OBJMAP_ENTRY20));
	return pEntry+1;
}

//Although these functions are big, they are only used once in a module
//so we should make them inline.

ATLINLINE ATLAPI AtlModuleInit(_ATL_MODULE* pM, _ATL_OBJMAP_ENTRY* p, HINSTANCE h)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
#ifdef _ATL_DLL_IMPL
	if ((pM->cbSize != _nAtlModuleVer1Size) && (pM->cbSize != sizeof(_ATL_MODULE)))
		return E_INVALIDARG;
#else
	ATLASSERT(pM->cbSize == sizeof(_ATL_MODULE));
#endif
	pM->m_pObjMap = p;
	pM->m_hInst = pM->m_hInstTypeLib = pM->m_hInstResource = h;
	pM->m_nLockCnt=0L;
	pM->m_hHeap = NULL;
	InitializeCriticalSection(&pM->m_csTypeInfoHolder);
	InitializeCriticalSection(&pM->m_csWindowCreate);
	InitializeCriticalSection(&pM->m_csObjMap);
#ifdef _ATL_DLL_IMPL
	if (pM->cbSize > _nAtlModuleVer1Size)
#endif
	{
		pM->m_pCreateWndList = NULL;
		pM->m_bDestroyHeap = true;
		pM->m_dwHeaps = 0;
		pM->m_nHeap = 0;
		pM->m_phHeaps = NULL;
		pM->m_pTermFuncs = NULL;
		if (pM->m_pObjMap != NULL)
		{
			_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
			while (pEntry->pclsid != NULL)
			{
				pEntry->pfnObjectMain(true); //initialize class resources
				pEntry = _NextObjectMapEntry(pM, pEntry);
			}
		}
	}
	
	return S_OK;
}

#if !defined(_WIN32_WCE)
ATLINLINE ATLAPI AtlModuleRegisterClassObjects(_ATL_MODULE* pM, DWORD dwClsContext, DWORD dwFlags)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	ATLASSERT(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	while (pEntry->pclsid != NULL && hRes == S_OK)
	{
		hRes = pEntry->RegisterClassObject(dwClsContext, dwFlags);
		pEntry = _NextObjectMapEntry(pM, pEntry);
	}
	return hRes;
}

ATLINLINE ATLAPI AtlModuleRevokeClassObjects(_ATL_MODULE* pM)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	ATLASSERT(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	while (pEntry->pclsid != NULL && hRes == S_OK)
	{
		hRes = pEntry->RevokeClassObject();
		pEntry = _NextObjectMapEntry(pM, pEntry);
	}
	return hRes;
}
#endif // _WIN32_WCE

ATLINLINE ATLAPI AtlModuleGetClassObject(_ATL_MODULE* pM, REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	ATLASSERT(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	if (ppv == NULL)
		return E_POINTER;
	*ppv = NULL;
	while (pEntry->pclsid != NULL)
	{
		if ((pEntry->pfnGetClassObject != NULL) && InlineIsEqualGUID(rclsid, *pEntry->pclsid))
		{
			if (pEntry->pCF == NULL)
			{
				EnterCriticalSection(&pM->m_csObjMap);
				if (pEntry->pCF == NULL)
					hRes = pEntry->pfnGetClassObject(pEntry->pfnCreateInstance, IID_IUnknown, (LPVOID*)&pEntry->pCF);
				LeaveCriticalSection(&pM->m_csObjMap);
			}
			if (pEntry->pCF != NULL)
				hRes = pEntry->pCF->QueryInterface(riid, ppv);
			break;
		}
		pEntry = _NextObjectMapEntry(pM, pEntry);
	}
	if (*ppv == NULL && hRes == S_OK)
		hRes = CLASS_E_CLASSNOTAVAILABLE;
	return hRes;
}

ATLINLINE ATLAPI AtlModuleTerm(_ATL_MODULE* pM)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	ATLASSERT(pM->m_hInst != NULL);
	if (pM->m_pObjMap != NULL)
	{
		_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
		while (pEntry->pclsid != NULL)
		{
			if (pEntry->pCF != NULL)
				pEntry->pCF->Release();
			pEntry->pCF = NULL;
#ifdef _ATL_DLL_IMPL
			if (pM->cbSize > _nAtlModuleVer1Size)
#endif
				pEntry->pfnObjectMain(false); //cleanup class resources
			pEntry = _NextObjectMapEntry(pM, pEntry);
		}
	}
	DeleteCriticalSection(&pM->m_csTypeInfoHolder);
	DeleteCriticalSection(&pM->m_csWindowCreate);
	DeleteCriticalSection(&pM->m_csObjMap);

#ifdef _ATL_DLL_IMPL
	if (pM->cbSize > _nAtlModuleVer1Size)
#endif
	{
		_ATL_TERMFUNC_ELEM* pElem = pM->m_pTermFuncs;
		_ATL_TERMFUNC_ELEM* pNext = NULL;
		while (pElem != NULL)
		{
			pElem->pFunc(pElem->dw);
			pNext = pElem->pNext;
			delete pElem;
			pElem = pNext;
		}
		if (pM->m_hHeap != NULL && pM->m_bDestroyHeap)
		{
#ifndef _ATL_NO_MP_HEAP
			if (pM->m_phHeaps != NULL)
			{
				for (DWORD i=0; i<=pM->m_dwHeaps; i++)
					HeapDestroy(pM->m_phHeaps[i]);
			}
#endif
			HeapDestroy(pM->m_hHeap);
		}
	}
	return S_OK;
}

ATLINLINE ATLAPI AtlModuleAddTermFunc(_ATL_MODULE* pM, _ATL_TERMFUNC* pFunc, DWORD dw)
{
	HRESULT hr = S_OK;
	_ATL_TERMFUNC_ELEM* pNew = NULL;
	ATLTRY(pNew = new _ATL_TERMFUNC_ELEM);
	if (pNew == NULL)
		hr = E_OUTOFMEMORY;
	else
	{
		pNew->pFunc = pFunc;
		pNew->dw = dw;
		EnterCriticalSection(&pM->m_csStaticDataInit);
		pNew->pNext = pM->m_pTermFuncs;
		pM->m_pTermFuncs = pNew;
		LeaveCriticalSection(&pM->m_csStaticDataInit);
	}
	return hr;
}

#if !defined(_WIN32_WCE)
ATLINLINE ATLAPI AtlRegisterClassCategoriesHelper( REFCLSID clsid, 
   const struct _ATL_CATMAP_ENTRY* pCatMap, BOOL bRegister )
{
   CComPtr< ICatRegister > pCatRegister;
   HRESULT hResult;
   const struct _ATL_CATMAP_ENTRY* pEntry;
   CATID catid;

   if( pCatMap == NULL )
   {
      return( S_OK );
   }

   hResult = CoCreateInstance( CLSID_StdComponentCategoriesMgr, NULL, 
      CLSCTX_INPROC_SERVER, IID_ICatRegister, (void**)&pCatRegister );
   if( FAILED( hResult ) )
   {
      // Since not all systems have the category manager installed, we'll allow
      // the registration to succeed even though we didn't register our 
      // categories.  If you really want to register categories on a system
      // without the category manager, you can either manually add the 
      // appropriate entries to your registry script (.rgs), or you can 
      // redistribute comcat.dll.
      return( S_OK );
   }

   hResult = S_OK;
   pEntry = pCatMap;
   while( pEntry->iType != _ATL_CATMAP_ENTRY_END )
   {
      catid = *pEntry->pcatid;
      if( bRegister )
      {
         if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
         {
            hResult = pCatRegister->RegisterClassImplCategories( clsid, 1, 
               &catid );
         }
         else
         {
            ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
            hResult = pCatRegister->RegisterClassReqCategories( clsid, 1, 
               &catid );
         }
         if( FAILED( hResult ) )
         {
            return( hResult );
         }
      }
      else
      {
         if( pEntry->iType == _ATL_CATMAP_ENTRY_IMPLEMENTED )
         {
            pCatRegister->UnRegisterClassImplCategories( clsid, 1, &catid );
         }
         else
         {
            ATLASSERT( pEntry->iType == _ATL_CATMAP_ENTRY_REQUIRED );
            pCatRegister->UnRegisterClassReqCategories( clsid, 1, &catid );
         }
      }
      pEntry++;
   }

   return( S_OK );
}
#endif // _WIN32_WCE

ATLINLINE ATLAPI AtlModuleRegisterServer(_ATL_MODULE* pM, BOOL bRegTypeLib, const CLSID* pCLSID)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	ATLASSERT(pM->m_hInst != NULL);
	ATLASSERT(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	HRESULT hRes = S_OK;
	for (;pEntry->pclsid != NULL; pEntry = _NextObjectMapEntry(pM, pEntry))
	{
		if (pCLSID == NULL)
		{
			if (pEntry->pfnGetObjectDescription != NULL &&
				pEntry->pfnGetObjectDescription() != NULL)
					continue;
		}
		else
		{
			if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
				continue;
		}
		hRes = pEntry->pfnUpdateRegistry(TRUE);
		if (FAILED(hRes))
			break;
#if !defined(_WIN32_WCE)
		if (pM->cbSize == sizeof(_ATL_MODULE))
		{
			hRes = AtlRegisterClassCategoriesHelper( *pEntry->pclsid, 
				pEntry->pfnGetCategoryMap(), TRUE );
			if (FAILED(hRes))
				break;
		}
#endif // _WIN32_WCE
	}
	if (SUCCEEDED(hRes) && bRegTypeLib)
		hRes = AtlModuleRegisterTypeLib(pM, 0);
	return hRes;
}

ATLINLINE ATLAPI AtlModuleUnregisterServerEx(_ATL_MODULE* pM, BOOL bUnRegTypeLib, const CLSID* pCLSID)
{
	ATLASSERT(pM != NULL);
	if (pM == NULL)
		return E_INVALIDARG;
	ATLASSERT(pM->m_hInst != NULL);
	ATLASSERT(pM->m_pObjMap != NULL);
	_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
	for (;pEntry->pclsid != NULL; pEntry = _NextObjectMapEntry(pM, pEntry))
	{
		if (pCLSID == NULL)
		{
			if (pEntry->pfnGetObjectDescription != NULL
				&& pEntry->pfnGetObjectDescription() != NULL)
				continue;
		}
		else
		{
			if (!IsEqualGUID(*pCLSID, *pEntry->pclsid))
				continue;
		}
		pEntry->pfnUpdateRegistry(FALSE); //unregister
#if !defined(_WIN32_WCE)
		AtlRegisterClassCategoriesHelper( *pEntry->pclsid, 
			pEntry->pfnGetCategoryMap(), FALSE );
#endif // _WIN32_WCE
	}
	if (bUnRegTypeLib)
		AtlModuleUnRegisterTypeLib(pM, 0);
	return S_OK;
}

ATLINLINE ATLAPI AtlModuleUnregisterServer(_ATL_MODULE* pM, const CLSID* pCLSID)
{
	return AtlModuleUnregisterServerEx(pM, FALSE, pCLSID);
}

ATLINLINE ATLAPI AtlModuleUpdateRegistryFromResourceD(_ATL_MODULE* pM, LPCOLESTR lpszRes,
	BOOL bRegister, struct _ATL_REGMAP_ENTRY* pMapEntries, IRegistrar* pReg)
{
	USES_CONVERSION;
	ATLASSERT(pM != NULL);
	HRESULT hRes = S_OK;
	CComPtr<IRegistrar> p;
	if (pReg != NULL)
		p = pReg;
	else
	{
		hRes = CoCreateInstance(CLSID_Registrar, NULL,
			CLSCTX_INPROC_SERVER, IID_IRegistrar, (void**)&p);
	}
	if (SUCCEEDED(hRes))
	{
		TCHAR szModule[_MAX_PATH];
		GetModuleFileName(pM->m_hInst, szModule, _MAX_PATH);

      // Convert to short path to work around bug in NT4's CreateProcess
      WCE_DEL TCHAR szModuleShort[_MAX_PATH];
      WCE_DEL GetShortPathName(szModule, szModuleShort, _MAX_PATH);
      LPOLESTR pszModule = T2OLE(WCE_IF(szModule,szModuleShort));

		int nLen = ocslen(pszModule);
		LPOLESTR pszModuleQuote = (LPOLESTR)alloca((nLen*2+1)*sizeof(OLECHAR));
		CComModule::ReplaceSingleQuote(pszModuleQuote, pszModule);
		p->AddReplacement(OLESTR("Module"), pszModuleQuote);

		if (NULL != pMapEntries)
		{
			while (NULL != pMapEntries->szKey)
			{
				ATLASSERT(NULL != pMapEntries->szData);
				p->AddReplacement((LPOLESTR)pMapEntries->szKey, (LPOLESTR)pMapEntries->szData);
				pMapEntries++;
			}
		}
		LPCOLESTR szType = OLESTR("REGISTRY");
		if (HIWORD(lpszRes)==0)
		{
			if (bRegister)
				hRes = p->ResourceRegister(pszModule, ((UINT)LOWORD((DWORD)lpszRes)), szType);
			else
				hRes = p->ResourceUnregister(pszModule, ((UINT)LOWORD((DWORD)lpszRes)), szType);
		}
		else
		{
			if (bRegister)
				hRes = p->ResourceRegisterSz(pszModule, lpszRes, szType);
			else
				hRes = p->ResourceUnregisterSz(pszModule, lpszRes, szType);
		}

	}
	return hRes;
}

/////////////////////////////////////////////////////////////////////////////
// TypeLib Support

ATLINLINE ATLAPI AtlModuleLoadTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex, BSTR* pbstrPath, ITypeLib** ppTypeLib)
{
	*pbstrPath = NULL;
	*ppTypeLib = NULL;
	ATLASSERT(pM != NULL);
	USES_CONVERSION;
	ATLASSERT(pM->m_hInstTypeLib != NULL);
	TCHAR szModule[_MAX_PATH+10];
	GetModuleFileName(pM->m_hInstTypeLib, szModule, _MAX_PATH);
	if (lpszIndex != NULL)
		lstrcat(szModule, OLE2CT(lpszIndex));
	LPOLESTR lpszModule = T2OLE(szModule);
	HRESULT hr = LoadTypeLib(lpszModule, ppTypeLib);
	if (!SUCCEEDED(hr))
	{
		// typelib not in module, try <module>.tlb instead
		LPTSTR lpszExt = NULL;
		LPTSTR lpsz;
		for (lpsz = szModule; *lpsz != NULL; lpsz = CharNext(lpsz))
		{
			if (*lpsz == _T('.'))
				lpszExt = lpsz;
		}
		if (lpszExt == NULL)
			lpszExt = lpsz;
		lstrcpy(lpszExt, _T(".tlb"));
		lpszModule = T2OLE(szModule);
		hr = LoadTypeLib(lpszModule, ppTypeLib);
	}
	if (SUCCEEDED(hr))
		*pbstrPath = OLE2BSTR(lpszModule);
	return hr;
}

ATLINLINE ATLAPI AtlModuleUnRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex)
{
	typedef HRESULT (WINAPI *PFNRTL)(REFGUID, WORD, WORD, LCID, SYSKIND);
	CComBSTR bstrPath;
	CComPtr<ITypeLib> pTypeLib;
	HRESULT hr = AtlModuleLoadTypeLib(pM, lpszIndex, &bstrPath, &pTypeLib);
	if (SUCCEEDED(hr))
	{
		TLIBATTR* ptla;
		HRESULT hr = pTypeLib->GetLibAttr(&ptla);
		if (SUCCEEDED(hr))
		{
			HINSTANCE h = LoadLibrary(_T("oleaut32.dll"));
			if (h != NULL)
			{
				PFNRTL pfn = (PFNRTL) GetProcAddress(h, WCE_IF(_T("UnRegisterTypeLib"),"UnRegisterTypeLib"));
				if (pfn != NULL)
					hr = pfn(ptla->guid, ptla->wMajorVerNum, ptla->wMinorVerNum, ptla->lcid, ptla->syskind);
				FreeLibrary(h);
			}
			pTypeLib->ReleaseTLibAttr(ptla);
		}
	}
	return hr;
}

ATLINLINE ATLAPI AtlModuleRegisterTypeLib(_ATL_MODULE* pM, LPCOLESTR lpszIndex)
{
	CComBSTR bstrPath;
	CComPtr<ITypeLib> pTypeLib;
	HRESULT hr = AtlModuleLoadTypeLib(pM, lpszIndex, &bstrPath, &pTypeLib);
	if (SUCCEEDED(hr))
	{
		OLECHAR szDir[_MAX_PATH];
		ocscpy(szDir, bstrPath);
		szDir[AtlGetDirLen(szDir)] = 0;
		hr = ::RegisterTypeLib(pTypeLib, bstrPath, szDir);
	}
	return hr;
}

ATLINLINE ATLAPI_(DWORD) AtlGetVersion(void* /* pReserved */)
{
	return _ATL_VER;
}

ATLINLINE ATLAPI_(void) AtlModuleAddCreateWndData(_ATL_MODULE* pM, _AtlCreateWndData* pData, void* pObject)
{
	pData->m_pThis = pObject;
	pData->m_dwThreadID = ::GetCurrentThreadId();
	::EnterCriticalSection(&pM->m_csWindowCreate);
	pData->m_pNext = pM->m_pCreateWndList;
	pM->m_pCreateWndList = pData;
	::LeaveCriticalSection(&pM->m_csWindowCreate);
}

ATLINLINE ATLAPI_(void*) AtlModuleExtractCreateWndData(_ATL_MODULE* pM)
{
	void* pv = NULL;
	::EnterCriticalSection(&pM->m_csWindowCreate);
	_AtlCreateWndData* pEntry = pM->m_pCreateWndList;
	if(pEntry != NULL)
	{
		DWORD dwThreadID = ::GetCurrentThreadId();
		_AtlCreateWndData* pPrev = NULL;
		while(pEntry != NULL)
		{
			if(pEntry->m_dwThreadID == dwThreadID)
			{
				if(pPrev == NULL)
					pM->m_pCreateWndList = pEntry->m_pNext;
				else
					pPrev->m_pNext = pEntry->m_pNext;
				pv = pEntry->m_pThis;
				break;
			}
			pPrev = pEntry;
			pEntry = pEntry->m_pNext;
		}
	}
	::LeaveCriticalSection(&pM->m_csWindowCreate);
	return pv;
}

#if !defined(_WIN32_WCE)
/////////////////////////////////////////////////////////////////////////////
// General DLL Version Helpers

inline HRESULT AtlGetDllVersion(HINSTANCE hInstDLL, DLLVERSIONINFO* pDllVersionInfo)
{
	ATLASSERT(pDllVersionInfo != NULL);
	if(::IsBadWritePtr(pDllVersionInfo, sizeof(DWORD)))
		return E_INVALIDARG;

	// We must get this function explicitly because some DLLs don't implement it.
	DLLGETVERSIONPROC pfnDllGetVersion = (DLLGETVERSIONPROC)::GetProcAddress(hInstDLL, "DllGetVersion");
	if(pfnDllGetVersion == NULL)
		return E_NOTIMPL;

	return (*pfnDllGetVersion)(pDllVersionInfo);
}

inline HRESULT AtlGetDllVersion(LPCTSTR lpstrDllName, DLLVERSIONINFO* pDllVersionInfo)
{
	HINSTANCE hInstDLL = ::LoadLibrary(lpstrDllName);
	if(hInstDLL == NULL)
		return E_FAIL;
	HRESULT hRet = AtlGetDllVersion(hInstDLL, pDllVersionInfo);
	::FreeLibrary(hInstDLL);
	return hRet;
}

// Common Control Versions:
//   Win95/WinNT 4.0	maj=4 min=00
//   IE 3.x		maj=4 min=70
//   IE 4.0		maj=4 min=71
inline HRESULT AtlGetCommCtrlVersion(LPDWORD pdwMajor, LPDWORD pdwMinor)
{
	ATLASSERT(pdwMajor != NULL && pdwMinor != NULL);
	if(::IsBadWritePtr(pdwMajor, sizeof(DWORD)) || ::IsBadWritePtr(pdwMinor, sizeof(DWORD)))
		return E_INVALIDARG;

	DLLVERSIONINFO dvi;
	::ZeroMemory(&dvi, sizeof(dvi));
	dvi.cbSize = sizeof(dvi);
	HRESULT hRet = AtlGetDllVersion(_T("comctl32.dll"), &dvi);

	if(SUCCEEDED(hRet))
	{
		*pdwMajor = dvi.dwMajorVersion;
		*pdwMinor = dvi.dwMinorVersion;
	}
	else if(hRet == E_NOTIMPL)
	{
		// If DllGetVersion is not there, then the DLL is a version 
		// previous to the one shipped with IE 3.x
		*pdwMajor = 4;
		*pdwMinor = 0;
		hRet = S_OK;
	}

	return hRet;
}

// Shell Versions:
//   Win95/WinNT 4.0					maj=4 min=00
//   IE 3.x, IE 4.0 without Web Integrated Desktop	maj=4 min=00
//   IE 4.0 with Web Integrated Desktop			maj=4 min=71
//   IE 4.01 with Web Integrated Desktop		maj=4 min=72
inline HRESULT AtlGetShellVersion(LPDWORD pdwMajor, LPDWORD pdwMinor)
{
	ATLASSERT(pdwMajor != NULL && pdwMinor != NULL);
	if(::IsBadWritePtr(pdwMajor, sizeof(DWORD)) || ::IsBadWritePtr(pdwMinor, sizeof(DWORD)))
		return E_INVALIDARG;

	DLLVERSIONINFO dvi;
	::ZeroMemory(&dvi, sizeof(dvi));
	dvi.cbSize = sizeof(dvi);
	HRESULT hRet = AtlGetDllVersion(_T("shell32.dll"), &dvi);

	if(SUCCEEDED(hRet))
	{
		*pdwMajor = dvi.dwMajorVersion;
		*pdwMinor = dvi.dwMinorVersion;
	}
	else if(hRet == E_NOTIMPL)
	{
		// If DllGetVersion is not there, then the DLL is a version 
		// previous to the one shipped with IE 4.x
		*pdwMajor = 4;
		*pdwMinor = 0;
		hRet = S_OK;
	}

	return hRet;
}
#endif // _WIN32_WCE

#ifndef _ATL_DLL_IMPL
}; //namespace ATL
#endif

//Prevent pulling in second time 
#undef _ATLBASE_IMPL

#endif // _ATLBASE_IMPL

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\patch\include\comcat.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Thu Sep 11 10:58:53 1997
 */
/* Compiler settings for comcat.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __comcat_h__
#define __comcat_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEnumGUID_FWD_DEFINED__
#define __IEnumGUID_FWD_DEFINED__
typedef interface IEnumGUID IEnumGUID;
#endif 	/* __IEnumGUID_FWD_DEFINED__ */


#ifndef __IEnumCATEGORYINFO_FWD_DEFINED__
#define __IEnumCATEGORYINFO_FWD_DEFINED__
typedef interface IEnumCATEGORYINFO IEnumCATEGORYINFO;
#endif 	/* __IEnumCATEGORYINFO_FWD_DEFINED__ */


#ifndef __ICatRegister_FWD_DEFINED__
#define __ICatRegister_FWD_DEFINED__
typedef interface ICatRegister ICatRegister;
#endif 	/* __ICatRegister_FWD_DEFINED__ */


#ifndef __ICatInformation_FWD_DEFINED__
#define __ICatInformation_FWD_DEFINED__
typedef interface ICatInformation ICatInformation;
#endif 	/* __ICatInformation_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_comcat_0000
 * at Thu Sep 11 10:58:53 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


//=--------------------------------------------------------------------------=
// ComCat.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995 - 1998 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//=--------------------------------------------------------------------------=
// OLE Componet Categories Interfaces.
//=--------------------------------------------------------------------------=
//




EXTERN_C const CLSID CLSID_StdComponentCategoriesMgr;

////////////////////////////////////////////////////////////////////////////
//  Types
typedef GUID CATID;

typedef REFGUID REFCATID;

#define IID_IEnumCLSID              IID_IEnumGUID
#define IEnumCLSID                  IEnumGUID
#define LPENUMCLSID                 LPENUMGUID
#define CATID_NULL                   GUID_NULL
#define IsEqualCATID(rcatid1, rcatid2)       IsEqualGUID(rcatid1, rcatid2)
#define IID_IEnumCATID       IID_IEnumGUID
#define IEnumCATID           IEnumGUID

////////////////////////////////////////////////////////////////////////////
//  Category IDs (link to uuid3.lib)
EXTERN_C const CATID CATID_Insertable;
EXTERN_C const CATID CATID_Control;
EXTERN_C const CATID CATID_Programmable;
EXTERN_C const CATID CATID_IsShortcut;
EXTERN_C const CATID CATID_NeverShowExt;
EXTERN_C const CATID CATID_DocObject;
EXTERN_C const CATID CATID_Printable;
EXTERN_C const CATID CATID_RequiresDataPathHost;
EXTERN_C const CATID CATID_PersistsToMoniker;
EXTERN_C const CATID CATID_PersistsToStorage;
EXTERN_C const CATID CATID_PersistsToStreamInit;
EXTERN_C const CATID CATID_PersistsToStream;
EXTERN_C const CATID CATID_PersistsToMemory;
EXTERN_C const CATID CATID_PersistsToFile;
EXTERN_C const CATID CATID_PersistsToPropertyBag;
EXTERN_C const CATID CATID_InternetAware;

////////////////////////////////////////////////////////////////////////////
//  Interface Definitions
#ifndef _LPENUMGUID_DEFINED
#define _LPENUMGUID_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_comcat_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0000_v0_0_s_ifspec;

#ifndef __IEnumGUID_INTERFACE_DEFINED__
#define __IEnumGUID_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumGUID
 * at Thu Sep 11 10:58:53 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumGUID __RPC_FAR *LPENUMGUID;


EXTERN_C const IID IID_IEnumGUID;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002E000-0000-0000-C000-000000000046")
    IEnumGUID : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumGUIDVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumGUID __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumGUID __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumGUID __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumGUID __RPC_FAR * This,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumGUIDVtbl;

    interface IEnumGUID
    {
        CONST_VTBL struct IEnumGUIDVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumGUID_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumGUID_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumGUID_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumGUID_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumGUID_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumGUID_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumGUID_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumGUID_Next_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ GUID __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumGUID_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Skip_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumGUID_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Reset_Proxy( 
    IEnumGUID __RPC_FAR * This);


void __RPC_STUB IEnumGUID_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumGUID_Clone_Proxy( 
    IEnumGUID __RPC_FAR * This,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumGUID_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumGUID_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_comcat_0006
 * at Thu Sep 11 10:58:53 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPENUMCATEGORYINFO_DEFINED
#define _LPENUMCATEGORYINFO_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_comcat_0006_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0006_v0_0_s_ifspec;

#ifndef __IEnumCATEGORYINFO_INTERFACE_DEFINED__
#define __IEnumCATEGORYINFO_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumCATEGORYINFO
 * at Thu Sep 11 10:58:53 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IEnumCATEGORYINFO __RPC_FAR *LPENUMCATEGORYINFO;

typedef struct  tagCATEGORYINFO
    {
    CATID catid;
    LCID lcid;
    OLECHAR szDescription[ 128 ];
    }	CATEGORYINFO;

typedef struct tagCATEGORYINFO __RPC_FAR *LPCATEGORYINFO;


EXTERN_C const IID IID_IEnumCATEGORYINFO;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002E011-0000-0000-C000-000000000046")
    IEnumCATEGORYINFO : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumCATEGORYINFOVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumCATEGORYINFO __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumCATEGORYINFO __RPC_FAR * This,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum);
        
        END_INTERFACE
    } IEnumCATEGORYINFOVtbl;

    interface IEnumCATEGORYINFO
    {
        CONST_VTBL struct IEnumCATEGORYINFOVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumCATEGORYINFO_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumCATEGORYINFO_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumCATEGORYINFO_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumCATEGORYINFO_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumCATEGORYINFO_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumCATEGORYINFO_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumCATEGORYINFO_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Next_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ CATEGORYINFO __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumCATEGORYINFO_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Skip_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumCATEGORYINFO_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Reset_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This);


void __RPC_STUB IEnumCATEGORYINFO_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumCATEGORYINFO_Clone_Proxy( 
    IEnumCATEGORYINFO __RPC_FAR * This,
    /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumCATEGORYINFO_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumCATEGORYINFO_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_comcat_0007
 * at Thu Sep 11 10:58:53 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPCATREGISTER_DEFINED
#define _LPCATREGISTER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_comcat_0007_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0007_v0_0_s_ifspec;

#ifndef __ICatRegister_INTERFACE_DEFINED__
#define __ICatRegister_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatRegister
 * at Thu Sep 11 10:58:53 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ ICatRegister __RPC_FAR *LPCATREGISTER;


EXTERN_C const IID IID_ICatRegister;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002E012-0000-0000-C000-000000000046")
    ICatRegister : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterCategories( 
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterCategories( 
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterClassImplCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterClassImplCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterClassReqCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnRegisterClassReqCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatRegisterVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatRegister __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatRegister __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterClassImplCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterClassImplCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterClassReqCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnRegisterClassReqCategories )( 
            ICatRegister __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cCategories,
            /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);
        
        END_INTERFACE
    } ICatRegisterVtbl;

    interface ICatRegister
    {
        CONST_VTBL struct ICatRegisterVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatRegister_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatRegister_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatRegister_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatRegister_RegisterCategories(This,cCategories,rgCategoryInfo)	\
    (This)->lpVtbl -> RegisterCategories(This,cCategories,rgCategoryInfo)

#define ICatRegister_UnRegisterCategories(This,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterCategories(This,cCategories,rgcatid)

#define ICatRegister_RegisterClassImplCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> RegisterClassImplCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_UnRegisterClassImplCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterClassImplCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_RegisterClassReqCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> RegisterClassReqCategories(This,rclsid,cCategories,rgcatid)

#define ICatRegister_UnRegisterClassReqCategories(This,rclsid,cCategories,rgcatid)	\
    (This)->lpVtbl -> UnRegisterClassReqCategories(This,rclsid,cCategories,rgcatid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICatRegister_RegisterCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATEGORYINFO __RPC_FAR rgCategoryInfo[  ]);


void __RPC_STUB ICatRegister_RegisterCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_UnRegisterCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_RegisterClassImplCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_RegisterClassImplCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_UnRegisterClassImplCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterClassImplCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_RegisterClassReqCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_RegisterClassReqCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatRegister_UnRegisterClassReqCategories_Proxy( 
    ICatRegister __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cCategories,
    /* [size_is][in] */ CATID __RPC_FAR rgcatid[  ]);


void __RPC_STUB ICatRegister_UnRegisterClassReqCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatRegister_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_comcat_0008
 * at Thu Sep 11 10:58:53 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


#endif
#ifndef _LPCATINFORMATION_DEFINED
#define _LPCATINFORMATION_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_comcat_0008_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0008_v0_0_s_ifspec;

#ifndef __ICatInformation_INTERFACE_DEFINED__
#define __ICatInformation_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ICatInformation
 * at Thu Sep 11 10:58:53 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ ICatInformation __RPC_FAR *LPCATINFORMATION;


EXTERN_C const IID IID_ICatInformation;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0002E013-0000-0000-C000-000000000046")
    ICatInformation : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE EnumCategories( 
            /* [in] */ LCID lcid,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCategoryDesc( 
            /* [in] */ REFCATID rcatid,
            /* [in] */ LCID lcid,
            /* [out] */ LPWSTR __RPC_FAR *pszDesc) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE EnumClassesOfCategories( 
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid) = 0;
        
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE IsClassOfCategories( 
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumImplCategoriesOfClass( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumReqCategoriesOfClass( 
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICatInformationVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICatInformation __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICatInformation __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ LCID lcid,
            /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCategoryDesc )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCATID rcatid,
            /* [in] */ LCID lcid,
            /* [out] */ LPWSTR __RPC_FAR *pszDesc);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumClassesOfCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsClassOfCategories )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [in] */ ULONG cImplemented,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
            /* [in] */ ULONG cRequired,
            /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumImplCategoriesOfClass )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumReqCategoriesOfClass )( 
            ICatInformation __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid,
            /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);
        
        END_INTERFACE
    } ICatInformationVtbl;

    interface ICatInformation
    {
        CONST_VTBL struct ICatInformationVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICatInformation_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICatInformation_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICatInformation_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICatInformation_EnumCategories(This,lcid,ppenumCategoryInfo)	\
    (This)->lpVtbl -> EnumCategories(This,lcid,ppenumCategoryInfo)

#define ICatInformation_GetCategoryDesc(This,rcatid,lcid,pszDesc)	\
    (This)->lpVtbl -> GetCategoryDesc(This,rcatid,lcid,pszDesc)

#define ICatInformation_EnumClassesOfCategories(This,cImplemented,rgcatidImpl,cRequired,rgcatidReq,ppenumClsid)	\
    (This)->lpVtbl -> EnumClassesOfCategories(This,cImplemented,rgcatidImpl,cRequired,rgcatidReq,ppenumClsid)

#define ICatInformation_IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,cRequired,rgcatidReq)	\
    (This)->lpVtbl -> IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,cRequired,rgcatidReq)

#define ICatInformation_EnumImplCategoriesOfClass(This,rclsid,ppenumCatid)	\
    (This)->lpVtbl -> EnumImplCategoriesOfClass(This,rclsid,ppenumCatid)

#define ICatInformation_EnumReqCategoriesOfClass(This,rclsid,ppenumCatid)	\
    (This)->lpVtbl -> EnumReqCategoriesOfClass(This,rclsid,ppenumCatid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ICatInformation_EnumCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ LCID lcid,
    /* [out] */ IEnumCATEGORYINFO __RPC_FAR *__RPC_FAR *ppenumCategoryInfo);


void __RPC_STUB ICatInformation_EnumCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatInformation_GetCategoryDesc_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCATID rcatid,
    /* [in] */ LCID lcid,
    /* [out] */ LPWSTR __RPC_FAR *pszDesc);


void __RPC_STUB ICatInformation_GetCategoryDesc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_RemoteEnumClassesOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][unique][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][unique][in] */ CATID __RPC_FAR rgcatidReq[  ],
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);


void __RPC_STUB ICatInformation_RemoteEnumClassesOfCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_RemoteIsClassOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][unique][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][unique][in] */ CATID __RPC_FAR rgcatidReq[  ]);


void __RPC_STUB ICatInformation_RemoteIsClassOfCategories_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatInformation_EnumImplCategoriesOfClass_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);


void __RPC_STUB ICatInformation_EnumImplCategoriesOfClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ICatInformation_EnumReqCategoriesOfClass_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumCatid);


void __RPC_STUB ICatInformation_EnumReqCategoriesOfClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICatInformation_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_comcat_0009
 * at Thu Sep 11 10:58:53 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL_itf_comcat_0009_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_comcat_0009_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE ICatInformation_EnumClassesOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_EnumClassesOfCategories_Stub( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][unique][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][unique][in] */ CATID __RPC_FAR rgcatidReq[  ],
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid);

/* [local] */ HRESULT STDMETHODCALLTYPE ICatInformation_IsClassOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ]);


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_IsClassOfCategories_Stub( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][unique][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][unique][in] */ CATID __RPC_FAR rgcatidReq[  ]);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\patch\include\process.h ===
/***
*process.h - definition and declarations for process control functions
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file defines the modeflag values for spawnxx calls.
*       Also contains the function argument declarations for all
*       process control related routines.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_PROCESS
#define _INC_PROCESS

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifndef _POSIX_

#ifdef __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif


#ifndef _MAC
#ifndef _WCHAR_T_DEFINED
typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED
#endif
#endif  /* ndef _MAC */


/* modeflag values for _spawnxx routines */

#ifndef _MAC

#define _P_WAIT         0
#define _P_NOWAIT       1
#define _OLD_P_OVERLAY  2
#define _P_NOWAITO      3
#define _P_DETACH       4

#ifdef  _MT
#define _P_OVERLAY      2
#else
extern int _p_overlay;
#define _P_OVERLAY      _p_overlay
#endif  /* _MT */

/* Action codes for _cwait(). The action code argument to _cwait is ignored
   on Win32 though it is accepted for compatibilty with old MS CRT libs */
#define _WAIT_CHILD      0
#define _WAIT_GRANDCHILD 1

#else   /* ndef _MAC */

#define _P_NOWAIT       1
#define _P_OVERLAY      2

#endif  /* ndef _MAC */


/* function prototypes */

#ifdef  _MT
_CRTIMP unsigned long  __cdecl _beginthread (void (__cdecl *) (void *),
        unsigned, void *);
_CRTIMP void __cdecl _endthread(void);
_CRTIMP unsigned long __cdecl _beginthreadex(void *, unsigned,
        unsigned (__stdcall *) (void *), void *, unsigned, unsigned *);
_CRTIMP void __cdecl _endthreadex(unsigned);
#endif

#if     _MSC_VER >= 1200
_CRTIMP __declspec(noreturn) void __cdecl abort(void);
_CRTIMP __declspec(noreturn) void __cdecl exit(int);
_CRTIMP __declspec(noreturn) void __cdecl _exit(int);
#else
_CRTIMP void __cdecl abort(void);
_CRTIMP void __cdecl exit(int);
_CRTIMP void __cdecl _exit(int);
#endif
_CRTIMP void __cdecl _cexit(void);
_CRTIMP void __cdecl _c_exit(void);
_CRTIMP int __cdecl _getpid(void);

#ifndef _MAC

_CRTIMP int __cdecl _cwait(int *, int, int);
_CRTIMP int __cdecl _execl(const char *, const char *, ...);
_CRTIMP int __cdecl _execle(const char *, const char *, ...);
_CRTIMP int __cdecl _execlp(const char *, const char *, ...);
_CRTIMP int __cdecl _execlpe(const char *, const char *, ...);
_CRTIMP int __cdecl _execv(const char *, const char * const *);
_CRTIMP int __cdecl _execve(const char *, const char * const *, const char * const *);
_CRTIMP int __cdecl _execvp(const char *, const char * const *);
_CRTIMP int __cdecl _execvpe(const char *, const char * const *, const char * const *);
_CRTIMP int __cdecl _spawnl(int, const char *, const char *, ...);
_CRTIMP int __cdecl _spawnle(int, const char *, const char *, ...);
_CRTIMP int __cdecl _spawnlp(int, const char *, const char *, ...);
_CRTIMP int __cdecl _spawnlpe(int, const char *, const char *, ...);
_CRTIMP int __cdecl _spawnv(int, const char *, const char * const *);
_CRTIMP int __cdecl _spawnve(int, const char *, const char * const *,
        const char * const *);
_CRTIMP int __cdecl _spawnvp(int, const char *, const char * const *);
_CRTIMP int __cdecl _spawnvpe(int, const char *, const char * const *,
        const char * const *);
_CRTIMP int __cdecl system(const char *);

#else   /* ndef _MAC */

_CRTIMP int __cdecl _spawn(int, const char *);

#endif  /* ndef _MAC */

#ifndef _MAC
#ifndef _WPROCESS_DEFINED
/* wide function prototypes, also declared in wchar.h  */
_CRTIMP int __cdecl _wexecl(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexecle(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexeclp(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexeclpe(const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wexecv(const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wexecve(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP int __cdecl _wexecvp(const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wexecvpe(const wchar_t *, const wchar_t * const *, const wchar_t * const *);
_CRTIMP int __cdecl _wspawnl(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnle(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnlp(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnlpe(int, const wchar_t *, const wchar_t *, ...);
_CRTIMP int __cdecl _wspawnv(int, const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wspawnve(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP int __cdecl _wspawnvp(int, const wchar_t *, const wchar_t * const *);
_CRTIMP int __cdecl _wspawnvpe(int, const wchar_t *, const wchar_t * const *,
        const wchar_t * const *);
_CRTIMP int __cdecl _wsystem(const wchar_t *);

#define _WPROCESS_DEFINED
#endif

/* --------- The following functions are OBSOLETE --------- */
/*
 * The Win32 API LoadLibrary, FreeLibrary and GetProcAddress should be used
 * instead.
 */
int __cdecl _loaddll(char *);
int __cdecl _unloaddll(int);
int (__cdecl * __cdecl _getdllprocaddr(int, char *, int))();
/* --------- The preceding functions are OBSOLETE --------- */


#ifdef  _DECL_DLLMAIN
/*
 * Declare DLL notification (initialization/termination) routines
 *      The preferred method is for the user to provide DllMain() which will
 *      be called automatically by the DLL entry point defined by the C run-
 *      time library code.  If the user wants to define the DLL entry point
 *      routine, the user's entry point must call _CRT_INIT on all types of
 *      notifications, as the very first thing on attach notifications and
 *      as the very last thing on detach notifications.
 */
#ifdef  _WINDOWS_       /* Use types from WINDOWS.H */
BOOL WINAPI DllMain(HANDLE, DWORD, LPVOID);
BOOL WINAPI _CRT_INIT(HANDLE, DWORD, LPVOID);
BOOL WINAPI _wCRT_INIT(HANDLE, DWORD, LPVOID);
extern BOOL (WINAPI *_pRawDllMain)(HANDLE, DWORD, LPVOID);
#else
int __stdcall DllMain(void *, unsigned, void *);
int __stdcall _CRT_INIT(void *, unsigned, void *);
int __stdcall _wCRT_INIT(void *, unsigned, void *);
extern int (__stdcall *_pRawDllMain)(void *, unsigned, void *);
#endif  /* _WINDOWS_ */
#endif
#endif  /* ndef _MAC */

#if     !__STDC__

/* Non-ANSI names for compatibility */


#ifndef _MAC

#define P_WAIT          _P_WAIT
#define P_NOWAIT        _P_NOWAIT
#define P_OVERLAY       _P_OVERLAY
#define OLD_P_OVERLAY   _OLD_P_OVERLAY
#define P_NOWAITO       _P_NOWAITO
#define P_DETACH        _P_DETACH
#define WAIT_CHILD      _WAIT_CHILD
#define WAIT_GRANDCHILD _WAIT_GRANDCHILD

#else   /* ndef _MAC */

#define P_NOWAIT        _P_NOWAIT
#define P_OVERLAY       _P_OVERLAY

#endif  /* ndef _MAC */

#ifndef _MAC

/* current declarations */
_CRTIMP int __cdecl cwait(int *, int, int);
_CRTIMP int __cdecl execl(const char *, const char *, ...);
_CRTIMP int __cdecl execle(const char *, const char *, ...);
_CRTIMP int __cdecl execlp(const char *, const char *, ...);
_CRTIMP int __cdecl execlpe(const char *, const char *, ...);
_CRTIMP int __cdecl execv(const char *, const char * const *);
_CRTIMP int __cdecl execve(const char *, const char * const *, const char * const *);
_CRTIMP int __cdecl execvp(const char *, const char * const *);
_CRTIMP int __cdecl execvpe(const char *, const char * const *, const char * const *);
_CRTIMP int __cdecl spawnl(int, const char *, const char *, ...);
_CRTIMP int __cdecl spawnle(int, const char *, const char *, ...);
_CRTIMP int __cdecl spawnlp(int, const char *, const char *, ...);
_CRTIMP int __cdecl spawnlpe(int, const char *, const char *, ...);
_CRTIMP int __cdecl spawnv(int, const char *, const char * const *);
_CRTIMP int __cdecl spawnve(int, const char *, const char * const *,
        const char * const *);
_CRTIMP int __cdecl spawnvp(int, const char *, const char * const *);
_CRTIMP int __cdecl spawnvpe(int, const char *, const char * const *,
        const char * const *);

#endif  /* ndef _MAC */

_CRTIMP int __cdecl getpid(void);

#endif  /* __STDC__ */

#ifdef  __cplusplus
}
#endif

#endif  /* _POSIX_ */

#endif  /* _INC_PROCESS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\patch\include\crtdbg.h ===
/***
*crtdbg.h - Supports debugging features of the C runtime library.
*
*       Copyright (c) 1994-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       Support CRT debugging features.
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_CRTDBG
#define _INC_CRTDBG

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif  /* __cplusplus */


 /****************************************************************************
 *
 * Constants and types
 *
 ***************************************************************************/


#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif

/* Define NULL pointer value */

#ifndef NULL
#ifdef  __cplusplus
#define NULL    0
#else
#define NULL    ((void *)0)
#endif
#endif

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

typedef void *_HFILE; /* file handle pointer */

#define _CRT_WARN           0
#define _CRT_ERROR          1
#define _CRT_ASSERT         2
#define _CRT_ERRCNT         3

#define _CRTDBG_MODE_FILE      0x1
#define _CRTDBG_MODE_DEBUG     0x2
#define _CRTDBG_MODE_WNDW      0x4
#define _CRTDBG_REPORT_MODE    -1

#define _CRTDBG_INVALID_HFILE ((_HFILE)-1)
#define _CRTDBG_HFILE_ERROR   ((_HFILE)-2)
#define _CRTDBG_FILE_STDOUT   ((_HFILE)-4)
#define _CRTDBG_FILE_STDERR   ((_HFILE)-5)
#define _CRTDBG_REPORT_FILE   ((_HFILE)-6)

typedef int (__cdecl * _CRT_REPORT_HOOK)(int, char *, int *);

 /****************************************************************************
 *
 * Heap
 *
 ***************************************************************************/

 /****************************************************************************.
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

#define _HOOK_ALLOC     1
#define _HOOK_REALLOC   2
#define _HOOK_FREE      3

typedef int (__cdecl * _CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int);

 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bit values for _crtDbgFlag flag:
 *
 * These bitflags control debug heap behavior.
 */

#define _CRTDBG_ALLOC_MEM_DF        0x01  /* Turn on debug allocation */
#define _CRTDBG_DELAY_FREE_MEM_DF   0x02  /* Don't actually free memory */
#define _CRTDBG_CHECK_ALWAYS_DF     0x04  /* Check heap every alloc/dealloc */
#define _CRTDBG_RESERVED_DF         0x08  /* Reserved - do not use */
#define _CRTDBG_CHECK_CRT_DF        0x10  /* Leak check/diff CRT blocks */
#define _CRTDBG_LEAK_CHECK_DF       0x20  /* Leak check at program exit */

#define _CRTDBG_REPORT_FLAG         -1    /* Query bitflag status */

#define _BLOCK_TYPE(block)          (block & 0xFFFF)
#define _BLOCK_SUBTYPE(block)       (block >> 16 & 0xFFFF)


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

/* Memory block identification */
#define _FREE_BLOCK      0
#define _NORMAL_BLOCK    1
#define _CRT_BLOCK       2
#define _IGNORE_BLOCK    3
#define _CLIENT_BLOCK    4
#define _MAX_BLOCKS      5

typedef void (__cdecl * _CRT_DUMP_CLIENT)(void *, size_t);

typedef struct _CrtMemState
{
        struct _CrtMemBlockHeader * pBlockHeader;
        unsigned long lCounts[_MAX_BLOCKS];
        unsigned long lSizes[_MAX_BLOCKS];
        unsigned long lHighWaterCount;
        unsigned long lTotalCount;
} _CrtMemState;


 /****************************************************************************
 *
 * Declarations, prototype and function-like macros
 *
 ***************************************************************************/


#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

#define _ASSERT(expr) ((void)0)

#undef _ASSERTE
#define _ASSERTE(expr) ((void)0)


#define _RPT0(rptno, msg)

#define _RPT1(rptno, msg, arg1)

#define _RPT2(rptno, msg, arg1, arg2)

#define _RPT3(rptno, msg, arg1, arg2, arg3)

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4)


#define _RPTF0(rptno, msg)

#define _RPTF1(rptno, msg, arg1)

#define _RPTF2(rptno, msg, arg1, arg2)

#define _RPTF3(rptno, msg, arg1, arg2, arg3)

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4)

#define _malloc_dbg(s, t, f, l)         malloc(s)
#define _calloc_dbg(c, s, t, f, l)      calloc(c, s)
#define _realloc_dbg(p, s, t, f, l)     realloc(p, s)
#define _expand_dbg(p, s, t, f, l)      _expand(p, s)
#define _free_dbg(p, t)                 free(p)
#define _msize_dbg(p, t)                _msize(p)

#define _CrtSetReportHook(f)                ((void)0)
#define _CrtSetReportMode(t, f)             ((int)0)
#define _CrtSetReportFile(t, f)             ((void)0)

#define _CrtDbgBreak()                      ((void)0)

#define _CrtSetBreakAlloc(a)                ((long)0)

#define _CrtSetAllocHook(f)                 ((void)0)

#define _CrtCheckMemory()                   ((int)1)
#define _CrtSetDbgFlag(f)                   ((int)0)
#define _CrtDoForAllClientObjects(f, c)     ((void)0)
#define _CrtIsValidPointer(p, n, r)         ((int)1)
#define _CrtIsValidHeapPointer(p)           ((int)1)
#define _CrtIsMemoryBlock(p, t, r, f, l)    ((int)1)

#define _CrtSetDumpClient(f)                ((void)0)

#define _CrtMemCheckpoint(s)                ((void)0)
#define _CrtMemDifference(s1, s2, s3)       ((int)0)
#define _CrtMemDumpAllObjectsSince(s)       ((void)0)
#define _CrtMemDumpStatistics(s)            ((void)0)
#define _CrtDumpMemoryLeaks()               ((int)0)


#else   /* _DEBUG */


 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/


/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

 /****************************************************************************
 *
 * Debug Reporting
 *
 ***************************************************************************/

_CRTIMP extern long _crtAssertBusy;

_CRTIMP _CRT_REPORT_HOOK __cdecl _CrtSetReportHook(
        _CRT_REPORT_HOOK
        );

_CRTIMP int __cdecl _CrtSetReportMode(
        int,
        int
        );

_CRTIMP _HFILE __cdecl _CrtSetReportFile(
        int,
        _HFILE
        );

_CRTIMP int __cdecl _CrtDbgReport(
        int,
        const char *,
        int,
        const char *,
        const char *,
        ...);

/* Asserts */

#define _ASSERT(expr) \
        do { if (!(expr) && \
                (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, NULL))) \
             _CrtDbgBreak(); } while (0)

//#define _ASSERTE(expr) \
//        do { if (!(expr) && \
//                (1 == _CrtDbgReport(_CRT_ASSERT, __FILE__, __LINE__, NULL, #expr))) \
//             _CrtDbgBreak(); } while (0)


/* Reports with no file/line info */

#define _RPT0(rptno, msg) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, "%s", msg))) \
                _CrtDbgBreak(); } while (0)

#define _RPT1(rptno, msg, arg1) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, msg, arg1))) \
                _CrtDbgBreak(); } while (0)

#define _RPT2(rptno, msg, arg1, arg2) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, msg, arg1, arg2))) \
                _CrtDbgBreak(); } while (0)

#define _RPT3(rptno, msg, arg1, arg2, arg3) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, msg, arg1, arg2, arg3))) \
                _CrtDbgBreak(); } while (0)

#define _RPT4(rptno, msg, arg1, arg2, arg3, arg4) \
        do { if ((1 == _CrtDbgReport(rptno, NULL, 0, NULL, msg, arg1, arg2, arg3, arg4))) \
                _CrtDbgBreak(); } while (0)


/* Reports with file/line info */

#define _RPTF0(rptno, msg) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, "%s", msg))) \
                _CrtDbgBreak(); } while (0)

#define _RPTF1(rptno, msg, arg1) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1))) \
                _CrtDbgBreak(); } while (0)

#define _RPTF2(rptno, msg, arg1, arg2) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2))) \
                _CrtDbgBreak(); } while (0)

#define _RPTF3(rptno, msg, arg1, arg2, arg3) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3))) \
                _CrtDbgBreak(); } while (0)

#define _RPTF4(rptno, msg, arg1, arg2, arg3, arg4) \
        do { if ((1 == _CrtDbgReport(rptno, __FILE__, __LINE__, NULL, msg, arg1, arg2, arg3, arg4))) \
                _CrtDbgBreak(); } while (0)

#if     defined(_M_IX86) && !defined(_CRT_PORTABLE)
#define _CrtDbgBreak() __asm { int 3 }
#elif   defined(_M_ALPHA) && !defined(_CRT_PORTABLE)
void _BPT();
#pragma intrinsic(_BPT)
#define _CrtDbgBreak() _BPT()
#else
_CRTIMP void __cdecl _CrtDbgBreak(
        void
        );
#endif

 /****************************************************************************
 *
 * Heap routines
 *
 ***************************************************************************/

#ifdef  _CRTDBG_MAP_ALLOC

#define   malloc(s)         _malloc_dbg(s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   calloc(c, s)      _calloc_dbg(c, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   realloc(p, s)     _realloc_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   _expand(p, s)     _expand_dbg(p, s, _NORMAL_BLOCK, __FILE__, __LINE__)
#define   free(p)           _free_dbg(p, _NORMAL_BLOCK)
#define   _msize(p)         _msize_dbg(p, _NORMAL_BLOCK)

#endif  /* _CRTDBG_MAP_ALLOC */

_CRTIMP extern long _crtBreakAlloc;      /* Break on this allocation */

_CRTIMP long __cdecl _CrtSetBreakAlloc(
        long
        );

/*
 * Prototypes for malloc, free, realloc, etc are in malloc.h
 */

_CRTIMP void * __cdecl _malloc_dbg(
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _calloc_dbg(
        size_t,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _realloc_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void * __cdecl _expand_dbg(
        void *,
        size_t,
        int,
        const char *,
        int
        );

_CRTIMP void __cdecl _free_dbg(
        void *,
        int
        );

_CRTIMP size_t __cdecl _msize_dbg (
        void *,
        int
        );


 /****************************************************************************
 *
 * Client-defined allocation hook
 *
 ***************************************************************************/

_CRTIMP _CRT_ALLOC_HOOK __cdecl _CrtSetAllocHook(
        _CRT_ALLOC_HOOK
        );


 /****************************************************************************
 *
 * Memory management
 *
 ***************************************************************************/

/*
 * Bitfield flag that controls CRT heap behavior
 * Default setting is _CRTDBG_ALLOC_MEM_DF
 */

_CRTIMP extern int _crtDbgFlag;

_CRTIMP int __cdecl _CrtCheckMemory(
        void
        );

_CRTIMP int __cdecl _CrtSetDbgFlag(
        int
        );

_CRTIMP void __cdecl _CrtDoForAllClientObjects(
        void (*pfn)(void *, void *),
        void *
        );

_CRTIMP int __cdecl _CrtIsValidPointer(
        const void *,
        unsigned int,
        int
        );

_CRTIMP int __cdecl _CrtIsValidHeapPointer(
        const void *
        );

_CRTIMP int __cdecl _CrtIsMemoryBlock(
        const void *,
        unsigned int,
        long *,
        char **,
        int *
        );


 /****************************************************************************
 *
 * Memory state
 *
 ***************************************************************************/

_CRTIMP _CRT_DUMP_CLIENT __cdecl _CrtSetDumpClient(
        _CRT_DUMP_CLIENT
        );

_CRTIMP void __cdecl _CrtMemCheckpoint(
        _CrtMemState *
        );

_CRTIMP int __cdecl _CrtMemDifference(
        _CrtMemState *,
        const _CrtMemState *,
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpAllObjectsSince(
        const _CrtMemState *
        );

_CRTIMP void __cdecl _CrtMemDumpStatistics(
        const _CrtMemState *
        );

_CRTIMP int __cdecl _CrtDumpMemoryLeaks(
        void
        );

#endif  /* _DEBUG */

#ifdef  __cplusplus
}

#ifndef _MFC_OVERRIDES_NEW

#ifndef _DEBUG

 /****************************************************************************
 *
 * Debug OFF
 * Debug OFF
 * Debug OFF
 *
 ***************************************************************************/

inline void* __cdecl operator new(unsigned int s, int, const char *, int)
        { return ::operator new(s); }

#if	_MSC_VER >= 1200
inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }
#endif
#else /* _DEBUG */

 /****************************************************************************
 *
 * Debug ON
 * Debug ON
 * Debug ON
 *
 ***************************************************************************/

_CRTIMP void * __cdecl operator new(
        unsigned int,
        int,
        const char *,
        int
        );


#if	_MSC_VER >= 1200
inline void __cdecl operator delete(void * _P, int, const char *, int)
        { ::operator delete(_P); }
#endif

#ifdef _CRTDBG_MAP_ALLOC

inline void* __cdecl operator new(unsigned int s)
        { return ::operator new(s, _NORMAL_BLOCK, __FILE__, __LINE__); }

#endif  /* _CRTDBG_MAP_ALLOC */

#endif  /* _DEBUG */

#endif _MFC_OVERRIDES_NEW

#endif  /* __cplusplus */

#endif  /* _INC_CRTDBG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\patch\include\winver.h ===
/*****************************************************************************\
*                                                                             *
* winver.h -    Version management functions, types, and definitions          *
*                                                                             *
*               Include file for VER.DLL.  This library is                    *
*               designed to allow version stamping of Windows executable files*
*               and of special .VER files for DOS executable files.           *
*                                                                             *
*          Copyright 1993 - 1998 Microsoft Corp.  All rights reserved      *
*                                                                             *
\*****************************************************************************/

#ifndef VER_H
#define VER_H

#ifdef __cplusplus
extern "C" {
#endif

/* ----- Symbols ----- */
#define VS_FILE_INFO            RT_VERSION
#define VS_VERSION_INFO         1
#define VS_USER_DEFINED         100

/* ----- VS_VERSION.dwFileFlags ----- */
#ifndef _MAC
#define VS_FFI_SIGNATURE        0xFEEF04BDL
#else
#define VS_FFI_SIGNATURE        0xBD04EFFEL
#endif
#define VS_FFI_STRUCVERSION     0x00010000L
#define VS_FFI_FILEFLAGSMASK    0x0000003FL

/* ----- VS_VERSION.dwFileFlags ----- */
#define VS_FF_DEBUG             0x00000001L
#define VS_FF_PRERELEASE        0x00000002L
#define VS_FF_PATCHED           0x00000004L
#define VS_FF_PRIVATEBUILD      0x00000008L
#define VS_FF_INFOINFERRED      0x00000010L
#define VS_FF_SPECIALBUILD      0x00000020L

/* ----- VS_VERSION.dwFileOS ----- */
#define VOS_UNKNOWN             0x00000000L
#define VOS_DOS                 0x00010000L
#define VOS_OS216               0x00020000L
#define VOS_OS232               0x00030000L
#define VOS_NT                  0x00040000L

#define VOS__BASE               0x00000000L
#define VOS__WINDOWS16          0x00000001L
#define VOS__PM16               0x00000002L
#define VOS__PM32               0x00000003L
#define VOS__WINDOWS32          0x00000004L

#define VOS_DOS_WINDOWS16       0x00010001L
#define VOS_DOS_WINDOWS32       0x00010004L
#define VOS_OS216_PM16          0x00020002L
#define VOS_OS232_PM32          0x00030003L
#define VOS_NT_WINDOWS32        0x00040004L

/* ----- VS_VERSION.dwFileType ----- */
#define VFT_UNKNOWN             0x00000000L
#define VFT_APP                 0x00000001L
#define VFT_DLL                 0x00000002L
#define VFT_DRV                 0x00000003L
#define VFT_FONT                0x00000004L
#define VFT_VXD                 0x00000005L
#define VFT_STATIC_LIB          0x00000007L

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_DRV ----- */
#define VFT2_UNKNOWN            0x00000000L
#define VFT2_DRV_PRINTER        0x00000001L
#define VFT2_DRV_KEYBOARD       0x00000002L
#define VFT2_DRV_LANGUAGE       0x00000003L
#define VFT2_DRV_DISPLAY        0x00000004L
#define VFT2_DRV_MOUSE          0x00000005L
#define VFT2_DRV_NETWORK        0x00000006L
#define VFT2_DRV_SYSTEM         0x00000007L
#define VFT2_DRV_INSTALLABLE    0x00000008L
#define VFT2_DRV_SOUND          0x00000009L
#define VFT2_DRV_COMM           0x0000000AL
#define VFT2_DRV_INPUTMETHOD    0x0000000BL

/* ----- VS_VERSION.dwFileSubtype for VFT_WINDOWS_FONT ----- */
#define VFT2_FONT_RASTER        0x00000001L
#define VFT2_FONT_VECTOR        0x00000002L
#define VFT2_FONT_TRUETYPE      0x00000003L

/* ----- VerFindFile() flags ----- */
#define VFFF_ISSHAREDFILE       0x0001

#define VFF_CURNEDEST           0x0001
#define VFF_FILEINUSE           0x0002
#define VFF_BUFFTOOSMALL        0x0004

/* ----- VerInstallFile() flags ----- */
#define VIFF_FORCEINSTALL       0x0001
#define VIFF_DONTDELETEOLD      0x0002

#define VIF_TEMPFILE            0x00000001L
#define VIF_MISMATCH            0x00000002L
#define VIF_SRCOLD              0x00000004L

#define VIF_DIFFLANG            0x00000008L
#define VIF_DIFFCODEPG          0x00000010L
#define VIF_DIFFTYPE            0x00000020L

#define VIF_WRITEPROT           0x00000040L
#define VIF_FILEINUSE           0x00000080L
#define VIF_OUTOFSPACE          0x00000100L
#define VIF_ACCESSVIOLATION     0x00000200L
#define VIF_SHARINGVIOLATION    0x00000400L
#define VIF_CANNOTCREATE        0x00000800L
#define VIF_CANNOTDELETE        0x00001000L
#define VIF_CANNOTRENAME        0x00002000L
#define VIF_CANNOTDELETECUR     0x00004000L
#define VIF_OUTOFMEMORY         0x00008000L

#define VIF_CANNOTREADSRC       0x00010000L
#define VIF_CANNOTREADDST       0x00020000L

#define VIF_BUFFTOOSMALL        0x00040000L

#ifndef RC_INVOKED              /* RC doesn't need to see the rest of this */

/* ----- Types and structures ----- */

typedef struct tagVS_FIXEDFILEINFO
{
    DWORD   dwSignature;            /* e.g. 0xfeef04bd */
    DWORD   dwStrucVersion;         /* e.g. 0x00000042 = "0.42" */
    DWORD   dwFileVersionMS;        /* e.g. 0x00030075 = "3.75" */
    DWORD   dwFileVersionLS;        /* e.g. 0x00000031 = "0.31" */
    DWORD   dwProductVersionMS;     /* e.g. 0x00030010 = "3.10" */
    DWORD   dwProductVersionLS;     /* e.g. 0x00000031 = "0.31" */
    DWORD   dwFileFlagsMask;        /* = 0x3F for version "0.42" */
    DWORD   dwFileFlags;            /* e.g. VFF_DEBUG | VFF_PRERELEASE */
    DWORD   dwFileOS;               /* e.g. VOS_DOS_WINDOWS16 */
    DWORD   dwFileType;             /* e.g. VFT_DRIVER */
    DWORD   dwFileSubtype;          /* e.g. VFT2_DRV_KEYBOARD */
    DWORD   dwFileDateMS;           /* e.g. 0 */
    DWORD   dwFileDateLS;           /* e.g. 0 */
} VS_FIXEDFILEINFO;

/* ----- Function prototypes ----- */

DWORD
APIENTRY
VerFindFileA(
        DWORD uFlags,
        LPSTR szFileName,
        LPSTR szWinDir,
        LPSTR szAppDir,
        LPSTR szCurDir,
        PUINT lpuCurDirLen,
        LPSTR szDestDir,
        PUINT lpuDestDirLen
        );
DWORD
APIENTRY
VerFindFileW(
        DWORD uFlags,
        LPWSTR szFileName,
        LPWSTR szWinDir,
        LPWSTR szAppDir,
        LPWSTR szCurDir,
        PUINT lpuCurDirLen,
        LPWSTR szDestDir,
        PUINT lpuDestDirLen
        );
#ifdef UNICODE
#define VerFindFile  VerFindFileW
#else
#define VerFindFile  VerFindFileA
#endif // !UNICODE

DWORD
APIENTRY
VerInstallFileA(
        DWORD uFlags,
        LPSTR szSrcFileName,
        LPSTR szDestFileName,
        LPSTR szSrcDir,
        LPSTR szDestDir,
        LPSTR szCurDir,
        LPSTR szTmpFile,
        PUINT lpuTmpFileLen
        );
DWORD
APIENTRY
VerInstallFileW(
        DWORD uFlags,
        LPWSTR szSrcFileName,
        LPWSTR szDestFileName,
        LPWSTR szSrcDir,
        LPWSTR szDestDir,
        LPWSTR szCurDir,
        LPWSTR szTmpFile,
        PUINT lpuTmpFileLen
        );
#ifdef UNICODE
#define VerInstallFile  VerInstallFileW
#else
#define VerInstallFile  VerInstallFileA
#endif // !UNICODE

/* Returns size of version info in bytes */
DWORD
APIENTRY
GetFileVersionInfoSizeA(
        LPSTR lptstrFilename, /* Filename of version stamped file */
        LPDWORD lpdwHandle
        );                      /* Information for use by GetFileVersionInfo */
/* Returns size of version info in bytes */
DWORD
APIENTRY
GetFileVersionInfoSizeW(
        LPWSTR lptstrFilename, /* Filename of version stamped file */
        LPDWORD lpdwHandle
        );                      /* Information for use by GetFileVersionInfo */
#ifdef UNICODE
#define GetFileVersionInfoSize  GetFileVersionInfoSizeW
#else
#define GetFileVersionInfoSize  GetFileVersionInfoSizeA
#endif // !UNICODE

/* Read version info into buffer */
BOOL
APIENTRY
GetFileVersionInfoA(
        LPSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle,         /* Information from GetFileVersionSize */
        DWORD dwLen,            /* Length of buffer for info */
        LPVOID lpData
        );                      /* Buffer to place the data structure */
/* Read version info into buffer */
BOOL
APIENTRY
GetFileVersionInfoW(
        LPWSTR lptstrFilename, /* Filename of version stamped file */
        DWORD dwHandle,         /* Information from GetFileVersionSize */
        DWORD dwLen,            /* Length of buffer for info */
        LPVOID lpData
        );                      /* Buffer to place the data structure */
#ifdef UNICODE
#define GetFileVersionInfo  GetFileVersionInfoW
#else
#define GetFileVersionInfo  GetFileVersionInfoA
#endif // !UNICODE

DWORD
APIENTRY
VerLanguageNameA(
        DWORD wLang,
        LPSTR szLang,
        DWORD nSize
        );
DWORD
APIENTRY
VerLanguageNameW(
        DWORD wLang,
        LPWSTR szLang,
        DWORD nSize
        );
#ifdef UNICODE
#define VerLanguageName  VerLanguageNameW
#else
#define VerLanguageName  VerLanguageNameA
#endif // !UNICODE

BOOL
APIENTRY
VerQueryValueA(
        const LPVOID pBlock,
        LPSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );
BOOL
APIENTRY
VerQueryValueW(
        const LPVOID pBlock,
        LPWSTR lpSubBlock,
        LPVOID * lplpBuffer,
        PUINT puLen
        );
#ifdef UNICODE
#define VerQueryValue  VerQueryValueW
#else
#define VerQueryValue  VerQueryValueA
#endif // !UNICODE

#endif  /* !RC_INVOKED */

#ifdef __cplusplus
}
#endif

#endif  /* !VER_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\patch\include\search.h ===
/***
*search.h - declarations for searcing/sorting routines
*
*       Copyright (c) 1985-1997, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       This file contains the declarations for the sorting and
*       searching routines.
*       [System V]
*
*       [Public]
*
****/

#if     _MSC_VER > 1000
#pragma once
#endif

#ifndef _INC_SEARCH
#define _INC_SEARCH

#if     !defined(_WIN32) && !defined(_MAC)
#error ERROR: Only Mac or Win32 targets supported!
#endif


#ifdef  __cplusplus
extern "C" {
#endif



/* Define _CRTIMP */

#ifndef _CRTIMP
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   /* ndef _DLL */
#define _CRTIMP
#endif  /* _DLL */
#endif  /* _CRTIMP */

/* Define __cdecl for non-Microsoft compilers */

#if     ( !defined(_MSC_VER) && !defined(__cdecl) )
#define __cdecl
#endif

/* Define _CRTAPI1 (for compatibility with the NT SDK) */

#ifndef _CRTAPI1
#if	_MSC_VER >= 800 && _M_IX86 >= 300
#define _CRTAPI1 __cdecl
#else
#define _CRTAPI1
#endif
#endif



#ifndef _SIZE_T_DEFINED
typedef unsigned int size_t;
#define _SIZE_T_DEFINED
#endif


/* Function prototypes */

_CRTIMP void * __cdecl bsearch(const void *, const void *, size_t, size_t,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl _lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void __cdecl qsort(void *, size_t, size_t, int (__cdecl *)(const void *,
        const void *));


#if     !__STDC__
/* Non-ANSI names for compatibility */
_CRTIMP void * __cdecl lfind(const void *, const void *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
_CRTIMP void * __cdecl lsearch(const void *, void  *, unsigned int *, unsigned int,
        int (__cdecl *)(const void *, const void *));
#endif  /* __STDC__ */


#ifdef  __cplusplus
}
#endif

#endif  /* _INC_SEARCH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\patch\include\servprov.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Thu Sep 11 10:59:13 1997
 */
/* Compiler settings for servprov.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __servprov_h__
#define __servprov_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IServiceProvider_FWD_DEFINED__
#define __IServiceProvider_FWD_DEFINED__
typedef interface IServiceProvider IServiceProvider;
#endif 	/* __IServiceProvider_FWD_DEFINED__ */


/* header files for imported files */
#include "objidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_servprov_0000
 * at Thu Sep 11 10:59:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


//=--------------------------------------------------------------------------=
// ServProv.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//---------------------------------------------------------------------------=
// IServiceProvider Interfaces.


#ifndef _LPSERVICEPROVIDER_DEFINED
#define _LPSERVICEPROVIDER_DEFINED


extern RPC_IF_HANDLE __MIDL_itf_servprov_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_servprov_0000_v0_0_s_ifspec;

#ifndef __IServiceProvider_INTERFACE_DEFINED__
#define __IServiceProvider_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IServiceProvider
 * at Thu Sep 11 10:59:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [unique][uuid][object] */ 


typedef /* [unique] */ IServiceProvider __RPC_FAR *LPSERVICEPROVIDER;


EXTERN_C const IID IID_IServiceProvider;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
#if (_MSC_VER >= 1200)	// VC6 or greater
extern "C++"
{
#endif

    MIDL_INTERFACE("6d5140c1-7436-11ce-8034-00aa006009fa")
    IServiceProvider : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE QueryService( 
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject) = 0;
        
#if (_MSC_VER >= 1200)	// VC6 or greater
		template <class Q>
		HRESULT STDMETHODCALLTYPE QueryService(REFGUID guidService, Q** pp)
		{
			return QueryService(guidService, __uuidof(Q), (void**)pp);
		}
#endif    
    };

#if (_MSC_VER >= 1200)	// VC6 or greater
} // extern "C++"
#endif
    
#else 	/* C style interface */

    typedef struct IServiceProviderVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServiceProvider __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServiceProvider __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServiceProvider __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryService )( 
            IServiceProvider __RPC_FAR * This,
            /* [in] */ REFGUID guidService,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        END_INTERFACE
    } IServiceProviderVtbl;

    interface IServiceProvider
    {
        CONST_VTBL struct IServiceProviderVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServiceProvider_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServiceProvider_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServiceProvider_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServiceProvider_QueryService(This,guidService,riid,ppvObject)	\
    (This)->lpVtbl -> QueryService(This,guidService,riid,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IServiceProvider_RemoteQueryService_Proxy( 
    IServiceProvider __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);


void __RPC_STUB IServiceProvider_RemoteQueryService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServiceProvider_INTERFACE_DEFINED__ */


/****************************************
 * Generated header for interface: __MIDL_itf_servprov_0074
 * at Thu Sep 11 10:59:13 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [local] */ 


#endif


extern RPC_IF_HANDLE __MIDL_itf_servprov_0074_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_servprov_0074_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* [local] */ HRESULT STDMETHODCALLTYPE IServiceProvider_QueryService_Proxy( 
    IServiceProvider __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IServiceProvider_QueryService_Stub( 
    IServiceProvider __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\audiodlg.cpp ===
#include "stdafx.h"
#include "resource.h"
#include <sapi.h>
#include <string.h>
#include "audiodlg.h"
#include <spddkhlp.h>
#include <stdio.h>

/*****************************************************************************
* AudioDlgProc *
*--------------*
*   Description:
*       DLGPROC for choosing the default audio input/output
****************************************************************** BECKYW ***/
INT_PTR CALLBACK AudioDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static CSpUnicodeSupport unicode;  
    CAudioDlg *pAudioDlg = (CAudioDlg *) unicode.GetWindowLongPtr( hWnd, GWLP_USERDATA );
    SPDBG_FUNC( "AudioDlgProc" );

    CComPtr<ISpObjectToken> cpToken;

    switch (uMsg) 
    {
        case WM_INITDIALOG:
            // pAudioDlg comes in on the lParam
            pAudioDlg = (CAudioDlg *) lParam;

            // Set pAudioDlg to the window long so we can get it later
            unicode.SetWindowLongPtr( hWnd, GWLP_USERDATA, lParam );

            pAudioDlg->OnInitDialog(hWnd);
            break;

        case WM_DESTROY:
            pAudioDlg->OnDestroy();
            break;

        case WM_COMMAND:
            if ( LOWORD( wParam ) == IDOK )
            {
                // Determine if there are changes to commit
                WCHAR pwszRequestedDefault[ MAX_PATH ];
                pwszRequestedDefault[0] = 0;
                if ( pAudioDlg->GetRequestedDefaultTokenID( pwszRequestedDefault, MAX_PATH ) )
                {
                    // What kind of changes have been made?
                    pAudioDlg->m_fChangesToCommit = 
                        (pAudioDlg->m_dstrCurrentDefaultTokenId &&
                        (0 != wcsicmp( pwszRequestedDefault, pAudioDlg->m_dstrCurrentDefaultTokenId )));

                    pAudioDlg->m_fChangesSinceLastTime = 
                         (pAudioDlg->m_dstrCurrentDefaultTokenId &&
                         (0 != wcsicmp( pwszRequestedDefault, pAudioDlg->m_dstrDefaultTokenIdBeforeOK )));
               }

                if ( pAudioDlg->m_fChangesSinceLastTime )
                {
                    pAudioDlg->m_dstrLastRequestedDefaultTokenId = pwszRequestedDefault;
                }

                ::EndDialog( hWnd, true );
            }
            
            else if ( LOWORD( wParam ) == IDCANCEL )
            {
                // There are no changes to commit
                pAudioDlg->m_fChangesSinceLastTime = false;

                ::EndDialog( hWnd, false );
            }

            // Handle the volume button
            else if ( LOWORD( wParam ) == ID_TTS_VOL )
            {
                pAudioDlg->GetAudioToken(&cpToken);
                CSpDynamicString wszTitle;
                CComPtr<ISpObjectWithToken> cpSpObjectWithToken;
                HRESULT hr = S_OK;

	            hr = cpToken->CreateInstance(
			            NULL, CLSCTX_INPROC_SERVER, IID_ISpObjectWithToken,
			            (void **)&cpSpObjectWithToken);
                if (SUCCEEDED(hr))
                {
                    WCHAR wszTitle[256];
                    ::LoadString(_Module.GetResourceInstance(), IDS_AUDIO_VOLUME, wszTitle, 256);
                    hr = cpToken->DisplayUI(pAudioDlg->GetHDlg(), wszTitle, SPDUI_AudioVolume, NULL, 0, cpSpObjectWithToken);
                }
                SPDBG_REPORT_ON_FAIL(hr);
            }

            // Handle the audio properties button
            else if ( LOWORD(wParam) == IDC_AUDIO_PROPERTIES)
            {
                pAudioDlg->GetAudioToken(&cpToken);
                CSpDynamicString wszTitle;
                CComPtr<ISpObjectWithToken> cpSpObjectWithToken;
                HRESULT hr = S_OK;

	            hr = cpToken->CreateInstance(
			            NULL, CLSCTX_INPROC_SERVER, IID_ISpObjectWithToken,
			            (void **)&cpSpObjectWithToken);
                if (SUCCEEDED(hr))
                {
                    WCHAR wszTitle[256];
                    ::LoadString(_Module.GetResourceInstance(), IDS_AUDIO_PROPERTIES, wszTitle, 256);
                    hr = cpToken->DisplayUI(pAudioDlg->GetHDlg(), wszTitle, SPDUI_AudioProperties, NULL, 0, cpSpObjectWithToken);
                }
                SPDBG_REPORT_ON_FAIL(hr);
            }

            // Handle a selection change for the audio device
            else if (( IDC_DEFAULT_DEVICE == LOWORD( wParam ) ) &&
                     ( CBN_SELCHANGE == HIWORD( wParam ) ))
            {
                SPDBG_ASSERT( !pAudioDlg->IsPreferredDevice() );

                pAudioDlg->GetAudioToken(&cpToken);
                pAudioDlg->UpdateDlgUI(cpToken);
            }

            // Handle a click to either the preferred or 'this device' radio buttons
            else if (HIWORD(wParam) == BN_CLICKED)
            {
                bool bPreferred;
                if( LOWORD(wParam) == IDC_PREFERRED_MM_DEVICE)
                {
                    bPreferred = true;
                }
                else if(LOWORD(wParam) == IDC_THIS_DEVICE)
                {
                    bPreferred = false;
                }

                ::EnableWindow( ::GetDlgItem(pAudioDlg->GetHDlg(), IDC_DEFAULT_DEVICE), !bPreferred );
                pAudioDlg->SetPreferredDevice( bPreferred );
                pAudioDlg->GetAudioToken(&cpToken);
                pAudioDlg->UpdateDlgUI(cpToken);
            }
            break;
    
    }

    return FALSE;
} /* AudioDlgProc */

/*****************************************************************************
* CAudioDlg::OnInitDialog *
*-------------------------*
*   Description:
*       Dialog Initialization
****************************************************************** BECKYW ***/
void CAudioDlg::OnInitDialog(HWND hWnd)
{
    SPDBG_FUNC( "CAudioDlg::OnInitDialog" );
    SPDBG_ASSERT(IsWindow(hWnd));
    m_hDlg = hWnd;

    // Set the appropriate captions
    WCHAR wszCaption[ MAX_LOADSTRING ];
    HINSTANCE hInst = _Module.GetResourceInstance();

    // Main Window Caption
    ::LoadString( hInst, 
        (m_iotype == eINPUT) ? IDS_DEFAULT_SPEECH_INPUT : IDS_DEFAULT_SPEECH_OUTPUT,
        wszCaption, MAX_LOADSTRING );
    ::SendMessage( hWnd, WM_SETTEXT, 0, (LPARAM) wszCaption );

    // Group Box Caption
    ::LoadString( hInst,
        (m_iotype == eINPUT) ? IDS_DEFAULT_INPUT : IDS_DEFAULT_OUTPUT,
        wszCaption, MAX_LOADSTRING );
    ::SendMessage( (HWND) ::GetDlgItem( hWnd, IDC_AUDIO_GROUPBOX ), 
        WM_SETTEXT, 0, (LPARAM) wszCaption );

    // Preferred Caption
    ::LoadString( hInst,
        (m_iotype == eINPUT) ? IDS_PREFERRED_INPUT : IDS_PREFERRED_OUTPUT,
        wszCaption, MAX_LOADSTRING );
    ::SendMessage( (HWND) ::GetDlgItem( hWnd, IDC_PREFERRED_MM_DEVICE ), 
        WM_SETTEXT, 0, (LPARAM) wszCaption );

    // Specific Caption
    ::LoadString( hInst,
        (m_iotype == eINPUT) ? IDS_SPECIFIC_INPUT : IDS_SPECIFIC_OUTPUT,
        wszCaption, MAX_LOADSTRING );
    ::SendMessage( (HWND) ::GetDlgItem( hWnd, IDC_THIS_DEVICE ), 
        WM_SETTEXT, 0, (LPARAM) wszCaption );
    // MSAA Specific Caption
    ::LoadString( hInst,
        (m_iotype == eINPUT) ? IDS_SPECIFIC_INPUT2 : IDS_SPECIFIC_OUTPUT2,
        wszCaption, MAX_LOADSTRING );
    ::SendMessage( (HWND) ::GetDlgItem( hWnd, IDC_THIS_DEVICE2 ), 
        WM_SETTEXT, 0, (LPARAM) wszCaption );

    // Volume Button
    ::LoadString( hInst,
        IDS_VOLUME,
        wszCaption, MAX_LOADSTRING );
    ::SendMessage( (HWND) ::GetDlgItem( hWnd, ID_TTS_VOL ), 
        WM_SETTEXT, 0, (LPARAM) wszCaption );

    // Properties Button
    ::LoadString( hInst,
        IDS_PROPERTIES,
        wszCaption, MAX_LOADSTRING );
    ::SendMessage( (HWND) ::GetDlgItem( hWnd, IDC_AUDIO_PROPERTIES ), 
        WM_SETTEXT, 0, (LPARAM) wszCaption );

    const WCHAR *pszCategory = (m_iotype == eINPUT) ? SPCAT_AUDIOIN : SPCAT_AUDIOOUT;

    const WCHAR *pszMMSysEnum = (m_iotype == eINPUT)
        ? SPMMSYS_AUDIO_IN_TOKEN_ID
        : SPMMSYS_AUDIO_OUT_TOKEN_ID;

    HRESULT hr = S_OK;
    if ( !m_dstrCurrentDefaultTokenId )
    {
        hr = SpGetDefaultTokenIdFromCategoryId( pszCategory, &m_dstrCurrentDefaultTokenId );
    }

    if (SUCCEEDED(hr))
    {
        // Determine what the initial setting will appear as 
        if ( m_dstrLastRequestedDefaultTokenId )
        {
            // An audio change was previously OK'ed
            m_dstrDefaultTokenIdBeforeOK = m_dstrLastRequestedDefaultTokenId;

            // The current default could be different if the user OK'ed a change
            // but did not apply it
            m_fChangesToCommit = ( 0 != wcsicmp( m_dstrCurrentDefaultTokenId, 
                m_dstrDefaultTokenIdBeforeOK ) );
        }
        else
        {
            // No audio change was previously OK'ed
            if ( !m_dstrDefaultTokenIdBeforeOK )
            {
                m_dstrDefaultTokenIdBeforeOK = m_dstrCurrentDefaultTokenId;
            }
        }

        if (wcsicmp(m_dstrDefaultTokenIdBeforeOK, pszMMSysEnum) == 0)
        {
            // This message will cause the check button to be correct.
            ::SendMessage( ::GetDlgItem(m_hDlg, IDC_PREFERRED_MM_DEVICE), BM_SETCHECK, true, 0L );

            // This message will cause the volume button to be enabled or disabled as appropriate
            ::SendMessage( m_hDlg, WM_COMMAND, MAKELONG( IDC_PREFERRED_MM_DEVICE, BN_CLICKED ),
                (LPARAM) ::GetDlgItem( m_hDlg, IDC_PREFERRED_MM_DEVICE ) );
        }
        else
        {
            // This message will cause the check button to be correct.
            ::SendMessage( ::GetDlgItem(m_hDlg, IDC_THIS_DEVICE), BM_SETCHECK, true, 0L );
        }
    
        // Initialize the list of audio devices
        hr = SpInitTokenComboBox( ::GetDlgItem( hWnd, IDC_DEFAULT_DEVICE ),
            (m_iotype == eINPUT) ? SPCAT_AUDIOIN : SPCAT_AUDIOOUT );
    }
    
    if (S_OK == hr)
    {
        if ( BST_CHECKED == ::SendMessage( ::GetDlgItem( m_hDlg, IDC_THIS_DEVICE ), BM_GETCHECK, 0, 0 ) )
        {
            // Select the appropriate default token ID here by going through the 
            // stuff in the list and selecting the one whose token ID matches
            // m_dstrDefaultTokenIdBeforeOK
            int nTokens = (int)::SendDlgItemMessage( m_hDlg, IDC_DEFAULT_DEVICE, CB_GETCOUNT, 0, 0 );
            int iItem = 0;
            CSpDynamicString dstrTokenId;
            bool fFound = false;
            for ( iItem = 0; 
                (iItem < nTokens) && !fFound;
                iItem++ )
            {
                ISpObjectToken *pToken = (ISpObjectToken *) ::SendDlgItemMessage( m_hDlg,
                    IDC_DEFAULT_DEVICE, CB_GETITEMDATA, iItem, 0 );

                HRESULT hr = E_FAIL;
                if ( pToken )
                {
                    hr = pToken->GetId(&dstrTokenId);
                }

                if ( SUCCEEDED( hr ) )
                {
                    fFound = (0 == wcsicmp( m_dstrDefaultTokenIdBeforeOK, dstrTokenId ));
                }

                dstrTokenId = (WCHAR *) NULL;
            }
            SPDBG_ASSERT( fFound );
            ::SendDlgItemMessage( m_hDlg, IDC_DEFAULT_DEVICE, CB_SETCURSEL, iItem - 1, 0 );

            // This message will cause the volume button to be enabled or disabled as appropriate
            ::SendMessage( m_hDlg, WM_COMMAND, MAKELONG( IDC_THIS_DEVICE, BN_CLICKED ),
                (LPARAM) ::GetDlgItem( m_hDlg, IDC_THIS_DEVICE ) );
        }

        ::SetCursor( ::LoadCursor( NULL, IDC_ARROW ) );
    }
    else
    {
        WCHAR szError[ MAX_LOADSTRING ];
        WCHAR szIO[ MAX_LOADSTRING ];
        WCHAR szErrorTemplate[ MAX_LOADSTRING ];
        ::LoadString( _Module.GetResourceInstance(), IDS_NO_DEVICES, szErrorTemplate, sp_countof( szErrorTemplate ) );
        ::LoadString( _Module.GetResourceInstance(), (eINPUT == m_iotype) ? IDS_INPUT : IDS_OUTPUT, szIO, sp_countof( szIO ) );
        swprintf( szError, szErrorTemplate, szIO );
        ::MessageBox( m_hDlg, szError, NULL, MB_ICONEXCLAMATION | g_dwIsRTLLayout );

        if ( FAILED( hr ) )
        {
            ::EndDialog( m_hDlg, -1 );
        }
        else
        {
            ::EnableWindow( ::GetDlgItem( m_hDlg, IDC_THIS_DEVICE ), FALSE );
            ::EnableWindow( ::GetDlgItem( m_hDlg, IDC_DEFAULT_DEVICE ), FALSE );
            ::EnableWindow( ::GetDlgItem( m_hDlg, IDC_PREFERRED_MM_DEVICE ), FALSE );
            ::EnableWindow( ::GetDlgItem( m_hDlg, IDC_AUDIO_PROPERTIES ), FALSE );
            ::EnableWindow( ::GetDlgItem( m_hDlg, ID_TTS_VOL ), FALSE );
        }
    }
} /* CAudioDlg::OnInitDialog */

/*****************************************************************************
* CAudioDlg::OnDestroy *
*----------------------*
*   Description:
*       Destruction
****************************************************************** BECKYW ***/
void CAudioDlg::OnDestroy()
{
    SPDBG_FUNC( "CAudioDlg::OnDestroy" );

    SpDestroyTokenComboBox( ::GetDlgItem( m_hDlg, IDC_DEFAULT_DEVICE ) );
} /* CAudioDlg::OnDestroy */

/*****************************************************************************
* CAudioDlg::OnApply *
*--------------------*
*   Description:
*       Set user specified options
****************************************************************** BECKYW ***/
HRESULT CAudioDlg::OnApply()
{
    SPDBG_FUNC( "CAudioDlg::OnApply" );

    if ( !m_dstrLastRequestedDefaultTokenId )
    {
        // nothing to apply
        return S_FALSE;
    }

    HRESULT hr;
    CComPtr<ISpObjectTokenCategory> cpCategory;
    hr = SpGetCategoryFromId(
            m_iotype == eINPUT 
                ? SPCAT_AUDIOIN 
                : SPCAT_AUDIOOUT,
            &cpCategory);

    if ( SUCCEEDED( hr ) )
    {
        hr = cpCategory->SetDefaultTokenId( m_dstrLastRequestedDefaultTokenId );
    }

    // Next time we bring this up we should show the actual default
    m_dstrLastRequestedDefaultTokenId = (WCHAR *) NULL;
    m_dstrDefaultTokenIdBeforeOK = (WCHAR *) NULL;

    return hr;
} /* CAudioDlg::OnApply */

/*****************************************************************************
* CAudioDlg::GetRequestedDefaultTokenID *
*---------------------------------------*
*   Description:
*       Looks at the UI and gets the token ID that the user wants to switch 
*       to.  This is returned in pwszNewID.
*   Return:
*       Number of characters in the ID
****************************************************************** BECKYW ***/
UINT CAudioDlg::GetRequestedDefaultTokenID( WCHAR *pwszNewID, UINT cLength )
{
    if ( !pwszNewID )
    {
        return 0;
    }

    CComPtr<ISpObjectTokenCategory> cpCategory;
    HRESULT hr = SpGetCategoryFromId(
            m_iotype == eINPUT 
                ? SPCAT_AUDIOIN 
                : SPCAT_AUDIOOUT,
            &cpCategory);

    if (SUCCEEDED(hr))
    {
        if( ::SendMessage( ::GetDlgItem(m_hDlg, IDC_PREFERRED_MM_DEVICE), BM_GETCHECK, 0, 0L ) == BST_CHECKED )
        {
            const WCHAR *pwszMMSysAudioID = (m_iotype == eINPUT) ? 
                                            SPMMSYS_AUDIO_IN_TOKEN_ID : 
                                            SPMMSYS_AUDIO_OUT_TOKEN_ID;
            UINT cMMSysAudioIDLength = wcslen( pwszMMSysAudioID );
            UINT cRet = __min( cLength - 1, cMMSysAudioIDLength );
            wcsncpy( pwszNewID, pwszMMSysAudioID, cRet );
            pwszNewID[ cRet ] = 0;

            return cRet;
        }
        else
        {
            ISpObjectToken *pToken = SpGetCurSelComboBoxToken( ::GetDlgItem( m_hDlg, IDC_DEFAULT_DEVICE ) );
            if (pToken)
            {
                CSpDynamicString dstrTokenId;
                hr = pToken->GetId(&dstrTokenId);

                if (SUCCEEDED(hr))
                {
                    UINT cIDLength = wcslen( dstrTokenId );
                    UINT cRet = __min( cLength - 1, cIDLength );
                    wcsncpy( pwszNewID, dstrTokenId, cRet );
                    pwszNewID[ cRet ] = 0;

                    return cRet;

                }
            }
        }
    }

    // There was an error
    return 0;
}   /* CAudioDlg::GetRequestedDefaultTokenID */

/*****************************************************************************
* CAudioDlg::GetAudioToken *
*--------------------------*
*   Description:
*       Returns an interface to the currently selected token. Currently this
*       can either be the 'preferred' device in which case, the object is created
*       on the fly. Or it can be one from the drop-down list which contains an
*       attached token. In this case, it needs to be addref'd so that the returned
*       token is consistent regardless of the source inside this function.
*
*       NB: This requires the caller to call release on the instance.
*
*   Return:
**************************************************************** AGARSIDE ***/
HRESULT CAudioDlg::GetAudioToken(ISpObjectToken **ppToken)
{
    HRESULT hr = S_OK;
    *ppToken = NULL;

    if (IsPreferredDevice())
    {
        hr = SpGetTokenFromId((this->IsInput())?(SPMMSYS_AUDIO_IN_TOKEN_ID):(SPMMSYS_AUDIO_OUT_TOKEN_ID),
                              ppToken, 
                              FALSE);
        SPDBG_ASSERT(SUCCEEDED(hr));
    }
    else
    {
        *ppToken = SpGetCurSelComboBoxToken( GetDlgItem(this->GetHDlg(), IDC_DEFAULT_DEVICE) );
        (*ppToken)->AddRef();
    }

    return S_OK;
}

/*****************************************************************************
* CAudioDlg::UpdateDlgUI *
*------------------------*
*   Description:
*   Return:
**************************************************************** AGARSIDE ***/
HRESULT CAudioDlg::UpdateDlgUI(ISpObjectToken *pToken)
{
    SPDBG_FUNC("CAudioDlg::UpdateDlgUI");
    HRESULT hr = S_OK;
    BOOL fSupported;
    CComPtr<ISpObjectWithToken> cpSpObjectWithToken;

    // Get hold of ISpObjectWithToken
	hr = pToken->CreateInstance(
			NULL, CLSCTX_INPROC_SERVER, IID_ISpObjectWithToken,
			(void **)&cpSpObjectWithToken);

    // Update volume button status.
    fSupported = FALSE;
    if (SUCCEEDED(hr))
    {
        pToken->IsUISupported(SPDUI_AudioVolume, NULL, 0, cpSpObjectWithToken, &fSupported);
        ::EnableWindow( ::GetDlgItem(this->GetHDlg(), ID_TTS_VOL), fSupported);
    }

    // Update UI button status.
    fSupported = FALSE;
    if (SUCCEEDED(hr))
    {
        pToken->IsUISupported(SPDUI_AudioProperties, NULL, 0, cpSpObjectWithToken, &fSupported);
        ::EnableWindow( ::GetDlgItem(this->GetHDlg(), IDC_AUDIO_PROPERTIES), fSupported);
    }

    SPDBG_REPORT_ON_FAIL(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\audiodlg.h ===
/*******************************************************************************
* AudioDlg.h *
*------------*
*   Description:
*       This is the header file for the default audio input/output dialog.
*-------------------------------------------------------------------------------
*  Created By: BECKYW                            Date: 10/15/99
*  Copyright (C) 1999 Microsoft Corporation
*  All Rights Reserved
*
*******************************************************************************/
#ifndef _AUDIODLG_H
#define _AUDIODLG_H

#define MAX_LOADSTRING      1000
#define WM_AUDIOINFO        WM_USER + 20

typedef enum IOTYPE
{
    eINPUT,
    eOUTPUT
};

typedef struct AUDIOINFO
{
    ISpObjectToken  *pToken;
}   AUDIOINFO;


class CAudioDlg
{
  private:
    BOOL                        m_bPreferredDevice;
    HWND                        m_hDlg;
    const IOTYPE                m_iotype;
    CSpDynamicString            m_dstrDefaultTokenIdBeforeOK;
    CSpDynamicString            m_dstrCurrentDefaultTokenId;
    
    // Indicates whether a change was made that will have to be committed
    bool                        m_fChangesToCommit;

    bool                        m_fChangesSinceLastTime;

    // Indicates if any changes have been made since the last apply
    // that need to be reflected in the UI
    CSpDynamicString            m_dstrLastRequestedDefaultTokenId;

    // holds the process information for the volume control
    PROCESS_INFORMATION         m_pi;   

    // Will decide between W() and A() versions
    CSpUnicodeSupport           m_unicode;

  public:
    CAudioDlg(IOTYPE iotype) :
        m_bPreferredDevice(true),
        m_hDlg(NULL),
        m_iotype(iotype),
        m_fChangesToCommit( false ),
        m_fChangesSinceLastTime( false ),
        m_dstrLastRequestedDefaultTokenId( (WCHAR *) NULL ),
        m_dstrCurrentDefaultTokenId( (WCHAR *) NULL )
    {
        m_pi.hProcess = NULL;
    }


    HRESULT                     OnApply(void);
    bool                        IsAudioDeviceChanged()
                                    { return m_fChangesToCommit; }
    bool                        IsAudioDeviceChangedSinceLastTime()
                                    { return m_fChangesSinceLastTime; }
  private:
    void                        OnDestroy(void);
    void                        OnInitDialog(HWND hWnd);
    HWND                        GetHDlg(void) 
                                { return m_hDlg; }
    BOOL                        IsPreferredDevice(void) 
                                { return m_bPreferredDevice; }
    void                        SetPreferredDevice( BOOL b ) 
                                { m_bPreferredDevice = b; }

    UINT                        GetRequestedDefaultTokenID( WCHAR *pwszNewID, UINT cLength );
    HRESULT                     GetAudioToken(ISpObjectToken **ppToken);
    HRESULT                     UpdateDlgUI(ISpObjectToken *pToken);
    BOOL                        IsInput(void)
                                { return (m_iotype == eINPUT); };

    friend INT_PTR CALLBACK AudioDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

};

#endif  // _AUDIODLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\makefile.inc ===
SelfRegister :
!if defined(MAKEDLL)
	copy /Y $(O)\sapi.cpl $(SYSTEMROOT)\system32\sapi.cpl
	copy /Y $(O)\sapi.cpl ..\sapi\$(O)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\helpresource.h ===
#define IDH_LIST_TTS			101  
#define IDH_TTS_ADV				102
#define IDH_OUTPUT_SETTINGS		103
#define IDH_SLIDER_SPEED		104
#define IDH_EDIT_SPEAK			105
#define IDH_SPEAK				106

#define IDH_USER				201
#define IDH_SETTINGS			202
#define IDH_ADD					203
#define IDH_DELETE				204

#define IDH_ENGINES				301
#define IDH_SR_ADV				302
#define IDH_USERTRAINING		303
#define IDH_PROGRESS1			304
#define IDH_AUD_IN				305
#define IDH_MICWIZ				306

#define IDH_BUILDER				401
#define IDH_VEDITOR				402
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\picture.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "picture.h"


/////////////////////////////////////////////////////////////////////////////
// CPicture properties

long CPicture::GetHandle()
{
	long result;
	GetProperty(0x0, VT_I4, (void*)&result);
	return result;
}

long CPicture::GetHPal()
{
	long result;
	GetProperty(0x2, VT_I4, (void*)&result);
	return result;
}

void CPicture::SetHPal(long propVal)
{
	SetProperty(0x2, VT_I4, propVal);
}

short CPicture::GetType()
{
	short result;
	GetProperty(0x3, VT_I2, (void*)&result);
	return result;
}

long CPicture::GetWidth()
{
	long result;
	GetProperty(0x4, VT_I4, (void*)&result);
	return result;
}

long CPicture::GetHeight()
{
	long result;
	GetProperty(0x5, VT_I4, (void*)&result);
	return result;
}

/////////////////////////////////////////////////////////////////////////////
// CPicture operations
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\ownerdrawui.inl ===
/*******************************************************************************
* OwnerDrawUI.inl *
*-----------------*
*   Description:
*       This is the header file for user-interface helper functions.  Note that
*       unlike SpHelper.H, this file requires the use of ATL.
*       Unlike spuihelp.h, this will take care of displaying DBCS characters
*       (non-native-codepage)
*
*   PLEASE NOTE: In order for this to work, the caller must I mean must 
*       process WM_DRAWITEM messages and call DrawODTokenListItem()!!! 
*-------------------------------------------------------------------------------
*   Copyright (c) Microsoft Corporation. All rights reserved.
*******************************************************************************/

#ifndef __sapi_h__
#include <sapi.h>
#endif

#ifndef SPError_h
#include <SPError.h>
#endif

#ifndef SPDebug_h
#include <SPDebug.h>
#endif

#ifndef __ATLBASE_H__
#include <ATLBASE.h>
#endif

#ifndef __ATLCONV_H__
#include <ATLCONV.H>
#endif

inline HRESULT InitODTokenList(UINT MsgAddString, UINT MsgSetItemData, UINT MsgSetCurSel,
                               HWND hwnd, const WCHAR * pszCatName,
                               const WCHAR * pszRequiredAttrib, const WCHAR * pszOptionalAttrib)
{
    HRESULT hr;
    ISpObjectToken * pToken;        // NOTE:  Not a CComPtr!  Be Careful.
    CComPtr<IEnumSpObjectTokens> cpEnum;
    hr = SpEnumTokens(pszCatName, pszRequiredAttrib, pszOptionalAttrib, &cpEnum);
    UINT cItems = 0;
    if (hr == S_OK)
    {
        bool fSetDefault = false;
        while (cpEnum->Next(1, &pToken, NULL) == S_OK)
        {
            if (SUCCEEDED(hr))
            {
                // This sets the thing as item data, since this CB is ownerdraw
                LRESULT i = ::SendMessage(hwnd, MsgAddString, 0, (LPARAM) pToken);

                if (i == CB_ERR || i == CB_ERRSPACE)    // Note:  CB_ and LB_ errors are identical values...
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    if (!fSetDefault)
                    {
                        ::SendMessage(hwnd, MsgSetCurSel, i, 0);
                        fSetDefault = true;
                    }

                    cItems++;
                }
            }
            if (FAILED(hr))
            {
                pToken->Release();
            }
        }
    }
    else
    {
        hr = SPERR_NO_MORE_ITEMS;
    }

    if ( SUCCEEDED( hr ) && (0 == cItems) )
    {
        hr = S_FALSE;
    }

    return hr;
}

inline HRESULT InitODTokenComboBox(HWND hwnd, const WCHAR * pszCatName,
                                   const WCHAR * pszRequiredAttrib = NULL, const WCHAR * pszOptionalAttrib = NULL)
{
    return InitODTokenList(CB_ADDSTRING, CB_SETITEMDATA, CB_SETCURSEL, hwnd, pszCatName, pszRequiredAttrib, pszOptionalAttrib);
}

//
//  Dont call this function directly.  Use DestoyTokenODComboBox or DestroyTokenODListBox.
//
inline void DestroyODTokenList(UINT MsgGetCount, UINT MsgGetItemData, HWND hwnd)
{
    LRESULT c = ::SendMessage(hwnd, MsgGetCount, 0, 0);
    for (LRESULT i = 0; i < c; i++)
    {
        IUnknown * pUnkObj = (IUnknown *)::SendMessage(hwnd, MsgGetItemData, i, 0);
        if (pUnkObj)
        {
            pUnkObj->Release();
        }
    }
}

inline void DestroyODTokenComboBox(HWND hwnd)
{
    DestroyODTokenList(CB_GETCOUNT, CB_GETITEMDATA, hwnd);
}

inline ISpObjectToken * GetODComboBoxToken(HWND hwnd, WPARAM Index)
{
    return (ISpObjectToken *)::SendMessage(hwnd, CB_GETITEMDATA, Index, 0);
}

inline ISpObjectToken * GetCurSelODComboBoxToken(HWND hwnd)
{
    LRESULT i = ::SendMessage(hwnd, CB_GETCURSEL, 0, 0);
    return (i == CB_ERR) ? NULL : GetODComboBoxToken(hwnd, i);
}

inline void UpdateCurSelODComboBoxToken(HWND hwnd)
{
    // Repainting the window will get the correct text displayed
    ::InvalidateRect( hwnd, NULL, TRUE );
}

// Don't call this directly.  
inline HRESULT AddTokenToODList(UINT MsgAddString, UINT MsgSetItemData, UINT MsgSetCurSel, HWND hwnd, ISpObjectToken * pToken)
{
    HRESULT hr = S_OK;
    USES_CONVERSION;
    LRESULT i = ::SendMessage(hwnd, MsgAddString, 0, (LPARAM)pToken);
    if (i == CB_ERR || i == CB_ERRSPACE)    // Note:  CB_ and LB_ errors are identical values...
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        ::SendMessage(hwnd, MsgSetCurSel, i, 0);
        pToken->AddRef();
    }
}

inline HRESULT AddTokenToODComboBox(HWND hwnd, ISpObjectToken * pToken)
{
    return AddTokenToODList(CB_ADDSTRING, CB_SETITEMDATA, CB_SETCURSEL, hwnd, pToken);
}

// Don't call this directly
inline HRESULT DeleteCurSelODToken(UINT MsgGetCurSel, UINT MsgSetCurSel, UINT MsgGetItemData, UINT MsgDeleteString, HWND hwnd)
{
    HRESULT hr = S_OK;
    LRESULT i = ::SendMessage(hwnd, MsgGetCurSel, 0, 0);
    if (i == CB_ERR)
    {
        hr = S_FALSE;
    }
    else
    {
        ISpObjectToken * pToken = (ISpObjectToken *)::SendMessage(hwnd, MsgGetItemData, i, 0);
        if (pToken)
        {
            pToken->Release();
        }
        ::SendMessage(hwnd, MsgDeleteString, i, 0);
        ::SendMessage(hwnd, MsgSetCurSel, i, 0);
    }
    return hr;
}

inline HRESULT DeleteCurSelODComboBoxToken(HWND hwnd)
{
    return DeleteCurSelODToken(CB_GETCURSEL, CB_SETCURSEL, CB_GETITEMDATA, CB_DELETESTRING, hwnd);
}

// The owner of the owner-draw control MUST call this upon receiving a WM_DRAWITEM message
void DrawODTokenListItem( LPDRAWITEMSTRUCT lpdis )
{
    UINT oldTextAlign = GetTextAlign(lpdis->hDC);

    COLORREF clrfTextOld = ::GetTextColor( lpdis->hDC );
    COLORREF clrfBkOld = ::GetBkColor( lpdis->hDC );

    // Get the item state and change colors accordingly
    if ( (ODS_DISABLED & lpdis->itemState) || (-1 == lpdis->itemID) )
    {
        ::SetTextColor( lpdis->hDC, ::GetSysColor( COLOR_GRAYTEXT ) );
    }
    else if ( ODS_SELECTED & lpdis->itemState )
    {
        // Set the text background and foreground colors
        SetTextColor(lpdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        SetBkColor(lpdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
    }

    UINT options = ETO_OPAQUE | ETO_CLIPPED;

    // Strings are stored as item data
    CSpDynamicString dstrName;
    if ( -1 != lpdis->itemID )
    {
        SpGetDescription( GetODComboBoxToken( lpdis->hwndItem, lpdis->itemID ), &dstrName );
    }
    else
    {
        dstrName = L"";
    }
  
    int cStringLen = wcslen( dstrName );

    SetTextAlign(lpdis->hDC, TA_UPDATECP);
    MoveToEx(lpdis->hDC, lpdis->rcItem.left, lpdis->rcItem.top, NULL);
    ExtTextOutW(lpdis->hDC,
                lpdis->rcItem.left, lpdis->rcItem.top,
                options,
                &lpdis->rcItem,
                dstrName, 
                cStringLen,
                NULL);

    ::SetTextColor( lpdis->hDC, clrfTextOld );
    ::SetBkColor( lpdis->hDC, clrfBkOld );

    SetTextAlign(lpdis->hDC, oldTextAlign);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\progressbar.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "progressbar.h"

// Dispatch interfaces referenced by this interface
#include "Picture.h"

/////////////////////////////////////////////////////////////////////////////
// CProgressBar

IMPLEMENT_DYNCREATE(CProgressBar, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CProgressBar properties

/////////////////////////////////////////////////////////////////////////////
// CProgressBar operations

float CProgressBar::GetMax()
{
	float result;
	InvokeHelper(0x1, DISPATCH_PROPERTYGET, VT_R4, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetMax(float newValue)
{
	static BYTE parms[] =
		VTS_R4;
	InvokeHelper(0x1, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

float CProgressBar::GetMin()
{
	float result;
	InvokeHelper(0x2, DISPATCH_PROPERTYGET, VT_R4, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetMin(float newValue)
{
	static BYTE parms[] =
		VTS_R4;
	InvokeHelper(0x2, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

long CProgressBar::GetMousePointer()
{
	long result;
	InvokeHelper(0x3, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetMousePointer(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x3, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

CPicture CProgressBar::GetMouseIcon()
{
	LPDISPATCH pDispatch;
	InvokeHelper(0x4, DISPATCH_PROPERTYGET, VT_DISPATCH, (void*)&pDispatch, NULL);
	return CPicture(pDispatch);
}

void CProgressBar::SetRefMouseIcon(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x4, DISPATCH_PROPERTYPUTREF, VT_EMPTY, NULL, parms,
		 newValue);
}

void CProgressBar::SetMouseIcon(LPDISPATCH newValue)
{
	static BYTE parms[] =
		VTS_DISPATCH;
	InvokeHelper(0x4, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

float CProgressBar::GetValue()
{
	float result;
	InvokeHelper(0x5, DISPATCH_PROPERTYGET, VT_R4, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetValue(float newValue)
{
	static BYTE parms[] =
		VTS_R4;
	InvokeHelper(0x5, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 newValue);
}

long CProgressBar::GetOLEDropMode()
{
	long result;
	InvokeHelper(0x60f, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetOLEDropMode(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x60f, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CProgressBar::GetAppearance()
{
	long result;
	InvokeHelper(DISPID_APPEARANCE, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetAppearance(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(DISPID_APPEARANCE, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CProgressBar::GetBorderStyle()
{
	long result;
	InvokeHelper(DISPID_BORDERSTYLE, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetBorderStyle(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(DISPID_BORDERSTYLE, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

BOOL CProgressBar::GetEnabled()
{
	BOOL result;
	InvokeHelper(DISPID_ENABLED, DISPATCH_PROPERTYGET, VT_BOOL, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetEnabled(BOOL bNewValue)
{
	static BYTE parms[] =
		VTS_BOOL;
	InvokeHelper(DISPID_ENABLED, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 bNewValue);
}

long CProgressBar::GetHWnd()
{
	long result;
	InvokeHelper(DISPID_HWND, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CProgressBar::OLEDrag()
{
	InvokeHelper(0x610, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

long CProgressBar::GetOrientation()
{
	long result;
	InvokeHelper(0x6, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetOrientation(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x6, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CProgressBar::GetScrolling()
{
	long result;
	InvokeHelper(0x7, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CProgressBar::SetScrolling(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x7, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

void CProgressBar::Refresh()
{
	InvokeHelper(DISPID_REFRESH, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\picture.h ===
#if !defined(AFX_PICTURE_H__5245593F_5C46_40FB_9DE4_69AD6DD0648A__INCLUDED_)
#define AFX_PICTURE_H__5245593F_5C46_40FB_9DE4_69AD6DD0648A__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CPicture wrapper class

class CPicture : public COleDispatchDriver
{
public:
	CPicture() {}		// Calls COleDispatchDriver default constructor
	CPicture(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	CPicture(const CPicture& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:
	long GetHandle();
	long GetHPal();
	void SetHPal(long);
	short GetType();
	long GetWidth();
	long GetHeight();

// Operations
public:
	// method 'Render' not emitted because of invalid return type or parameter type
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PICTURE_H__5245593F_5C46_40FB_9DE4_69AD6DD0648A__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\progressbar.h ===
#if !defined(AFX_PROGRESSBAR_H__78F8DA9B_4EF4_4500_97B6_647141CA2280__INCLUDED_)
#define AFX_PROGRESSBAR_H__78F8DA9B_4EF4_4500_97B6_647141CA2280__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


// Dispatch interfaces referenced by this interface
class CPicture;

/////////////////////////////////////////////////////////////////////////////
// CProgressBar wrapper class

class CProgressBar : public CWnd
{
protected:
	DECLARE_DYNCREATE(CProgressBar)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x35053a22, 0x8589, 0x11d1, { 0xb1, 0x6a, 0x0, 0xc0, 0xf0, 0x28, 0x36, 0x28 } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
	float GetMax();
	void SetMax(float newValue);
	float GetMin();
	void SetMin(float newValue);
	long GetMousePointer();
	void SetMousePointer(long nNewValue);
	CPicture GetMouseIcon();
	void SetRefMouseIcon(LPDISPATCH newValue);
	void SetMouseIcon(LPDISPATCH newValue);
	float GetValue();
	void SetValue(float newValue);
	long GetOLEDropMode();
	void SetOLEDropMode(long nNewValue);
	long GetAppearance();
	void SetAppearance(long nNewValue);
	long GetBorderStyle();
	void SetBorderStyle(long nNewValue);
	BOOL GetEnabled();
	void SetEnabled(BOOL bNewValue);
	long GetHWnd();
	void OLEDrag();
	long GetOrientation();
	void SetOrientation(long nNewValue);
	long GetScrolling();
	void SetScrolling(long nNewValue);
	void Refresh();
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_PROGRESSBAR_H__78F8DA9B_4EF4_4500_97B6_647141CA2280__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SpeechCPL.rc
//
#define IDS_NAME                        1
#define IDS_DESCRIPTION                 2
#define IDS_CAPTION                     3
#define ID_TTS_VOL                      3
#define IDS_E_INSTALL                   4
#define IDS_E_ENGINE                    5
#define IDS_E_MICWIZARD                 6
#define IDS_TREE_ROOT                   7
#define IDS_TREE_INPUT                  8
#define IDS_TREE_OUTPUT                 9
#define IDS_LANGID                      10
#define IDS_DEF_VOICE_TEXT              11
#define IDS_ENGINE_SETTINGS             12
#define IDI_CPL                         101
#define IDI_MIC                         101
#define IDB_OUTPUT                      103
#define IDB_INPUT                       104
#define IDB_LANG                        107
#define IDS_AGE_UNKNOWN                 107
#define IDB_ENGINE                      108
#define IDS_AGE_YOUNG                   108
#define IDB_TTSMODE                     109
#define IDS_AGE_NOTYOUNG                109
#define IDS_GENDER_UNKNOWN              110
#define IDS_GENDER_MALE                 111
#define IDS_GENDER_FEMALE               112
#define IDD_DEBUG                       113
#define IDS_USER_DEFAULT                113
#define IDS_TTSNAME                     115
#define IDD_DEFAULT_VOICE               116
#define IDD_TTS                         116
#define IDS_LANGUAGE                    116
#define IDD_MM_INPUTS                   117
#define IDD_SR                          117
#define IDS_GENDER                      117
#define IDS_VENDOR                      118
#define IDD_USER                        119
#define IDS_TTSDESCRIPTION              119
#define IDD_USER_NAME                   120
#define IDD_USER_PROP                   120
#define IDS_PREVIEW                     120
#define IDB_CHECKMARK                   121
#define IDS_STOP_PREVIEW                121
#define IDB_TTSPROP                     122
#define IDS_DEFAULT_SPEECH_INPUT        122
#define IDI_TTSICON                     123
#define IDS_DEFAULT_SPEECH_OUTPUT       123
#define IDD_AUDIO_DEFAULT               124
#define IDS_DEFAULT_INPUT               124
#define IDS_DEFAULT_OUTPUT              125
#define IDD_ENVIRONMENT                 125
#define IDS_CURRENT_USER                126
#define IDD_VOCAB                       126
#define IDD_DICT_RULES                  127
#define IDS_DESCRIPT                    127
#define IDS_LANG_DESC                   128
#define IDI_PEOPLE                      129
#define IDS_VEND_DESC                   129
#define IDD_SR_ADV                      130
#define IDS_DATE_ADV                    130
#define IDI_VOL                         132
#define IDS_DUP_NAME                    132
#define IDS_PREFERRED_INPUT             133
#define IDD_PROF_WIZ                    134
#define IDS_PREFERRED_OUTPUT            134
#define IDD_PROF_PROP                   136
#define IDS_SPECIFIC_INPUT              137
#define IDD_ABOUT                       137
#define IDS_SPECIFIC_OUTPUT             138
#define IDI_SAPICPL                     138
#define IDS_ENGINE_LIST_NAME            139
#define IDS_VOICE_LIST_NAME             140
#define IDS_PROFILE_LIST_NAME           141
#define IDS_ASK_CONFIRM                 142
#define IDS_ASK_TITLE                   143
#define IDS_PROPERTIES                  144
#define IDS_RENAME                      145
#define IDS_CONTEXT_WARNING             146
#define IDS_GETTOK_WARNING              147
#define IDS_AUDIO_WARNING               148
#define IDS_FORMAT_WARNING              149
#define IDS_METER_WARNING               150
#define IDS_DEFAULT_WARNING             151
#define IDS_DEFAULT_ENGINE_WARNING      151
#define IDS_UISUPPORT_WARNING           152
#define IDS_RECOSET_WARNING             153
#define IDS_CTXT_WARNING                154
#define IDS_WNDMESS_WARNING             155
#define ID_CONTROL_PANEL_GRAMMAR        156
#define IDS_REMOVE_WARNING              157
#define IDS_AUDIO_DEVICE_WARNING        159
#define IDS_ENGINE_IN_USE_WARNING       160
#define IDS_RECOSTATE_PROBLEM           161
#define IDS_PROFILE_WARNING             162
#define IDS_CANNOTAPPLY                 163
#define IDS_OUTOFMEMORY                 164
#define IDS_AUDIO_CHANGE_FAILED         166
#define IDS_COINITIALIZE_FAILED         167
#define IDD_SPEECH                      206
#define IDC_MIC                         214
#define IDC_TREE                        1002
#define IDC_PROPERTIES                  1004
#define IDC_ABOUT                       1005
#define IDC_TRAINING                    1006
#define IDC_USERTRAINING                1006
#define IDC_PRONUNCIATION               1007
#define IDC_FUNC_TRACE                  1007
#define IDC_AUD_IN                      1007
#define IDC_PARAM_INFO                  1008
#define IDC_SPECIALHANDLING             1009
#define IDC_DUMP_INFO                   1009
#define IDC_DEF_VOICE                   1010
#define IDC_EDIT_SPEAK                  1017
#define IDC_SPEAK                       1019
#define IDC_MMINPUT_COMBO               1020
#define IDC_SET_AS_CURRENT              1020
#define IDC_RUN_MICWIZ                  1022
#define IDC_SHARE_INPUT                 1023
#define IDC_ENGINE_DEFAULT              1024
#define IDC_ENABLE_CHECK                1025
#define IDC_STANDARD_IN                 1026
#define IDC_THIS_IN                     1027
#define IDC_STANDARD_IN_CB              1028
#define IDC_DEFAULT_INPUT               1028
#define IDC_THIS_IN_CB                  1029
#define IDC_INPUT_SETTINGS              1030
#define IDC_DEFAULT_OUTPUT              1031
#define IDC_SR_ENGINE                   1032
#define IDC_BUTTON1                     1033
#define IDC_MICWIZ                      1033
#define IDC_OUTPUT_SETTINGS             1033
#define IDC_CREATE_USER                 1033
#define IDC_ADD_LANG                    1033
#define IDC_ADD_USER                    1033
#define IDC_RESTORE                     1033
#define IDC_BUILDER                     1033
#define IDC_MODIFY_OLD                  1033
#define IDC_ABOUT_HELP                  1033
#define IDC_PREFERRED_INPUT             1034
#define IDC_PREFERRED_MM_INPUT          1034
#define IDC_ADD                         1034
#define IDC_TESTMIC                     1034
#define IDC_THIS_INPUT                  1035
#define IDC_SR_ADV                      1035
#define IDC_DELETE_OLD                  1035
#define IDC_PREFERRED_OUTPUT            1036
#define IDC_PREFERRED_MM_OUTPUT         1036
#define IDC_EXPORT                      1036
#define IDC_DELETE                      1036
#define IDC_THIS_OUTPUT                 1037
#define IDC_IMPORT                      1037
#define IDC_MODIFY                      1037
#define IDC_IGNORE_ASSERTS              1038
#define IDC_DELETE_USER                 1041
#define IDC_USER_PROPS                  1042
#define IDC_USER_LIST                   1043
#define IDC_USER_NAME                   1044
#define IDC_USER_SAVE                   1044
#define IDC_SET_DEFAULT                 1044
#define IDC_FEMALE                      1045
#define IDC_MALE                        1046
#define IDC_AGE                         1047
#define IDC_LANG_LIST                   1048
#define IDC_DEL_LANG                    1049
#define IDC_COMBO_AGE                   1050
#define IDC_COMBO2                      1051
#define IDC_COMBO_GENDER                1051
#define IDC_SLIDER1                     1052
#define IDC_COMBO4                      1054
#define IDC_EDIT_LCID                   1056
#define IDC_DEF_STATUS                  1057
#define IDC_ENGINEPROPERTIES            1058
#define IDC_LIST_TTS                    1064
#define IDC_CURRENTUSER                 1065
#define IDC_DIRECTIONS                  1066
#define IDC_GROUP_PREVIEWVOICE          1068
#define IDC_GROUP_VOICESPEED            1069
#define IDC_SLIDER_SPEED                1070
#define IDC_THIS_DEVICE                 1071
#define IDC_THIS_DEVICE2                1072
#define IDC_PREFERRED_MM_DEVICE         1073
#define IDC_DEFAULT_DEVICE              1074
#define IDC_AUDIO_GROUPBOX              1075
#define IDC_USER                        1077
#define IDC_ENGINES                     1080
#define IDC_LAST_TRAIN_DATE             1082
#define IDC_ADVICE                      1083
#define IDC_PROGRESS1                   1084
#define IDC_PRON_SENS                   1087
#define IDC_ACC_RRT                     1088
#define IDC_DATE_ADV                    1089
#define IDC_COMBO1                      1090
#define IDC_COMBO_VOICES                1090
#define IDC_TTS_ADV                     1091
#define IDC_VEDITOR                     1092
#define IDC_LANG_COMBO                  1093
#define ID_NEXT                         1094
#define IDC_PROF_ICON                   1099
#define IDC_PROF_CAPTION                1100
#define IDC_PROF_GROUP                  1101
#define IDC_SR_ICON                     1102
#define IDC_SR_CAPTION                  1103
#define IDC_SR_LIST_CAP                 1104
#define IDC_TRAIN_GROUP                 1105
#define IDC_IN_GROUP                    1106
#define IDC_MIC_CAP                     1107
#define IDC_MIC_INST                    1108
#define IDC_TTS_ICON                    1109
#define IDC_TTS_CAP                     1110
#define IDC_SLOW                        1111
#define IDC_NORMAL                      1112
#define IDC_FAST                        1113
#define IDC_VOCAB_GRP                   1114
#define IDC_VOCAB_ICON1                 1115
#define IDC_VOCAB_ICON2                 1116
#define IDC_BLD_INST                    1117
#define IDC_EDT_CAP                     1118
#define IDC_MIC_ICON                    1120
#define IDC_TRN_ADVICE                  1121
#define IDC_CUSTOM1                     1124
#define IDC_AUDIO_PROPERTIES            1125
#define IDS_AUDIO_PROPERTIES            1126
#define IDS_VOLUME                      1127
#define IDD_AUDIO_PROPERTIES            1128
#define IDC_ADVANCED_GROUPBOX           1129
#define IDC_AUTOMATIC_MM_LINE           1130
#define IDC_THIS_MM_LINE                1131
#define IDC_MM_LINE                     1132
#define IDC_THIS_MM_LINE2               1133
#define IDS_ADVANCED_GROUPBOX           1134
#define IDS_AUTOMATIC_MM_LINE           1135
#define IDS_THIS_MM_LINE                1136
#define IDC_DEVICE_NAME                 1137
#define IDS_THIS_MM_LINE2               1137
#define IDS_DEVICE_NAME                 1138
#define IDS_AUDIO_VOLUME                1139
#define IDC_COMBO_RECOGNIZERS           1140
#define IDS_ENGINE_SWITCH_ERROR         1140
#define IDS_RECOPROFILE_ADD_ERROR       1141
#define IDS_DEFAULT_PROFILE_NAME        1142
#define IDS_UNNAMED_RECOPROFILE         1143
#define IDC_VERSION_STATIC              1143
#define IDS_TTS_ERROR                   1144
#define IDC_STATC_SAPIVER               1144
#define IDC_STATIC_SAPIVER              1144
#define IDS_SPEAK_ERROR                 1145
#define IDC_CPL_SAPI4                   1145
#define IDS_NO_DEVICES                  1146
#define IDC_GROUP_SAPI4                 1146
#define IDS_INPUT                       1147
#define IDC_STATIC_SAPI4                1147
#define IDS_OUTPUT                      1148
#define IDS_SAPI_VERSION                1149
#define IDS_AUDIOIN_CHANGE_WARNING      1150
#define IDS_AUDIOOUT_CHANGE_WARNING     1151
#define IDS_DUP_NAME_DELETED            1152
#define IDS_TTSUI_ERROR                 1153
#define IDS_STRING1154                  1154
#define IDS_NO_IE5                      1155
#define IDS_SPECIFIC_INPUT2             1156
#define IDS_SPECIFIC_OUTPUT2            1157
#define IDS_UNSUPPORTED_LANG		1158
#define IDS_MAX_PROFILES_EXCEEDED	1159

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        139
#define _APS_NEXT_COMMAND_VALUE         40003
#define _APS_NEXT_CONTROL_VALUE         1148
#define _APS_NEXT_SYMED_VALUE           112
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\speechcpl.cpp ===
// SpeechCpl.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SpeechCplps.mk in the project directory.



#include "stdafx.h"
#include <initguid.h>
#include <assertwithstack.cpp>
#include "resource.h"
#include "stuff.h"
#include "sapiver.h"
#include <SpSatellite.h>

#define SAPI4CPL    L"speech.cpl"

#define SHLWAPIDLL "shlwapi.dll"


const CLSID LIBID_SPEECHCPLLib = { /* ae9b6e4a-dc9a-41cd-8d53-dcbc3673d5e2 */
    0xae9b6e4a,
    0xdc9a,
    0x41cd,
    {0x8d, 0x53, 0xdc, 0xbc, 0x36, 0x73, 0xd5, 0xe2}
  };


CComModule _Module;

BOOL IsIECurrentEnough();
BOOL g_fIEVersionGoodEnough = IsIECurrentEnough();
HINSTANCE g_hInstance;

CSpSatelliteDLL g_SatelliteDLL;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

// Forward definition of About dlgproc
INT_PTR CALLBACK AboutDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
bool IsSAPI4Installed();

/*****************************************************************************
* DllMain *
*---------*
*   Description:
*       DLL Entry Point
****************************************************************** MIKEAR ***/
#ifdef _WIN32_WCE
extern "C"
BOOL WINAPI DllMain(HANDLE hInst, DWORD dwReason, LPVOID /*lpReserved*/)
    HINSTANCE hInstance = (HINSTANCE)hInst;
#else
extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
#endif
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        g_hInstance = hInstance;
		_Module.Init(ObjectMap, g_hInstance, &LIBID_SPEECHCPLLib);
        SHFusionInitializeFromModuleID(hInstance, 124);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        SHFusionUninitialize();
    }
    return TRUE;    // ok
} /* DllMain */

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}



// Error Messages
#if 0
void Error(HWND hWnd, HRESULT hRes, UINT uResID)
{
    SPDBG_FUNC( "Error" );
    WCHAR	szErrorTemplate[256];
    WCHAR	szError[288];
    WCHAR	szCaption[128];
    HMODULE hMod;
    UINT	uFlags;
    DWORD	dwRes;
    LPVOID	pvMsg;
    int		iLen;

    // Load the caption for the error message box

    iLen = LoadString(_Module.GetResourceInstance(), IDS_CAPTION, szCaption, 128);

    SPDBG_ASSERT(iLen != 0);

    // Was a resource ID specified?

    if (uResID == 0xFFFFFFFF) {

	    // Nope. Use the HRESULT.

	    // Is it a Speech error? NOTE: we have to check this before
	    // system error messages because there are conflicts between
	    // some speech errors (e.g. 0x80040202) and system errors.

	    // NOTE NOTE NOTE!!! This is NOT perfect. Since we don't know
	    // the context of the error here we won't be able to distinguish
	    // whether the error is really a speech error or a system error.
	    // Since we use speech heavily and the system errors that conflict
	    // are unlikely to occur in here, we'll check the speech errors
	    // first.

	    uFlags = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM;

	    if ((hRes >= 0x80040200) && (hRes <= 0x80040502)) {

		    WCHAR szSpeechDll[_MAX_PATH];
		    WCHAR *pchWindows;

		    // NOTE NOTE NOTE: use GetSystemDirectory instead of
		    // GetWindowsDirectory. GetWindowsDirectory doesn't
		    // work without registry manipulation under Hydra.

		    GetSystemDirectory(szSpeechDll, _MAX_PATH);

		    pchWindows = wcsrchr(szSpeechDll, '\\');

		    if (pchWindows)
			    *pchWindows = 0;

		    wcscat(szSpeechDll, kpszSpeechDllPath);

		    // Load speech.dll

            CSpUnicodeSupport unicode;
		    hMod = unicode.LoadLibrary(szSpeechDll);

		    if (hMod)
			    uFlags |= FORMAT_MESSAGE_FROM_HMODULE;
	    }

	    // Get the error string

	    dwRes = FormatMessage(uFlags, hMod, hRes, 0, (LPWSTR)&pvMsg, 0, NULL);

	    // Unload speech.dll (if necessary)

	    if (hMod)
		    FreeLibrary(hMod);

	    // Did we get the error message?

	    if (dwRes != 0)
            {
                MessageBox(hWnd, (LPTSTR)pvMsg, szCaption, MB_OK|MB_TOPMOST|g_dwIsRTLLayout);
                LocalFree(pvMsg);
                return;
	    }
    }

    // If this is an unknown error just put up a generic
    // message.

    if (uResID == 0xFFFFFFFF)
        uResID = IDS_E_INSTALL;

    // We don't want to show the user the IDS_E_INSTALL message more
    // than once.

    if ((uResID == IDS_E_INSTALL) && g_bNoInstallError)
        return;

    // Load the string resource

    iLen = LoadString(_Module.GetResourceInstance(), uResID, szErrorTemplate, 256);
    
    // It better be there

    SPDBG_ASSERT(iLen != 0);

    // Format and show the error

    wsprintf(szError, szErrorTemplate, hRes);
    MessageBox(hWnd, szError, szCaption, MB_OK|MB_TOPMOST|g_dwIsRTLLayout);
}
#endif


/*****************************************************************************
* RunControlPanel *
*-----------------*
*   Description:
*       Perform Control Panel initialization and display property sheet
****************************************************************** MIKEAR ***/
void RunControlPanel(HWND hWndCpl)
{

    SPDBG_FUNC( "RunControlPanel" );
    PROPSHEETHEADER psh;
    PROPSHEETPAGE rgpsp[kcMaxPages];
    HPROPSHEETPAGE rPages[kcMaxPages];

    UINT kcPages = 0;

    // Set up the property sheet header. NOTE: the
    // resources for the control panel applet are in
    // this module. For NT5, the resource loader handles
    // the multi-lingual UI by searching for a speech.cpl.mui
    // resource only DLL in the %system%\mui\XXXX directory
    // where XXXX is the hex langid.

    ZeroMemory(rgpsp, sizeof(PROPSHEETPAGE) * kcMaxPages);
    ZeroMemory(&psh, sizeof(PROPSHEETHEADER));
    ZeroMemory(rPages, sizeof(HPROPSHEETPAGE) * kcMaxPages);

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_DEFAULT;
    psh.hwndParent = hWndCpl;
    psh.hInstance = _Module.GetResourceInstance();
    psh.pszCaption = MAKEINTRESOURCE(IDS_CAPTION);
    psh.phpage = rPages;
    psh.nPages = 0;    // make sure psh.nPages gets an initial value

//    CComPtr<ISpEnumAudioInstance> cpEnumDevice;
    BOOL  fHaveVoices = FALSE;
    BOOL  fHaveRecognizers = FALSE;
    ULONG ulNumInputDevices = 1;
    ULONG ulNumOutputDevices = 1;

    // Get the voice and recognizer count
    CComPtr<ISpObjectToken> cpDefVoice;
    fHaveVoices = SUCCEEDED(SpGetDefaultTokenFromCategoryId(SPCAT_VOICES, &cpDefVoice));

    CComPtr<ISpObjectToken> cpDefReco;
    fHaveRecognizers = SUCCEEDED(SpGetDefaultTokenFromCategoryId(SPCAT_RECOGNIZERS, &cpDefReco));

    // Set up the PROPSHEETPAGE structure(s). If there are no voices
    // or no recognizers, then don't show the corresponding pages.  Also
    // don't show the page if there is only 1 voice or recognizer and
    // one device.

    if( fHaveRecognizers ) 
    {
        rgpsp[kcPages].dwSize = IsOS(OS_WHISTLERORGREATER)? sizeof(PROPSHEETPAGE) : PROPSHEETPAGE_V2_SIZE;
        rgpsp[kcPages].dwFlags = PSP_DEFAULT;
        rgpsp[kcPages].hInstance = _Module.GetResourceInstance();
        rgpsp[kcPages].pszTemplate = MAKEINTRESOURCE(IDD_SR);
        rgpsp[kcPages].pfnDlgProc = SRDlgProc;
        rPages[kcPages] = CreatePropertySheetPage(rgpsp+kcPages);
        kcPages++;
    }
    else
    {
        if ( g_pSRDlg )
        {
            delete g_pSRDlg;
            g_pSRDlg = NULL;
        }
    }

    if( fHaveVoices ) 
    {
        rgpsp[kcPages].dwSize = IsOS(OS_WHISTLERORGREATER)? sizeof(PROPSHEETPAGE) : PROPSHEETPAGE_V2_SIZE;
       rgpsp[kcPages].dwFlags = PSP_DEFAULT;
        rgpsp[kcPages].hInstance = _Module.GetResourceInstance();
        rgpsp[kcPages].pszTemplate = MAKEINTRESOURCE(IDD_TTS);
        rgpsp[kcPages].pfnDlgProc = TTSDlgProc;
        rPages[kcPages] = CreatePropertySheetPage(rgpsp+kcPages);
        kcPages++;
    }
    else
    {
        if ( g_pTTSDlg )
        {
            delete g_pTTSDlg;
            g_pTTSDlg = NULL;
        }
    }

    // Always display the "Other" (formerly "About") pane on OS <=Win2000 or
    // on Whister and beyond if Sapi4 is present
    if ( !IsOS(OS_WHISTLERORGREATER) || IsSAPI4Installed() )
    {
        rgpsp[kcPages].dwSize = IsOS(OS_WHISTLERORGREATER)? sizeof(PROPSHEETPAGE) : PROPSHEETPAGE_V2_SIZE;
        rgpsp[kcPages].dwFlags = PSP_DEFAULT ;
        rgpsp[kcPages].hInstance = _Module.GetResourceInstance();
        rgpsp[kcPages].pszTemplate = MAKEINTRESOURCE(IDD_ABOUT);
        rgpsp[kcPages].pfnDlgProc = AboutDlgProc;
        rPages[kcPages] = CreatePropertySheetPage(rgpsp+kcPages);
        kcPages++;
    }


    psh.nPages = kcPages;

    // Is the current default working language a
    // RTL reading language?

    if (GetSystemMetrics(SM_MIDEASTENABLED))
    {
        psh.dwFlags |= PSH_RTLREADING;
        rgpsp[0].dwFlags |= PSP_RTLREADING;
        g_dwIsRTLLayout = MB_RTLREADING;
    }

    // Show the property sheet
    ::PropertySheet(&psh);
   
} /* RunControlPanel */

/*****************************************************************************
* IsSAPI4Installed *
*------------------*
*   Description:
*       Returns true iff speech.cpl is found in the system directory
****************************************************************** BeckyW ***/
bool IsSAPI4Installed()
{
    WCHAR wszSystemDir[ MAX_PATH ];
    if ( ::GetSystemDirectory( wszSystemDir, sp_countof( wszSystemDir ) ) )
    {
        WCHAR wszFoundPath[ MAX_PATH ];
        WCHAR *pwchFile = NULL;
        wszFoundPath[0] = 0;
        return (0 != ::SearchPath( wszSystemDir, SAPI4CPL, NULL,
            sp_countof( wszFoundPath ), wszFoundPath, &pwchFile ));
    }

    return false;

}   /* IsSAPI4Installed */

/*****************************************************************************
* RunSAPI4CPL *
*-------------*
*   Description:
*       Runs speech.cpl and waits for it to exit
****************************************************************** BeckyW ***/
void RunSAPI4CPL()
{
    // Different OS's keep rundll32.exe in different directories,
    // so we'll just find it here
    WCHAR szStartProg[MAX_PATH];
    WCHAR *pchFilePart;
    ::SearchPath( NULL, _T("rundll32.exe"), NULL, MAX_PATH, 
        szStartProg, &pchFilePart );
    STARTUPINFO si;
    ZeroMemory( &si, sizeof(si) );
    PROCESS_INFORMATION pi;
    si.cb = sizeof(STARTUPINFO);
   ::CreateProcess( szStartProg, L"rundll32 shell32.dll,Control_RunDLL speech.cpl", 
      NULL, NULL, false, NORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi );

    // Wait for it to exit
    ::WaitForSingleObject( pi.hProcess, INFINITE );
}   /* RunSAPI4CPL */

/*****************************************************************************
* IsIECurrentEnough *
*-------------------*
*   Description:
*       Returns true iff the version of IE installed meets our requirements
*       (IE5 and higher)
****************************************************************** BeckyW ***/
BOOL IsIECurrentEnough()
{
    BOOL fCurrentEnough = false;

    DWORD dwDummy = 0;
    BYTE *pbBlock = NULL;
    DWORD dwSize = ::GetFileVersionInfoSizeA( SHLWAPIDLL, &dwDummy );
    if ( dwSize )
    {
        pbBlock = new BYTE[ dwSize ];
    }

    BOOL fSuccess = FALSE;
    if ( pbBlock )
    {
        fSuccess = ::GetFileVersionInfoA( SHLWAPIDLL, 0, dwSize, pbBlock );
    }

    LPVOID pvInfo = NULL;
    if ( fSuccess )
    {
        UINT uiLen = 0;
        fSuccess = ::VerQueryValueA( pbBlock, "\\", &pvInfo, &uiLen );
    }

    if ( fSuccess )
    {
        VS_FIXEDFILEINFO *pvffi = (VS_FIXEDFILEINFO *) pvInfo;
        WORD wVersion = HIWORD(pvffi->dwFileVersionMS);
        fCurrentEnough = HIWORD(pvffi->dwFileVersionMS) >= 5;
    }

    delete[] pbBlock;

    return fCurrentEnough;
}   /* IsIECurrentEnough */

/*****************************************************************************
* CPlApplet *
*-----------*
*   Description:
*       Required export for Control Panel applets
****************************************************************** MIKEAR ***/
LONG APIENTRY CPlApplet(HWND hWndCpl, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
{
    SPDBG_FUNC( "CPlApplet" );

    // Standard CPL
    LPNEWCPLINFO lpNewCPlInfo;
    int tmpFlag;

	HRESULT hr = S_OK;

    switch (uMsg)
    { 
    case CPL_INIT:

        if (g_fIEVersionGoodEnough)
        {
            _Module.m_hInstResource = g_SatelliteDLL.Load(g_hInstance, TEXT("spcplui.dll"));
        }
#ifdef _DEBUG
        // Turn on memory leak checking
        tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
        tmpFlag |= _CRTDBG_LEAK_CHECK_DF;
        _CrtSetDbgFlag( tmpFlag );
#endif

        if ( FAILED( hr ) )
        {
            // CoInitialize failed, we can't run the CPL
            return 0;
        }
        
        return TRUE;
	          
    case CPL_EXIT:
        // These were new'ed right before RunControlPanel() was called
        if ( g_pSRDlg )
        {
            delete g_pSRDlg;
        }
        if ( g_pTTSDlg )
        {
            delete g_pTTSDlg;
        }

        return TRUE;
	          
    case CPL_GETCOUNT:
        {
            return g_fIEVersionGoodEnough ? 1 : 0;
        }
     
    case CPL_INQUIRE:
        LPCPLINFO lpCPLInfo;
        lpCPLInfo = (LPCPLINFO)lParam2;
        lpCPLInfo->lData = 0;
        
        lpCPLInfo->idIcon = IDI_SAPICPL;
        lpCPLInfo->idName = IDS_NAME;
        lpCPLInfo->idInfo = IDS_DESCRIPTION;
        break;

    case CPL_NEWINQUIRE:
        LPNEWCPLINFO lpNewCPLInfo;
        lpNewCPLInfo = (LPNEWCPLINFO) lParam2;

        lpNewCPLInfo->dwSize = sizeof( NEWCPLINFO );
        lpNewCPLInfo->hIcon = ::LoadIcon( _Module.GetResourceInstance(), MAKEINTRESOURCE( IDI_SAPICPL ) );
        ::LoadString( _Module.GetResourceInstance(), IDS_NAME, lpNewCPLInfo->szName, 32 );
        ::LoadString( _Module.GetResourceInstance(), IDS_DESCRIPTION, lpNewCPLInfo->szInfo, 64 );

        break;
    
    case CPL_DBLCLK:
        {
            // Construct dialog pages and display property sheet

            if ( !g_fIEVersionGoodEnough )
            {
                // No can do: Can't run this guy since there isn't enough IE love
                WCHAR szError[ 256 ];
                szError[0] = 0;
                ::LoadString( _Module.GetResourceInstance(), IDS_NO_IE5, szError, sp_countof( szError ) );
                ::MessageBox( NULL, szError, NULL, MB_ICONEXCLAMATION | g_dwIsRTLLayout );
            }
            else
            {
                // setup TTS dialog
                g_pTTSDlg = new CTTSDlg();

                // setup SR dialog
                g_pSRDlg = new CSRDlg();

                if ( g_pTTSDlg && g_pSRDlg )
                {
                    RunControlPanel(hWndCpl);
                }
                else
                {
		            WCHAR szError[256];
		            szError[0] = '\0';
                    ::LoadString(_Module.GetResourceInstance(), IDS_OUTOFMEMORY, szError, sp_countof(szError));
                    ::MessageBox(NULL, szError, NULL, MB_ICONWARNING|g_dwIsRTLLayout);
                }
            }

        }
        break;
    }     

    return 0; 
} /* CPlApplet */


/*****************************************************************************
* AboutDlgProc *
*--------------*
*   Description:
*       Dialog proc for the about propsheet
****************************************************************** BECKYW ****/
INT_PTR CALLBACK AboutDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SPDBG_FUNC( "AboutDlgProc" );

	USES_CONVERSION;

    static bool fSAPI4 = false;
    static WCHAR szHelpFile[ MAX_PATH ];

    switch (uMsg) 
    {
        case WM_INITDIALOG:
        {
            WCHAR szVerString[ MAX_LOADSTRING ];
            ::LoadString( _Module.GetResourceInstance(),
                IDS_SAPI_VERSION, szVerString, sp_countof( szVerString ) );
            wcscat( szVerString, _T(VER_PRODUCTVERSION_STR) );
            ::SetDlgItemText( hWnd, IDC_STATIC_SAPIVER, szVerString );
                
            // Don't display help or file versioning on Whistler and beyond
            if ( IsOS(OS_WHISTLERORGREATER) )
            {
                ::ShowWindow( ::GetDlgItem( hWnd, IDC_ABOUT_HELP ), SW_HIDE );
                ::ShowWindow( ::GetDlgItem( hWnd, IDC_VERSION_STATIC ), SW_HIDE );
                ::ShowWindow( ::GetDlgItem( hWnd, IDC_STATIC_SAPIVER ), SW_HIDE );
            }
            else
            {
                // Display help only if it's there
                WCHAR szHelpDir[ MAX_PATH ];
                UINT uiRet = ::GetWindowsDirectory( szHelpDir, sp_countof( szHelpDir ) );
                DWORD dwRet = 0;
                if ( uiRet > 0 )
                {
                    wcscat( szHelpDir, L"\\Help" );
                    WCHAR *pchFilePart = NULL;
                    dwRet = ::SearchPath( szHelpDir, L"speech.chm", NULL, 
                        sp_countof( szHelpFile ), szHelpFile, &pchFilePart );
                }
                if ( 0 == dwRet )
                {
                    szHelpFile[0] = 0;
                    ::ShowWindow( ::GetDlgItem( hWnd, IDC_ABOUT_HELP ), SW_HIDE );
                }
            }

            // Display the link to SAPI4 only if SAPI4 is installed
            fSAPI4 = IsSAPI4Installed();
            if ( !fSAPI4 )
            {
                ::ShowWindow( ::GetDlgItem( hWnd, IDC_GROUP_SAPI4 ), SW_HIDE );
                ::ShowWindow( ::GetDlgItem( hWnd, IDC_STATIC_SAPI4 ), SW_HIDE );
                ::ShowWindow( ::GetDlgItem( hWnd, IDC_CPL_SAPI4 ), SW_HIDE );
            }
            break;
        }

        case WM_COMMAND:
            switch( LOWORD(wParam) )
            {
                case IDC_ABOUT_HELP:
                {
                    if ( *szHelpFile )
                    {
                        CSpUnicodeSupport unicode;
                        unicode.HtmlHelp( NULL, szHelpFile, 0, 0 );
                    }

                    break;
                }

                case IDC_CPL_SAPI4:
                {
                    // Run SAPI4's control panel after exiting ours with a "Cancel"
                    HWND hwndParent = ::GetParent( hWnd );
                    PSHNOTIFY pshnot;
                    pshnot.lParam = 0;
                    pshnot.hdr.hwndFrom = hwndParent;
                    pshnot.hdr.code = PSN_QUERYCANCEL;
                    pshnot.hdr.idFrom = 0;
                    if ( g_pSRDlg )
                    {
                        ::SendMessage( g_pSRDlg->GetHDlg(), WM_NOTIFY, (WPARAM) hwndParent, (LPARAM) &pshnot );
                    }
                    if ( g_pTTSDlg )
                    {
                        ::SendMessage( g_pTTSDlg->GetHDlg(), WM_NOTIFY, (WPARAM) hwndParent, (LPARAM) &pshnot );
                    }

                    ::DestroyWindow( hwndParent );

                    RunSAPI4CPL();
                    break;
                }
                break;
            }
    }

    return FALSE;
} /* AboutDlgProc */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\srdlg.cpp ===
#include "stdafx.h"
#include "resource.h"
#include <sapi.h>
#include <string.h>
#include "SRDlg.h"
#include <spddkhlp.h>
#include <initguid.h>
#include "helpresource.h"
#include "richedit.h"
#include "mlang.h"
#include "Lmcons.h"

static DWORD aKeywordIds[] = {
   // Control ID           // Help Context ID
   IDC_ADD,                 IDH_ADD,
    IDC_MODIFY,         IDH_SETTINGS,
    IDC_DELETE,             IDH_DELETE,
    IDC_TRN_ADVICE,         IDH_NOHELP,
    IDC_USER,               IDH_USER,
    IDC_MIC_ICON,           IDH_NOHELP,
   IDC_COMBO_RECOGNIZERS,   IDH_ENGINES,       
   IDC_SR_ADV,             IDH_SR_ADV,
   IDC_USERTRAINING,       IDH_USERTRAINING,
   IDC_PROGRESS1,          IDH_PROGRESS1,
   IDC_AUD_IN,             IDH_AUD_IN,
   IDC_MICWIZ,             IDH_MICWIZ,
   IDC_SR_ICON,             IDH_NOHELP,
   IDC_SR_CAPTION,          IDH_NOHELP,
   IDC_SR_LIST_CAP,         IDH_NOHELP,
   IDC_TRAIN_GROUP,         IDH_NOHELP,
    IDC_ADVICE,             IDH_NOHELP,
    IDC_IN_GROUP,           IDH_NOHELP,
    IDC_MIC_CAP,            IDH_NOHELP,
    IDC_MIC_INST,           IDH_NOHELP,
   0,                      0
};

/*****************************************************************************
* CSRDlg::CreateRecoContext *
*---------------------------*
*   Description:
*       This creates a new instance of the recognizer with whatever is the 
*       current defaults for the recognizer.
*       The "fInitialize" argument is FALSE by default.  If set, it does
*       NOT attempt to set the m_pCurUserToken reco profile and instead
*       just picks up whatever CoCreateInstance() on the shared recognizer
*       gave it.
*       NOTE: The caller is responsible for displaying error messages to 
*       the user when this fails.
*   Return: 
*       S_OK 
*       Failed HRESULT from recognizer/recocontext initialization functions
****************************************************************** BECKYW ***/
HRESULT CSRDlg::CreateRecoContext(BOOL *pfContextInitialized, BOOL fInitialize, ULONG ulFlags)
{
    // Kill the reco context and notify sink first, if we have one
    if ( m_cpRecoCtxt )
    {
        m_cpRecoCtxt->SetNotifySink( NULL );
    }
    m_cpRecoCtxt.Release();

    HRESULT hr;
    
    // SOFTWARE ENGINEERING OPPORTUNITY (beckyw 8/24): This is a workaround for a 
    // bug that appears to repro only on my dev machine, in which the recostate
    // needs to be inactive for this whole thing.
    if ( m_cpRecoEngine )
    {
        m_cpRecoEngine->SetRecoState( SPRST_INACTIVE );
    }

    if ( m_cpRecoEngine )
    {
        SPRECOSTATE recostate;
        hr = m_cpRecoEngine->GetRecoState( &recostate );

        // This is due to a SOFTWARE ENGINEERING OPPORTUNITY in which SetRecognizer( NULL )
        // doesn't work if the recostate is SPRST_ACTIVE_ALWAYS.
        // In this case, we temporarily switch the recostate
        if ( SUCCEEDED( hr ) && (SPRST_ACTIVE_ALWAYS == recostate) )
        {
            hr = m_cpRecoEngine->SetRecoState( SPRST_INACTIVE );
        }

        // Kick the recognizer
        if ( SUCCEEDED( hr ) && (ulFlags & SRDLGF_RECOGNIZER) )
        {
            hr = m_cpRecoEngine->SetRecognizer( NULL );
        }

        // Kick the audio input 
        if ( SUCCEEDED( hr )  && (ulFlags & SRDLGF_AUDIOINPUT))
        {
            hr = m_cpRecoEngine->SetInput( NULL, TRUE );
        }

        // Set the recostate back if we changed it.
        if ( (SPRST_ACTIVE_ALWAYS == recostate) )
        {
            HRESULT hrRecoState = m_cpRecoEngine->SetRecoState( recostate );
            if ( FAILED( hrRecoState ) )
            {
                hr = hrRecoState;
            }
        }
    }
    else 
    {
        hr = m_cpRecoEngine.CoCreateInstance( CLSID_SpSharedRecognizer );
    }

    if(!fInitialize && SUCCEEDED( hr ))
    {
        // Normally set to m_pCurUserToken
        // When initializing this is not created yet so just set to default
        hr = m_cpRecoEngine->SetRecoProfile(m_pCurUserToken);
    }

    if ( SUCCEEDED( hr ) )
    {
        hr = m_cpRecoEngine->CreateRecoContext(&m_cpRecoCtxt);
    }
    
    if ( SUCCEEDED( hr ) )
    {
        hr = m_cpRecoCtxt->SetNotifyWindowMessage(m_hDlg, WM_RECOEVENT, 0, 0);
    }

    if ( SUCCEEDED( hr ) )
    {
        const ULONGLONG ullInterest = SPFEI(SPEI_SR_AUDIO_LEVEL);
        hr = m_cpRecoCtxt->SetInterest(ullInterest, ullInterest);
    }

    // Set the pfContextInitialized flag if everything has gone OK;
    // if something has not gone OK, clean up
    if ( pfContextInitialized )
    {
        // If we got here, the reco context has been initialized
        *pfContextInitialized = SUCCEEDED( hr );
    }
    if ( FAILED( hr ))
    {
        m_cpRecoCtxt.Release();
        m_cpRecoEngine.Release();

        
        return hr;
    }

#ifdef _DEBUG
    // Let's make sure we actually have the right recognizer now
    CComPtr<ISpObjectToken> cpCurDefaultToken; // What it should be
    SpGetDefaultTokenFromCategoryId(SPCAT_RECOGNIZERS, &cpCurDefaultToken);

    CComPtr<ISpObjectToken> cpRecognizerToken;
    m_cpRecoEngine->GetRecognizer( &cpRecognizerToken );
    if ( cpRecognizerToken )
    {
        CSpDynamicString dstrCurDefaultToken;
        cpCurDefaultToken->GetId( &dstrCurDefaultToken );

        CSpDynamicString dstrRecognizerToken;
        cpRecognizerToken->GetId( &dstrRecognizerToken );

        if ( 0 != wcsicmp( dstrCurDefaultToken, dstrRecognizerToken ) )
        {
            OutputDebugString( L"Warning: We just created a recognizer that isn't the default!\n" );
        }
    }
#endif

    // Now turn on the reco state for the volume meter
    hr = m_cpRecoEngine->SetRecoState( SPRST_ACTIVE_ALWAYS );

    return(hr);
}   

/*****************************************************************************
* SortCols *
*-----------*
*   Description:
*       Comparison function for subitems in the reco list
****************************************************************** BRENTMID ***/
int CALLBACK SortCols( LPARAM pToken1, LPARAM pToken2, LPARAM pDefToken )
{
    USES_CONVERSION;

    // Get the names
    CSpDynamicString dstrDesc1;
    CSpDynamicString dstrDesc2;
    SpGetDescription( (ISpObjectToken *) pToken1, &dstrDesc1 );
    SpGetDescription( (ISpObjectToken *) pToken2, &dstrDesc2 );
    
    // First check if there is no description for either one.
    // If there is no description, set it to "<no name>"
    if ( !dstrDesc1.m_psz || !dstrDesc2.m_psz )
    {
        WCHAR szNoName[ MAX_LOADSTRING ];
        szNoName[0] = 0;
        ::LoadString( _Module.GetResourceInstance(), IDS_UNNAMED_RECOPROFILE, szNoName, sp_countof( szNoName ) );
        
        USES_CONVERSION;
        if ( !dstrDesc1 )
        {
            dstrDesc1 = szNoName;
            SpSetDescription( (ISpObjectToken *) pToken1, dstrDesc1 );
        }
        if ( !dstrDesc2 )
        {
            dstrDesc2 = szNoName;
            SpSetDescription( (ISpObjectToken *) pToken2, dstrDesc2 );
        }
    }

    if (pDefToken == pToken1) {
        return -1;   // make sure pToken1 goes to top of list
    }
    else if (pDefToken == pToken2) {
        return 1;    // make sure pToken2 goes to top of list
    }

    // PREFIX: verify memory allocation
    // if we failed a memory allocation somewhere return that they are equal so the sort will just leave them alone.
    if ((NULL == dstrDesc1.m_psz) || (NULL == dstrDesc2.m_psz))
    {
        return 0;
    }

    return wcscmp(_wcslwr(dstrDesc1.m_psz), _wcslwr(dstrDesc2.m_psz));
}

/*****************************************************************************
* CSRDlg::RecoEvent *
*-------------------*
*   Description:
*       Handles the SR events for the volume meter
****************************************************************** BRENTMID ***/
void CSRDlg::RecoEvent()
{
    CSpEvent event;
    if (m_cpRecoCtxt)
    {
        while (event.GetFrom(m_cpRecoCtxt) == S_OK)
        {
            if (event.eEventId == SPEI_SR_AUDIO_LEVEL)
            {
                ULONG l = (ULONG)event.wParam;
            
                SendMessage( GetDlgItem ( m_hDlg, IDC_PROGRESS1 ), PBM_SETPOS, l, 0);
            }
        }
    }
}   


/*****************************************************************************
* TrySwitchDefaultEngine *
*------------------------*
*   Description:
*       This function is called when we want to run some UI for the engine
*       the user has selected, but because we don't know which shared engine
*       is running and whether another app is using it we can't directly
*       create the UI. So this method temporarily switches the default recognizer,
*       and recreates the engine, and then checks its token. If another app
*       was using the engine we wouldn't be able to switch and we return S_FALSE.
*       A side effect of this method is that for the duration of the UI, the
*       default will be changed, even though the user hasn't yet pressed apply,
*       but there seems no good way round this.
*
*       In the case that m_pCurRecoToken is actually the same token as the
*       one the currently-active recognizer uses, we don't need to create
*       a new recognizer and recocontext; instead we just return successfully.
*   Return:
*       S_OK
*       FAILED HRESULT of various functions
*           In particular, SPERR_ENGINE_BUSY means that someone else is 
*           running the engine, so this couldn't be done.
****************************************************************** DAVEWOOD ***/
HRESULT CSRDlg::TrySwitchDefaultEngine( bool fShowErrorMessages)
{
    HRESULT hr = S_OK;
    bool fMatch = false;
    
    // Set the new temporary default
    if(SUCCEEDED(hr))
    {
        hr = SpSetDefaultTokenForCategoryId(SPCAT_RECOGNIZERS, m_pCurRecoToken);
    }

    if ( SUCCEEDED( hr ) && IsRecoTokenCurrentlyBeingUsed( m_pCurRecoToken ) )
    {
        // No need to switch engine all over again: just keep the one in use
        return S_OK;
    }

    // Try to create the engine & context with the default
    // then see if this was actually the engine we expected
    if(SUCCEEDED(hr))
    {
        hr = CreateRecoContext( );
    }

    if ( FAILED( hr ) && fShowErrorMessages )
    {
        WCHAR szError[256];
        szError[0] = '\0';
        
        // What to complain about...
        UINT uiErrorID = HRESULTToErrorID( hr );

        if ( uiErrorID )
        {
            LoadString(_Module.GetResourceInstance(), 
                uiErrorID, 
                szError, sp_countof(szError));
            MessageBox(g_pSRDlg->m_hDlg, szError, m_szCaption, MB_ICONWARNING|g_dwIsRTLLayout);
        }
    }

    return hr;
}

/*****************************************************************************
* CSRDlg::ResetDefaultEngine *
*----------------------------*
*   Description:
*       This function resets the engine default back to its original value.
*       If the engine already has the right token, it doesn't bother trying
*       to create the engine again and returns S_OK
*   Return:
*       S_OK
*       S_FALSE if the default was set back but no engine was created
*       FAILED HRESULT of SpSetDefaultTokenForCategoryId()
****************************************************************** DAVEWOOD ***/
HRESULT CSRDlg::ResetDefaultEngine( bool fShowErrorMessages )
{
    HRESULT hr = S_OK;

    // Reset the old default
    if(m_pDefaultRecToken)
    {
        hr = SpSetDefaultTokenForCategoryId(SPCAT_RECOGNIZERS, m_pDefaultRecToken);
    }

    HRESULT hrRet = hr;

    BOOL fContextInitialized = FALSE;
    if ( SUCCEEDED( hr ) )
    {
        if ( IsRecoTokenCurrentlyBeingUsed( m_pDefaultRecToken ) )
        {
            // No need to switch engine all over again: just keep the one in use

            if ( m_cpRecoCtxt )
            {
                fContextInitialized = TRUE;
            }
            else
            {
                hr = SPERR_UNINITIALIZED;
            }
            
            // The UI might have monkeyed with the recostate.
            // Just in case, let's set it back to ACTIVE_ALWAYS
            if ( SUCCEEDED( hr ) )
            {
                hr = m_cpRecoEngine->SetRecoState( SPRST_ACTIVE_ALWAYS );
            }
        }
        else
        {
            // Create the engine & context using the old default
            hr = g_pSRDlg->CreateRecoContext( &fContextInitialized );
        }
    }

    if ( FAILED( hr ) )
    {
        BOOL fContextInitialized = FALSE;
        hr = g_pSRDlg->CreateRecoContext( &fContextInitialized );

        // Let's not complain about unsupported languages twice as this may be confusing
        // to the user.
        if ( FAILED( hr ) && ( SPERR_UNSUPPORTED_LANG != hr ) )
        {
            RecoContextError( fContextInitialized, fShowErrorMessages, hr );
            // The default was set back but no engine was successfully set up.

            // A FAILED hresult is not necessary here since the user
            // has been notified of the error
            hrRet = S_FALSE;
        }

        // Gray out all the buttons
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_USERTRAINING), FALSE);
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_MICWIZ), FALSE);
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_SR_ADV), FALSE);
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_MODIFY), FALSE);
    }

    return hrRet;
}   /* CSRDlg::ResetDefaultEngine */

/*****************************************************************************
* CSRDlg::IsRecoTokenCurrentlyBeingUsed *
*---------------------------------------*
*   Description:
*       Call GetRecognizer() on the recognizer currently in use, and 
*       compare IDs
****************************************************************** BECKYW ****/
bool CSRDlg::IsRecoTokenCurrentlyBeingUsed( ISpObjectToken *pRecoToken )
{
    if ( !pRecoToken || !m_cpRecoEngine )
    {
        return false;
    }

    CComPtr<ISpObjectToken> cpRecoTokenInUse;
    HRESULT hr = m_cpRecoEngine->GetRecognizer( &cpRecoTokenInUse );

    CSpDynamicString dstrTokenID;
    CSpDynamicString dstrTokenInUseID;
    if ( SUCCEEDED( hr ) )
    {
        hr = pRecoToken->GetId( &dstrTokenID );
    }
    if ( SUCCEEDED( hr ) )
    {
        hr = cpRecoTokenInUse->GetId( &dstrTokenInUseID );
    }

    return ( SUCCEEDED( hr ) && (0 == wcscmp(dstrTokenID, dstrTokenInUseID)) );
}   /* CSRDlg::IsRecoTokenCurrentlyBeingUsed */

/*****************************************************************************
* CSRDlg::HasRecognizerChanged *
*------------------------------*
*   Description:
*       Look at the currently-requested default recognizer, compare against the
*       original default recognizer, and return true iff it is 
*       different
****************************************************************** BECKYW ****/
bool CSRDlg::HasRecognizerChanged()
{
    bool fChanged = false;

    // Check the recognizer token
    CSpDynamicString dstrCurDefaultRecognizerID;
    CSpDynamicString dstrCurSelectedRecognizerID;
    HRESULT hr = E_FAIL;
    if ( m_pDefaultRecToken )
    {
        hr = m_pDefaultRecToken->GetId( &dstrCurDefaultRecognizerID );
    }
    if ( SUCCEEDED( hr ) && m_pCurRecoToken ) 
    {
        hr = m_pCurRecoToken->GetId( &dstrCurSelectedRecognizerID );
    }
    if (SUCCEEDED( hr ) && ( 0 != wcsicmp( dstrCurDefaultRecognizerID, dstrCurSelectedRecognizerID ) ))
    {
        fChanged = true;
    }

    return fChanged;

}   /* CSRDlg::HasRecognizerChanged */

/*****************************************************************************
* CSRDlg::KickCPLUI *
*-------------------*
*   Description:
*       Look at the currently-requested defaults, compare against the
*       original defaults, and enable the Apply button iff anything is 
*       different
****************************************************************** BECKYW ****/
void CSRDlg::KickCPLUI()
{
    // Check the default recognizer token
    bool fChanged = HasRecognizerChanged();

    // Check the default user token
    CSpDynamicString dstrCurSelectedProfileID;
    HRESULT hr = E_FAIL;
    if ( m_pCurUserToken )
    {
        hr = m_pCurUserToken->GetId( &dstrCurSelectedProfileID );
    }
    if (SUCCEEDED( hr ) && m_dstrOldUserTokenId 
        && ( 0 != wcsicmp( dstrCurSelectedProfileID, m_dstrOldUserTokenId ) ))
    {
        fChanged = true;
    }

    // Check the audio input device
    if ( m_pAudioDlg && m_pAudioDlg->IsAudioDeviceChanged() )
    {
        fChanged = true;
    }

    // If any tokens have been deleted, there has been a change
    if ( m_iDeletedTokens > 0 )
    {
        fChanged = true;
    }

    // If any tokens have been added, there has been a change
    if ( m_iAddedTokens > 0 )
    {
        fChanged = true;
    }

    // Tell the main propsheet
    HWND hwndParent = ::GetParent( m_hDlg );
    ::SendMessage( hwndParent, 
        fChanged ? PSM_CHANGED : PSM_UNCHANGED, (WPARAM)(m_hDlg), 0 ); 
}   /* CSRDlg::KickCPLUI */

/*****************************************************************************
* CSRDlg::RecoContextError *
*--------------------------*
*   Description:
*       Reacts to an error generated by trying to create and set up the 
*       recognition context within the CPL by displaying an error message
*       and graying out the UI.
****************************************************************** BECKYW ****/
void CSRDlg::RecoContextError( BOOL fRecoContextExists, BOOL fGiveErrorMessage,
                              HRESULT hrRelevantError )
{
    // Complain about the appropriate problem, if needed
    if ( fGiveErrorMessage )
    {
        WCHAR szError[256];
        szError[0] = '\0';
        
        // Figure out what error to talk about
        UINT uiErrorID = 0;
        if ( fRecoContextExists )
        {
            // There is a reco context but it couldn't be turned on
            uiErrorID = IDS_METER_WARNING;
        }
        else
        {
            uiErrorID = HRESULTToErrorID( hrRelevantError );
        }

        if ( uiErrorID )
        {
            LoadString(_Module.GetResourceInstance(), uiErrorID, 
                szError, sp_countof(szError));
            MessageBox(m_hDlg, szError, m_szCaption, MB_ICONWARNING|g_dwIsRTLLayout);
        }
    }

    // Gray out all the buttons
    if ( !fRecoContextExists )
    {
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_USERTRAINING), FALSE);
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_MICWIZ), FALSE);
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_SR_ADV), FALSE);
        ::EnableWindow(::GetDlgItem(m_hDlg, IDC_MODIFY), FALSE);
    }
}   /* CSRDlg::RecoContextError */

/*****************************************************************************
* CSRDlg::HRESULTToErrorID *
*--------------------------*
*   Description:
*       Translates a failed HRESULT from a recognizer/recocontext 
*       initializion into a resource string ID
****************************************************************** BECKYW ****/
UINT CSRDlg::HRESULTToErrorID( HRESULT hr )
{
    if ( SUCCEEDED( hr ) )
    {
        return 0;
    }

    // What to complain about...
    UINT uiErrorID;
    switch( hr )
    {
    case SPERR_ENGINE_BUSY:
        uiErrorID = IDS_ENGINE_IN_USE_WARNING;
        break;
    case SPERR_UNSUPPORTED_LANG:
        uiErrorID = IDS_UNSUPPORTED_LANG;
        break;
    default:
        // Generic error
        uiErrorID = IDS_ENGINE_SWITCH_ERROR;
        break;
    }

    return uiErrorID;
 
}   /* CSRDlg::HRESULTToErrorID */

/*****************************************************************************
* CSRDlg::IsProfileNameInvisible *
*--------------------------------*
*   Description:
*       A profile name is "invisible" iff it is the name of an existing
*       profile AND it is on the pending deletes list AND it is does not
*       exist for any tokens off the pending deletes list
****************************************************************** BECKYW ****/
bool CSRDlg::IsProfileNameInvisible( WCHAR *pwszProfile )
{
    if ( !pwszProfile )
    {
        return false;
    }

    bool fIsInvisible = false;
    for ( int i=0; !fIsInvisible && (i < m_iDeletedTokens); i++ )
    {
        ISpObjectToken *pDeletedToken = m_aDeletedTokens[i];
        if ( !pDeletedToken )
        {
            continue;
        }

        CSpDynamicString dstrDeletedDesc;
        HRESULT hr = SpGetDescription( pDeletedToken, &dstrDeletedDesc );
        if ( FAILED( hr ) )
        {
            continue;
        }

        if ( 0 == wcscmp( dstrDeletedDesc, pwszProfile ) )
        {
            bool fOnList = false;

            // Now go through everything on the recoprofile list
            // that is visible to the user
            int cItems = ListView_GetItemCount( m_hUserList );
            for ( int j=0; !fOnList && (j < cItems); j++ )
            {
                LVITEM lvitem;
                ::memset( &lvitem, 0, sizeof( lvitem ) );
                lvitem.iItem = j;
                lvitem.mask = LVIF_PARAM;
                BOOL fSuccess = ListView_GetItem( m_hUserList, &lvitem );
                
                ISpObjectToken *pVisibleToken = 
                    fSuccess ? (ISpObjectToken *) lvitem.lParam : NULL;

                if ( pVisibleToken )
                {
                    CSpDynamicString dstrVisible;
                    hr = SpGetDescription( pVisibleToken, &dstrVisible );

                    if ( SUCCEEDED( hr ) &&
                        (0 == wcscmp( dstrVisible, pwszProfile )) )
                    {
                        fOnList = true;
                    }
                }
            }

            if ( !fOnList )
            {
                // The name matches something on the deleted list,
                // but it appears nowhere on the list of profiles visible
                // to the user.
                fIsInvisible = true;
            }
        }
    }

    return fIsInvisible;
}   /* IsProfileNameInvisible */

/*****************************************************************************
* SRDlgProc *
*-----------*
*   Description:
*       DLGPROC for managing recognition engines
****************************************************************** MIKEAR ***/
INT_PTR CALLBACK SRDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SPDBG_FUNC( "SRDlgProc" );

    USES_CONVERSION;

    switch (uMsg) 
    {
        case WM_RECOEVENT:
        {
            g_pSRDlg->RecoEvent();
            break;
        }
        
        case WM_DRAWITEM:      // draw the items
        {
            g_pSRDlg->OnDrawItem( hWnd, ( DRAWITEMSTRUCT * )lParam );
            break;
        }

        case WM_INITDIALOG:
        {
            g_pSRDlg->OnInitDialog(hWnd);
            break;
        }

        case WM_DESTROY:
        {
            g_pSRDlg->OnDestroy();

            break;
        }

        // Handle the context sensitive help
        case WM_CONTEXTMENU:
        {
            WinHelp((HWND) wParam, CPL_HELPFILE, HELP_CONTEXTMENU, (DWORD_PTR)(LPWSTR) aKeywordIds);
            break;
        }

        case WM_HELP:
        {
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, CPL_HELPFILE, HELP_WM_HELP,(DWORD_PTR)(LPWSTR) aKeywordIds);
            break;
        }

        case WM_NOTIFY:
            switch (((NMHDR*)lParam)->code)
            {
                case LVN_DELETEITEM:
                {
                    if (wParam != IDC_USER)
                    {
                        break;
                    }

                    if (g_pSRDlg->m_fDontDelete)
                    {
                        break;  
                    }

                    ISpObjectToken *pToken = (ISpObjectToken*)(((NMLISTVIEW*)lParam)->lParam);

                    if (pToken)
                    {
                        pToken->Release();
                    }
                    break;
                }

                case LVN_ITEMCHANGED:
                {
                    // Code ends up here when a profile is added, deleted, or changed
                    // We verify that we weren't selected before, but are now
                    // and then kill the current reco context, deactivate the engine, change the profile
                    // and fire everything back up again
                    if ( IDC_USER == wParam )
                    {
                        LPNMLISTVIEW lplv = (LPNMLISTVIEW) lParam;
                        if ( !(lplv->uOldState & LVIS_FOCUSED) && lplv->uNewState & LVIS_FOCUSED )
                        {
                            if ( g_pSRDlg->m_cpRecoEngine && g_pSRDlg->m_cpRecoCtxt )
                            {
                                HRESULT hr;

                                ISpObjectToken *pSelectedToken = (ISpObjectToken *) lplv->lParam;

                                hr = g_pSRDlg->m_cpRecoEngine->SetRecoState( SPRST_INACTIVE );
                                
                                if ( SUCCEEDED( hr ) )
                                {
                                    hr = g_pSRDlg->m_cpRecoEngine->SetRecoProfile( pSelectedToken );

                                    // Restart audio regardless of success of SetRecoProfile
                                    g_pSRDlg->m_cpRecoEngine->SetRecoState(SPRST_ACTIVE_ALWAYS);

                                    if ( FAILED( hr ) )
                                    {
                                        WCHAR szError[256];
                                        szError[0] = '\0';
                                        LoadString(_Module.GetResourceInstance(), IDS_PROFILE_WARNING, szError, sp_countof(szError));
                                        MessageBox(g_pSRDlg->m_hDlg, szError, g_pSRDlg->m_szCaption, MB_ICONWARNING|g_dwIsRTLLayout);
                                    }
                                }
                                
                                if ( SUCCEEDED( hr ) )
                                {
                                    // This is now the new default
                                    g_pSRDlg->m_pCurUserToken = pSelectedToken;
                                    g_pSRDlg->UserSelChange( lplv->iItem );
                                }

                            }
                        }
                    }
                    break;
                }
 
                case PSN_APPLY:
                {
                    g_pSRDlg->OnApply();
                    break;
                }

                case PSN_QUERYCANCEL:  // user clicks the Cancel button
                {
                    g_pSRDlg->OnCancel();
                    break;
                }

            }
            break;

        case WM_COMMAND:
            if (CBN_SELCHANGE == HIWORD(wParam))
            {
                g_pSRDlg->EngineSelChange();
            }
            else if (HIWORD(wParam) == BN_CLICKED)
            {
                HRESULT hr = S_OK;

                if (LOWORD(wParam) == IDC_MODIFY)  // the "Modify" button
                {
                    hr = g_pSRDlg->TrySwitchDefaultEngine( true );

                    if ( SUCCEEDED( hr ) )
                    {
                        g_pSRDlg->ProfileProperties();
                    }
                    
                    // Switch back to original default, complaining about errors only if there
                    // wasn't a complaint from the call to TrySwitchDefaultEngine
                    hr = g_pSRDlg->ResetDefaultEngine( SUCCEEDED( hr ));
                    
                }

                else if (LOWORD(wParam) == IDC_ADD) // the "Add" button
                {
                    // The engine we want to add this user for may not be the currently-
                    // running engine.  Try and switch it, and complain if there's 
                    // a problem
                    hr = g_pSRDlg->TrySwitchDefaultEngine( true );

                    if ( SUCCEEDED( hr ) )
                    {
                        g_pSRDlg->CreateNewUser();
                    }

                    // Switch back to original default, but complain about errors
                    // only if the UI actually succeeded in showing
                    g_pSRDlg->ResetDefaultEngine( SUCCEEDED( hr ) );
                }

                else if (LOWORD(wParam) == IDC_DELETE) // the "Delete" button
                {
                    g_pSRDlg->DeleteCurrentUser();
                }

                else if (LOWORD(wParam) == IDC_SR_ADV)
                {
                    // The engine we want to display UI for may not be the currently
                    // running engine. Try and switch it
                    hr = g_pSRDlg->TrySwitchDefaultEngine( true );

                    if(SUCCEEDED(hr))
                    {
                        // display the UI w/ the new temporary default
                        g_pSRDlg->m_pCurRecoToken->DisplayUI(hWnd, NULL, 
                            SPDUI_EngineProperties, NULL, 0, g_pSRDlg->m_cpRecoEngine);
   
                    }
                    
                    // Switch back to original default, complaining about errors only if there
                    // wasn't a complaint from the call to TrySwitchDefaultEngine
                    hr = g_pSRDlg->ResetDefaultEngine( SUCCEEDED( hr ));
                }

                else if(LOWORD(wParam) == IDC_USERTRAINING)
                {
                    // The engine we want to display UI for may not be the currently
                    // running engine. Try and switch it
                    hr = g_pSRDlg->TrySwitchDefaultEngine( true );
                    
                    if(SUCCEEDED(hr))
                    {
                        // display the UI w/ the new temporary default
                        SPDBG_ASSERT( g_pSRDlg->m_cpRecoEngine );
                        g_pSRDlg->m_cpRecoEngine->DisplayUI(hWnd, NULL, SPDUI_UserTraining, NULL, 0);
                    }
                    
                    // Switch back to original default, complaining about errors only if there
                    // wasn't a complaint from the call to TrySwitchDefaultEngine
                    hr = g_pSRDlg->ResetDefaultEngine( SUCCEEDED( hr ));
                }

                else if(LOWORD(wParam) == IDC_MICWIZ)
                {
                    // The engine we want to display UI for may not be the currently
                    // running engine. Try and switch it
                    hr = g_pSRDlg->TrySwitchDefaultEngine( true );
                    
                    if(SUCCEEDED(hr))
                    {
                        // display the UI w/ the new temporary default
                        SPDBG_ASSERT( g_pSRDlg->m_cpRecoEngine );
                        g_pSRDlg->m_cpRecoEngine->DisplayUI(hWnd, NULL, SPDUI_MicTraining, NULL, 0);
                    }

                    // Switch back to original default, complaining about errors only if there
                    // wasn't a complaint from the call to TrySwitchDefaultEngine
                    hr = g_pSRDlg->ResetDefaultEngine( SUCCEEDED( hr ));
                }

                else if (LOWORD(wParam) == IDC_AUD_IN)
                {
                    // The m_pAudioDlg will be non-NULL only if the audio dialog
                    // has been previously brough up.
                    // Otherwise, we need a newly-initialized one
                    if ( !g_pSRDlg->m_pAudioDlg )
                    {
                        g_pSRDlg->m_pAudioDlg = new CAudioDlg( eINPUT );
                    }
                    ::DialogBoxParam( _Module.GetResourceInstance(), 
                                MAKEINTRESOURCE( IDD_AUDIO_DEFAULT ),
                                hWnd, 
                                AudioDlgProc,
                                (LPARAM) g_pSRDlg->m_pAudioDlg );

                    if ( g_pSRDlg->m_pAudioDlg->IsAudioDeviceChangedSinceLastTime() )
                    {
                        // Warn the user that he needs to apply the changes
                        WCHAR szWarning[MAX_LOADSTRING];
                        szWarning[0] = 0;
                        LoadString( _Module.GetResourceInstance(), IDS_AUDIOIN_CHANGE_WARNING, szWarning, MAX_LOADSTRING);
                        MessageBox( g_pSRDlg->GetHDlg(), szWarning, g_pSRDlg->m_szCaption, MB_ICONWARNING |g_dwIsRTLLayout);
                    }

                    // Kick the Apply button
                    g_pSRDlg->KickCPLUI();

                }
            }
            break;
    }

    return FALSE;
} /* SRDlgProc */

/****************************************************************************
* CSRDlg::CreateNewUser *
*-------------------------*
*   Description:  Adds a new speech user profile to the registry
*
*   Returns:
*
********************************************************************* RAL ***/

void CSRDlg::CreateNewUser()
{
    SPDBG_FUNC("CSRDlg::CreateNewUser");
    HRESULT hr = S_OK;

    // Make sure that we haven't already added too many profiles to keep track of
    if ( m_iAddedTokens >= iMaxAddedProfiles_c )
    {
        WCHAR wszError[ MAX_LOADSTRING ];
        ::LoadString( _Module.GetResourceInstance(), IDS_MAX_PROFILES_EXCEEDED,
            wszError, MAX_LOADSTRING );
        ::MessageBox( m_hDlg, wszError, m_szCaption, MB_ICONEXCLAMATION | g_dwIsRTLLayout );

        return;
    }

    CComPtr<ISpObjectToken> cpNewToken;
    hr = SpCreateNewToken(SPCAT_RECOPROFILES, NULL, &cpNewToken);

    if (SUCCEEDED(hr))
    {
        if (!UserPropDlg(cpNewToken))   // User canceled!
        {
            cpNewToken->Remove(NULL);
        }
        else
        {
            //set the default
            m_pCurUserToken = cpNewToken;

            // Put the new token on the added tokens list
            cpNewToken->GetId( &(m_aAddedTokens[ m_iAddedTokens++ ]) );

            // make this the default after we edit it
            ChangeDefaultUser();
            
            // This will make sure that it gets displayed.
            // Note that m_pCurUserToken will point an AddRefed ISpObjectToken *
            // after the call to PopulateList()
            PopulateList();

            // Update the UI
            KickCPLUI();
        }
    }
    else
    {
        WCHAR szError[MAX_LOADSTRING];
        szError[0] = 0;
        LoadString(_Module.GetResourceInstance(), IDS_RECOPROFILE_ADD_ERROR, szError, MAX_LOADSTRING);
        MessageBox( m_hDlg, szError, m_szCaption, MB_ICONWARNING | g_dwIsRTLLayout);
    }

    // Only enable the delete button if there are 2 or more user profiles
    int iNumUsers = (int)::SendMessage(m_hUserList, LVM_GETITEMCOUNT, 0, 0);
    if (iNumUsers < 2) 
    {
        EnableWindow(GetDlgItem(m_hDlg, IDC_DELETE), FALSE);
    }
    else
    {
        EnableWindow(GetDlgItem(m_hDlg, IDC_DELETE), TRUE);
    }

    // Sort the items initially
    ::SendMessage( m_hUserList, LVM_SORTITEMS, (LPARAM)m_pCurUserToken, LPARAM(&SortCols) );
}

/****************************************************************************
* CSRDlg::UserPropDlg *
*-----------------------*
*   Description:  This is for when a user wants to add a new profile
*
*   Returns:
*
********************************************************************* BRENTMID ***/

HRESULT CSRDlg::UserPropDlg(ISpObjectToken * pToken)
{
    SPDBG_FUNC("CSRDlg::UserPropDlg");
    HRESULT hr = S_OK;

    CEnvrPropDlg Dlg(this, pToken);

    hr = (HRESULT)DialogBoxParam(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDD_PROF_WIZ), m_hDlg,
        CEnvrPropDlg::DialogProc, (LPARAM)(&Dlg));
    
    return hr;
}

/****************************************************************************
* CEnvrPropDlg::InitDialog *
*--------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

BOOL CEnvrPropDlg::InitDialog(HWND hDlg)
{
    USES_CONVERSION;
    CSpDynamicString dstrDescription;
    m_hDlg = hDlg;

    //
    //  Get the description if there is one...
    //
    SpGetDescription(m_cpToken, &dstrDescription);

    if (dstrDescription)
    {
        ::SendDlgItemMessage(hDlg, IDC_USER_NAME, WM_SETTEXT, 0, (LPARAM) dstrDescription.m_psz);
        ::SendDlgItemMessage(hDlg, IDC_USER_NAME, EM_LIMITTEXT, UNLEN, 0);
    }

    // We want the EN_CHANGE notifications from the edit control
    ::SendDlgItemMessage( hDlg, IDC_USER_NAME, EM_SETEVENTMASK, 0, ENM_CHANGE );

    if (!m_isModify)
    {
        // Set the user name to the one in the registry, if found; 
        // otherwise set it to the user name
        HKEY hkUserKey;
        LONG lUserOpen;
        WCHAR szUserName[ UNLEN + 1 ];
        szUserName[0] = 0;
        DWORD dwUserLen = UNLEN + 1;
        
        lUserOpen = ::RegOpenKeyEx( HKEY_CURRENT_USER, 
            L"Software\\Microsoft\\MS Setup (ACME)\\User Info", 
            0, KEY_READ, &hkUserKey );
        if ( lUserOpen == ERROR_SUCCESS )
        {
            lUserOpen = RegQueryValueEx( hkUserKey, L"DefName", NULL, NULL, 
                (BYTE *) szUserName, &dwUserLen );
            RegCloseKey(hkUserKey);
        }

        if ( ERROR_SUCCESS != lUserOpen )
        {
            // Just use the win32 user name
            BOOL fSuccess = ::GetUserName( szUserName, &dwUserLen );
            if ( !fSuccess ) 
            {
                szUserName[0] = 0;
            }
        }

        // Now put that in the edit box.
        // First check to make sure the name is nonempty
        // and enable the UI accordingly
        WCHAR *pwch;
        for ( pwch = szUserName; *pwch && iswspace( *pwch ); pwch++ )
        {
        }
        ::EnableWindow( ::GetDlgItem( m_hDlg, IDOK ), (0 != *pwch) );
        ::EnableWindow( ::GetDlgItem( m_hDlg, ID_NEXT ), (0 != *pwch) );
        
        // Set the edit box to have the user's name
        // Need to use SETTEXTEX since this might contain wide chars
        SETTEXTEX stx;
        stx.flags = ST_DEFAULT;
        stx.codepage = 1200;
        ::SendDlgItemMessage( m_hDlg, 
            IDC_USER_NAME, EM_SETTEXTEX, (WPARAM) &stx, (LPARAM) szUserName );

    }

    ::SetFocus(::GetDlgItem(hDlg, IDC_USER_NAME));

    return TRUE;
}

/****************************************************************************
* CEnvrPropDlg::ApplyChanges *
*----------------------------*
*   Description:
*
*   Returns:
*
********************************************************************* RAL ***/

EPD_RETURN_VALUE CEnvrPropDlg::ApplyChanges()
{
    USES_CONVERSION;
    SPDBG_FUNC("CEnvrPropDlg::ApplyChanges");
    WCHAR szName[UNLEN + 1];
    *szName = 0;
    GETTEXTEX gtex = { sp_countof(szName), GT_DEFAULT, 1200, NULL, NULL };
    ::SendDlgItemMessage(m_hDlg, IDC_USER_NAME, EM_GETTEXTEX, (WPARAM)&gtex, (LPARAM)szName);

    if (*szName == 0)
    {
        return EPD_FAILED;
    }

    // Check to see if this profile name already exists
    CComPtr<IEnumSpObjectTokens>    cpEnum;
    ISpObjectToken                  *pToken;
    CSpDynamicString                dstrDescription;
    CSpDynamicString                dInputString;
    CSpDynamicString                dstrOldTok;
    bool                            isDuplicate = false;
    
    HRESULT hr = SpEnumTokens(SPCAT_RECOPROFILES, NULL, NULL, &cpEnum);
    
    // Get the description of the currently selected profile
    dstrOldTok.Clear();
    hr = SpGetDescription( m_pParent->m_pCurUserToken, &dstrOldTok );
    
    while (cpEnum && cpEnum->Next(1, &pToken, NULL) == S_OK)
    {
        // Get the description of the enumerated token
        dstrDescription.Clear();
        hr = SpGetDescription( pToken, &dstrDescription );

        pToken->Release();

        // Get the input string
        // PREFIX: verify memory alloc
        if (NULL == (dInputString = szName))
        {
            hr = E_OUTOFMEMORY;
        }

        if ( SUCCEEDED(hr) )
        {
            if ( wcscmp( dstrDescription.m_psz, dInputString.m_psz ) == 0 )
            {
                // the name is duplicated
                isDuplicate = true;
            }
        }
    }

    if ( isDuplicate )   // this not a modify box and the user entered a duplicate name
    {
        return EPD_DUP;  // tell the user about it
    }

    if (FAILED(SpSetDescription(m_cpToken, szName)))
    {
        return EPD_FAILED;
    }

    return EPD_OK;
}




/*****************************************************************************
* EnvrPropDialogProc *
*--------------------*
*   Description:
*       Mesage handler for User Name dialog
****************************************************************** BRENTMID ***/
INT_PTR CALLBACK CEnvrPropDlg::DialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    USES_CONVERSION;

    static CSpUnicodeSupport unicode;
    CEnvrPropDlg * pThis = (CEnvrPropDlg *) unicode.GetWindowLongPtr(hDlg, GWLP_USERDATA);
    switch (message)
    {
        case WM_INITDIALOG:
            unicode.SetWindowLongPtr(hDlg, GWLP_USERDATA, lParam);
            pThis = (CEnvrPropDlg *)lParam;
            return pThis->InitDialog(hDlg);

        case WM_COMMAND:
        {
            if (( IDC_USER_NAME == LOWORD(wParam) )
                && ( EN_CHANGE == HIWORD(wParam) ))
            {
                // Edit control contents have changed: 
                
                // See if we should enable the "finish" and "next" buttons by getting the
                // text in the edit box and making sure it has at least one
                // non-whitespace character
                WCHAR szName[ UNLEN+1 ];
                *szName = 0;
                GETTEXTEX gtex = { UNLEN, GT_DEFAULT, 1200, NULL, NULL };
                ::SendDlgItemMessage(pThis->m_hDlg, 
                    IDC_USER_NAME, EM_GETTEXTEX, (WPARAM)&gtex, (LPARAM)szName);

                WCHAR *pch = szName;
                for ( ; *pch && iswspace( *pch ); pch++ )
                {
                }

                ::EnableWindow( ::GetDlgItem( pThis->m_hDlg, IDOK ), (0 != *pch) );
                ::EnableWindow( ::GetDlgItem( pThis->m_hDlg, ID_NEXT ), (0 != *pch) );

                break;
            }
            
            if( LOWORD(wParam) == IDCANCEL ) 
            {
                EndDialog(hDlg, FALSE);
                return TRUE;
            }

            // user clicks the NEXT button
            if ( (LOWORD( wParam ) == ID_NEXT) || (LOWORD( wParam ) == IDOK) )
            {
                EPD_RETURN_VALUE eRet = pThis->ApplyChanges();

                if ( eRet == EPD_OK ) 
                {
                    if ( ID_NEXT == LOWORD(wParam) )
                    {
                        // Launch the micwiz, if we can

                        // Try to switch engines in case the user has changed engines
                        // without applying
                        HRESULT hr = g_pSRDlg->TrySwitchDefaultEngine( true );

                        if ( S_OK == hr )
                        {
                            SPDBG_ASSERT( g_pSRDlg->m_cpRecoEngine );

                            if ( g_pSRDlg->m_cpRecoEngine )
                            {
                                // Switch the recoprofile to the new one (might need to turn off
                                // recostate first

                                // Turn off recostate before calling SetRecoProfile() if necessary
                                SPRECOSTATE eOldRecoState = SPRST_INACTIVE;
                                g_pSRDlg->m_cpRecoEngine->GetRecoState( &eOldRecoState );
                                HRESULT hrRecoState = S_OK;
                                if ( SPRST_INACTIVE != eOldRecoState )
                                {
                                    hrRecoState = g_pSRDlg->m_cpRecoEngine->SetRecoState( SPRST_INACTIVE );
                                }

                                // Change to the newly-added recoprofile
                                HRESULT hrSetRecoProfile = E_FAIL;
                                if ( SUCCEEDED( hrRecoState ) )
                                {
                                    hrSetRecoProfile = 
                                        g_pSRDlg->m_cpRecoEngine->SetRecoProfile( pThis->m_cpToken );
                                
                                    // Restore the recostate
                                    g_pSRDlg->m_cpRecoEngine->SetRecoState( eOldRecoState );
                                }


                                // Bring on the micwiz and the training wiz
                                // Follow the yellow brick road.
                                g_pSRDlg->m_cpRecoEngine->DisplayUI(hDlg, NULL, SPDUI_MicTraining, NULL, 0);
                                if ( SUCCEEDED( hrSetRecoProfile ) )
                                {
                                    // Only want to train the profile if it actually _is_ this profile being 
                                    // used...
                                    g_pSRDlg->m_cpRecoEngine->DisplayUI(hDlg, NULL, SPDUI_UserTraining, NULL, 0);
                                }
                            }
                        }

                    // Switch back to original default, complaining about errors only if there
                    // wasn't a complaint from the call to TrySwitchDefaultEngine
                    hr = g_pSRDlg->ResetDefaultEngine( SUCCEEDED( hr ));
}

                    // now we are done
                    EndDialog(hDlg, TRUE);
                }
                else if ( eRet == EPD_DUP )  // user tried to enter a duplicate name
                {
                    // What name was added?
                    WCHAR szName[ UNLEN+1 ];
                    *szName = 0;
                    GETTEXTEX gtex = { UNLEN, GT_DEFAULT, 1200, NULL, NULL };
                    ::SendDlgItemMessage(pThis->m_hDlg, 
                        IDC_USER_NAME, EM_GETTEXTEX, (WPARAM)&gtex, (LPARAM)szName);

                    WCHAR pszDuplicate[MAX_LOADSTRING];
                    LoadString(_Module.GetResourceInstance(), 
                        g_pSRDlg->IsProfileNameInvisible( szName ) ? IDS_DUP_NAME_DELETED : IDS_DUP_NAME, 
                        pszDuplicate, MAX_LOADSTRING);
                    MessageBox( hDlg, pszDuplicate, g_pSRDlg->m_szCaption, MB_ICONEXCLAMATION | g_dwIsRTLLayout );
                }

            }
        }
        break;
    }
    return FALSE;
} /* UserNameDialogProc */

/*****************************************************************************
* CSRDlg::UserSelChange *
*-------------------------*
*   Description:
*       Changes the deafult user
****************************************************************** BRENTMID ***/
void CSRDlg::UserSelChange( int iSelIndex )
{
    HRESULT hr = S_OK;
    SPDBG_FUNC( "CSRDlg::UserSelChange" );

    // Get the selected item's token
    LVITEM lvitem;
    lvitem.iItem = iSelIndex;
    lvitem.iSubItem = 0;
    lvitem.mask = LVIF_PARAM;
    ::SendMessage( m_hUserList, LVM_GETITEM, 0, (LPARAM) &lvitem );
                    
    ISpObjectToken *pToken = (ISpObjectToken *) lvitem.lParam;

    if (pToken)
    {
        
        // Try to find the item in the list associated with the current default token
        LVFINDINFO lvfi;
        if ( iSelIndex >= 0 )
        {
            // Something was selected; this is the new default user
            lvfi.flags = LVFI_PARAM;
            lvfi.lParam = (LPARAM) m_pCurUserToken;
            int iCurDefaultIndex = (int)::SendMessage( m_hUserList, LVM_FINDITEM, -1, (LPARAM) &lvfi );
            
            if ( iCurDefaultIndex >= 0 )
            {
                // The current default has been found in the list; remove its checkmark
                SetCheckmark( m_hUserList, iCurDefaultIndex, false );
            }
            
            SetCheckmark( m_hUserList, iSelIndex, true );
            
            //set the default
            m_pCurUserToken = pToken;
            m_iLastSelected = iSelIndex;

            // Kick the Apply button
            KickCPLUI();
        }
    }
} /* CSRDlg::UserSelChange */

/*****************************************************************************
* CSRDlg::DeleteCurrentUser *
*-------------------------*
*   Description:
*       Deletes the default user
****************************************************************** BRENTMID ***/
void CSRDlg::DeleteCurrentUser()
{
    // Make sure that we haven't already deleted too many profiles to keep track of
    if ( m_iDeletedTokens >= iMaxDeletedProfiles_c )
    {
        WCHAR wszError[ MAX_LOADSTRING ];
        ::LoadString( _Module.GetResourceInstance(), IDS_MAX_PROFILES_EXCEEDED,
            wszError, MAX_LOADSTRING );
        ::MessageBox( m_hDlg, wszError, m_szCaption, MB_ICONEXCLAMATION | g_dwIsRTLLayout );
        
        return;
    }

    // First confirm this action with the user
    WCHAR pszAsk[ MAX_LOADSTRING ];
    WCHAR pszWinTitle[ MAX_LOADSTRING ];
    ::LoadString( _Module.GetResourceInstance(), IDS_ASK_CONFIRM, pszAsk, MAX_LOADSTRING );
    ::LoadString( _Module.GetResourceInstance(), IDS_ASK_TITLE, pszWinTitle, MAX_LOADSTRING );

    if ( MessageBox( m_hDlg, pszAsk, pszWinTitle, MB_YESNO | g_dwIsRTLLayout ) == IDNO )
    {
        // User said no.
        return;
    }

    // We need to hang onto the current user token, since when the focus
    // changes because of the delete, there will be a different m_pCurUserToken
    ISpObjectToken *pTokenToDelete = m_pCurUserToken;
    SPDBG_ASSERT( pTokenToDelete );
    if ( !pTokenToDelete )
    {
        return;
    }

    m_fDontDelete = TRUE;

    // Try to find the item in the list associated with the current default token
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM) pTokenToDelete;
    int iCurDefaultIndex = (int)::SendMessage( m_hUserList, LVM_FINDITEM, -1, (LPARAM) &lvfi );
    
    if ( iCurDefaultIndex >= 0 )
    {
        // The current default has been found in the list; remove its checkmark
        SetCheckmark( m_hUserList, iCurDefaultIndex, false );
    }
    
    //remove the token
    ::SendMessage( m_hUserList, LVM_DELETEITEM, iCurDefaultIndex, NULL );

    // now setup the new default

    // Get the first item's token
    LVITEM lvitem;
    lvitem.iItem = 0;
    lvitem.iSubItem = 0;
    lvitem.mask = LVIF_PARAM;
    ::SendMessage( m_hUserList, LVM_GETITEM, 0, (LPARAM) &lvitem );
                    
    ISpObjectToken *pToken = (ISpObjectToken *) lvitem.lParam;

    // set the selected item.
    // Focusing it will cause it to be the default
    lvitem.state = LVIS_SELECTED | LVIS_FOCUSED;
    lvitem.stateMask = LVIS_SELECTED | LVIS_FOCUSED;
    ::SendMessage( m_hUserList, LVM_SETITEMSTATE, 0, (LPARAM) &lvitem );

    SetCheckmark( m_hUserList, 0, true );
    
    // enable or disable the delete button based on # of profiles
    int iNumUsers = (int)::SendMessage(m_hUserList, LVM_GETITEMCOUNT, 0, 0);
    if (iNumUsers < 2) 
    {
        EnableWindow(GetDlgItem(m_hDlg, IDC_DELETE), FALSE);
    }
    else
    {
        EnableWindow(GetDlgItem(m_hDlg, IDC_DELETE), TRUE);
    }

    //set the focus back to the user profiles
    ::SetFocus(GetDlgItem( m_hDlg, IDC_USER ));

    // set the new default profile, inform the SR engine, and remove the old token
    SpSetDefaultTokenForCategoryId(SPCAT_RECOPROFILES, m_pCurUserToken );

    // Save the tokens in case the user clicks "Cancel"
    m_aDeletedTokens[m_iDeletedTokens] = pTokenToDelete;  // save the deleted token for possible "Cancel"
    m_iDeletedTokens++;  // increment the number deleted
    KickCPLUI();
    
    // Currently we immediately APPLY this deletion, since the user has already said "YES"
    // when the were prompted to confirm the delete.
    // If we want to have an "APPLY / CANCEL" thing happen, switch the #if 1 and #if 0

    // send the appropriate message to the parent
    HWND parentWin = ::GetParent( m_hDlg );


    // now the last selected token is gone, so note that
    m_iLastSelected = -1;

    // Sort the items initially
    ::SendMessage( m_hUserList, LVM_SORTITEMS, (LPARAM)m_pCurUserToken, LPARAM(&SortCols) );

    m_fDontDelete = FALSE;
}   /* CSRDlg::DeleteCurrentUser */

/*****************************************************************************
* CSRDlg::ProfileProperties *
*-------------------------*
*   Description:
*       Modifies the properites through engine UI
****************************************************************** BRENTMID ***/

void CSRDlg::ProfileProperties()
{
    if ( m_cpRecoEngine )
    {
        m_cpRecoEngine->DisplayUI(m_hDlg, NULL, SPDUI_RecoProfileProperties, NULL, 0);
    }
}

/*****************************************************************************
* CSRDlg::OnInitDialog *
*----------------------*
*   Description:
*       Dialog Initialization
****************************************************************** MIKEAR ***/
void CSRDlg::OnInitDialog(HWND hWnd)
{
    SPDBG_FUNC( "CSRDlg::OnInitDialog" );
    USES_CONVERSION;
    SPDBG_ASSERT(IsWindow(hWnd));

    m_hDlg = hWnd;
    
    // This will be the caption for all MessageBoxes
    m_szCaption[0] = 0;
    ::LoadString( _Module.GetResourceInstance(), IDS_CAPTION, m_szCaption, sp_countof( m_szCaption ) );

    m_hSRCombo = ::GetDlgItem( hWnd, IDC_COMBO_RECOGNIZERS );
    SpInitTokenComboBox( m_hSRCombo, SPCAT_RECOGNIZERS );

    // The first one in the list will be the current default
    int iSelected = (int) ::SendMessage( m_hSRCombo, CB_GETCURSEL, 0, 0 );
    ISpObjectToken *pCurDefault = (ISpObjectToken *) ::SendMessage( m_hSRCombo, CB_GETITEMDATA, iSelected, 0 );
    m_pCurRecoToken = pCurDefault;
    m_pDefaultRecToken = pCurDefault;

    // This simulates selecting the default engine - ensures the UI is setup correctly.
    EngineSelChange(TRUE);

    InitUserList( hWnd );
    m_hUserList = ::GetDlgItem( hWnd, IDC_USER );

    ::SendMessage( m_hUserList, LVM_SETCOLUMNWIDTH, 0, MAKELPARAM((int) LVSCW_AUTOSIZE, 0) );

    int iNumUsers = (int)::SendMessage(m_hUserList, LVM_GETITEMCOUNT, 0, 0);
    if (iNumUsers < 2) 
    {
        EnableWindow(GetDlgItem(m_hDlg, IDC_DELETE), FALSE);
    }
    else
    {
        EnableWindow(GetDlgItem(m_hDlg, IDC_DELETE), TRUE);
    }

    //set the focus back to the user profiles
    ::SetFocus(GetDlgItem( m_hDlg, IDC_USER ));

} /* CSRDlg::OnInitDialog */

/*****************************************************************************
* CSRDlg::SetCheckmark *
*----------------------*
*   Description:
*       Sets the specified item in the list control to be either checked
*       or unchecked (as the default user)
******************************************************************************/
void CSRDlg::SetCheckmark( HWND hList, int iIndex, bool bCheck )
{
    ListView_SetCheckState( hList, iIndex, bCheck );
}   /* CSRDlg::SetCheckmark */

/*****************************************************************************
* CSRDlg::OnDestroy *
*-------------------*
*   Description:
*       Destruction
****************************************************************** MIKEAR ***/
void CSRDlg::OnDestroy()
{
    SPDBG_FUNC( "CSRDlg::OnDestroy" );

    // spuihelp will take care of releasing its own tokens
    SpDestroyTokenComboBox( m_hSRCombo );

    // The tokens kepts as itemdata in the reco profile list were 
    // released in the LVN_DELETEITEM code

    // Shuts off the reco engine
    ShutDown();

} /* CSRDlg::OnDestroy */

/*****************************************************************************
* CSRDlg::ShutDown *
*------------------*
*   Description:
*       Shuts down by releasing the engine and reco context
****************************************************************** MIKEAR ***/
void CSRDlg::ShutDown()
{

    // Release objects
    m_cpRecoCtxt.Release();
    m_cpRecoEngine.Release();

}   /* CSRDlg::ShutDown */

/************************************************************
* CSRDlg::InitUserList
*
*   Description:
*       Initializes user list
*********************************************** BRENTMID ***/
void CSRDlg::InitUserList(HWND hWnd)
{
    const int iInitWidth_c = 260;  // pixel width of "Description Column"

    // Set up the "Description" column for the settings display
    m_hUserList = ::GetDlgItem( hWnd, IDC_USER );
    WCHAR pszColumnText[ UNLEN+1 ] = L"";
    LVCOLUMN lvc;
    lvc.mask = LVCF_FMT| LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;

    ::LoadString( _Module.GetResourceInstance(), IDS_DESCRIPT, pszColumnText, UNLEN );
    lvc.pszText = pszColumnText;
    lvc.iSubItem = 0;
    lvc.cx = iInitWidth_c;
    lvc.fmt = LVCFMT_LEFT;
    ListView_InsertColumn( m_hUserList, 1, &lvc );

    // This should be a checkbox list
    ::SendMessage( m_hUserList, LVM_SETEXTENDEDLISTVIEWSTYLE, LVS_EX_CHECKBOXES, LVS_EX_CHECKBOXES );

    PopulateList();

    // Sort the items initially
    ::SendMessage( m_hUserList, LVM_SORTITEMS, (LPARAM)m_pCurUserToken, LPARAM(&SortCols) );

}   // CSRDlg::InitUserList

/************************************************************
* CSRDlg::PopulateList
*
*   Description:
*       Populates user list
*********************************************** BRENTMID ***/
void CSRDlg::PopulateList()
{
    USES_CONVERSION;

    // Populate the list control
    int                             iIndex = 0;
    LVITEM                          lvitem;
    CComPtr<IEnumSpObjectTokens>    cpEnum;
    ISpObjectToken                  *pToken;
    WCHAR                           *pszAttrib = NULL;

    HRESULT hr;

    // this is to lazily init the user profile if there are none - DON'T REMOVE
    if ( m_cpRecoEngine )
    {
        CComPtr<ISpObjectToken> cpTempToken;
        m_cpRecoEngine->GetRecoProfile(&cpTempToken);
    }

    // Now clear the list
    ListView_DeleteAllItems( m_hUserList );

    // We will list the tokens in the order they are enumerated
    hr = SpEnumTokens(SPCAT_RECOPROFILES, NULL, NULL, &cpEnum);

    if (hr == S_OK)
    {
        bool fSetDefault = false;
        while (cpEnum->Next(1, &pToken, NULL) == S_OK)
        {
            // first check to see if the token is in the "Deleted List"
            bool f_isDel = false;

            for (int iDel = 0; iDel < m_iDeletedTokens; iDel++)
            {
                CSpDynamicString dstrT1;
                CSpDynamicString dstrT2;

                pToken->GetId( &dstrT1 );
                m_aDeletedTokens[ iDel ]->GetId( &dstrT2 );

                if (dstrT1.m_psz && dstrT2.m_psz && !wcscmp(dstrT1.m_psz, dstrT2.m_psz))
                {
                    f_isDel = true;
                }
            }

            // if we should show it
            if ( f_isDel )
            {
                // This token has a refcounted reference to it on the deleted list:
                // this reference should be released
                pToken->Release();
            }
            else 
            {
                // Not a pending delete: We should show it

                // now insert the token 
                lvitem.mask = LVIF_TEXT | LVIF_PARAM | LVIF_STATE;
                lvitem.iItem = iIndex;
                lvitem.iSubItem = 0;
                lvitem.lParam = (LPARAM) pToken;
                
                CSpDynamicString cUser;
                SpGetDescription(pToken, &cUser);
                lvitem.pszText = cUser;
                
                // if this is the default it should be selected/focused
                if ( !fSetDefault )
                {
                    lvitem.state = LVIS_SELECTED | LVIS_FOCUSED;
                }
                else
                {
                    lvitem.state = 0;
                }
                
                iIndex = (int)::SendMessage( m_hUserList, LVM_INSERTITEM, 0, (LPARAM) &lvitem );

                // the default is the first token returned by cpEnum->Next
                if ( !fSetDefault )
                {
                    fSetDefault = true;
                    
                    // Put the checkmark there
                    SetCheckmark( m_hUserList, iIndex, true );
                    m_pCurUserToken = pToken;
                            
                    // Set the m_dstrOldUserTokenId to the first default if it hasn't been set yet.
                    if ( !m_dstrOldUserTokenId )
                    {
                        m_pCurUserToken->GetId( &m_dstrOldUserTokenId );
                    }
                }
                
                iIndex++;
            }
        }

        // Autosize according to the strings now in the list
        ::SendMessage( m_hUserList, LVM_SETCOLUMNWIDTH, 0, MAKELPARAM((int) LVSCW_AUTOSIZE, 0) );
    }

    // now find the default item so we can scroll to it
    // Try to find the item in the list associated with the current default token
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM) m_pCurUserToken;
    int iCurDefaultIndex = (int)::SendMessage( m_hUserList, LVM_FINDITEM, -1, (LPARAM) &lvfi );
        
    if ( iCurDefaultIndex >= 0 )
    {
        // The current default has been found in the list; scroll to it
        ListView_EnsureVisible( m_hUserList, iCurDefaultIndex, false );
    }
    
    // Name the list view something appropriate
    WCHAR pszListName[ MAX_LOADSTRING ];
    ::LoadString( _Module.GetResourceInstance(), IDS_PROFILE_LIST_NAME, pszListName, MAX_LOADSTRING );
    ::SendMessage( m_hUserList, WM_SETTEXT, 0, (LPARAM)pszListName );
}

/*****************************************************************************
* CSRDlg::OnApply *
*-----------------*
*   Description:
*       Set user specified options
****************************************************************** MIKEAR ***/
void CSRDlg::OnApply()
{
    SPDBG_FUNC( "CSRDlg::OnApply" );

    int iSelected = (int) ::SendMessage( m_hSRCombo, CB_GETCURSEL, 0, 0 );
    ULONG ulFlags = 0;

    // Pick up the recognizer change, if any
    bool fRecognizerChange = false;
    ISpObjectToken *pToken = NULL;
    if ( HasRecognizerChanged() )
    {
        pToken = (ISpObjectToken *) ::SendMessage( m_hSRCombo, CB_GETITEMDATA, iSelected, 0 );
        if ( CB_ERR == (LRESULT) pToken )
        {
            pToken = NULL;
        }

        HRESULT hrEngine = S_OK;
        if (pToken && (iSelected >=0))
        {
            hrEngine = SpSetDefaultTokenForCategoryId(SPCAT_RECOGNIZERS, pToken );
            if (FAILED(hrEngine))
            {
                WCHAR szError[256];
                szError[0] = '\0';
                LoadString(_Module.GetResourceInstance(), IDS_DEFAULT_ENGINE_WARNING, szError, sp_countof(szError));
                MessageBox(m_hDlg, szError, MB_OK, MB_ICONWARNING | g_dwIsRTLLayout);
            }
            else
            {
                fRecognizerChange = true;
            }
        }
    }

    // Pick up any audio changes that may have been made
    HRESULT hrAudio = S_OK;
    bool fAudioChange = false;
    if ( m_pAudioDlg )
    {
        fAudioChange = m_pAudioDlg->IsAudioDeviceChanged();

        if ( fAudioChange )
        {
            hrAudio = m_pAudioDlg->OnApply();
        }

        if ( FAILED( hrAudio ) )
        {
            WCHAR szError[256];
            szError[0] = '\0';
            LoadString(_Module.GetResourceInstance(), IDS_AUDIO_CHANGE_FAILED, szError, sp_countof(szError));
            MessageBox(m_hDlg, szError, NULL, MB_ICONWARNING|g_dwIsRTLLayout);
        }

        // Kill the audio dialog, as we are done with it.
        delete m_pAudioDlg;
        m_pAudioDlg = NULL;
    }
    
    // Permanently delete any profiles the user has deleted
    for (int iIndex = 0; iIndex < m_iDeletedTokens; iIndex++)
    {
        HRESULT hr = m_aDeletedTokens[iIndex]->Remove(NULL);

        if (FAILED(hr))
        {
            // might fail if a user has another app open
            WCHAR szError[256];
            szError[0] = '\0';
            LoadString(_Module.GetResourceInstance(), IDS_REMOVE_WARNING, szError, sp_countof(szError));
            MessageBox(m_hDlg, szError, MB_OK, MB_ICONWARNING|g_dwIsRTLLayout);

            // This will make sure that the attempted deleted item shows up again
            PopulateList();
        }
        else
        {
            // The token is now removed, we can release it
            m_aDeletedTokens[iIndex]->Release();
        }
    }
    m_iDeletedTokens = 0;

    // The added token list's tokens were added as they were put onto the list,
    // so just clear the list so that they stay added at the end
    m_iAddedTokens = 0;

    // Now we don't care about the old user because of the apply
    m_dstrOldUserTokenId.Clear();
    m_pCurUserToken->GetId( &m_dstrOldUserTokenId );
    
    ChangeDefaultUser();

    // Kick the engine to pick up the changes.
    // Note that the recoprofile change would have taken effect when
    // we selected that list item, and that there is no way to 
    // pick up the audio changes right now since SetInput() is not
    // implemented for shared engines.
    if ( fRecognizerChange || fAudioChange )
    {
        BOOL fRecoContextInitialized = FALSE;

        if (fRecognizerChange)
        {
            ulFlags |= SRDLGF_RECOGNIZER;
        }

        if (fAudioChange)
        {
            ulFlags |= SRDLGF_AUDIOINPUT;
        }

        HRESULT hr = CreateRecoContext( &fRecoContextInitialized, FALSE, ulFlags);
        if ( FAILED( hr ) )
        {
            RecoContextError( fRecoContextInitialized, TRUE, hr );
        }

        if ( fRecognizerChange )
        {
            SPDBG_ASSERT( pToken );
            m_pDefaultRecToken = pToken;
        }

        EngineSelChange();
    }

    if(m_cpRecoEngine)
    {
        m_cpRecoEngine->SetRecoState( SPRST_ACTIVE );
    }

} /* CSRDlg::OnApply */

/************************************************************
* CSRDlg::OnDrawItem
*
*   Description:
*       Handles drawing items in the list view
*********************************************** BRENTMID ***/
void CSRDlg::OnDrawItem( HWND hWnd, const DRAWITEMSTRUCT * pDrawStruct )
{
    RECT rcClip;
    LVITEM lvi;
    UINT uiFlags = ILD_TRANSPARENT;
    HIMAGELIST himl;
    int cxImage = 0, cyImage = 0;
    UINT uFirstColWidth;

    // Get the item image to be displayed
    lvi.mask = LVIF_IMAGE | LVIF_STATE | LVIF_PARAM;
    lvi.iItem = pDrawStruct->itemID;
    lvi.iSubItem = 0;
    ListView_GetItem(pDrawStruct->hwndItem, &lvi);

    // We want to be drawing the current default as selected
    LVFINDINFO lvfi;
    lvfi.flags = LVFI_PARAM;
    lvfi.lParam = (LPARAM) m_pCurUserToken;
    UINT uiCurDefaultIndex = (UINT)::SendMessage( m_hUserList, LVM_FINDITEM, -1, (LPARAM) &lvfi );
    bool fSelected = (uiCurDefaultIndex == pDrawStruct->itemID);
    
    // Check to see if this item is selected
    if ( fSelected )
    {
        // Set the text background and foreground colors
        SetTextColor(pDrawStruct->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        SetBkColor(pDrawStruct->hDC, GetSysColor(COLOR_HIGHLIGHT));
    }
    else
    {
        // Set the text background and foreground colors to the standard window
        // colors
        SetTextColor(pDrawStruct->hDC, GetSysColor(COLOR_WINDOWTEXT));
        SetBkColor(pDrawStruct->hDC, GetSysColor(COLOR_WINDOW));
    }

    // Get the image list and draw the image.
    // The image list will consist of the checked box and the unchecked box
    // for the LVS_EX_CHECKBOXES style
    himl = ListView_GetImageList(pDrawStruct->hwndItem, LVSIL_STATE);
    if (himl)
    {
        // For a LVS_EX_CHECKBOXES style, image 0 is unchecked and image 1 is checked
        ImageList_Draw(himl, 
            fSelected ? 1 : 0, 
            pDrawStruct->hDC,
            pDrawStruct->rcItem.left, pDrawStruct->rcItem.top,
            uiFlags);

        // Find out how big the image we just drew was
        ImageList_GetIconSize(himl, &cxImage, &cyImage);
    }

    // Calculate the width of the first column after the image width.  If
    // There was no image, then cxImage will be zero.
    LVCOLUMN pColumn;
    pColumn.mask = LVCF_WIDTH;
    ::SendMessage( m_hUserList, LVM_GETCOLUMN, 0, (LPARAM)&pColumn );

    int iColWidth = pColumn.cx;  // pixel width of "Description Column"
    uFirstColWidth = iColWidth - cxImage;

    // Set up the new clipping rect for the first column text and draw it
    rcClip.left = pDrawStruct->rcItem.left + cxImage;
    rcClip.right = pDrawStruct->rcItem.left + iColWidth;
    rcClip.top = pDrawStruct->rcItem.top;
    rcClip.bottom = pDrawStruct->rcItem.bottom;

    ISpObjectToken *pToken = (ISpObjectToken *) lvi.lParam;
    CSpDynamicString dstrTokenName;
    SpGetDescription(pToken, &dstrTokenName);

    DrawItemColumn(pDrawStruct->hDC, dstrTokenName, &rcClip);

    // If we changed the colors for the selected item, undo it
    if ( fSelected )
    {
        // Set the text background and foreground colors
        SetTextColor(pDrawStruct->hDC, GetSysColor(COLOR_WINDOWTEXT));
        SetBkColor(pDrawStruct->hDC, GetSysColor(COLOR_WINDOW));
    }

    // If the item is focused, now draw a focus rect around the entire row
    if (pDrawStruct->itemState & ODS_FOCUS)
    {
        // Adjust the left edge to exclude the image
        rcClip = pDrawStruct->rcItem;
        rcClip.left += cxImage;

        // Draw the focus rect
        if ( ::GetFocus() == m_hUserList )
        {
            DrawFocusRect(pDrawStruct->hDC, &rcClip);
        }
    }

}   // CSRDlg::OnDrawItem

/************************************************************
* CSRDlg::DrawItemColumn
*
*   Description:
*       Handles drawing of the column data
*********************************************** BRENTMID ***/
void CSRDlg::DrawItemColumn(HDC hdc, WCHAR* lpsz, LPRECT prcClip)
{
    USES_CONVERSION;

    int iHeight = 0;    // Will cause CreateFont() to use default in case we
                        // don't get the height below
    
    // Get the height of the text
    if (hdc)
    {
        TEXTMETRIC tm;
        
        if (GetTextMetrics(hdc, &tm))
        {
            iHeight = tm.tmHeight;
        }
    }

    // link the font
    LCID dwLCID = GetUserDefaultLCID();

    // Pick an appropriate font.  On Windows 2000, let the system fontlink.
    
    DWORD dwVersion = GetVersion();
    HFONT hfontNew = NULL;
    HFONT hfontOld = NULL;

    if (   (dwVersion >= 0x80000000)
        || (LOBYTE(LOWORD(dwVersion)) < 5 ) )
    {
        // Less than NT5: Figure out what font

        WCHAR achCodePage[6];
        UINT uiCodePage;
        
        if (0 != GetLocaleInfo(dwLCID, LOCALE_IDEFAULTANSICODEPAGE, achCodePage, 6))
        {
            uiCodePage = _wtoi(achCodePage);
        }
        else
        {
            uiCodePage = GetACP();
        }
        
        CComPtr<IMultiLanguage> cpMultiLanguage;
        MIMECPINFO MimeCpInfo;
        
        if (   SUCCEEDED(cpMultiLanguage.CoCreateInstance(CLSID_CMultiLanguage))
            && SUCCEEDED(cpMultiLanguage->GetCodePageInfo(uiCodePage, &MimeCpInfo)))
        {
            USES_CONVERSION;
            hfontNew = CreateFont(iHeight, 0, 0, 0, FW_NORMAL, 0, 0, 0,
                MimeCpInfo.bGDICharset,
                OUT_DEFAULT_PRECIS,
                CLIP_DEFAULT_PRECIS,
                DEFAULT_QUALITY,
                DEFAULT_PITCH,
                MimeCpInfo.wszProportionalFont);
            
        }

        cpMultiLanguage.Release();
    }

    if ( hfontNew )
    {
        hfontOld = (HFONT) ::SelectObject( hdc, hfontNew );
    }

    CSpDynamicString szString;
    CSpDynamicString szNewString;

    // Check to see if the string fits in the clip rect.  If not, truncate
    // the string and add "...".
    szString = lpsz;
    szNewString = CalcStringEllipsis(hdc, szString, UNLEN, prcClip->right - prcClip->left);
    szString =  szNewString;
        
    // print the text
    ExtTextOutW(hdc, prcClip->left + 2, prcClip->top + 2, ETO_CLIPPED | ETO_OPAQUE,
               prcClip, szString.m_psz, szString.Length(), NULL);

    // Replace the old font
    if ( hfontNew )
    {
        ::SelectObject( hdc, hfontOld );
        ::DeleteObject( hfontNew );
    }

}

/************************************************************
* CSRDlg::CalcStringEllipsis
*
*   Description:
*       If the text won't fit in the box, edit it, and make
*       it have ellipses
*********************************************** BRENTMID ***/
CSpDynamicString CSRDlg::CalcStringEllipsis(HDC hdc, CSpDynamicString lpszString, int cchMax, UINT uColWidth)
{
    USES_CONVERSION;

    WCHAR  szEllipsis[] = L"...";
    SIZE   sizeString;
    SIZE   sizeEllipsis;
    int    cbString;
    CSpDynamicString lpszTemp;
    BOOL   fSuccess = FALSE;

    // Adjust the column width to take into account the edges
    uColWidth -= 4;

    lpszTemp = lpszString;

    // Get the width of the string in pixels
    cbString = lpszTemp.Length();
    if (!::GetTextExtentPoint32(hdc, lpszTemp, cbString, &sizeString))
    {
        SPDBG_ASSERT(FALSE);
    }

    // If the width of the string is greater than the column width shave
    // the string and add the ellipsis
    if ((ULONG)sizeString.cx > uColWidth)
    {
        if (!::GetTextExtentPoint32(hdc, szEllipsis, lstrlen(szEllipsis),
            &sizeEllipsis))
        {
            SPDBG_ASSERT(FALSE);
        }

        while ((cbString > 0) && (fSuccess == FALSE))
        {
            lpszTemp[--cbString] = 0;
            if (!::GetTextExtentPoint32(hdc, lpszTemp, cbString, &sizeString))
            {
                SPDBG_ASSERT(FALSE);
            }
            
            if ((ULONG)(sizeString.cx + sizeEllipsis.cx) <= uColWidth)
            {
                // The string with the ellipsis finally fits, now make sure
                // there is enough room in the string for the ellipsis
                if (cchMax >= (cbString + lstrlen(szEllipsis)))
                {
                    // Concatenate the two strings and break out of the loop
                    lpszTemp.Append( szEllipsis );
                    lpszString = lpszTemp;
                    fSuccess = TRUE;
                }
            }
        }
    }
    else
    {
        // No need to do anything, everything fits great.
        fSuccess = TRUE;
    }

    return (lpszString);
}  // CSRDlg::CalStringEllipsis

/************************************************************
* CSRDlg::ChangeDefaultUser
*
*   Description:
*       Handles changes to the environment settings
*********************************************** BRENTMID ***/
void CSRDlg::ChangeDefaultUser()
{
    HRESULT hr;
    
    if (m_pCurUserToken)
    {
        hr = SpSetDefaultTokenForCategoryId(SPCAT_RECOPROFILES, m_pCurUserToken);
    }

    // Sort the items initially
    ::SendMessage( m_hUserList, LVM_SORTITEMS, (LPARAM)m_pCurUserToken, LPARAM(&SortCols) );

}   // CSRDlg::ChangeDefaultUser

/************************************************************
* CSRDlg::OnCancel
*
*   Description:
*       Handles undoing changes to the environment settings
*********************************************** BRENTMID ***/
void CSRDlg::OnCancel()
{
    // Get the original user and make sure that is still the default.
    // Note that in general m_pCurUserToken does not AddRef the 
    // ISpObjectToken it points to, so this is OK.
    SpGetTokenFromId( m_dstrOldUserTokenId, &m_pCurUserToken );

    ChangeDefaultUser();
    
    // Set the old recoprofile so that none of the profiles added in this
    // session will be in use:
    // This allows us to roll back the adds below
    // m_pCurUserToken does the trick since it is guaranteed to have
    // been around before this session

    if (m_cpRecoEngine)
    {
        m_cpRecoEngine->SetRecoState( SPRST_INACTIVE );
        m_cpRecoEngine->SetRecoProfile( m_pCurUserToken );
        m_cpRecoEngine->SetRecoState( SPRST_ACTIVE );
    }

    // Roll back and delete any new profiles added
    int cItems = (int) ::SendMessage( m_hUserList, LVM_GETITEMCOUNT, 0, 0 );
    LVITEM lvitem;
    for ( int i = 0; i < m_iAddedTokens; i++ )
    {
        // Look for the list item with a ref out on this token.
        // We need to do this because in order for a token to be successfully 
        // removed the only existing ref to that token has to call the Remove() 
        // method.  The list is holding a ref to that item.
        bool fFound = false;
        for ( int j=0; !fFound && (j < cItems); j++ )
        {
            ::memset( &lvitem, 0, sizeof( lvitem ) );
            lvitem.iItem = j;
            lvitem.mask = LVIF_PARAM;
            ::SendMessage( m_hUserList, LVM_GETITEM, 0, (LPARAM) &lvitem );

            CSpDynamicString dstrItemId;
            ISpObjectToken *pItemToken = (ISpObjectToken *) lvitem.lParam;
            if ( pItemToken )
            {
                HRESULT hrId = pItemToken->GetId( &dstrItemId );
                if ( SUCCEEDED( hrId ) && 
                    dstrItemId && m_aAddedTokens[i] && 
                    ( 0 == wcscmp( dstrItemId, m_aAddedTokens[ i ] ) ) )
                {
                    // Should this fail, the profile just doesn't get removed: big deal 
                    pItemToken->Remove( NULL );
                    fFound = true;
                }
            }
        }
        
    }

    // We AddRefed it...
    m_pCurUserToken->Release();
}   // CSRDlg::OnCancel


/*****************************************************************************
* CSRDlg::EngineSelChange *
*-------------------------*
*   Description:
*       This function updates the list box when the user selects a new engine.
*       If queries the token to see which UI items the engine supports.
*       The parameter fInitialize determines if the engine is actually created.
*       It does NOT actually change the default engine.
****************************************************************** MIKEAR ***/
void CSRDlg::EngineSelChange(BOOL fInitialize)
{
    HRESULT hr = S_OK;
    SPDBG_FUNC( "CSRDlg::EngineSelChange" );

    int iSelected = (int) ::SendMessage( m_hSRCombo, CB_GETCURSEL, 0, 0 );
    ISpObjectToken *pToken = (ISpObjectToken *) ::SendMessage( m_hSRCombo, CB_GETITEMDATA, iSelected, 0 );
    if ( CB_ERR == (LRESULT) pToken )
    {
        pToken = NULL;
    }

    if (pToken)
    {
        // Now the current reco token is the one we got off the currently-selected combobox item
        m_pCurRecoToken = pToken;

        // Kick the UI to enable the Apply button if necessary
        KickCPLUI();

        HRESULT hrRecoContextOK = S_OK;
        if(fInitialize)
        {
            BOOL fContextInitialized = FALSE;
            hrRecoContextOK = CreateRecoContext(&fContextInitialized, TRUE); 
            if ( FAILED( hrRecoContextOK ) )
            {
                RecoContextError( fContextInitialized, true, hrRecoContextOK );
            }
        }
        
        if ( FAILED( hrRecoContextOK ) )
        {
            // Don't continue, all the buttons are grayed out,
            // which is what we want
            return;
        }
    }

    // Check for something being wrong, in which case we want to gray out all
    // the UI and stop here.
    // For instance, if we had trouble creating the reco context that's supposed to
    // be on now (the one for m_pDefaultRecToken), we certainly shouldn't
    // enable the UI buttons...
    if ( !pToken || (!m_cpRecoCtxt && (pToken == m_pDefaultRecToken)) )
    {
        RecoContextError( FALSE, FALSE );
        return;
    }

    // Determine if the training UI component is supported.
    // We can pass the current reco engine in as an argument only
    // if it's the same as the one who's token we're asking about.
    IUnknown *punkObject = (pToken == m_pDefaultRecToken) ? m_cpRecoEngine : NULL;
    BOOL fSupported = FALSE;
    hr = pToken->IsUISupported(SPDUI_UserTraining, NULL, 0, punkObject, &fSupported);
    if (FAILED(hr))
    {
        fSupported = FALSE;
    }
    ::EnableWindow(::GetDlgItem(m_hDlg, IDC_USERTRAINING), fSupported);

    // Determine if the Mic Wiz UI component is supported
    fSupported = FALSE;
    hr = pToken->IsUISupported(SPDUI_MicTraining, NULL, 0, punkObject, &fSupported);
    if (FAILED(hr))
    {
        fSupported = FALSE;
    }
    ::EnableWindow(::GetDlgItem(m_hDlg, IDC_MICWIZ), fSupported);

    // Determine if the Engine Prop UI component is supported
    fSupported = FALSE;
    hr = pToken->IsUISupported(SPDUI_EngineProperties, NULL, 0, punkObject, &fSupported);
    if (FAILED(hr))
    {
        fSupported = FALSE;
    }
    ::EnableWindow(::GetDlgItem(m_hDlg, IDC_SR_ADV), fSupported);


    // Determine if the Reco Profile Prop UI component is supported
    fSupported = FALSE;
    hr = pToken->IsUISupported(SPDUI_RecoProfileProperties, NULL, 0, punkObject, &fSupported);
    if (FAILED(hr))
    { 
        fSupported = FALSE;
    }
    ::EnableWindow(::GetDlgItem(m_hDlg, IDC_MODIFY), fSupported);
        
} /* CSRDlg::EngineSelChange */

/*****************************************************************************
* CSRDlg::IsCurRecoEngineAndCurRecoTokenMatch *
*---------------------------------------------*
*   Description:
*       Returns true in pfMatch iff the m_pCurRecoToken is the same
*       as the token for m_cpRecoEngine.
*   Return:
*       S_OK
*       E_POINTER
*       Failed HRESULTs from any of the SAPI calls
****************************************************************** BECKYW ***/
HRESULT CSRDlg::IsCurRecoEngineAndCurRecoTokenMatch( bool *pfMatch )
{
    if ( !pfMatch )
    {
        return E_POINTER;
    }

    if ( !m_cpRecoEngine || !m_pCurRecoToken )
    {
        return E_FAIL;
    }

    *pfMatch = false;

    // This gets the object token for the engine
    CComPtr<ISpObjectToken> cpRecoEngineToken;
    HRESULT hr = m_cpRecoEngine->GetRecognizer( &cpRecoEngineToken );
    
    WCHAR *pwszRecoEngineTokenID = NULL;
    WCHAR *pwszCurRecoTokenID = NULL;
    if ( SUCCEEDED( hr ) )
    {
        hr = cpRecoEngineToken->GetId( &pwszRecoEngineTokenID );
    }
    if ( SUCCEEDED( hr ) )
    {
        hr = m_pCurRecoToken->GetId( &pwszCurRecoTokenID );
    }

    if ( pwszRecoEngineTokenID && pwszCurRecoTokenID )
    {
        *pfMatch = ( 0 == wcscmp( pwszRecoEngineTokenID, pwszCurRecoTokenID ) );
    }

    return hr;
}   /* CSRDlg::IsCurRecoEngineAndCurRecoTokenMatch */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\silence.h ===
/*********************************************************************
Silence.H - Includes to use the code to detect silence.

begun 5/14/94 by Mike Rozak
*/

#ifndef _SILENCE_H_
#define _SILENCE_H_

#ifndef _SPEECH_
typedef unsigned _int64 QWORD, *PQWORD;

#endif


/*********************************************************************
Typedefs */

#define  SIL_YES              (2)
#define  SIL_NO               (0)
#define  SIL_UNKNOWN          (1)

// #define  SIL_SAMPRATE         (11025)     // assumed sampling rate
#define  PHADD_BEGIN_SILENCE  (4)         // 1/4 second
#define  PCADD_BEGIN_SILENCE  (4)         // 1/4 second
#define  FILTERNUM            (1024)      // max # samples i nthe filter
#if 0
#define  MAXVOICEHZ           (300)       // maximum voice pitchm in hz
#define  PHMAXVOICEHZ         (300)       // maximum voice pitch in hz (phone)
#endif
#define  PHMAXVOICEHZ         (500)       // maximum voice pitch in hz (phone)
#define  PCMAXVOICEHZ         (500)       // maximum voice pitch in hz (PC)
#define  MINVOICEHZ           (50)        // minimum voice pitch in hz

// Store characteristics of a block
typedef struct {
   WORD     wMaxLevel;
   WORD     wMaxDelta;
   BYTE     bIsVoiced;
   BYTE     bHighLevel;
   BYTE     bHighDelta;
} BLOCKCHAR, *PBLOCKCHAR;

// Store information about a block
typedef struct {
   short   *pSamples;     // Sample data, or NULL if empty
   DWORD   dwNumSamples;  // number of samples in block
   QWORD   qwTimeStamp;   // time stamp for block
} BINFO, *PBINFO;

class CSilence {
   private:
      WORD     m_wBlocksPerSec;
      WORD     m_wBlocksInQueue;
      WORD     m_wLatestBlock;   // points to the last block entered in the circular list
      PBINFO   m_paBlockInfo;
      DWORD    m_dwSoundBits;
      DWORD    m_dwVoicedBits;   // turned on if block was voiced
      BLOCKCHAR m_bcSilence;     // what silence is
      BOOL     m_fFirstBlock;    // TRUE if the next block is the first
                                 // block ever, and used to judge silence, else FALSE
      BOOL     m_fInUtterance;   // TRUE if we're in an utterance
      DWORD    m_dwUtteranceLength; // Number of frames that utterance has gone on
      WORD     m_wReaction;      // reaction time
      WORD     m_wNoiseThresh;   // noiuse threshhold
      short    *m_pASFiltered;   // pointer to filtered data buffer
      WORD     m_wAddSilenceDiv;
      DWORD    m_dwHighFreq;
      DWORD    m_dwSamplesPerSec;
#ifdef USE_REG_ENG_CTRL
   BOOL   m_fSilenceDetectEnbl;
   BOOL   m_fVoiceDetectEnbl;
   WORD   m_wTimeToCheckDiv;
   DWORD   m_dwLowFreq;
   DWORD   m_dwCheckThisManySamples;
   DWORD   m_dwNumFilteredSamples;
   WORD   m_wMinConfidenceAdj;
   DWORD   m_dwLPFShift;
   DWORD   m_dwLPFWindow;
#endif

   public:
      CSilence (WORD wBlocksPerSec);
      ~CSilence (void);

      BOOL Init(BOOL fPhoneOptimized, DWORD dwSamplesPerSec);
      BOOL AddBlock (short * pSamples, DWORD dwNumSamples, WORD * wVU,
            QWORD qwTimeStamp);
      short * GetBlock (DWORD * pdwNumSamples, QWORD * pqwTimeStamp);
      void KillUtterance(void);
      void NoiseResistSet (WORD wValue)
         {
         m_wNoiseThresh = wValue;
         };
      void ReactionTimeSet (DWORD dwTime)
         {m_wReaction = (WORD) ((dwTime * m_wBlocksPerSec) / 1000);};
      WORD GetBackgroundNoise (void)
         {return m_bcSilence.wMaxLevel;};
      void ExpectNoiseChange (WORD wValue);

   private:
      BOOL CSilence::IsSegmentVoiced (short *pSamples, DWORD dwNumSamples,
            DWORD dwSamplesPerSec, WORD wMinConfidence, short *asFiltered);
      BOOL CSilence::WhatsTheNewState (DWORD dwSoundBits, DWORD dwVoicedBits,
            BOOL fWasInUtterance, BOOL fLongUtterance,
            WORD wBlocksPerSec, WORD *wStarted, WORD wReaction);
};

typedef CSilence *PCSilence;

WORD NEAR PASCAL TrimMaxAmp(short * lpS, DWORD dwNum);

#endif   // _SILENCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\silence.cpp ===
/*********************************************************************
Silence.Cpp - Code for detecting silence on an incoming audio stream

begun 5/14/94 by Mike Rozak
Modified 12/10/96 by John Merrill to fix up alignment problems
*/


#include "stdafx.h"
#include <malloc.h>
#include "silence.h"

// temporary
#pragma warning(disable: 4100 4244) 

/*********************************************************************
LowPassFilter - This low-pass filters 16-bit mono PCM data from one
   buffer into another.

inputs
   short    *lpSrc - Source buffer
   DWORD    dwNumSamples - Number of samples in the source buffer
   short    *lpDst - Destination buffer. This will be filled in
               with a low-passed version. It will have about an 8
               sample lag. This must be as large as lpSrc.
   short    *psMax - Filled in with the new maximum.
               If NULL then nothing is copied.
   short    *psMin - Filled in with the new minimum
               If NULL then nothing is copied.
   short    *psAvg - Filled in with the new average
               If NULL then nothing is copied.
   DWORD    dwSamplesPerSec
returns
   DWORD - Number of samples returned. This will be <= dwNumSamples,
      possible dwNumSamples - 7.
*/
DWORD LowPassFilter (short *lpSrc, DWORD dwNumSamples, short *lpDst,
   short *psMax, short *psMin, short *psAvg, DWORD dwSamplesPerSec)
{
    SPDBG_FUNC( "LowPassFilter" );
DWORD    i;
long     lSum;
short    sSum, sMax, sMin;
short    *lpLag;
BOOL     fLow = (dwSamplesPerSec < 13000);

#define  SHIFTRIGHT        (fLow ? 3 : 4)   // # bits to shift right.
#define  WINDOWSIZE        (1 << SHIFTRIGHT)   // # samples

if (dwNumSamples < (DWORD) (WINDOWSIZE+1))
   return 0;

// take the first 8 samples and average them together.
lSum = 0;
for (i = 0; i < (DWORD) WINDOWSIZE; i++)
   lSum += lpSrc[i];
sSum = (short) (lSum >> SHIFTRIGHT);

//loop through the rest of the samples
lpLag = lpSrc;
lpSrc += WINDOWSIZE;
dwNumSamples -= WINDOWSIZE;
lSum = 0;   // total
sMax = -32768;
sMin = 32767;
for (i = 0;dwNumSamples; lpSrc++, lpDst++, lpLag++, i++, dwNumSamples--) {
   sSum = sSum - (*lpLag >> SHIFTRIGHT) + (*lpSrc >> SHIFTRIGHT);
   // sSum = *lpSrc; // Dont do any filtering at all
   *lpDst = sSum;
   lSum += sSum;
   if (sSum > sMax)
      sMax = sSum;
   if (sSum < sMin)
      sMin = sSum;
   };

// whow much did we do
if (psMax)
   *psMax = sMax;
if (psMin)
   *psMin = sMin;
if (psAvg && i)
   *psAvg = (short) (lSum / (long) i);
return i;
}


/*********************************************************************
QuantSamples - This quantizes the samples to +1, 0, or -1 (in place),
   depedning if the given value is:
      > sPositive then +1
      < sNegative then -1
      else 0

inputs
   short       *pSamples - Samples
   DWORD       dwNumSamples - Number of samples
   short       sPositive - Positive threshhold
   short       sNegative - Negative threshhold
returns
   none
*/
void QuantSamples (short *pSamples, DWORD dwNumSamples,
   short sPositive, short sNegative)
{
    SPDBG_FUNC( "QuantSamples" );
while (dwNumSamples) {
   if (*pSamples > sPositive)
      *pSamples = 1;
   else if (*pSamples < sNegative)
      *pSamples = -1;
   else
      *pSamples = 0;
   pSamples++;
   dwNumSamples--;
   };
}

/*********************************************************************
FindZC - This searches through the samples for the first zero crossing.
   The returned point will have its previous sample at <= 0, and the
   new one at >0.

inputs
   short       *pSamples - Samples;
   DWORD       dwNumSamples - Number of samples
returns
   DWORD - first sampe number which is positive, or 0 if cant find
*/
DWORD FindZC (short *pSamples, DWORD dwNumSamples)
{
    SPDBG_FUNC( "FindZC" );
DWORD i;

for (i = 1; i < dwNumSamples; i++)
   if ((pSamples[i] > 0) && (pSamples[i-1] <= 0))
      return i;

// else cant find
return 0;
}


/*********************************************************************
CompareSegments - This compares two wave segments and sees how much
   alike they are, returning a confidence that they are the same.

inputs
   short       *pA - Samples. This assumes that the samples
                  are -1, 0, or +1.
   short       *pB - Samples for B. Should be -1, 0, or +1
   DWORD       dwNumSamples - Number of samples in each of them
returns
   WORD - Confidence from 0 to 0xffff (highest confidence)

Notes about the algo: Each sample will score a "similarity point"
for like signs, or if one of the values is a 0.
*/
WORD CompareSegments (short *pA, short *pB, DWORD dwNumSamples)
{
    SPDBG_FUNC( "CompareSegments" );
DWORD    dwSimilar = 0;
DWORD    dwLeft;

for (dwLeft = dwNumSamples; dwLeft; pA++, pB++, dwLeft--)
   if ((*pA == *pB) || (*pA == 0) || (*pB == 0))
      dwSimilar++;

return (WORD) ((dwSimilar * 0xffff) / dwNumSamples);
}


/*********************************************************************
FindMostLikelyWaveLen - This Searches through wave data and finds the
   most likeley wavelength for voiced audio. it returns a condifence
   score from 0 to ffff (ffff is 100% positive).

inputs
   short       *pSamples - Samples
   DWORD       dwNumSamples - Number of samples
   DWORD       dwMinWaveLen - Minimum accepatble wavelength
   DWORD       dwMaxWaveLen - Maximum acceptable wavelength
   WORD       *pwConfidence - Filled in with confidence rating.
returns
   DWORD - Wavelength found. 0 if can't deteermine anything
*/
DWORD FindMostLikelyWaveLen (short *pSamples, DWORD dwNumSamples,
   DWORD dwMinWaveLen, DWORD dwMaxWaveLen, WORD *pwConfidence)
{
    SPDBG_FUNC( "FindMostLikelyWaveLen" );
#define     NUMCOMP     (3)
DWORD    dwFirstZC, i;
DWORD    dwBestWaveLen;
WORD     wBestConfidence;
DWORD    dwCurZC, dwCurWaveLen, dwTemp;
WORD     wConf, wTemp;

// Step one, find the first zero crossing
dwFirstZC = FindZC (pSamples, dwNumSamples);
if (!dwFirstZC)
   return 0;   // error

// Start at a minimum-wavelength away and start finding a wave
// which repeats three times and compares well.
dwBestWaveLen = 0;   // best wavelength found so far
wBestConfidence = 0; // confidence of the best wavelength
dwCurWaveLen = dwMinWaveLen;
while (dwCurWaveLen <= dwMaxWaveLen) {
   // Try the first comparison
   dwCurZC = dwFirstZC + dwCurWaveLen;
   if (dwCurZC >= dwNumSamples)
      break;   // no more samples left

   // find first zero crossing from the current wavelen
   dwTemp = FindZC (pSamples + dwCurZC, dwNumSamples - dwCurZC);
   if (!dwTemp)
      break;      // no more samples left
   dwCurZC += dwTemp;
   dwCurWaveLen += dwTemp;

   // Make sure that we have three wavelength's worth
   if ((dwFirstZC + (NUMCOMP+1)*dwCurWaveLen) >= dwNumSamples)
      break;   // cant compare this

   // Do two confidence tests and multiply them toegther to
   // get the confidence for this wavelength
   wConf = 0xffff;
   for (i = 0; i < NUMCOMP; i++) {
      wTemp = CompareSegments (pSamples + dwFirstZC /* + i * dwCurWaveLen */,
         pSamples + (dwFirstZC + (i+1) * dwCurWaveLen), dwCurWaveLen);
      wConf = (WORD) (((DWORD) wConf * (DWORD) wTemp) >> 16);
      };

   // If we're more confident about this one than others then use it
   if (wConf >= wBestConfidence) {
      wBestConfidence = wConf;
      dwBestWaveLen = dwCurWaveLen;
      };

   // Up the current wavelength just a tad
   dwCurWaveLen++;
   };

*pwConfidence = wBestConfidence;
return dwBestWaveLen;
}

/*********************************************************************
IsSegmentVoiced - This detects if the segment if voiced or not.

inputs
   short       *pSamples - Sample data
   DWORD       dwNumSamples - number of samples
   DWORD       dwSamplesPerSec - Number of sample sper second
   WORD        wMinConfidence - Minimum condifence
returns
   BOOL - TRUE if its definately voiced, FALSE if not or cant tell
*/

BOOL CSilence::IsSegmentVoiced (short *pSamples, DWORD dwNumSamples,
   DWORD dwSamplesPerSec, WORD wMinConfidence, short *asFiltered)
{
    SPDBG_FUNC( "CSilence::IsSegmentVoiced" );
//#define     FILTERNUM      (1024)      // max # samples i nthe filter
//#define     MAXVOICEHZ     (300)       // maximum voicce pitchm in hz
//#define     MINVOICEHZ     (50)        // minimum voice pitch in hz
// #define     MINCONFIDENCE  (0x6000)    // minimum confidence
   // This means that 70% of the samples line up from one wavelength
   // to another

DWORD    dwNumFilter;
//short    asFiltered[FILTERNUM];
short    sMax, sMin, sAvg;
DWORD    dwWaveLen;
WORD     wConfidence;
short    sPositive, sNegative;

// Filter it first so we just get the voiced audio range
if (dwNumSamples > FILTERNUM)
   dwNumSamples = FILTERNUM;
dwNumFilter = LowPassFilter (pSamples, dwNumSamples, asFiltered,
  &sMax, &sMin, &sAvg, m_dwSamplesPerSec);

// Truncate the wave samples to +1, 0, -1
sPositive = sAvg;
sNegative =  sAvg;
QuantSamples (asFiltered, dwNumFilter, sPositive, sNegative);

// look through the voiced wavelengths for a frequency
dwWaveLen = FindMostLikelyWaveLen (asFiltered, dwNumFilter,
   dwSamplesPerSec / m_dwHighFreq, dwSamplesPerSec / MINVOICEHZ,
   &wConfidence);

return (dwWaveLen && (wConfidence >= wMinConfidence));
}




/*********************************************************************
TrimMaxAmp - This extracts the maximum amplitude range of the wave file
	segment.

inputs
	short *	lpS - samples to look through
	WORD		dwNum - number of samples
returns
	WORD - maximum amplitude range
*/
WORD NEAR PASCAL TrimMaxAmp (short * lpS, DWORD dwNum)
{
    SPDBG_FUNC( "TrimMaxAmp" );
DWORD i;
short	sMin, sMax, sTemp;

sMin = 32767;
sMax = (short) -32768;
for (i = dwNum; i; i--) {
   sTemp = *(lpS++);
	if (sTemp < sMin)
		sMin = sTemp;
	if (sTemp > sMax)
		sMax = sTemp;
	};

// If we're clipping at all then claim that we've maxed out.
// Some sound cards have bad DC offsets
if ((sMax >= 0x7f00) || (sMin <= -0x7f00))
   return 0xffff;

return (WORD) (sMax - sMin);
}

/********************************************************************
TrimMaxAmpDelta - This extracts the maximum amplitude range and 
                  calculates the maximum delta of the wave file
	               segment.

inputs
   PBLOCKCHAR  pBlockChar - Pointer to a block characteristic
            structure which is filled in. 
	short *	lpS - deltas to look through
	WORD		dwNum - number of samples
returns
	nothing
*/
void TrimMaxAmpDelta(PBLOCKCHAR pBlockChar, short *lpS, DWORD dwNum)
{
    SPDBG_FUNC( "TrimMaxAmpDelta" );
   DWORD i;
   WORD wMax = 0;
   WORD wTemp;
   short sMin, sMax, sCur, sLast;

   // BUGFIX:  4303 Merge TrimMaxAmp and TrimMaxDelta
   sLast = sMin = sMax = *(lpS++);
   for (i = dwNum - 1; i; i--, sLast = sCur) {
      sCur = *(lpS++);
      // TrimMaxAmp
      if (sCur < sMin)
         sMin = sCur;
      if (sCur > sMax)
         sMax = sCur;

      // TrimMaxDelta
      wTemp = sCur > sLast ? (WORD) (sCur - sLast) : (WORD) (sLast - sCur);
      if (wTemp > wMax)
         wMax = wTemp;

   }
   // If we're clipping at all then claim that we've maxed out.
   // Some sound cards have bad DC offsets
   pBlockChar->wMaxLevel = ((sMax >= 0x7F00) || (sMin <= -0x7F00)) ? 0xFFFF : (WORD) (sMax - sMin);
   pBlockChar->wMaxDelta = wMax;
} /* End of TrimMaxAmpDelta() */ 

         
/*********************************************************************
GetBlockChar - This gets the characteristics of a block of audio.
   This characteristics can then be used to determine if the block
   is silent or not.

inputs
   short    *lpS - sample data
   DWORD    dwNum - number of samples
   PBLOCKCHAR  pBlockChar - Pointer to a block characteristic
            structure which is filled in. 
   BOOL     fTestVoiced - Voicce testing will only be done if
            this is TTRUE (in order to save processor).
returns
   none
*/
void GetBlockChar(short *lpS, DWORD dwNum, PBLOCKCHAR pBlockChar, BOOL fTestVoiced)
{
    SPDBG_FUNC( "GetBlockChar" );
   // BUGFIX:  4303 Merge TrimMaxAmp and TrimMaxDelta
   TrimMaxAmpDelta(pBlockChar, lpS, dwNum);
   pBlockChar->bIsVoiced = pBlockChar->bHighLevel =
      pBlockChar->bHighDelta = SIL_UNKNOWN;
}


/*********************************************************************
IsBlockSound - This detects whether the block is silent or not.

inputs
   PBLOCKCHAR  pBlockInQuestion - Block in question. This has the
      bHighLevel and bHighDelta flags modified
   PBLOCKCHAR  pBlockSilence - Silent block  
   BOOL        fInUtterance - TRUE if we're in an utterance (which
            means be more sensative), FALSE if we're not
returns
   BOOL - TTRUE if has sound, FALSE if it is silent
*/
BOOL IsBlockSound (PBLOCKCHAR pBlockInQuestion, PBLOCKCHAR pBlockSilence,
   BOOL fInUtterance)
{
    SPDBG_FUNC( "IsBlockSound" );
#ifdef SOFTEND // Use so that catches a soft ending to phrases
#define     SENSINV_THRESHHOLD_LEVEL(x)     (((x)/4)*3)
#define     SENSINV_THRESHHOLD_DELTA(x)     (((x)/4)*3)
#else
#define     SENSINV_THRESHHOLD_LEVEL(x)     ((x)/2)
#define     SENSINV_THRESHHOLD_DELTA(x)     ((x)/2)
#endif
#define     NORMINV_THRESHHOLD_LEVEL(x)     ((x)/2)
#define     NORMINV_THRESHHOLD_DELTA(x)     ((x)/2)

if (fInUtterance) {
   pBlockInQuestion->bHighLevel =
      SENSINV_THRESHHOLD_LEVEL(pBlockInQuestion->wMaxLevel) >= pBlockSilence->wMaxLevel;
   pBlockInQuestion->bHighDelta =
      SENSINV_THRESHHOLD_DELTA(pBlockInQuestion->wMaxDelta) >= pBlockSilence->wMaxDelta;
   }
else {
   pBlockInQuestion->bHighLevel =
      NORMINV_THRESHHOLD_LEVEL(pBlockInQuestion->wMaxLevel) >= pBlockSilence->wMaxLevel;
   pBlockInQuestion->bHighDelta =
      NORMINV_THRESHHOLD_DELTA(pBlockInQuestion->wMaxDelta) >= pBlockSilence->wMaxDelta;
   };


return pBlockInQuestion->bHighLevel || pBlockInQuestion->bHighDelta;
}


/*********************************************************************
ReEvaluateSilence - This takes the values used for silence and re-evaluates
   them based upon new data which indicates what silence is. It
   automatically adjusts to the noise level in the room over a few seconds.
   NOTE: This should not be called when an utterance is happening, or
   when it might be starting.

inputs
   PBLOCKCHAR     pSilence - This is the silence block, and should
                     start out with values in it. It will be modified
                     so to incorporate the new silence information.
   PBLOCKCHAR     pNew - New block which is known to be silence.
   BYTE           bWeight - This is the weighting of the new block
                     in influencing the old block, in a value from 0 to 255.
                     256 means that the value of the new silence completely
                     overpowers the old one, 0 means that it doesnt have
                     any affect.
returns
   none
*/
void ReEvaluateSilence (PBLOCKCHAR pSilence, PBLOCKCHAR pNew,
   BYTE bWeight)
{
    SPDBG_FUNC( "ReEvaluateSilence" );
#define  ADJUST(wOrig,wNew,bWt)                 \
   (WORD) ((                                    \
      ((DWORD) (wOrig) * (DWORD) (256 - (bWt))) + \
      ((DWORD) (wNew) * (DWORD) (bWt))          \
      ) >> 8);

pSilence->wMaxLevel = ADJUST (pSilence->wMaxLevel,
   pNew->wMaxLevel, bWeight);
pSilence->wMaxDelta = ADJUST (pSilence->wMaxDelta,
   pNew->wMaxDelta, bWeight);

// If it's way too silence (and too good to be true) then assume
// a default silece
// if (!pNew->wMaxLevel && !pNew->wMaxDelta) {
//   if (pSilence->wMaxLevel < 2500)
//      pSilence->wMaxLevel = 2500;
//   if (pSilence->wMaxDelta < 400)
//       pSilence->wMaxDelta = 400;
//   }
}

/*********************************************************************
WhatsTheNewState - This takes in a stream of bit-field indicating which
   of the last 32 blocks were detected as having sound, and what our
   state was the last time this was called (utterance or not). It then
   figureous out if we're still in an utterance, or we just entered one.
   It also says how many buffers ago that was.

inputs
   DWORD    dwSoundBits - This is a bit-field of the last 32
               audio blocks. A 1 in the field indicates that there was
               sound there, a 0 indicates no sound. The low bit
               corresponds to the most recent block, and high bit
               the oldest.
   DWORD    dwVoicedBits - Just like sound bits except that it indicates
               voiced sections of sound.
   BOOL     fWasInUtterance - This is true is we had an utterance
               the last time this called, FALSE if there was silence
   BOOL     fLongUtterance - If this is a long utterance then dont
               react for 1/4 second, otherwise use 1/8 second for
               short utterance
   WORD     wBlocksPerSec - How many of the above-mentioned blocks
               fit into a second.
   WORD     *wStarted - If a transition occurs from no utterance to
               an utterance, then this fills in the number of of blocks
               ago that the utterance started, into *wStarted. Otherwise
               it is not changed.
   WORD     wReaction - Reaction time (in blocks) after an utterance is
               finished
returns
   BOOL - TRUE if we're in an utterance now,  FALSE if we're in silence
*/

BOOL CSilence::WhatsTheNewState (DWORD dwSoundBits, DWORD dwVoicedBits,
   BOOL fWasInUtterance, BOOL fLongUtterance,
   WORD wBlocksPerSec, WORD *wStarted, WORD wReaction)
{
    SPDBG_FUNC( "CSilence::WhatsTheNewState" );
WORD wCount, wOneBits;
WORD  wTimeToCheck;
DWORD dwTemp, dwMask;

if (fWasInUtterance)
   wTimeToCheck = wReaction;
else
   wTimeToCheck = (wBlocksPerSec/4);   // 1/4 second
if (!wTimeToCheck)
   wTimeToCheck = 1;


for (wOneBits = 0, wCount = wTimeToCheck, dwTemp = dwSoundBits;
      wCount;
      dwTemp /= 2, wCount--)
   if (dwTemp & 0x01)
      wOneBits++;

if (fWasInUtterance) {
   // If we were in an utterance, then we still are in an utterance
   // UNLESS the number of bits which are turned on for the last
   // 0.5 seconds is less that 1/4 of what should be turned on.
   if ( (wOneBits >= 1))
      return TRUE;
   else
      return FALSE;
   }
else {
   // We are in silence. We cannot possible go into an utterance
   // until the current block is voicced
   if (!(dwVoicedBits & 0x01))
      return FALSE;

   // If we were in silence then we're still in silence
   // UNLESS the number of bits which are turned on for the last
   // 0.5 seconds is more than 1/2 of what should be turned on.
   // If so, then start the utterance 0.75 seconds ago.
   if (wOneBits >= (wTimeToCheck / 2)) {
      // we're not in an utterance

      // Look back until get 1/8 second of silence, and include
      // that in the data returned
      dwTemp = dwSoundBits;
 //     dwMask = (1 << (wBlocksPerSec / 8)) - 1;
 //     for (wCount = wBlocksPerSec/8; dwTemp & dwMask; dwTemp >>= 1, wCount++);
      dwMask = (1 << (wBlocksPerSec / m_wAddSilenceDiv)) - 1;
      for (wCount = wBlocksPerSec/m_wAddSilenceDiv; dwTemp & dwMask; dwTemp >>= 1, wCount++);

      *wStarted = wCount;

      return TRUE;
      }
   else
      return FALSE;
   };

}


/*********************************************************************
CSilence::CSilence - This creates the silence class.

inputs
   WORD     wBlocksPerSec - Number of blocks per second. The blocks
               will be passed down through AddBlock().
returns
   class
*/
CSilence::CSilence (WORD wBlocksPerSec)
{
    SPDBG_FUNC( "CSilence::CSilence" );
m_wBlocksPerSec = min(wBlocksPerSec, 32); // no more than the # bits in a DWORD
m_wBlocksInQueue = m_wBlocksPerSec;   // 1 second worth.
m_wLatestBlock = 0;
m_paBlockInfo = NULL;
m_dwSoundBits = m_dwVoicedBits = 0;
m_fFirstBlock = TRUE;
m_fInUtterance = FALSE;
m_dwUtteranceLength = 0;
m_dwSamplesPerSec = 11025;
}

/*********************************************************************
CSilence::~CSilence - Free up everything.
*/
CSilence::~CSilence (void)
{
    SPDBG_FUNC( "CSilence::~CSilence" );
   WORD  i;

   if (m_paBlockInfo) {
      for (i = 0; i < m_wBlocksInQueue; i++)
         if (m_paBlockInfo[i].pSamples)
            free(m_paBlockInfo[i].pSamples);
      free(m_paBlockInfo);
   }

   if (m_pASFiltered)
      free(m_pASFiltered);
}

/*********************************************************************
CSilence::Init - This initializes the silence code. It basically
   allocates memory. It should be called immediately after the object
   is created and then not again.

inputs
   none
returns
   BOOL - TRUE if succeded, else out of memory
*/
BOOL CSilence::Init(BOOL fPhoneOptimized, DWORD dwSamplesPerSec)
{
    SPDBG_FUNC( "CSilence::Init" );
   m_dwSamplesPerSec = dwSamplesPerSec;
   if (fPhoneOptimized) {
   	m_wAddSilenceDiv = (WORD) PHADD_BEGIN_SILENCE;
	   m_dwHighFreq = PHMAXVOICEHZ;
	}
   else {
   	m_wAddSilenceDiv = (WORD) PCADD_BEGIN_SILENCE;
	   m_dwHighFreq = PCMAXVOICEHZ;
	}
   if ((m_pASFiltered = (short *) malloc((sizeof(short)) * FILTERNUM)) == NULL)
	   return (FALSE);

   // Initialize memory for the blocks and clear it.
   if (m_paBlockInfo)
      return (TRUE);
   m_paBlockInfo = (PBINFO) malloc(m_wBlocksInQueue * sizeof(BINFO));
   if (!m_paBlockInfo)
      return (FALSE);
   if (m_wBlocksInQueue && m_paBlockInfo)
      memset(m_paBlockInfo, 0, m_wBlocksInQueue * sizeof(BINFO));
   return (TRUE);
} /* End of Init() */

/*********************************************************************
CSilence::AddBlock - This does the following:
   - Add the block the the queue. Free up an old block if needed.
      The block should be 1/wBlocksPerSec long (about).
   - Analyze the block to see if its got sound or is quiet.
   - Fill in *wVU with a VU level.
   - Return TRUE if we're in an utterance, FALSE if its silence now.
      If TRUE then app should call GetBlock() until no more blocks left,
      and pass them to the SR engine.

inputs
   short    *pSamples - Pointer to samples. This memory should
               be allocaed with malloc(), and may be freed by the
               object.
   DWORD    dwNumSamples - Number of samples
   WORD     *wVU - This is fille in with the VU meter for the block
   QWORD	qwTimeStamp - Time stamp for this buffer.
returns
   BOOL - TRUE if an utterance is taking place, FALSE if its silent
*/
BOOL CSilence::AddBlock (short *pSamples, DWORD dwNumSamples,
   WORD *wVU, QWORD qwTimeStamp)
{
    SPDBG_FUNC( "CSilence::AddBlock" );
BLOCKCHAR      bcNew;
BOOL           fSound, fUtt;
PBINFO         pbInfo;
WORD           wUttStart, i;

// Dont add empty blocks
if (!dwNumSamples) {
   if (pSamples)
      free (pSamples);
   return m_fInUtterance;
   };

// Analyze the block for characteristics.
GetBlockChar (pSamples, dwNumSamples, &bcNew, !m_fInUtterance);

// fill in the vu
*wVU = bcNew.wMaxLevel;

// see if it's silent or not
if (m_fFirstBlock) {
   // first block, so of course its silent
   m_bcSilence = bcNew;
   m_fFirstBlock = FALSE;
   fSound = FALSE;

   // BUGFIX 2466 - If it's way too silence (and too good to be true) then assume
   // a default silece
   if ((m_bcSilence.wMaxLevel < 500) || (m_bcSilence.wMaxDelta < 100)) {
      m_bcSilence.wMaxLevel = 2500;
      m_bcSilence.wMaxDelta = 400;
      };

   // If it's way too loud then cut down
   if ((m_bcSilence.wMaxLevel > 2500) || (m_bcSilence.wMaxDelta > 1500)) {
      m_bcSilence.wMaxLevel = min (m_bcSilence.wMaxLevel, 2500);
      m_bcSilence.wMaxDelta = min (m_bcSilence.wMaxDelta, 1500);
      };
   }
else {
   fSound = IsBlockSound (&bcNew, &m_bcSilence, m_fInUtterance);
   };

// Test to see if the block is voiced if:
//    - The amplitude level is more than background sound
//    - We're not yet in an utterance (to save processor)
if (bcNew.bHighLevel && !m_fInUtterance) {
   WORD  wNoise;
   wNoise = (m_dwSamplesPerSec <= 13000) ?
               m_wNoiseThresh :
               ((m_wNoiseThresh / 3) * 2);

   bcNew.bIsVoiced = this->IsSegmentVoiced (pSamples, dwNumSamples, m_dwSamplesPerSec, wNoise, m_pASFiltered) ?
      SIL_YES : SIL_NO;
}

// add the block
m_dwVoicedBits = (m_dwVoicedBits << 1) |
   ( (bcNew.bIsVoiced  == SIL_YES) ? 1 : 0 );
m_dwSoundBits = (m_dwSoundBits << 1) | (fSound ? 1 : 0);
m_wLatestBlock++;
if (m_wLatestBlock >= m_wBlocksInQueue)
   m_wLatestBlock = 0;
pbInfo = m_paBlockInfo + m_wLatestBlock;
if (pbInfo->pSamples)
   free (pbInfo->pSamples);
pbInfo->pSamples = pSamples;
pbInfo->dwNumSamples = dwNumSamples;

// BUGFIX: Alignment code.  We need to store the timestamp for
// the BEGINNING of the block, not the end!

pbInfo->qwTimeStamp = qwTimeStamp - dwNumSamples * sizeof(WORD);

// What's our utterance state?
fUtt = this->WhatsTheNewState (m_dwSoundBits, m_dwVoicedBits, m_fInUtterance,
   m_dwUtteranceLength >= m_wBlocksPerSec,
   m_wBlocksPerSec, &wUttStart, m_wReaction);
if (fUtt && !m_fInUtterance) {
   // We just entered an utterance, so wUttStart has a valid teerm
   // in it. Go through the buffer queue and free all buffers which
   // are older than wUttStart. Remembeer, this is a circular buffer
   for (i = 0; i < (m_wBlocksInQueue - wUttStart); i++) {
      pbInfo = m_paBlockInfo +
         ( (m_wLatestBlock + i + 1) % m_wBlocksInQueue);
      if (pbInfo->pSamples)
         free (pbInfo->pSamples);
      pbInfo->pSamples = NULL;
      };

   // Since we just entered an utterance clear the utterance length counter
   m_dwUtteranceLength = 0;
   };
m_fInUtterance = fUtt;

// Remember how long this utterance has done on. Long utterances
// deserve more patience as far as silence goes
m_dwUtteranceLength++;

// Adjust the silence level if we're not in an utterance
// Requiring !fSound so that we dont accidentally indclude any
// utterance sections in the sound calculations
if (!m_fInUtterance /* && !fSound */) {
   ReEvaluateSilence (&m_bcSilence, &bcNew,
      255 / m_wBlocksPerSec);
   }
else if (m_dwUtteranceLength >= ((DWORD)m_wBlocksPerSec * 30))
   // if we have a very long utterance (> 30 second) then it's not
   ReEvaluateSilence (&m_bcSilence, &bcNew, 255 / m_wBlocksPerSec);

// done
return m_fInUtterance;
}

/*********************************************************************
CSilence::ExpectNoiseChange - Sent to the silence detection algorithm
   when it should expect the noise floor to go up/down.

inputs
   WORD     wValue - Amount that noise floor should change.
               0x100 = no change. > 0x100 => louder, < 0x100 => quieter
returns
*/
void CSilence::ExpectNoiseChange (WORD wValue)
{
    SPDBG_FUNC( "CSilence::ExpectNoiseChange" );
DWORD dwTemp;

dwTemp = ((DWORD) m_bcSilence.wMaxLevel * wValue) >> 8;
if (dwTemp > 0xffff)
   dwTemp = 0xffff;
m_bcSilence.wMaxLevel = (WORD) dwTemp;

dwTemp = ((DWORD) m_bcSilence.wMaxDelta * wValue) >> 8;
if (dwTemp > 0xffff)
   dwTemp = 0xffff;
m_bcSilence.wMaxDelta = (WORD) dwTemp;
}

/*********************************************************************
CSilence::GetBlock - This gets a block from the queue. This will fail
   if there are no more blocks left to get OR if there's not utterance.

inputs
   DWORD    *pdwNumSamples - If a block is returned then this
            will be filled in with the number of samples in the block.	 
	QWORD	*pqwTimeStamp - Filled in woth the time-stamp for the
			buffer.
returns
   short * - Pointer to a block of samples. This memory is the
         caller's property and can be freed with free().
*/
short * CSilence::GetBlock (DWORD *pdwNumSamples, QWORD * pqwTimeStamp)
{
    SPDBG_FUNC( "CSilence::GetBlock" );
PBINFO         pbInfo;
WORD           i, wCount;
short          *pSamples;

if (!m_fInUtterance)
   return NULL;

// find the first occurance
i = (m_wLatestBlock + 1) % m_wBlocksInQueue;
for (wCount = m_wBlocksInQueue; wCount;
      i = ((i < (m_wBlocksInQueue-1)) ? (i+1) : 0), wCount-- ) {
   pbInfo = m_paBlockInfo + i;
   if (pbInfo->pSamples) {
      *pdwNumSamples = pbInfo->dwNumSamples;
	  *pqwTimeStamp = pbInfo->qwTimeStamp;
      pSamples = pbInfo->pSamples;
      pbInfo->pSamples = NULL;

      return pSamples;
      };
   };

// if got here then couldnt find anything
return NULL;
}

/*********************************************************************
CSilence::KillUtterance - Kills an exitsing utterance.

inputs
   none
returns
   none
*/
void CSilence::KillUtterance (void)
{
    SPDBG_FUNC( "CSilence::KillUtterance" );
m_fInUtterance = FALSE;
m_dwSoundBits = 0;
m_dwVoicedBits = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__20E01DF1_138E_11D3_A9DA_00C04F72DB1F__INCLUDED_)
#define AFX_STDAFX_H__20E01DF1_138E_11D3_A9DA_00C04F72DB1F__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifdef _WIN32_WINNT
#undef _WIN32_WINNT
#endif

#define _WIN32_WINNT 0x0600

#ifndef _WIN32_IE
#define _WIN32_IE   0x0401
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <w95wraps.h>
#include <shlwapip.h>
#include <crtdbg.h>
#include <tchar.h>
#include <cpl.h>
#include <commctrl.h>
#include <htmlhelp.h>
#include <sapi.h>
#include <spdebug.h>
#include <spunicode.h>
#include <spuihelp.h>
#include <spddkhlp.h>
#include <shfusion.h>

static DWORD  g_dwIsRTLLayout = FALSE;

#ifdef _WIN32_WCE
#include <WinCEstub.h>
#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__20E01DF1_138E_11D3_A9DA_00C04F72DB1F__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\stuff.h ===
/*******************************************************************************
* Stuff.h *
*---------*
*   Description:
*       This is the header file for the speech control panel applet.
*-------------------------------------------------------------------------------
*  Created By: MIKEAR                            Date: 11/17/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*
*******************************************************************************/
#ifndef _Stuff_h
#define _Stuff_h

#include "TTSDlg.h"
#include "SRDlg.h"

// Globals

static BOOL   g_bNoInstallError = FALSE;
CTTSDlg      *g_pTTSDlg = NULL;
CSRDlg       *g_pSRDlg = NULL;
CEnvrDlg     *g_pEnvrDlg = NULL;

// Constants

const UINT      kcMaxPages = 3;

// This isn't in the NT4 headers

#ifndef WS_EX_LAYOUTRTL
#define WS_EX_LAYOUTRTL		0x00400000L
#endif

#endif  // #ifdef _Stuff_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\srdlg.h ===
/*******************************************************************************
* SRDlg.h *
*------------*
*   Description:
*       This is the header file for the default voice dialog.
*-------------------------------------------------------------------------------
*  Created By: MIKEAR                            Date: 11/17/98
*  Copyright (C) 1998 Microsoft Corporation
*  All Rights Reserved
*
*-------------------------------------------------------------------------------
*  Revisions:
*      BRENTMID 11/29/1999 - Redesigned UI to match functional spec.
*
*******************************************************************************/
#ifndef _SRDlg_h
#define _SRDlg_h

#include "audiodlg.h"

// External Declarations
class CEnvrDlg;
class CEnvrPropDlg;
#define IDH_NOHELP          -1
#define CPL_HELPFILE        L"sapicpl.hlp"
#define WM_RECOEVENT    WM_APP      // Window message used for recognition events

// Constant Declarations
const int iMaxColLength_c = 255;
const int iMaxAddedProfiles_c = 100;    // maximum number of profiles a user can add
                                        // in one session
const int iMaxDeletedProfiles_c = 100;  // maximum number of profiles a user can delete
                                        // and rollback in one session
// Typedefs
typedef enum EPD_RETURN_VALUE
{
    EPD_OK,
    EPD_DUP,
    EPD_EMPTY_NAME,
    EPD_FAILED
}   EPD_RETURN_VALUE;


typedef enum SRDLGUPDATEFLAGS
{
    SRDLGF_RECOGNIZER              = 0x01,
    SRDLGF_AUDIOINPUT   = 0x02,
    SRDLGF_ALL =0x03
} SRDLGUPDATEFLAGS;


// Class Declarations
class CSRDlg
{
  private:
    
    HACCEL                  m_hAccelTable;
    HWND                	m_hDlg;
    HWND                    m_hSRCombo;         // engine selection combobox
    HWND                	m_hUserList;        // user selection window
	BOOL					m_fDontDelete;
    BOOL                	m_bInitEngine;      // has the default engine been initialized
    BOOL                	m_bPreferredDevice;
    
    CComPtr<ISpRecognizer>  m_cpRecoEngine;
    CComPtr<ISpRecoContext> m_cpRecoCtxt;       // Recognition context
    CAudioDlg          		*m_pAudioDlg;
    ISpObjectToken     		*m_pCurRecoToken;   // holds the token for the currently selected engine
    CSpDynamicString        m_dstrOldUserTokenId;   
                                                // the original user token ID - need to revert to this on Cancel
	
    ISpObjectToken*         m_aDeletedTokens[iMaxDeletedProfiles_c];  
                                                // array holding the tokens
    int                     m_iDeletedTokens;   // holds the number of currently deleted tokens

    CSpDynamicString        m_aAddedTokens[ iMaxAddedProfiles_c ];
    int                     m_iAddedTokens;
	
    int                     m_iLastSelected;    // index of the previously selected item
    WCHAR                   m_szCaption[ MAX_LOADSTRING ];

    HRESULT CreateRecoContext(BOOL *pfContextInitialized = NULL, BOOL fInitialize = FALSE, ULONG ulFlags = SRDLGF_ALL);      
	void RecoEvent();
    
    void PopulateList();             // Populates the list
    void InitUserList(HWND hWnd);    // initializes user profile list
    void ProfileProperties();        // Modifies the profile properties through engine UI
	void DrawItemColumn(HDC hdc, WCHAR* lpsz, LPRECT prcClip);
	CSpDynamicString        CalcStringEllipsis(HDC hdc, CSpDynamicString lpszString, int cchMax, UINT uColWidth);
    void SetCheckmark( HWND hList, int iIndex, bool bCheck );
    
    HRESULT UserPropDlg( ISpObjectToken * pToken); // user wants to add a new profile
  
  public:
    CSRDlg() :
        m_hAccelTable( NULL ),
        m_hDlg( NULL ),
        m_hSRCombo( NULL ),
        m_hUserList( NULL ),
        m_fDontDelete( FALSE ),
        m_bInitEngine( FALSE ),
        m_bPreferredDevice( TRUE ),
        m_cpRecoEngine( NULL ),
        m_cpRecoCtxt( NULL ),
        m_pAudioDlg(NULL),
        m_pCurRecoToken( NULL ),
        m_dstrOldUserTokenId( (WCHAR *) NULL ),
        m_iDeletedTokens( 0 ),
        m_iAddedTokens( 0 ),
        m_pCurUserToken( NULL ),
        m_pDefaultRecToken( NULL )
    {
            ::memset( m_aAddedTokens, 0, sizeof( CSpDynamicString ) * iMaxAddedProfiles_c );
    }

    ~CSRDlg()
    {
        if ( m_pAudioDlg )
        {
            delete m_pAudioDlg;
        }
    }

    ISpObjectToken     *m_pCurUserToken;      // currently selected user token
    ISpObjectToken     *m_pDefaultRecToken;   // current default recognizer token.
                                              // This is the token of the engine that is 
                                              // currently running (except for temporary switches
                                              // in order to train non-default engines.
    void CreateNewUser();                     // Adds a new speech user profile to the registry
    void DeleteCurrentUser();        // Deletes the current user
    void OnCancel();                 // Handles undoing the changes to the settings
    void UserSelChange( int iSelIndex);            
                                     // Handles a new selection
	void OnDrawItem( HWND hWnd, const DRAWITEMSTRUCT * pDrawStruct );  // handles item drawing
    void OnApply();
    void OnDestroy();
    void OnInitDialog(HWND hWnd);
    void ChangeDefaultUser();               // Changes the default user in the registry
    void ShutDown();                    // Shuts off the engine
    void EngineSelChange(BOOL fInitialize = FALSE);
    HRESULT IsCurRecoEngineAndCurRecoTokenMatch( bool *pfMatch );
    HRESULT TrySwitchDefaultEngine( bool fShowErrorMessages = false );
    HRESULT ResetDefaultEngine( bool fShowErrorMessages = true);
    bool IsRecoTokenCurrentlyBeingUsed( ISpObjectToken *pRecoToken );
    bool HasRecognizerChanged();
    void KickCPLUI();                       // Looks at the current requested defaults
                                            // and decides if "Apply" needs to be enabled
    void RecoContextError( BOOL fRecoContextExists = FALSE, BOOL fGiveErrorMessage = TRUE,
                            HRESULT hrRelevantError = E_FAIL );
    UINT HRESULTToErrorID( HRESULT hr );
    bool IsProfileNameInvisible( WCHAR *pwszProfile );

    HWND GetHDlg() { return m_hDlg; }
    ISpRecognizer *GetRecognizer() { return m_cpRecoEngine; }
    ISpRecoContext *GetRecoContext() { return m_cpRecoCtxt; }
    BOOL IsPreferredDevice() { return m_bPreferredDevice; }
    void SetPreferredDevice( BOOL b ) { m_bPreferredDevice = b; }

    friend INT_PTR CALLBACK SRDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend CEnvrPropDlg;
};

// Function Declarations
INT_PTR CALLBACK SRDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

class CEnvrPropDlg
{
public:
    CSRDlg            *         m_pParent;
    HWND                        m_hDlg;
    CComPtr<ISpObjectToken>     m_cpToken;
    int                         m_isModify;  // is this a new profile or a modify of an old profile

    CEnvrPropDlg(CSRDlg * pParent, ISpObjectToken * pToken) :
        m_cpToken(pToken),
        m_pParent(pParent)
    {
        CSpUnicodeSupport unicode;
        m_hinstRichEdit = unicode.LoadLibrary(L"riched20.dll");
        m_hDlg = NULL;
        m_isModify = 0;
    }

    ~CEnvrPropDlg()
    {
        FreeLibrary(m_hinstRichEdit);
    }

    BOOL InitDialog(HWND hDlg);
    EPD_RETURN_VALUE ApplyChanges();
    static INT_PTR CALLBACK DialogProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam);

private:
        HINSTANCE           m_hinstRichEdit; // used to allow rich edit controls
};

// Function Declarations
// Callback function to handle windows messages
INT_PTR CALLBACK EnvrDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

// Globals
extern CSRDlg *g_pSRDlg;
extern CEnvrDlg *g_pEnvrDlg;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\include\makefile.inc ===
GenerateBuildNum :
	cd $(SPEECH_ROOT)
	cscript $(SPEECH_ROOT)\builder\makebldnum.sapi5.10.vbs $(O)
	cd $(SPEECH_ROOT)\sapi\include
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\tom.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu May 07 14:12:12 1998
 */
/* Compiler settings for tom.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __tomtmp_h__
#define __tomtmp_h__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C"{
#endif

/* Forward Declarations */

#ifndef __ITextDocument_FWD_DEFINED__
#define __ITextDocument_FWD_DEFINED__
typedef interface ITextDocument ITextDocument;
#endif 	/* __ITextDocument_FWD_DEFINED__ */


#ifndef __ITextRange_FWD_DEFINED__
#define __ITextRange_FWD_DEFINED__
typedef interface ITextRange ITextRange;
#endif 	/* __ITextRange_FWD_DEFINED__ */


#ifndef __ITextSelection_FWD_DEFINED__
#define __ITextSelection_FWD_DEFINED__
typedef interface ITextSelection ITextSelection;
#endif 	/* __ITextSelection_FWD_DEFINED__ */


#ifndef __ITextFont_FWD_DEFINED__
#define __ITextFont_FWD_DEFINED__
typedef interface ITextFont ITextFont;
#endif 	/* __ITextFont_FWD_DEFINED__ */


#ifndef __ITextPara_FWD_DEFINED__
#define __ITextPara_FWD_DEFINED__
typedef interface ITextPara ITextPara;
#endif 	/* __ITextPara_FWD_DEFINED__ */


#ifndef __ITextStoryRanges_FWD_DEFINED__
#define __ITextStoryRanges_FWD_DEFINED__
typedef interface ITextStoryRanges ITextStoryRanges;
#endif 	/* __ITextStoryRanges_FWD_DEFINED__ */


#ifndef __ITextDocument2_FWD_DEFINED__
#define __ITextDocument2_FWD_DEFINED__
typedef interface ITextDocument2 ITextDocument2;
#endif 	/* __ITextDocument2_FWD_DEFINED__ */


#ifndef __ITextMsgFilter_FWD_DEFINED__
#define __ITextMsgFilter_FWD_DEFINED__
typedef interface ITextMsgFilter ITextMsgFilter;
#endif 	/* __ITextMsgFilter_FWD_DEFINED__ */


#ifndef __ITextDocument_FWD_DEFINED__
#define __ITextDocument_FWD_DEFINED__
typedef interface ITextDocument ITextDocument;
#endif 	/* __ITextDocument_FWD_DEFINED__ */


#ifndef __ITextRange_FWD_DEFINED__
#define __ITextRange_FWD_DEFINED__
typedef interface ITextRange ITextRange;
#endif 	/* __ITextRange_FWD_DEFINED__ */


#ifndef __ITextSelection_FWD_DEFINED__
#define __ITextSelection_FWD_DEFINED__
typedef interface ITextSelection ITextSelection;
#endif 	/* __ITextSelection_FWD_DEFINED__ */


#ifndef __ITextFont_FWD_DEFINED__
#define __ITextFont_FWD_DEFINED__
typedef interface ITextFont ITextFont;
#endif 	/* __ITextFont_FWD_DEFINED__ */


#ifndef __ITextPara_FWD_DEFINED__
#define __ITextPara_FWD_DEFINED__
typedef interface ITextPara ITextPara;
#endif 	/* __ITextPara_FWD_DEFINED__ */


#ifndef __ITextStoryRanges_FWD_DEFINED__
#define __ITextStoryRanges_FWD_DEFINED__
typedef interface ITextStoryRanges ITextStoryRanges;
#endif 	/* __ITextStoryRanges_FWD_DEFINED__ */


#ifndef __ITextDocument2_FWD_DEFINED__
#define __ITextDocument2_FWD_DEFINED__
typedef interface ITextDocument2 ITextDocument2;
#endif 	/* __ITextDocument2_FWD_DEFINED__ */


#ifndef __ITextMsgFilter_FWD_DEFINED__
#define __ITextMsgFilter_FWD_DEFINED__
typedef interface ITextMsgFilter ITextMsgFilter;
#endif 	/* __ITextMsgFilter_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * );

/****************************************
 * Generated header for interface: __MIDL_itf_tom_0000
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */











extern RPC_IF_HANDLE __MIDL_itf_tom_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_tom_0000_v0_0_s_ifspec;


#ifndef __tom_LIBRARY_DEFINED__
#define __tom_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: tom
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [version][uuid] */


typedef /* [public] */
enum __MIDL___MIDL_itf_tom_0000_0001
    {	tomFalse	= 0,
	tomTrue	= -1,
	tomUndefined	= -9999999,
	tomToggle	= -9999998,
	tomAutoColor	= -9999997,
	tomDefault	= -9999996,
	tomSuspend	= -9999995,
	tomResume	= -9999994,
	tomApplyNow	= 0,
	tomApplyLater	= 1,
	tomTrackParms	= 2,
	tomCacheParms	= 3,
	tomBackward	= 0xc0000001,
	tomForward	= 0x3fffffff,
	tomMove	= 0,
	tomExtend	= 1,
	tomNoSelection	= 0,
	tomSelectionIP	= 1,
	tomSelectionNormal	= 2,
	tomSelectionFrame	= 3,
	tomSelectionColumn	= 4,
	tomSelectionRow	= 5,
	tomSelectionBlock	= 6,
	tomSelectionInlineShape	= 7,
	tomSelectionShape	= 8,
	tomSelStartActive	= 1,
	tomSelAtEOL	= 2,
	tomSelOvertype	= 4,
	tomSelActive	= 8,
	tomSelReplace	= 16,
	tomEnd	= 0,
	tomStart	= 32,
	tomCollapseEnd	= 0,
	tomCollapseStart	= 1,
	tomClientCoord	= 256,
	tomNone	= 0,
	tomSingle	= 1,
	tomWords	= 2,
	tomDouble	= 3,
	tomDotted	= 4,
	tomDash	= 5,
	tomDashDot	= 6,
	tomDashDotDot	= 7,
	tomWave	= 8,
	tomThick	= 9,
	tomHair	= 10,
	tomLineSpaceSingle	= 0,
	tomLineSpace1pt5	= 1,
	tomLineSpaceDouble	= 2,
	tomLineSpaceAtLeast	= 3,
	tomLineSpaceExactly	= 4,
	tomLineSpaceMultiple	= 5,
	tomAlignLeft	= 0,
	tomAlignCenter	= 1,
	tomAlignRight	= 2,
	tomAlignJustify	= 3,
	tomAlignDecimal	= 3,
	tomAlignBar	= 4,
	tomAlignInterWord	= 3,
	tomAlignInterLetter	= 4,
	tomAlignScaled	= 5,
	tomAlignGlyphs	= 6,
	tomAlignSnapGrid	= 7,
	tomSpaces	= 0,
	tomDots	= 1,
	tomDashes	= 2,
	tomLines	= 3,
	tomThickLines	= 4,
	tomEquals	= 5,
	tomTabBack	= -3,
	tomTabNext	= -2,
	tomTabHere	= -1,
	tomListNone	= 0,
	tomListBullet	= 1,
	tomListNumberAsArabic	= 2,
	tomListNumberAsLCLetter	= 3,
	tomListNumberAsUCLetter	= 4,
	tomListNumberAsLCRoman	= 5,
	tomListNumberAsUCRoman	= 6,
	tomListNumberAsSequence	= 7,
	tomListParentheses	= 0x10000,
	tomListPeriod	= 0x20000,
	tomListPlain	= 0x30000,
	tomCharacter	= 1,
	tomWord	= 2,
	tomSentence	= 3,
	tomParagraph	= 4,
	tomLine	= 5,
	tomStory	= 6,
	tomScreen	= 7,
	tomSection	= 8,
	tomColumn	= 9,
	tomRow	= 10,
	tomWindow	= 11,
	tomCell	= 12,
	tomCharFormat	= 13,
	tomParaFormat	= 14,
	tomTable	= 15,
	tomObject	= 16,
	tomMatchWord	= 2,
	tomMatchCase	= 4,
	tomMatchPattern	= 8,
	tomUnknownStory	= 0,
	tomMainTextStory	= 1,
	tomFootnotesStory	= 2,
	tomEndnotesStory	= 3,
	tomCommentsStory	= 4,
	tomTextFrameStory	= 5,
	tomEvenPagesHeaderStory	= 6,
	tomPrimaryHeaderStory	= 7,
	tomEvenPagesFooterStory	= 8,
	tomPrimaryFooterStory	= 9,
	tomFirstPageHeaderStory	= 10,
	tomFirstPageFooterStory	= 11,
	tomNoAnimation	= 0,
	tomLasVegasLights	= 1,
	tomBlinkingBackground	= 2,
	tomSparkleText	= 3,
	tomMarchingBlackAnts	= 4,
	tomMarchingRedAnts	= 5,
	tomShimmer	= 6,
	tomWipeDown	= 7,
	tomWipeRight	= 8,
	tomAnimationMax	= 8,
	tomLowerCase	= 0,
	tomUpperCase	= 1,
	tomTitleCase	= 2,
	tomSentenceCase	= 4,
	tomToggleCase	= 5,
	tomReadOnly	= 0x100,
	tomShareDenyRead	= 0x200,
	tomShareDenyWrite	= 0x400,
	tomPasteFile	= 0x1000,
	tomCreateNew	= 0x10,
	tomCreateAlways	= 0x20,
	tomOpenExisting	= 0x30,
	tomOpenAlways	= 0x40,
	tomTruncateExisting	= 0x50,
	tomRTF	= 0x1,
	tomText	= 0x2,
	tomHTML	= 0x3,
	tomWordDocument	= 0x4,
	tomBold	= 0x80000001,
	tomItalic	= 0x80000002,
	tomUnderline	= 0x80000004,
	tomStrikeout	= 0x80000008,
	tomProtected	= 0x80000010,
	tomLink	= 0x80000020,
	tomSmallCaps	= 0x80000040,
	tomAllCaps	= 0x80000080,
	tomHidden	= 0x80000100,
	tomOutline	= 0x80000200,
	tomShadow	= 0x80000400,
	tomEmboss	= 0x80000800,
	tomImprint	= 0x80001000,
	tomDisabled	= 0x80002000,
	tomRevised	= 0x80004000,
	tomNormalCaret	= 0,
	tomKoreanBlockCaret	= 0x1,
	tomIncludeInset	= 0x1,
	tomIgnoreCurrentFont	= 0,
	tomMatchFontCharset	= 0x1,
	tomMatchFontSignature	= 0x2,
	tomCharset	= 0x80000000
    }	tomConstants;










EXTERN_C const IID LIBID_tom;

#ifndef __ITextDocument_INTERFACE_DEFINED__
#define __ITextDocument_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITextDocument
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][nonextensible][dual][version][uuid] */



EXTERN_C const IID IID_ITextDocument;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("8CC497C0-A1DF-11ce-8098-00AA0047BE5D")
    ITextDocument : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetName(
            /* [retval][out] */ BSTR __RPC_FAR *pName) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSelection(
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStoryCount(
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStoryRanges(
            /* [retval][out] */ ITextStoryRanges __RPC_FAR *__RPC_FAR *ppStories) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSaved(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSaved(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetDefaultTabStop(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetDefaultTabStop(
            /* [in] */ float Value) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE New( void) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Open(
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Save(
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Freeze(
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Unfreeze(
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE BeginEditCollection( void) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndEditCollection( void) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Undo(
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Redo(
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Range(
            /* [in] */ long cp1,
            /* [in] */ long cp2,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE RangeFromPoint(
            /* [in] */ long x,
            /* [in] */ long y,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;

    };

#else 	/* C style interface */

    typedef struct ITextDocumentVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ITextDocument __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ITextDocument __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            ITextDocument __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )(
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSelection )(
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryCount )(
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryRanges )(
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ ITextStoryRanges __RPC_FAR *__RPC_FAR *ppStories);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSaved )(
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSaved )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultTabStop )(
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultTabStop )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ float Value);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *New )(
            ITextDocument __RPC_FAR * This);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Freeze )(
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unfreeze )(
            ITextDocument __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEditCollection )(
            ITextDocument __RPC_FAR * This);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEditCollection )(
            ITextDocument __RPC_FAR * This);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Undo )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redo )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Range )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ long cp1,
            /* [in] */ long cp2,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RangeFromPoint )(
            ITextDocument __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);

        END_INTERFACE
    } ITextDocumentVtbl;

    interface ITextDocument
    {
        CONST_VTBL struct ITextDocumentVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define ITextDocument_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextDocument_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextDocument_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextDocument_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextDocument_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextDocument_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextDocument_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextDocument_GetName(This,pName)	\
    (This)->lpVtbl -> GetName(This,pName)

#define ITextDocument_GetSelection(This,ppSel)	\
    (This)->lpVtbl -> GetSelection(This,ppSel)

#define ITextDocument_GetStoryCount(This,pCount)	\
    (This)->lpVtbl -> GetStoryCount(This,pCount)

#define ITextDocument_GetStoryRanges(This,ppStories)	\
    (This)->lpVtbl -> GetStoryRanges(This,ppStories)

#define ITextDocument_GetSaved(This,pValue)	\
    (This)->lpVtbl -> GetSaved(This,pValue)

#define ITextDocument_SetSaved(This,Value)	\
    (This)->lpVtbl -> SetSaved(This,Value)

#define ITextDocument_GetDefaultTabStop(This,pValue)	\
    (This)->lpVtbl -> GetDefaultTabStop(This,pValue)

#define ITextDocument_SetDefaultTabStop(This,Value)	\
    (This)->lpVtbl -> SetDefaultTabStop(This,Value)

#define ITextDocument_New(This)	\
    (This)->lpVtbl -> New(This)

#define ITextDocument_Open(This,pVar,Flags,CodePage)	\
    (This)->lpVtbl -> Open(This,pVar,Flags,CodePage)

#define ITextDocument_Save(This,pVar,Flags,CodePage)	\
    (This)->lpVtbl -> Save(This,pVar,Flags,CodePage)

#define ITextDocument_Freeze(This,pCount)	\
    (This)->lpVtbl -> Freeze(This,pCount)

#define ITextDocument_Unfreeze(This,pCount)	\
    (This)->lpVtbl -> Unfreeze(This,pCount)

#define ITextDocument_BeginEditCollection(This)	\
    (This)->lpVtbl -> BeginEditCollection(This)

#define ITextDocument_EndEditCollection(This)	\
    (This)->lpVtbl -> EndEditCollection(This)

#define ITextDocument_Undo(This,Count,prop)	\
    (This)->lpVtbl -> Undo(This,Count,prop)

#define ITextDocument_Redo(This,Count,prop)	\
    (This)->lpVtbl -> Redo(This,Count,prop)

#define ITextDocument_Range(This,cp1,cp2,ppRange)	\
    (This)->lpVtbl -> Range(This,cp1,cp2,ppRange)

#define ITextDocument_RangeFromPoint(This,x,y,ppRange)	\
    (This)->lpVtbl -> RangeFromPoint(This,x,y,ppRange)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetName_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pName);


void __RPC_STUB ITextDocument_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetSelection_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);


void __RPC_STUB ITextDocument_GetSelection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetStoryCount_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextDocument_GetStoryCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetStoryRanges_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ ITextStoryRanges __RPC_FAR *__RPC_FAR *ppStories);


void __RPC_STUB ITextDocument_GetStoryRanges_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetSaved_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextDocument_GetSaved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_SetSaved_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextDocument_SetSaved_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_GetDefaultTabStop_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextDocument_GetDefaultTabStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextDocument_SetDefaultTabStop_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextDocument_SetDefaultTabStop_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_New_Proxy(
    ITextDocument __RPC_FAR * This);


void __RPC_STUB ITextDocument_New_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Open_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pVar,
    /* [in] */ long Flags,
    /* [in] */ long CodePage);


void __RPC_STUB ITextDocument_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Save_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pVar,
    /* [in] */ long Flags,
    /* [in] */ long CodePage);


void __RPC_STUB ITextDocument_Save_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Freeze_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextDocument_Freeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Unfreeze_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextDocument_Unfreeze_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_BeginEditCollection_Proxy(
    ITextDocument __RPC_FAR * This);


void __RPC_STUB ITextDocument_BeginEditCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_EndEditCollection_Proxy(
    ITextDocument __RPC_FAR * This);


void __RPC_STUB ITextDocument_EndEditCollection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Undo_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *prop);


void __RPC_STUB ITextDocument_Undo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Redo_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *prop);


void __RPC_STUB ITextDocument_Redo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_Range_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [in] */ long cp1,
    /* [in] */ long cp2,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextDocument_Range_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextDocument_RangeFromPoint_Proxy(
    ITextDocument __RPC_FAR * This,
    /* [in] */ long x,
    /* [in] */ long y,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextDocument_RangeFromPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextDocument_INTERFACE_DEFINED__ */


#ifndef __ITextRange_INTERFACE_DEFINED__
#define __ITextRange_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITextRange
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][nonextensible][dual][version][uuid] */



EXTERN_C const IID IID_ITextRange;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("8CC497C2-A1DF-11ce-8098-00AA0047BE5D")
    ITextRange : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetText(
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetText(
            /* [in] */ BSTR bstr) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetChar(
            /* [retval][out] */ long __RPC_FAR *pch) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetChar(
            /* [in] */ long ch) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetDuplicate(
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetFormattedText(
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetFormattedText(
            /* [in] */ ITextRange __RPC_FAR *pRange) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStart(
            /* [retval][out] */ long __RPC_FAR *pcpFirst) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetStart(
            /* [in] */ long cpFirst) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetEnd(
            /* [retval][out] */ long __RPC_FAR *pcpLim) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetEnd(
            /* [in] */ long cpLim) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetFont(
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *pFont) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetFont(
            /* [in] */ ITextFont __RPC_FAR *pFont) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetPara(
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *pPara) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetPara(
            /* [in] */ ITextPara __RPC_FAR *pPara) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStoryLength(
            /* [retval][out] */ long __RPC_FAR *pcch) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStoryType(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Collapse(
            /* [in] */ long bStart) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Expand(
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetIndex(
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pIndex) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetIndex(
            /* [in] */ long Unit,
            /* [in] */ long Index,
            /* [in] */ long Extend) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetRange(
            /* [in] */ long cpActive,
            /* [in] */ long cpOther) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE InRange(
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE InStory(
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsEqual(
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Select( void) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE StartOf(
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndOf(
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Move(
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveStart(
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveEnd(
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveWhile(
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveStartWhile(
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveEndWhile(
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveUntil(
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveStartUntil(
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveEndUntil(
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FindText(
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FindTextStart(
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE FindTextEnd(
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Delete(
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Cut(
            /* [out] */ VARIANT __RPC_FAR *pVar) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Copy(
            /* [out] */ VARIANT __RPC_FAR *pVar) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Paste(
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CanPaste(
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format,
            /* [retval][out] */ long __RPC_FAR *pb) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CanEdit(
            /* [retval][out] */ long __RPC_FAR *pbCanEdit) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ChangeCase(
            /* [in] */ long Type) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetPoint(
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetPoint(
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ long Type,
            /* [in] */ long Extend) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ScrollIntoView(
            /* [in] */ long Value) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetEmbeddedObject(
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppv) = 0;

    };

#else 	/* C style interface */

    typedef struct ITextRangeVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ITextRange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ITextRange __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ITextRange __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            ITextRange __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            ITextRange __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            ITextRange __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            ITextRange __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetText )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetText )(
            ITextRange __RPC_FAR * This,
            /* [in] */ BSTR bstr);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChar )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pch);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetChar )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long ch);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDuplicate )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormattedText )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFormattedText )(
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStart )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcpFirst);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStart )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long cpFirst);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnd )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcpLim);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnd )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long cpLim);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFont )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *pFont);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFont )(
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextFont __RPC_FAR *pFont);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPara )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *pPara);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPara )(
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextPara __RPC_FAR *pPara);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryLength )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcch);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryType )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Collapse )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long bStart);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Expand )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIndex )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pIndex);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIndex )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Index,
            /* [in] */ long Extend);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRange )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long cpActive,
            /* [in] */ long cpOther);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InRange )(
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InStory )(
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEqual )(
            ITextRange __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Select )(
            ITextRange __RPC_FAR * This);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartOf )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndOf )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStart )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEnd )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveWhile )(
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStartWhile )(
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEndWhile )(
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveUntil )(
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStartUntil )(
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEndUntil )(
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindText )(
            ITextRange __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindTextStart )(
            ITextRange __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindTextEnd )(
            ITextRange __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cut )(
            ITextRange __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *pVar);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Copy )(
            ITextRange __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *pVar);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Paste )(
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanPaste )(
            ITextRange __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format,
            /* [retval][out] */ long __RPC_FAR *pb);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanEdit )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pbCanEdit);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChangeCase )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Type);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPoint )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPoint )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ long Type,
            /* [in] */ long Extend);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ScrollIntoView )(
            ITextRange __RPC_FAR * This,
            /* [in] */ long Value);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEmbeddedObject )(
            ITextRange __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppv);

        END_INTERFACE
    } ITextRangeVtbl;

    interface ITextRange
    {
        CONST_VTBL struct ITextRangeVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define ITextRange_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextRange_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextRange_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextRange_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextRange_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextRange_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextRange_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextRange_GetText(This,pbstr)	\
    (This)->lpVtbl -> GetText(This,pbstr)

#define ITextRange_SetText(This,bstr)	\
    (This)->lpVtbl -> SetText(This,bstr)

#define ITextRange_GetChar(This,pch)	\
    (This)->lpVtbl -> GetChar(This,pch)

#define ITextRange_SetChar(This,ch)	\
    (This)->lpVtbl -> SetChar(This,ch)

#define ITextRange_GetDuplicate(This,ppRange)	\
    (This)->lpVtbl -> GetDuplicate(This,ppRange)

#define ITextRange_GetFormattedText(This,ppRange)	\
    (This)->lpVtbl -> GetFormattedText(This,ppRange)

#define ITextRange_SetFormattedText(This,pRange)	\
    (This)->lpVtbl -> SetFormattedText(This,pRange)

#define ITextRange_GetStart(This,pcpFirst)	\
    (This)->lpVtbl -> GetStart(This,pcpFirst)

#define ITextRange_SetStart(This,cpFirst)	\
    (This)->lpVtbl -> SetStart(This,cpFirst)

#define ITextRange_GetEnd(This,pcpLim)	\
    (This)->lpVtbl -> GetEnd(This,pcpLim)

#define ITextRange_SetEnd(This,cpLim)	\
    (This)->lpVtbl -> SetEnd(This,cpLim)

#define ITextRange_GetFont(This,pFont)	\
    (This)->lpVtbl -> GetFont(This,pFont)

#define ITextRange_SetFont(This,pFont)	\
    (This)->lpVtbl -> SetFont(This,pFont)

#define ITextRange_GetPara(This,pPara)	\
    (This)->lpVtbl -> GetPara(This,pPara)

#define ITextRange_SetPara(This,pPara)	\
    (This)->lpVtbl -> SetPara(This,pPara)

#define ITextRange_GetStoryLength(This,pcch)	\
    (This)->lpVtbl -> GetStoryLength(This,pcch)

#define ITextRange_GetStoryType(This,pValue)	\
    (This)->lpVtbl -> GetStoryType(This,pValue)

#define ITextRange_Collapse(This,bStart)	\
    (This)->lpVtbl -> Collapse(This,bStart)

#define ITextRange_Expand(This,Unit,pDelta)	\
    (This)->lpVtbl -> Expand(This,Unit,pDelta)

#define ITextRange_GetIndex(This,Unit,pIndex)	\
    (This)->lpVtbl -> GetIndex(This,Unit,pIndex)

#define ITextRange_SetIndex(This,Unit,Index,Extend)	\
    (This)->lpVtbl -> SetIndex(This,Unit,Index,Extend)

#define ITextRange_SetRange(This,cpActive,cpOther)	\
    (This)->lpVtbl -> SetRange(This,cpActive,cpOther)

#define ITextRange_InRange(This,pRange,pb)	\
    (This)->lpVtbl -> InRange(This,pRange,pb)

#define ITextRange_InStory(This,pRange,pb)	\
    (This)->lpVtbl -> InStory(This,pRange,pb)

#define ITextRange_IsEqual(This,pRange,pb)	\
    (This)->lpVtbl -> IsEqual(This,pRange,pb)

#define ITextRange_Select(This)	\
    (This)->lpVtbl -> Select(This)

#define ITextRange_StartOf(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> StartOf(This,Unit,Extend,pDelta)

#define ITextRange_EndOf(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> EndOf(This,Unit,Extend,pDelta)

#define ITextRange_Move(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> Move(This,Unit,Count,pDelta)

#define ITextRange_MoveStart(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> MoveStart(This,Unit,Count,pDelta)

#define ITextRange_MoveEnd(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> MoveEnd(This,Unit,Count,pDelta)

#define ITextRange_MoveWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveWhile(This,Cset,Count,pDelta)

#define ITextRange_MoveStartWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveStartWhile(This,Cset,Count,pDelta)

#define ITextRange_MoveEndWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveEndWhile(This,Cset,Count,pDelta)

#define ITextRange_MoveUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveUntil(This,Cset,Count,pDelta)

#define ITextRange_MoveStartUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveStartUntil(This,Cset,Count,pDelta)

#define ITextRange_MoveEndUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveEndUntil(This,Cset,Count,pDelta)

#define ITextRange_FindText(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindText(This,bstr,cch,Flags,pLength)

#define ITextRange_FindTextStart(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindTextStart(This,bstr,cch,Flags,pLength)

#define ITextRange_FindTextEnd(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindTextEnd(This,bstr,cch,Flags,pLength)

#define ITextRange_Delete(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> Delete(This,Unit,Count,pDelta)

#define ITextRange_Cut(This,pVar)	\
    (This)->lpVtbl -> Cut(This,pVar)

#define ITextRange_Copy(This,pVar)	\
    (This)->lpVtbl -> Copy(This,pVar)

#define ITextRange_Paste(This,pVar,Format)	\
    (This)->lpVtbl -> Paste(This,pVar,Format)

#define ITextRange_CanPaste(This,pVar,Format,pb)	\
    (This)->lpVtbl -> CanPaste(This,pVar,Format,pb)

#define ITextRange_CanEdit(This,pbCanEdit)	\
    (This)->lpVtbl -> CanEdit(This,pbCanEdit)

#define ITextRange_ChangeCase(This,Type)	\
    (This)->lpVtbl -> ChangeCase(This,Type)

#define ITextRange_GetPoint(This,Type,px,py)	\
    (This)->lpVtbl -> GetPoint(This,Type,px,py)

#define ITextRange_SetPoint(This,x,y,Type,Extend)	\
    (This)->lpVtbl -> SetPoint(This,x,y,Type,Extend)

#define ITextRange_ScrollIntoView(This,Value)	\
    (This)->lpVtbl -> ScrollIntoView(This,Value)

#define ITextRange_GetEmbeddedObject(This,ppv)	\
    (This)->lpVtbl -> GetEmbeddedObject(This,ppv)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetText_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB ITextRange_GetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetText_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ BSTR bstr);


void __RPC_STUB ITextRange_SetText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetChar_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pch);


void __RPC_STUB ITextRange_GetChar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetChar_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long ch);


void __RPC_STUB ITextRange_SetChar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetDuplicate_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextRange_GetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetFormattedText_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextRange_GetFormattedText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetFormattedText_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextRange __RPC_FAR *pRange);


void __RPC_STUB ITextRange_SetFormattedText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetStart_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcpFirst);


void __RPC_STUB ITextRange_GetStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetStart_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long cpFirst);


void __RPC_STUB ITextRange_SetStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetEnd_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcpLim);


void __RPC_STUB ITextRange_GetEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetEnd_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long cpLim);


void __RPC_STUB ITextRange_SetEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetFont_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *pFont);


void __RPC_STUB ITextRange_GetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetFont_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextFont __RPC_FAR *pFont);


void __RPC_STUB ITextRange_SetFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetPara_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *pPara);


void __RPC_STUB ITextRange_GetPara_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetPara_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextPara __RPC_FAR *pPara);


void __RPC_STUB ITextRange_SetPara_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetStoryLength_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcch);


void __RPC_STUB ITextRange_GetStoryLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetStoryType_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextRange_GetStoryType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Collapse_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long bStart);


void __RPC_STUB ITextRange_Collapse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Expand_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_Expand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetIndex_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [retval][out] */ long __RPC_FAR *pIndex);


void __RPC_STUB ITextRange_GetIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetIndex_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Index,
    /* [in] */ long Extend);


void __RPC_STUB ITextRange_SetIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetRange_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long cpActive,
    /* [in] */ long cpOther);


void __RPC_STUB ITextRange_SetRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_InRange_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextRange __RPC_FAR *pRange,
    /* [retval][out] */ long __RPC_FAR *pb);


void __RPC_STUB ITextRange_InRange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_InStory_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextRange __RPC_FAR *pRange,
    /* [retval][out] */ long __RPC_FAR *pb);


void __RPC_STUB ITextRange_InStory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_IsEqual_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ ITextRange __RPC_FAR *pRange,
    /* [retval][out] */ long __RPC_FAR *pb);


void __RPC_STUB ITextRange_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Select_Proxy(
    ITextRange __RPC_FAR * This);


void __RPC_STUB ITextRange_Select_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_StartOf_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_StartOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_EndOf_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_EndOf_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Move_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveStart_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveEnd_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveWhile_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveWhile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveStartWhile_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveStartWhile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveEndWhile_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveEndWhile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveUntil_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveUntil_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveStartUntil_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveStartUntil_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_MoveEndUntil_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *Cset,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_MoveEndUntil_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_FindText_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ BSTR bstr,
    /* [in] */ long cch,
    /* [in] */ long Flags,
    /* [retval][out] */ long __RPC_FAR *pLength);


void __RPC_STUB ITextRange_FindText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_FindTextStart_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ BSTR bstr,
    /* [in] */ long cch,
    /* [in] */ long Flags,
    /* [retval][out] */ long __RPC_FAR *pLength);


void __RPC_STUB ITextRange_FindTextStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_FindTextEnd_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ BSTR bstr,
    /* [in] */ long cch,
    /* [in] */ long Flags,
    /* [retval][out] */ long __RPC_FAR *pLength);


void __RPC_STUB ITextRange_FindTextEnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Delete_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextRange_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Cut_Proxy(
    ITextRange __RPC_FAR * This,
    /* [out] */ VARIANT __RPC_FAR *pVar);


void __RPC_STUB ITextRange_Cut_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Copy_Proxy(
    ITextRange __RPC_FAR * This,
    /* [out] */ VARIANT __RPC_FAR *pVar);


void __RPC_STUB ITextRange_Copy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_Paste_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pVar,
    /* [in] */ long Format);


void __RPC_STUB ITextRange_Paste_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_CanPaste_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ VARIANT __RPC_FAR *pVar,
    /* [in] */ long Format,
    /* [retval][out] */ long __RPC_FAR *pb);


void __RPC_STUB ITextRange_CanPaste_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_CanEdit_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pbCanEdit);


void __RPC_STUB ITextRange_CanEdit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_ChangeCase_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Type);


void __RPC_STUB ITextRange_ChangeCase_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetPoint_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Type,
    /* [out] */ long __RPC_FAR *px,
    /* [out] */ long __RPC_FAR *py);


void __RPC_STUB ITextRange_GetPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_SetPoint_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long x,
    /* [in] */ long y,
    /* [in] */ long Type,
    /* [in] */ long Extend);


void __RPC_STUB ITextRange_SetPoint_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_ScrollIntoView_Proxy(
    ITextRange __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextRange_ScrollIntoView_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextRange_GetEmbeddedObject_Proxy(
    ITextRange __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB ITextRange_GetEmbeddedObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextRange_INTERFACE_DEFINED__ */


#ifndef __ITextSelection_INTERFACE_DEFINED__
#define __ITextSelection_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITextSelection
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][nonextensible][dual][version][uuid] */



EXTERN_C const IID IID_ITextSelection;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("8CC497C1-A1DF-11ce-8098-00AA0047BE5D")
    ITextSelection : public ITextRange
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetFlags(
            /* [retval][out] */ long __RPC_FAR *pFlags) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetFlags(
            /* [in] */ LONG Flags) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetType(
            /* [retval][out] */ long __RPC_FAR *pType) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveLeft(
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveRight(
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveUp(
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE MoveDown(
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE HomeKey(
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE EndKey(
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE TypeText(
            /* [in] */ BSTR bstr) = 0;

    };

#else 	/* C style interface */

    typedef struct ITextSelectionVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ITextSelection __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ITextSelection __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            ITextSelection __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetText )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetText )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetChar )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pch);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetChar )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long ch);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDuplicate )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFormattedText )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFormattedText )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStart )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcpFirst);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStart )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long cpFirst);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnd )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcpLim);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEnd )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long cpLim);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFont )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *pFont);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFont )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextFont __RPC_FAR *pFont);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPara )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *pPara);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPara )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextPara __RPC_FAR *pPara);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryLength )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcch);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryType )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Collapse )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long bStart);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Expand )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIndex )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [retval][out] */ long __RPC_FAR *pIndex);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIndex )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Index,
            /* [in] */ long Extend);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRange )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long cpActive,
            /* [in] */ long cpOther);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InRange )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InStory )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEqual )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ ITextRange __RPC_FAR *pRange,
            /* [retval][out] */ long __RPC_FAR *pb);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Select )(
            ITextSelection __RPC_FAR * This);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *StartOf )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndOf )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStart )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEnd )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveWhile )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStartWhile )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEndWhile )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveUntil )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveStartUntil )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveEndUntil )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *Cset,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindText )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindTextStart )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FindTextEnd )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr,
            /* [in] */ long cch,
            /* [in] */ long Flags,
            /* [retval][out] */ long __RPC_FAR *pLength);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Cut )(
            ITextSelection __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *pVar);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Copy )(
            ITextSelection __RPC_FAR * This,
            /* [out] */ VARIANT __RPC_FAR *pVar);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Paste )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanPaste )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Format,
            /* [retval][out] */ long __RPC_FAR *pb);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanEdit )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pbCanEdit);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ChangeCase )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Type);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPoint )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *px,
            /* [out] */ long __RPC_FAR *py);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPoint )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [in] */ long Type,
            /* [in] */ long Extend);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ScrollIntoView )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Value);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEmbeddedObject )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppv);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFlags )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pFlags);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetFlags )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ LONG Flags);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetType )(
            ITextSelection __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pType);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveLeft )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveRight )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveUp )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MoveDown )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Count,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HomeKey )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndKey )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ long Unit,
            /* [in] */ long Extend,
            /* [retval][out] */ long __RPC_FAR *pDelta);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TypeText )(
            ITextSelection __RPC_FAR * This,
            /* [in] */ BSTR bstr);

        END_INTERFACE
    } ITextSelectionVtbl;

    interface ITextSelection
    {
        CONST_VTBL struct ITextSelectionVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define ITextSelection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextSelection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextSelection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextSelection_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextSelection_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextSelection_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextSelection_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextSelection_GetText(This,pbstr)	\
    (This)->lpVtbl -> GetText(This,pbstr)

#define ITextSelection_SetText(This,bstr)	\
    (This)->lpVtbl -> SetText(This,bstr)

#define ITextSelection_GetChar(This,pch)	\
    (This)->lpVtbl -> GetChar(This,pch)

#define ITextSelection_SetChar(This,ch)	\
    (This)->lpVtbl -> SetChar(This,ch)

#define ITextSelection_GetDuplicate(This,ppRange)	\
    (This)->lpVtbl -> GetDuplicate(This,ppRange)

#define ITextSelection_GetFormattedText(This,ppRange)	\
    (This)->lpVtbl -> GetFormattedText(This,ppRange)

#define ITextSelection_SetFormattedText(This,pRange)	\
    (This)->lpVtbl -> SetFormattedText(This,pRange)

#define ITextSelection_GetStart(This,pcpFirst)	\
    (This)->lpVtbl -> GetStart(This,pcpFirst)

#define ITextSelection_SetStart(This,cpFirst)	\
    (This)->lpVtbl -> SetStart(This,cpFirst)

#define ITextSelection_GetEnd(This,pcpLim)	\
    (This)->lpVtbl -> GetEnd(This,pcpLim)

#define ITextSelection_SetEnd(This,cpLim)	\
    (This)->lpVtbl -> SetEnd(This,cpLim)

#define ITextSelection_GetFont(This,pFont)	\
    (This)->lpVtbl -> GetFont(This,pFont)

#define ITextSelection_SetFont(This,pFont)	\
    (This)->lpVtbl -> SetFont(This,pFont)

#define ITextSelection_GetPara(This,pPara)	\
    (This)->lpVtbl -> GetPara(This,pPara)

#define ITextSelection_SetPara(This,pPara)	\
    (This)->lpVtbl -> SetPara(This,pPara)

#define ITextSelection_GetStoryLength(This,pcch)	\
    (This)->lpVtbl -> GetStoryLength(This,pcch)

#define ITextSelection_GetStoryType(This,pValue)	\
    (This)->lpVtbl -> GetStoryType(This,pValue)

#define ITextSelection_Collapse(This,bStart)	\
    (This)->lpVtbl -> Collapse(This,bStart)

#define ITextSelection_Expand(This,Unit,pDelta)	\
    (This)->lpVtbl -> Expand(This,Unit,pDelta)

#define ITextSelection_GetIndex(This,Unit,pIndex)	\
    (This)->lpVtbl -> GetIndex(This,Unit,pIndex)

#define ITextSelection_SetIndex(This,Unit,Index,Extend)	\
    (This)->lpVtbl -> SetIndex(This,Unit,Index,Extend)

#define ITextSelection_SetRange(This,cpActive,cpOther)	\
    (This)->lpVtbl -> SetRange(This,cpActive,cpOther)

#define ITextSelection_InRange(This,pRange,pb)	\
    (This)->lpVtbl -> InRange(This,pRange,pb)

#define ITextSelection_InStory(This,pRange,pb)	\
    (This)->lpVtbl -> InStory(This,pRange,pb)

#define ITextSelection_IsEqual(This,pRange,pb)	\
    (This)->lpVtbl -> IsEqual(This,pRange,pb)

#define ITextSelection_Select(This)	\
    (This)->lpVtbl -> Select(This)

#define ITextSelection_StartOf(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> StartOf(This,Unit,Extend,pDelta)

#define ITextSelection_EndOf(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> EndOf(This,Unit,Extend,pDelta)

#define ITextSelection_Move(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> Move(This,Unit,Count,pDelta)

#define ITextSelection_MoveStart(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> MoveStart(This,Unit,Count,pDelta)

#define ITextSelection_MoveEnd(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> MoveEnd(This,Unit,Count,pDelta)

#define ITextSelection_MoveWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveWhile(This,Cset,Count,pDelta)

#define ITextSelection_MoveStartWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveStartWhile(This,Cset,Count,pDelta)

#define ITextSelection_MoveEndWhile(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveEndWhile(This,Cset,Count,pDelta)

#define ITextSelection_MoveUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveUntil(This,Cset,Count,pDelta)

#define ITextSelection_MoveStartUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveStartUntil(This,Cset,Count,pDelta)

#define ITextSelection_MoveEndUntil(This,Cset,Count,pDelta)	\
    (This)->lpVtbl -> MoveEndUntil(This,Cset,Count,pDelta)

#define ITextSelection_FindText(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindText(This,bstr,cch,Flags,pLength)

#define ITextSelection_FindTextStart(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindTextStart(This,bstr,cch,Flags,pLength)

#define ITextSelection_FindTextEnd(This,bstr,cch,Flags,pLength)	\
    (This)->lpVtbl -> FindTextEnd(This,bstr,cch,Flags,pLength)

#define ITextSelection_Delete(This,Unit,Count,pDelta)	\
    (This)->lpVtbl -> Delete(This,Unit,Count,pDelta)

#define ITextSelection_Cut(This,pVar)	\
    (This)->lpVtbl -> Cut(This,pVar)

#define ITextSelection_Copy(This,pVar)	\
    (This)->lpVtbl -> Copy(This,pVar)

#define ITextSelection_Paste(This,pVar,Format)	\
    (This)->lpVtbl -> Paste(This,pVar,Format)

#define ITextSelection_CanPaste(This,pVar,Format,pb)	\
    (This)->lpVtbl -> CanPaste(This,pVar,Format,pb)

#define ITextSelection_CanEdit(This,pbCanEdit)	\
    (This)->lpVtbl -> CanEdit(This,pbCanEdit)

#define ITextSelection_ChangeCase(This,Type)	\
    (This)->lpVtbl -> ChangeCase(This,Type)

#define ITextSelection_GetPoint(This,Type,px,py)	\
    (This)->lpVtbl -> GetPoint(This,Type,px,py)

#define ITextSelection_SetPoint(This,x,y,Type,Extend)	\
    (This)->lpVtbl -> SetPoint(This,x,y,Type,Extend)

#define ITextSelection_ScrollIntoView(This,Value)	\
    (This)->lpVtbl -> ScrollIntoView(This,Value)

#define ITextSelection_GetEmbeddedObject(This,ppv)	\
    (This)->lpVtbl -> GetEmbeddedObject(This,ppv)


#define ITextSelection_GetFlags(This,pFlags)	\
    (This)->lpVtbl -> GetFlags(This,pFlags)

#define ITextSelection_SetFlags(This,Flags)	\
    (This)->lpVtbl -> SetFlags(This,Flags)

#define ITextSelection_GetType(This,pType)	\
    (This)->lpVtbl -> GetType(This,pType)

#define ITextSelection_MoveLeft(This,Unit,Count,Extend,pDelta)	\
    (This)->lpVtbl -> MoveLeft(This,Unit,Count,Extend,pDelta)

#define ITextSelection_MoveRight(This,Unit,Count,Extend,pDelta)	\
    (This)->lpVtbl -> MoveRight(This,Unit,Count,Extend,pDelta)

#define ITextSelection_MoveUp(This,Unit,Count,Extend,pDelta)	\
    (This)->lpVtbl -> MoveUp(This,Unit,Count,Extend,pDelta)

#define ITextSelection_MoveDown(This,Unit,Count,Extend,pDelta)	\
    (This)->lpVtbl -> MoveDown(This,Unit,Count,Extend,pDelta)

#define ITextSelection_HomeKey(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> HomeKey(This,Unit,Extend,pDelta)

#define ITextSelection_EndKey(This,Unit,Extend,pDelta)	\
    (This)->lpVtbl -> EndKey(This,Unit,Extend,pDelta)

#define ITextSelection_TypeText(This,bstr)	\
    (This)->lpVtbl -> TypeText(This,bstr)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextSelection_GetFlags_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pFlags);


void __RPC_STUB ITextSelection_GetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextSelection_SetFlags_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [in] */ LONG Flags);


void __RPC_STUB ITextSelection_SetFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextSelection_GetType_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pType);


void __RPC_STUB ITextSelection_GetType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_MoveLeft_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_MoveLeft_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_MoveRight_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_MoveRight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_MoveUp_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_MoveUp_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_MoveDown_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Count,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_MoveDown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_HomeKey_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_HomeKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_EndKey_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [in] */ long Unit,
    /* [in] */ long Extend,
    /* [retval][out] */ long __RPC_FAR *pDelta);


void __RPC_STUB ITextSelection_EndKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextSelection_TypeText_Proxy(
    ITextSelection __RPC_FAR * This,
    /* [in] */ BSTR bstr);


void __RPC_STUB ITextSelection_TypeText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextSelection_INTERFACE_DEFINED__ */


#ifndef __ITextFont_INTERFACE_DEFINED__
#define __ITextFont_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITextFont
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][nonextensible][dual][version][uuid] */



EXTERN_C const IID IID_ITextFont;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("8CC497C3-A1DF-11ce-8098-00AA0047BE5D")
    ITextFont : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetDuplicate(
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *ppFont) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetDuplicate(
            /* [in] */ ITextFont __RPC_FAR *pFont) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CanChange(
            /* [retval][out] */ long __RPC_FAR *pB) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsEqual(
            /* [in] */ ITextFont __RPC_FAR *pFont,
            /* [retval][out] */ long __RPC_FAR *pB) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Reset(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStyle(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetStyle(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetAllCaps(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetAllCaps(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetAnimation(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetAnimation(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetBackColor(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetBackColor(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetBold(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetBold(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetEmboss(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetEmboss(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetForeColor(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetForeColor(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetHidden(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetHidden(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetEngrave(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetEngrave(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetItalic(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetItalic(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetKerning(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetKerning(
            /* [in] */ float Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetLanguageID(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetLanguageID(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetName(
            /* [retval][out] */ BSTR __RPC_FAR *pbstr) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetName(
            /* [in] */ BSTR bstr) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetOutline(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetOutline(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetPosition(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetPosition(
            /* [in] */ float Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetProtected(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetProtected(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetShadow(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetShadow(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSize(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSize(
            /* [in] */ float Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSmallCaps(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSmallCaps(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSpacing(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSpacing(
            /* [in] */ float Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStrikeThrough(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetStrikeThrough(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSubscript(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSubscript(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSuperscript(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSuperscript(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetUnderline(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetUnderline(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetWeight(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetWeight(
            /* [in] */ long Value) = 0;

    };

#else 	/* C style interface */

    typedef struct ITextFontVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ITextFont __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ITextFont __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ITextFont __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            ITextFont __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            ITextFont __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            ITextFont __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            ITextFont __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDuplicate )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *ppFont);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDuplicate )(
            ITextFont __RPC_FAR * This,
            /* [in] */ ITextFont __RPC_FAR *pFont);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanChange )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pB);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEqual )(
            ITextFont __RPC_FAR * This,
            /* [in] */ ITextFont __RPC_FAR *pFont,
            /* [retval][out] */ long __RPC_FAR *pB);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStyle )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStyle )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllCaps )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAllCaps )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAnimation )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAnimation )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBackColor )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBackColor )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetBold )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetBold )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEmboss )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEmboss )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetForeColor )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetForeColor )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHidden )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHidden )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEngrave )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEngrave )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetItalic )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetItalic )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKerning )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKerning )(
            ITextFont __RPC_FAR * This,
            /* [in] */ float Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLanguageID )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLanguageID )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstr);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetName )(
            ITextFont __RPC_FAR * This,
            /* [in] */ BSTR bstr);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOutline )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOutline )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPosition )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPosition )(
            ITextFont __RPC_FAR * This,
            /* [in] */ float Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProtected )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetProtected )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetShadow )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetShadow )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSize )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSize )(
            ITextFont __RPC_FAR * This,
            /* [in] */ float Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSmallCaps )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSmallCaps )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpacing )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSpacing )(
            ITextFont __RPC_FAR * This,
            /* [in] */ float Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStrikeThrough )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStrikeThrough )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSubscript )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSubscript )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSuperscript )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSuperscript )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetUnderline )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetUnderline )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWeight )(
            ITextFont __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWeight )(
            ITextFont __RPC_FAR * This,
            /* [in] */ long Value);

        END_INTERFACE
    } ITextFontVtbl;

    interface ITextFont
    {
        CONST_VTBL struct ITextFontVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define ITextFont_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextFont_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextFont_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextFont_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextFont_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextFont_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextFont_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextFont_GetDuplicate(This,ppFont)	\
    (This)->lpVtbl -> GetDuplicate(This,ppFont)

#define ITextFont_SetDuplicate(This,pFont)	\
    (This)->lpVtbl -> SetDuplicate(This,pFont)

#define ITextFont_CanChange(This,pB)	\
    (This)->lpVtbl -> CanChange(This,pB)

#define ITextFont_IsEqual(This,pFont,pB)	\
    (This)->lpVtbl -> IsEqual(This,pFont,pB)

#define ITextFont_Reset(This,Value)	\
    (This)->lpVtbl -> Reset(This,Value)

#define ITextFont_GetStyle(This,pValue)	\
    (This)->lpVtbl -> GetStyle(This,pValue)

#define ITextFont_SetStyle(This,Value)	\
    (This)->lpVtbl -> SetStyle(This,Value)

#define ITextFont_GetAllCaps(This,pValue)	\
    (This)->lpVtbl -> GetAllCaps(This,pValue)

#define ITextFont_SetAllCaps(This,Value)	\
    (This)->lpVtbl -> SetAllCaps(This,Value)

#define ITextFont_GetAnimation(This,pValue)	\
    (This)->lpVtbl -> GetAnimation(This,pValue)

#define ITextFont_SetAnimation(This,Value)	\
    (This)->lpVtbl -> SetAnimation(This,Value)

#define ITextFont_GetBackColor(This,pValue)	\
    (This)->lpVtbl -> GetBackColor(This,pValue)

#define ITextFont_SetBackColor(This,Value)	\
    (This)->lpVtbl -> SetBackColor(This,Value)

#define ITextFont_GetBold(This,pValue)	\
    (This)->lpVtbl -> GetBold(This,pValue)

#define ITextFont_SetBold(This,Value)	\
    (This)->lpVtbl -> SetBold(This,Value)

#define ITextFont_GetEmboss(This,pValue)	\
    (This)->lpVtbl -> GetEmboss(This,pValue)

#define ITextFont_SetEmboss(This,Value)	\
    (This)->lpVtbl -> SetEmboss(This,Value)

#define ITextFont_GetForeColor(This,pValue)	\
    (This)->lpVtbl -> GetForeColor(This,pValue)

#define ITextFont_SetForeColor(This,Value)	\
    (This)->lpVtbl -> SetForeColor(This,Value)

#define ITextFont_GetHidden(This,pValue)	\
    (This)->lpVtbl -> GetHidden(This,pValue)

#define ITextFont_SetHidden(This,Value)	\
    (This)->lpVtbl -> SetHidden(This,Value)

#define ITextFont_GetEngrave(This,pValue)	\
    (This)->lpVtbl -> GetEngrave(This,pValue)

#define ITextFont_SetEngrave(This,Value)	\
    (This)->lpVtbl -> SetEngrave(This,Value)

#define ITextFont_GetItalic(This,pValue)	\
    (This)->lpVtbl -> GetItalic(This,pValue)

#define ITextFont_SetItalic(This,Value)	\
    (This)->lpVtbl -> SetItalic(This,Value)

#define ITextFont_GetKerning(This,pValue)	\
    (This)->lpVtbl -> GetKerning(This,pValue)

#define ITextFont_SetKerning(This,Value)	\
    (This)->lpVtbl -> SetKerning(This,Value)

#define ITextFont_GetLanguageID(This,pValue)	\
    (This)->lpVtbl -> GetLanguageID(This,pValue)

#define ITextFont_SetLanguageID(This,Value)	\
    (This)->lpVtbl -> SetLanguageID(This,Value)

#define ITextFont_GetName(This,pbstr)	\
    (This)->lpVtbl -> GetName(This,pbstr)

#define ITextFont_SetName(This,bstr)	\
    (This)->lpVtbl -> SetName(This,bstr)

#define ITextFont_GetOutline(This,pValue)	\
    (This)->lpVtbl -> GetOutline(This,pValue)

#define ITextFont_SetOutline(This,Value)	\
    (This)->lpVtbl -> SetOutline(This,Value)

#define ITextFont_GetPosition(This,pValue)	\
    (This)->lpVtbl -> GetPosition(This,pValue)

#define ITextFont_SetPosition(This,Value)	\
    (This)->lpVtbl -> SetPosition(This,Value)

#define ITextFont_GetProtected(This,pValue)	\
    (This)->lpVtbl -> GetProtected(This,pValue)

#define ITextFont_SetProtected(This,Value)	\
    (This)->lpVtbl -> SetProtected(This,Value)

#define ITextFont_GetShadow(This,pValue)	\
    (This)->lpVtbl -> GetShadow(This,pValue)

#define ITextFont_SetShadow(This,Value)	\
    (This)->lpVtbl -> SetShadow(This,Value)

#define ITextFont_GetSize(This,pValue)	\
    (This)->lpVtbl -> GetSize(This,pValue)

#define ITextFont_SetSize(This,Value)	\
    (This)->lpVtbl -> SetSize(This,Value)

#define ITextFont_GetSmallCaps(This,pValue)	\
    (This)->lpVtbl -> GetSmallCaps(This,pValue)

#define ITextFont_SetSmallCaps(This,Value)	\
    (This)->lpVtbl -> SetSmallCaps(This,Value)

#define ITextFont_GetSpacing(This,pValue)	\
    (This)->lpVtbl -> GetSpacing(This,pValue)

#define ITextFont_SetSpacing(This,Value)	\
    (This)->lpVtbl -> SetSpacing(This,Value)

#define ITextFont_GetStrikeThrough(This,pValue)	\
    (This)->lpVtbl -> GetStrikeThrough(This,pValue)

#define ITextFont_SetStrikeThrough(This,Value)	\
    (This)->lpVtbl -> SetStrikeThrough(This,Value)

#define ITextFont_GetSubscript(This,pValue)	\
    (This)->lpVtbl -> GetSubscript(This,pValue)

#define ITextFont_SetSubscript(This,Value)	\
    (This)->lpVtbl -> SetSubscript(This,Value)

#define ITextFont_GetSuperscript(This,pValue)	\
    (This)->lpVtbl -> GetSuperscript(This,pValue)

#define ITextFont_SetSuperscript(This,Value)	\
    (This)->lpVtbl -> SetSuperscript(This,Value)

#define ITextFont_GetUnderline(This,pValue)	\
    (This)->lpVtbl -> GetUnderline(This,pValue)

#define ITextFont_SetUnderline(This,Value)	\
    (This)->lpVtbl -> SetUnderline(This,Value)

#define ITextFont_GetWeight(This,pValue)	\
    (This)->lpVtbl -> GetWeight(This,pValue)

#define ITextFont_SetWeight(This,Value)	\
    (This)->lpVtbl -> SetWeight(This,Value)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetDuplicate_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ ITextFont __RPC_FAR *__RPC_FAR *ppFont);


void __RPC_STUB ITextFont_GetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetDuplicate_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ ITextFont __RPC_FAR *pFont);


void __RPC_STUB ITextFont_SetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextFont_CanChange_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pB);


void __RPC_STUB ITextFont_CanChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextFont_IsEqual_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ ITextFont __RPC_FAR *pFont,
    /* [retval][out] */ long __RPC_FAR *pB);


void __RPC_STUB ITextFont_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextFont_Reset_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetStyle_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetStyle_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetAllCaps_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetAllCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetAllCaps_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetAllCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetAnimation_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetAnimation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetAnimation_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetAnimation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetBackColor_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetBackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetBackColor_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetBackColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetBold_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetBold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetBold_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetBold_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetEmboss_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetEmboss_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetEmboss_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetEmboss_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetForeColor_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetForeColor_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetForeColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetHidden_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetHidden_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetHidden_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetHidden_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetEngrave_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetEngrave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetEngrave_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetEngrave_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetItalic_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetItalic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetItalic_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetItalic_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetKerning_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetKerning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetKerning_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextFont_SetKerning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetLanguageID_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetLanguageID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetLanguageID_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetLanguageID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetName_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstr);


void __RPC_STUB ITextFont_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetName_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ BSTR bstr);


void __RPC_STUB ITextFont_SetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetOutline_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetOutline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetOutline_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetOutline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetPosition_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetPosition_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextFont_SetPosition_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetProtected_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetProtected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetProtected_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetProtected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetShadow_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetShadow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetShadow_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetShadow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSize_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSize_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextFont_SetSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSmallCaps_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSmallCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSmallCaps_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetSmallCaps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSpacing_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSpacing_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextFont_SetSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetStrikeThrough_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetStrikeThrough_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetStrikeThrough_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetStrikeThrough_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSubscript_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSubscript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSubscript_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetSubscript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetSuperscript_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetSuperscript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetSuperscript_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetSuperscript_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetUnderline_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetUnderline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetUnderline_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetUnderline_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextFont_GetWeight_Proxy(
    ITextFont __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextFont_GetWeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextFont_SetWeight_Proxy(
    ITextFont __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextFont_SetWeight_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextFont_INTERFACE_DEFINED__ */


#ifndef __ITextPara_INTERFACE_DEFINED__
#define __ITextPara_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITextPara
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][nonextensible][dual][version][uuid] */



EXTERN_C const IID IID_ITextPara;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("8CC497C4-A1DF-11ce-8098-00AA0047BE5D")
    ITextPara : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetDuplicate(
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *ppPara) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetDuplicate(
            /* [in] */ ITextPara __RPC_FAR *pPara) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE CanChange(
            /* [retval][out] */ long __RPC_FAR *pB) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE IsEqual(
            /* [in] */ ITextPara __RPC_FAR *pPara,
            /* [retval][out] */ long __RPC_FAR *pB) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Reset(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetStyle(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetStyle(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetAlignment(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetAlignment(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetHyphenation(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetHyphenation(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetFirstLineIndent(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetKeepTogether(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetKeepTogether(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetKeepWithNext(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetKeepWithNext(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetLeftIndent(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetLineSpacing(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetLineSpacingRule(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListAlignment(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListAlignment(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListLevelIndex(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListLevelIndex(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListStart(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListStart(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListTab(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListTab(
            /* [in] */ float Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetListType(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetListType(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetNoLineNumber(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetNoLineNumber(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetPageBreakBefore(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetPageBreakBefore(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetRightIndent(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetRightIndent(
            /* [in] */ float Value) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetIndents(
            /* [in] */ float StartIndent,
            /* [in] */ float LeftIndent,
            /* [in] */ float RightIndent) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE SetLineSpacing(
            /* [in] */ long LineSpacingRule,
            /* [in] */ float LineSpacing) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSpaceAfter(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSpaceAfter(
            /* [in] */ float Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetSpaceBefore(
            /* [retval][out] */ float __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetSpaceBefore(
            /* [in] */ float Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetWidowControl(
            /* [retval][out] */ long __RPC_FAR *pValue) = 0;

        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE SetWidowControl(
            /* [in] */ long Value) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetTabCount(
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE AddTab(
            /* [in] */ float tbPos,
            /* [in] */ long tbAlign,
            /* [in] */ long tbLeader) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE ClearAllTabs( void) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE DeleteTab(
            /* [in] */ float tbPos) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE GetTab(
            /* [in] */ long iTab,
            /* [out] */ float __RPC_FAR *ptbPos,
            /* [out] */ long __RPC_FAR *ptbAlign,
            /* [out] */ long __RPC_FAR *ptbLeader) = 0;

    };

#else 	/* C style interface */

    typedef struct ITextParaVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ITextPara __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ITextPara __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ITextPara __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            ITextPara __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            ITextPara __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            ITextPara __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            ITextPara __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDuplicate )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *ppPara);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDuplicate )(
            ITextPara __RPC_FAR * This,
            /* [in] */ ITextPara __RPC_FAR *pPara);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CanChange )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pB);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsEqual )(
            ITextPara __RPC_FAR * This,
            /* [in] */ ITextPara __RPC_FAR *pPara,
            /* [retval][out] */ long __RPC_FAR *pB);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStyle )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStyle )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAlignment )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetAlignment )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHyphenation )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHyphenation )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFirstLineIndent )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKeepTogether )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKeepTogether )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKeepWithNext )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKeepWithNext )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLeftIndent )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineSpacing )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLineSpacingRule )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListAlignment )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListAlignment )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListLevelIndex )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListLevelIndex )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListStart )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListStart )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListTab )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListTab )(
            ITextPara __RPC_FAR * This,
            /* [in] */ float Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetListType )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetListType )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNoLineNumber )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNoLineNumber )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPageBreakBefore )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPageBreakBefore )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRightIndent )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRightIndent )(
            ITextPara __RPC_FAR * This,
            /* [in] */ float Value);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIndents )(
            ITextPara __RPC_FAR * This,
            /* [in] */ float StartIndent,
            /* [in] */ float LeftIndent,
            /* [in] */ float RightIndent);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLineSpacing )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long LineSpacingRule,
            /* [in] */ float LineSpacing);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpaceAfter )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSpaceAfter )(
            ITextPara __RPC_FAR * This,
            /* [in] */ float Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSpaceBefore )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSpaceBefore )(
            ITextPara __RPC_FAR * This,
            /* [in] */ float Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWidowControl )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetWidowControl )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTabCount )(
            ITextPara __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddTab )(
            ITextPara __RPC_FAR * This,
            /* [in] */ float tbPos,
            /* [in] */ long tbAlign,
            /* [in] */ long tbLeader);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ClearAllTabs )(
            ITextPara __RPC_FAR * This);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteTab )(
            ITextPara __RPC_FAR * This,
            /* [in] */ float tbPos);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTab )(
            ITextPara __RPC_FAR * This,
            /* [in] */ long iTab,
            /* [out] */ float __RPC_FAR *ptbPos,
            /* [out] */ long __RPC_FAR *ptbAlign,
            /* [out] */ long __RPC_FAR *ptbLeader);

        END_INTERFACE
    } ITextParaVtbl;

    interface ITextPara
    {
        CONST_VTBL struct ITextParaVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define ITextPara_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextPara_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextPara_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextPara_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextPara_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextPara_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextPara_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextPara_GetDuplicate(This,ppPara)	\
    (This)->lpVtbl -> GetDuplicate(This,ppPara)

#define ITextPara_SetDuplicate(This,pPara)	\
    (This)->lpVtbl -> SetDuplicate(This,pPara)

#define ITextPara_CanChange(This,pB)	\
    (This)->lpVtbl -> CanChange(This,pB)

#define ITextPara_IsEqual(This,pPara,pB)	\
    (This)->lpVtbl -> IsEqual(This,pPara,pB)

#define ITextPara_Reset(This,Value)	\
    (This)->lpVtbl -> Reset(This,Value)

#define ITextPara_GetStyle(This,pValue)	\
    (This)->lpVtbl -> GetStyle(This,pValue)

#define ITextPara_SetStyle(This,Value)	\
    (This)->lpVtbl -> SetStyle(This,Value)

#define ITextPara_GetAlignment(This,pValue)	\
    (This)->lpVtbl -> GetAlignment(This,pValue)

#define ITextPara_SetAlignment(This,Value)	\
    (This)->lpVtbl -> SetAlignment(This,Value)

#define ITextPara_GetHyphenation(This,pValue)	\
    (This)->lpVtbl -> GetHyphenation(This,pValue)

#define ITextPara_SetHyphenation(This,Value)	\
    (This)->lpVtbl -> SetHyphenation(This,Value)

#define ITextPara_GetFirstLineIndent(This,pValue)	\
    (This)->lpVtbl -> GetFirstLineIndent(This,pValue)

#define ITextPara_GetKeepTogether(This,pValue)	\
    (This)->lpVtbl -> GetKeepTogether(This,pValue)

#define ITextPara_SetKeepTogether(This,Value)	\
    (This)->lpVtbl -> SetKeepTogether(This,Value)

#define ITextPara_GetKeepWithNext(This,pValue)	\
    (This)->lpVtbl -> GetKeepWithNext(This,pValue)

#define ITextPara_SetKeepWithNext(This,Value)	\
    (This)->lpVtbl -> SetKeepWithNext(This,Value)

#define ITextPara_GetLeftIndent(This,pValue)	\
    (This)->lpVtbl -> GetLeftIndent(This,pValue)

#define ITextPara_GetLineSpacing(This,pValue)	\
    (This)->lpVtbl -> GetLineSpacing(This,pValue)

#define ITextPara_GetLineSpacingRule(This,pValue)	\
    (This)->lpVtbl -> GetLineSpacingRule(This,pValue)

#define ITextPara_GetListAlignment(This,pValue)	\
    (This)->lpVtbl -> GetListAlignment(This,pValue)

#define ITextPara_SetListAlignment(This,Value)	\
    (This)->lpVtbl -> SetListAlignment(This,Value)

#define ITextPara_GetListLevelIndex(This,pValue)	\
    (This)->lpVtbl -> GetListLevelIndex(This,pValue)

#define ITextPara_SetListLevelIndex(This,Value)	\
    (This)->lpVtbl -> SetListLevelIndex(This,Value)

#define ITextPara_GetListStart(This,pValue)	\
    (This)->lpVtbl -> GetListStart(This,pValue)

#define ITextPara_SetListStart(This,Value)	\
    (This)->lpVtbl -> SetListStart(This,Value)

#define ITextPara_GetListTab(This,pValue)	\
    (This)->lpVtbl -> GetListTab(This,pValue)

#define ITextPara_SetListTab(This,Value)	\
    (This)->lpVtbl -> SetListTab(This,Value)

#define ITextPara_GetListType(This,pValue)	\
    (This)->lpVtbl -> GetListType(This,pValue)

#define ITextPara_SetListType(This,Value)	\
    (This)->lpVtbl -> SetListType(This,Value)

#define ITextPara_GetNoLineNumber(This,pValue)	\
    (This)->lpVtbl -> GetNoLineNumber(This,pValue)

#define ITextPara_SetNoLineNumber(This,Value)	\
    (This)->lpVtbl -> SetNoLineNumber(This,Value)

#define ITextPara_GetPageBreakBefore(This,pValue)	\
    (This)->lpVtbl -> GetPageBreakBefore(This,pValue)

#define ITextPara_SetPageBreakBefore(This,Value)	\
    (This)->lpVtbl -> SetPageBreakBefore(This,Value)

#define ITextPara_GetRightIndent(This,pValue)	\
    (This)->lpVtbl -> GetRightIndent(This,pValue)

#define ITextPara_SetRightIndent(This,Value)	\
    (This)->lpVtbl -> SetRightIndent(This,Value)

#define ITextPara_SetIndents(This,StartIndent,LeftIndent,RightIndent)	\
    (This)->lpVtbl -> SetIndents(This,StartIndent,LeftIndent,RightIndent)

#define ITextPara_SetLineSpacing(This,LineSpacingRule,LineSpacing)	\
    (This)->lpVtbl -> SetLineSpacing(This,LineSpacingRule,LineSpacing)

#define ITextPara_GetSpaceAfter(This,pValue)	\
    (This)->lpVtbl -> GetSpaceAfter(This,pValue)

#define ITextPara_SetSpaceAfter(This,Value)	\
    (This)->lpVtbl -> SetSpaceAfter(This,Value)

#define ITextPara_GetSpaceBefore(This,pValue)	\
    (This)->lpVtbl -> GetSpaceBefore(This,pValue)

#define ITextPara_SetSpaceBefore(This,Value)	\
    (This)->lpVtbl -> SetSpaceBefore(This,Value)

#define ITextPara_GetWidowControl(This,pValue)	\
    (This)->lpVtbl -> GetWidowControl(This,pValue)

#define ITextPara_SetWidowControl(This,Value)	\
    (This)->lpVtbl -> SetWidowControl(This,Value)

#define ITextPara_GetTabCount(This,pCount)	\
    (This)->lpVtbl -> GetTabCount(This,pCount)

#define ITextPara_AddTab(This,tbPos,tbAlign,tbLeader)	\
    (This)->lpVtbl -> AddTab(This,tbPos,tbAlign,tbLeader)

#define ITextPara_ClearAllTabs(This)	\
    (This)->lpVtbl -> ClearAllTabs(This)

#define ITextPara_DeleteTab(This,tbPos)	\
    (This)->lpVtbl -> DeleteTab(This,tbPos)

#define ITextPara_GetTab(This,iTab,ptbPos,ptbAlign,ptbLeader)	\
    (This)->lpVtbl -> GetTab(This,iTab,ptbPos,ptbAlign,ptbLeader)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetDuplicate_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ ITextPara __RPC_FAR *__RPC_FAR *ppPara);


void __RPC_STUB ITextPara_GetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetDuplicate_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ ITextPara __RPC_FAR *pPara);


void __RPC_STUB ITextPara_SetDuplicate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_CanChange_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pB);


void __RPC_STUB ITextPara_CanChange_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_IsEqual_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ ITextPara __RPC_FAR *pPara,
    /* [retval][out] */ long __RPC_FAR *pB);


void __RPC_STUB ITextPara_IsEqual_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_Reset_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetStyle_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetStyle_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetAlignment_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetAlignment_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetHyphenation_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetHyphenation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetHyphenation_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetHyphenation_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetFirstLineIndent_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetFirstLineIndent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetKeepTogether_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetKeepTogether_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetKeepTogether_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetKeepTogether_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetKeepWithNext_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetKeepWithNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetKeepWithNext_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetKeepWithNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetLeftIndent_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetLeftIndent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetLineSpacing_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetLineSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetLineSpacingRule_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetLineSpacingRule_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListAlignment_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListAlignment_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetListAlignment_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListLevelIndex_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListLevelIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListLevelIndex_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetListLevelIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListStart_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListStart_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetListStart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListTab_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListTab_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextPara_SetListTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetListType_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetListType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetListType_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetListType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetNoLineNumber_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetNoLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetNoLineNumber_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetNoLineNumber_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetPageBreakBefore_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetPageBreakBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetPageBreakBefore_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetPageBreakBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetRightIndent_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetRightIndent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetRightIndent_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextPara_SetRightIndent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetIndents_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ float StartIndent,
    /* [in] */ float LeftIndent,
    /* [in] */ float RightIndent);


void __RPC_STUB ITextPara_SetIndents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetLineSpacing_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long LineSpacingRule,
    /* [in] */ float LineSpacing);


void __RPC_STUB ITextPara_SetLineSpacing_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetSpaceAfter_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetSpaceAfter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetSpaceAfter_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextPara_SetSpaceAfter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetSpaceBefore_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ float __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetSpaceBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetSpaceBefore_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ float Value);


void __RPC_STUB ITextPara_SetSpaceBefore_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetWidowControl_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pValue);


void __RPC_STUB ITextPara_GetWidowControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ITextPara_SetWidowControl_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long Value);


void __RPC_STUB ITextPara_SetWidowControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetTabCount_Proxy(
    ITextPara __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextPara_GetTabCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_AddTab_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ float tbPos,
    /* [in] */ long tbAlign,
    /* [in] */ long tbLeader);


void __RPC_STUB ITextPara_AddTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_ClearAllTabs_Proxy(
    ITextPara __RPC_FAR * This);


void __RPC_STUB ITextPara_ClearAllTabs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_DeleteTab_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ float tbPos);


void __RPC_STUB ITextPara_DeleteTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextPara_GetTab_Proxy(
    ITextPara __RPC_FAR * This,
    /* [in] */ long iTab,
    /* [out] */ float __RPC_FAR *ptbPos,
    /* [out] */ long __RPC_FAR *ptbAlign,
    /* [out] */ long __RPC_FAR *ptbLeader);


void __RPC_STUB ITextPara_GetTab_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextPara_INTERFACE_DEFINED__ */


#ifndef __ITextStoryRanges_INTERFACE_DEFINED__
#define __ITextStoryRanges_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITextStoryRanges
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][nonextensible][dual][version][uuid] */



EXTERN_C const IID IID_ITextStoryRanges;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("8CC497C5-A1DF-11ce-8098-00AA0047BE5D")
    ITextStoryRanges : public IDispatch
    {
    public:
        virtual /* [restricted][id] */ HRESULT STDMETHODCALLTYPE _NewEnum(
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkEnum) = 0;

        virtual /* [id] */ HRESULT STDMETHODCALLTYPE Item(
            /* [in] */ long Index,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange) = 0;

        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE GetCount(
            /* [retval][out] */ long __RPC_FAR *pCount) = 0;

    };

#else 	/* C style interface */

    typedef struct ITextStoryRangesVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ITextStoryRanges __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ITextStoryRanges __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            ITextStoryRanges __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [restricted][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *_NewEnum )(
            ITextStoryRanges __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkEnum);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Item )(
            ITextStoryRanges __RPC_FAR * This,
            /* [in] */ long Index,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )(
            ITextStoryRanges __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);

        END_INTERFACE
    } ITextStoryRangesVtbl;

    interface ITextStoryRanges
    {
        CONST_VTBL struct ITextStoryRangesVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define ITextStoryRanges_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextStoryRanges_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextStoryRanges_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextStoryRanges_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextStoryRanges_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextStoryRanges_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextStoryRanges_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextStoryRanges__NewEnum(This,ppunkEnum)	\
    (This)->lpVtbl -> _NewEnum(This,ppunkEnum)

#define ITextStoryRanges_Item(This,Index,ppRange)	\
    (This)->lpVtbl -> Item(This,Index,ppRange)

#define ITextStoryRanges_GetCount(This,pCount)	\
    (This)->lpVtbl -> GetCount(This,pCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [restricted][id] */ HRESULT STDMETHODCALLTYPE ITextStoryRanges__NewEnum_Proxy(
    ITextStoryRanges __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppunkEnum);


void __RPC_STUB ITextStoryRanges__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [id] */ HRESULT STDMETHODCALLTYPE ITextStoryRanges_Item_Proxy(
    ITextStoryRanges __RPC_FAR * This,
    /* [in] */ long Index,
    /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);


void __RPC_STUB ITextStoryRanges_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ITextStoryRanges_GetCount_Proxy(
    ITextStoryRanges __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCount);


void __RPC_STUB ITextStoryRanges_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextStoryRanges_INTERFACE_DEFINED__ */


#ifndef __ITextDocument2_INTERFACE_DEFINED__
#define __ITextDocument2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITextDocument2
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][nonextensible][dual][version][uuid] */



EXTERN_C const IID IID_ITextDocument2;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("01c25500-4268-11d1-883a-3c8b00c10000")
    ITextDocument2 : public ITextDocument
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AttachMsgFilter(
            /* [in] */ IUnknown __RPC_FAR *pFilter) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE SetEffectColor(
            /* [in] */ long Index,
            /* [in] */ COLORREF cr) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetEffectColor(
            /* [in] */ long Index,
            /* [out] */ COLORREF __RPC_FAR *pcr) = 0;

        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE GetCaretType(
            /* [retval][out] */ long __RPC_FAR *pCaretType) = 0;

        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE SetCaretType(
            /* [in] */ long CaretType) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetImmContext(
            /* [retval][out] */ long __RPC_FAR *pContext) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReleaseImmContext(
            /* [in] */ long Context) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetPreferredFont(
            /* [in] */ long cp,
            /* [in] */ long CodePage,
            /* [in] */ long Option,
            /* [out] */ BSTR __RPC_FAR *pbstr,
            /* [out] */ long __RPC_FAR *pPitchAndFamily) = 0;

        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE GetNotificationMode(
            /* [retval][out] */ long __RPC_FAR *pMode) = 0;

        virtual /* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE SetNotificationMode(
            /* [in] */ long Mode) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetClientRect(
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *pLeft,
            /* [out] */ long __RPC_FAR *pTop,
            /* [out] */ long __RPC_FAR *pRight,
            /* [out] */ long __RPC_FAR *pBottom) = 0;

        virtual /* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE GetSelectionEx(
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetWindow(
            /* [out] */ long __RPC_FAR *phWnd) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFEFlags(
            /* [out] */ long __RPC_FAR *pFlags) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE UpdateWindow( void) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE CheckTextLimit(
            long cch,
            long __RPC_FAR *pcch) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE IMEInProgress(
            long Mode) = 0;

    };

#else 	/* C style interface */

    typedef struct ITextDocument2Vtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ITextDocument2 __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ITextDocument2 __RPC_FAR * This);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )(
            ITextDocument2 __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);

        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pName);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSelection )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryCount )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStoryRanges )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ ITextStoryRanges __RPC_FAR *__RPC_FAR *ppStories);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSaved )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetSaved )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Value);

        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultTabStop )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ float __RPC_FAR *pValue);

        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetDefaultTabStop )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ float Value);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *New )(
            ITextDocument2 __RPC_FAR * This);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Save )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ VARIANT __RPC_FAR *pVar,
            /* [in] */ long Flags,
            /* [in] */ long CodePage);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Freeze )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Unfreeze )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCount);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BeginEditCollection )(
            ITextDocument2 __RPC_FAR * This);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndEditCollection )(
            ITextDocument2 __RPC_FAR * This);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Undo )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redo )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Count,
            /* [retval][out] */ long __RPC_FAR *prop);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Range )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long cp1,
            /* [in] */ long cp2,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);

        /* [id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RangeFromPoint )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long x,
            /* [in] */ long y,
            /* [retval][out] */ ITextRange __RPC_FAR *__RPC_FAR *ppRange);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachMsgFilter )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ IUnknown __RPC_FAR *pFilter);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetEffectColor )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Index,
            /* [in] */ COLORREF cr);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEffectColor )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Index,
            /* [out] */ COLORREF __RPC_FAR *pcr);

        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCaretType )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pCaretType);

        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCaretType )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long CaretType);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetImmContext )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pContext);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseImmContext )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Context);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPreferredFont )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long cp,
            /* [in] */ long CodePage,
            /* [in] */ long Option,
            /* [out] */ BSTR __RPC_FAR *pbstr,
            /* [out] */ long __RPC_FAR *pPitchAndFamily);

        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetNotificationMode )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pMode);

        /* [helpstring][propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetNotificationMode )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Mode);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetClientRect )(
            ITextDocument2 __RPC_FAR * This,
            /* [in] */ long Type,
            /* [out] */ long __RPC_FAR *pLeft,
            /* [out] */ long __RPC_FAR *pTop,
            /* [out] */ long __RPC_FAR *pRight,
            /* [out] */ long __RPC_FAR *pBottom);

        /* [helpstring][propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSelectionEx )(
            ITextDocument2 __RPC_FAR * This,
            /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetWindow )(
            ITextDocument2 __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *phWnd);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFEFlags )(
            ITextDocument2 __RPC_FAR * This,
            /* [out] */ long __RPC_FAR *pFlags);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UpdateWindow )(
            ITextDocument2 __RPC_FAR * This);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CheckTextLimit )(
            ITextDocument2 __RPC_FAR * This,
            long cch,
            long __RPC_FAR *pcch);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IMEInProgress )(
            ITextDocument2 __RPC_FAR * This,
            long Mode);

        END_INTERFACE
    } ITextDocument2Vtbl;

    interface ITextDocument2
    {
        CONST_VTBL struct ITextDocument2Vtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define ITextDocument2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextDocument2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextDocument2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextDocument2_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ITextDocument2_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ITextDocument2_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ITextDocument2_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ITextDocument2_GetName(This,pName)	\
    (This)->lpVtbl -> GetName(This,pName)

#define ITextDocument2_GetSelection(This,ppSel)	\
    (This)->lpVtbl -> GetSelection(This,ppSel)

#define ITextDocument2_GetStoryCount(This,pCount)	\
    (This)->lpVtbl -> GetStoryCount(This,pCount)

#define ITextDocument2_GetStoryRanges(This,ppStories)	\
    (This)->lpVtbl -> GetStoryRanges(This,ppStories)

#define ITextDocument2_GetSaved(This,pValue)	\
    (This)->lpVtbl -> GetSaved(This,pValue)

#define ITextDocument2_SetSaved(This,Value)	\
    (This)->lpVtbl -> SetSaved(This,Value)

#define ITextDocument2_GetDefaultTabStop(This,pValue)	\
    (This)->lpVtbl -> GetDefaultTabStop(This,pValue)

#define ITextDocument2_SetDefaultTabStop(This,Value)	\
    (This)->lpVtbl -> SetDefaultTabStop(This,Value)

#define ITextDocument2_New(This)	\
    (This)->lpVtbl -> New(This)

#define ITextDocument2_Open(This,pVar,Flags,CodePage)	\
    (This)->lpVtbl -> Open(This,pVar,Flags,CodePage)

#define ITextDocument2_Save(This,pVar,Flags,CodePage)	\
    (This)->lpVtbl -> Save(This,pVar,Flags,CodePage)

#define ITextDocument2_Freeze(This,pCount)	\
    (This)->lpVtbl -> Freeze(This,pCount)

#define ITextDocument2_Unfreeze(This,pCount)	\
    (This)->lpVtbl -> Unfreeze(This,pCount)

#define ITextDocument2_BeginEditCollection(This)	\
    (This)->lpVtbl -> BeginEditCollection(This)

#define ITextDocument2_EndEditCollection(This)	\
    (This)->lpVtbl -> EndEditCollection(This)

#define ITextDocument2_Undo(This,Count,prop)	\
    (This)->lpVtbl -> Undo(This,Count,prop)

#define ITextDocument2_Redo(This,Count,prop)	\
    (This)->lpVtbl -> Redo(This,Count,prop)

#define ITextDocument2_Range(This,cp1,cp2,ppRange)	\
    (This)->lpVtbl -> Range(This,cp1,cp2,ppRange)

#define ITextDocument2_RangeFromPoint(This,x,y,ppRange)	\
    (This)->lpVtbl -> RangeFromPoint(This,x,y,ppRange)


#define ITextDocument2_AttachMsgFilter(This,pFilter)	\
    (This)->lpVtbl -> AttachMsgFilter(This,pFilter)

#define ITextDocument2_SetEffectColor(This,Index,cr)	\
    (This)->lpVtbl -> SetEffectColor(This,Index,cr)

#define ITextDocument2_GetEffectColor(This,Index,pcr)	\
    (This)->lpVtbl -> GetEffectColor(This,Index,pcr)

#define ITextDocument2_GetCaretType(This,pCaretType)	\
    (This)->lpVtbl -> GetCaretType(This,pCaretType)

#define ITextDocument2_SetCaretType(This,CaretType)	\
    (This)->lpVtbl -> SetCaretType(This,CaretType)

#define ITextDocument2_GetImmContext(This,pContext)	\
    (This)->lpVtbl -> GetImmContext(This,pContext)

#define ITextDocument2_ReleaseImmContext(This,Context)	\
    (This)->lpVtbl -> ReleaseImmContext(This,Context)

#define ITextDocument2_GetPreferredFont(This,cp,CodePage,Option,pbstr,pPitchAndFamily)	\
    (This)->lpVtbl -> GetPreferredFont(This,cp,CodePage,Option,pbstr,pPitchAndFamily)

#define ITextDocument2_GetNotificationMode(This,pMode)	\
    (This)->lpVtbl -> GetNotificationMode(This,pMode)

#define ITextDocument2_SetNotificationMode(This,Mode)	\
    (This)->lpVtbl -> SetNotificationMode(This,Mode)

#define ITextDocument2_GetClientRect(This,Type,pLeft,pTop,pRight,pBottom)	\
    (This)->lpVtbl -> GetClientRect(This,Type,pLeft,pTop,pRight,pBottom)

#define ITextDocument2_GetSelectionEx(This,ppSel)	\
    (This)->lpVtbl -> GetSelectionEx(This,ppSel)

#define ITextDocument2_GetWindow(This,phWnd)	\
    (This)->lpVtbl -> GetWindow(This,phWnd)

#define ITextDocument2_GetFEFlags(This,pFlags)	\
    (This)->lpVtbl -> GetFEFlags(This,pFlags)

#define ITextDocument2_UpdateWindow(This)	\
    (This)->lpVtbl -> UpdateWindow(This)

#define ITextDocument2_CheckTextLimit(This,cch,pcch)	\
    (This)->lpVtbl -> CheckTextLimit(This,cch,pcch)

#define ITextDocument2_IMEInProgress(This,Mode)	\
    (This)->lpVtbl -> IMEInProgress(This,Mode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_AttachMsgFilter_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ IUnknown __RPC_FAR *pFilter);


void __RPC_STUB ITextDocument2_AttachMsgFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_SetEffectColor_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Index,
    /* [in] */ COLORREF cr);


void __RPC_STUB ITextDocument2_SetEffectColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetEffectColor_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Index,
    /* [out] */ COLORREF __RPC_FAR *pcr);


void __RPC_STUB ITextDocument2_GetEffectColor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetCaretType_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pCaretType);


void __RPC_STUB ITextDocument2_GetCaretType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_SetCaretType_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long CaretType);


void __RPC_STUB ITextDocument2_SetCaretType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetImmContext_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pContext);


void __RPC_STUB ITextDocument2_GetImmContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_ReleaseImmContext_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Context);


void __RPC_STUB ITextDocument2_ReleaseImmContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetPreferredFont_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long cp,
    /* [in] */ long CodePage,
    /* [in] */ long Option,
    /* [out] */ BSTR __RPC_FAR *pbstr,
    /* [out] */ long __RPC_FAR *pPitchAndFamily);


void __RPC_STUB ITextDocument2_GetPreferredFont_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetNotificationMode_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pMode);


void __RPC_STUB ITextDocument2_GetNotificationMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_SetNotificationMode_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Mode);


void __RPC_STUB ITextDocument2_SetNotificationMode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetClientRect_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [in] */ long Type,
    /* [out] */ long __RPC_FAR *pLeft,
    /* [out] */ long __RPC_FAR *pTop,
    /* [out] */ long __RPC_FAR *pRight,
    /* [out] */ long __RPC_FAR *pBottom);


void __RPC_STUB ITextDocument2_GetClientRect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetSelectionEx_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [retval][out] */ ITextSelection __RPC_FAR *__RPC_FAR *ppSel);


void __RPC_STUB ITextDocument2_GetSelectionEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetWindow_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *phWnd);


void __RPC_STUB ITextDocument2_GetWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_GetFEFlags_Proxy(
    ITextDocument2 __RPC_FAR * This,
    /* [out] */ long __RPC_FAR *pFlags);


void __RPC_STUB ITextDocument2_GetFEFlags_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_UpdateWindow_Proxy(
    ITextDocument2 __RPC_FAR * This);


void __RPC_STUB ITextDocument2_UpdateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_CheckTextLimit_Proxy(
    ITextDocument2 __RPC_FAR * This,
    long cch,
    long __RPC_FAR *pcch);


void __RPC_STUB ITextDocument2_CheckTextLimit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextDocument2_IMEInProgress_Proxy(
    ITextDocument2 __RPC_FAR * This,
    long Mode);


void __RPC_STUB ITextDocument2_IMEInProgress_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextDocument2_INTERFACE_DEFINED__ */


#ifndef __ITextMsgFilter_INTERFACE_DEFINED__
#define __ITextMsgFilter_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ITextMsgFilter
 * at Thu May 07 14:12:12 1998
 * using MIDL 3.01.75
 ****************************************/
/* [object][nonextensible][version][uuid] */



EXTERN_C const IID IID_ITextMsgFilter;

#if defined(__cplusplus) && !defined(CINTERFACE)

    interface DECLSPEC_UUID("a3787420-4267-11d1-883a-3c8b00c10000")
    ITextMsgFilter : public IUnknown
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AttachDocument(
            /* [in] */ HWND hwnd,
            /* [in] */ ITextDocument2 __RPC_FAR *pTextDoc) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE HandleMessage(
            /* [out][in] */ UINT __RPC_FAR *pmsg,
            /* [out][in] */ WPARAM __RPC_FAR *pwparam,
            /* [out][in] */ LPARAM __RPC_FAR *plparam,
            /* [out] */ LRESULT __RPC_FAR *plres) = 0;

        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE AttachMsgFilter(
            /* [in] */ ITextMsgFilter __RPC_FAR *pMsgFilter) = 0;

    };

#else 	/* C style interface */

    typedef struct ITextMsgFilterVtbl
    {
        BEGIN_INTERFACE

        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )(
            ITextMsgFilter __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )(
            ITextMsgFilter __RPC_FAR * This);

        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )(
            ITextMsgFilter __RPC_FAR * This);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachDocument )(
            ITextMsgFilter __RPC_FAR * This,
            /* [in] */ HWND hwnd,
            /* [in] */ ITextDocument2 __RPC_FAR *pTextDoc);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HandleMessage )(
            ITextMsgFilter __RPC_FAR * This,
            /* [out][in] */ UINT __RPC_FAR *pmsg,
            /* [out][in] */ WPARAM __RPC_FAR *pwparam,
            /* [out][in] */ LPARAM __RPC_FAR *plparam,
            /* [out] */ LRESULT __RPC_FAR *plres);

        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AttachMsgFilter )(
            ITextMsgFilter __RPC_FAR * This,
            /* [in] */ ITextMsgFilter __RPC_FAR *pMsgFilter);

        END_INTERFACE
    } ITextMsgFilterVtbl;

    interface ITextMsgFilter
    {
        CONST_VTBL struct ITextMsgFilterVtbl __RPC_FAR *lpVtbl;
    };



#ifdef COBJMACROS


#define ITextMsgFilter_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ITextMsgFilter_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ITextMsgFilter_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ITextMsgFilter_AttachDocument(This,hwnd,pTextDoc)	\
    (This)->lpVtbl -> AttachDocument(This,hwnd,pTextDoc)

#define ITextMsgFilter_HandleMessage(This,pmsg,pwparam,plparam,plres)	\
    (This)->lpVtbl -> HandleMessage(This,pmsg,pwparam,plparam,plres)

#define ITextMsgFilter_AttachMsgFilter(This,pMsgFilter)	\
    (This)->lpVtbl -> AttachMsgFilter(This,pMsgFilter)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextMsgFilter_AttachDocument_Proxy(
    ITextMsgFilter __RPC_FAR * This,
    /* [in] */ HWND hwnd,
    /* [in] */ ITextDocument2 __RPC_FAR *pTextDoc);


void __RPC_STUB ITextMsgFilter_AttachDocument_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextMsgFilter_HandleMessage_Proxy(
    ITextMsgFilter __RPC_FAR * This,
    /* [out][in] */ UINT __RPC_FAR *pmsg,
    /* [out][in] */ WPARAM __RPC_FAR *pwparam,
    /* [out][in] */ LPARAM __RPC_FAR *plparam,
    /* [out] */ LRESULT __RPC_FAR *plres);


void __RPC_STUB ITextMsgFilter_HandleMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ITextMsgFilter_AttachMsgFilter_Proxy(
    ITextMsgFilter __RPC_FAR * This,
    /* [in] */ ITextMsgFilter __RPC_FAR *pMsgFilter);


void __RPC_STUB ITextMsgFilter_AttachMsgFilter_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ITextMsgFilter_INTERFACE_DEFINED__ */

#endif /* __tom_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * );
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * );

unsigned long             __RPC_USER  HWND_UserSize(     unsigned long __RPC_FAR *, unsigned long            , HWND __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  HWND_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  HWND_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, HWND __RPC_FAR * );
void                      __RPC_USER  HWND_UserFree(     unsigned long __RPC_FAR *, HWND __RPC_FAR * );

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * );
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * );
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * );

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\enduser\speech\sapi\cpl\ttsdlg.cpp ===
#include "stdafx.h"
#include "resource.h"
#include <sapi.h>
#include <string.h>
#include "TTSDlg.h"
#include "audiodlg.h"
#include <spddkhlp.h>
#include "helpresource.h"
#include "srdlg.h"
#include "richedit.h"
#include <SPCollec.h>
#include "SAPIINT.h"
#include "SpATL.h"
#include "SpAutoHandle.h"
#include "SpAutoMutex.h"
#include "SpAutoEvent.h"
#include "spvoice.h"
#include <richedit.h>
#include <richole.h>
#include "tom.h"

static DWORD aKeywordIds[] = {
   // Control ID           // Help Context ID
   IDC_COMBO_VOICES,        IDH_LIST_TTS,
   IDC_TTS_ADV,             IDH_TTS_ADV,
   IDC_OUTPUT_SETTINGS,     IDH_OUTPUT_SETTINGS,
   IDC_SLIDER_SPEED,        IDH_SLIDER_SPEED,
   IDC_EDIT_SPEAK,          IDH_EDIT_SPEAK,
   IDC_SPEAK,               IDH_SPEAK,
   IDC_TTS_ICON,			IDH_NOHELP,
	IDC_DIRECTIONS,			IDH_NOHELP,
	IDC_TTS_CAP,			IDH_NOHELP,
	IDC_SLOW,				IDH_NOHELP,				
	IDC_NORMAL,				IDH_NOHELP,
	IDC_FAST,				IDH_NOHELP,
	IDC_GROUP_VOICESPEED,	IDH_NOHELP,
	IDC_GROUP_PREVIEWVOICE,	IDH_NOHELP,
   0,                       0
};

// Address of the TrackBar's WNDPROC
WNDPROC g_TrackBarWindowProc; 

// Our own internal TrackBar WNDPROC used to intercept and process VK_UP and VK_DOWN messages
LRESULT CALLBACK MyTrackBarWindowProc( HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam );

/*****************************************************************************
* TTSDlgProc *
*------------*
*   Description:
*       DLGPROC for the TTS
****************************************************************** MIKEAR ***/
INT_PTR CALLBACK TTSDlgProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    SPDBG_FUNC( "TTSDlgProc" );

	USES_CONVERSION;

    switch (uMsg) 
    {
        case WM_INITDIALOG:
        {
            g_pTTSDlg->OnInitDialog(hWnd);
            break;
        }

        case WM_DESTROY:
        {
            g_pTTSDlg->OnDestroy();
            break;
        }
       
		// Handle the context sensitive help
		case WM_CONTEXTMENU:
		{
			WinHelp((HWND) wParam, CPL_HELPFILE, HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR) aKeywordIds);
			break;
		}

		case WM_HELP:
		{
			WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, CPL_HELPFILE, HELP_WM_HELP,(DWORD_PTR)(LPSTR) aKeywordIds);
			break;
		}

        case WM_HSCROLL:
        {
            g_pTTSDlg->ChangeSpeed();

            break;
        }

        case WM_NOTIFY:
            switch (((NMHDR*)lParam)->code)
            {
                case PSN_APPLY:
                {
                    g_pTTSDlg->OnApply();
                    break;
                }
                
                case PSN_KILLACTIVE:
                {
                    // if the voice is speaking, stop it before switching tabs
                    if (g_pTTSDlg->m_bIsSpeaking) {
                        g_pTTSDlg->Speak();
                    }

                    break;
                }

                case PSN_QUERYCANCEL:  // user clicks the Cancel button
                {
                    if ( g_pSRDlg )
                    {
                        g_pSRDlg->OnCancel();
                    }
					break;
                }
            }
            break;

        case WM_COMMAND:
            switch ( LOWORD(wParam) )
            { 
                case IDC_COMBO_VOICES:
                {
                    if ( CBN_SELCHANGE == HIWORD(wParam) )
                    {
                        HRESULT hr = g_pTTSDlg->DefaultVoiceChange(false);
                        if ( SUCCEEDED( hr ) )
                        {
                            g_pTTSDlg->Speak();
                        }
                    }
                    break;
                }
                case IDC_OUTPUT_SETTINGS:
                {
					// if it's speaking make it stop
					g_pTTSDlg->StopSpeak();

                    ::SetFocus(GetDlgItem(g_pTTSDlg->m_hDlg, IDC_OUTPUT_SETTINGS));

                    // The m_pAudioDlg will be non-NULL only if the audio dialog
                    // has been previously brough up.
                    // Otherwise, we need a newly-initialized one
                    if ( !g_pTTSDlg->m_pAudioDlg )
                    {
                        g_pTTSDlg->m_pAudioDlg = new CAudioDlg(eOUTPUT );
                    }
                    
                    if (g_pTTSDlg->m_pAudioDlg != NULL)
                    {
                        ::DialogBoxParam( _Module.GetResourceInstance(), 
                                    MAKEINTRESOURCE( IDD_AUDIO_DEFAULT ),
                                    hWnd, 
                                    AudioDlgProc,
                                    (LPARAM) g_pTTSDlg->m_pAudioDlg );

                        if ( g_pTTSDlg->m_pAudioDlg->IsAudioDeviceChangedSinceLastTime() )
                        {
                            // Warn the user that he needs to apply the changes
                            WCHAR szWarning[MAX_LOADSTRING];
                            szWarning[0] = 0;
                            LoadString( _Module.GetResourceInstance(), IDS_AUDIOOUT_CHANGE_WARNING, szWarning, MAX_LOADSTRING);
                            MessageBox( g_pTTSDlg->GetHDlg(), szWarning, g_pTTSDlg->m_szCaption, MB_ICONWARNING | g_dwIsRTLLayout );
                        }
                    }

                    g_pTTSDlg->KickCPLUI();

                    break;
                }

				case IDC_EDIT_SPEAK:
				{
                    if (HIWORD(wParam) == EN_CHANGE)  // user is changing text
					{
						g_pTTSDlg->SetEditModified(true);
					}

                    break;
                }

                case IDC_SPEAK:
                {
                    g_pTTSDlg->Speak();
                    break;
                }

				case IDC_TTS_ADV:
				{
                    // convert the title of the window to wide chars
                    CSpDynamicString dstrTitle;
                    WCHAR szTitle[256];
                    szTitle[0] = '\0';
                    LoadString(_Module.GetResourceInstance(), IDS_ENGINE_SETTINGS, szTitle, sp_countof(szTitle));
                    dstrTitle = szTitle;
					HRESULT hr = g_pTTSDlg->m_cpCurVoiceToken->DisplayUI(
                        hWnd, dstrTitle, SPDUI_EngineProperties, NULL, 0, NULL );
                    if ( FAILED( hr ) )
                    {
                        WCHAR szError[ MAX_LOADSTRING ];
                        ::LoadString( _Module.GetResourceInstance(), IDS_TTSUI_ERROR, szError, sp_countof( szError ) );
                        ::MessageBox( hWnd, szError, g_pTTSDlg->m_szCaption, MB_ICONEXCLAMATION | g_dwIsRTLLayout );
                        ::EnableWindow( ::GetDlgItem( hWnd, IDC_TTS_ADV ), FALSE );
                    }
					break;
				}
            }
            break;
    }

    return FALSE;
} /* TTSDlgProc */

/*****************************************************************************
* MyTrackBarWindowProc *
*------------*
*   Description:
*       This is our own privately sub-classed WNDPROC for the rate TrackBar. We 
*       tell the TTS dialog to use this one so we can pre-process the VK_UP and
*       VK_DOWN messages before the TrackBar's WNDPROC "incorrectly" handles them
*       on it's own. All other messages we just pass through to the TrackBar's 
*       WNDPROC.
****************************************************************** Leonro ***/
LRESULT CALLBACK MyTrackBarWindowProc( 
  HWND hwnd,      // handle to window
  UINT uMsg,      // message identifier
  WPARAM wParam,  // first message parameter
  LPARAM lParam   // second message parameter
)
{
    switch( uMsg )
    {
    case WM_KEYDOWN:
    case WM_KEYUP:
        if( wParam == VK_UP )
        {
            wParam = VK_RIGHT;
        }
        else if( wParam == VK_DOWN )
        {
            wParam = VK_LEFT;
        }
        break;  
    }

    return CallWindowProc( g_TrackBarWindowProc, hwnd, uMsg, wParam, lParam );
}

/*****************************************************************************
* CTTSDlg::SetEditModified( bool fModify ) *
*-----------------------*
*   Description:
*       Access method for m_fTextModified
****************************************************************** BRENTMID ***/
void CTTSDlg::SetEditModified( bool fModify )
{
	m_fTextModified = fModify;
}

/*****************************************************************************
* CTTSDlg::OnInitDialog *
*-----------------------*
*   Description:
*       Dialog Initialization
****************************************************************** BECKYW ***/
void CTTSDlg::OnInitDialog(HWND hWnd)
{
    USES_CONVERSION;
    SPDBG_FUNC( "CTTSDlg::OnInitDialog" );
    SPDBG_ASSERT(IsWindow(hWnd));
    m_hDlg = hWnd;

    // Put text on the speak button
    ChangeSpeakButton();

    // This is to be the caption for error messages
    m_szCaption[0] = 0;
    ::LoadString( _Module.GetResourceInstance(), IDS_CAPTION, m_szCaption, sp_countof( m_szCaption ) );

    // Initialize the TTS personality list
    InitTTSList( hWnd );

    // Set the range on the slider
    HWND hSlider = ::GetDlgItem( hWnd, IDC_SLIDER_SPEED );
    ::SendMessage( hSlider, TBM_SETRANGE, true, MAKELONG( VOICE_MIN_SPEED, VOICE_MAX_SPEED ) );

    // Retrieve address of the TrackBar's WNDPROC so we can sub-class it and intercept
    // and process the VK_UP and VK_DOWN messages before it handle's them on it's
    // own "incorrectly"
    g_TrackBarWindowProc = (WNDPROC)GetWindowLongPtr( hSlider, GWLP_WNDPROC );

    // Set the WNDPROC of the TrackBar to MyTrackBarWindowProc
    SetWindowLongPtr( hSlider, GWLP_WNDPROC, (LONG_PTR)MyTrackBarWindowProc );

    // Limit the text in the preview pane
    ::SendDlgItemMessage( hWnd, IDC_EDIT_SPEAK, EM_LIMITTEXT, MAX_EDIT_TEXT - 1, 0 );

    // Find the original default token
    SpGetDefaultTokenFromCategoryId( SPCAT_VOICES, &m_cpOriginalDefaultVoiceToken );

    // Set the appropriate voice
    DefaultVoiceChange(true);

} /* CTTSDlg::OnInitDialog */

/*****************************************************************************
* CTTSDlg::InitTTSList *
*----------------------*
*   Description:
*       Initializes the list control for the TTS dialog box.
**********************