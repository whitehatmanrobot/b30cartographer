andles[2];

    aHandles[0] = pResyncPerfData->m_hTerminate;
    HANDLE  hTimer = pResyncPerfData->m_hWaitableTimer;

    CRITICAL_SECTION*   pcs = pResyncPerfData->m_pcs;

	BOOL	bFullDredge = pResyncPerfData->m_fFullDredge;

    delete pResyncPerfData;
    pResyncPerfData = NULL;

    // Reset the spawned flag
    gfSpawnedResync = FALSE;

    // Okay.  Signal this event so the starting thread can get us going
    SetEvent( ghResyncThreadEvent );

    // Now, if ghChildProcessHandle is not NULL, then we've obviously kicked off a
    // dredge before.  See where the last one is at.  If it's not done, wait for
    // it to finish.  We will always check this at the start of this chunk of code,
    // since we are really the only location in which the process handle can ever get set,
    // and there really shouldn't be more than one thread ever, waiting to start another
    // dredge

    if ( NULL != ghChildProcessHandle )
    {

        aHandles[1] = ghChildProcessHandle;

        DWORD   dwWait = WaitForMultipleObjects( 2, aHandles, FALSE, INFINITE );

        // If abort was signalled, leave!
        if ( dwWait == WAIT_OBJECT_0 )
        {
            return 0;
        }

        // If the process handle was signalled, close the process, reset the timer
        // and we'll get ready to start the next dredge!
        if ( dwWait == WAIT_OBJECT_0 + 1 )
        {
            EnterCriticalSection( pcs );

            CloseHandle( ghChildProcessHandle );
            ghChildProcessHandle = NULL;
            ResetResyncTimer( hTimer );

            LeaveCriticalSection( pcs );

        }

    }
    else
    {
        // If the Child Process Handle is NULL, we've never dredged before, so we'll
        // just reset the timer
        ResetResyncTimer( hTimer );
    }

    BOOL    fHoldOff = TRUE;

    // Reset this handle to the timer now
    aHandles[1] = hTimer;

    while ( fHoldOff )
    {
        // Wait for either the terminate event or the timer
        DWORD   dwWait = WaitForMultipleObjects( 2, aHandles, FALSE, INFINITE );

        // This means the terminate was signaled
        if ( dwWait == WAIT_OBJECT_0 ) 
        {
            break;        
        } else
        // This means the timer was signaled
        if ( dwWait == WAIT_OBJECT_0 + 1 )
        {          
            EnterCriticalSection( pcs );

            // Finally, if the current thread id != gdwResyncThreadId, this means another
            // resync perf thread got kicked off, inside of the critical section,
            // so we should just let it wait on the timer.  We don't really need to do
            // this, since the main thread will wait on this thread to complete before
            // it actually kicks off another thread.

            if ( GetCurrentThreadId() != gdwResyncThreadId )
            {
                // Used the following int 3 for debugging
                // _asm int 3;
                LeaveCriticalSection( pcs );
                break;
            }

            // Once we get through the critical section, check that the
            // timer is still signalled.  If it is not, this means that somebody
            // got control of the critical section and reset the timer

            if ( WaitForSingleObject( aHandles[1], 0 ) == WAIT_OBJECT_0 )
            {

                // Last quick sanity check on the abort event
                if ( WaitForSingleObject( aHandles[0], 0 ) == WAIT_OBJECT_0 )
                {
                    // Outa here!
                    LeaveCriticalSection( pcs );
                    break;
                }

                // Okay, we really will try to create the process now.
                gfSpawnedResync = TRUE;

                // We signalled to start the process, so make it so.
                PROCESS_INFORMATION pi;
                STARTUPINFO si;
                memset(&si, 0, sizeof(si));
                si.cb = sizeof(si);

                TCHAR * pBuff = (TCHAR *)_alloca(sizeof(_T("WMIADAP.EXE /F")));
                lstrcpy(pBuff,bFullDredge?_T("WMIADAP.EXE /F"):_T("WMIADAP.EXE"));

                BOOL bRes = CreateProcess(NULL, 
										  pBuff, 
										  NULL, 
										  NULL, 
										  FALSE, 
										  CREATE_NO_WINDOW,
										  NULL, 
										  NULL,  
										  &si, 
										  &pi);
                if(bRes)
                {
                    // Who cares about this one?
                    CloseHandle(pi.hThread);

                    // Clean up our old values
                    if ( NULL != ghChildProcessHandle )
                    {
                        CloseHandle( ghChildProcessHandle );
                        ghChildProcessHandle = NULL;
                    }

                    ghChildProcessHandle = pi.hProcess;
                }

                // We're done
                fHoldOff = FALSE;

            }   // Check that we're still signalled, or we will just have to go back to waiting

            LeaveCriticalSection( pcs );

        } 

    }   // WHILE fHoldOff

    return 0;
}

// For the waitable timer
//#define _SECOND 10000000

// Create all the things we need
BOOL InitResync( void )
{
    if ( gfResyncInit )
        return gfResyncInit;

    if ( ( NULL == gpCreateWaitableTimerW ) && ( NULL == gpSetWaitableTimerW ) )
    {
        ghKernel32 = LoadLibrary( __TEXT("Kernel32.dll") );
        if ( NULL == ghKernel32 )
        {
            return FALSE;
        }
        
        gpCreateWaitableTimerW = ( PCREATEWAITABLETIMERW ) GetProcAddress( ghKernel32, "CreateWaitableTimerW" );
        gpSetWaitableTimerW = ( PSETWAITABLETIMER ) GetProcAddress( ghKernel32, "SetWaitableTimer" );

        if ( ( NULL == gpCreateWaitableTimerW ) || ( NULL == gpSetWaitableTimerW ) )
        {
            FreeLibrary( ghKernel32 );
            ghKernel32 = NULL;
            return FALSE;
        }
    }
        
    if ( NULL == ghWaitableTimer )
    {
        ghWaitableTimer = gpCreateWaitableTimerW( NULL, TRUE, NULL );

        // We gotta big problem
        if ( NULL == ghWaitableTimer )
        {
            // Log an error here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a waitable timer for Resyncperf.\n" ) );
        }

    }

    if ( NULL == ghResyncThreadEvent )
    {
        ghResyncThreadEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

        // We gotta big problem
        if ( NULL == ghResyncThreadEvent )
        {
            // Log an event here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a ResyncThreadEvent event for Resyncperf.\n" ) );
        }

    }

    // This critical section won't be freed or deleted because of
    // potential timing issues.  But since it's only one, I think
    // we can live with it.
    if ( NULL == g_pResyncCs )
    {
        g_pResyncCs = new CRITICAL_SECTION;

        // We gotta big problem
        if ( NULL == g_pResyncCs )
        {
            // Log an event here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a ResyncCs critical section for Resyncperf.\n" ) );
        }
        else
        {
            InitializeCriticalSection( g_pResyncCs );
        }

    }

    gfResyncInit = (    NULL    !=  ghWaitableTimer &&
                        NULL    !=  g_pResyncCs     &&
                        NULL    != ghResyncThreadEvent  );

    // Read the initialization information

    CNTRegistry reg;
    
    if ( CNTRegistry::no_error == reg.Open( HKEY_LOCAL_MACHINE, L"Software\\Microsoft\\WBEM\\CIMOM" ) )
    {
        long lError = reg.GetDWORD( L"ADAPDelay", &gdwADAPDelaySec );

        if ( CNTRegistry::no_error == lError )
        {
            //This is what we want
        }
        else if ( CNTRegistry::not_found == lError )
        {
            // Not set, so add it
            reg.SetDWORD( L"ADAPDelay", WMIADAP_DEFAULT_DELAY );
            gdwADAPDelaySec = WMIADAP_DEFAULT_DELAY;
        }
        else
        {
            // Error
            ERRORTRACE( ( LOG_WINMGMT, "ResyncPerf experienced an error while attempting to read the WMIADAPDelay value in the CIMOM subkey.  Continuing using a default value.\n" ) );
            gdwADAPDelaySec = WMIADAP_DEFAULT_DELAY;
        }
    }
    else
    {
        // Error
        ERRORTRACE( ( LOG_WINMGMT, "ResyncPerf could not open the CIMOM subkey to read initialization data. Continuing using a default value.\n" ) );
        gdwADAPDelaySec = WMIADAP_DEFAULT_DELAY;
    }

    return gfResyncInit;
}

// PLEASE NOTE - THIS FUNCTION IS NOT REENTRANT!  PLEASE DO NOT CALL IT ON MULTIPLE THREADS!
void ResyncPerf( HANDLE hTerminate )
{
    // Make sure this is Win2000 or greater
    if ( !IsW2KOrMore() )
    {
        return;
    }

    // Assume that we should check the timer
    BOOL    fFirstTime = !gfResyncInit;

    if ( !InitResync() )
        return;

    // Auto FreeLibrary for the gpKernel32 Library handle
    CAutoFreeLib    aflKernel32;
    
    EnterCriticalSection( g_pResyncCs );

    // Now, if this or the first time, or the spawned resyncflag is set to TRUE, then we need
    // to kick off another thread.  By checking gfSpawnedResync in a critical section, since
    // it only gets set in the same critical section, we ensure that we will resignal as needed
    // as well as only kick off a thread when we really need to.

    BOOL    fSpawnThread = ( fFirstTime || gfSpawnedResync );

    if ( !fSpawnThread )
    {
        // We are here because we don't appear to have spawned a resync.
        // This is either because we are servicing many lodctr requests
        // within our time delay, or a dredger was started and
        // a previous request request to dredge is waiting for
        // the process to complete.  If the child process handle
        // is not NULL, there is no real need to reset the
        // waitable timer

        if ( NULL == ghChildProcessHandle && ghResyncThreadHandle )
        {
            // Reset the timer here
            ResetResyncTimer( ghWaitableTimer );
        }

    }

    LeaveCriticalSection( g_pResyncCs );


    if ( fSpawnThread )
    {
        HANDLE  ahHandle[2];

        if ( NULL != ghResyncThreadHandle )
        {
            ahHandle[0] = hTerminate;
            ahHandle[1] = ghResyncThreadHandle;

            // Wait for ten seconds on this handle.  If it is not signalled, something is
            // direly wrong.  We're probably not going to be able to kick off a dredge
            // so put some info to this effect in the error log.  The only time we should
            // have contention here, is when a lodctr event is signalled, just as the timer
            // becomes signalled.  The resync thread will wake up and start another dredge
            // this thread will wait for the other thread to complete before continuing.
            // We will kick off another resync thread, which will start another dredge,
            // but it will wait for the first dredge to continue.  This is a worst case
            // scenario, and arguably kicking off two dredges isn't that bad of a bailout

            DWORD   dwRet = WaitForMultipleObjects( 2, ahHandle, FALSE, 10000 );

            // We're done
            if ( dwRet == WAIT_OBJECT_0 )
            {
                return;
            }

            if ( dwRet != WAIT_OBJECT_0 + 1 )
            {
                ERRORTRACE( ( LOG_WINMGMT, "The wait for a termination event or ResyncThreadHandle timed out in Resyncperf.\n" ) );
                return;
            }

            CloseHandle( ghResyncThreadHandle );
            ghResyncThreadHandle = NULL;
        }

        EnterCriticalSection( g_pResyncCs );

        DWORD   dwThreadId = 0;

        RESYNCPERFDATASTRUCT*   pResyncData = new RESYNCPERFDATASTRUCT;

        // Boy are we low on memory!
        if ( NULL == pResyncData )
        {
            LeaveCriticalSection( g_pResyncCs );

            // Log an event here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a RESYNCPERFDATASTRUCT in Resyncperf.\n" ) );
            
            return;
        }

        // Store the data for the resync operation
        pResyncData->m_hTerminate = hTerminate;
        pResyncData->m_hWaitableTimer = ghWaitableTimer;
        pResyncData->m_pcs = g_pResyncCs;
		pResyncData->m_fFullDredge = fFirstTime;

        ghResyncThreadHandle = (HANDLE) _beginthreadex( NULL, 0, ResyncPerfThread, (void*) pResyncData,
                                                        0, (unsigned int *) &gdwResyncThreadId );

        LeaveCriticalSection( g_pResyncCs );


        if ( NULL == ghResyncThreadHandle )
        {
            LeaveCriticalSection( g_pResyncCs );

            // Log an event here
            ERRORTRACE( ( LOG_WINMGMT, "Could not create a ResyncPerfThread thread in Resyncperf.\n" ) );

            return;
        }
        else
        {
            // Wait for the resync thread event to be signalled by the thread we just started.
            // If it doesn't signal in 10 seconds, something is VERY wrong
            DWORD   dwWait = WaitForSingleObject( ghResyncThreadEvent, INFINITE );

            if ( dwWait != WAIT_OBJECT_0 )
            {
                // Log an event
                ERRORTRACE( ( LOG_WINMGMT, "The ResyncPerfThread thread never signaled the ghResyncThreadEvent in Resyncperf.\n" ) );

                return;
            }
        }

    }   // IF fSpawnThread

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\sched.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SCHED.H

Abstract:

	Declares the CSched class which is a crude schedualer.

History:

--*/

#ifndef _sched_H_
#define _sched_H_

enum JobType {FirstCoreShutdown = 0, FinalCoreShutdown, CoreMaintLoad, FlushDB, PeriodicBackup, PossibleStartCore, EOL};

class CSched
{
private:
    DWORD m_dwDue[EOL];
public:
    CSched();
    void SetWorkItem(JobType jt, DWORD dwMsFromNow);
    DWORD GetWaitPeriod();
    bool IsWorkItemDue(JobType jt);
    void ClearWorkItem(JobType jt);
    void StartCoreIfEssNeeded();

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\strings.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    STRINGS.H

Abstract:

	resource IDs.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _provstub_H_
#define _provstub_H_

#define ID1		101
#define ID2		102
#define ID3		103
#define ID4		104
#define ID5		105
#define ID6		106
#define ID7		107
#define ID8		108
#define ID9		109
#define ID10	110

#define ID_ERROR_SHORT		200
#define ID_ERROR_LONG		201
#define ID_BACKUP_TITLE		202
#define ID_RESTORE_TITLE	203

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server2\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
#define COREPOL_HEADERFILE_IS_INCLUDED

#define COREPROX_POLARITY __declspec( dllimport )

#define COREPOL_HEADERFILE_IS_INCLUDED
#define POLARITY_HEADERFILE_IS_INCLUDED
#define POLARITY __declspec( dllimport )
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\servutil.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SERVUTIL.CPP

Abstract:

	Defines various service utilities.

History:

  a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include "servutil.h"
//***************************************************************************
//
//  BOOL InstallService
//
//  DESCRIPTION:
//
//  Installs a service
//
//  PARAMETERS:
//
//  pServiceName        short service name
//  pDisplayName        name displayed to the user
//  pBinary             full path to the binary
//
//  RETURN VALUE:
//
//  TRUE if it worked
//
//***************************************************************************

BOOL InstallService(
                        IN LPCTSTR pServiceName,
                        IN LPCTSTR pDisplayName,
                        IN LPCTSTR pBinary)
{
    SC_HANDLE   schService = NULL;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = CreateService(
            schSCManager,               // SCManager database
            pServiceName,        // name of service
            pDisplayName, // name to display
            SERVICE_ALL_ACCESS,         // desired access
            SERVICE_WIN32_OWN_PROCESS,  // service type
            SERVICE_DEMAND_START,       // start type
            SERVICE_ERROR_NORMAL,       // error control type
            pBinary,                     // service's binary
            NULL,                       // no load ordering group
            NULL,                       // no tag identifier
            NULL,                       // dependencies
            NULL,                       // LocalSystem account
            NULL);                      // no password

        if ( schService )
        {
            CloseServiceHandle(schService);
        }

        CloseServiceHandle(schSCManager);
    }
    return schService != NULL;
}

//***************************************************************************
//
//  BOOL RemoveService
//
//  DESCRIPTION:
//
//  Stops and then removes the service.  
//
//  PARAMETERS:
//
//  pServiceName        Short service name
//
//  RETURN VALUE:
//
//  TRUE if it worked
//
//***************************************************************************

BOOL RemoveService(
                        IN LPCTSTR pServiceName)
{
    SC_HANDLE   schService;
    BOOL bRet = FALSE;
    SC_HANDLE   schSCManager;
    StopService(pServiceName, 15);

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, pServiceName, SERVICE_ALL_ACCESS);

        if (schService)
        {
            bRet =  DeleteService(schService);
            CloseServiceHandle(schService);
        }

        CloseServiceHandle(schSCManager);
    }
    return bRet;
}

//***************************************************************************
//
//  BOOL StopService
//
//  DESCRIPTION:
//
//  Stops and then removes the service. 
//
//  PARAMETERS:
//
//  pServiceName        short service name
//  dwMaxWait           max time in seconds to wait
//
//  RETURN VALUE:
//
//  TRUE if it worked
//
//***************************************************************************

BOOL StopService(
                        IN LPCTSTR pServiceName,
                        IN DWORD dwMaxWait)
{
    BOOL bRet = FALSE;
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;
    DWORD dwCnt;
    SERVICE_STATUS          ssStatus;       // current status of the service

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, pServiceName, SERVICE_ALL_ACCESS);

        if (schService)
        {
            // try to stop the service
            if ( bRet = ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) )
            {
                for(dwCnt=0; dwCnt < dwMaxWait &&
                    QueryServiceStatus( schService, &ssStatus ); dwCnt++)
                {
                    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
                        Sleep( 1000 );
                    else
                        break;
                }

            }

            CloseServiceHandle(schService);
        }

        CloseServiceHandle(schSCManager);
    }
    return bRet;
}

//***************************************************************************
//
//  BOOL StartService
//
//  DESCRIPTION:
//
//  Starts the service runnig
//
//  PARAMETERS:
//
//  pServiceName        short service name
//  dwMaxWait           max time in seconds to wait
//
//  RETURN VALUE:
//
//  TRUE if it worked
//
//***************************************************************************

BOOL StartService(
                        IN LPCTSTR pServiceName,
                        IN DWORD dwMaxWait)
{
    DWORD dwCnt;
    BOOL bRet = FALSE;
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;
    SERVICE_STATUS          ssStatus;       // current status of the service

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, pServiceName, SERVICE_ALL_ACCESS);

        if (schService)
        {
            // try to stop the service
            if ( bRet = StartService( schService, 0, NULL ) )
            {
                for(dwCnt = 0; dwCnt < dwMaxWait &&
                    QueryServiceStatus( schService, &ssStatus ); dwCnt++)
                {
                    if ( ssStatus.dwCurrentState != SERVICE_RUNNING )
                        Sleep( 1000 );
                    else
                        break;
                }

            }

            CloseServiceHandle(schService);
        }

        CloseServiceHandle(schSCManager);
    }
    return bRet;
}


//***************************************************************************
//
//  BOOL SetDependency
//
//  DESCRIPTION:
//
//  Sets a service's dependency list.
//
//  PARAMETERS:
//
//  pServiceName        short service name
//  pDependency         dependency list
//
//  RETURN VALUE:
//
//  TRUE if it worked
//
//***************************************************************************

BOOL SetDependency(
                        IN LPCTSTR pServiceName,
                        IN LPCTSTR pDependency)
{
    BOOL bRet = FALSE;
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, pServiceName, SERVICE_ALL_ACCESS);

        if (schService)
        {
            bRet = ChangeServiceConfig(
                schService,
                    SERVICE_NO_CHANGE,
                    SERVICE_NO_CHANGE,
                    SERVICE_NO_CHANGE,
                    NULL,
                    NULL,
                    NULL,
                    pDependency,
                    NULL,
                    NULL,
                    NULL);
            CloseServiceHandle(schService);
        }

        CloseServiceHandle(schSCManager);
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server2\servutil.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SERVUTIL.H

Abstract:

	Declares a set of general purpose service utilitils.

History:

  a-davj  04-Mar-97   Created.

--*/

#ifndef _SERVUTIL_H_
#define _SERVUTIL_H_

BOOL StopService(LPCTSTR pServiceName, DWORD dwMaxWait=0);
BOOL StartService(LPCTSTR pServiceName, DWORD dwMaxWait=0);
BOOL InstallService(LPCTSTR pServiceName,LPCTSTR pDisplayName, LPCTSTR pBinary);
BOOL RemoveService(LPCTSTR pServiceName);
BOOL SetDependency(LPCTSTR pServiceName, LPCTSTR pDependency);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\utils.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    UTILS.CPP

Abstract:

    Purpose: Defines various utilities.

History:

    a-davj    14-Aug-96   Created.

--*/

#include "precomp.h"
#include "genutils.h"

extern bool bServer;


//***************************************************************************
//
//  LPWSTR A2WHelper
//
//  DESCRIPTION:
//
//  used by the A2W and W2A routines which serve to emulate the 
//  MFC character conversion macros.
//
//  PARAMETERS:
//
//  lpw                 pointer to wide character string
//  lpa                 pointer to narrow string
//  nChars              max size of wide character array
//
//  RETURN VALUE:
//
//  poinnter to wide character array, or NULL if bogus arguments
//
//***************************************************************************

LPWSTR A2WHelper(
                        OUT LPWSTR lpw,
                        IN LPCSTR lpa,
                        IN int nChars)
{
    if (lpa == NULL || lpw == NULL)
        return NULL;
    mbstowcs(lpw,lpa,nChars);
    return lpw;
}

//***************************************************************************
//
//  LPSTR W2AHelper
//
//  DESCRIPTION:
//
//  used by the A2W and W2A routines which serve to emulate the 
//  MFC character conversion macros.
//
//  PARAMETERS:
//
//  lpa                 mbs string
//  lpw                 wide character string
//  nChars              max conversion size
//
//  RETURN VALUE:
//
//  pointer to narrow string, or NULL if bogus arguments.
//
//***************************************************************************

LPSTR W2AHelper(
                        IN LPSTR lpa,
                        IN LPCWSTR lpw,
                        IN int nChars)
{
    if (lpw == NULL || lpa == NULL)
        return NULL;
    wcstombs(lpa,lpw,nChars);
    return lpa;
}


//***************************************************************************
//
//  BOOL bVerifyPointer
//
//  DESCRIPTION:
//
//  Simple utility for verifying that an ole object pointer is valid.
//  THIS INCREASES THE OBJECT'S REFERENCE COUNT.
//
//  PARAMETERS:
//
//  pTest               Object to test
//
//  RETURN VALUE:
//
//  TRUE if object is OK.
//***************************************************************************

BOOL bVerifyPointer(
                        IN PVOID pTest)
{
    PVOID pTemp = NULL;
    IUnknown * pIUnknown = (IUnknown *)pTest;
    SCODE sc;
    if(pTest == NULL)
        return FALSE;

    // Do a QI to verify that the object is OK and to bump the
    // reference count if it is.

    sc = pIUnknown->QueryInterface(IID_IUnknown, &pTemp);
    if(sc != S_OK || pTemp == NULL)
    {
        delete pTest;
        return FALSE;
    }
    return TRUE;
}


void MyCoUninitialize()
{
    if(IsNT() && bServer)
        CoUninitialize();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\winmgmt.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WINMGMT.H

Abstract:

	Declares the PROG_RESOURCES stucture, the MyService class and a few
	utility type functions.

History:

--*/

#ifndef _WinMgmt_H_
#define _WinMgmt_H_

#include <flexarry.h>
typedef LPVOID * PPVOID;

//***************************************************************************
//
// STRUCT NAME:
//
// PROG_RESOURCES
//
// DESCRIPTION:
//
// Holds various resource that need to be freed at the end of execution.
//
//***************************************************************************


struct PROG_RESOURCES
{
    HANDLE          m_hExclusive;
    HANDLE          m_hTerminateEvent;
    BOOL            m_bOleInitialized;

    IClassFactory*  m_pLoginFactory;
    IClassFactory*  m_pBackupFactory;
    DWORD           m_dwLoginClsFacReg;
    DWORD           m_dwBackupClsFacReg;

    CFlexArray      m_Array;

    PROG_RESOURCES();
} ;

class CForwardFactory : public IClassFactory
{
protected:
    long m_lRef;
    CLSID m_ForwardClsid;
    IClassFactory* m_pFactory;

public:
    CForwardFactory(REFCLSID rForwardClsid) 
        : m_lRef(0), m_ForwardClsid(rForwardClsid), m_pFactory(NULL)
    {}
    ~CForwardFactory();

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppv);
    HRESULT STDMETHODCALLTYPE CreateInstance(IUnknown* pUnkOuter, 
                                REFIID riid, void** ppv);
    HRESULT STDMETHODCALLTYPE LockServer(BOOL fLock);
};

//***************************************************************************
//
// CLASS NAME:
//
// MyService 
//
// DESCRIPTION:
//
// Having an instace of this class allows WinMgmt to run as a service.
// routes the calls to the actual WBEM core functions.  See SERVICE.TXT,
// which should be in the coredll project, for a few pages of details!
//
//***************************************************************************

class MyService : public CNtService{
public:
    MyService();
    ~MyService();
    DWORD WorkerThread();
    void UserCode(int nCode);
    BOOL bOK(){return (m_hStopEvent != NULL && m_hBreakPoint != NULL);};
    void Stop(){SetEvent(m_hStopEvent);};
    VOID Log(LPCSTR lpszMsg);
    HANDLE m_hStopEvent;
    HANDLE m_hBreakPoint;
};

LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
BOOL Initialize(PROG_RESOURCES & pr, BOOL bRunAsApp);
void Cleanup();
HWND MyCreateWindow(HINSTANCE hInstance);

typedef HRESULT (ADAP_DORESYNCPERF) ( HANDLE, DWORD, long, DWORD );

#define WBEM_REG_ADAP		__TEXT("Software\\Microsoft\\WBEM\\CIMOM\\ADAP")
#define WBEM_NORESYNCPERF	__TEXT("NoResyncPerf")
#define WBEM_NOSHELL		__TEXT("NoShell")
#define WBEM_WMISETUP		__TEXT("WMISetup")
#define WBEM_ADAPEXTDLL		__TEXT("ADAPExtDll")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\win9xaut.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    WIN9XAUT.H

Abstract:

  Declares some routines which are useful for doing autostart on Win9X boxs.

  The registry value hklm\software\microsoft\WinMgmt\wbem\Win9XAutostart
  is used to control wether or not autostarting is desired.
  It has the following values; 0= no, 1= Only if ESS needs it, 2= always.

  If it is decided that autostarting is desired, then a subkey
  under hklm\software\microsoft\windows\currentVersion\runservice should be
  created.

  THESE FUNCTIONS DONT DO ANYTHING UNDER NT SINCE NT AUTOSTARTING IS DONE VIA
  SERVICES!

History:

	a-davj  5-April-98   Created.

--*/

#ifndef _Win9XAut_H_
#define _Win9XAut_H_

// Returns the current WinMgmt option for this.  Note that -1 is returned if the
// value has not been set in the registry, or if we are running on NT.

DWORD GetWin95RestartOption();

// Sets the current WinMgmt option for this.

void SetWin95RestartOption(DWORD dwChoice);

// Reads the current option, checks what ESS needs and does the right thing.  I.e. It either
// adds the service, or removes it.

void UpdateTheWin95ServiceList();

// Adds WinMgmt to the autorestart list.

void AddToList();

// Removes WinMgmt from the autostart list.

void RemoveFromList();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server2\strings.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    STRINGS.H

Abstract:

	resource IDs.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _provstub_H_
#define _provstub_H_

#define ID1		101
#define ID2		102
#define ID3		103
#define ID4		104
#define ID5		105
#define ID6		106
#define ID7		107
#define ID8		108
#define ID9		109
#define ID10	110
#define ID11	111
#define ID_LAST 112


#define ID_ERROR_SHORT		200
#define ID_ERROR_LONG		201
#define ID_BACKUP_TITLE		202
#define ID_RESTORE_TITLE	203

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\win9xaut.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    WIN9XAUT.CPP

Abstract:

  Defines some routines which are useful for doing autostart on Win9X boxs.

  The registry value hklm\software\microsoft\WinMgmt\wbem\Win9XAutostart
  is used to control wether or not autostarting is desired.
  It has the following values; 0= no, 1= Only if ESS needs it, 2= always.

  If it is decided that autostarting is desired, then a subkey
  under hklm\software\microsoft\windows\currentVersion\runservice should be
  created.

  THESE FUNCTIONS DONT DO ANYTHING UNDER NT SINCE NT AUTOSTARTING IS DONE VIA
  SERVICES!

History:

    a-davj  5-April-98   Created.

--*/

#include "precomp.h"
#include <wbemint.h>
#include "corepol.h"
#include "genutils.h"
#include "PersistCfg.h"
#include "reg.h"
#include "Win9XAut.h"

TCHAR * pServiceName = __TEXT("MicrosoftWBEMCIMObjectManager");  // spaces are not allowed!

//***************************************************************************
//
//  void AddToList()
//
//  DESCRIPTION:
//
//  Adds WinMgmt to the Win9X RunService list.
//
//***************************************************************************

void AddToList()
{
    // Determine WinMgmt's location by using the clsid section

    WCHAR      wcID[40];
    TCHAR  szCLSID[140];
    TCHAR cWinMgmtPath[MAX_PATH];
    HKEY hKey;

    // Create the registry path using the CLSID

    if(0 == StringFromGUID2(CLSID_WbemLevel1Login, wcID, 140))
        return;

    lstrcpy(szCLSID, __TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
   
#ifdef UNICODE
    lstrcat(szCLSID, wcID);
#else
    char       szID[40];
    wcstombs(szID, wcID, 40);
    lstrcat(szCLSID, szID);
#endif

    // Get the path to the registered WinMgmt

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet != NO_ERROR)
        return;

    long lSize = MAX_PATH;
    long lRes = RegQueryValue(hKey, __TEXT("LocalServer32"),cWinMgmtPath, &lSize);
    RegCloseKey(hKey);
    if(lRes != ERROR_SUCCESS)
        return;

    // Get a registry object pointing to the runservices

    Registry reg(__TEXT("software\\microsoft\\windows\\currentVersion\\runservices"));
    reg.SetStr(pServiceName, cWinMgmtPath);

}

//***************************************************************************
//
//  void RemoveFromList()
//
//  DESCRIPTION:
//
//  Removes WinMgmt from the Win9X RunService list.
//
//***************************************************************************

void RemoveFromList()
{
    HKEY hKey;
    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, __TEXT("software\\microsoft\\windows\\currentVersion\\runservices"), &hKey);
    if(dwRet == NO_ERROR)
    {
        DWORD dwSize = 0;
        long lRes = RegQueryValueEx(hKey, pServiceName, NULL, NULL, NULL, &dwSize);
        if(lRes == ERROR_SUCCESS)
            RegDeleteValue(hKey,pServiceName);
        RegCloseKey(hKey);
    }

}

//***************************************************************************
//
//  DWORD GetWin95RestartOption()
//
//  DESCRIPTION:
//
//  Returns the current WinMgmt option for this.  
//
//  Return Value:
// 
//  0= no, 1= Only if ESS needs it, 2= always, -1 is returned if the
//  value has not been set in the registry, or if we are running on NT.
//
//***************************************************************************

DWORD GetWin95RestartOption()
{
    DWORD dwRet = -1;
    if(IsNT())
        return dwRet;
    Registry reg(WBEM_REG_WINMGMT);
    reg.GetDWORDStr(__TEXT("AutostartWin9X"), &dwRet);
    return dwRet;
}

//***************************************************************************
//
//  void SetWin95RestartOption()
//
//  DESCRIPTION:
//
//  Sets the current WinMgmt option for this.
//
//  PARAMETERS:
//  
//  dwChoice                0= no, 1= Only if ESS needs it, 2= always
//
//***************************************************************************

void SetWin95RestartOption(DWORD dwChoice)
{
    if(IsNT())
        return;
    Registry reg(WBEM_REG_WINMGMT);
    reg.SetDWORDStr(__TEXT("AutostartWin9X"), dwChoice);
}

//***************************************************************************
//
//  void UpdateTheWin95ServiceList()
//
//  DESCRIPTION:
//
//  Reads the current option, checks what ESS needs and does the right thing.  
//  I.e. It either adds the service, or removes it.
//
//***************************************************************************

void UpdateTheWin95ServiceList()
{
    if(IsNT())
        return;
    DWORD dwChoice;
    dwChoice = GetWin95RestartOption();

    bool bNeedToAuto = false;

    if(dwChoice == 1)
    {
        // Set to true only if ESS needs to run.
    
        DWORD dwNeedESS;
        CPersistentConfig per;
        if(per.GetPersistentCfgValue(PERSIST_CFGVAL_CORE_ESS_NEEDS_LOADING, dwNeedESS))
            if(dwNeedESS)
                bNeedToAuto = true;
    }
    else if(dwChoice == 2)
        bNeedToAuto = true;

    if(bNeedToAuto)
        AddToList();
    else
        RemoveFromList();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server2\winmgmt.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WINMGMT.H

Abstract:

	Declares the PROG_RESOURCES stucture, the MyService class and a few
	utility type functions.

History:

--*/

#ifndef _WinMgmt_H_
#define _WinMgmt_H_


typedef HRESULT (ADAP_DORESYNCPERF) ( HANDLE, DWORD, long, DWORD );

#define WBEM_REG_ADAP		__TEXT("Software\\Microsoft\\WBEM\\CIMOM\\ADAP")
#define WBEM_NORESYNCPERF	__TEXT("NoResyncPerf")
#define WBEM_NOSHELL		__TEXT("NoShell")
#define WBEM_WMISETUP		__TEXT("WMISetup")
#define WBEM_ADAPEXTDLL		__TEXT("ADAPExtDll")
#define SERVICE_DLL         __TEXT("wmisvc.dll")

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server2\winmgmt.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WINMGMT.CPP

Abstract:

    Implements the windows application or an NT service which
    loads up the various transport prtocols.

    If started with /exe argument, it will always run as an exe.
    If started with /kill argument, it will stop any running exes or services.
    If started with /? or /help dumps out information.

History:

    a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include <malloc.h>
#include <tchar.h>
#include <Shellapi.h> // for CommandLineToArgvW

#include <wbemidl.h>
#include <reg.h>      // for Registry
#include <wbemutil.h> // for DEBUGTRACE
#include <cominit.h>  // for InitializeCom
#include <genutils.h> // EnableAllPrivileges
#include <mofcomp.h>
#include <winmgmtr.h>
#include <arrtempl.h>

#include "servutil.h"
#include "WinMgmt.h"
#include "STRINGS.h"

BOOL g_fDoResync = TRUE;
BOOL g_fSetup = FALSE;

#define BUFF_MAX 200


HINSTANCE ghInstance;

void SetToAuto();
DWORD RegServer();
DWORD UnregServer();
void DoResyncPerf();
void DoClearAdap();
// to accomodate revert-to-alone
DWORD DoSetToAlone(CHAR * pszLevel);
DWORD DoSetToShared(CHAR * pszLevel);
// for Back-up Restore
int DoBackup();
int DoRestore();
void DisplayWbemError(HRESULT hresError, DWORD dwLongFormatString, DWORD dwShortFormatString, DWORD dwTitle);

void (STDAPICALLTYPE *pServiceLocalConn)(DWORD *dwSize, char * pData);
void LoadMofsInDirectory(const TCHAR *szDirectory);
BOOL CheckGlobalSetupSwitch( void );



//***************************************************************************
//
//  void TerminateRunning
//
//  DESCRIPTION:
//
//  Stops another running copy even if it is a service.
//
//***************************************************************************

void TerminateRunning()
{

    HANDLE hTerm = OpenEvent(EVENT_MODIFY_STATE,FALSE,
            TEXT("WINMGMT_MARSHALLING_SERVER_TERMINATE"));
    if(hTerm)
    {
        SetEvent(hTerm);
        CloseHandle(hTerm);
    }
    StopService(__TEXT("wmiapsrv"), 15);
    StopService(__TEXT("WinMgmt"), 15);

    return;
}

//***************************************************************************
//
//  void DisplayMessage
//
//  DESCRIPTION:
//
//  Displays a usage message box.
//
//***************************************************************************

void DisplayMessage()
{
    //
    //  ISSUE: these might not be enought for certain localized strings
    //
    TCHAR tBuff[BUFF_MAX];
    TCHAR tBig[1024];
    tBig[0] = 0;

    UINT ui;
    for(ui = ID1; ui <= ID9; ui++)
    {
        int iRet = LoadString(ghInstance, ui, tBuff, BUFF_MAX);
        if(iRet > 0)
            lstrcat(tBig, tBuff);
    }
    if(lstrlen(tBig) > 0)
        MessageBox(NULL,  tBig,__TEXT("WinMgmt"), MB_OK);

}


BOOL CheckNoResyncSwitch( void )
{
    BOOL bRetVal = TRUE;
    DWORD dwVal = 0;
    Registry rCIMOM(WBEM_REG_WINMGMT);
    if (rCIMOM.GetDWORDStr( WBEM_NORESYNCPERF, &dwVal ) == Registry::no_error)
    {
        bRetVal = !dwVal;

        if ( bRetVal )
        {
            DEBUGTRACE((LOG_WBEMCORE, "NoResyncPerf in CIMOM is set to TRUE - ADAP will not be shelled\n"));
        }
    }

    // If we didn't get anything there, we should try the volatile key
    if ( bRetVal )
    {
        Registry rAdap( HKEY_LOCAL_MACHINE, KEY_READ, WBEM_REG_ADAP);

        if ( rAdap.GetDWORD( WBEM_NOSHELL, &dwVal ) == Registry::no_error )
        {
            bRetVal = !dwVal;

            if ( bRetVal )
            {
                DEBUGTRACE((LOG_WBEMCORE, 
                    "NoShell in ADAP is set to TRUE - ADAP will not be shelled\n"));
            }

        }
    }

    return bRetVal;
}

BOOL CheckSetupSwitch( void )
{
    BOOL bRetVal = FALSE;
    DWORD dwVal = 0;
    Registry r(WBEM_REG_WINMGMT);
    if (r.GetDWORDStr( WBEM_WMISETUP, &dwVal ) == Registry::no_error)
    {
        bRetVal = dwVal;
        DEBUGTRACE((LOG_WBEMCORE, "Registry entry is indicating a setup is running\n"));
    }
    return bRetVal;
}

BOOL CheckGlobalSetupSwitch( void )
{
    BOOL bRetVal = FALSE;
    DWORD dwVal = 0;
    Registry r(TEXT("system\\Setup"));
    if (r.GetDWORD( TEXT("SystemSetupInProgress"), &dwVal ) == Registry::no_error)
    {
        if(dwVal == 1)
            bRetVal = TRUE;
    }
    return bRetVal;
}


// This function will place a volatile registry key under the CIMOM key in which we will
// write a value indicating we should not shell ADAP.  This way, after a setup runs, WINMGMT
// will NOT automatically shell ADAP dredges of the registry, until the system is rebooted
// and the volatile registry key is removed.

void SetNoShellADAPSwitch( void )
{
    HKEY    hKey = NULL;
    DWORD   dwDisposition = 0;

    Registry    r( HKEY_LOCAL_MACHINE, REG_OPTION_VOLATILE, KEY_ALL_ACCESS, WBEM_REG_ADAP );

    if ( ERROR_SUCCESS == r.GetLastError() )
    {

        if ( r.SetDWORD( WBEM_NOSHELL, 1 ) != Registry::no_error )
        {
            DEBUGTRACE( ( LOG_WINMGMT, "Failed to create NoShell value in volatile reg key: %d\n",
                        r.GetLastError() ) );
        }

        RegCloseKey( hKey );

    }
    else
    {
        DEBUGTRACE( ( LOG_WINMGMT, "Failed to create volatile ADAP reg key: %d\n", r.GetLastError() ) );
    }

}

//***************************************************************************
//
//  int APIENTRY WinMain
//
//  DESCRIPTION:
//
//  Entry point for windows applications.  If this is running under
//  NT, then this will run as a service, unless the "/EXE" command line
//  argument is used.
//
//  PARAMETERS:
//
//  hInstance           Instance handle
//  hPrevInstance       not used in win32
//  szCmdLine           command line argument
//  nCmdShow            how window is to be shown(ignored)
//
//  RETURN VALUE:
//
//  0
//***************************************************************************

int APIENTRY WinMain(
                        IN HINSTANCE hInstance,
                        IN HINSTANCE hPrevInstance,
                        IN LPSTR szCmdLine,
                        IN int nCmdShow)
{
    // This should not be uninitialized!  It is here to prevent the class factory from being called during
    // shutdown.
    
    ghInstance = hInstance;

    DEBUGTRACE((LOG_WINMGMT,"\nStarting WinMgmt, ProcID = %x, CmdLine = %s", GetCurrentProcessId(), szCmdLine));

    if(szCmdLine && (szCmdLine[0] == '-' || szCmdLine[0] == '/' ))
    {
        if(!_stricmp("RegServer",szCmdLine+1))
            return RegServer();
        else if(!_stricmp("UnregServer",szCmdLine+1))
            return UnregServer();    
        else if(!_stricmp("kill",szCmdLine+1))
        {
            TerminateRunning();
            return 0;
        }
        else if (_strnicmp("backup ", szCmdLine+1, strlen("backup ")) == 0)
        {
            return DoBackup();
        }
        else if (_strnicmp("restore ", szCmdLine+1, strlen("restore ")) == 0)
        {
            return DoRestore();
        }
        else if(_strnicmp("resyncperf", szCmdLine+1, strlen("resyncperf")) == 0)
        {
            DoResyncPerf();
            return 0;
        }
        else if(_strnicmp("clearadap", szCmdLine+1, strlen("clearadap")) == 0)
        {
            DoClearAdap();
            return 0;
        }
        else if (0 == _strnicmp("cncnt",szCmdLine+1,strlen("cnct")))
        {
            CHAR pNumber[16];
            sprintf(pNumber,"%d",RPC_C_AUTHN_LEVEL_CONNECT); // our OLD default
            return DoSetToAlone(pNumber);        
        }
        else if (0 == _strnicmp("pkt",szCmdLine+1, strlen("pkt")))
        {
			// NULL means default means PKT
            return DoSetToShared(NULL);            
        }
        else if(0 == _strnicmp("?", szCmdLine+1,strlen("?")))
        {
            DisplayMessage();
            return 0;
        }
    }

    return 0;
}

//***************************************************************************
//
//  int RegServer
//
//  DESCRIPTION:
//
//  Self registers the dll.
//
//***************************************************************************

typedef HRESULT (__stdcall *  pfnDllRegisterServer)(void);

DWORD RegServer()
{
    HMODULE hMod = LoadLibraryEx(SERVICE_DLL,NULL,0);
    DWORD dwRes = 0;
    
    if (hMod)
    {
        pfnDllRegisterServer DllRegisterServer = (pfnDllRegisterServer)GetProcAddress(hMod,"DllRegisterServer");

		if(DllRegisterServer)
		{
			dwRes = DllRegisterServer();
		} 
		else 
		{
            dwRes = GetLastError();
		}

		FreeLibrary(hMod);        
    } 
    else 
    {
        dwRes = GetLastError();
    }

    return dwRes;

}

//***************************************************************************
//
//  int UnregServer
//
//  DESCRIPTION:
//
//  Unregisters the exe.
//
//***************************************************************************

typedef HRESULT (__stdcall *  pfnDllUnregisterServer)(void);

DWORD UnregServer()
{
    HMODULE hMod = LoadLibraryEx(SERVICE_DLL,NULL,0);
    DWORD dwRes = 0;
    
    if (hMod)
    {
        pfnDllUnregisterServer DllUnregisterServer = (pfnDllUnregisterServer)GetProcAddress(hMod,"DllUnregisterServer");

		if(DllUnregisterServer)
		{
			dwRes = DllUnregisterServer();
		} 
		else 
		{
            dwRes = GetLastError();
		}

		FreeLibrary(hMod);        
    } 
    else 
    {
        dwRes = GetLastError();
    }

    return dwRes;
}

//
//
// move in a segregate svchost, to allow OLD connect level
//
///////////////////////////////////////////////////////////


typedef 
void (CALLBACK * pfnMoveToAlone)(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);

DWORD 
DoSetToAlone(CHAR * pszLevel)
{
    HMODULE hMod = LoadLibraryEx(SERVICE_DLL,NULL,0);
    DWORD dwRes = 0;
    
    if (hMod)
    {
        pfnMoveToAlone MoveToAlone = (pfnMoveToAlone)GetProcAddress(hMod,"MoveToAlone");

		if(MoveToAlone)
		{
			MoveToAlone(NULL,hMod,pszLevel,0);
		} 
		else 
		{
            dwRes = GetLastError();
		}

		FreeLibrary(hMod);        
    } 
    else 
    {
        dwRes = GetLastError();
    }

    return dwRes;    
};

//
//
// move in a shares svchost
//
///////////////////////////////////////////////////////////

typedef 
void (CALLBACK * pfnMoveToShared)(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);

DWORD DoSetToShared(char * pszLevel)
{
	HMODULE hMod = LoadLibraryEx(SERVICE_DLL,NULL,0);
    DWORD dwRes = 0;
    
    if (hMod)
    {
        pfnMoveToShared MoveToShared = (pfnMoveToAlone)GetProcAddress(hMod,"MoveToShared");

		if(MoveToShared)
		{
			MoveToShared(NULL,hMod,pszLevel,0);
		} 
		else 
		{
            dwRes = GetLastError();
		}

		FreeLibrary(hMod);        
    } 
    else 
    {
        dwRes = GetLastError();
    }

    return dwRes;    
};

//***************************************************************************
//
//  int DoBackup
//
//  DESCRIPTION:
//
//  Calls into IWbemBackupRestore::Backup to backup the repository.
//
//***************************************************************************
int DoBackup()
{
	int hr = WBEM_S_NO_ERROR;

    //*************************************************
    // Split up command line and validate parameters
    //*************************************************
    wchar_t *wszCommandLine = GetCommandLineW();
    if (wszCommandLine == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        DisplayWbemError(hr, ID_ERROR_LONG, ID_ERROR_SHORT, ID_BACKUP_TITLE);
    }

    int nNumArgs = 0;
    wchar_t **wszCommandLineArgv = NULL;

    if (SUCCEEDED(hr))
    {
        wszCommandLineArgv = CommandLineToArgvW(wszCommandLine, &nNumArgs);

        if ((wszCommandLineArgv == NULL) || (nNumArgs != 3))
        {
            hr = WBEM_E_INVALID_PARAMETER;
            DisplayMessage();
        }
    }

    //wszCommandLineArgv[0] = winmgmt.exe
    //wszCommandLineArgv[1] = /backup
    //wszCommandLineArgv[2] = <backup filename>

    if (SUCCEEDED(hr))
    {
        InitializeCom();
        IWbemBackupRestore* pBackupRestore = NULL;
        hr = CoCreateInstance(CLSID_WbemBackupRestore, 0, CLSCTX_LOCAL_SERVER,
                            IID_IWbemBackupRestore, (LPVOID *) &pBackupRestore);
        if (SUCCEEDED(hr))
        {
            EnableAllPrivileges(TOKEN_PROCESS);
            hr = pBackupRestore->Backup(wszCommandLineArgv[2], 0);

            if (FAILED(hr))
            {
                DisplayWbemError(hr, ID_ERROR_LONG, ID_ERROR_SHORT, ID_BACKUP_TITLE);
            }

            pBackupRestore->Release();
        }
        else
        {
            DisplayWbemError(hr, ID_ERROR_LONG, ID_ERROR_SHORT, ID_BACKUP_TITLE);
        }
        CoUninitialize();
    }

	return hr;
}

//***************************************************************************
//
//  int DoRestore
//
//  DESCRIPTION:
//
//  Calls into IWbemBackupRestore::Restore to restore the repository.
//
//***************************************************************************
int DoRestore()
{
	int hr = WBEM_S_NO_ERROR;

    //*************************************************
    // Split up command line and validate parameters
    //*************************************************
    wchar_t *wszCommandLine = GetCommandLineW();
    if (wszCommandLine == NULL)
    {
        hr = WBEM_E_OUT_OF_MEMORY;
        DisplayWbemError(hr, ID_ERROR_LONG, ID_ERROR_SHORT, ID_RESTORE_TITLE);
    }

    int nNumArgs = 0;
    wchar_t **wszCommandLineArgv = NULL;

    if (SUCCEEDED(hr))
    {
        wszCommandLineArgv = CommandLineToArgvW(wszCommandLine, &nNumArgs);

        if ((wszCommandLineArgv == NULL) || (nNumArgs != 4))
        {
            hr = WBEM_E_INVALID_PARAMETER;
            DisplayMessage();
        }
    }

    //wszCommandLineArgv[0] = winmgmt.exe
    //wszCommandLineArgv[1] = /restore
    //wszCommandLineArgv[2] = <restore filename>
    //wszcommandLineArgv[3] = <restore options>

    //*****************************************************
    // Validate restore option
    //*****************************************************
    if (SUCCEEDED(hr))
    {
        if ((wcscmp(wszCommandLineArgv[3], L"0") != 0) &&
            (wcscmp(wszCommandLineArgv[3], L"1") != 0))
        {
            hr = WBEM_E_INVALID_PARAMETER;
            DisplayMessage();
        }
    }

    long lFlags = 0;

    //*****************************************************
    // Retrieve restore option
    //*****************************************************
    if (SUCCEEDED(hr))
    {
        lFlags = (long) (*wszCommandLineArgv[3] - L'0');
    }

    //*****************************************************
    // Create the IWbemBackupRestore interface and get that
    // to do the restore for us...
    //*****************************************************
    if (SUCCEEDED(hr))
    {
        InitializeCom();
        IWbemBackupRestore* pBackupRestore = NULL;
        hr = CoCreateInstance(CLSID_WbemBackupRestore, 0, CLSCTX_LOCAL_SERVER,
                            IID_IWbemBackupRestore, (LPVOID *) &pBackupRestore);
        if (SUCCEEDED(hr))
        {
            EnableAllPrivileges(TOKEN_PROCESS);
            hr = pBackupRestore->Restore(wszCommandLineArgv[2], lFlags);

            if (FAILED(hr))
            {
                DisplayWbemError(hr, ID_ERROR_LONG, ID_ERROR_SHORT, ID_RESTORE_TITLE);
            }

            pBackupRestore->Release();
        }
        else
        {
            DisplayWbemError(hr, ID_ERROR_LONG, ID_ERROR_SHORT, ID_RESTORE_TITLE);
        }
        CoUninitialize();
    }

    //**************************************************
    //All done!
    //**************************************************
	return hr;
}

void DisplayWbemError(HRESULT hresError, DWORD dwLongFormatString, DWORD dwShortFormatString, DWORD dwTitle)
{
    wchar_t* szError = new wchar_t[2096];
	if (!szError)
		return;
	CVectorDeleteMe<wchar_t> delme1(szError);
	szError[0] = 0;

    WCHAR* szFacility = new wchar_t[2096];
	if (!szFacility)
		return;
	CVectorDeleteMe<wchar_t> delme2(szFacility);
    szFacility[0] = 0;

    TCHAR* szMsg = new TCHAR[2096];
	if (!szMsg)
		return;
	CVectorDeleteMe<TCHAR> delme3(szMsg);

    TCHAR* szFormat = new TCHAR[100];
	if (!szFormat)
		return;
	CVectorDeleteMe<TCHAR> delme4(szFormat);

    TCHAR* szTitle = new TCHAR[100];
	if (!szTitle)
		return;
	CVectorDeleteMe<TCHAR> delme5(szTitle);

    IWbemStatusCodeText * pStatus = NULL;

    SCODE sc = CoCreateInstance(CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
                                        IID_IWbemStatusCodeText, (LPVOID *) &pStatus);
    
    if(sc == S_OK)
    {
        BSTR bstr = 0;
        sc = pStatus->GetErrorCodeText(hresError, 0, 0, &bstr);
        if(sc == S_OK)
        {
            wcsncpy(szError, bstr, 2096-1);
            SysFreeString(bstr);
            bstr = 0;
        }
        sc = pStatus->GetFacilityCodeText(hresError, 0, 0, &bstr);
        if(sc == S_OK)
        {
            wcsncpy(szFacility, bstr, 2096-1);
            SysFreeString(bstr);
            bstr = 0;
        }
        pStatus->Release();
    }
    if(wcslen(szFacility) == 0 || wcslen(szError) == 0)
    {
        LoadString(GetModuleHandle(NULL), dwShortFormatString, szFormat, 99);
        _stprintf(szMsg, szFormat, hresError);
    }
    else
    {
        LoadString(GetModuleHandle(NULL), dwLongFormatString, szFormat, 99);
        _stprintf(szMsg, szFormat, hresError, szFacility, szError);
    }

    LoadString(GetModuleHandle(NULL), dwTitle, szTitle, 99);
    MessageBox(0, szMsg, szTitle, MB_ICONERROR | MB_OK);
}

void DoResyncPerf()
{
    PROCESS_INFORMATION pi;
    STARTUPINFO si;
    memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);
	si.dwFlags = STARTF_FORCEOFFFEEDBACK;

	// Get the appropriate cmdline and attach the proper command line switches
	LPTSTR	pCmdLine = GetWMIADAPCmdLine( 64 );
	CVectorDeleteMe<TCHAR>	vdm( pCmdLine );

	if ( NULL == pCmdLine )
	{
		return;
	}

	TCHAR pPassedCmdLine[64];
	_tcscpy(pPassedCmdLine,_T("wmiadap.exe /F"));
	
	if ( CreateProcess( pCmdLine, pPassedCmdLine, NULL, NULL, FALSE, CREATE_NO_WINDOW,
			      NULL, NULL,  &si, &pi ) )
	{
        // Cleanup handles right away
		// ==========================
        CloseHandle( pi.hThread );
        CloseHandle( pi.hProcess );
	}

    return;
}

void DoClearAdap()
{
	PROCESS_INFORMATION pi;
	STARTUPINFO si;
	memset(&si, 0, sizeof(si));
	si.cb = sizeof(si);
    si.dwFlags = STARTF_FORCEOFFFEEDBACK;

	// Get the appropriate cmdline and attach the proper command line switches
	LPTSTR	pCmdLine = GetWMIADAPCmdLine( 64 );
	CVectorDeleteMe<TCHAR>	vdm( pCmdLine );

	if ( NULL == pCmdLine )
	{
		return;
	}

	TCHAR pPassedCmdLine[64];
	_tcscpy(pPassedCmdLine,_T("wmiadap.exe /C"));

	if ( CreateProcess( pCmdLine, pPassedCmdLine, NULL, NULL, FALSE, CREATE_NO_WINDOW,
				  NULL, NULL,  &si, &pi) )
	{
        // Cleanup handles right away
		// ==========================
        CloseHandle( pi.hThread );
        CloseHandle( pi.hProcess );
	}

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server\winmgmt.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WINMGMT.CPP

Abstract:

    Implements the windows application or an NT service which
    loads up the various transport prtocols.

    If started with /exe argument, it will always run as an exe.
    If started with /kill argument, it will stop any running exes or services.
    If started with /? or /help dumps out information.

History:

    a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>
#include <malloc.h>
#include <tchar.h>
#include <Shellapi.h>

#include <wbemidl.h>
#include <reg.h>
#include <wbemutil.h>
#include <cntserv.h>
#include <cominit.h>
#include <sync.h>
#include <lmwksta.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <utils.h>
#include <genutils.h>
#include "servutil.h"
#include <persistcfg.h>
#include "WinMgmt.h"
#include "sched.h"
#include "STRINGS.h"
#include "win9Xaut.h"
#include <wbemint.h>
#include <wbemprov.h>
#include <winntsec.h>
#include <mofcomp.h>

#include <winmgmtr.h>
#include <BackupRestore.h>
#include <arrtempl.h>
#include <corex.h>
#include "process.h"
#include "resync.h"

#define CORE_PROVIDER_UNLOAD_TIMEOUT ( 30 * 1000 )

HWND ghWnd = NULL;      // handle to main window
BOOL gbShowIcon = FALSE;
BOOL g_bRemovedAppId = FALSE;
BOOL g_fDoResync = TRUE;
BOOL g_fSetup = FALSE;
#define BUFF_MAX 200
bool gbSetToRunAsApp = false;

HINSTANCE ghInstance;
HANDLE ghCoreCanUnload = NULL;
HANDLE ghProviderCanUnload = NULL;
HANDLE ghCoreUnloaded = NULL;
HANDLE ghCoreLoaded = NULL;
HANDLE ghNeedRegistration = NULL;
HANDLE ghRegistrationDone = NULL;
HANDLE ghMofDirChange = NULL;
HANDLE ghLoadCtrEvent = NULL;
HANDLE ghUnloadCtrEvent = NULL;
HANDLE ghHoldOffNewClients = NULL;
BOOL gbRunAsApp = TRUE;

TCHAR * g_szHotMofDirectory = NULL;
BOOL gbRunningAsManualService = FALSE;
bool gbShuttingDownWinMgmt = false;
BOOL gbCoreLoaded = FALSE;
HANDLE ghMainMutex;
bool bServer = true;
HANDLE g_hAbort = NULL;
void SetToAuto();

class CInMutex
{
protected:
    HANDLE m_hMutex;
public:
    CInMutex(HANDLE hMutex) : m_hMutex(hMutex)
    {
		if(m_hMutex)
			WaitForSingleObject(m_hMutex, INFINITE);
    }
    ~CInMutex()
    {
		if(m_hMutex)
			ReleaseMutex(m_hMutex);
    }
};

void DoResyncPerf();
void DoClearAdap();
int DoBackup();
int DoRestore();
void DisplayWbemError(HRESULT hresError, DWORD dwLongFormatString, DWORD dwShortFormatString, DWORD dwTitle);

void AddToAutoRecoverList(TCHAR * pFileName);
bool IsStringPresent(char * pTest, char * pMultStr);

PROG_RESOURCES pr;

void (STDAPICALLTYPE *pServiceLocalConn)(DWORD *dwSize, char * pData);
void LoadMofsInDirectory(const TCHAR *szDirectory);
BOOL CheckGlobalSetupSwitch( void );

HRESULT GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1]);
HRESULT DoDeleteRepository(const wchar_t *wszExcludeFile);
HRESULT DoDeleteContentsOfDirectory(const wchar_t *wszExcludeFile, const wchar_t *wszRepositoryDirectory);
HRESULT DoDeleteDirectory(const wchar_t *wszExcludeFile, const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory);

//***************************************************************************
//
//  ShutDownCore
//
//  DESCRIPTION:
//
//  Calls the core shutdown logic, but only if the core is loaded.  Note that
//  the shutdown is protected with a CS which is shared with the class factory.
//  This prevents the class factory from creating a new connection during shutdown.
//
//***************************************************************************

bool ShutDownCore(BOOL bProcessShutdown)
{
    SCODE sc = WBEM_E_FAILED;
    HMODULE hCoreModule = LoadLibrary(__TEXT("wbemcore.dll"));
    if(hCoreModule)
    {
        HRESULT (STDAPICALLTYPE *pfn)(DWORD);
        pfn = (long (__stdcall *)(DWORD))GetProcAddress(hCoreModule, "Shutdown");
        if(pfn)
        {
            sc = (*pfn)(bProcessShutdown);
            DEBUGTRACE((LOG_WINMGMT, "core is being shut down by WinMgmt.exe, it returned 0x%x",sc));
        }

        FreeLibrary(hCoreModule);
     }
    return sc == S_OK;
}


//***************************************************************************
//
//  OKToUnloadCore
//
//  DESCRIPTION:
//
//  Calls the core DllCanUnloadNow function.
//
//***************************************************************************

bool OKToUnloadCore()
{
    SCODE sc = WBEM_E_FAILED;
    HMODULE hCoreModule = LoadLibrary(__TEXT("wbemcore.dll"));
    if(hCoreModule)
    {
        HRESULT (STDAPICALLTYPE *pfn)();
        pfn = (HRESULT (__stdcall *)())GetProcAddress(hCoreModule, "DllCanUnloadNow");
        if(pfn)
        {
            sc = (*pfn)();
            ERRORTRACE((LOG_WINMGMT, "core was asked if ok to unload and returned 0x%x", sc));
        }
        FreeLibrary(hCoreModule);
     }
    return sc == S_OK;
}

//***************************************************************************
//
//  CreateNarrowGuidString
//
//  DESCRIPTION:
//
//  Fills in the narrow buffer with a clsid.  Note that pBuff must point to
//  a buffer large enough to hold a the clsid.
//
//***************************************************************************

void CreateNarrowGuidString(REFCLSID rclsid, TCHAR * pBuff)
{
    pBuff[0] = 0;
    LPWSTR wszGuid;
    StringFromCLSID(rclsid, &wszGuid);

#ifdef UNICODE
    swprintf(pBuff, L"%s", wszGuid);
#else
    sprintf(pBuff, "%S", wszGuid);
#endif

    CoTaskMemFree(wszGuid);
}

//***************************************************************************
//
//  SetCLSIDToService
//
//  DESCRIPTION:
//
//  Used to restore clsid keys back to a state where they can be part of
//  a service.
//
//***************************************************************************

void SetCLSIDToService(TCHAR * szGuid, TCHAR * szAppIDGuid)
{
    Registry rClsid;
    rClsid.Open(HKEY_LOCAL_MACHINE, __TEXT("SOFTWARE\\CLASSES\\CLSID"));
    rClsid.MoveToSubkey(szGuid);
    rClsid.SetStr(__TEXT("AppId"), szAppIDGuid);

    TCHAR cPath[MAX_PATH];
    lstrcpy(cPath, __TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(cPath, szGuid);
    lstrcat(cPath, __TEXT("\\LocalServer32"));
    RegDeleteKey(HKEY_LOCAL_MACHINE, cPath);
}

//***************************************************************************
//
//  SetCLSIDToExe
//
//  DESCRIPTION:
//
//  Used to st clsid keys back to a state where they can be part of
//  an exe.
//
//***************************************************************************

void SetCLSIDToExe(TCHAR * szGuid)
{
    Registry rCLSID;
    rCLSID.Open(HKEY_LOCAL_MACHINE, __TEXT("SOFTWARE\\CLASSES\\CLSID"));
    rCLSID.MoveToSubkey(szGuid);
    rCLSID.DeleteValue(__TEXT("AppId"));

    TCHAR LocalServerKey[MAX_PATH];
    lstrcpy(LocalServerKey, __TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(LocalServerKey, szGuid);
    Registry rLocalServer;
    rLocalServer.Open(HKEY_LOCAL_MACHINE, LocalServerKey);
    rLocalServer.MoveToSubkey(__TEXT("LocalServer32"));

    TCHAR szPath[MAX_PATH+1];
    if(GetModuleFileName(ghInstance, szPath, MAX_PATH))
        rLocalServer.SetStr(NULL, szPath);
}

//***************************************************************************
//
//  SetToRunAsService
//
//  DESCRIPTION:
//
//  Sets up the registry so that we can run as an nt service.
//
//***************************************************************************

void SetToRunAsService()
{

    TCHAR szMainGuid[128];
    TCHAR szBackupGuid[128];
    CreateNarrowGuidString(CLSID_WbemLevel1Login, szMainGuid);
    CreateNarrowGuidString(CLSID_WbemBackupRestore, szBackupGuid);

    SetCLSIDToService(szMainGuid, szMainGuid);
    SetCLSIDToService(szBackupGuid, szMainGuid);

    Registry rAppid;
    rAppid.Open(HKEY_LOCAL_MACHINE, __TEXT("SOFTWARE\\CLASSES\\APPID"));
    rAppid.MoveToSubkey(szMainGuid);
    rAppid.SetStr(__TEXT("LocalService"), __TEXT("WinMgmt"));
    rAppid.DeleteValue(__TEXT("RunAs"));
}

//***************************************************************************
//
//  SetToRunAsExe
//
//  DESCRIPTION:
//
//  Sets up the registry so that we can run as an exe.  This is used for devs.
//
//***************************************************************************

void SetToRunAsExe()
{
    // Only want to remove the APPID Value if we are running under NT.
    // ===============================================================

    // If the APPID value exists in the registry for PrivateWbemLevel1Login
    //  then remove it as we can't run as an EXE if we are setup to run
    // as a DCOM service.
    // =============================================================

    TCHAR szMainGuid[128];
    TCHAR szBackupGuid[128];
    CreateNarrowGuidString(CLSID_WbemLevel1Login, szMainGuid);
    CreateNarrowGuidString(CLSID_WbemBackupRestore, szBackupGuid);

    SetCLSIDToExe(szMainGuid);
    SetCLSIDToExe(szBackupGuid);

    Registry rAppid;
    rAppid.Open(HKEY_LOCAL_MACHINE, __TEXT("SOFTWARE\\CLASSES\\APPID"));
    rAppid.MoveToSubkey(szMainGuid);

    rAppid.DeleteValue(__TEXT("LocalService"));
    rAppid.SetStr(__TEXT("RunAs"), __TEXT("Interactive User"));
	gbSetToRunAsApp = true;
}


//***************************************************************************
//
//  WaitingFunction
//
//  DESCRIPTION:
//
//  Here is where we wait for messages and events during WinMgmt execution.
//  We return from here when the program/service is being stopped.
//
//***************************************************************************

void WaitingFunction(HANDLE hTerminate)
{

    CSched sched;

    DEBUGTRACE((LOG_WINMGMT,"Inside the waiting function\n"));
    if(!gbRunAsApp)
        SetToAuto();


    HANDLE hEvents[] = {hTerminate, ghCoreCanUnload, ghCoreUnloaded, ghCoreLoaded, ghNeedRegistration,
        ghProviderCanUnload, ghMofDirChange, ghLoadCtrEvent, ghUnloadCtrEvent};
    int iNumEvents = sizeof(hEvents) / sizeof(HANDLE);
    DWORD dwFlags;
    SCODE sc;
    CPersistentConfig per;
    per.TidyUp();

    sched.SetWorkItem(PossibleStartCore, 60000);

    //Load any MOFs in the MOF directory if needed...
    LoadMofsInDirectory(g_szHotMofDirectory);

    // resync the perf counters if win2k and we haven't turned this off for debugging
    // and we are not running during setup

    if(IsW2KOrMore() && g_fDoResync && !g_fSetup)
        ResyncPerf( hTerminate );

    SetProcessWorkingSetSize(GetCurrentProcess(), -1, -1);

    while(1)
    {
        DWORD dwDelay = sched.GetWaitPeriod();
        DWORD dwObj = WbemWaitForMultipleObjects(iNumEvents, hEvents, dwDelay);
        switch (dwObj)
        {
            case 0:     // bail out for terminate event
                {
                    DEBUGTRACE((LOG_WINMGMT,"Got a termination event\n"));
                    CInMutex im(ghMainMutex);
                    gbShuttingDownWinMgmt = true;
                    Cleanup();
                }
                return;
            case 1:     // core can unload
                DEBUGTRACE((LOG_WINMGMT,"Got a core can unload event\n"));
                sched.SetWorkItem(FirstCoreShutdown, 30000);   // 30 seconds until next unloac;
                break;
            case 2:     // core went away
                DEBUGTRACE((LOG_WINMGMT,"Got a core unloaded event\n"));
                gbCoreLoaded = FALSE;
                SetProcessWorkingSetSize(GetCurrentProcess(), -1, -1);
                break;

            case 3:     // core loaded
                DEBUGTRACE((LOG_WINMGMT,"Got a core loaded event\n"));
                gbCoreLoaded = TRUE;
                break;

            case 4:     // Need Registration

                DEBUGTRACE((LOG_WINMGMT,"Got a NeedRegistration event\n"));
                if(pr.m_pLoginFactory)
                {
                    CoRevokeClassObject(pr.m_dwLoginClsFacReg);
                    pr.m_pLoginFactory->Release();
                    pr.m_pLoginFactory = NULL;                    
                }
                dwFlags = CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER;
                if(IsDcomEnabled())
                    dwFlags |= CLSCTX_REMOTE_SERVER;

                pr.m_pLoginFactory = new CForwardFactory(CLSID_InProcWbemLevel1Login);
                pr.m_pLoginFactory->AddRef();

                sc = CoRegisterClassObject(CLSID_WbemLevel1Login, pr.m_pLoginFactory,
                                dwFlags,
                                REGCLS_MULTIPLEUSE, &pr.m_dwLoginClsFacReg);

                SetEvent(ghRegistrationDone);
                ResetEvent(ghNeedRegistration);
                break;
            case 5:     // provider can unload
                {
                    DEBUGTRACE((LOG_WINMGMT,"Got a provider can unload event\n"));
                    CInMutex im(ghMainMutex);
                    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
                    //
                    // HACKHACK: Call it again to make sure that components that
                    // were released by unloading the first one can be unloaded
                    //
                    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
                    SetProcessWorkingSetSize(GetCurrentProcess(), -1, -1);
                    sched.SetWorkItem(FinalCoreShutdown, CORE_PROVIDER_UNLOAD_TIMEOUT);   // 11 minutes until next unloac;
                }
                break;

            case 6:     // change in the hot mof directory
                {
                    DEBUGTRACE((LOG_WINMGMT,"Got change in the hot mof directory\n"));
                    LoadMofsInDirectory(g_szHotMofDirectory);

                    //Continue to monitor changes
                    if (!FindNextChangeNotification(ghMofDirChange))
                    {
                        DuplicateHandle(GetCurrentProcess(), GetCurrentThread(),
                                        GetCurrentProcess(), &ghMofDirChange,
                                        0, FALSE, DUPLICATE_SAME_ACCESS);
                    }
                }
                break;

            case 7:     // load ctr
            case 8:    // unload ctr

                // Don't start a resync if setup is being run or the noresync switch is set
                if ( !g_fSetup && g_fDoResync )
                {
                    ResyncPerf( hTerminate );
                }
                break;

            case WAIT_TIMEOUT:

                DEBUGTRACE((LOG_WINMGMT,"Got a TIMEOUT work item\n"));
                if(sched.IsWorkItemDue(FirstCoreShutdown))
                {

                    // All the clients have left the core and a decent time interval has passed.  Set the
                    // WINMGMT_CORE_CAN_BACKUP event.  When the core is done, it will set the WINMGMT_CORE_BACKUP_DONE
                    // event which will start the final unloading.

                    DEBUGTRACE((LOG_WINMGMT,"Got a FirstCoreShutdown work item\n"));
                    sched.ClearWorkItem(FirstCoreShutdown);
                    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
                    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
                }
                if(sched.IsWorkItemDue(FinalCoreShutdown))
                {
                    CInMutex im(ghMainMutex);
                    DEBUGTRACE((LOG_WINMGMT,"Got a FinalCoreShutdown work item\n"));
                    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
                    //
                    // HACKHACK: Call it again to make sure that components that
                    // were released by unloading the first one can be unloaded

                    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
                    sched.ClearWorkItem(FinalCoreShutdown);
                    SetProcessWorkingSetSize(GetCurrentProcess(), -1, -1);
                }
                if(sched.IsWorkItemDue(PossibleStartCore))
                {
                    CInMutex im(ghMainMutex);
                    sched.StartCoreIfEssNeeded();
                    sched.ClearWorkItem(PossibleStartCore);
                    SetProcessWorkingSetSize(GetCurrentProcess(), -1, -1);
                }
                break;
        }

    }

}

//***************************************************************************
//  LoadMofsInDirectory
//
// Given a directory, loads all files into the MOF compiler.  If successful
// places the file in a 'good' directory under the given directory, otherwise
// places it in the 'bad' directory under the given directory.
// If the file exists already in the 'good' or 'bad' directory, it will
// first delete the file.
//***************************************************************************
void LoadMofsInDirectory(const TCHAR *szDirectory)
{
    if(CheckGlobalSetupSwitch())
        return;                     // not hot compiling during setup!
    TCHAR *szHotMofDirFF = new TCHAR[lstrlen(szDirectory) + lstrlen(__TEXT("\\*")) + 1];
    if(!szHotMofDirFF)return;
    CDeleteMe<TCHAR> delMe1(szHotMofDirFF);

    TCHAR *szHotMofDirBAD = new TCHAR[lstrlen(szDirectory) + lstrlen(__TEXT("\\bad\\")) + 1];
    if(!szHotMofDirBAD)return;
    CDeleteMe<TCHAR> delMe2(szHotMofDirBAD);

    TCHAR *szHotMofDirGOOD = new TCHAR[lstrlen(szDirectory) + lstrlen(__TEXT("\\good\\")) + 1];
    if(!szHotMofDirGOOD)return;
    CDeleteMe<TCHAR> delMe3(szHotMofDirGOOD);

    IWinmgmtMofCompiler * pCompiler = NULL;

    //Find search parameter
    lstrcpy(szHotMofDirFF, szDirectory);
    lstrcat(szHotMofDirFF, __TEXT("\\*"));

    //Where bad mofs go
    lstrcpy(szHotMofDirBAD, szDirectory);
    lstrcat(szHotMofDirBAD, __TEXT("\\bad\\"));

    //Where good mofs go
    lstrcpy(szHotMofDirGOOD, szDirectory);
    lstrcat(szHotMofDirGOOD, __TEXT("\\good\\"));

    //Make sure directories exist
    WbemCreateDirectory(szDirectory);
    WbemCreateDirectory(szHotMofDirBAD);
    WbemCreateDirectory(szHotMofDirGOOD);

    //Find file...
    WIN32_FIND_DATA ffd;
    HANDLE hFF = FindFirstFile(szHotMofDirFF, &ffd);

    if (hFF != INVALID_HANDLE_VALUE)
    {
        do
        {
            //We only process if this is a file
            if (!(ffd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                //Create a full filename with path
                TCHAR *szFullFilename = new TCHAR[lstrlen(szDirectory) + lstrlen(__TEXT("\\")) + lstrlen(ffd.cFileName) + 1];
                if(!szFullFilename) return;
                CDeleteMe<TCHAR> delMe4(szFullFilename);
                lstrcpy(szFullFilename, szDirectory);
                lstrcat(szFullFilename, __TEXT("\\"));
                lstrcat(szFullFilename, ffd.cFileName);


                TRACE((LOG_WBEMCORE,"Auto-loading MOF %s\n", szFullFilename));

                //We need to hold off on this file until it has been finished writing
                //otherwise the CompileFile will not be able to read the file!
                HANDLE hMof = INVALID_HANDLE_VALUE;
                DWORD dwRetry = 10;
                while (hMof == INVALID_HANDLE_VALUE)
                {
                    hMof = CreateFile(szFullFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

                    //If cannot open yet sleep for a while
                    if (hMof == INVALID_HANDLE_VALUE)
                    {
                        if (--dwRetry == 0)
                            break;
                        Sleep(1000);
                    }
                }

                DWORD dwRetCode;
                WBEM_COMPILE_STATUS_INFO Info;
                DWORD dwAutoRecoverRequired = 0;
                if (hMof == INVALID_HANDLE_VALUE)
                {
                    TRACE((LOG_WBEMCORE,"Auto-loading MOF %s failed because we could not open it for exclusive access\n", szFullFilename));
                    dwRetCode = 1;
                }
                else
                {
                    CloseHandle(hMof);

                    //Load the MOF file
                    WCHAR wPath[MAX_PATH+1];
                    if(szFullFilename)
                    {
#ifdef UNICODE
                        wcsncpy(wPath, szFullFilename, MAX_PATH+1);
#else
                        mbstowcs(wPath, szFullFilename, MAX_PATH);
#endif
                        if (pCompiler == 0)
                        {
                            SCODE sc = CoCreateInstance(CLSID_WinmgmtMofCompiler, 0, CLSCTX_INPROC_SERVER,
                                                                IID_IWinmgmtMofCompiler, (LPVOID *) &pCompiler);
                            if(sc != S_OK)
                                return;
                        }
                        dwRetCode = pCompiler->WinmgmtCompileFile(
                                wPath,
                                NULL,
                                WBEM_FLAG_DONT_ADD_TO_LIST,             // autocomp, check, etc
                                0,
                                0,
                                NULL, NULL, &Info);
                    }
                }
                
                TCHAR *szNewDir = (dwRetCode?szHotMofDirBAD:szHotMofDirGOOD);
                TCHAR *szNewFilename = new TCHAR[lstrlen(szNewDir)  + lstrlen(ffd.cFileName) + 1];
                if(!szNewFilename) return;
                CDeleteMe<TCHAR> delMe5(szNewFilename);

                lstrcpy(szNewFilename, szNewDir);
                lstrcat(szNewFilename, ffd.cFileName);

                //Make sure we have access to delete the old file...
                DWORD dwOldAttribs = GetFileAttributes(szNewFilename);

                if (dwOldAttribs != -1)
                {
                    dwOldAttribs &= ~FILE_ATTRIBUTE_READONLY;
                    SetFileAttributes(szNewFilename, dwOldAttribs);

                    //Move it to directory
                    if (DeleteFile(szNewFilename))
                    {
                        TRACE((LOG_WBEMCORE, "Removing old MOF %s\n", szNewFilename));
                    }
                }
                
                TRACE((LOG_WBEMCORE, "Loading of MOF %s was %s.  Moving to %s\n", szFullFilename, dwRetCode?"unsuccessful":"successful", szNewFilename));
                MoveFile(szFullFilename, szNewFilename);

                //Now mark the file as read only so no one deletes it!!!
                //Like that stops anyone deleting files :-)
                dwOldAttribs = GetFileAttributes(szNewFilename);

                if (dwOldAttribs != -1)
                {
                    dwOldAttribs |= FILE_ATTRIBUTE_READONLY;
                    SetFileAttributes(szNewFilename, dwOldAttribs);
                }

                if ((dwRetCode == 0) && (Info.dwOutFlags & AUTORECOVERY_REQUIRED))
                {
                    //We need to add this item into the registry for auto-recovery purposes
                    TRACE((LOG_WBEMCORE, "MOF %s had an auto-recover pragrma.  Updating registry.\n", szNewFilename));
                    AddToAutoRecoverList(szNewFilename);
                }
            }

        } while (FindNextFile(hFF, &ffd));

        FindClose(hFF);
    }
    if (pCompiler)
        pCompiler->Release();
}


//***************************************************************************
//
//  MyService::MyService
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

MyService::MyService()
{
    m_hStopEvent = CreateEvent(NULL,TRUE,FALSE,NULL);
    m_hBreakPoint = CreateEvent(NULL,TRUE,FALSE,NULL);
    if(m_hStopEvent == NULL || m_hBreakPoint == NULL)
    {
        DEBUGTRACE((LOG_WINMGMT,"MyService could not initialize\n"));
    }
}

//***************************************************************************
//
//  MyService::~MyService
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

MyService::~MyService()
{
    if(m_hStopEvent)
        CloseHandle(m_hStopEvent);
    if(m_hBreakPoint)
        CloseHandle(m_hBreakPoint);
}

//***************************************************************************
//
//  DWORD MyService::WorkerThread
//
//  DESCRIPTION:
//
//  Where the service runs.  In this case, the service just waits for
//  the terminate event to be set.
//
//  RETURN VALUE:
//
//  0
//***************************************************************************

DWORD MyService::WorkerThread()
{
    DEBUGTRACE((LOG_WINMGMT,"Starting service worker thread\n"));
    if(!::Initialize(pr,FALSE))
        return 0;
    WaitingFunction(m_hStopEvent);
    DEBUGTRACE((LOG_WINMGMT,"Stopping service worker thread\n"));
    return 0;
}

//***************************************************************************
//
//  VOID MyService::Log
//
//  DESCRIPTION:
//
//  Gives the service a change to dump out trace messages.
//
//  PARAMETERS:
//
//  lpszMsg             message to be dumped.
//
//***************************************************************************

VOID MyService::Log(
                        IN LPCSTR lpszMsg)
{
    TRACE((LOG_WINMGMT,lpszMsg));
}

//***************************************************************************
//
//  void MyService::UserCode
//
//  DESCRIPTION:
//
//  Not used in this app, it is where user command codes which can be
//  sent to service are handled.
//
//  PARAMETERS:
//
//  nCode               command code.
//
//***************************************************************************

void MyService::UserCode(
                        IN int nCode)
{
    DEBUGTRACE((LOG_WINMGMT,"just got user code of %d\n",nCode));
}


//***************************************************************************
//
//  CForwardFactory::AddRef()
//  CForwardFactory::Release()
//  CForwardFactory::QueryInterface()
//  CForwardFactory::CreateInstance()
//
//  DESCRIPTION:
//
//  Class factory for the exported WbemNTLMLogin interface.  Note that this
//  just serves as a wrapper to the factory inside the core.  The reason for
//  having a wrapper is that the core may not always be loaded.
//
//***************************************************************************

ULONG STDMETHODCALLTYPE CForwardFactory::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

ULONG STDMETHODCALLTYPE CForwardFactory::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

HRESULT STDMETHODCALLTYPE CForwardFactory::QueryInterface(REFIID riid,
                                                            void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IClassFactory)
    {
        *ppv = (IClassFactory*)this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

HRESULT STDMETHODCALLTYPE CForwardFactory::CreateInstance(IUnknown* pUnkOuter,
                            REFIID riid, void** ppv)
{
    DEBUGTRACE((LOG_WINMGMT, "Creating an instance!\n"));
    SCODE sc = S_OK;
    CInMutex im(ghMainMutex);

    try {
    
	    if(gbShuttingDownWinMgmt)
	    {
	        DEBUGTRACE((LOG_WINMGMT, "CreateInstance returned CO_E_SERVER_STOPPING\n"));
	        return CO_E_SERVER_STOPPING;
	    }
	    DWORD dwRes = WaitForSingleObject(ghHoldOffNewClients, 1000);
	    if(dwRes != WAIT_OBJECT_0 && dwRes != WAIT_ABANDONED)
	        return CO_E_SERVER_STOPPING;
	    ReleaseMutex(ghHoldOffNewClients);

	    if(m_ForwardClsid == CLSID_WbemBackupRestore)
	    {
	        CWbemBackupRestore * pObj = new CWbemBackupRestore(ghInstance);
	        if (!pObj)
	            return WBEM_E_OUT_OF_MEMORY;

	        sc = pObj->QueryInterface(riid, ppv);
	        if(FAILED(sc))
	            delete pObj;
	    }
	    else 
	    {
	        sc = CoCreateInstance(CLSID_InProcWbemLevel1Login, NULL,
	                CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER, IID_IUnknown,
	                (void**)ppv);
	        DEBUGTRACE((LOG_WINMGMT, "Inner create returned: 0x%X\n", sc));
	    }
	} 
	catch (...) 
	{
	    ERRORTRACE((LOG_WINMGMT,"---------------\nException thrown from CreateInstance\n-------------\n"));
	    sc = E_NOINTERFACE;
	}
    return sc;
}

HRESULT STDMETHODCALLTYPE CForwardFactory::LockServer(BOOL fLock)
{
    return m_pFactory->LockServer(fLock);
}

CForwardFactory::~CForwardFactory()
{
    if(m_pFactory)
        m_pFactory->Release();
}

//***************************************************************************
//
//  PROG_RESOURCES::PROG_RESOURCES
//
//  DESCRIPTION:
//
//  Constuctor.
//
//***************************************************************************

PROG_RESOURCES::PROG_RESOURCES()
{
    m_hTerminateEvent = NULL;
    m_hExclusive = NULL;
    m_bOleInitialized = FALSE;

    m_pLoginFactory = NULL;
    m_pBackupFactory = NULL;
    m_dwLoginClsFacReg = 0;

};

//***************************************************************************
//
//  void TerminateRunning
//
//  DESCRIPTION:
//
//  Stops another running copy even if it is a service.
//
//***************************************************************************

void TerminateRunning()
{
    DWORD dwFlag = EVENT_MODIFY_STATE;
    if(IsNT())
        dwFlag |= SYNCHRONIZE;
    HANDLE hTerm = OpenEvent(EVENT_MODIFY_STATE,FALSE,
            TEXT("WINMGMT_MARSHALLING_SERVER_TERMINATE"));
    if(hTerm)
    {
        SetEvent(hTerm);
        CloseHandle(hTerm);
    }
    if(IsNT())
	{
        StopService(__TEXT("wmiapsrv"), 15);
        StopService(__TEXT("WinMgmt"), 15);
	}
    return;
}

//***************************************************************************
//
//  void DisplayMessage
//
//  DESCRIPTION:
//
//  Displays a usage message box.
//
//***************************************************************************

void DisplayMessage()
{
    TCHAR tBuff[BUFF_MAX];
    TCHAR tBig[1024];
    tBig[0] = 0;

    UINT ui;
    for(ui = ID1; ui <= ID10; ui++)
    {
        int iRet = LoadString(ghInstance, ui, tBuff, BUFF_MAX);
        if(iRet > 0)
            lstrcat(tBig, tBuff);
    }
    if(lstrlen(tBig) > 0)
        MessageBox(NULL,  tBig,__TEXT("WinMgmt"), MB_OK);

}

//***************************************************************************
//
//  void InitializeLaunchPermissions()
//
//  DESCRIPTION:
//
//  Sets the DCOM Launch permissions.
//
//***************************************************************************

void InitializeLaunchPermissions()
{

    Registry reg(__TEXT("SOFTWARE\\CLASSES\\APPID\\{8bc3f05e-d86b-11d0-a075-00c04fb68820}"));
    if(reg.GetLastError() != 0)
        return;

    // If there already is a SD, then dont overwrite

    BYTE * pData = NULL;
    DWORD dwDataSize = 0;

    int iRet = reg.GetBinary(__TEXT("LaunchPermission"), &pData, &dwDataSize);
    if(iRet == 0)
    {
        delete pData;
        return;
    }

    //  Create a sd with a single entry for launch permissions.

    CNtSecurityDescriptor LaunchPermSD;


    // Create the raw "Everyone" SID
    PSID pRawSid;
    SID_IDENTIFIER_AUTHORITY id = SECURITY_WORLD_SID_AUTHORITY;;

    if(AllocateAndInitializeSid( &id, 1,
        0,0,0,0,0,0,0,0,&pRawSid))
    {

        // Create the class sids for everyone and administrators

        CNtSid SidEveryone(pRawSid);
        FreeSid(pRawSid);
        CNtSid SidAdmins(L"Administrators");
        if(SidEveryone.GetStatus() != 0 || SidEveryone.GetStatus() != 0)
            return;

        // Create a single ACE, and add it to the ACL

        CNtAcl DestAcl;
        CNtAce Users(1, ACCESS_ALLOWED_ACE_TYPE, 0, SidEveryone);
        if(Users.GetStatus() != 0)
            return;
        DestAcl.AddAce(&Users);
        if(DestAcl.GetStatus() != 0)
            return;

        // Set the descresionary acl, and the owner and group sids

        LaunchPermSD.SetDacl(&DestAcl);
        LaunchPermSD.SetOwner(&SidAdmins);
        LaunchPermSD.SetGroup(&SidAdmins);
        if(LaunchPermSD.GetStatus() != 0)
            return;

        // Write it out

        reg.SetBinary(__TEXT("LaunchPermission"), (BYTE *)LaunchPermSD.GetPtr(), LaunchPermSD.GetSize());
    }
}

//***************************************************************************
//
//  AddClsid
//
//  DESCRIPTION:
//
//  Adds a clsid entry during self registration
//
//***************************************************************************

void AddClsid(TCHAR * pszCLSIDGuid, TCHAR * pszAppIDGuid, TCHAR * pszTitle)
{
    Registry rClsid;
    rClsid.Open(HKEY_LOCAL_MACHINE, __TEXT("SOFTWARE\\CLASSES\\CLSID"));
    rClsid.MoveToSubkey(pszCLSIDGuid);
    rClsid.SetStr(NULL, pszTitle);
    rClsid.SetStr(__TEXT("AppId"), pszAppIDGuid);
    if(!IsNT())
        SetCLSIDToExe(pszCLSIDGuid);
}

//***************************************************************************
//
//  SetRestart
//
//  DESCRIPTION:
//
//  win2k services have the ability to be restarted after a crash.  This sets
//  the config mgr for that.
//
//***************************************************************************

void SetRestart(SC_HANDLE sh)
{

    if(!IsW2KOrMore())
        return;

    BOOL (WINAPI *pConfig)( SC_HANDLE, DWORD ,LPVOID);

    HINSTANCE hLib = LoadLibrary(__TEXT("advapi32.dll"));
    if(hLib)
    {
        (FARPROC&)pConfig = GetProcAddress(hLib, "ChangeServiceConfig2W");
        if(pConfig)
        {
            SC_ACTION ac[2];
            ac[0].Type = SC_ACTION_RESTART;
            ac[0].Delay = 60000;
            ac[1].Type = SC_ACTION_RESTART;
            ac[1].Delay = 60000;
            SERVICE_FAILURE_ACTIONS sf;
            sf.dwResetPeriod = 86400;
            sf.lpRebootMsg = NULL;
            sf.lpCommand = NULL;
            sf.cActions = 2;
            sf.lpsaActions = ac;
            pConfig(sh, SERVICE_CONFIG_FAILURE_ACTIONS, &sf);
        }
        FreeLibrary(hLib);
    }}
//***************************************************************************
//
//  SetToAuto
//
//  DESCRIPTION:
//
//  The first time that winmgmt is run as a service after setup, we want to set the service
//  to be automatic.
//
//***************************************************************************

void SetToAuto()
{

    if(g_fSetup)
        return;
    if(!IsNT() )
        return;

    DWORD dwVal = 1;
    Registry rWINMGMT(WBEM_REG_WINMGMT);
    if (rWINMGMT.GetDWORDStr( __TEXT("AlreadySetToAuto"), &dwVal ) == Registry::no_error)
    {
        if(dwVal == 1)
            return;
    }

    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, __TEXT("WinMgmt"), SERVICE_ALL_ACCESS);

        if (schService)
        {

            if(ChangeServiceConfig(  schService,
                  SERVICE_NO_CHANGE ,       // type of service
                  SERVICE_AUTO_START,         // when to start service
                  SERVICE_NO_CHANGE ,      // severity if service fails to start
                  NULL,  // pointer to service binary file name
                  NULL,  // pointer to load ordering group name
                  NULL,  // pointer to variable to get tag identifier
                  NULL,  // pointer to array of dependency names
                  NULL,
                  NULL,  // pointer to password for service account
                  NULL))
            {
                gbRunningAsManualService = FALSE;
                rWINMGMT.SetDWORDStr( __TEXT("AlreadySetToAuto"), 1);
            }
            SetRestart(schService);
            CloseServiceHandle(schService);
        }
        CloseServiceHandle(schSCManager);
    }
}

//***************************************************************************
//
//  int RegServer
//
//  DESCRIPTION:
//
//  Self registers the exe.
//
//***************************************************************************


int RegServer()
{
    TCHAR * pszWbemTitle = __TEXT("Windows Management Instrumentation");
    TCHAR * pszBackupTitle = __TEXT("Windows Management Instrumentation Backup and Recovery");

    TCHAR szMainGuid[128];
    TCHAR szBackupGuid[128];
    CreateNarrowGuidString(CLSID_WbemLevel1Login, szMainGuid);
    CreateNarrowGuidString(CLSID_WbemBackupRestore, szBackupGuid);

    AddClsid(szMainGuid, szMainGuid, pszWbemTitle);
    AddClsid(szBackupGuid, szMainGuid, pszBackupTitle);
    
    //////////////////////////////////////////////////////

    if(!IsNT())
    {
        DWORD dwOpt = GetWin95RestartOption();
        if(dwOpt == -1)
            SetWin95RestartOption(0);
        Registry reg(WBEM_REG_WINMGMT);

        TCHAR * pStr = NULL;
        long lRet = reg.GetStr(__TEXT("EnableAnonConnections"), &pStr);
        if(lRet == 0 && pStr)
            delete pStr;
        else
            reg.SetStr(__TEXT("EnableAnonConnections"), __TEXT("0"));
    }

    Registry rAppid;
    rAppid.Open(HKEY_LOCAL_MACHINE, __TEXT("SOFTWARE\\CLASSES\\APPID"));
    rAppid.MoveToSubkey(szMainGuid);
    rAppid.SetStr(NULL, pszWbemTitle);
    if(IsNT())
    {
        rAppid.SetStr(__TEXT("LocalService"), __TEXT("WinMgmt"));
        InitializeLaunchPermissions();
        Registry rWINMGMT(WBEM_REG_WINMGMT);
        rWINMGMT.SetDWORDStr( __TEXT("AlreadySetToAuto"), 0);
    }
    else
    {
        rAppid.SetStr(__TEXT("RunAs"), __TEXT("Interactive User"));
        rAppid.Open(HKEY_LOCAL_MACHINE, __TEXT("SOFTWARE\\CLASSES\\APPID"));
        rAppid.MoveToSubkey(__TEXT("WinMgmt.EXE"));
        rAppid.SetStr(__TEXT("AppId"), szMainGuid);
    }

    Registry rAppid2;
    rAppid2.Open(HKEY_LOCAL_MACHINE, __TEXT("SOFTWARE\\CLASSES\\APPID"));
    rAppid2.MoveToSubkey(__TEXT("winmgmt.exe"));
    rAppid2.SetStr(__TEXT("AppId"), szMainGuid);


    return 0;
}

//***************************************************************************
//
//  DeleteCLSIDEntry
//
//  DESCRIPTION:
//
//  Removes a CLSID entry.
//
//***************************************************************************

void DeleteCLSIDEntry(TCHAR * szID)
{
    TCHAR  szCLSID[128];
    HKEY hKey;
    lstrcpy(szCLSID, TEXT("SOFTWARE\\CLASSES\\CLSID\\"));
    lstrcat(szCLSID, szID);

    // First delete the InProcServer subkey.

    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, szCLSID, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey, __TEXT("LocalServer32"));
        RegDeleteKey(hKey, __TEXT("InProcServer32"));
        RegCloseKey(hKey);
    }

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, __TEXT("SOFTWARE\\CLASSES\\CLSID"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,szID);
        RegCloseKey(hKey);
    }
}

//***************************************************************************
//
//  int UnregServer
//
//  DESCRIPTION:
//
//  Unregisters the exe.
//
//***************************************************************************

int UnregServer()
{
    // Create the path using the CLSID
    TCHAR szMainGuid[128];
    TCHAR szBackupGuid[128];
    CreateNarrowGuidString(CLSID_WbemLevel1Login, szMainGuid);
    CreateNarrowGuidString(CLSID_WbemBackupRestore, szBackupGuid);

    DeleteCLSIDEntry(szMainGuid);
    DeleteCLSIDEntry(szBackupGuid);

    HKEY hKey;
    DWORD dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, __TEXT("SOFTWARE\\CLASSES\\APPID"), &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,__TEXT("WinMgmt.EXE"));
        RegDeleteKey(hKey,szMainGuid);
        RegCloseKey(hKey);
    }

    if(!IsNT())
    {
        dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, WBEM_REG_WINMGMT, &hKey);
        if(dwRet == NO_ERROR)
        {
            RegDeleteValue(hKey,__TEXT("AutostartWin9X"));
            RegCloseKey(hKey);
        }

        RemoveFromList();
    }
    return 0;
}

BOOL CheckNoResyncSwitch( void )
{
    BOOL bRetVal = TRUE;
    DWORD dwVal = 0;
    Registry rCIMOM(WBEM_REG_WINMGMT);
    if (rCIMOM.GetDWORDStr( WBEM_NORESYNCPERF, &dwVal ) == Registry::no_error)
    {
        bRetVal = !dwVal;

        if ( bRetVal )
        {
            DEBUGTRACE((LOG_WBEMCORE, "NoResyncPerf in CIMOM is set to TRUE - ADAP will not be shelled\n"));
        }
    }

    // If we didn't get anything there, we should try the volatile key
    if ( bRetVal )
    {
        Registry rAdap( HKEY_LOCAL_MACHINE, KEY_READ, WBEM_REG_ADAP);

        if ( rAdap.GetDWORD( WBEM_NOSHELL, &dwVal ) == Registry::no_error )
        {
            bRetVal = !dwVal;

            if ( bRetVal )
            {
                DEBUGTRACE((LOG_WBEMCORE, 
                    "NoShell in ADAP is set to TRUE - ADAP will not be shelled\n"));
            }

        }
    }

    return bRetVal;
}

BOOL CheckSetupSwitch( void )
{
    BOOL bRetVal = FALSE;
    DWORD dwVal = 0;
    Registry r(WBEM_REG_WINMGMT);
    if (r.GetDWORDStr( WBEM_WMISETUP, &dwVal ) == Registry::no_error)
    {
        bRetVal = dwVal;
        DEBUGTRACE((LOG_WBEMCORE, "Registry entry is indicating a setup is running\n"));
    }
    return bRetVal;
}
BOOL CheckGlobalSetupSwitch( void )
{
    BOOL bRetVal = FALSE;
    DWORD dwVal = 0;
    Registry r(_T("system\\Setup"));
    if (r.GetDWORD( _T("SystemSetupInProgress"), &dwVal ) == Registry::no_error)
    {
        if(dwVal == 1)
            bRetVal = TRUE;
    }
    return bRetVal;
}


// This function will place a volatile registry key under the CIMOM key in which we will
// write a value indicating we should not shell ADAP.  This way, after a setup runs, WINMGMT
// will NOT automatically shell ADAP dredges of the registry, until the system is rebooted
// and the volatile registry key is removed.

void SetNoShellADAPSwitch( void )
{
    HKEY    hKey = NULL;
    DWORD   dwDisposition = 0;

    Registry    r( HKEY_LOCAL_MACHINE, REG_OPTION_VOLATILE, KEY_ALL_ACCESS, WBEM_REG_ADAP );

    if ( ERROR_SUCCESS == r.GetLastError() )
    {

        if ( r.SetDWORD( WBEM_NOSHELL, 1 ) != Registry::no_error )
        {
            DEBUGTRACE( ( LOG_WINMGMT, "Failed to create NoShell value in volatile reg key: %d\n",
                        r.GetLastError() ) );
        }

        RegCloseKey( hKey );

    }
    else
    {
        DEBUGTRACE( ( LOG_WINMGMT, "Failed to create volatile ADAP reg key: %d\n", r.GetLastError() ) );
    }

}

//***************************************************************************
//
//  int APIENTRY WinMain
//
//  DESCRIPTION:
//
//  Entry point for windows applications.  If this is running under
//  NT, then this will run as a service, unless the "/EXE" command line
//  argument is used.
//
//  PARAMETERS:
//
//  hInstance           Instance handle
//  hPrevInstance       not used in win32
//  szCmdLine           command line argument
//  nCmdShow            how window is to be shown(ignored)
//
//  RETURN VALUE:
//
//  0
//***************************************************************************

int APIENTRY WinMain(
                        IN HINSTANCE hInstance,
                        IN HINSTANCE hPrevInstance,
                        IN LPSTR szCmdLine,
                        IN int nCmdShow)
{
    // This should not be uninitialized!  It is here to prevent the class factory from being called during
    // shutdown.

    ghMainMutex = CreateMutex(NULL, FALSE, NULL);
    ghInstance = hInstance;
    DEBUGTRACE((LOG_WINMGMT,"Starting WinMgmt, ProcID = %x, CmdLine = %s\n",
        GetCurrentProcessId(), szCmdLine));

    if(szCmdLine && (szCmdLine[0] == '-' || szCmdLine[0] == '/' ))
    {
        if(!_stricmp("RegServer",szCmdLine+1))
            return RegServer();
        else if(!_stricmp("UnregServer",szCmdLine+1))
            return UnregServer();
        else if(!_stricmp("exe",szCmdLine+1))
            gbShowIcon = TRUE;
        else if(!_stricmp("kill",szCmdLine+1))
        {
            TerminateRunning();
            return 0;
        }
        else if (_strnicmp("backup ", szCmdLine+1, strlen("backup ")) == 0)
        {
            return DoBackup();
        }
        else if (_strnicmp("restore ", szCmdLine+1, strlen("restore ")) == 0)
        {
            return DoRestore();
        }
        else if(_strnicmp("resyncperf", szCmdLine+1, strlen("resyncperf")) == 0)
        {
            DoResyncPerf();
            return 0;
        }
        else if(_strnicmp("clearadap", szCmdLine+1, strlen("clearadap")) == 0)
        {
            DoClearAdap();
            return 0;
        }
        else if(_stricmp("EMBEDDING", szCmdLine+1))
        {
            DisplayMessage();
            return 0;
        }
    }

    BOOL bIsService = FALSE;
    if (IsNT())
    {
        DWORD dwServiceReturn = CNtService::IsRunningAsService(bIsService);
        DEBUGTRACE((LOG_WINMGMT,"WinMgmt bIsService = %d, return code from function determining if service = %d\n", bIsService, dwServiceReturn));
    }

    gbRunAsApp = (!IsNT() || gbShowIcon || !bIsService);
    DEBUGTRACE((LOG_WINMGMT,"WinMgmt gbRunAsApp = %d\n", gbRunAsApp));

    if(gbRunAsApp && IsNT())
        SetToRunAsExe();

    if(!gbRunAsApp && IsNT())
        SetToRunAsService();

    // Check if we're performing a setup so we'll know not to perform certain operations if
    // necessary
    g_fSetup = CheckSetupSwitch();

    if ( g_fSetup )
    {
        SetNoShellADAPSwitch();
    }

    // Look in the registry to decide if we will launch a resync perf or not
    g_fDoResync = CheckNoResyncSwitch();

    // Run as either an app or a service.  Note that Cleanup() is called during the WaitingFunction
    // which is used by both apps and services.

    if(gbRunAsApp)
    {
        if(!Initialize(pr,TRUE))
        {
            // if initialization failed and we are running as an app, create
            // the service object with "DieImmediatly" set so that the SCM
            // will be informed of the problem.

            TRACE((LOG_WINMGMT,"Bailing out due to initialization failure\n"));
            Cleanup();
            return 1;
        }

        // run as minimized windows app.

        ghWnd = MyCreateWindow(hInstance);
        WaitingFunction(pr.m_hTerminateEvent);
    }
    else
    {

        // Run as service

        MyService svc;
        if(svc.bOK())
        {
            svc.SetPauseContinue(FALSE);
            DWORD dwRet = svc.Run(__TEXT("WinMgmt"), TRUE);
        }
    }

    return 0;
}

//***************************************************************************
//
//  LRESULT CALLBACK WndProc
//
//  DESCRIPTION:
//
//  Window procedure.
//
//  PARAMETERS:
//
//  hWnd                window handle
//  message             message id
//  wParam              word parameter
//  lParam              long parameter
//
//  RETURN VALUE:
//
//
//***************************************************************************

LRESULT CALLBACK WndProc(
                        IN HWND hWnd,
                        IN UINT message,
                        IN WPARAM wParam,
                        IN LPARAM lParam)
{

    DEBUGTRACE((LOG_WINMGMT,"WindowProc got hWnd=%x, message=%x, wParam=%x, lParam=%x\n",
                hWnd, message, wParam, lParam));

    switch (message) {

        case WM_QUERYOPEN:    //todo, queryend session
            return 0;

        case WM_QUERYENDSESSION:
            DEBUGTRACE((LOG_WINMGMT,"Got QueryEndSession\n"));
            return TRUE;

        case WM_ENDSESSION:
            DEBUGTRACE((LOG_WINMGMT,"Got EndSession\n"));
            if(wParam == TRUE)
            {
                SetEvent(pr.m_hTerminateEvent);
                ShutDownCore(TRUE);
                UpdateTheWin95ServiceList();
            }
            return 0;

        case WM_DESTROY:
            DEBUGTRACE((LOG_WINMGMT,"Got WM_DESTROY\n"));
            PostQuitMessage(0);
            SetEvent(pr.m_hTerminateEvent);
            break;

        default:
            return (DefWindowProc(hWnd, message, wParam, lParam));
    }
    return (0);
}

//***************************************************************************
//
//  HWND MyCreateWindow
//
//  DESCRIPTION:
//
//  Registers the window class, creates the window and shows it.
//
//  PARAMETERS:
//
//  hInstance           app instance handle
//
//  RETURN VALUE:
//
//  main window handle, NULL if error.
//
//***************************************************************************

HWND MyCreateWindow(
                        IN HINSTANCE hInstance)
{
    WNDCLASS wndclass;
    wndclass.style = 0;
    wndclass.lpfnWndProc = WndProc;
    wndclass.cbClsExtra = 0;
    wndclass.cbWndExtra = 0;
    wndclass.hInstance = hInstance;
    wndclass.hIcon = LoadIcon(hInstance, TEXT("WinMgmt"));
    wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
    wndclass.lpszMenuName = NULL;
    wndclass.lpszClassName = TEXT("WINMGMTCLASS");
    if(!RegisterClass(&wndclass))
    {
        TRACE((LOG_WINMGMT,"COULD NOT REGISTER THE WINDOW CLASS\n"));
        return NULL;
    }
    HWND hWnd = CreateWindow(TEXT("WINMGMTCLASS"),
                    TEXT("WINMGMT"),
                    WS_OVERLAPPED | WS_SYSMENU,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    CW_USEDEFAULT,
                    NULL, NULL, hInstance, NULL);
    if(hWnd == NULL)
    {
        TRACE((LOG_WINMGMT,"COULD NOT CREATE THE WINDOW\n"));
        return NULL;
    }

    // This program is visible only for debug builds.

    if(gbShowIcon)
    {
        ShowWindow(hWnd,SW_MINIMIZE);
        UpdateWindow(hWnd);
        HMENU hMenu = GetSystemMenu(hWnd, FALSE);
        if(hMenu)
            DeleteMenu(hMenu, SC_RESTORE, MF_BYCOMMAND);
    }
    return hWnd;

}



//***************************************************************************
//
//  bool InitHotMofStuff
//
//  DESCRIPTION:
//
//  Sets up the hot mof directory and creates an event for it.
//
//  TRUE if OK.
//
//***************************************************************************

bool InitHotMofStuff()
{

    // Get the installation directory

    Registry r1(WBEM_REG_WBEM);

    if (r1.GetStr(__TEXT("MOF Self-Install Directory"), &g_szHotMofDirectory) == Registry::failed)
    {
        // Look for the install directory
        TCHAR * pWorkingDir;

        if (r1.GetStr(__TEXT("Installation Directory"), &pWorkingDir))
        {
            ERRORTRACE((LOG_WINMGMT,"Unable to read 'Installation Directory' from registry\n"));
            return false;
        }

        g_szHotMofDirectory = new TCHAR [lstrlen(pWorkingDir) + lstrlen(__TEXT("\\MOF")) +1];
        if(!g_szHotMofDirectory)return false;
        _stprintf(g_szHotMofDirectory, __TEXT("%s\\MOF"), pWorkingDir);
        delete pWorkingDir;
        if(r1.SetStr(__TEXT("MOF Self-Install Directory"), g_szHotMofDirectory)  == Registry::failed)
        {
            ERRORTRACE((LOG_WINMGMT,"Unable to create 'Hot MOF Directory' in the registry\n"));
            return false;
        }
    }

    // Construct the path to the database.
    // ===================================

    WbemCreateDirectory(g_szHotMofDirectory);


    //Create an event on change notification for the MOF directory

    ghMofDirChange = FindFirstChangeNotification(g_szHotMofDirectory, FALSE, FILE_NOTIFY_CHANGE_FILE_NAME);
    if (ghMofDirChange == INVALID_HANDLE_VALUE)
    {
        DuplicateHandle(GetCurrentProcess(), GetCurrentThread(),
                        GetCurrentProcess(), &ghMofDirChange,
                        0, FALSE, DUPLICATE_SAME_ACCESS);
    }
    return true;
}

//***************************************************************************
//
//  GetServicePricipalName
//
//  DESCRIPTION:
//
//  Used to establish the pricipal name for the kerberos server.  This should be
//  domain\machine name and is put into the pPricipal argument.
//
//***************************************************************************

void GetServicePricipalName(WCHAR * pPrincipal, DWORD dwBuffLen)
{
    NET_API_STATUS (NET_API_FUNCTION *pGetInfo)(
        IN  LMSTR   servername OPTIONAL,
        IN  DWORD   level,
        OUT LPBYTE  *bufptr
        );

    NET_API_STATUS (NET_API_FUNCTION * pFree)(IN LPVOID Buffer);


    HINSTANCE hLib = LoadLibrary(__TEXT("netapi32.dll"));
    if(hLib)
    {
        (FARPROC&)pGetInfo = GetProcAddress(hLib, "NetWkstaGetInfo");
        (FARPROC&)pFree = GetProcAddress(hLib, "NetApiBufferFree");
        if(pGetInfo && pFree)
        {

            LPWKSTA_INFO_100 pBuf = NULL;
            NET_API_STATUS nStatus;
            nStatus = pGetInfo(NULL,  100, (LPBYTE *)&pBuf);
            if (nStatus == NERR_Success)
            {
                DWORD dwLen = wcslen(pBuf->wki100_langroup) + wcslen(pBuf->wki100_computername) + 2;
                if(dwLen <= dwBuffLen)
                {
                    wcscpy(pPrincipal, pBuf->wki100_langroup);
                    wcscat(pPrincipal, L"\\");
                    wcscat(pPrincipal, pBuf->wki100_computername);
                }
                pFree(pBuf);
            }
        }
        FreeLibrary(hLib);
    }
}

//***************************************************************************
//
//  BOOL Initialize
//
//  DESCRIPTION:
//
//  Gets an inproc locator to the gateway, and then loads up each
//  of the transport objects and initializes them.
//
//  PARAMETERS:
//
//  pr                  structure for holding system resources
//  bRunAsApp           set to TRUE if not running as a service
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL Initialize(
                        OUT IN PROG_RESOURCES & pr,
                        IN BOOL bRunAsApp)
{

    // Set the error mode.  This is used to provent the system from putting up dialog boxs to
    // open files

    UINT errormode = SetErrorMode(0);
    errormode |= SEM_NOOPENFILEERRORBOX|SEM_FAILCRITICALERRORS;
    SetErrorMode(errormode);
    RegDisablePredefinedCache();    // special call as per bug wmi 1550


    USES_CONVERSION;
    HKEY hKey;
    int iCnt;
    TCHAR tcName[MAX_PATH+1];
    DEBUGTRACE((LOG_WINMGMT,"Starting Initialize, ID = %x\n", GetCurrentProcessId()));

    if(!InitHotMofStuff())
        return FALSE;

    ghCoreCanUnload = CreateEvent(NULL,FALSE,FALSE,
            TEXT("WINMGMT_COREDLL_CANSHUTDOWN"));

    ghProviderCanUnload = CreateEvent(NULL,FALSE,FALSE,
            TEXT("WINMGMT_PROVIDER_CANSHUTDOWN"));

    ghCoreUnloaded = CreateEvent(NULL,FALSE,FALSE,
            TEXT("WINMGMT_COREDLL_UNLOADED"));

    ghCoreLoaded = CreateEvent(NULL,FALSE,FALSE,
            TEXT("WINMGMT_COREDLL_LOADED"));

    // check if this is running a manual service

    if(IsNT() && bRunAsApp == FALSE)
    {
        SC_HANDLE   schService;
        SC_HANDLE   schSCManager;

        schSCManager = OpenSCManager(
                            NULL,                   // machine (NULL == local)
                            NULL,                   // database (NULL == default)
                            SC_MANAGER_ALL_ACCESS   // access required
                            );
        if ( schSCManager )
        {
            schService = OpenService(schSCManager, __TEXT("WinMgmt"), SERVICE_ALL_ACCESS);

            if (schService)
            {
                DWORD dwNeeded;
                LPQUERY_SERVICE_CONFIG pBuff = NULL;
                long lRet = QueryServiceConfig(
                                schService,
                                NULL, 0, &dwNeeded);
                lRet = GetLastError();
                if(lRet == ERROR_INSUFFICIENT_BUFFER)
                {
                    pBuff = (LPQUERY_SERVICE_CONFIG)new BYTE[dwNeeded];
                    lRet = QueryServiceConfig(
                                schService,
                                pBuff, dwNeeded, &dwNeeded);
                    if(pBuff->dwStartType == SERVICE_DEMAND_START)
                        gbRunningAsManualService = TRUE;

                    delete pBuff;
                }
                CloseServiceHandle(schService);
            }

            CloseServiceHandle(schSCManager);
        }

    }

    pr.m_hTerminateEvent = CreateEvent(NULL,TRUE,FALSE,
        TEXT("WINMGMT_MARSHALLING_SERVER_TERMINATE"));
    if(pr.m_hTerminateEvent == NULL)
    {
        TRACE((LOG_WINMGMT,"WINMGMT terminating because CreateEvent, last error = 0x%x\n",
                GetLastError()));
        return FALSE;
    }

    // Make sure there isnt already a copy running.

    DWORD dwRet;

    pr.m_hExclusive = CreateMutex( NULL, FALSE, TEXT("WINMGMT_MARSHALLING_SERVER"));
    if(pr.m_hExclusive)
        dwRet = WaitForSingleObject(pr.m_hExclusive, 0);
    if(pr.m_hExclusive == NULL || dwRet != WAIT_OBJECT_0)
    {
        if(pr.m_hExclusive)
            CloseHandle(pr.m_hExclusive);
        pr.m_hExclusive = NULL;
        TRACE((LOG_WINMGMT,"WINMGMT terminating an existing copy was detected\n"));
        return FALSE;
    }

    ghNeedRegistration = CreateEvent(NULL,TRUE,FALSE, __TEXT("WINMGMT_NEED_REGISTRATION"));
    SetObjectAccess2(ghNeedRegistration);
    ghRegistrationDone = CreateEvent(NULL,TRUE,FALSE, __TEXT("WINMGMT_REGISTRATION_DONE"));
    SetObjectAccess2(ghRegistrationDone);

    ghLoadCtrEvent = CreateEvent(NULL, FALSE, FALSE, __TEXT("WMI_SysEvent_LodCtr"));
    ghUnloadCtrEvent = CreateEvent(NULL, FALSE, FALSE, __TEXT("WMI_SysEvent_UnLodCtr"));

    ghHoldOffNewClients = CreateMutex(NULL, FALSE, __TEXT("WINMGMT_KEEP_NEW_CLIENTS_AT_BAY")); 
    if(ghHoldOffNewClients == NULL)
        ghHoldOffNewClients = OpenMutex(SYNCHRONIZE, FALSE, __TEXT("WINMGMT_KEEP_NEW_CLIENTS_AT_BAY")); 

    if(ghNeedRegistration == NULL || ghRegistrationDone == NULL || 
       ghLoadCtrEvent == NULL || ghUnloadCtrEvent == NULL ||
       ghHoldOffNewClients == NULL)
    {
        TRACE((LOG_WINMGMT,"WINMGMT couldnt create the sync objects\n"));
        return FALSE;
    }

    SetObjectAccess2(ghLoadCtrEvent);
    SetObjectAccess2(ghUnloadCtrEvent);

    // Initialize Ole

    SCODE sc;

    sc = InitializeCom();
    if(sc != S_OK)
    {
        TRACE((LOG_WINMGMT,"WINMGMT Could not initialize Ole\n"));
        return FALSE;
    }
    pr.m_bOleInitialized = TRUE;

    // Initialize server security
    // ==========================

    if(IsStandAloneWin9X())
        sc = InitializeSecurity(NULL, -1, NULL, NULL,
                                RPC_C_AUTHN_LEVEL_NONE,
                                RPC_C_IMP_LEVEL_IDENTIFY,
                                NULL, EOAC_NONE, 0);
    else if(IsKerberosAvailable())
    {
        // Following is EOAC_STATIC_CLOAKING
        DWORD dwCloaking = 0x20;
        sc = InitializeSecurity(NULL, -1, NULL, NULL,
                                RPC_C_AUTHN_LEVEL_CONNECT,
                                RPC_C_IMP_LEVEL_IDENTIFY,
                                NULL,
                                dwCloaking,     // Static cloaking.  The constant isn't in the current headers
                                0);
    }
    else
        sc = InitializeSecurity(NULL, -1, NULL, NULL,
                                RPC_C_AUTHN_LEVEL_CONNECT,
                                RPC_C_IMP_LEVEL_IDENTIFY,
                                NULL,0,0);
    if(FAILED(sc))
    {
        TRACE((LOG_WINMGMT,"WINMGMT Could not initialize security: %X\n", sc));
    }
    else if(sc == S_FALSE)
    {
        DEBUGTRACE((LOG_WINMGMT,"NT 3.51: running without security\n"));
    }

    DWORD dwFlags = CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER;
    if(IsDcomEnabled())
        dwFlags |= CLSCTX_REMOTE_SERVER;

    pr.m_pLoginFactory = new CForwardFactory(CLSID_InProcWbemLevel1Login);
    pr.m_pLoginFactory->AddRef();

    sc = CoRegisterClassObject(CLSID_WbemLevel1Login, pr.m_pLoginFactory,
                                dwFlags,
                                REGCLS_MULTIPLEUSE, &pr.m_dwLoginClsFacReg);
    if(sc != S_OK)
    {
        TRACE((LOG_WINMGMT,"Failed to register the "
                            "CLSID_WbemLevel1Login class factory, "
                            "sc = 0x%x\n", sc));
        return FALSE;
    }
    else
    {
        DEBUGTRACE((LOG_WINMGMT, "Registered class factory with flags: 0x%X\n",
                dwFlags));
    }
    pr.m_pBackupFactory = new CForwardFactory(CLSID_WbemBackupRestore);
    pr.m_pBackupFactory->AddRef();

    sc = CoRegisterClassObject(CLSID_WbemBackupRestore, pr.m_pBackupFactory,
                                dwFlags,
                                REGCLS_MULTIPLEUSE, &pr.m_dwBackupClsFacReg);
    if(sc != S_OK)
    {
        TRACE((LOG_WINMGMT,"Failed to register the "
                            "Backup/recovery class factory, "
                            "sc = 0x%x\n", sc));
        return FALSE;
    }

    // Get the registry key which is the root for all the transports.
    // ==============================================================

    long lRet = RegOpenKey(HKEY_LOCAL_MACHINE,
                        TEXT("Software\\Microsoft\\WBEM\\CIMOM\\TRANSPORTS"),
                        &hKey);
    if(lRet != ERROR_SUCCESS)
    {
        DEBUGTRACE((LOG_WINMGMT,"RegOpenKey returned 0x%x while trying to open the transports node.  Using default transports!\n",lRet));
    }
    else
    {
        // Loop through each transport subkey.
        // ===================================

        for(iCnt = 0;ERROR_SUCCESS == RegEnumKey(hKey,iCnt,tcName,MAX_PATH+1);
                                                    iCnt++)
        {
            HKEY hSubKey;
            lRet = RegOpenKey(hKey,tcName,&hSubKey);
            if(lRet != ERROR_SUCCESS)
                continue;
            DWORD bytecount = sizeof(DWORD);
            DWORD dwType;

            // If the Enabled value isnt 1, then the transport is disabled
            // and is ignored.
            // ===========================================================

            char cTemp[20];
            bytecount=20;
            lRet = RegQueryValueEx(hSubKey, TEXT("Enabled"), NULL, &dwType,
                    (LPBYTE) cTemp, &bytecount);
            if(lRet != ERROR_SUCCESS || dwType != REG_SZ || cTemp[0] != '1')
            {
                RegCloseKey(hSubKey);
                continue;
            }

            // Read the CLSID string and convert it into an CLSID structure.
            // =============================================================

            WCHAR wszCLSID[50];
            char szCLSID[100];
            bytecount = 100;
            lRet = RegQueryValueEx(hSubKey, TEXT("CLSID"), NULL, &dwType,
                    (LPBYTE) &szCLSID, &bytecount);

            RegCloseKey(hSubKey);
            if(lRet != ERROR_SUCCESS)
            {
                continue;
            }

            CLSID clsid;

            // Convert to WCS depending on if UNICODE is defined, since
            // the data will be returned as an ANSI or UNICODE string
#ifndef UNICODE
            wcscpy( wszCLSID, (WCHAR*) szCLSID );
#else
            mbstowcs( wszCLSID, szCLSID, strlen( szCLSID ) + 1 );
#endif

            sc = CLSIDFromString( wszCLSID, &clsid);
            if(sc != S_OK)
            {
                continue;
            }

            // Load up the transport object and then initialize it.
            // ====================================================

            IWbemTransport * pTransport =  NULL;
            sc = CoCreateInstance(clsid, 0, CLSCTX_INPROC_SERVER,
                        IID_IWbemTransport, (LPVOID *) &pTransport);
            if(sc != S_OK || pTransport == NULL)
            {
                continue;
            }

            sc = pTransport->Initialize();
            if(sc != S_OK)
                pTransport->Release();
            else
                pr.m_Array.Add(pTransport);     // add it to the list
        }

        RegCloseKey(hKey);
    }
    
    DEBUGTRACE((LOG_WINMGMT,"Initialize complete\n"));

    // TO BE REPLACED WITH PROPER CODING --- FORCE CORE
    // ================================================

    return TRUE;
}

//***************************************************************************
//
//  void Cleanup
//
//  DESCRIPTION:
//
//  Release any currently loaded transports and close Ole etc.
//
//  PARAMETERS:
//
//***************************************************************************

void Cleanup()
{
    int iCnt;

    DEBUGTRACE((LOG_WINMGMT,"Starting cleanup, ID = %x\n", GetCurrentProcessId()));
    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;
    CoFreeUnusedLibrariesEx ( CORE_PROVIDER_UNLOAD_TIMEOUT , 0 ) ;

    // make sure this is called just once

    static iNumCalled = 0;
    if(iNumCalled > 0)
        return;
    iNumCalled++;

    for(iCnt = 0; iCnt < pr.m_Array.Size(); iCnt++)
    {
        IWbemTransport* pCurr = (IWbemTransport *)pr.m_Array.GetAt(iCnt);
        if(pCurr)
            pCurr->Release();
    }

    if(ghCoreCanUnload)
        CloseHandle(ghCoreCanUnload);
    if(ghProviderCanUnload)
        CloseHandle(ghProviderCanUnload);
    if(ghCoreUnloaded)
        CloseHandle(ghCoreUnloaded);
    if(ghCoreLoaded)
        CloseHandle(ghCoreLoaded);

    if(ghNeedRegistration)
        CloseHandle(ghNeedRegistration);
    if(ghRegistrationDone)
        CloseHandle(ghRegistrationDone);
    if(ghMofDirChange)
        CloseHandle(ghMofDirChange);

    if(ghLoadCtrEvent)
        CloseHandle(ghLoadCtrEvent);
    if(ghUnloadCtrEvent)
        CloseHandle(ghUnloadCtrEvent);

    if(ghHoldOffNewClients)
        CloseHandle(ghHoldOffNewClients);

    if(pr.m_hTerminateEvent)
        CloseHandle(pr.m_hTerminateEvent);
    if(pr.m_hExclusive)
    {
        ReleaseMutex(pr.m_hExclusive);
        CloseHandle(pr.m_hExclusive);
    }

    if(g_szHotMofDirectory)
        delete g_szHotMofDirectory;

    // If the core is still loaded, call its shutdown function

    ShutDownCore(TRUE);

    if(pr.m_pLoginFactory) {
        CoRevokeClassObject(pr.m_dwLoginClsFacReg);
        pr.m_pLoginFactory->Release();
        pr.m_pLoginFactory = NULL;
    }
    if(pr.m_pBackupFactory) {
        CoRevokeClassObject(pr.m_dwBackupClsFacReg);
        pr.m_pBackupFactory->Release();
        pr.m_pBackupFactory = NULL;
    }


    if(pr.m_bOleInitialized)
        OleUninitialize();

    if(IsNT() && gbSetToRunAsApp)
        SetToRunAsService();

    UpdateTheWin95ServiceList();
    if(IsNT())
        RegCloseKey(HKEY_PERFORMANCE_DATA);

    DEBUGTRACE((LOG_WINMGMT,"Ending cleanup\n"));
    return;
}








//***************************************************************************
//
//  bool IsValidMulti
//
//  DESCRIPTION:
//
//  Does a sanity check on a multstring.
//
//  PARAMETERS:
//
//  pMultStr        Multistring to test.
//  dwSize          size of multistring
//
//  RETURN:
//
//  true if OK
//
//***************************************************************************

bool IsValidMulti(TCHAR * pMultStr, DWORD dwSize)
{
    // Divide the size by the size of a tchar, in case these
    // are Widestrings
    dwSize /= sizeof(TCHAR);

    if(pMultStr && dwSize >= 2 && pMultStr[dwSize-2]==0 && pMultStr[dwSize-1]==0)
        return true;
    return false;
}

//***************************************************************************
//
//  bool IsStringPresetn
//
//  DESCRIPTION:
//
//  Searches a multstring for the presense of a string.
//
//  PARAMETERS:
//
//  pTest           String to look for.
//  pMultStr        Multistring to test.
//
//  RETURN:
//
//  true if string is found
//
//***************************************************************************

bool IsStringPresent(TCHAR * pTest, TCHAR * pMultStr)
{
    TCHAR * pTemp;
    for(pTemp = pMultStr; *pTemp; pTemp += lstrlen(pTemp) + 1)
        if(!lstrcmpi(pTest, pTemp))
            return true;
    return false;
}

//***************************************************************************
//
//  void AddToAutoRecoverList
//
//  DESCRIPTION:
//
//  Adds the file to the autocompile list, if it isnt already on it.
//
//  PARAMETERS:
//
//  pFileName           File to add
//
//***************************************************************************

void AddToAutoRecoverList(TCHAR * pFileName)
{
    TCHAR cFullFileName[MAX_PATH+1];
    TCHAR * lpFile;
    DWORD dwSize;
    TCHAR * pNew = NULL;
    TCHAR * pTest;
    DWORD dwNewSize = 0;

    // Get the full file name

    long lRet = GetFullPathName(pFileName, MAX_PATH, cFullFileName, &lpFile);
    if(lRet == 0)
        return;

    bool bFound = false;
    Registry r(WBEM_REG_WINMGMT);
    TCHAR *pMulti = r.GetMultiStr(__TEXT("Autorecover MOFs"), dwSize);

    // Ignore the empty string case

    if(dwSize == 1)
    {
        delete pMulti;
        pMulti = NULL;
    }
    if(pMulti)
    {
        if(!IsValidMulti(pMulti, dwSize))
        {
            delete pMulti;
            return;             // bail out, messed up multistring
        }
        bFound = IsStringPresent(cFullFileName, pMulti);
        if(!bFound)
            {

            // The registry entry does exist, but doesnt have this name
            // Make a new multistring with the file name at the end

            dwNewSize = dwSize + ((lstrlen(cFullFileName) + 1) * sizeof(TCHAR));
            pNew = new TCHAR[dwNewSize / sizeof(TCHAR)];
            if(!pNew)
                return;
            memcpy(pNew, pMulti, dwSize);

            // Find the double null

            for(pTest = pNew; pTest[0] || pTest[1]; pTest++);     // intentional semi

            // Tack on the path and ensure a double null;

            pTest++;
            lstrcpy(pTest, cFullFileName);
            pTest+= lstrlen(cFullFileName)+1;
            *pTest = 0;         // add second numm
        }
    }
    else
    {
        // The registry entry just doesnt exist.  Create it with a value equal to our name

        dwNewSize = ((lstrlen(cFullFileName) + 2) * sizeof(TCHAR));
        pNew = new TCHAR[dwNewSize / sizeof(TCHAR)];
        if(!pNew)
            return;
        lstrcpy(pNew, cFullFileName);
        pTest = pNew + lstrlen(pNew) + 1;
        *pTest = 0;         // add second null
    }

    if(pNew)
    {
        // We will cast pNew, since the underlying function will have to cast to
        // LPBYTE and we will be WCHAR if UNICODE is defined
        r.SetMultiStr(__TEXT("Autorecover MOFs"), pNew, dwNewSize);
        delete pNew;
    }

    FILETIME ftCurTime;
    LARGE_INTEGER liCurTime;
    TCHAR szBuff[50];
    GetSystemTimeAsFileTime(&ftCurTime);
    liCurTime.LowPart = ftCurTime.dwLowDateTime;
    liCurTime.HighPart = ftCurTime.dwHighDateTime;
    _ui64tot(liCurTime.QuadPart, szBuff, 10);
    r.SetStr(__TEXT("Autorecover MOFs timestamp"), szBuff);

}

HRESULT GetRepPath(wchar_t wcsPath[MAX_PATH+1], wchar_t * wcsName)
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if(lRes)
        return WBEM_E_FAILED;

    wchar_t wszTmp[MAX_PATH+1];
    DWORD dwLen = MAX_PATH+1;
    lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL, 
                (LPBYTE)(wchar_t*)wszTmp, &dwLen);
	RegCloseKey(hKey);
    if(lRes)
        return WBEM_E_FAILED;

	if (ExpandEnvironmentStringsW(wszTmp, wcsPath, MAX_PATH+1) == 0)
		return WBEM_E_FAILED;

    if (wcsPath[wcslen(wcsPath)] != L'\\')
        wcscat(wcsPath, L"\\");

    wcscat(wcsPath, wcsName);

    return WBEM_S_NO_ERROR;

}

int DoBackup()
{
	int hr = WBEM_S_NO_ERROR;

    //*************************************************
    // Split up command line and validate parameters
    //*************************************************
    wchar_t *wszCommandLine = GetCommandLineW();
    if (wszCommandLine == NULL)
    {
        DisplayWbemError(hr, ID_ERROR_LONG, ID_ERROR_SHORT, ID_BACKUP_TITLE);
        hr = WBEM_E_OUT_OF_MEMORY;
    }



	// !!!!! ***** temporarily disabled until SVCHOST changes are checked in ***** !!!!!
	hr = WBEM_E_NOT_SUPPORTED;
	DisplayWbemError(hr, ID_ERROR_LONG, ID_ERROR_SHORT, ID_BACKUP_TITLE);



    int nNumArgs = 0;
    wchar_t **wszCommandLineArgv = NULL;

    if (SUCCEEDED(hr))
    {
        wszCommandLineArgv = CommandLineToArgvW(wszCommandLine, &nNumArgs);

        if ((wszCommandLineArgv == NULL) || (nNumArgs != 3))
        {
            hr = WBEM_E_INVALID_PARAMETER;
            DisplayMessage();
        }
    }

    //wszCommandLineArgv[0] = winmgmt.exe
    //wszCommandLineArgv[1] = /backup
    //wszCommandLineArgv[2] = <backup filename>

    if (SUCCEEDED(hr))
    {
        InitializeCom();
        IWbemBackupRestore* pBackupRestore = NULL;
        hr = CoCreateInstance(CLSID_WbemBackupRestore, 0, CLSCTX_LOCAL_SERVER,
                            IID_IWbemBackupRestore, (LPVOID *) &pBackupRestore);
        if (SUCCEEDED(hr))
        {
			EnableAllPrivileges(TOKEN_PROCESS);
            hr = pBackupRestore->Backup(wszCommandLineArgv[2], 0);

            if (FAILED(hr))
            {
                DisplayWbemError(hr, ID_ERROR_LONG, ID_ERROR_SHORT, ID_BACKUP_TITLE);
				hr = WBEM_E_FAILED;
            }

            pBackupRestore->Release();
        }
        CoUninitialize();
    }

	return hr;
}

int DoRestore()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    //*************************************************
    // Split up command line and validate parameters
    //*************************************************
    wchar_t *wszCommandLine = GetCommandLineW();
    if (wszCommandLine == NULL)
        hr = WBEM_E_OUT_OF_MEMORY;




	// !!!!! ***** temporarily disabled until SVCHOST changes are checked in ***** !!!!!
	hr = WBEM_E_NOT_SUPPORTED;
	DisplayWbemError(hr, ID_ERROR_LONG, ID_ERROR_SHORT, ID_BACKUP_TITLE);




    int nNumArgs = 0;
    wchar_t **wszCommandLineArgv = NULL;

    if (SUCCEEDED(hr))
    {
        wszCommandLineArgv = CommandLineToArgvW(wszCommandLine, &nNumArgs);

        if ((wszCommandLineArgv == NULL) || (nNumArgs != 4))
        {
            hr = WBEM_E_INVALID_PARAMETER;
        }
    }

    //wszCommandLineArgv[0] = winmgmt.exe
    //wszCommandLineArgv[1] = /restore
    //wszCommandLineArgv[2] = <restore filename>
    //wszcommandLineArgv[3] = <restore options>

    if (SUCCEEDED(hr))
    {
        if ((wcscmp(wszCommandLineArgv[3], L"0") != 0) &&
            (wcscmp(wszCommandLineArgv[3], L"1") != 0))
        {
            hr = WBEM_E_INVALID_PARAMETER;
        }
    }

    long lFlags = 0;
    
    if (SUCCEEDED(hr))
    {
        lFlags = (long) (*wszCommandLineArgv[3] - L'0');
    }

    //**************************************************
	// Check that the user has the proper security
    //**************************************************
//	if (SUCCEEDED(hr))
//	{
//		EnableAllPrivileges(TOKEN_PROCESS);
//		if(!CheckSecurity(SE_RESTORE_NAME))
//			hr = WBEM_E_ACCESS_DENIED;
//	}

    //**************************************************
    // Check that <restore filename> is a valid filename
    //**************************************************
	DWORD dwAttributes = 0;
    
    if (SUCCEEDED(hr))
    {
        dwAttributes = GetFileAttributesW(wszCommandLineArgv[2]);
        if (dwAttributes == -1)
        {
            //File does not exist...
            hr = WBEM_E_INVALID_PARAMETER;
        }
	    else
	    {
		    // The file already exists -- create mask of the attributes that would make an existing file invalid for use
		    DWORD dwMask =	FILE_ATTRIBUTE_DEVICE |
						    FILE_ATTRIBUTE_DIRECTORY |
						    FILE_ATTRIBUTE_OFFLINE |
						    FILE_ATTRIBUTE_REPARSE_POINT |
						    FILE_ATTRIBUTE_SPARSE_FILE;

		    if (dwAttributes & dwMask)
			    hr = WBEM_E_INVALID_PARAMETER;
	    }
    }

    //**************************************************
    // Shutdown main WinMgmt process if it is running
    // and make sure it does not start up while we are
    // preparing to restore...
    //**************************************************
    bool bShutdown = false;
    int nRetryCount = 20;
    HANDLE hExclusiveMutex = 0;

    if (SUCCEEDED(hr))
    {
        while (!bShutdown && nRetryCount--)
        {
            hExclusiveMutex = CreateMutex( NULL, FALSE, TEXT("WINMGMT_MARSHALLING_SERVER"));
            DWORD dwWait;
            if (hExclusiveMutex != 0)
                dwWait = WaitForSingleObject(hExclusiveMutex, 0);
            if(hExclusiveMutex == NULL || ( dwWait != WAIT_OBJECT_0))
            {
                if(hExclusiveMutex)
                    CloseHandle(hExclusiveMutex);
                if (lFlags & WBEM_FLAG_BACKUP_RESTORE_FORCE_SHUTDOWN)
                {
                    TerminateRunning();
                    Sleep(3000);
                }
                else
                {
                    hr = WBEM_E_BACKUP_RESTORE_WINMGMT_RUNNING;
                    break;
                }
            }
            else
                bShutdown = true;
        }

        if (!nRetryCount && !bShutdown)
            hr = WBEM_E_TIMED_OUT;
    }

    //**************************************************
    //Now we need to delete the existing database
    //**************************************************
    if (SUCCEEDED(hr))
    {
        hr = DoDeleteRepository(wszCommandLineArgv[2]);
    }

    //**************************************************
    //Now we need to copy over the <restore file> into
    //the repository directory
    //**************************************************
    wchar_t szRecoveryActual[MAX_PATH+1] = { 0 };
    
    if (SUCCEEDED(hr))
        hr = GetRepPath(szRecoveryActual, L"repdrvfs.rec");

    if (SUCCEEDED(hr))
    {
        if(_wcsicmp(szRecoveryActual, wszCommandLineArgv[2]))
        {
            DeleteFileW(szRecoveryActual);
	        CopyFileW(wszCommandLineArgv[2], szRecoveryActual, FALSE);
        }
    }


    //**************************************************
    //We need to release the exclusive mutex so that
    //we can successfully connect to winmgmt
    //**************************************************
    if (hExclusiveMutex)
        CloseHandle(hExclusiveMutex);

    if (SUCCEEDED(hr))
    {
        //**************************************************
        //Connecting to winmgmt will now result in this 
        //backup file getting loaded
        //**************************************************
        InitializeCom();

        {   //Scoping for destruction of COM objects before CoUninitialize!
            IWbemLocator *pLocator = NULL;
            hr = CoCreateInstance(CLSID_WbemLocator,NULL, CLSCTX_ALL, IID_IWbemLocator,(void**)&pLocator);
            CReleaseMe relMe(pLocator);

            if (SUCCEEDED(hr))
            {
                IWbemServices *pNamespace = NULL;
                BSTR tmpStr = SysAllocString(L"root");
                CSysFreeMe sysFreeMe(tmpStr);

                hr = pLocator->ConnectServer(tmpStr, NULL, NULL, NULL, NULL, NULL, NULL, &pNamespace);
                CReleaseMe relMe4(pNamespace);
            }
        }

        CoUninitialize();
    }

    //Delete the restore file
    if (*szRecoveryActual)
        DeleteFileW(szRecoveryActual);

    //**************************************************
    //All done!
    //**************************************************
    return hr;
}

void DisplayWbemError(HRESULT hresError, DWORD dwLongFormatString, DWORD dwShortFormatString, DWORD dwTitle)
{
    WCHAR szError[2096];
    szError[0] = 0;
    WCHAR szFacility[2096];
    szFacility[0] = 0;
    TCHAR szMsg[2096];
    TCHAR szFormat[100];
    TCHAR szTitle[100];
    IWbemStatusCodeText * pStatus = NULL;

    SCODE sc = CoCreateInstance(CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
                                        IID_IWbemStatusCodeText, (LPVOID *) &pStatus);
    
    if(sc == S_OK)
    {
        BSTR bstr = 0;
        sc = pStatus->GetErrorCodeText(hresError, 0, 0, &bstr);
        if(sc == S_OK)
        {
            wcsncpy(szError, bstr, 2096-1);
            SysFreeString(bstr);
            bstr = 0;
        }
        sc = pStatus->GetFacilityCodeText(hresError, 0, 0, &bstr);
        if(sc == S_OK)
        {
            wcsncpy(szFacility, bstr, 2096-1);
            SysFreeString(bstr);
            bstr = 0;
        }
        pStatus->Release();
    }
    if(wcslen(szFacility) == 0 || wcslen(szError) == 0)
    {
        LoadString(GetModuleHandle(NULL), dwShortFormatString, szFormat, 99);
        _stprintf(szMsg, szFormat, hresError);
    }
    else
    {
        LoadString(GetModuleHandle(NULL), dwLongFormatString, szFormat, 99);
        _stprintf(szMsg, szFormat, hresError, szFacility, szError);
    }

    LoadString(GetModuleHandle(NULL), dwTitle, szTitle, 99);
    MessageBox(0, szMsg, szTitle, MB_ICONERROR | MB_OK);
}

void DoResyncPerf()
{
    PROCESS_INFORMATION pi;
    STARTUPINFO si;
    memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);
	// make a writable buffer
	TCHAR pExecName[(1+sizeof(_T("WMIADAP.EXE /F")))/sizeof(TCHAR)];
	lstrcpy(pExecName,_T("WMIADAP.EXE /F"));

	if ( CreateProcess( NULL, pExecName, NULL, NULL, FALSE, CREATE_NO_WINDOW,
			      NULL, NULL,  &si, &pi ) )
	{
        // Cleanup handles right away
		// ==========================
        CloseHandle( pi.hThread );
        CloseHandle( pi.hProcess );
	}

    return;
}

void DoClearAdap()
{
	PROCESS_INFORMATION pi;
	STARTUPINFO si;
	memset(&si, 0, sizeof(si));
	si.cb = sizeof(si);
	// make a writable buffer
	TCHAR pExecName[(1+sizeof(_T("WMIADAP.EXE /C")))/sizeof(TCHAR)];
	lstrcpy(pExecName,_T("WMIADAP.EXE /C"));

	if ( CreateProcess( NULL, pExecName, NULL, NULL, FALSE, CREATE_NO_WINDOW,
				  NULL, NULL,  &si, &pi) )
	{
        // Cleanup handles right away
		// ==========================
        CloseHandle( pi.hThread );
        CloseHandle( pi.hProcess );
	}

    return;
}

/******************************************************************************
 *
 *	GetRepositoryDirectory
 *
 *	Description:
 *		Retrieves the location of the repository directory from the registry.
 *
 *	Parameters:
 *		wszRepositoryDirectory:	Array to store location in.
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT GetRepositoryDirectory(wchar_t wszRepositoryDirectory[MAX_PATH+1])
{
    HKEY hKey;
    long lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, 
                    L"SOFTWARE\\Microsoft\\WBEM\\CIMOM",
                    0, KEY_READ, &hKey);
    if(lRes)
        return WBEM_E_FAILED;

    wchar_t wszTmp[MAX_PATH + 1];
    DWORD dwLen = MAX_PATH + 1;
    lRes = RegQueryValueExW(hKey, L"Repository Directory", NULL, NULL, 
                (LPBYTE)wszTmp, &dwLen);
	RegCloseKey(hKey);
    if(lRes)
        return WBEM_E_FAILED;

	if (ExpandEnvironmentStringsW(wszTmp,wszRepositoryDirectory, MAX_PATH + 1) == 0)
		return WBEM_E_FAILED;

	return WBEM_S_NO_ERROR;
}

/******************************************************************************
 *
 *	CRepositoryPackager::DeleteRepository
 *
 *	Description:
 *		Delete all files and directories under the repository directory.
 *		The repository directory location is retrieved from the registry.
 *
 *	Parameters:
 *		<none>
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT DoDeleteRepository(const wchar_t *wszExcludeFile)
{
	HRESULT hres = WBEM_S_NO_ERROR;
	wchar_t wszRepositoryDirectory[MAX_PATH+1];

	//Get the root directory of the repository
	hres = GetRepositoryDirectory(wszRepositoryDirectory);

	if (SUCCEEDED(hres))
	{
		hres = DoDeleteContentsOfDirectory(wszExcludeFile, wszRepositoryDirectory);
	}
	
	return hres;
}

/******************************************************************************
 *
 *	DoDeleteContentsOfDirectory
 *
 *	Description:
 *		Given a directory, iterates through all files and directories and
 *		calls into the function to delete it.
 *
 *	Parameters:
 *		wszRepositoryDirectory:	Directory to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT DoDeleteContentsOfDirectory(const wchar_t *wszExcludeFile, const wchar_t *wszRepositoryDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;

	wchar_t *wszFullFileName = new wchar_t[MAX_PATH+1];
	if (wszFullFileName == NULL)
		return WBEM_E_OUT_OF_MEMORY;

	WIN32_FIND_DATAW findFileData;
	HANDLE hff = INVALID_HANDLE_VALUE;

	//create file search pattern...
	wchar_t *wszSearchPattern = new wchar_t[MAX_PATH+1];
	if (wszSearchPattern == NULL)
		hres = WBEM_E_OUT_OF_MEMORY;
	else
	{
		wcscpy(wszSearchPattern, wszRepositoryDirectory);
		wcscat(wszSearchPattern, L"\\*");
	}

	//Start the file iteration in this directory...
	if (SUCCEEDED(hres))
	{
		hff = FindFirstFileW(wszSearchPattern, &findFileData);
		if (hff == INVALID_HANDLE_VALUE)
		{
			hres = WBEM_E_FAILED;
		}
	}
	
	if (SUCCEEDED(hres))
	{
		do
		{
			//If we have a filename of '.' or '..' we ignore it...
			if ((wcscmp(findFileData.cFileName, L".") == 0) ||
				(wcscmp(findFileData.cFileName, L"..") == 0))
			{
				//Do nothing with these...
			}
			else if (findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				//This is a directory, so we need to deal with that...
				hres = DoDeleteDirectory(wszExcludeFile, wszRepositoryDirectory, findFileData.cFileName);
				if (FAILED(hres))
					break;
			}
			else
			{
				//This is a file, so we need to deal with that...
				wcscpy(wszFullFileName, wszRepositoryDirectory);
				wcscat(wszFullFileName, L"\\");
				wcscat(wszFullFileName, findFileData.cFileName);

                //Make sure this is not the excluded filename...
                if (_wcsicmp(wszFullFileName, wszExcludeFile) != 0)
                {
				    if (!DeleteFileW(wszFullFileName))
				    {
					    hres = WBEM_E_FAILED;
					    break;
				    }
                }
			}
			
		} while (FindNextFileW(hff, &findFileData));
	}
	
	if (wszSearchPattern)
		delete [] wszSearchPattern;

	if (hff != INVALID_HANDLE_VALUE)
		FindClose(hff);

	return hres;
}

/******************************************************************************
 *
 *	DoDeleteDirectory
 *
 *	Description:
 *		This is the code which processes a directory.  It iterates through
 *		all files and directories in that directory.
 *
 *	Parameters:
 *		wszParentDirectory:	Full path of parent directory
 *		eszSubDirectory:	Name of sub-directory to process
 *
 *	Return:
 *		HRESULT:		WBEM_S_NO_ERROR			If successful
 *						WBEM_E_OUT_OF_MEMORY	If out of memory
 *						WBEM_E_FAILED			If anything else failed
 *
 ******************************************************************************
 */
HRESULT DoDeleteDirectory(const wchar_t *wszExcludeFile, const wchar_t *wszParentDirectory, wchar_t *wszSubDirectory)
{
	HRESULT hres = WBEM_S_NO_ERROR;

	//Get full path of new directory...
	wchar_t *wszFullDirectoryName = NULL;
	if (SUCCEEDED(hres))
	{
		wszFullDirectoryName = new wchar_t[MAX_PATH+1];
		if (wszFullDirectoryName == NULL)
			hres = WBEM_E_OUT_OF_MEMORY;
		else
		{
			wcscpy(wszFullDirectoryName, wszParentDirectory);
			wcscat(wszFullDirectoryName, L"\\");
			wcscat(wszFullDirectoryName, wszSubDirectory);
		}
	}

	//Package the contents of that directory...
	if (SUCCEEDED(hres))
	{
		hres = DoDeleteContentsOfDirectory(wszExcludeFile, wszFullDirectoryName);
	}

	// now that the directory is empty, remove it
	if (!RemoveDirectoryW(wszFullDirectoryName))
    {   //If a remove directory fails, it may be because our excluded file is in it!
//		hres = WBEM_E_FAILED;
    }

	delete [] wszFullDirectoryName;

	return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\server2\servutil.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SERVUTIL.CPP

Abstract:

	Defines various service utilities.

History:

  a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include "servutil.h"
//***************************************************************************
//
//  BOOL InstallService
//
//  DESCRIPTION:
//
//  Installs a service
//
//  PARAMETERS:
//
//  pServiceName        short service name
//  pDisplayName        name displayed to the user
//  pBinary             full path to the binary
//
//  RETURN VALUE:
//
//  TRUE if it worked
//
//***************************************************************************

BOOL InstallService(
                        IN LPCTSTR pServiceName,
                        IN LPCTSTR pDisplayName,
                        IN LPCTSTR pBinary)
{
    SC_HANDLE   schService = NULL;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = CreateService(
            schSCManager,               // SCManager database
            pServiceName,        // name of service
            pDisplayName, // name to display
            SERVICE_ALL_ACCESS,         // desired access
            SERVICE_WIN32_OWN_PROCESS,  // service type
            SERVICE_DEMAND_START,       // start type
            SERVICE_ERROR_NORMAL,       // error control type
            pBinary,                     // service's binary
            NULL,                       // no load ordering group
            NULL,                       // no tag identifier
            NULL,                       // dependencies
            NULL,                       // LocalSystem account
            NULL);                      // no password

        if ( schService )
        {
            CloseServiceHandle(schService);
        }

        CloseServiceHandle(schSCManager);
    }
    return schService != NULL;
}

//***************************************************************************
//
//  BOOL RemoveService
//
//  DESCRIPTION:
//
//  Stops and then removes the service.  
//
//  PARAMETERS:
//
//  pServiceName        Short service name
//
//  RETURN VALUE:
//
//  TRUE if it worked
//
//***************************************************************************

BOOL RemoveService(
                        IN LPCTSTR pServiceName)
{
    SC_HANDLE   schService;
    BOOL bRet = FALSE;
    SC_HANDLE   schSCManager;
    StopService(pServiceName, 15);

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, pServiceName, SERVICE_ALL_ACCESS);

        if (schService)
        {
            bRet =  DeleteService(schService);
            CloseServiceHandle(schService);
        }

        CloseServiceHandle(schSCManager);
    }
    return bRet;
}

//***************************************************************************
//
//  BOOL StopService
//
//  DESCRIPTION:
//
//  Stops and then removes the service. 
//
//  PARAMETERS:
//
//  pServiceName        short service name
//  dwMaxWait           max time in seconds to wait
//
//  RETURN VALUE:
//
//  TRUE if it worked
//
//***************************************************************************

BOOL StopService(
                        IN LPCTSTR pServiceName,
                        IN DWORD dwMaxWait)
{
    BOOL bRet = FALSE;
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;
    DWORD dwCnt;
    SERVICE_STATUS          ssStatus;       // current status of the service

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, pServiceName, SERVICE_ALL_ACCESS);

        if (schService)
        {
            // try to stop the service
            if ( bRet = ControlService( schService, SERVICE_CONTROL_STOP, &ssStatus ) )
            {
                for(dwCnt=0; dwCnt < dwMaxWait &&
                    QueryServiceStatus( schService, &ssStatus ); dwCnt++)
                {
                    if ( ssStatus.dwCurrentState == SERVICE_STOP_PENDING )
                        Sleep( 1000 );
                    else
                        break;
                }

            }

            CloseServiceHandle(schService);
        }

        CloseServiceHandle(schSCManager);
    }
    return bRet;
}

//***************************************************************************
//
//  BOOL StartService
//
//  DESCRIPTION:
//
//  Starts the service runnig
//
//  PARAMETERS:
//
//  pServiceName        short service name
//  dwMaxWait           max time in seconds to wait
//
//  RETURN VALUE:
//
//  TRUE if it worked
//
//***************************************************************************

BOOL StartService(
                        IN LPCTSTR pServiceName,
                        IN DWORD dwMaxWait)
{
    DWORD dwCnt;
    BOOL bRet = FALSE;
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;
    SERVICE_STATUS          ssStatus;       // current status of the service

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, pServiceName, SERVICE_ALL_ACCESS);

        if (schService)
        {
            // try to stop the service
            if ( bRet = StartService( schService, 0, NULL ) )
            {
                for(dwCnt = 0; dwCnt < dwMaxWait &&
                    QueryServiceStatus( schService, &ssStatus ); dwCnt++)
                {
                    if ( ssStatus.dwCurrentState != SERVICE_RUNNING )
                        Sleep( 1000 );
                    else
                        break;
                }

            }

            CloseServiceHandle(schService);
        }

        CloseServiceHandle(schSCManager);
    }
    return bRet;
}


//***************************************************************************
//
//  BOOL SetDependency
//
//  DESCRIPTION:
//
//  Sets a service's dependency list.
//
//  PARAMETERS:
//
//  pServiceName        short service name
//  pDependency         dependency list
//
//  RETURN VALUE:
//
//  TRUE if it worked
//
//***************************************************************************

BOOL SetDependency(
                        IN LPCTSTR pServiceName,
                        IN LPCTSTR pDependency)
{
    BOOL bRet = FALSE;
    SC_HANDLE   schService;
    SC_HANDLE   schSCManager;

    schSCManager = OpenSCManager(
                        NULL,                   // machine (NULL == local)
                        NULL,                   // database (NULL == default)
                        SC_MANAGER_ALL_ACCESS   // access required
                        );
    if ( schSCManager )
    {
        schService = OpenService(schSCManager, pServiceName, SERVICE_ALL_ACCESS);

        if (schService)
        {
            bRet = ChangeServiceConfig(
                schService,
                    SERVICE_NO_CHANGE,
                    SERVICE_NO_CHANGE,
                    SERVICE_NO_CHANGE,
                    NULL,
                    NULL,
                    NULL,
                    pDependency,
                    NULL,
                    NULL,
                    NULL);
            CloseServiceHandle(schService);
        }

        CloseServiceHandle(schSCManager);
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\comlink.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    COMLINK.CPP

Abstract:

    Declarations for CComLink, which implements a network-independent
    transport for WBEM custom marshaling.

History:

    a-davj  15-Aug-96   Created.

--*/

#include "precomp.h"
#include "wmishared.h"
#include "cominit.h"

HANDLE g_Terminate = NULL;  

//***************************************************************************
//
//  CComLink::CComLink
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  hRead               read handle
//  hWrite              write handle
//  Type                type of connection
//  hTerm               Event which can be set to terminate the object
//
//  RETURN VALUE:
//
//  
//***************************************************************************

CComLink::CComLink (

    IN LinkType Type

) : m_ObjList ( this ) 
{
    m_LastReadTime = GetCurrentTime () ;

    InitializeCriticalSection(&m_cs);

    m_TerminationEvent      = CreateEvent(NULL,TRUE,FALSE,NULL);

    m_WriteMutex            = CreateMutex(NULL,FALSE,NULL);
  
    // Determine the timeout period, based on the registry entry.

    m_TimeoutMilliseconds = GetTimeout();

    // unlike Ole objects which get incremented by the mandatory
    // QueryInterface, this requires an initial nudge for the count.
    // =============================================================

    m_cRef = 1;

    ObjectCreated(OBJECT_TYPE_COMLINK);
}

//***************************************************************************
//
//  CComLink::~CComLink
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CComLink::~CComLink()
{    
    if ( m_TerminationEvent )
    {
        SetEvent ( m_TerminationEvent ) ;
    }

    // Delete the worker threads and the proxy/stub list

    m_ObjList.Free () ;

    if ( m_TerminationEvent )
        CloseHandle ( m_TerminationEvent ) ;

    if ( m_WriteMutex )
        CloseHandle ( m_WriteMutex ) ;

    DeleteCriticalSection ( & m_cs ) ;

    ObjectDestroyed(OBJECT_TYPE_COMLINK);
}

//***************************************************************************
//
//  int CComLink::AddRef2
//
//  DESCRIPTION:
//
//  Adds to the reference count.  Note that if pAdd isnt null, then pAdd is
//  pointing to an object that needs to be notified if this object goes away.
//
//  PARAMETERS:
//
//  pAdd                object to add to the "notify" list
//  ot                  object type
//  fa                  how to dispose of the object
//
//  RETURN VALUE:
//
//  reference count
//***************************************************************************

int CComLink::AddRef2 (

    void * pAdd,
    ObjType ot,
    FreeAction fa
)
{
    int iRet;

    EnterCriticalSection(&m_cs);

    if(pAdd)
    {
        m_ObjList.AddEntry(pAdd, ot, fa);  //todo, test result
    }

    m_cRef++;
//    DEBUGTRACE((LOG,"--AddRef2 after increment %d",m_cRef));

    iRet = m_cRef;

    LeaveCriticalSection(&m_cs);

    return iRet;
}

//***************************************************************************
//
//  int CComLink::Release2
//
//  DESCRIPTION:
//
//  Decrements the reference count.  Note that if pRemove isnt null, then 
//  it points to an object that no longer needs to be notified when this
//  object goes away.
//
//  PARAMETERS:
//
//  pRemove             pointer to object that is to be removed
//  ot                  object type
//
//  RETURN VALUE:
//
//  refernce count
//
//***************************************************************************

int CComLink::Release2 (

    IN void *pRemove,
    IN ObjType ot
)
{
    int iRet;

    EnterCriticalSection( gMaintObj.GetCriticalSection () );
    EnterCriticalSection(&m_cs);

    if(pRemove)
    {
        m_ObjList.RemoveEntry(pRemove, ot);  //todo, test result
    }

//    DEBUGTRACE((LOG,"\n--Release2 count is %d, ot is %d", m_cRef, ot));

    m_cRef--;
    iRet = m_cRef;

    if ( iRet == 2 )
    {
        gMaintObj.Indicate ( this ) ;
    }

    if ( iRet == 1 )
    {
        SetEvent ( m_TerminationEvent ) ;
        gMaintObj.ShutDownComlink ( this ) ;
        Shutdown () ;
    }

    LeaveCriticalSection(&m_cs);
    LeaveCriticalSection( gMaintObj.GetCriticalSection () );

    if( iRet == 0 )
    {
        delete this ;
    }


    return iRet;
}

//***************************************************************************
//
//  int CComLink::Release2
//
//  DESCRIPTION:
//
//  Decrements the reference count.  Note that if pRemove isnt null, then 
//  it points to an object that no longer needs to be notified when this
//  object goes away.
//
//  PARAMETERS:
//
//  pRemove             pointer to object that is to be removed
//  ot                  object type
//
//  RETURN VALUE:
//
//  refernce count
//
//***************************************************************************

int CComLink::Release3 (

    IN void *pRemove,
    IN ObjType ot
)
{
    int iRet;

    if(pRemove)
    {
        m_ObjList.RemoveEntry(pRemove, ot);  //todo, test result
    }

//    DEBUGTRACE((LOG,"\n--Release2 count is %d, ot is %d", m_cRef, ot));

    m_cRef--;
    iRet = m_cRef;

    if ( iRet == 2 )
    {
        gMaintObj.UnLockedIndicate ( this ) ;
    }

    if ( iRet == 1 )
    {
        SetEvent ( m_TerminationEvent ) ;
        gMaintObj.UnLockedShutDownComlink ( this ) ;
        UnLockedShutdown () ;
    }

    if( iRet == 0 )
    {
        delete this ;
    }

    return iRet;
}

//***************************************************************************
//
//  DWORD CComLink::GetStatus
//
//  DESCRIPTION:
//
//  Gets the status.
//
//  RETURN VALUE:
//
//  no_error if OK, otherwise failed.
//
//***************************************************************************

DWORD CComLink :: GetStatus ()
{
    if ( m_WriteQueue.GetStatus () != no_error || m_ReadQueue.GetStatus () != no_error )
    {
        return failed;
    }
    else 
    {
        return no_error;
    }
}

void CComLink :: ReleaseStubs ()
{
    m_ObjList.ReleaseStubs () ;
}

//***************************************************************************
//
//  CObjectSinkProxy * CComLink::GetObjectSinkProxy
//
//  DESCRIPTION:
//
//  Returns a pointer to a new or existing proxy for an object sink.
//
//  PARAMETERS:
//
//  stubAddr            stub for the clients notification object
//  pServices           IWbemServices interface to which the sink proxy is bound
//  createIfNotFound    only if TRUE will a new proxy be created
//
//  RETURN VALUE:
//
//  Return: NULL if out of memory or bad arugments.  Otherwise it is the pointer
//  to a CObjectSinkProxy object.
//
//  If a proxy is returned, its Ref count will have been incremented by 1.
//
//***************************************************************************

CObjectSinkProxy * CComLink::GetObjectSinkProxy( IN IStubAddress& stubAddr,
                                                 IN IWbemServices* pServices,
                                                 IN bool createIfNotFound)
{
    EnterCriticalSection(&m_cs);

    CObjectSinkProxy * pNoteProxy = NULL;
    if(!stubAddr.IsValid ())
    {
        LeaveCriticalSection(&m_cs);
        return NULL;
    }

    // First check the list of existing stubs and reuse one if possible.  This means that
    // if the client sends the same pointer twice, then WBEMCORE will get the same proxy.

            
    CLinkList * pList = GetListPtr();
    if(pList)
    {
        // Note double cast which is needed since CObjectSinkClientProxy uses multiple
        // inheritance.

        CProxy * pProxy = (CProxy * )pList->GetProxy(stubAddr);
        if(pProxy)
        {
            pNoteProxy = (CObjectSinkProxy *)pProxy;
            pNoteProxy->AddRef ();
            LeaveCriticalSection(&m_cs);
            return pNoteProxy;
        }
    }

    // Getting here means we are bereft of an existing usable proxy, so we must make one
    if (createIfNotFound)
    {
        pNoteProxy = CreateObjectSinkProxy (stubAddr, pServices);

        // Note that a successful call below will increment the refcount on pNoteProxy,
        // which is what we want
        if (!bVerifyPointer (pNoteProxy))
            pNoteProxy = NULL;
    }

    LeaveCriticalSection(&m_cs);

    return pNoteProxy;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\anonpipe.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    ANONPIPE.H

Abstract:

    Defines the functions used for anonpipe transport.

History:

	a-davj  16-june-97   Created.

--*/

/////////////////////////////////////////////////////////////////////
//
//
//
/////////////////////////////////////////////////////////////////////

#ifndef _WBEMANONPIPE_
#define _WBEMANONPIPE_

//***************************************************************************
//
//  CLASS NAME:
//
//  CComLink_LPipe
//
//  DESCRIPTION:
//
//  ANONPIPE implementation of the CComLink.
//
//***************************************************************************

//***************************************************************************
//
//  CLASS NAME:
//
//  CComLink_LPipe
//
//  DESCRIPTION:
//
//  Unnamed pipe implementation of the CComLink.
//
//***************************************************************************

class CComLink_LPipe : public CComLink
{
friend DWORD LaunchReadPipeThread ( LPDWORD pParam ) ;
public:

    CComLink_LPipe ( 

		LinkType Type ,
		HANDLE a_Read ,
		HANDLE a_Write ,
		HANDLE a_Term
	) ;

// Destructor for Pipe

	// Sends a COMLINK_MSG_NOTIFY_DESTRUCT to 
	// its partner, if any.
	// Does a Release() on the CMsgHandler as well.

    ~CComLink_LPipe () ;

    DWORD Call ( IN IOperation &a_Operation ) ;

	DWORD UnLockedTransmit ( CTransportStream &a_WriteStream ) ;
    DWORD Transmit ( CTransportStream &a_WriteStream ) ;

    DWORD StrobeConnection () ;  

	DWORD ProbeConnection () ;  

	DWORD HandleCall ( IN IOperation &a_Operation ) ;

	DWORD UnLockedShutdown () ;
	DWORD Shutdown () ;

	void UnLockedDropLink () ;
	void DropLink () ;

	CObjectSinkProxy*	CreateObjectSinkProxy (IN IStubAddress& dwStubAddr, 
											   IN IWbemServices* pServices);

private:

    DWORD DoReading () ;

    void ProcessRead ( PACKET_HEADER *ph , BYTE *pData , DWORD dwDataSize ) ;

/*
 *	Pipe Handles
 */

    HANDLE m_Read ;			// Handle used to read from PIPE
    HANDLE m_Write ;			// Handle used to write to PIPE
	HANDLE m_Terminate ;		// Handle used to inform of termination from server/client
/*
 *	Thread Handle of Reader thread
 */

    HANDLE m_ReadThread;				// Thread Handle created for Synchronous listening 
    HANDLE m_ReadThreadDoneEvent ;		// Event Handle used to indicate thread has shutdown, based on hTermEvent.

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\anonpipe.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    ANONPIPE.CPP

Abstract:

    Defines the functions used for anonpipe transport.

History:

    a-davj  16-june-97   Created.

--*/

#include "precomp.h"
#include "wmishared.h"
#include "anonpipe.h"

//***************************************************************************
//
//  DWORD LaunchReadPipeThread
//
//  DESCRIPTION:
//
//  Starting point for anon pipe read thread.
//
//  PARAMETERS:
//
//  pParam              pointer to comlink object
//
//  RETURN VALUE:
//
//  0
//***************************************************************************

DWORD LaunchReadPipeThread ( LPDWORD pParam )
{
    InitializeCom () ;
    CComLink_LPipe *t_Com = ( CComLink_LPipe *) pParam ;

    DWORD dwRet = t_Com->DoReading () ;
    MyCoUninitialize () ;
    return dwRet;
}

//***************************************************************************
//
//  CComLink_LPipe::CComLink_LPipe
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  hRead               write handle
//  hWrite              read handle
//  Type                comlink type
//  hTerm               event which can be set to invoke destruction
//
//***************************************************************************

CComLink_LPipe::CComLink_LPipe (

    IN LinkType a_Type,
    IN HANDLE a_Read,
    IN HANDLE a_Write,
    IN HANDLE a_Terminate

) : CComLink ( a_Type ) ,
    m_Read ( a_Read ) ,
    m_Write ( a_Write ) ,
    m_Terminate ( a_Terminate ) 
{
    DWORD t_ThreadId ;

    if( m_Terminate )
    {
        AddRef2 ( NULL , NONE , DONOTHING ) ;

        m_ReadThread = CreateThread (

            NULL,
            0,
            (LPTHREAD_START_ROUTINE) LaunchReadPipeThread, 
            (LPVOID)this,
            0,
            &t_ThreadId
        ) ;
    }

    m_ReadThreadDoneEvent   = CreateEvent(NULL,TRUE,FALSE,NULL);

    gMaintObj.AddComLink ( this ) ;
}

//***************************************************************************
//
//  CComLink_LPipe::~CComLink_LPipe
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CComLink_LPipe :: ~CComLink_LPipe ()
{
    DEBUGTRACE((LOG,"\nLocal Pipe comlink [0x%x] is terminating", this));

    // Stop the read thread

    if(m_ReadThread)
    {
        DWORD dwRet = WbemWaitForSingleObject ( m_ReadThreadDoneEvent , 2000 ) ;
        if ( dwRet != WAIT_OBJECT_0 )
        {
        }

        if ( m_Read ) 
            CloseHandle ( m_Read ) ;

        if ( m_Write ) 
            CloseHandle ( m_Write ) ;

        if ( m_Terminate ) 
            CloseHandle ( m_Terminate ) ;

        if ( m_ReadThread )
            CloseHandle ( m_ReadThread ) ;

        if ( m_ReadThreadDoneEvent )
            CloseHandle ( m_ReadThreadDoneEvent ) ;

        TerminateThread ( m_ReadThread , 1 ) ;

        return ;
    }

    if ( m_Read ) 
        CloseHandle ( m_Read ) ;

    if ( m_Write ) 
        CloseHandle ( m_Write ) ;

    if ( m_Terminate ) 
        CloseHandle ( m_Terminate ) ;

    if ( m_ReadThread )
        CloseHandle ( m_ReadThread ) ;

    if ( m_ReadThreadDoneEvent )
        CloseHandle ( m_ReadThreadDoneEvent ) ;

}

DWORD CComLink_LPipe :: Call ( IN IOperation &a_Operation )
{
    HRESULT t_Result = WBEM_E_TRANSPORT_FAILURE;

    // Verify that the streams are OK and get a slot in the write queue

    if ( ! SUCCEEDED ( a_Operation.GetStatus () ) )
    {
        t_Result = WBEM_E_INVALID_STREAM;
    }
    else
    {
        BOOL t_ReceivedResponse = FALSE ;

        HANDLE t_EventContainer [ 2 ] ;

        t_EventContainer [ 0 ] = m_WriteQueue.AllocateRequest ( a_Operation ) ;
        if ( ! t_EventContainer [ 0 ] ) 
        {
            t_Result = WBEM_E_OUT_OF_MEMORY ;
        }
        else
        {
            t_EventContainer [ 1 ] = m_TerminationEvent ;

            ResetEvent ( t_EventContainer [ 0 ] ) ;
        
            ISecurityHelper t_Helper ;
            CTransportStream t_WriteStream ;

            bool t_Status = a_Operation.EncodeRequest ( t_WriteStream , t_Helper ) ;
            if ( t_Status ) 
            {
                Transmit ( t_WriteStream ) ;

                DWORD t_Status = WbemWaitForMultipleObjects ( 2 , t_EventContainer , INFINITE ) ;

                // Check for forced termiation
                // ===========================

                switch ( t_Status )
                {
                    case WAIT_OBJECT_0+1:
                    {
                        t_Result = WBEM_E_TRANSPORT_FAILURE;    // Termination event
                    }
                    break ;

                    case WAIT_OBJECT_0:
                    {
                        if ( m_WriteQueue.GetRequestStatus ( t_EventContainer [0] ) == COMLINK_MSG_RETURN ) 
                        {
                            CTransportStream &t_ReadStream = a_Operation.GetDecodeStream ();            
                            t_ReadStream.Reset () ;
                            DWORD t_Position = t_ReadStream.GetCurrentPos () + sizeof ( PACKET_HEADER ) ;
                            t_ReadStream.SetCurrentPos ( t_Position ) ;

                            ISecurityHelper t_Helper ;
                            if ( a_Operation.DecodeResponse ( t_ReadStream , t_Helper ) ) 
                            {
                            }
                            else
                            {
                            }
        
                            // looks good so far. Get the return code

                            t_Result = a_Operation.GetStatus () ;

                        }
                        else if ( m_WriteQueue.GetRequestStatus ( t_EventContainer [0] ) == COMLINK_MSG_RETURN_FATAL_ERROR )
                        {
                // this occures only if the server is out of resources, in that
                // case we dont want to send additional request.
                // ============================================================

                            t_Result = WBEM_E_PROVIDER_FAILURE;
                        }
                        else 
                        {
                            t_Result = WBEM_E_TRANSPORT_FAILURE;
                        }
                    }
                    break ;

                    default:
                    {
                        t_Result = WBEM_E_TRANSPORT_FAILURE;
                    }
                    break ;
                }
            }
        }

        // All done, give up the slot and return.

        m_WriteQueue.DeallocateRequest ( t_EventContainer [ 0 ] ) ;

        a_Operation.SetErrorInfoOnThread () ;
    }

    a_Operation.SetStatus ( t_Result ) ;

    return t_Result ;
}

//***************************************************************************
//
//  int CComLink_LPipe::Transmit
//
//  DESCRIPTION:
//
//  Transmitts a packet via the anon pipe
//
//  PARAMETERS:
//
//  dwSend              type of package
//  *pSendStream        stream containing data to write
//  guidPacketID        GUILD to identify packet
//  hWrite              write header
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  WBEM_E_TRANSPORT_FAILURE   if write fails
//  otherwise error set by Serialize
//
//***************************************************************************

DWORD CComLink_LPipe::Transmit ( CTransportStream &a_WriteStream ) 
{
    BOOL t_Status = TRUE ;

#if 0
    DWORD t_Result = WbemWaitForSingleObject ( m_WriteMutex , MAX_WAIT_FOR_WRITE ) ; 
#else
    DWORD t_Result = WAIT_OBJECT_0 ;
    EnterCriticalSection(&m_cs);
#endif

    if ( t_Result == WAIT_OBJECT_0 )
    {
        t_Result = a_WriteStream.CMemStream :: Serialize ( m_Write ) ;  // Serialise the stream to the pipe
        t_Status = SUCCEEDED ( t_Result ) ;
        if ( ! t_Status ) 
        {
// Set Some internal error
        }
    }
    else
    {
        t_Status = FALSE ;
    }

#if 0
    ReleaseMutex ( m_WriteMutex ) ;
#else
    LeaveCriticalSection(&m_cs);
#endif

    return t_Status ;
}

//***************************************************************************
//
//  int CComLink_LPipe::Transmit
//
//  DESCRIPTION:
//
//  Transmitts a packet via the anon pipe
//
//  PARAMETERS:
//
//  dwSend              type of package
//  *pSendStream        stream containing data to write
//  guidPacketID        GUILD to identify packet
//  hWrite              write header
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  WBEM_E_TRANSPORT_FAILURE   if write fails
//  otherwise error set by Serialize
//
//***************************************************************************

DWORD CComLink_LPipe::UnLockedTransmit ( CTransportStream &a_WriteStream ) 
{
    BOOL t_Status = TRUE ;

    HRESULT t_Result = a_WriteStream.CMemStream :: Serialize ( m_Write ) ;  // Serialise the stream to the pipe
    t_Status = SUCCEEDED ( t_Result ) ;
    if ( ! t_Status ) 
    {
// Set Some internal error
    }

    return t_Status ;
}

//***************************************************************************
//
//  CComLink_LPipe::DoReading
//
//  DESCRIPTION:
//
//  Where the anon pipe read thread lives.
//
//***************************************************************************

DWORD CComLink_LPipe :: DoReading ()
{
    while ( 1 )
    {
        DWORD t_Result = WbemWaitForSingleObject ( m_TerminationEvent ,  0 ) ;
        if ( t_Result != WAIT_OBJECT_0 ) 
        {
            CTransportStream t_ReadStream ;
            switch ( t_ReadStream.CMemStream :: Deserialize ( m_Read ) )
            {
                case CTransportStream :: failed:
                case CTransportStream :: out_of_memory:
                {
                    DWORD t_ErrorResult = GetLastError () ;
                    SetEvent ( m_TerminationEvent ) ;
                    SetEvent ( m_ReadThreadDoneEvent ) ;

                    Release2 ( NULL , NONE ) ;

                    return 0;                        // terminate the thread
                }
                break ;

                default:
                {
                    t_ReadStream.Reset () ;

					PACKET_HEADER *t_PacketHeader = (PACKET_HEADER *)
											((BYTE *)t_ReadStream.GetPtr() + t_ReadStream.GetCurrentPos());
                    ProcessRead ( 

                        t_PacketHeader , 
                        ( unsigned char * ) t_ReadStream.GetPtr () ,
                        t_ReadStream.Size ()
                    ) ;
                }
                break ;
            }
        }
        else
        {
            SetEvent ( m_ReadThreadDoneEvent ) ;
            Release2 ( NULL , NONE ) ;
            return 0;   
        }
    }

    return 0 ;
}

//***************************************************************************
//
//  void CComLink::ProcessRead
//
//  DESCRIPTION:
//
//  Got a package from our partner.  It could be a response to something
//  we sent, or it could be something initiated in our partner.
//
//  PARAMETERS:
//
//  pPacketHeader       pointer to header object  
//  pData               data to be sent
//  dwDataSize          size of data
//
//  RETURN VALUE:
//
//  
//***************************************************************************

void CComLink_LPipe :: ProcessRead (

    IN PACKET_HEADER *a_PacketHeader ,
    IN BYTE *a_PayLoadData ,
    IN DWORD a_PayLoadSize
)
{
    m_LastReadTime = GetCurrentTime ();
    
    // bump up the count at the start and restore at the end of this 
    // routine.  This is done so that object wount disappear in the 
    // middle of handling a read.
    //==============================================================

    AddRef2(NULL, NONE, DONOTHING);

    DWORD t_Type = a_PacketHeader->GetType();
    RequestId t_RequestId  = a_PacketHeader->GetRequestId ();

    DEBUGTRACE((LOG,"\nProcessing Read on comlink [0x%x], type is %d RequestId=%d",
                    this, t_Type,t_RequestId));                


    if ( t_Type == COMLINK_MSG_RETURN || t_Type == COMLINK_MSG_RETURN_FATAL_ERROR )
    {
        IOperation *t_Operation = m_WriteQueue.GetOperation ( t_RequestId );
        if ( ! t_Operation )
        {
            Release2 ( NULL , NONE ) ;

            return;                             //todo, else, should bitch
        }

        if ( t_Type == COMLINK_MSG_RETURN )
        {
            CTransportStream &t_ReadStream = t_Operation->GetDecodeStream ();
            t_ReadStream.CMemStream :: Deserialize ( a_PayLoadData , a_PayLoadSize ) ;
        }
        else
        {
            t_Operation->SetStatus ( WBEM_E_PROVIDER_FAILURE ) ;
        }

        m_WriteQueue.SetEventAndStatus ( t_RequestId , t_Type ) ;
    }
    else if ( t_Type == COMLINK_MSG_CALL )    
    {
        // This is a new call. This might be lengthy 
        // and so a thread is created to call the stub.  If the thread is 
        // created, it is responsible for freeing up the allocations and 
        // doing an extra Release on the comlink
        // =================================================================
        
    //  ISecurityHelper t_Helper ;
        CTransportStream t_ReadStream ;
        t_ReadStream.CMemStream :: Deserialize ( a_PayLoadData , a_PayLoadSize ) ;

        t_ReadStream.Reset () ;
        DWORD t_Position = t_ReadStream.GetCurrentPos () + sizeof ( PACKET_HEADER ) ;
        t_ReadStream.SetCurrentPos ( t_Position ) ;

        IOperation *t_Operation = NULL ;
        if ( IOperation_LPipe :: Decode ( *a_PacketHeader , t_ReadStream , &t_Operation ) )
        {
            ISecurityHelper t_Helper ;
            if ( t_Operation->DecodeRequest ( t_ReadStream , t_Helper ) )
            {
                HANDLE t_ReadEvent = m_ReadQueue.AllocateRequest ( *t_Operation );
                if ( t_ReadEvent )
                {
                    BOOL t_Status = gThrdPool.Execute ( 

                        *this , 
                        *t_Operation
                    ) ;

                    if ( t_Status )
                    {
                        return ;
                    }

                // should only be here if some failure, clean up any allocations

                    if ( t_ReadEvent )
                    {
                        m_ReadQueue.DeallocateRequest ( t_ReadEvent ) ;
                    }
                }
            }
            else
            {
            }
        }
    }
    else if ( t_Type == COMLINK_MSG_PING )
    {
// Reply to strobe

        ISecurityHelper t_Helper ;
        COperation_LPipe_Ping t_pingOp (*a_PacketHeader);
        CTransportStream t_WriteStream ;

        if (t_pingOp.EncodeResponse ( t_WriteStream, t_Helper ))
        {
            if ( Transmit ( t_WriteStream ) )
            {
            }
            else
            {
            }
        }
    }
    else if ( t_Type == COMLINK_MSG_PING_ACK )
    {
        // simple ack type
        m_WriteQueue.SetEventAndStatus ( t_RequestId ,t_Type ) ;
    }
    else if ( t_Type == COMLINK_MSG_CALL_NACK )
    {
        // simple ack type
        m_WriteQueue.SetEventAndStatus ( t_RequestId ,t_Type ) ;
    }
    else if ( t_Type == COMLINK_MSG_HEART_BEAT )
    {
        ISecurityHelper t_Helper ;
        COperation_LPipe_Strobe t_StrobeOp (*a_PacketHeader);
        CTransportStream t_WriteStream ;

        if (t_StrobeOp.EncodeResponse ( t_WriteStream, t_Helper ))
        {
            if ( Transmit ( t_WriteStream ) )
            {
            }
            else
            {
            }
        }
    }
    else if ( t_Type == COMLINK_MSG_HEART_BEAT_ACK )
    {
    }
    else if ( t_Type == COMLINK_MSG_NOTIFY_DESTRUCT )
    {
        SetEvent ( m_TerminationEvent ) ;
        gMaintObj.ShutDownComlink ( this ) ;
    }
    else
    {
// ???
    }

    Release2 ( NULL , NONE ) ;
}

//***************************************************************************
//
//  DWORD CComLink::Ping
//
//  DESCRIPTION:
//
//  Sends a simple message and waits for a simple ack.  This is used as a
//  "heart beat" test.
//
//  PARAMETERS:
//
//  hTerm1              First event handle that can be used to stop this call
//  hTerm2              second event handle that can be used to stop this call
//
//  RETURN VALUE:
//
//  S_OK                no error,
//  else set by SendAndWaitSimple
//
//***************************************************************************

DWORD CComLink_LPipe :: ProbeConnection ()
{
    HRESULT t_Result ;

    ISecurityHelper t_Helper ;

    COperation_LPipe_Ping t_Operation  ;

    HANDLE t_EventContainer [ 2 ] ;

    t_EventContainer [ 0 ] = m_WriteQueue.AllocateRequest ( t_Operation ) ;
    if ( ! t_EventContainer [ 0 ] ) 
    {
        t_Result = WBEM_E_OUT_OF_MEMORY ;
    }
    else
    {
        t_EventContainer [ 1 ] = m_TerminationEvent ;

        ResetEvent ( t_EventContainer [ 0 ] ) ;
    
        ISecurityHelper t_Helper ;
        CTransportStream t_WriteStream ;

        bool t_Status = t_Operation.EncodeRequest ( t_WriteStream , t_Helper ) ;
        if ( t_Status ) 
        {
            Transmit ( t_WriteStream ) ;

            DWORD t_Status = WbemWaitForMultipleObjects ( 2 , t_EventContainer , INFINITE ) ;

            // Check for forced termiation
            // ===========================

            switch ( t_Status )
            {
                case WAIT_OBJECT_0+1:
                {
                    t_Result = WBEM_E_TRANSPORT_FAILURE;    // Termination event
                }
                break ;

                case WAIT_OBJECT_0:
                {
                    if ( m_WriteQueue.GetRequestStatus ( t_EventContainer [0] ) == COMLINK_MSG_PING_ACK && SUCCEEDED ( t_Operation.GetStatus () ) ) 
                    {
                // looks good so far. Get the return code

                    }
                    else if ( m_WriteQueue.GetRequestStatus ( t_EventContainer [0] ) == COMLINK_MSG_RETURN_FATAL_ERROR )
                    {
            // this occures only if the server is out of resources, in that
            // case we dont want to send additional request.
            // ============================================================

                        t_Result = WBEM_E_PROVIDER_FAILURE;
                    }
                    else 
                    {
                        t_Result = WBEM_E_TRANSPORT_FAILURE;
                    }
                }
                break ;

                default:
                {
                    t_Result = WBEM_E_TRANSPORT_FAILURE;
                }
                break ;
            }
        }
        else
        {
            t_Result = WBEM_E_TRANSPORT_FAILURE ;
        }

        // All done, give up the slot and return.

        m_WriteQueue.DeallocateRequest ( t_EventContainer [ 0 ] ) ;

    }

    return t_Result ;
}

//***************************************************************************
//
//  DWORD CComLink::Ping
//
//  DESCRIPTION:
//
//  Sends a simple message and waits for a simple ack.  This is used as a
//  "heart beat" test.
//
//  PARAMETERS:
//
//  hTerm1              First event handle that can be used to stop this call
//  hTerm2              second event handle that can be used to stop this call
//
//  RETURN VALUE:
//
//  S_OK                no error,
//  else set by SendAndWaitSimple
//
//***************************************************************************

DWORD CComLink_LPipe :: StrobeConnection ()
{
DEBUGTRACE((LOG,"\nStrobe Connection"));

    HRESULT t_Result ;

    ISecurityHelper t_Helper ;

    COperation_LPipe_Strobe t_Operation  ;

    HANDLE t_EventContainer [ 1 ] ;

    t_EventContainer [ 0 ] = m_WriteQueue.AllocateRequest ( t_Operation ) ;
    if ( ! t_EventContainer [ 0 ] ) 
    {
        t_Result = WBEM_E_OUT_OF_MEMORY ;
    }
    else
    {
        ResetEvent ( t_EventContainer [ 0 ] ) ;
    
        ISecurityHelper t_Helper ;
        CTransportStream t_WriteStream ;

        bool t_Status = t_Operation.EncodeRequest ( t_WriteStream , t_Helper ) ;
        if ( t_Status ) 
        {
            Transmit ( t_WriteStream ) ;
        }

        // All done, give up the slot and return.

        m_WriteQueue.DeallocateRequest ( t_EventContainer [ 0 ] ) ;
    }

DEBUGTRACE((LOG,"\nLeave Strobe Connection"));
    return t_Result ;
}

DWORD CComLink_LPipe :: UnLockedShutdown ()
{
DEBUGTRACE((LOG,"\nShutdown"));

    HRESULT t_Result ;

    ISecurityHelper t_Helper ;

    COperation_LPipe_Shutdown t_Operation  ;

    HANDLE t_EventContainer [ 1 ] ;

    t_EventContainer [ 0 ] = m_WriteQueue.UnLockedAllocateRequest ( t_Operation ) ;
    if ( ! t_EventContainer [ 0 ] ) 
    {
        t_Result = WBEM_E_OUT_OF_MEMORY ;
    }
    else
    {
        ResetEvent ( t_EventContainer [ 0 ] ) ;
    
        ISecurityHelper t_Helper ;
        CTransportStream t_WriteStream ;

        bool t_Status = t_Operation.EncodeRequest ( t_WriteStream , t_Helper ) ;
        if ( t_Status ) 
        {
            UnLockedTransmit ( t_WriteStream ) ;
        }

        m_WriteQueue.UnLockedDeallocateRequest ( t_EventContainer [ 0 ] ) ;
    }

    UnLockedDropLink () ;

DEBUGTRACE((LOG,"\nLeave Shutdown"));
    return t_Result ;
}

DWORD CComLink_LPipe :: Shutdown ()
{
DEBUGTRACE((LOG,"\nShutdown"));

    HRESULT t_Result ;

    ISecurityHelper t_Helper ;

    COperation_LPipe_Shutdown t_Operation  ;

    HANDLE t_EventContainer [ 1 ] ;

    t_EventContainer [ 0 ] = m_WriteQueue.AllocateRequest ( t_Operation ) ;
    if ( ! t_EventContainer [ 0 ] ) 
    {
        t_Result = WBEM_E_OUT_OF_MEMORY ;
    }
    else
    {
        ResetEvent ( t_EventContainer [ 0 ] ) ;
    
        ISecurityHelper t_Helper ;
        CTransportStream t_WriteStream ;

        bool t_Status = t_Operation.EncodeRequest ( t_WriteStream , t_Helper ) ;
        if ( t_Status ) 
        {
            Transmit ( t_WriteStream ) ;
        }

        m_WriteQueue.DeallocateRequest ( t_EventContainer [ 0 ] ) ;
    }

    DropLink () ;

DEBUGTRACE((LOG,"\nLeave Shutdown"));
    return t_Result ;
}

DWORD CComLink_LPipe :: HandleCall ( IN IOperation &a_Operation )
{
    a_Operation.HandleCall ( *this ) ;

    ISecurityHelper t_Helper ;
    CTransportStream t_WriteStream ;

    bool t_Status = a_Operation.EncodeResponse ( t_WriteStream , t_Helper ) ;
    if ( t_Status ) 
    {
        Transmit ( t_WriteStream ) ;
    }
    else
    {
    }

    m_ReadQueue.DeallocateRequest ( m_ReadQueue.GetHandle ( a_Operation.GetRequestId () ) ) ;

    HRESULT t_Result = a_Operation.GetStatus () ;

    IOperation *t_Operation = & a_Operation ;

    delete t_Operation ;

    return t_Result ;
}

CObjectSinkProxy* CComLink_LPipe::CreateObjectSinkProxy (IN IStubAddress& stubAddr,
                                                         IN IWbemServices* pServices)
{
    return new CObjectSinkProxy_LPipe (this, stubAddr, pServices);
}

void CComLink_LPipe :: DropLink ()
{
    EnterCriticalSection(&m_cs);

    ISecurityHelper t_Helper ;

    COperation_LPipe_Shutdown t_Operation  ;

    HANDLE t_EventContainer [ 1 ] ;

    t_EventContainer [ 0 ] = m_WriteQueue.AllocateRequest ( t_Operation ) ;
    if ( ! t_EventContainer [ 0 ] ) 
    {
        HRESULT t_Result = WBEM_E_OUT_OF_MEMORY ;
    }
    else
    {
        ResetEvent ( t_EventContainer [ 0 ] ) ;
    
        ISecurityHelper t_Helper ;
        CTransportStream t_WriteStream ;

        bool t_Status = t_Operation.EncodeRequest ( t_WriteStream , t_Helper ) ;
        if ( t_Status ) 
        {
            if(m_ReadThread)
            {
#if 0
                DWORD t_Result = WbemWaitForSingleObject ( m_WriteMutex , MAX_WAIT_FOR_WRITE ) ; 
#else
                DWORD t_Result = WAIT_OBJECT_0 ;
                EnterCriticalSection(&m_cs);
#endif
                if ( t_Result == WAIT_OBJECT_0 )
                {
                    t_Result = t_WriteStream.CMemStream :: Serialize ( m_Terminate ) ;  // Serialise the stream to the pipe
                    t_Status = SUCCEEDED ( t_Result ) ;
                    if ( ! t_Status ) 
                    {
            // Set Some internal error
                    }
                }
                else
                {
                    t_Status = FALSE ;
                }

#if 0
                ReleaseMutex ( m_WriteMutex ) ;
#else
                LeaveCriticalSection(&m_cs);
#endif
            }
        }

        m_WriteQueue.DeallocateRequest ( t_EventContainer [ 0 ] ) ;
    }

    ReleaseStubs () ;

    LeaveCriticalSection(&m_cs);
}

void CComLink_LPipe :: UnLockedDropLink ()
{
    ISecurityHelper t_Helper ;

    COperation_LPipe_Shutdown t_Operation  ;

    HANDLE t_EventContainer [ 1 ] ;

    t_EventContainer [ 0 ] = m_WriteQueue.UnLockedAllocateRequest ( t_Operation ) ;
    if ( ! t_EventContainer [ 0 ] ) 
    {
        HRESULT t_Result = WBEM_E_OUT_OF_MEMORY ;
    }
    else
    {
        ResetEvent ( t_EventContainer [ 0 ] ) ;
    
        ISecurityHelper t_Helper ;
        CTransportStream t_WriteStream ;

        bool t_Status = t_Operation.EncodeRequest ( t_WriteStream , t_Helper ) ;
        if ( t_Status ) 
        {
            if(m_ReadThread)
            {
                HRESULT t_Result = t_WriteStream.CMemStream :: Serialize ( m_Terminate ) ;  // Serialise the stream to the pipe
                t_Status = SUCCEEDED ( t_Result ) ;
                if ( ! t_Status ) 
                {
        // Set Some internal error
                }
            }
        }

        m_WriteQueue.UnLockedDeallocateRequest ( t_EventContainer [ 0 ] ) ;
    }

    ReleaseStubs () ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\cstub.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CSTUB.CPP

Abstract:

    Declarations for CStub, which to keep track of objects
    that a stub is taking care of.

History:

    a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include "wmishared.h"


//***************************************************************************
//
//  CStub::CStub
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CStub::CStub()
{
    ObjectCreated(OBJECT_TYPE_CSTUB);
}

//***************************************************************************
//
//  CStub::~CStub
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CStub::~CStub()
{
    ObjectDestroyed(OBJECT_TYPE_CSTUB);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\iopn.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    IOPN.CPP

Abstract:

    Declares the fundamental protocol-independent operation class

History:

    alanbos  18-Dec-97   Created.

--*/

#include "precomp.h"
#include "wmishared.h"

// IOperation
RequestId IOperation::m_id = 0;

// Used on stub side by subclass to get the error info
// so that it can then encode it however it likes for
// response
IErrorInfo* IOperation::GetErrorInfoFromObject () 
{ 
    if (m_pErrorInfo)
        m_pErrorInfo->AddRef ();

    return m_pErrorInfo; 
}
    
// Used on stub side to include any error information for the
// thread into the operation in preparation for marhsaling
// back to the client.  Called by ??
void IOperation::SetErrorInfoIntoObject ()
{
    // Clear any current error object
    if (m_pErrorInfo)
    {
        m_pErrorInfo->Release ();
        m_pErrorInfo = NULL;
    }

    IErrorInfo* pInfo;

    if (S_OK == GetErrorInfo (0, &pInfo))
        m_pErrorInfo = pInfo;
}

// Used on proxy side to save the decoded error info into
// the operation.  Called by subclass just after the
// decode.
void IOperation::SetErrorInfoIntoObject (IErrorInfo* pInfo)
{
    // Clear any current error object
    if (m_pErrorInfo)
    {
        m_pErrorInfo->Release ();
        m_pErrorInfo = NULL;
    }

    m_pErrorInfo = pInfo;

    if (m_pErrorInfo)
        m_pErrorInfo->AddRef ();
}


// Used on proxy side to recreate the original IErrorInfo set
// in the server thread.  Called by the CComLink just at the
// right time.
void IOperation::SetErrorInfoOnThread ()
{
    if (m_pErrorInfo)
    {
        SetErrorInfo (0, m_pErrorInfo);
        m_pErrorInfo->Release ();
        m_pErrorInfo = NULL;
    }
}

void IOperation::SetContext (IWbemContext* pContext)
{
    if (m_pContext)
        m_pContext->Release ();

    m_pContext = pContext; 
    if (m_pContext)
        m_pContext->AddRef ();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\cproxy.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CPROXY.CPP

Abstract:

    Base class for all proxy objects, plus the .

History:

    a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include "wmishared.h"

//***************************************************************************
//
//  CProxy::CProxy
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  pComLink            comlink object that serves this proxy.
//  stubAddr          stub on the server.
//
//***************************************************************************

CProxy::CProxy(
                        IN CComLink * pComLink,
                        IN IStubAddress& stubAddr)
{
    m_pComLink = pComLink;
    m_pStubAddr = stubAddr.Clone ();
    m_pUnkInner = NULL;

    // There should always be a CComLink object.  If it is deleted,
    // then we want to be notified via SetLinkPtrToNULL that it is
    // no longer available.  
    // ============================================================    
    
    if(m_pComLink)
        m_pComLink->AddRef2(this, PROXY, NOTIFY);

    InitializeCriticalSection(&m_cs);
    m_dwNumActiveCalls = 0;     
    return;
}

//***************************************************************************
//
//  CProxy::~CProxy
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CProxy::~CProxy(void)
{
    EnterCriticalSection(&m_cs);

    delete m_pStubAddr;

    if(m_pComLink)
        m_pComLink->Release2(this,PROXY);

    // Release the aggregated free-threaded marshaler
    if (m_pUnkInner)
        m_pUnkInner->Release ();

    LeaveCriticalSection(&m_cs);
    DeleteCriticalSection(&m_cs);
    return;
}

//***************************************************************************
//
//  void CProxy::SetLinkPtrToNULL
//
//  DESCRIPTION:
//
//  Called in the event that the CComLink object is deleted before the proxy
//  and keeps the proxy from using CComLink anymore.
//
//***************************************************************************

void CProxy::Indicate ( CComLink *a_ComLink )
{
    EnterCriticalSection(&m_cs);
    m_pComLink = NULL;
    LeaveCriticalSection(&m_cs);
}

//***************************************************************************
//
//  DWORD CProxy::ProxyCall
//
//  DESCRIPTION:
//
//  Provides a safe means for the proxy to use the CComLink object.  It
//  increments the m_dwNumActiveCalls call during the call.
//
//  PARAMETERS:
//
//  pIn                 stream where results are put
//  pOut                stream containing what to send
//
//  RETURN VALUE:
//
//  WBEM_E_OUT_OF_MEMORY
//  WBEM_E_INVALID_PARAMETER
//  WBEM_E_TRANSPORT_FAILURE
//  WBEM_E_PROVIDER_FAILURE
//  WBEM_E_INVALID_STREAM
//  or an error code set by the stub, or WBEM.
//
//***************************************************************************

DWORD CProxy::ProxyCall(
                        IOperation& opn)
{
    DWORD dwRet;
    CComLink * pComLink;

    EnterCriticalSection(&m_cs);
    if(m_pComLink == NULL)
    {
        LeaveCriticalSection(&m_cs);
        return WBEM_E_TRANSPORT_FAILURE;
    }
    pComLink = m_pComLink;
    m_dwNumActiveCalls++;
    LeaveCriticalSection(&m_cs);

    dwRet = pComLink->Call(opn);
    EnterCriticalSection(&m_cs);
    m_dwNumActiveCalls--;
    LeaveCriticalSection(&m_cs);
    return dwRet;

}

//***************************************************************************
//
//  SCODE CProxy::CreateProxy
//
//  DESCRIPTION:
//
//  Creates a new proxy object, singly AddRef'd.
//
//  PARAMETERS:
//
//  ot                  Object type.  Ex, ENUMERATOR, SINK
//  ppNew               pointer to created object
//  pread               memory stream containing results of call. 
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  WBEM_E_OUT_OF_MEMORY
//  WBEM_E_INVALID_PARAMETER
//***************************************************************************

SCODE CProxy::CreateProxy(
                        IN ObjType ot,
                        OUT void ** ppNew,
                        IStubAddress& stubAddr)
{
    switch (ot)
    {
        case PROVIDER:
            *ppNew = GetProvProxy (stubAddr);
            break;

        case ENUMERATOR:
            *ppNew = GetEnumProxy (stubAddr);
            break;

        case CALLRESULT:
            *ppNew = GetResProxy (stubAddr);
            break;

        case OBJECTSINK:
            *ppNew = GetSinkProxy (stubAddr);
            break;

        default:
            return WBEM_E_INVALID_PARAMETER;   // should never get here.
    }

    // If successful the following call will AddRef the returned proxy.
    return (bVerifyPointer(*ppNew)) ? WBEM_NO_ERROR : WBEM_E_OUT_OF_MEMORY;
}

//***************************************************************************
//
//  SCODE CProxy::CallAndCleanup
//
//  DESCRIPTION:
//
//  Forwards the call to ProxyCall, takes care of the error object
//  and possibly creates a new proxy.  This is used in the Sync cases.
//
//  PARAMETERS:
//
//  ot                  Object type.  Ex, ENUMERATOR, SINK
//  ppNew               pointer to created object
//  pread               memory stream containing results of call. 
//  pwrite              write stream.
//  pErrorObj           pointer to optional error object.
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  otherwise an error code set by ProxyCall.
//***************************************************************************

SCODE CProxy::CallAndCleanup(
                        IN ObjType ot,
                        OUT void ** ppNew, 
                        OUT IOperation& proxyOp)
{
    DWORD dwRet;
    IWbemCallResult** ppCallResult = NULL;
    dwRet = ProxyCall(proxyOp); 

    if( ! FAILED ( dwRet ) && ot != NONE && ppNew)
        dwRet = CreateProxy(ot, ppNew, *(proxyOp.GetProxyAddress (ot)));

    if ( ! FAILED ( dwRet ) && ( ppCallResult = proxyOp.GetResultObjectPP ()) )
        CreateProxy(CALLRESULT, (void **)ppCallResult, 
                                *(proxyOp.GetProxyAddress (CALLRESULT)));

    return dwRet;
}

//***************************************************************************
//
//  SCODE CProxy::CallAndCleanupAsync
//
//  DESCRIPTION:
//
//  Forwards the call to ProxyCall.  Since async calls pass a call back,
//  this function also makes sure that the reference count for notify 
//  stubs is incremented.  This is used for the async calls.
//
//  PARAMETERS:
//
//  pread               result stream
//  pwrite              output stream
//  pResponseHandler    notify object stream
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  otherwise Return code is set by ProxyCall()
//
//***************************************************************************

SCODE CProxy::CallAndCleanupAsync(
                        IN IOperation& opn,
                        IN IWbemObjectSink FAR* pResponseHandler)
{
    DWORD dwRet;

    pResponseHandler->AddRef();
    m_pComLink->AddRef2(pResponseHandler, OBJECTSINK, RELEASEIT);
    dwRet = ProxyCall(opn);
    if(dwRet != WBEM_NO_ERROR)
    {
        m_pComLink->Release2(pResponseHandler, OBJECTSINK);
        pResponseHandler->Release();
    }

    return dwRet;
}

//***************************************************************************
//
//  CObjectSinkProxy::CObjectSinkProxy
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  pComLink            Comlink object that connects to the server
//  stubAddr          corresponding stub on the server
//
//***************************************************************************

CObjectSinkProxy::CObjectSinkProxy(
                        IN CComLink * pComLink,
                        IN IStubAddress& stubAddr)
                            : CProxy(pComLink, stubAddr)
{
    m_cRef = 0;

    /*
     * Aggregate the free-threaded marshaler for cheap in-proc
     * threading as we are thread-safe.  
     */
    HRESULT hRes = CoCreateFreeThreadedMarshaler ((IUnknown *) this, &m_pUnkInner);

    ObjectCreated(OBJECT_TYPE_OBJSINKPROXY);
    return;
}

//***************************************************************************
//
//  CObjectSinkProxy::~CObjectSinkProxy
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CObjectSinkProxy::~CObjectSinkProxy(void)
{
    ObjectDestroyed(OBJECT_TYPE_OBJSINKPROXY);
    return;
}

//***************************************************************************
// HRESULT CObjectSinkProxy::QueryInterface
// long CObjectSinkProxy::AddRef
// long CObjectSinkProxy::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CObjectSinkProxy::QueryInterface(
                        IN REFIID riid,
                        OUT PPVOID ppv)
{
    *ppv=NULL;

    // Delegate queries for IMarshal to the aggregated
    // free-threaded marshaler
    if (IID_IMarshal==riid && m_pUnkInner)
        return m_pUnkInner->QueryInterface (riid, ppv);

    if ((IID_IUnknown==riid || IID_IWbemObjectSink == riid) && ppv)
        *ppv=this;

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CObjectSinkProxy::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CObjectSinkProxy::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;

    // refernce count is zero, delete this object and the remote object.
    ReleaseProxy ();
    
    m_cRef++;   // Artificial reference count to prevent re-entrancy
    delete this;
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\comlink.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    COMLINK.H

Abstract:


History:

--*/

#ifndef _COMLINK_H_
#define _COMLINK_H_

// Size of password digests, nonces, etc

#define DIGEST_SIZE 16

// How many times will transmission be attempted

#define MAX_XMIT_TRIES 3

// how long till a timeout occurs in ms.

#define TIMEOUT_IN_MS 20000
#define MIN_TIMEOUT_IN_MS 1000
#define STROBES_PER_TIMEOUT_PERIOD 4

// Max amount of time waiting for the write mutex (ms)

#define MAX_WAIT_FOR_WRITE 3000

// Number of mail slot packets which can share a single ACK.

#define MAX_MAILSLOT 390

// Maximum number of different protocols

#define MAX_PROTOCOLS 20

// number of elements to add when the stub buffer grows

#define STUB_BUFF_GROW_SIZE 8

#define CURRENT_VERSION 0

#define NO_REPLY_YET 0xFFFF

#define PACKET_REMOTE_CREATE_REQUEST 1
#define PACKET_LOCAL_CREATE_REQUEST 2
#define PACKET_REMOTE_CREATE_ACK 3
#define PACKET_LOCAL_CREATE_ACK 4

#define COMLINK_MSG_PING        0x11
#define COMLINK_MSG_PING_ACK    0x12
#define COMLINK_MSG_NOTIFY_DESTRUCT     0x16
#define COMLINK_MSG_CALL      0x17
#define COMLINK_MSG_RETURN     0x18
#define COMLINK_MSG_RETURN_FATAL_ERROR 0x20

// These next two are used for a handshake at the end of a 
// COMLINK_MSG_CALL and COMLINK_MSG_RETURN pair

#define COMLINK_MSG_CALL_NACK     0x23
#define COMLINK_MSG_HEART_BEAT    0x24
#define COMLINK_MSG_HEART_BEAT_ACK    0x25


// note that if new stubs are added, they should be done before
// the LASTONE.

enum ProvFunc {

	ADDREFMARSH=33,
	RELEASE,
	NEXT,
	RESET,
	CLONE,
	SKIP,
	INDICATE,
    GETKEYPROTOCOLS, 
	INITCONNECTION, 
	REQUESTCHALLENGE, 
    LOGINBYTOKEN, 
	GETRESULTOBJECT,
	GETRESULTSTRING,
	GETCALLSTATUS, 
	GETSERVICES,
	NEXTASYNC, 
	SETSTATUS,
    SSPIPRELOGIN,
	WBEMLOGIN,
	ESTABLISHPOSITION
};

enum LinkType 
{
	NORMALCLIENT, 
	NORMALSERVER, 
	CLIENTCONNECT
};

#define COMLINK_MSG_CREATE_PROXY        0x214
#define COMLINK_MSG_CREATE_STUB         0x215


#define INITIAL_QUEUE_SIZE 5

typedef LONG RequestId ;

/*
 *	Forward Declarations
 */

class CComLink;
class IOperation ;

/*
 *	Handle used to Terminate ???
 */

extern HANDLE g_Terminate;  

class CObjectSinkProxy ;

//***************************************************************************
//
// STRUCT NAME:
//
// Request 
//
// DESCRIPTION:
//
// Holds all the info needed to keep track of an ongoing write or read.
//
//***************************************************************************

struct Request 
{
public:

    HANDLE m_Event ;				// Event Handle Signalled when operation response arrives
    IOperation *m_Operation ;		// Operation associated with Use Slot
    RequestId m_RequestId ;			// Request Id of Used Slot
    BOOL m_InUse ;					// Request Slot in use.
	DWORD m_Status ;				// Status of Request
};

//***************************************************************************
//
// CLASS NAME:
//
// CRequestQueue
//
// DESCRIPTION:
//
// Since the code is free threaded, there might be multiple reads or writes
// going on at any one time.  To keep track of the writes, and object of this
// class is created and another is created to keep track of the reads.
//
//***************************************************************************

class CRequestQueue
{
public:

	CRequestQueue() ;
	~CRequestQueue() ;

/*
 *	Status of Queue, Mutex is good and Container is allocated.
 */

	DWORD GetStatus ();

/* 
 *	Get Status of Request
 */

	DWORD GetRequestStatus ( HANDLE Event ) ;

/*
 *	Allocate a Request Identifier
 */

	HANDLE AllocateRequest ( IN IOperation &a_Operation ) ;

	HANDLE UnLockedAllocateRequest ( IN IOperation &a_Operation ) ;

/*
 *	Relinquish Request Slot
 */

	DWORD DeallocateRequest ( HANDLE hEvent ) ;

	DWORD UnLockedDeallocateRequest ( HANDLE hEvent ) ;

/*
 *	Get Associated Operation 
 */

	IOperation *GetOperation ( RequestId a_RequestId ) ;

/* 
 *	Get Associated Event Handle
 */

	HANDLE GetHandle ( IN RequestId a_RequestId ) ;

/*
 *	Set Status of Request and Set Event to indicate change in status
 */

	HANDLE SetEventAndStatus (IN RequestId a_RequestId , DWORD Status ) ;
  
private:

/*
 *	Extraction functions
 */

	BOOL FindByRequestId ( RequestId a_RequestId , DWORD &a_ContainerIndex ) ;

    BOOL FindByHandle ( HANDLE a_EventToFind, DWORD &a_ContainerIndex ) ;

/*
 *	Allocated/Deallocation of Requests
 */

    BOOL ExpandArray (

		DWORD dwAdditionalEntries , 
		int &piAvailable 
	) ;

    void FreeStuff () ;

    int GetEmptySlot () ;

/*
 *	Access Control to Request Queue
 */

    HANDLE m_Mutex;          

    CRITICAL_SECTION m_cs;
/*
 *	Request Container
 */

    DWORD m_RequestContainerSize ;
    Request *m_RequestContainer ;

};

class IComLinkNotification 
{
public:

	virtual void Indicate ( CComLink *a_ComLink ) {} ;
} ;

//***************************************************************************
//
// CLASS NAME:
//
// CComLink 
//
// DESCRIPTION:
//
// Two objects of this class, one on the client and one on the server, 
// maintain the communication between client and serer.  A few key 
// functions, such as xmit and read, are always overriden with transport
// specific functions.
//
//***************************************************************************

class CComLink
{
protected:

/*
 *	Reference counting 
 */

    long m_cRef;  

protected:

/*
 *	Linked list of Proxy Objects, each has associated Stub in Client/Server depending on role
 */

    CLinkList m_ObjList;

/*
 *	Role of ComLink
 */

    LinkType m_LinkType;

/*
 *	Queue of outgoing requests
 */

    CRequestQueue m_WriteQueue;  // Queue of Outgoing Requests
    CRequestQueue m_ReadQueue;   // Queue of Incoming Responses

/*
 *	Access control
 */

    HANDLE m_WriteMutex;     // controls access for writing
    CRITICAL_SECTION m_cs;

/*
 *	Handles used for inter thread ipc
 */

    HANDLE m_TerminationEvent ;		// ComLink has been informed that it should shut down because of IDLE OUT or Destruction of ComLink

/*
 *	Timing information
 */

    DWORD m_TimeoutMilliseconds ;	// Timeout
    DWORD m_LastReadTime ;			// Last time something was read.

/*
 * Factory call for making new object sink proxies.  This is implemented
 * in subclasses.
 */

	virtual CObjectSinkProxy*	CreateObjectSinkProxy (IN IStubAddress& dwStubAddr,
													   IN IWbemServices* pServices) PURE;

public:

    CComLink ( LinkType Type ) ;

    virtual ~CComLink () ;   

    enum 
	{
		no_error, 
		failed 
	};

    enum 
	{
		packet_type_call = 1, 
		packet_type_post 
	};

    DWORD GetStatus ();

    void StartTermination ()
	{
		if ( m_TerminationEvent ) 
			SetEvent ( m_TerminationEvent ) ;
	} ;

    CLinkList *GetListPtr ()
	{
		return &m_ObjList ;
	} ;

    LinkType GetType ()
	{
		return m_LinkType ;
	};

    void SetType ( LinkType a_LinkType )
	{
		m_LinkType = a_LinkType ;
	} ;

    DWORD GetTimeOfLastRead ()
	{
		return m_LastReadTime ;
	};

    DWORD GetTimeoutMilliSec ()
	{
		return m_TimeoutMilliseconds;
	} ;

/*
 *	Add a Proxy object or Just AddRef ComLink
 */

    int AddRef2 ( void *a_Proxy , ObjType a_ProxyType , FreeAction a_FreeAction );

/* 
 *	Release Comlink and Remove Proxy if pRemove != NULL
 */

    int Release2 ( void *pRemove, ObjType a_ProxyType ) ;
	int Release3 ( void *pRemove, ObjType a_ProxyType ) ;

	void ReleaseStubs () ;

/* 
 *	Abstract functions
 */

    virtual DWORD Call ( IN IOperation &a_Operation ) = 0 ;

	virtual DWORD UnLockedTransmit ( CTransportStream &a_WriteStream ) = 0 ;    
	virtual DWORD Transmit ( CTransportStream &a_WriteStream ) = 0 ;

    virtual DWORD StrobeConnection () = 0 ;  

	virtual DWORD ProbeConnection () = 0 ;  

	virtual DWORD UnLockedShutdown () = 0 ;
	virtual DWORD Shutdown () = 0 ;

	virtual DWORD HandleCall ( IN IOperation &a_Operation ) = 0 ;

	virtual void UnLockedDropLink () = 0 ;

	virtual void DropLink () = 0 ;

/*
 *	Transport endpoint specifics
 */

    virtual HANDLE GetStreamHandle ()	// Failure returns NULL, success otherwise
	{
		return NULL;
	};

    virtual void ProcessEvent ()	// Dispatch Asynchronous Event following indication
	{
	};

    virtual SOCKET GetSocketHandle ()	// Failure returns INVALID_SOCKET , success otherwise
	{
		return INVALID_SOCKET ;
	};

/*
 * Get an object sink proxy for the given stub address
 */
	CObjectSinkProxy*	GetObjectSinkProxy (IN IStubAddress& stubAddr,
											IN IWbemServices* pServices,
											IN bool createIfNotFound = TRUE);

/*
 * Check that the stub is valid
 */
	inline IUnknown*	GetStub (DWORD dwStubAddr, DWORD dwStubType)
	{
		return (m_ObjList.GetStub (dwStubAddr, (enum ObjType) dwStubType));
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\cproxy.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CPROXY.H

Abstract:

	Declares the CProxy class and those subclasses used by both proxy
	and stub.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _CProxy_H_
#define _CProxy_H_

class CProvProxy;
class CEnumProxy;
class CResProxy;
class CObjectSinkProxy;

//***************************************************************************
//
//  CLASS NAME:
//
//  CProxy
//
//  DESCRIPTION:
//
//  Generic proxy.  Always overridden so as to add functions specific to
//  whatever interface is being proxied.  However the class is useful
//  for keeping track of the comlink object, the stub address, and to
//  provide a bit of reentrancy protection.
//***************************************************************************

class CProxy : public IComLinkNotification
{
    protected:
        long				m_cRef;         //Object reference count
        IStubAddress 		*m_pStubAddr;	// remote stub address
        CComLink 			*m_pComLink;		// our transport object
        CRITICAL_SECTION	m_cs;
        DWORD				m_dwNumActiveCalls; // Number of currently active calls
		IUnknown			*m_pUnkInner;	// Aggregated free-threaded marshaler

		virtual void		ReleaseProxy () {}
		
		// Proxy factory methods - these are supplied by the derived classes
		virtual CProvProxy*	GetProvProxy (IStubAddress& stubAddr) { return NULL; }
		virtual CEnumProxy*	GetEnumProxy (IStubAddress& stubAddr) { return NULL; }
		virtual CResProxy*	GetResProxy (IStubAddress& stubAddr) { return NULL; }
		virtual CObjectSinkProxy* GetSinkProxy (IStubAddress& stubAddr) { return NULL; }

    public: 

        CProxy(CComLink * pComLink, IStubAddress& stubAddr);

        virtual			~CProxy(void);
		virtual void	ReleaseProxyFromServer () {}

        void			Indicate ( CComLink *a_ComLink );
        IStubAddress&	GetStubAdd(){return *m_pStubAddr;};
        DWORD			GetNumActiveCalls(){return m_dwNumActiveCalls;};
        DWORD			ProxyCall(IOperation& proxyOperation);

        HRESULT			CreateProxy(ObjType ot, void ** ppNew, IStubAddress& stubAddr);
        HRESULT			CallAndCleanup(ObjType ot, void ** ppNew, IOperation& opn);
        HRESULT			CallAndCleanupAsync(IOperation& opn, IWbemObjectSink FAR* pResponseHandler);
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CObjectSinkProxy
//
//  DESCRIPTION:
//
//  Client side proxy for the IWbemObjectSink interface.
//
//***************************************************************************

class CObjectSinkProxy : public IWbemObjectSink, public CProxy
{
protected:
	CObjectSinkProxy(CComLink * pComLink, IStubAddress& stubAddr);

public:
	~CObjectSinkProxy ();
	/* IUnknown methods */
	STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID FAR* ppvObj) ;
	STDMETHOD_(ULONG, AddRef)(THIS) ;
	STDMETHOD_(ULONG, Release)(THIS) ;
};

class IServerLogin : public IUnknown
{
public:
	// pseudo-IWbemLevel1Login methods

    STDMETHOD(RequestChallenge)
		(LPWSTR pNetworkResource,
        LPWSTR pUser,
        WBEM_128BITS Nonce) PURE;

	STDMETHOD(EstablishPosition)(
			LPWSTR wszClientMachineName,
			DWORD dwProcessId,
			DWORD* phAuthEventHandle)	PURE;

	STDMETHOD(WBEMLogin)
		(LPWSTR pPreferredLocale,
		WBEM_128BITS AccessToken,
		long lFlags,                   // WBEM_LOGIN_TYPE
		IWbemContext *pCtx,              
		IWbemServices **ppNamespace) PURE;

	// NTLM authentication methods
    STDMETHOD(SspiPreLogin)
        (LPSTR pszSSPIPkg,
        long lFlags,
        long lBufSize,
        byte __RPC_FAR *pInToken,
        long lOutBufSize,
        long __RPC_FAR *plOutBufBytes,
        byte __RPC_FAR *pOutToken,
		LPWSTR wszClientMachineName,
        DWORD dwProcessId,
        DWORD __RPC_FAR *pAuthEventHandle) PURE;
                    
    STDMETHOD(Login)
		(LPWSTR pNetworkResource,
		LPWSTR pPreferredLocale,
        WBEM_128BITS AccessToken,
        IN LONG lFlags,
        IWbemContext  *pCtx,
        IN OUT IWbemServices  **ppNamespace) PURE;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\linklist.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    LINKLIST.H

Abstract:

    Declares the classes and stuctures needed to maintain linked
	lists of objects.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _linklist_H_
#define _linklist_H_

enum ObjType {PROVIDER, ENUMERATOR, OBJECTSINK, LOGIN, CALLRESULT, LASTONE, 
                  CLASS, PROXY, NONE, COMLINK};
enum FreeAction {NOTIFY, RELEASEIT, DONOTHING};


//***************************************************************************
//
//  STRUCT NAME:
//
//  ListEntry 
//
//  DESCRIPTION:
//
//  This structure is used to hold a few vital statistics about each
//  of the objects keep in the list.
//
//***************************************************************************

struct ListEntry 
{
    void * m_pObj;
    ObjType m_type;
    FreeAction m_freeAction;
};

class CComLink ;

//***************************************************************************
//
//  CLASS NAME:
//
//  CLinkList
//
//  DESCRIPTION:
//
//  The comlink object has to keep track of all manner of proxies and stubs
//  that rely on it.  This class provides an easy means to keep a list of
//  these various objects.
//
//***************************************************************************

class CLinkList 
{
public:
    CLinkList( CComLink *a_ComLink);
    
    ~CLinkList(){Free();DeleteCriticalSection(&m_cs);};
    BOOL		AddEntry(void * pAdd, ObjType ot, FreeAction fa);
    BOOL		RemoveEntry(void * pDel, ObjType ot);
    void		Free(void);
    DWORD		GetProxy(IStubAddress& stubAddr);
	void		ReleaseStubs () ;
	IUnknown	*GetStub (DWORD dwStubAddr, ObjType ot);
private:
    void				DisposeOfEntry(ListEntry *);
    CFlexArray			m_Array;
    CRITICAL_SECTION	m_cs;
	CComLink			*m_ComLink ;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\maintobj.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MAINTOBJ.CPP

Abstract:

    Maintenance object for keeping track of CComLink objects.

History:

    a-davj  24-Sep-97   Created.

--*/

#include "precomp.h"
#include "wmishared.h"

DWORD ClientMaintThread ( LPDWORD pParam ) ;

//***************************************************************************
//
//  LockOut::LockOut
//  LockOut::~LockOut
//
//  DESCRIPTION:
//
//  Constructor and destructor
//
//***************************************************************************

LockOut::LockOut(CRITICAL_SECTION & cs)
{
    m_cs = &cs;
    EnterCriticalSection(m_cs);
}

LockOut::~LockOut()
{
    LeaveCriticalSection(m_cs);
}

//***************************************************************************
//
//  MaintObj::MaintObj
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//
//***************************************************************************

MaintObj :: MaintObj ( BOOL a_Client )
{
    InitializeCriticalSection ( & m_cs ) ;

    m_ChangeEvent               = CreateEvent(NULL,TRUE,FALSE,NULL);
    m_ClientThreadStartedEvent  = CreateEvent(NULL,TRUE,FALSE,NULL);
    m_ClientThreadHandle = NULL;

    m_ClientRole = a_Client;
}

//***************************************************************************
//
//  MaintObj::~MaintObj
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

MaintObj :: ~MaintObj ()
{
    // If this object is supplying the thread, as is the case in a client,
    // the thread should be terminated as a result of the global termiation
    // event already being set.  However, threads being threads, give it
    // some time to die gracefully before resorting to a termination.

    if ( m_ClientThreadHandle )
    {
        DWORD dwRes = WbemWaitForSingleObject ( m_ClientThreadHandle , 2000 ) ;
        if ( dwRes == WAIT_TIMEOUT )
        {
            TerminateThread ( m_ClientThreadHandle , 1 ) ;
        }

        CloseHandle ( m_ClientThreadHandle ) ;
    }

    DeleteCriticalSection ( & m_cs ) ;

    if ( m_ChangeEvent )
        CloseHandle ( m_ChangeEvent ) ;

    if ( m_ClientThreadStartedEvent )
        CloseHandle ( m_ClientThreadStartedEvent ) ;
}

//***************************************************************************
//
//  MaintObj::AddComLink
//
//  DESCRIPTION:
//
//  Called when it is time to add a new CComLink object to the list of things
//  being maintained.
//
//  PARAMETERS:
//
//  pComLink            Pointer to the object to be added to the list
//
//  RETURN VALUE:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT MaintObj :: AddComLink ( CComLink *a_ComLink )
{
    LockOut lock ( m_cs ) ;

    // Add the object pointer to the CComLink list

    a_ComLink->AddRef2 ( NULL , NONE , DONOTHING ) ;

    ComEntry *t_ComLinkNode = new ComEntry ( a_ComLink ) ;
    if ( t_ComLinkNode == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    HANDLE t_StreamHandle = a_ComLink->GetStreamHandle () ;

    HRESULT scRet = m_ComLinkContainer.Add ( t_ComLinkNode ) ;
    if ( SUCCEEDED ( scRet ) )
    {
        // Some comlinks use events to indicate time to read.  If this is one
        // of these, add it to the list.

        if ( t_StreamHandle )
        {
            EventEntry * t_EventNode = new EventEntry ( t_StreamHandle );
            m_EventContainer.Add ( t_EventNode ) ;
        }
    }

    // If ComLinks has transitioned to one ( actually really need to test for transition from 0 to 1 ) 
    // or event handle has been removed then update worket thread.

    if ( m_ComLinkContainer.Size () == 1 || t_StreamHandle )
    {
        SetEvent ( m_ChangeEvent ) ;
    }

    return scRet;
}

void MaintObj::Indicate ( CComLink *a_ComLink )
{
    LockOut lock ( m_cs ) ;

    // Find the entry in the list an immediatly delete it

    int t_Index ;
    ComEntry *t_ComEntryNode = FindEntry ( a_ComLink, t_Index ) ;
    if ( t_ComEntryNode == NULL )
    {
        return ;
    }

    m_ComLinkContainer.RemoveAt ( t_Index ) ;
    delete t_ComEntryNode ;

    a_ComLink->Release2 ( NULL , NONE ) ;
}

void MaintObj::UnLockedIndicate ( CComLink *a_ComLink )
{
    // Find the entry in the list an immediatly delete it

    int t_Index ;
    ComEntry *t_ComEntryNode = UnLockedFindEntry ( a_ComLink, t_Index ) ;
    if ( t_ComEntryNode == NULL )
    {
        return ;
    }

    m_ComLinkContainer.RemoveAt ( t_Index ) ;
    delete t_ComEntryNode ;

    a_ComLink->Release3 ( NULL , NONE ) ;
}

//***************************************************************************
//
//  MaintObj::ShutDownComlink
//
//  DESCRIPTION:
//
//  Called when a comlink should be terminated.  Note that the actual
//  deletion is done in the maintenace loop since we dont want the CComLink
//  object to delete itself in a member function.
//
//  PARAMETERS:
//
//  pComLink            Pointer to the object to be added to the list
//
//  RETURN VALUE:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT MaintObj::ShutDownComlink ( CComLink *a_ComLink )
{
    LockOut lock ( m_cs ) ;

    HRESULT scRet = UnLockedShutDownComlink ( a_ComLink ) ;
    return scRet;
}

//***************************************************************************
//
//  MaintObj::ShutDownComlink
//
//  DESCRIPTION:
//
//  Called when a comlink should be terminated.  Note that the actual
//  deletion is done in the maintenace loop since we dont want the CComLink
//  object to delete itself in a member function.
//
//  PARAMETERS:
//
//  pComLink            Pointer to the object to be added to the list
//
//  RETURN VALUE:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT MaintObj::UnLockedShutDownComlink ( CComLink *a_ComLink )
{
    HRESULT scRet = S_OK;

    // Find the entry in the list an immediatly delete it

    int t_Index ;
    HANDLE t_StreamHandle = NULL;
    ComEntry *t_ComEntryNode = UnLockedFindEntry ( a_ComLink, t_Index ) ;
    if ( t_ComEntryNode != NULL )
    {
        m_ComLinkContainer.RemoveAt ( t_Index ) ;
        delete t_ComEntryNode ;

        t_StreamHandle = a_ComLink->GetStreamHandle ();

        a_ComLink->UnLockedShutdown () ;

        a_ComLink->Release3 ( NULL , NONE ) ;
    }

    // some comlinks have an event for reading which needs to be deleted.
    // These cannot be deleted immediatly since the maintenance thread is
    // currently waiting on these.  So, mark it for deletion instead.

    if ( t_StreamHandle )
    {
        int t_Size = m_EventContainer.Size() ; 
        for ( int t_Index = 0; t_Index < t_Size ; t_Index ++ )
        {
            EventEntry *t_EventNode = ( EventEntry * ) m_EventContainer [ t_Index ] ;
            if(t_EventNode && ( t_EventNode->m_AsynchronousEventHandle == t_StreamHandle ) )
            {
                t_EventNode->m_DeleteASAP = TRUE;
                break;
            }
        }
    }

    // If ComLinks has transitioned to zero or event handle has been removed then update worket thread.
    
    if ( m_ComLinkContainer.Size () == 0 || t_StreamHandle )
    {
        SetEvent ( m_ChangeEvent ) ;
    }

    return scRet;
}

//***************************************************************************
//
//  MaintObj::StartClientThreadIfNeeded 
//
//  DESCRIPTION:
//
//  Only used by clients since the server uses the main thread.  This is
//  called when the locator determines that a non dcom connection is 
//  being make.
//
//***************************************************************************

HRESULT MaintObj::StartClientThreadIfNeeded ()
{
    DWORD dwRes = WbemWaitForSingleObject ( m_ClientThreadStartedEvent , 0 ) ;
    if( dwRes == WAIT_OBJECT_0 )
    {
// Thread has already been started, one per process.

        return S_FALSE ;
    }

    LockOut lock ( m_cs ) ;

    DWORD t_ThreadId;

    m_ClientThreadHandle = CreateThread (

        NULL ,
        0 ,
        ( LPTHREAD_START_ROUTINE ) ClientMaintThread ,
        ( LPVOID ) m_ClientThreadStartedEvent ,
        0,
        &t_ThreadId
    ) ;

    if ( ! m_ClientThreadHandle )
    {
        return WBEM_E_FAILED ;
    }

    DWORD t_Timeout = GetTimeout () ;
    dwRes = WbemWaitForSingleObject ( m_ClientThreadStartedEvent , t_Timeout ) ;
    if ( dwRes == WAIT_OBJECT_0 )
    {
        return S_OK ;
    }
    else
    {
        return WBEM_E_FAILED ;
    }
}

//***************************************************************************
//
//  MaintObj::ShutDownAllComlinks
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  RETURN VALUE:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT MaintObj::ShutDownAllComlinks ()
{
    LockOut lock ( m_cs ) ;

    UnLockedShutDownAllComlinks () ;

    return S_OK;
}

//***************************************************************************
//
//  MaintObj::ShutDownAllComlinks
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  RETURN VALUE:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT MaintObj::UnLockedShutDownAllComlinks ()
{
    while ( m_ComLinkContainer.Size () > 0 )
    {
        ComEntry *t_ComLinkNode = (ComEntry *) m_ComLinkContainer [ 0 ] ;
        CComLink*t_ComLink = t_ComLinkNode->m_ComLink ;

        UnLockedShutDownComlink ( t_ComLink ) ;
    }

// Should be zero by the time we get here

    int t_Size = m_EventContainer.Size () ;
    for ( int t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
    {
        EventEntry *t_EntryNode = ( EventEntry * ) m_EventContainer [ t_Index ];
        if ( t_EntryNode )
        {
            delete t_EntryNode ;
        }
    }

    return S_OK;
}

//***************************************************************************
//
//  MaintObj::CheckForHungConnections()
//
//  DESCRIPTION:
//
//  Called periodically by the server maintenace thread to eliminate any 
//  clients which have died or gone away without releasing properly.
//
//  PARAMETERS:
//
//  RETURN VALUE:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT MaintObj :: CheckForHungConnections ()
{
    LockOut lock ( m_cs ) ;

    DWORD t_RegistryTimeout = GetTimeout () ;

    int t_Size = m_ComLinkContainer.Size () ;
    for ( int t_Index = t_Size-1; t_Index >= 0; t_Index --)
    {
        ComEntry *t_ComLinkNode = ( ComEntry * ) m_ComLinkContainer [ t_Index ] ;
        if ( t_ComLinkNode )
        {
            CComLink *t_ComLink = t_ComLinkNode->m_ComLink ;
            if( t_ComLink )
            {
                DWORD t_LastActivity = GetCurrentTime () - t_ComLink->GetTimeOfLastRead () ;

// If now hearbeats have been received for some time, then
// start the termination process.  Note that does the shut down
// if there are not any active calls being processed at this time.

                if ( t_LastActivity > t_RegistryTimeout )
                {
                    t_ComLink->StartTermination () ;
            
// If there are no busy threads then shutdown comlink. There seems to be a hole in this logic !!!!!

                    if ( gThrdPool.Busy () == FALSE )
                    {
                        ShutDownComlink ( t_ComLink ) ;
                    }
                }
            }
        }
    }

    return S_OK;
}
    
//***************************************************************************
//
//  MaintObj::SendHeartBeats()
//
//  DESCRIPTION:
//
//  Sends a periodic "Keep Alive" message to the partner.
//
//  PARAMETERS:
//
//  RETURN VALUE:
//
//  S_OK if all is well, else an error code
//
//***************************************************************************

HRESULT MaintObj :: SendHeartBeats ()
{
    LockOut lock ( m_cs ) ;

    int t_Size = m_ComLinkContainer.Size () ;
    for( int t_Index = 0; t_Index < t_Size ; t_Index ++ )
    {
        ComEntry *t_ComLinkNode = ( ComEntry * ) m_ComLinkContainer [ t_Index ] ;
        if ( t_ComLinkNode )
        {
            CComLink *t_ComLink = t_ComLinkNode->m_ComLink ;
            if ( t_ComLink )            
            {
                t_ComLink->StrobeConnection () ;
            }
        }
    }

    return S_OK;
}

//***************************************************************************
//
//  MaintObj::FindEntry()
//
//  DESCRIPTION:
//
//  Finds a particular CComLink in the list, returns a pointer and the index
//  is set.
//
//  PARAMETERS:
//
//  pComLink            CComLink object pointer
//  iFind               set to the index in our array.
//
//  RETURN VALUE:
//
//  Pointer to ComEntry object.  Note that iFind is set via reference
//
//***************************************************************************

ComEntry *MaintObj :: UnLockedFindEntry ( CComLink *a_ComLink , int &a_Index )
{
    a_Index = -1 ;

    int t_Size = m_ComLinkContainer.Size();

    for( int t_Index = 0; t_Index < t_Size; t_Index ++ )
    {
        ComEntry *t_ComLinkNode = ( ComEntry * ) m_ComLinkContainer [ t_Index ] ;
        if ( a_ComLink == t_ComLinkNode->m_ComLink )
        {
            a_Index = t_Index ;
            return t_ComLinkNode ;
        }
    }

    return NULL ;
}

//***************************************************************************
//
//  MaintObj::FindEntry()
//
//  DESCRIPTION:
//
//  Finds a particular CComLink in the list, returns a pointer and the index
//  is set.
//
//  PARAMETERS:
//
//  pComLink            CComLink object pointer
//  iFind               set to the index in our array.
//
//  RETURN VALUE:
//
//  Pointer to ComEntry object.  Note that iFind is set via reference
//
//***************************************************************************

ComEntry *MaintObj :: FindEntry ( CComLink *a_ComLink , int &a_Index )
{
    LockOut lock ( m_cs ) ;

    return UnLockedFindEntry ( a_ComLink , a_Index ) ;
}

//***************************************************************************
//
//  MaintObj::GetSocketComLink()
//
//  DESCRIPTION:
//
//  Given a socket number, this finds the CComLink object which is using
//  this socket.
//
//  PARAMETERS:
//
//  s                   Socket number
//
//  RETURN VALUE:
//
//  CComlink object, NULL if not found.
//
//***************************************************************************

CComLink *MaintObj :: GetSocketComLink ( SOCKET s )
{
    LockOut lock ( m_cs ) ;

    int t_Size = m_ComLinkContainer.Size () ;
    for( int t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
    {
        ComEntry *t_ComLinkNode = ( ComEntry * ) m_ComLinkContainer [ t_Index ] ;
        if ( t_ComLinkNode )
        {
            CComLink *t_ComLink = t_ComLinkNode->m_ComLink ;
            
            if ( t_ComLink && t_ComLink->GetSocketHandle () == s )
            {
                return t_ComLink ;
            }
        }
    }

    return NULL;
}

//***************************************************************************
//
//  MaintObj::GetEvents()
//
//  DESCRIPTION:
//
//  This is called by the maintenace thread an it returns a list of events
//  to wait on and sets the time between pings.  Note that the handle list
//  includes the termination event, the change in state event, as well as 
//  any asynchronous read events.
//
//  PARAMETERS:
//
//  ghTerminate         Terminate event
//  piNum               Set to the number of events returned
//  pdwRest             Set to the time between pings
//  bServer             True if being called by the server.  Note that
//                      this currently isnt relevant.  
//  RETURN VALUE:
//
//  pointer to a handle array.  Note that the CALLER SHOULD FREE THIS when
//  it is either done, or needs a fresh list.
//
//***************************************************************************

HANDLE *MaintObj::GetEvents (

    HANDLE a_Terminate, 
    int &a_EventContainerSize , 
    DWORD &a_EventTimeout 
)
{
    // note that this is called by the maintenance thread in responce
    // to the change event being set.  

    LockOut lock ( m_cs ) ;

    // Figure out how long to delay

    DWORD t_ComLinkCount = m_ComLinkContainer.Size();
    if ( t_ComLinkCount )
    {
        DWORD t_RegistryTimeout = GetTimeout () / STROBES_PER_TIMEOUT_PERIOD ;
        a_EventTimeout = t_RegistryTimeout ;
    }
    else 
    {
        a_EventTimeout = INFINITE;
    }

    // find out how many events need to be watched for the comlinks

    int t_Size = m_EventContainer.Size() ;
    int t_NumberOfAsyncEvents = 0 ;
    int t_NumberToDelete = 0 ;

    for ( int t_Index = 0; t_Index < t_Size ; t_Index ++ )
    {
        EventEntry *t_AsyncEntry = ( EventEntry * ) m_EventContainer [ t_Index ] ;
        if ( t_AsyncEntry )
        {
            if ( t_AsyncEntry->m_DeleteASAP )
            {
                t_NumberToDelete ++ ;
            }
            else
            {
                t_NumberOfAsyncEvents ++ ;
            }
        }
    }

    a_EventContainerSize = t_NumberOfAsyncEvents + 2 ;
    HANDLE *t_EventContainer = new HANDLE [ a_EventContainerSize ] ;
    t_EventContainer[0] = a_Terminate;
    t_EventContainer[1] = m_ChangeEvent;

    // Add each comlink event entry to the list

    int t_ContainerIndex = 2;
    for ( t_Index = 0; t_Index < t_Size ; t_Index ++ )
    {
        EventEntry *t_AsyncEntry = ( EventEntry * ) m_EventContainer [ t_Index ] ;
        if ( t_AsyncEntry )
        {
            if ( t_AsyncEntry->m_DeleteASAP == FALSE )
            {
                t_EventContainer [ t_ContainerIndex ] = t_AsyncEntry->m_AsynchronousEventHandle ;
                t_ContainerIndex ++ ;
            }
        }
    }

    if ( t_NumberToDelete != 0 )
    {
        // Delete any unused event objects

        for ( t_Index = t_Size - 1 ; t_Index >= 0; t_Index -- )
        {
            EventEntry *t_AsyncEntry = ( EventEntry * ) m_EventContainer [ t_Index ] ;
            if ( t_AsyncEntry )
            {
                if ( t_AsyncEntry->m_DeleteASAP )
                {
                    m_EventContainer.RemoveAt ( t_Index ) ;
                    delete t_AsyncEntry ;
                }
            }
        }

        m_EventContainer.Compress () ;
    }

    ResetEvent ( m_ChangeEvent ) ;

    return t_EventContainer ;
}

//***************************************************************************
//
//  MaintObj::ServiceEvent()
//
//  DESCRIPTION:
//
//  Called by the maintenance thread when one of the events used by CComLinks
//  to indicate read ready data is set.
//
//  PARAMETERS:
//
//  hEvent              Event that was set.
//
//***************************************************************************

void MaintObj :: ServiceEvent ( HANDLE a_Event )
{
    LockOut lock ( m_cs ) ;

    int t_Size = m_ComLinkContainer.Size () ;

    for ( int t_Index = 0 ; t_Index < t_Size ; t_Index ++ )
    {
        ComEntry *t_ComLinkNode = ( ComEntry * ) m_ComLinkContainer [ t_Size ];
        if ( t_ComLinkNode )
        {
            CComLink *t_ComLink = t_ComLinkNode->m_ComLink ;
            if ( a_Event == t_ComLink->GetStreamHandle () )
            {          
                t_ComLink->ProcessEvent () ;
                return ;
            }
        }
    }

    ResetEvent ( a_Event ) ;     //hmm, never found it, reset so we dont go into infinite loop
}

BOOL MaintObj :: ClientRole ()
{
    return m_ClientRole ;
}

//***************************************************************************
//
//  DWORD ClientMaintThread
//
//  DESCRIPTION:
//
//  Periodically pings the connection and thus detects when the connection
//  has died.
//
//  PARAMETERS:
//
//  pParam              points to the comlink object that is to be watched.
//
//  RETURN VALUE:
//
//  N/A
//***************************************************************************

DWORD ClientMaintThread ( LPDWORD pParam )
{
    DWORD t_EventTimeout = 0 ;

    // Do some initial work and signal when we are ready.
    
    HANDLE t_ThreadStartedEvent = ( HANDLE ) pParam ;
    SetEvent ( t_ThreadStartedEvent ) ;

    int t_EventContainerSize ;

    HANDLE *t_EventContainer = gMaintObj.GetEvents ( g_Terminate , t_EventContainerSize , t_EventTimeout ) ;

    while(1) 
    {
        DWORD dwRet = MsgWaitForMultipleObjects ( t_EventContainerSize , t_EventContainer , FALSE, t_EventTimeout , QS_ALLINPUT ) ; 
                            
        // Check for termination, if that is the case free up and exit.
        // ============================================================

        if ( dwRet == 0xffffffff )
        {
            DWORD t_GetLastError = GetLastError () ;
        }
        else if ( dwRet == WAIT_OBJECT_0 )
        {
            // Ok, delete the comlink objects and exit!

            delete [] t_EventContainer;

            gMaintObj.ShutDownAllComlinks () ;
            ExitThread(0);
        }
        else if ( dwRet == ( WAIT_OBJECT_0 + 1 ) )
        {
            // There has been a change in either the number of connections, or
            // the number of active connections.

            delete [] t_EventContainer ;
            t_EventContainer = gMaintObj.GetEvents ( g_Terminate , t_EventContainerSize , t_EventTimeout ) ;
        }
        else if ( ( dwRet >= ( WAIT_OBJECT_0 + t_EventContainerSize ) ) && ( dwRet < ( WAIT_OBJECT_0 + t_EventContainerSize ) ) )
        {
            gMaintObj.ServiceEvent ( t_EventContainer [ dwRet - WAIT_OBJECT_0 ] ) ;
        }
        else if ( dwRet == WAIT_TIMEOUT )
        {

// time period elapsed

DEBUGTRACE((LOG,"\nHeart Beat"));

            if ( gMaintObj.ClientRole () )
            {
                gMaintObj.SendHeartBeats ();
            }

DEBUGTRACE((LOG,"\nHung Connections"));

            gMaintObj.CheckForHungConnections () ;

DEBUGTRACE((LOG,"\nCompleted Check for Hung Connections"));

        }
        else
        {
            MSG t_Message ;
            BOOL t_Status = PeekMessage ( &t_Message , NULL , 0 , 0 , PM_REMOVE ) ;
            if ( t_Status )
            {
                TranslateMessage ( &t_Message ) ;
                DispatchMessage ( &t_Message ) ;
            }
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\maintobj.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MAINTOBJ.H

Abstract:

    Declares the MaintObj class.

History:

	a-davj  24-Sep-97   Created.

--*/

#ifndef _MaintObj_H_
#define _MaintObj_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  ComEntry
//
//  DESCRIPTION:
//
//  This is just a self initializing structure which keeps track of 
//  a single CComLink object
//***************************************************************************

class ComEntry
{
public:

    ComEntry ( CComLink * pComLink )
	{
		m_ComLink = pComLink; 
        m_FirstPingTime = 0;
	} ;

    ~ComEntry(){};

    CComLink *m_ComLink ;

    DWORD m_FirstPingTime;
};

//***************************************************************************
//
//  CLASS NAME:
//
//  EventEntry
//
//  DESCRIPTION:
//
//  This is just a self clearing structure which keeps track of 
//  a single event object
//***************************************************************************

class EventEntry
{
public:

    EventEntry ( HANDLE a_AsynchronousEventHandle )
	{
		m_AsynchronousEventHandle = a_AsynchronousEventHandle ; 
		m_DeleteASAP = FALSE;
	} ;

    ~EventEntry()
	{
		if ( m_AsynchronousEventHandle )
			CloseHandle ( m_AsynchronousEventHandle ) ;
	};

    HANDLE m_AsynchronousEventHandle ;

    BOOL m_DeleteASAP ;
};

//***************************************************************************
//
//  CLASS NAME:
//
//  LockOut
//
//  DESCRIPTION:
//
//  A trivial class whose only purpose is to provide a simple way of making 
//  routines thread safe.  See some of the code in MaintObj.cpp for examples
//  of its use.
//***************************************************************************

class LockOut 
{
public:

	LockOut ( CRITICAL_SECTION &cs ) ;
    ~LockOut () ;

private:

	CRITICAL_SECTION *m_cs ;
};

//***************************************************************************
//
//  CLASS NAME:
//
//  MaintObj
//
//  DESCRIPTION:
//
//  Keeps track of the CComLink objects.
//***************************************************************************

class MaintObj : public IComLinkNotification
{
private:

	ComEntry *FindEntry ( CComLink *pComLink , int & iFind ) ;
	ComEntry *UnLockedFindEntry ( CComLink *pComLink , int & iFind ) ;

	CFlexArray m_ComLinkContainer ;            // holds list of CComLink objects

	CFlexArray m_EventContainer ;              // Some CComlink ojbects have async notifiy events.

	HANDLE m_ChangeEvent ;
	HANDLE m_ClientThreadHandle ;
	HANDLE m_ClientThreadStartedEvent ;

	BOOL m_ClientRole ;

	CRITICAL_SECTION m_cs;

public: 

	MaintObj ( BOOL a_Client ) ;
    ~MaintObj () ;

	SCODE AddComLink ( CComLink *a_ComLink ) ;

    SCODE UnLockedShutDownComlink ( CComLink *a_ComLink ) ;
    SCODE ShutDownComlink ( CComLink *a_ComLink ) ;
	SCODE UnLockedShutDownAllComlinks () ;
    SCODE ShutDownAllComlinks () ;

	void UnLockedIndicate ( CComLink *a_ComLink ) ;
	void Indicate ( CComLink *a_ComLink ) ;

    SCODE CheckForHungConnections () ;
    SCODE SendHeartBeats () ;

    CComLink *GetSocketComLink ( SOCKET a_Socket ) ;

    HRESULT StartClientThreadIfNeeded();

    void ServiceEvent ( HANDLE hEvent ) ;

    HANDLE *GetEvents ( HANDLE a_TerminateHandle , int &a_EventContainerSize , DWORD &a_Timeout ) ;

	HANDLE GetThreadHandle () { return m_ClientThreadHandle ; }
	BOOL ClientRole () ;

	CRITICAL_SECTION *GetCriticalSection () { return &m_cs ; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\linklist.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    LINKLIST.CPP

Abstract:

    Class which maintains lists of Objects.

History:

    a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include "wmishared.h"


//***************************************************************************
//
//  CLinkList::CLinkList
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CLinkList::CLinkList ( CComLink *a_ComLink ) : m_ComLink ( a_ComLink )
{
    InitializeCriticalSection(&m_cs);
}

//***************************************************************************
//
//  BOOL CLinkList::AddEntry
//
//  DESCRIPTION:
//
//  Adds an object to the list
//
//  PARAMETERS:
//
//  pAdd                Pointer to object to add
//  ot                  object type
//  fa                  how to dispose of the object
//
//  RETURN VALUE:
//
//  Return: true if OK.
//
//***************************************************************************

BOOL CLinkList::AddEntry(
                        IN void * pAdd,
                        IN ObjType ot,
                        IN FreeAction fa)
{
    int iRet;
    ListEntry * pNew = new ListEntry();
    if(pNew == NULL)
        return FALSE;
    pNew->m_pObj = pAdd;
    pNew->m_type = ot;
    pNew->m_freeAction = fa;

    EnterCriticalSection(&m_cs);

    iRet = m_Array.Add(pNew);
    LeaveCriticalSection(&m_cs);
    if(iRet == CFlexArray::no_error)
        return TRUE;
    else
    {
        delete pNew;
        return FALSE;
    }
}

//***************************************************************************
//
//  BOOL CLinkList::RemoveEntry
//
//  DESCRIPTION:
//
//  Removes an object from the list
//
//  PARAMETERS:
//
//  pDel                pointer to object to be removed
//  ot                  object type
//
//  RETURN VALUE:
//
//  Return: true if OK.
//
//***************************************************************************

BOOL CLinkList::RemoveEntry(
                        IN void * pDel,
                        IN ObjType ot)
{
    int iCnt;
    BOOL bFound = FALSE;
    if(pDel == NULL)
        return TRUE;
    int iRet = CFlexArray::failed;
    EnterCriticalSection(&m_cs);
    for(iCnt = 0; iCnt < m_Array.Size(); iCnt++)
    {
        ListEntry * pCurr = (ListEntry *)m_Array.GetAt(iCnt);
        if(pCurr != NULL)
            if(pCurr->m_pObj == pDel && pCurr->m_type == ot)
            {
                // Found it.  Note that this routine does not need
                // to delete the actual object since this routine is
                // generally called by the object's destructor.
                // =================================================

                iRet = m_Array.RemoveAt(iCnt);
                delete pCurr;
                bFound = TRUE;      
                break;
            }
    }
    LeaveCriticalSection(&m_cs);
    return iRet == CFlexArray::no_error;
}

void CLinkList::ReleaseStubs ()
{
    EnterCriticalSection(&m_cs);

    for(int iCnt = 0; iCnt < m_Array.Size(); iCnt++)
    {
        ListEntry * pCurr = (ListEntry *)m_Array.GetAt(iCnt);
        if(pCurr != NULL)
        {
            switch (pCurr->m_type )
            {
                case PROVIDER:
                case ENUMERATOR:
                case OBJECTSINK: 
                case LOGIN:
                case CALLRESULT:
                {

                    int iRet = m_Array.RemoveAt(iCnt--);

                    IUnknown * pObj = (IUnknown *)pCurr->m_pObj;
                    pObj->Release();

                    delete pCurr;

                    m_ComLink->Release2 ( NULL , NONE ) ;
                }
                break ;

                case PROXY:
                {
                    int iRet = m_Array.RemoveAt(iCnt--);

                    // Tidy up proxy to release server resources
                    CProxy *pObj = (CProxy *) pCurr->m_pObj;

                    delete pCurr;

                    pObj->ReleaseProxyFromServer ();
                }
                break;

                default:
                {
                }
                break ;
            }
        }
    }

    LeaveCriticalSection(&m_cs);
}

//***************************************************************************
//
//  void CLinkList::Free
//
//  DESCRIPTION:
//
//  Called by the destructor to get rid of everything.  Typcially
//  this is used by the comlink destructor and so it must get rid of any
//  unused proxies and stubs.
//
//***************************************************************************

void CLinkList::Free(void)
{
    int iCnt;
    EnterCriticalSection(&m_cs);
    for(iCnt = m_Array.Size() -1; iCnt >= 0 ; iCnt--)
    {
        ListEntry* pCurr = (ListEntry *)m_Array.GetAt(iCnt);
        if(pCurr != NULL)
        {

            // Remove from list, also delete the list object and get rid
            // of the object itself since it hasnt gone away on its own.

            m_Array.RemoveAt(iCnt);
            DisposeOfEntry(pCurr);
            delete pCurr;      
        }
    }
    LeaveCriticalSection(&m_cs);
}

//***************************************************************************
//
//  BOOL CLinkList::GetStub
//
//  DESCRIPTION:
//
//  Given a stub address and type returns the actual stub (AddRef'd)
//
//  PARAMETERS:
//
//  dwStubAddr            Expected stub address
//  ot                  object type
//
//  RETURN VALUE:
//
//  Return: true if OK.
//
//***************************************************************************

IUnknown* CLinkList::GetStub(
                        IN DWORD dwStubAddr,
                        IN ObjType ot)
{
    int iCnt;
    EnterCriticalSection(&m_cs);
    for(iCnt = 0; iCnt < m_Array.Size(); iCnt++)
    {
        ListEntry * pCurr = (ListEntry *)m_Array.GetAt(iCnt);

        if(pCurr)
		{
#ifdef _WIN64
			void * pTest = (void *)dwStubAddr;
            if(pCurr->m_pObj == pTest && pCurr->m_type == ot)
#else
			if((DWORD)pCurr->m_pObj == dwStubAddr && pCurr->m_type == ot)
#endif
            {
                IUnknown * pObj = (IUnknown *)pCurr->m_pObj;
                pObj->AddRef ();
                LeaveCriticalSection(&m_cs);
                return pObj;
            }
		}
    }
    LeaveCriticalSection(&m_cs);
    return NULL;
}


//***************************************************************************
//
//  void CLinkList::DisposeOfEntry
//
//  DESCRIPTION:
//
//  Gets rid of a proxy or stub.
//
//  PARAMETERS:
//
//  pDispose            Object to get rid of
//
//***************************************************************************

void CLinkList::DisposeOfEntry(
                        ListEntry * pDispose)
{                                                          
    
    if(pDispose->m_freeAction == RELEASEIT)
    {
        // This case takes care of ObjectSink objects.  They should not
        // be deleted, but released.

        IUnknown * pObj = (IUnknown *)pDispose->m_pObj;
        pObj->Release();
    }
    else if(pDispose->m_freeAction == NOTIFY)
    {
        // for proxies, we need to make sure there are no active calls 
        // so as to avoid deleteing the object out from underneath the
        // threads.

        IComLinkNotification * pObj = (IComLinkNotification *)pDispose->m_pObj;
        pObj->Indicate ( m_ComLink );
    }
}

//***************************************************************************
//
//  void CLinkList::GetProxy
//
//  DESCRIPTION:
//
//  Given the remote partners stub address, this finds the corresponding
//  proxy address.
//
//  PARAMETERS:
//
//  dwStub              Stub address
//
//  Return Value:
//
//  Stub address if successful, otherwise it returns 0
//
//***************************************************************************

DWORD CLinkList::GetProxy(IStubAddress& stubAddr)
{
    int iCnt;
    DWORD dwRet = 0;
    EnterCriticalSection(&m_cs);
    for(iCnt = 0; iCnt < m_Array.Size(); iCnt++)
    {
        ListEntry * pCurr = (ListEntry *)m_Array.GetAt(iCnt);
        if(pCurr)
            if(pCurr->m_type == PROXY)
                {
                    CProxy * pProxy = (CProxy *)pCurr->m_pObj;
                    if(pProxy && stubAddr.IsEqual (pProxy->GetStubAdd()))
                    {
#ifdef _WIN64
						unsigned __int64 lTemp = (unsigned __int64)pProxy;
						dwRet = (DWORD)lTemp;
#else
                        dwRet = (DWORD)pProxy;
#endif
                        break;
                    }
                }
    }
    LeaveCriticalSection(&m_cs);
    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\iopn.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    IOPN.H

Abstract:

    Declares the fundamental protocol-independent operation class

History:

	alanbos  18-Dec-97   Created.

--*/

#ifndef _IOPN_H_
#define _IOPN_H_

#if 0
typedef enum tag_WBEM_LOGIN_TYPE
{
    WBEM_FLAG_INPROC_LOGIN = 0,
    WBEM_FLAG_LOCAL_LOGIN  = 1,
    WBEM_FLAG_REMOTE_LOGIN = 2,
    WBEM_AUTHENTICATION_METHOD_MASK  = 0xF,

    WBEM_FLAG_USE_MULTIPLE_CHALLENGES = 0x10,
}   WBEM_LOGIN_TYPE;
#endif

typedef enum tag_WBEM_COM_METHOD_MASK
{
    WBEM_METHOD_OpenNamespace            = 0x1,
    WBEM_METHOD_CancelAsyncCall          = 0x2,
    WBEM_METHOD_QueryObjectSink          = 0x4,

    // Class & instance retrieval.
    // ===========================

    WBEM_METHOD_GetObject                = 0x8,
    WBEM_METHOD_GetObjectAsync           = 0x10,

    // Class Manipulation Methods
    // ==========================
    WBEM_METHOD_PutClass                 = 0x20,
    WBEM_METHOD_PutClassAsync            = 0x40,
    WBEM_METHOD_DeleteClass              = 0x80,
    WBEM_METHOD_DeleteClassAsync         = 0x100,
    WBEM_METHOD_CreateClassEnum          = 0x200,
    WBEM_METHOD_CreateClassEnumAsync     = 0x400,

    // Instance manipulation.
    // ============================
    WBEM_METHOD_PutInstance                 = 0x800,
    WBEM_METHOD_PutInstanceAsync            = 0x1000,
    WBEM_METHOD_DeleteInstance              = 0x2000,
    WBEM_METHOD_DeleteInstanceAsync         = 0x4000,
    WBEM_METHOD_CreateInstanceEnum          = 0x8000,
    WBEM_METHOD_CreateInstanceEnumAsync     = 0x10000,

    // Queries.
    // ========
    WBEM_METHOD_ExecQuery                  = 0x20000,
    WBEM_METHOD_ExecQueryAsync             = 0x40000,
	WBEM_METHOD_ExecNotificationQuery      = 0x80000,
    WBEM_METHOD_ExecNotificationQueryAsync = 0x100000,

    // Methods
    // =======
    WBEM_METHOD_ExecMethod                 = 0x400000,
    WBEM_METHOD_ExecMethodAsync            = 0x800000,

}   WBEM_COM_METHOD_MASK;

// Base class (abstract) for any proxied operation irrespective
// of interface or protocol.  This encapsulates both the
// operation request and the response.
class IOperation
{
private:
	CTransportStream			m_decodeStream;	// for decoding MSG_RETURN
	static RequestId	m_id;			// per-call unique id generator
	RequestId			m_requestId;	// the unique id for this call (app global)
	bool				m_async;		// whether the API call was async
	bool				m_moreData;		// if there is more data to encode (sending only)
	HRESULT				m_status;		// the call status (to be returned to caller)
	IWbemContext*		m_pContext;		// any context info for the call
	IWbemCallResult**	m_ppCallResult;	// The caller's pointer for semisynchronous mode
	IErrorInfo*			m_pErrorInfo;	// In case of error; this may be decoded and set
										// in different threads
	IStubAddress*		m_addr [LASTONE];		// any returned stub addresses
			
protected:
	inline IOperation (IWbemContext* pContext = NULL, IWbemCallResult** ppResult = NULL,
		bool isAsync = FALSE) :
		m_async (isAsync),
		m_moreData (false),
		m_requestId (InterlockedIncrement (&m_id)),
		m_pContext (pContext),
		m_ppCallResult (ppResult),
		m_status (WBEM_NO_ERROR),
		m_pErrorInfo (NULL)
	{
		if (m_pContext)
			m_pContext->AddRef ();

		for (DWORD i = 0; i < LASTONE; i++) m_addr [i] = NULL;
	}

	
	// Some operations need to create a proxy on return - this sets the address
	void	SetProxyAddress (ObjType type, IStubAddress& stubAddr) 
	{ 
		if (m_addr [type])
			delete m_addr [type];
		m_addr [type] = stubAddr.Clone (); 
	}

	// The following methods are intended to be called by the CProvProxy subclasses
	// only.  The first determines whether the caller expected an IWbemCallResult
	// to be returned, and the second is used to determine the proxy address (in the
	// case the the corresponding COM API call returns another proxied interface pointer).
	void				SetResultObjectPP (IWbemCallResult** ppCallResult)
							{ m_ppCallResult = ppCallResult; }

	IWbemContext*		GetContext () { return m_pContext; }
	void				SetContext (IWbemContext* pContext);
	

	// Set by subclasses to indicate whether there is more data to come
	inline void	SetMoreData (bool moreData) { m_moreData = moreData; }
	inline bool	IsMoreData () { return m_moreData; }

	// Get and Set IErrorInfo helper methods used by subclasses
	IErrorInfo*		GetErrorInfoFromObject ();
	void			SetErrorInfoIntoObject (IErrorInfo* pInfo);

	// Used on stub side to set the current thread IErrorInfo (if any)
	// into this object. 
	void			SetErrorInfoIntoObject ();

public:
	inline virtual ~IOperation () 
	{
		if (m_pContext) m_pContext->Release ();
		if (m_pErrorInfo) m_pErrorInfo->Release ();

		for (DWORD i = 0; i < LASTONE; i++) delete m_addr [i];
	}

	// These must be overriden in the subclass. Decode functions assume
	// no packet header, whereas Encode functions will encode the packet
	// header.  Note that proxies implement 
	virtual bool	DecodeRequest (CTransportStream& decodeStream, 
									ISecurityHelper& securityHelper) PURE;
	virtual bool	DecodeResponse (CTransportStream& decodeStream, 
									ISecurityHelper& securityHelper) PURE;
	virtual bool	EncodeRequest (CTransportStream& encodeStream, 
									ISecurityHelper& securityHelper) PURE;
	virtual bool	EncodeResponse (CTransportStream& encodeStream, 
									ISecurityHelper& securityHelper) PURE;

	// Used on stubs; comlink calls this to initiate the stub handling.  
	inline virtual void	HandleCall (CComLink& comLink) {};

	// Return the request id unique to this operation
	inline RequestId	GetRequestId () { return m_requestId; }
	inline void	SetRequestId (RequestId requestId) { m_requestId = requestId; }
	
	// Access to the COM operation response status
	inline HRESULT		GetStatus () { return m_status; }
	inline void			SetStatus (HRESULT status) { m_status = status; }

	// Indicates whether the operation as requested by the client is asynchronous
	inline bool			IsAsync () { return m_async; }

	// Indicates whether the COMLink should wait for a protocol-level response
	// before returning on the send thread, or whether a simple transport-level 
	// dispatch of the request is all that is required.
	inline virtual bool	WaitForAck () { return TRUE; }

	// Used on the proxy side to set the error info decoded into this operation
	// into the current thread.
	void			SetErrorInfoOnThread ();

	inline IStubAddress*		GetProxyAddress (ObjType type) { return m_addr [type]; }

	inline IWbemCallResult**	GetResultObjectPP () { return m_ppCallResult; }

	inline CTransportStream&			GetDecodeStream () { return m_decodeStream; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\package.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PACKAGE.H

Abstract:

    Declares the PACKET_HEADER and CPackage classes.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _package_H_
#define _package_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  PACKET_HEADER
//
//  DESCRIPTION:
//
//  Each chunk of data that is read or written via CComLink starts with some
//  header information and this class encapsulates that info.
//
//***************************************************************************

class PACKET_HEADER 
{
private:

	DWORD m_Signature;
	DWORD m_Type;
    RequestId m_RequestId ;
    DWORD m_TotalSize;

public: 

    PACKET_HEADER ( DWORD a_Type , DWORD a_AdditionalSize , RequestId a_RequestId );
    PACKET_HEADER () ;
    ~PACKET_HEADER () ;

	void SetType ( DWORD a_Type ) { m_Type = a_Type ; }
	void SetRequestId ( RequestId a_RequestId ) { m_RequestId = a_RequestId ; }
	void SetTotalDataSize ( DWORD a_TotalDataSize ) { m_TotalSize = a_TotalDataSize + sizeof ( PACKET_HEADER ) ; }
	void SetSize ( DWORD a_TotalSize ) { m_TotalSize = a_TotalSize ; } 

    DWORD GetType(){return m_Type;};
    RequestId GetRequestId (){return m_RequestId ;};
    DWORD GetSize(){return m_TotalSize;};
    DWORD GetTotalDataSize(){return m_TotalSize-sizeof(PACKET_HEADER);};

    BOOL Verify();
};

#define PHSIZE sizeof(PACKET_HEADER)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\package.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    PACKAGE.CPP

Abstract:

    Defines the CPackage class which provides a pool of threads
    to handle calls.

History:

    a-davj  06-Nov-96   Created.

--*/

#include "precomp.h"
#include "wmishared.h"

//***************************************************************************
//
//  PACKET_HEADER::PACKET_HEADER
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  dwType              type of package
//  dwAdditionalSize    total size of the data in the package
//  guidPacketID        guid of the package
//
//***************************************************************************

PACKET_HEADER::PACKET_HEADER (

    IN DWORD a_Type,
    IN DWORD a_AdditionalSize,
    IN RequestId a_RequestId 
)
{
    m_Signature = 0x4f4c454d;
    m_Type = a_Type ;
    m_RequestId = a_RequestId ;
    m_TotalSize = a_AdditionalSize + PHSIZE ;

    ObjectCreated(OBJECT_TYPE_PACKET_HEADER);
}

//***************************************************************************
//
//  PACKET_HEADER::PACKET_HEADER
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

PACKET_HEADER::PACKET_HEADER()
{
    m_Signature = m_Type = m_TotalSize = 0;

    ObjectCreated(OBJECT_TYPE_PACKET_HEADER);
}

//***************************************************************************
//
//  PACKET_HEADER::~PACKET_HEADER
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

PACKET_HEADER::~PACKET_HEADER()
{
    ObjectDestroyed(OBJECT_TYPE_PACKET_HEADER);
}

//***************************************************************************
//
//  BOOL PACKET_HEADER::Verify
//
//  DESCRIPTION:
//
//  Check the package header for the correct signature bytes.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL PACKET_HEADER::Verify()
{
    return ( m_Signature == 0x4f4c454d ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\pipeopn.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PIPEOPN.CPP

Abstract:

    Declares the abstract and generic (to proxy and stub) pipe operation classes

History:

    alanbos  18-Dec-97   Created.

--*/

#include "precomp.h"
#include "wmishared.h"

// Used as a placeholder in the encode stream
static PACKET_HEADER gDummyPacketHeader (0,0,0);

// IOperation_LPipe

bool IOperation_LPipe::DecodeCallHeader (CTransportStream& decodeStream,
                    OUT DWORD& dwStubAddr, OUT DWORD& dwStubType,
                    OUT DWORD& dwStubFunc)
{
    // Decode the stub address, type and method call id
    DWORD dwInSt = CTransportStream::no_error;
    dwInSt |= decodeStream.ReadDWORD (&dwStubAddr);
    dwInSt |= decodeStream.ReadDWORD (&dwStubType);
    dwInSt |= decodeStream.ReadDWORD (&dwStubFunc);

    return (CTransportStream::no_error == dwInSt);
}

// IBasicOperation_LPipe
void    IBasicOperation_LPipe::EncodePacketHeader (CTransportStream& encodeStream,
                                                   DWORD msgType)
{
#if 0
    // TODO - this is gross as we have to copy the current contents twice!
    // What we need is either (1) WriteBytes should not reset the end of stream,
    // or (2) introduce a Prepend operation.

    // Copy the current encoded stream contents - this is the data minus the
    // header
    CTransportStream        dataStream (encodeStream);

    // Determine the data length and set in the header
    PACKET_HEADER   ph (msgType, dataStream.Size () - PHSIZE, GetRequestId ());
    
    // Serialize the header into the stream - note this will squelch the original
    // data hence the copy above.
    encodeStream.Reset ();
    encodeStream.WriteBytes (&ph, PHSIZE);

    // Add the original data contents again
    encodeStream.Append (&dataStream);
#else
    PACKET_HEADER ph (msgType, encodeStream.Size () - PHSIZE, GetRequestId ());
    DWORD   curPos = encodeStream.GetCurrentPos ();
    encodeStream.Reset ();
    encodeStream.WriteBytes (&ph, PHSIZE);
    encodeStream.SetCurrentPos (curPos);
#endif
}

bool IBasicOperation_LPipe::DecodeHeader (BYTE *pByte, DWORD numBytes, PACKET_HEADER& header)
{
    if (PHSIZE != numBytes)
        return FALSE;

    memcpy ((void *) &header, pByte, PHSIZE);
    return TRUE;
}

void IBasicOperation_LPipe::DecodeResult (CTransportStream& decodeStream)
{
    DWORD dwCallRet = WBEM_E_FAILED;    // Just in case
    decodeStream.ReadDWORD(&dwCallRet);
    SetStatus (dwCallRet);
}

bool IBasicOperation_LPipe::EncodeRequest 
            (CTransportStream& encodeStream, ISecurityHelper& secHelp)
{
#if 0
#else
    // Put a dummy header in for now.
    encodeStream.WriteBytes ((LPVOID) &gDummyPacketHeader, PHSIZE);
#endif

    // Encode the per-operation data
    EncodeOperationReq (encodeStream);
    // Encode header now because we finally know the data length
    EncodePacketHeader (encodeStream, GetMessageType ());  
    return true;
}

bool IBasicOperation_LPipe::DecodeRequest 
            (CTransportStream& encodeStream, ISecurityHelper& secHelp)
{
    // Note: the packet header has already been removed
    DecodeOperationReq (encodeStream);
    return true;
}

bool IBasicOperation_LPipe::EncodeResponse 
            (CTransportStream& encodeStream, ISecurityHelper& secHelp)
{
#if 0
#else
    // Put a dummy header in for now
    encodeStream.WriteBytes ((LPVOID) &gDummyPacketHeader, PHSIZE);
#endif 

    // Encode the per-operation data
    EncodeOperationRsp (encodeStream);

    // Encode header now because we finally know the data length
    EncodePacketHeader (encodeStream, GetResponseType ());  
    return true;
}

bool IBasicOperation_LPipe::DecodeResponse 
            (CTransportStream& encodeStream, ISecurityHelper& secHelp)
{
    // Note: the packet header has already been removed
    DecodeOperationRsp (encodeStream);
    return true;
}

// Given a PH and decodeStream, create an IOperation of the right type
bool IBasicOperation_LPipe::Decode (PACKET_HEADER& header, CTransportStream& decodeStream, 
                        IOperation** ppOpn) 
{
    *ppOpn = NULL;

    /*
     * We only deal with incoming call request messages.  If this isn't one
     * we can go no further.
     */
    if (COMLINK_MSG_CALL != header.GetType ())
        return false;

    /*
     * Decode the call message header
     */
    DWORD   dwStubAddr = 0;
    DWORD   dwStubType = 0;
    DWORD   dwStubFunc = 0;
    
    /*
     * If we cannot decode the call header, discard the message.
     */
    if (!IOperation_LPipe::DecodeCallHeader (decodeStream, dwStubAddr, 
                dwStubType, dwStubFunc))
        return false;

    bool    isAsync = false;
    CStubAddress_WinMgmt    stubAddr (dwStubAddr);

    switch (dwStubType)
    {
    case OBJECTSINK:
        switch (dwStubFunc)
        {
        case RELEASE:
            *ppOpn = new CStubOperation_LPipe_Release (stubAddr, dwStubType);
            break;

        case INDICATE:
            *ppOpn = new CStubOperation_LPipe_Indicate (stubAddr);
            break;

        case SETSTATUS:
            *ppOpn = new CStubOperation_LPipe_SetStatus (stubAddr);
            break;
        }
        break;

        // The remaining messages would only be handled by the server stub
#ifdef MARSHALER_STUB
    case PROVIDER:
        switch (dwStubFunc)
        {
        case RELEASE:
            *ppOpn = new CStubOperation_LPipe_Release (stubAddr, dwStubType);
            break;

        case WBEM_METHOD_CancelAsyncCall:
            *ppOpn = new CStubOperation_LPipe_CancelAsyncCall (stubAddr);
            break;

        case WBEM_METHOD_CreateClassEnumAsync:
        case WBEM_METHOD_CreateInstanceEnumAsync:
            isAsync = true;
        case WBEM_METHOD_CreateClassEnum:
        case WBEM_METHOD_CreateInstanceEnum:
            *ppOpn = new CStubOperation_LPipe_CreateEnum (stubAddr, dwStubFunc, isAsync);
            break;

        case WBEM_METHOD_DeleteClassAsync:
        case WBEM_METHOD_DeleteInstanceAsync:
            isAsync = true;
        case WBEM_METHOD_DeleteClass:
        case WBEM_METHOD_DeleteInstance:
            *ppOpn = new CStubOperation_LPipe_Delete (stubAddr, dwStubFunc, isAsync);
            break;

        case WBEM_METHOD_ExecMethodAsync:
            isAsync = true;
        case WBEM_METHOD_ExecMethod:
            *ppOpn = new CStubOperation_LPipe_ExecMethod (stubAddr, dwStubFunc, isAsync);
            break;

        case WBEM_METHOD_ExecNotificationQueryAsync:
        case WBEM_METHOD_ExecQueryAsync:
            isAsync = true;
        case WBEM_METHOD_ExecNotificationQuery:
        case WBEM_METHOD_ExecQuery:
            *ppOpn = new CStubOperation_LPipe_ExecQuery (stubAddr, dwStubFunc, isAsync);
            break;

        case WBEM_METHOD_GetObjectAsync:
            isAsync = true;
        case WBEM_METHOD_GetObject:
            *ppOpn = new CStubOperation_LPipe_GetObject (stubAddr, dwStubFunc, isAsync);
            break;

        case WBEM_METHOD_OpenNamespace:
            *ppOpn = new CStubOperation_LPipe_OpenNamespace (stubAddr);
            break;

        case WBEM_METHOD_PutClassAsync:
        case WBEM_METHOD_PutInstanceAsync:
            isAsync = true;
        case WBEM_METHOD_PutClass:
        case WBEM_METHOD_PutInstance:
            *ppOpn = new CStubOperation_LPipe_Put (stubAddr, dwStubFunc, isAsync); 
            break;

        case WBEM_METHOD_QueryObjectSink:
            *ppOpn = new CStubOperation_LPipe_QueryObjectSink (stubAddr);
            break;
        }
        break;

    case CALLRESULT:
        switch (dwStubFunc)
        {
        case RELEASE:
            *ppOpn = new CStubOperation_LPipe_Release (stubAddr, dwStubType);
            break;

        case GETRESULTOBJECT:
        case GETRESULTSTRING:
        case GETCALLSTATUS:
        case GETSERVICES:
            *ppOpn = new CStubOperation_LPipe_CallResult (stubAddr, dwStubFunc);
            break;
        }
        break;

    case ENUMERATOR:
        switch (dwStubFunc)
        {
        case RELEASE:
            *ppOpn = new CStubOperation_LPipe_Release (stubAddr, dwStubType);
            break;

        case NEXT:
            *ppOpn = new CStubOperation_LPipe_Next (stubAddr);
            break;

        case RESET:
            *ppOpn = new CStubOperation_LPipe_Reset (stubAddr);
            break;

        case CLONE:
            *ppOpn = new CStubOperation_LPipe_Clone (stubAddr);
            break;

        case SKIP:
            *ppOpn = new CStubOperation_LPipe_Skip (stubAddr);
            break;

        case NEXTASYNC:
            *ppOpn = new CStubOperation_LPipe_NextAsync (stubAddr);
            break;
        }
        break;

    case LOGIN:
        switch (dwStubFunc)
        {
        case RELEASE:
            *ppOpn = new CStubOperation_LPipe_Release (stubAddr, dwStubType);
            break;

        case REQUESTCHALLENGE:
            *ppOpn = new CStubOperation_LPipe_RequestChallenge (stubAddr);
            break;

        case ESTABLISHPOSITION:
            *ppOpn = new CStubOperation_LPipe_EstablishPosition (stubAddr);
            break;

        case SSPIPRELOGIN:
            *ppOpn = new CStubOperation_LPipe_SspiPreLogin (stubAddr);
            break;

        case LOGINBYTOKEN:
            *ppOpn = new CStubOperation_LPipe_Login (stubAddr);
            break;

        case WBEMLOGIN:
            *ppOpn = new CStubOperation_LPipe_WBEMLogin (stubAddr);
            break;
        }
        break;
#endif
    }

    if (!(*ppOpn))
    {
        // We could not recognize the message type or function.  In this 
        // case we make a NotSupported message to send back.

        *ppOpn = new COperation_LPipe_NotSupported ();
    }

    // Set the correct request id into operation.  It is taken from the
    // incoming header so as to ensure the response id matches the request.
    (*ppOpn)->SetRequestId (header.GetRequestId ());
    DEBUGTRACE((LOG,"\nDecode Request [Func = %d, RequestId = %d]", dwStubFunc, (*ppOpn)->GetRequestId ()));
        
    return true; 
}

// IProxyOperation_LPipe

void IProxyOperation_LPipe::DecodeStubAddress (ObjType ot, CTransportStream& decodeStream,
                                               bool checkValid)
{
    CStubAddress_WinMgmt stubAddr;
    stubAddr.Deserialize (decodeStream);

    if ((checkValid && !stubAddr.IsValid ()) || 
        (decodeStream.Status () != CTransportStream::no_error))
        SetStatus (WBEM_E_INVALID_STREAM);
    else
        SetProxyAddress (ot, stubAddr);
}

void IProxyOperation_LPipe::EncodeContext (CTransportStream& encodeStream)
{
    bool    setContext = FALSE;
    IWbemContext *pContext = GetContext ();

    if (pContext)
    {
        IStream     *pStr = NULL;   // This is released when the write stream is deleted
        IUnknown    *pUnk = NULL;   // This is released below

        if ((SUCCEEDED (encodeStream.QueryInterface (IID_IStream, (void **) &pStr)))
            && (SUCCEEDED (pContext->QueryInterface (IID_IUnknown, (void **) &pUnk))))
        {
            setContext = TRUE;
            encodeStream.WriteDWORD (1);
            CoMarshalInterface (pStr, IID_IWbemContext, pUnk, MSHCTX_LOCAL, NULL, 
                                    MSHLFLAGS_NORMAL);
            pUnk->Release ();
        }
    }
    
    if (!setContext)
        encodeStream.WriteDWORD (0);
}
    
void IProxyOperation_LPipe::EncodeCallHeader (CTransportStream& encodeStream)
{
    // Encode the stub address, type and method call id
    encodeStream.WriteDWORD (m_stubAddr);
    encodeStream.WriteDWORD (m_stubType);
    encodeStream.WriteDWORD (m_stubFunc);
}

void IProxyOperation_LPipe::DecodeErrorObject (CTransportStream& decodeStream)
{
    if(decodeStream.NextType() != VT_UI4)
    {
        // Got an error object to deserialize
        IErrorInfo* pInfo = NULL;
        IStream* pStr = NULL;

        HRESULT t_Result ;
        if ((S_OK == ( t_Result = decodeStream.QueryInterface(IID_IStream, (void**)&pStr))) )
        {
            if ((S_OK == ( t_Result = CoUnmarshalInterface(pStr, IID_IErrorInfo, (void**)&pInfo))) && pInfo)
            {
                SetErrorInfoIntoObject (pInfo);
                pInfo->Release ();
            }
        }
    }
}

// IStubOperation_LPipe

void IStubOperation_LPipe::EncodeStubAddress (ObjType ot, CTransportStream& encodeStream)
{
    CStubAddress_WinMgmt *pStubAddr = (CStubAddress_WinMgmt *) GetProxyAddress (ot);

    if (pStubAddr && pStubAddr->IsValid ())
        pStubAddr->Serialize (encodeStream);
    else
        encodeStream.WriteDWORD (0);
}

void IStubOperation_LPipe::EncodeErrorObject (CTransportStream& encodeStream)
{
    IErrorInfo* pInfo = GetErrorInfoFromObject ();

    if (pInfo)
    {
        IStream * pStr = NULL;
        HRESULT t_Result ;

        if(S_OK == ( t_Result = encodeStream.QueryInterface(IID_IStream, (void**)&pStr)))
        {
            t_Result = CoMarshalInterface(pStr, IID_IWbemClassObject, pInfo, 
                                MSHCTX_LOCAL, NULL, MSHLFLAGS_NORMAL);
        }
        pInfo->Release ();
    }
}

void IStubOperation_LPipe::DecodeContext (CTransportStream& decodeStream)
{
    DWORD           gotContext;

    if (CTransportStream::no_error != decodeStream.ReadDWORD (&gotContext))
        SetStatus (WBEM_E_INVALID_STREAM);
    else if (1 == gotContext)
    {
        IStream     *pStr = NULL;   // This is released when the read stream is deleted
        IWbemContext*   pContext = NULL;
    
        if ((SUCCEEDED (decodeStream.QueryInterface (IID_IStream, (void **) &pStr)))
             && pStr 
             && (SUCCEEDED (CoUnmarshalInterface (pStr, IID_IWbemContext, 
                    (void **) &pContext))))
        {
            SetContext (pContext);
            pContext->Release ();
        }
        else 
            SetStatus (WBEM_E_INVALID_STREAM);
    }
}

void IStubOperation_LPipe::HandleCall (CComLink& comLink)
{
    DEBUGTRACE((LOG,"\nHandle Call [Func = %d, RequestId = %d]", m_stubFunc, GetRequestId ()));

    // Always protect our stub; if the following call succeeds then we will have AddRef'd
    // the stub we are about to use in this operation.
    IUnknown *pStub = comLink.GetStub (m_stubAddr, m_stubType);

    if (!pStub)
        SetStatus (WBEM_E_FAILED);
    
    if (WBEM_NO_ERROR == GetStatus ())
    {
        Execute (comLink, pStub);
        SetErrorInfoIntoObject ();
    }

    // Now release the stub as this operation is done with it.
    if ( pStub )
        pStub->Release ();
    else
    {
ERRORTRACE((LOG,"\nHANDLE CALL FAILED[Func = %d, RequestId = %d]", m_stubFunc, GetRequestId ()));
    }
}

// CProxyOperation_LPipe_Indicate
void CProxyOperation_LPipe_Indicate::EncodeOp (CTransportStream& encodeStream)
{
    encodeStream.WriteLong(m_objectCount);

    for(long lCnt = 0; lCnt < m_objectCount; lCnt++)
         ((CWbemObject *)m_pObjArray[lCnt])->WriteToStream(&encodeStream);
}

// CProxyOperation_LPipe::SetStatus
void CProxyOperation_LPipe_SetStatus::EncodeOp (CTransportStream& encodeStream)
{
    encodeStream.WriteLong(m_flags);
    encodeStream.WriteLong(m_param);
    encodeStream.WriteBSTR(m_strParam);

    if (m_pObjParam)
    {
        encodeStream.WriteLong (1);
        ((CWbemObject *)m_pObjParam)->WriteToStream(&encodeStream);
    }
    else
        encodeStream.WriteLong (0);
}

// CStubOperation_LPipe_Indicate
void CStubOperation_LPipe_Indicate::DecodeOp (CTransportStream& decodeStream)
{
    if ((CTransportStream::no_error == decodeStream.ReadLong (&m_objectCount)) 
                && (0 < m_objectCount))
    {
        m_pObjArray = (IWbemClassObject **) (new CWbemObject * [m_objectCount]);

        if (!m_pObjArray)
            SetStatus (WBEM_E_OUT_OF_MEMORY);
        else
        {
            long lCnt;

            for (lCnt = 0; lCnt < m_objectCount; lCnt++)
            {
                m_pObjArray [lCnt] = CreateClassObject (&decodeStream);
                
                if (!bVerifyPointer (m_pObjArray [lCnt]))
                    break;

                m_pObjArray [lCnt]->Release (); // Reduce ref count back to 1
            }

            if (lCnt < m_objectCount)
            {
                // We terminated prematurely
                SetStatus (WBEM_E_FAILED);
                long lDelTo = lCnt;

                for (lCnt = 0; lCnt < lDelTo; lCnt++)
                    delete m_pObjArray [lCnt];
            }
        }
    }
}
    
void CStubOperation_LPipe_Indicate::Execute (CComLink& comLink, IUnknown *pStub)
{
    IWbemObjectSink*    pObj = (IWbemObjectSink *) pStub;
    DEBUGTRACE((LOG,"\nCalling Indicate into stub = %X", pObj));
    SetStatus (pObj->Indicate (m_objectCount, m_pObjArray));
    
    // Drop the reference count
    for (long lCnt = 0; lCnt < m_objectCount; lCnt++)
        m_pObjArray [lCnt]->Release ();
}

// CStubOperation_LPipe::SetStatus
void CStubOperation_LPipe_SetStatus::DecodeOp (CTransportStream& decodeStream)
{
    DWORD dwInSt = CTransportStream::no_error;
    long    lGotObj= 0;
    dwInSt |= decodeStream.ReadLong (&m_flags);
    dwInSt |= decodeStream.ReadLong (&m_param);
    dwInSt |= decodeStream.ReadBSTR (&m_strParam);
    dwInSt |= decodeStream.ReadLong (&lGotObj);

    if (lGotObj)
    {
        m_pObjParam = CreateClassObject (&decodeStream);

        if (!bVerifyPointer (m_pObjParam))
        {
            m_pObjParam = NULL;
            SetStatus (WBEM_E_FAILED);
        }
        else
            m_pObjParam->Release ();    // Bumped up by bVerifyPointer
    }
}

void CStubOperation_LPipe_SetStatus::Execute (CComLink& comLink, IUnknown *pStub)
{
    IWbemObjectSink*    pObj = (IWbemObjectSink *) pStub;
    DEBUGTRACE((LOG,"\nCalling SetStatus into stub = %X", pObj));
    SetStatus (pObj->SetStatus (m_flags, m_param, m_strParam,
                        m_pObjParam));
}

// CStubOperation_LPipe_Release
void CStubOperation_LPipe_Release::Execute (CComLink& comLink, IUnknown *pStub)
{
    switch (m_stubType)
    {
        case LOGIN:
        case ENUMERATOR:
        case PROVIDER:
        case OBJECTSINK:
        case CALLRESULT:
            comLink.Release2 ((void *) pStub, (enum ObjType) m_stubType);
            SetStatus (pStub->Release ());
            break;
            
        default:
            SetStatus (WBEM_E_FAILED);
            return;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\pipesnkp.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PIPOESNKP.CPP

Abstract:

    Purpose: Defines the CObjectSinkProxy_LPipe objects. The sink object 
    is the one case where both the client and server have have stubs and proxys.

History:

    alanbos  04-Mar-97   Created.

--*/

#include "precomp.h"
#include "wmishared.h"

void CObjectSinkProxy_LPipe::ReleaseProxy ()
{
    if (NULL == m_pComLink)
        return;

    CProxyOperation_LPipe_Release opn ((CStubAddress_WinMgmt &) GetStubAdd (), OBJECTSINK);
    CallAndCleanup (NONE, NULL, opn);
}

//***************************************************************************
//
//  SCODE CObjectSinkProxy_LPipe::Indicate
//
//  DESCRIPTION:
//
//  Called when the client wants to notify the server of some event.
//
//  PARAMETERS:
//
//  lObjectCount        number of notify objects to be passed
//  pObjArray           array of notify objects.
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  WBEM_E_INVALID_PARAMETER
//  or various transport and server problems.
//
//***************************************************************************

SCODE CObjectSinkProxy_LPipe::Indicate(
                        long lObjectCount,
                        IWbemClassObject FAR* FAR* pObjArray)
{
    if(pObjArray == 0 || lObjectCount < 1)
        return WBEM_E_INVALID_PARAMETER;

    if (NULL == m_pComLink) 
        return WBEM_E_TRANSPORT_FAILURE;

    CProxyOperation_LPipe_Indicate opn (lObjectCount, pObjArray, 
                        (CStubAddress_WinMgmt &) GetStubAdd ());
    return CallAndCleanup (NONE, NULL, opn);
}

//***************************************************************************
//
//  SCODE CObjectSinkProxy_LPipe::SetStatus
//
//  DESCRIPTION:
//
//  Called when the client wants to set that status.
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR        all is well
//  WBEM_E_INVALID_PARAMETER
//  or various transport and server problems.
//
//***************************************************************************

SCODE CObjectSinkProxy_LPipe::SetStatus( 
            /* [in] */ long lFlags,
            /* [in] */ long lParam,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam)
{
    if (NULL == m_pComLink) 
        return WBEM_E_TRANSPORT_FAILURE;

    CProxyOperation_LPipe_SetStatus opn (lFlags, lParam, strParam, pObjParam,
                    (CStubAddress_WinMgmt &) GetStubAdd ());
    return CallAndCleanup (NONE, NULL, opn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\pipeopn.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PIPEOPN.H

Abstract:

    Declares the abstract and generic (to proxy and stub) pipe operation classes

History:

	alanbos  18-Dec-97   Created.

--*/

#ifndef _PIPEOPN_H_
#define _PIPEOPN_H_

// Abstract class for operations over Anonymous Pipes.  
class IBasicOperation_LPipe : public IOperation
{
private:
	DWORD	m_msgType;
		
protected:
	inline IBasicOperation_LPipe (IWbemContext* pContext = NULL, 
				IWbemCallResult** ppResult = NULL, 
				bool isAsync = FALSE, DWORD msgType = COMLINK_MSG_CALL) :
		m_msgType (msgType), 
		IOperation (pContext, ppResult, isAsync) 
	{}

	inline DWORD GetMessageType () { return m_msgType; }
	inline virtual DWORD GetResponseType () { return COMLINK_MSG_RETURN; }

	// Encode the packet header structure into the stream.  This is done
	// at the end of the encode operation since that is when we know
	// the data length.
	void	EncodePacketHeader (CTransportStream& encodeStream, DWORD msgType);
	
	// Result encode/decode
	void	DecodeResult (CTransportStream& decodeStream);
	inline void	EncodeResult (CTransportStream& encodeStream)
	{
		encodeStream.WriteDWORD (GetStatus ());
	}

	// The following complete the decode and encode routines and depend
	// on the operation in hand.  They are usually overridden in the subclass.
	// Proxies and stubs implement different halves.
	inline virtual void	DecodeOperationReq (CTransportStream& decodeStream) {}
	inline virtual void	DecodeOperationRsp (CTransportStream& decodeStream) {}
	inline virtual void	EncodeOperationReq (CTransportStream& encodeStream) {}
	inline virtual void	EncodeOperationRsp (CTransportStream& encodeStream) {}
	
public:
	// Given a PH and decodeStream, create an IOperation of the right type
	// Reset stream on entry for all decode but no encode.  
	static bool		Decode (PACKET_HEADER& header, CTransportStream& decodeStream, 
						IOperation** ppOpn);

	// Utility functions 
	inline static DWORD	GetHeaderLength () { return PHSIZE; }
	static bool		DecodeHeader (BYTE *pByte, DWORD numBytes, PACKET_HEADER& header);

	// The main encode/decode routines
	bool	EncodeRequest (CTransportStream& encodeStream, ISecurityHelper& secHelp);
	bool	EncodeResponse (CTransportStream& encodeStream, ISecurityHelper& secHelp);
	bool	DecodeRequest (CTransportStream& decodeStream, ISecurityHelper& secHelp);
	bool	DecodeResponse (CTransportStream& decodeStream, ISecurityHelper& secHelp);
};

class COperation_LPipe_Ping : public IBasicOperation_LPipe
{
public:
	// For requests (proxy)
	inline COperation_LPipe_Ping () :
		IBasicOperation_LPipe (NULL, NULL, FALSE, COMLINK_MSG_PING) {}

	// For responses (stub)
	inline COperation_LPipe_Ping (PACKET_HEADER& header) :
		IBasicOperation_LPipe (NULL, NULL, FALSE, COMLINK_MSG_PING) 
	{
		SetRequestId (header.GetRequestId ());
	}

	inline DWORD GetResponseType () { return COMLINK_MSG_PING_ACK; }
};

class COperation_LPipe_Strobe : public IBasicOperation_LPipe
{
public:
	// For requests (proxy)
	inline COperation_LPipe_Strobe () :
		IBasicOperation_LPipe (NULL, NULL, FALSE, COMLINK_MSG_HEART_BEAT) {}

	// For responses (stub)
	inline COperation_LPipe_Strobe (PACKET_HEADER& header) :
		IBasicOperation_LPipe (NULL, NULL, FALSE, COMLINK_MSG_HEART_BEAT) 
	{
		SetRequestId (header.GetRequestId ());
	}

	inline DWORD GetResponseType () { return COMLINK_MSG_HEART_BEAT_ACK; }
};

class COperation_LPipe_NotSupported : public IBasicOperation_LPipe
{
public:
	inline COperation_LPipe_NotSupported () :
		IBasicOperation_LPipe () 
	{
		SetStatus (WBEM_E_NOT_SUPPORTED);
	}
};

class COperation_LPipe_Shutdown : public IBasicOperation_LPipe 
{
public:
	inline COperation_LPipe_Shutdown () :
	  IBasicOperation_LPipe (NULL, NULL, FALSE, COMLINK_MSG_NOTIFY_DESTRUCT) {}
};

// Call Operations (these have a target stub)
class IOperation_LPipe : public IBasicOperation_LPipe
{
protected:
	DWORD		m_stubAddr;
	DWORD		m_stubType;
	DWORD		m_stubFunc;

	inline IOperation_LPipe (CStubAddress_WinMgmt& stubAddr, DWORD stubType = 0, DWORD stubFunc = 0, 
				IWbemContext* pContext = NULL, IWbemCallResult** ppResult = NULL, 
				bool isAsync = FALSE) :
		m_stubAddr (stubAddr.GetRawAddress ()), m_stubType (stubType), m_stubFunc (stubFunc), 
		IBasicOperation_LPipe (pContext, ppResult, isAsync) {}

	// This is where the operation-specific encode and decode 
	// behavior is overridden by subclasses.
	inline virtual void	EncodeOp (CTransportStream& encodeStream) {};
	inline virtual void	DecodeOp (CTransportStream& decodeStream) {};

public:
	// Decode the call header information
	static bool	DecodeCallHeader (CTransportStream& decodeStream, 
				OUT DWORD& dwStubAddr, OUT DWORD& dwStubType, OUT DWORD& dwStubFunc);
};

class IProxyOperation_LPipe : public IOperation_LPipe
{
protected:
	IProxyOperation_LPipe (CStubAddress_WinMgmt& stubAddr, DWORD stubType, DWORD stubFunc, 
			IWbemContext* pContext = NULL, IWbemCallResult** ppResult = NULL, 
			bool isAsync = FALSE) :
		IOperation_LPipe (stubAddr, stubType, stubFunc, pContext, ppResult, isAsync)
		{}

	// Determines whether call result was set by stub
	inline bool	GetResultObjectP () 
	{
		IWbemCallResult**	ppResObj = GetResultObjectPP ();
		return (ppResObj && *ppResObj);
	}

	// Encodes context information associated with proxy request
	void	EncodeContext (CTransportStream& encodeStream);
	// This encodes the Stub Address, Stub Type and Stub Function
	void	EncodeCallHeader (CTransportStream& encodeStream);
	
	// Decodes error objects and stub addresses
	void	DecodeErrorObject (CTransportStream& decodeStream);
	void	DecodeStubAddress (ObjType ot, CTransportStream& decodeStream, bool checkValid = true);

	inline void	EncodeOperationReq (CTransportStream& encodeStream)
	{
		DEBUGTRACE((LOG,"\nEncode Request [Func = %d, RequestId = %d]", m_stubFunc, GetRequestId ()));
		EncodeCallHeader (encodeStream);
		EncodeOp (encodeStream);
	}

	inline void	DecodeOperationRsp (CTransportStream& decodeStream)
	{
		DecodeErrorObject (decodeStream);
		DecodeResult (decodeStream);	
		DecodeOp (decodeStream);
	}
};

class IStubOperation_LPipe : public IOperation_LPipe
{
protected:
	IStubOperation_LPipe (CStubAddress_WinMgmt& stubAddr, DWORD dwStubType, 
				DWORD dwStubFunc, bool isAsync = FALSE) : 
				IOperation_LPipe (stubAddr, dwStubType, dwStubFunc, NULL, NULL, isAsync) 
	{}

	// Error object encode/decode
	void	EncodeErrorObject (CTransportStream& encodeStream);
	// Stub Address encode/decode
	void	EncodeStubAddress (ObjType ot, CTransportStream& encodeStream);

	// Decode the context
	void	DecodeContext (CTransportStream& decodeStream);
	
	inline void	DecodeOperationReq (CTransportStream& decodeStream)
	{
		if (WBEM_NO_ERROR == GetStatus ())
			DecodeOp (decodeStream);
	}

	inline void	EncodeOperationRsp (CTransportStream& encodeStream)
	{
		EncodeErrorObject (encodeStream);
		EncodeResult (encodeStream);
		EncodeOp (encodeStream);
	}

	// This method actually invokes the proxied command against WINMGMT
	virtual void	Execute (CComLink& comLink, IUnknown *pStub) PURE;

public:
	void	HandleCall (CComLink& comLink);
};

// Anonymous Pipe Release Operation
class CProxyOperation_LPipe_Release : public IProxyOperation_LPipe
{
public:
	inline CProxyOperation_LPipe_Release (CStubAddress_WinMgmt& stubAddr, DWORD iProv) :
		IProxyOperation_LPipe (stubAddr, iProv, RELEASE) {}
};

// Anonymous Pipe Indicate Operation
class CProxyOperation_LPipe_Indicate : public IProxyOperation_LPipe
{
private:
	IWbemClassObject FAR* FAR*	m_pObjArray;
	long						m_objectCount;

protected:
	void	EncodeOp (CTransportStream& encodeStream);

public:
	inline CProxyOperation_LPipe_Indicate (long lObjectCount,
				IWbemClassObject FAR* FAR* pObjArray, CStubAddress_WinMgmt& stubAddr) : 
		m_pObjArray (pObjArray), m_objectCount (lObjectCount),
		IProxyOperation_LPipe(stubAddr, OBJECTSINK, INDICATE)
	{}
};

class CStubOperation_LPipe_Indicate : public IStubOperation_LPipe
{
private:
	IWbemClassObject**	m_pObjArray;
	long				m_objectCount;

protected:
	void	DecodeOp (CTransportStream& decodeStream);
	void	Execute (CComLink& comLink, IUnknown *pStub);

public:
	inline CStubOperation_LPipe_Indicate (CStubAddress_WinMgmt& stubAddr) : 
		m_pObjArray (NULL), m_objectCount (0),
		IStubOperation_LPipe(stubAddr, OBJECTSINK, INDICATE)
	{}
	inline virtual ~CStubOperation_LPipe_Indicate () 
	{
		if (m_pObjArray) delete [] m_pObjArray;
	}
};

// Anonymous Pipe Release Operation
class CStubOperation_LPipe_Release : public IStubOperation_LPipe
{
protected:
	void	Execute (CComLink& comLink, IUnknown *pStub);
public:
	CStubOperation_LPipe_Release (CStubAddress_WinMgmt& stubAddr, DWORD dwStubType) : 
	  IStubOperation_LPipe (stubAddr, dwStubType, RELEASE) {}
};


// Anonymous Pipe SetStatus Operation
class CProxyOperation_LPipe_SetStatus : public IProxyOperation_LPipe
{
private:
	long					m_flags;
	long					m_param;
	BSTR					m_strParam;
	IWbemClassObject FAR* 	m_pObjParam;

protected:
	void	EncodeOp (CTransportStream& encodeStream);

public:
	inline CProxyOperation_LPipe_SetStatus (long lFlags, long lParam, 
					BSTR strParam, IWbemClassObject FAR* pObjParam,
					CStubAddress_WinMgmt& stubAddr) :
		m_flags (lFlags), m_param (lParam), m_strParam (strParam),
		m_pObjParam (pObjParam), 
		IProxyOperation_LPipe (stubAddr, OBJECTSINK, SETSTATUS)
	{}
};

class CStubOperation_LPipe_SetStatus : public IStubOperation_LPipe
{
private:
	long					m_flags;
	long					m_param;
	BSTR					m_strParam;
	IWbemClassObject*	 	m_pObjParam;

protected:
	void	DecodeOp (CTransportStream& encodeStream);
	void	Execute (CComLink& comLink, IUnknown *pStub);

public:
	inline CStubOperation_LPipe_SetStatus (CStubAddress_WinMgmt& stubAddr) :
		m_flags (0), m_param (0), m_strParam (NULL),
		m_pObjParam (NULL), 
		IStubOperation_LPipe (stubAddr, OBJECTSINK, SETSTATUS)
	{}
	inline virtual ~CStubOperation_LPipe_SetStatus () 
	{
		if (m_strParam) delete m_strParam;
		if (m_pObjParam) m_pObjParam->Release ();
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <localloc.h>

extern DWORD LOG;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\pipesnkp.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PIPESNKP.H

Abstract:

    Declares the Anonymous Pipe object sink proxy (used by both proxy & stub)

History:

	alanbos  12-Dec-97   Created.

--*/

#ifndef _PIPESNKP_H_
#define _PIPESNKP_H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CObjectSinkProxy_LPipe
//
//  DESCRIPTION:
//
//  Anonymous Pipe Proxy for the IWbemObjectSink interface.
//
//***************************************************************************

class CObjectSinkProxy_LPipe : public CObjectSinkProxy
{
private:
	IWbemServices	*m_pServices;

protected:
	void	ReleaseProxy ();

public:
	CObjectSinkProxy_LPipe(CComLink * pComLink, IStubAddress& stubAddr,
							IWbemServices* pServices = NULL) :
	  CObjectSinkProxy(pComLink, stubAddr) 
	{
		if (pServices)
		{
			pServices->AddRef ();
			m_pServices = pServices;
		}
		else
			m_pServices = NULL;
	}

	~CObjectSinkProxy_LPipe ()
	{
		if (m_pServices)
			m_pServices->Release ();
	}

	inline void	ReleaseProxyFromServer ()
	{
		/*
		 * Object sink proxies on the server may not have been released 
		 * correctly if the client did not call CancelAsyncCall or the 
		 * async call has not yet completed.  This is called from a
		 * ComLink shutdown to ensure that the proxy is released correctly.
		 */
					
		if (m_pServices)
			m_pServices->CancelAsyncCall (this);
	}
	
    /* IWbemObjectSink methods */
    STDMETHOD_(SCODE, Indicate)(THIS_ long lObjectCount, 
					IWbemClassObject FAR* FAR* pObjArray);
	STDMETHODIMP SetStatus( 
            /* [in] */ long lFlags,
            /* [in] */ long lParam,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\pipestbo.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PIPESTBO.H

Abstract:

	Declares the stub pipe operation classes

History:

	alanbos  18-Dec-97   Created.

--*/

#ifndef _PIPESTBO_H_
#define _PIPESTBO_H_

// Anonymous Pipe Cancel Async Call Operation
class CStubOperation_LPipe_CancelAsyncCall : public IStubOperation_LPipe
{
private:
	DWORD	m_pSink;

protected:
	void	DecodeOp (CTransportStream& decodeStream)
	{
		SetStatus ((CTransportStream::no_error == decodeStream.ReadDWORD (&m_pSink)) ?
			WBEM_NO_ERROR : WBEM_E_INVALID_STREAM);
	}
	void Execute (CComLink& comLink, IUnknown *pStub);

public:
	CStubOperation_LPipe_CancelAsyncCall (CStubAddress_WinMgmt& stubAddr) : 
		m_pSink (0), IStubOperation_LPipe (stubAddr, PROVIDER, WBEM_METHOD_CancelAsyncCall) {}
};

// Anonymous Pipe Create Class or Instance Enum Operation
class CStubOperation_LPipe_CreateEnum : public IStubOperation_LPipe
{
private:
	BSTR					m_parent;
	long					m_flags;
	DWORD					m_handler;

protected:
	inline void	EncodeOp (CTransportStream& encodeStream)
	{
		if (!IsAsync () && (WBEM_NO_ERROR == GetStatus ()))
			EncodeStubAddress (ENUMERATOR, encodeStream);
	}
	void	DecodeOp (CTransportStream& decodeStream);
	void	Execute (CComLink& comLink, IUnknown *pStub);

public:
	inline CStubOperation_LPipe_CreateEnum (CStubAddress_WinMgmt& stubAddr, DWORD dwStubFunc, bool isAsync) :
		m_parent (NULL), m_flags (0), m_handler (0),
		IStubOperation_LPipe (stubAddr, PROVIDER, dwStubFunc, isAsync) {}
	inline virtual ~CStubOperation_LPipe_CreateEnum () 
	{
		SysFreeString (m_parent);
	}
};

// Anonymous Pipe Delete Class or Instance Operation
class CStubOperation_LPipe_Delete : public IStubOperation_LPipe
{
private:
	BSTR		m_path;
	long		m_flags;
	DWORD		m_pHandler;

protected:
	void	EncodeOp (CTransportStream& encodeStream)
	{
		if (!IsAsync ())
			EncodeStubAddress (CALLRESULT, encodeStream);
	}
	void	DecodeOp (CTransportStream& decodeStream);
	void	Execute (CComLink& comLink, IUnknown *pStub);
	
public:
	inline CStubOperation_LPipe_Delete (CStubAddress_WinMgmt& stubAddr, DWORD dwStubFunc, bool isAsync) : 
		m_path (NULL), m_flags (0), m_pHandler (0),
		IStubOperation_LPipe (stubAddr, PROVIDER, dwStubFunc, isAsync) {}

	inline virtual ~CStubOperation_LPipe_Delete ()
	{
		SysFreeString (m_path);
	}
};

// Anonymous Pipe Execute (Notification) Query Operation
class CStubOperation_LPipe_ExecQuery : public IStubOperation_LPipe
{
private:
	BSTR		m_queryLanguage;
	BSTR		m_query;
	long		m_flags;
	DWORD		m_pHandler;

protected:
	inline void	EncodeOp (CTransportStream& encodeStream)
	{
		if (!IsAsync () && (WBEM_NO_ERROR == GetStatus ()))
			EncodeStubAddress (ENUMERATOR, encodeStream);
	}
	void	DecodeOp (CTransportStream& decodeStream);
	void	Execute (CComLink& comLink, IUnknown *pStub);
	
public:
	inline CStubOperation_LPipe_ExecQuery (CStubAddress_WinMgmt& stubAddr, DWORD dwStubFunc, bool isAsync) : 
		m_queryLanguage (NULL), m_query (NULL), m_flags (0),
		m_pHandler (0),
		IStubOperation_LPipe (stubAddr, PROVIDER, dwStubFunc, isAsync) {}
	
	inline virtual ~CStubOperation_LPipe_ExecQuery ()
	{
		SysFreeString (m_queryLanguage);
		SysFreeString (m_query);
	}
};

// Anonymous Pipe Get Object Operation
class CStubOperation_LPipe_GetObject : public IStubOperation_LPipe
{
private:
	BSTR		m_path;
	long		m_flags;
	DWORD		m_pHandler;
	IWbemClassObject* m_pObject;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);
	void	Execute (CComLink& comLink, IUnknown *pStub);

public:
	inline CStubOperation_LPipe_GetObject (CStubAddress_WinMgmt& stubAddr, DWORD dwStubFunc, bool isAsync) : 
		m_path (NULL), m_flags (0), m_pHandler (0), m_pObject (NULL),
		IStubOperation_LPipe (stubAddr, PROVIDER, dwStubFunc, isAsync) {}

	inline virtual ~CStubOperation_LPipe_GetObject ()
	{
		SysFreeString (m_path);
		if (m_pObject) m_pObject->Release ();
	}
};

// Anonymous Pipe Open Namespace Operation
class CStubOperation_LPipe_OpenNamespace : public IStubOperation_LPipe
{
private:
	BSTR			m_path;
	long			m_flags;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);
	void	Execute (CComLink& comLink, IUnknown *pStub);

public:
	inline CStubOperation_LPipe_OpenNamespace (CStubAddress_WinMgmt& stubAddr) : 
		m_path (NULL), m_flags (0), 
		IStubOperation_LPipe (stubAddr, PROVIDER, WBEM_METHOD_OpenNamespace) {}

	inline virtual ~CStubOperation_LPipe_OpenNamespace () 
	{
		SysFreeString (m_path);
	}
};

// Anonymous Pipe Put Class or Instance Operation
class CStubOperation_LPipe_Put : public IStubOperation_LPipe
{
private:
	IWbemClassObject FAR*	m_pObject;
	long					m_flags;
	DWORD					m_pHandler;

protected:
	inline void	EncodeOp (CTransportStream& encodeStream)
	{
		if (!IsAsync ())
			EncodeStubAddress (CALLRESULT, encodeStream);
	}
	void	DecodeOp (CTransportStream& decodeStream);
	void	Execute (CComLink& comLink, IUnknown *pStub);
	
public:
	inline CStubOperation_LPipe_Put (CStubAddress_WinMgmt& stubAddr, DWORD dwStubFunc, bool isAsync) : 
		m_pObject (NULL), m_flags (0), m_pHandler (0),
		IStubOperation_LPipe (stubAddr, PROVIDER, dwStubFunc, isAsync) {}
	virtual ~CStubOperation_LPipe_Put () 
	{
		if (m_pObject) m_pObject->Release ();
	}
};

// Anonymous Pipe Query Object Sink Operation
class CStubOperation_LPipe_QueryObjectSink : public IStubOperation_LPipe
{
private:
	long			m_flags;

protected:
	inline void	EncodeOp (CTransportStream& encodeStream)
	{
		if (WBEM_NO_ERROR == GetStatus ())
			EncodeStubAddress (OBJECTSINK, encodeStream);
	}
	inline void	DecodeOp (CTransportStream& decodeStream)
	{
		if (CTransportStream::no_error != decodeStream.ReadLong (&m_flags))
			SetStatus (WBEM_E_INVALID_STREAM);
	}
	void	Execute (CComLink& comLink, IUnknown *pStub);

public:
	inline CStubOperation_LPipe_QueryObjectSink (CStubAddress_WinMgmt& stubAddr) : 
		m_flags (0), 
		IStubOperation_LPipe (stubAddr, PROVIDER, WBEM_METHOD_QueryObjectSink) {}
};

// Anonymous Pipe Execute Method Operation
class CStubOperation_LPipe_ExecMethod : public IStubOperation_LPipe
{
private:
	BSTR					m_path;
	BSTR					m_method;
	long					m_flags;
	IWbemClassObject FAR*	m_pInParams;
	DWORD					m_pHandler;
	IWbemClassObject FAR*	m_pOutParams;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);
	void	Execute (CComLink& comLink, IUnknown *pStub);

public:
	inline CStubOperation_LPipe_ExecMethod (CStubAddress_WinMgmt& stubAddr, DWORD dwStubFunc, bool isAsync) : 
		m_path (NULL), m_method (NULL),	m_flags (0), m_pInParams (NULL), 
		m_pOutParams (NULL), m_pHandler (0),
		IStubOperation_LPipe (stubAddr, PROVIDER, dwStubFunc, isAsync) {}

	inline virtual ~CStubOperation_LPipe_ExecMethod () 
	{
		SysFreeString (m_path);
		SysFreeString (m_method);
		if (m_pInParams) m_pInParams->Release ();
		if (m_pOutParams) m_pOutParams->Release ();
	}
};

// Anonymous Pipe request challenge operation
class CStubOperation_LPipe_RequestChallenge : public IStubOperation_LPipe
{
private:
	BSTR			m_networkResource;
	BSTR			m_user;
	BYTE			m_nonce [DIGEST_SIZE];

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);	
	void	Execute (CComLink& comLink, IUnknown *pStub); 

public:
	CStubOperation_LPipe_RequestChallenge (CStubAddress_WinMgmt& stubAddr) :
		m_networkResource (NULL), m_user (NULL), 
		IStubOperation_LPipe (stubAddr, LOGIN, REQUESTCHALLENGE) {}
	virtual ~CStubOperation_LPipe_RequestChallenge () 
	{
		SysFreeString (m_networkResource);
		SysFreeString (m_user);
	}
};

// Anonymous Pipe establish position operation
class CStubOperation_LPipe_EstablishPosition : public IStubOperation_LPipe
{
private:
	BSTR			m_clientMachineName;
	DWORD			m_processId;
	DWORD			m_authEventHandle;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);	
	void	Execute (CComLink& comLink, IUnknown *pStub); 

public:
	CStubOperation_LPipe_EstablishPosition (CStubAddress_WinMgmt& stubAddr) :
		m_clientMachineName (NULL), m_processId (0), m_authEventHandle (0),
		IStubOperation_LPipe (stubAddr, LOGIN, ESTABLISHPOSITION) {}
	virtual ~CStubOperation_LPipe_EstablishPosition () 
	{
		SysFreeString (m_clientMachineName);
	}
};

// Anonymous Pipe WBEMLogin operation
class CStubOperation_LPipe_WBEMLogin : public IStubOperation_LPipe
{
private:
	BSTR			m_preferredLocale;
	long			m_bytesRead;		// into access token
	BYTE			m_accessToken [DIGEST_SIZE];
    long			m_flags;
    
protected:
	void	EncodeOp (CTransportStream& encodeStream)
	{
		if (WBEM_NO_ERROR == GetStatus ())
			EncodeStubAddress (PROVIDER, encodeStream);
	}
	void	DecodeOp (CTransportStream& decodeStream); 
	void	Execute (CComLink& comLink, IUnknown *pStub); 
	
public:
	CStubOperation_LPipe_WBEMLogin (CStubAddress_WinMgmt& stubAddr) :
		m_bytesRead (0), m_preferredLocale (NULL), m_flags (0), 
		IStubOperation_LPipe (stubAddr, LOGIN, WBEMLOGIN) {}
	virtual ~CStubOperation_LPipe_WBEMLogin () 
	{
		SysFreeString (m_preferredLocale);
	}
};

// Anonymous Pipe SSPI Pre Login operation
class CStubOperation_LPipe_SspiPreLogin : public IStubOperation_LPipe
{
private:
    LPSTR			m_pszSSPIPkg;
    long			m_flags;
    long			m_bufSize;
    byte*			m_pInToken;
    long			m_outBufSize;
    byte*			m_pOutToken;
	long			m_outBufBytes;
	BSTR			m_clientMachineName;
	DWORD			m_dwProcessID; 
	DWORD			m_authEventHandle;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);
	void	Execute (CComLink& comLink, IUnknown *pStub);

public:
	CStubOperation_LPipe_SspiPreLogin (CStubAddress_WinMgmt& stubAddr) :
		m_pszSSPIPkg (NULL), m_flags (0), m_bufSize (0), 
		m_pInToken (NULL), m_outBufSize (0), m_outBufBytes (0),
		m_pOutToken (NULL), m_dwProcessID (0), 
		m_authEventHandle (0), m_clientMachineName (NULL),
		IStubOperation_LPipe (stubAddr, LOGIN, SSPIPRELOGIN) {}
	virtual ~CStubOperation_LPipe_SspiPreLogin () 
	{
		SysFreeString (m_clientMachineName);
		if (m_pszSSPIPkg) delete m_pszSSPIPkg;
		if (m_pInToken) delete [] m_pInToken;
		if (m_pOutToken) delete [] m_pOutToken;
	}
};

// Anonymous Pipe Login operation
class CStubOperation_LPipe_Login : public IStubOperation_LPipe
{
private:
	BSTR			m_networkResource;
	BSTR			m_preferredLocale;
	long			m_bytesRead;		// into access token
	BYTE			m_accessToken [DIGEST_SIZE];
    long			m_flags;
    
protected:
	void	EncodeOp (CTransportStream& encodeStream)
	{
		if (WBEM_NO_ERROR == GetStatus ())
			EncodeStubAddress (PROVIDER, encodeStream);
	}
	void	DecodeOp (CTransportStream& decodeStream); 
	void	Execute (CComLink& comLink, IUnknown *pStub); 
	
public:
	CStubOperation_LPipe_Login (CStubAddress_WinMgmt& stubAddr) :
		m_networkResource (NULL), m_bytesRead (0),
		m_preferredLocale (NULL), m_flags (0), 
		IStubOperation_LPipe (stubAddr, LOGIN, LOGINBYTOKEN) {}
	virtual ~CStubOperation_LPipe_Login () 
	{
		SysFreeString (m_networkResource);
		SysFreeString (m_preferredLocale);
	}
};

// Anonymous Pipe Reset Operation
class CStubOperation_LPipe_Reset : public IStubOperation_LPipe
{
protected:
	void	Execute (CComLink& comLink, IUnknown *pStub);

public:
	CStubOperation_LPipe_Reset (CStubAddress_WinMgmt& stubAddr) :
		IStubOperation_LPipe (stubAddr, ENUMERATOR, RESET) {}
};

// Anonymous Pipe Next Operation
class CStubOperation_LPipe_Next : public IStubOperation_LPipe
{
private:
	long		m_timeout;
	ULONG		m_count;
	IWbemClassObject**	m_objArray;
	DWORD		m_returned;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream); 
	void	Execute (CComLink& comLink, IUnknown *pStub);	

public:
	CStubOperation_LPipe_Next (CStubAddress_WinMgmt& stubAddr) :
		m_timeout (0), m_count(0), m_objArray (NULL), m_returned (0),
		IStubOperation_LPipe (stubAddr, ENUMERATOR, NEXT) {}

	~CStubOperation_LPipe_Next () { delete [] m_objArray ; }
};

// Anonymous Pipe Clone Operation
class CStubOperation_LPipe_Clone : public IStubOperation_LPipe
{
protected:
	void	EncodeOp (CTransportStream& encodeStream)
	{
		if (WBEM_NO_ERROR == GetStatus ())
			EncodeStubAddress (ENUMERATOR, encodeStream);
	}
	void	Execute (CComLink& comLink, IUnknown *pStub);
	
public:
	CStubOperation_LPipe_Clone (CStubAddress_WinMgmt& stubAddr) :
		IStubOperation_LPipe (stubAddr, ENUMERATOR, CLONE) {}
};

// Anonymous Pipe NextAsync Operation
class CStubOperation_LPipe_NextAsync : public IStubOperation_LPipe
{
private:
	long		m_count;
	DWORD		m_pSink;
	// This is the local WINMGMT address of the IWbemServices interface
	// from which the enumerator was originally obtained.
	DWORD		m_pServiceStub;

protected:
	void	DecodeOp (CTransportStream& decodeStream);
    void	Execute (CComLink& comLink, IUnknown *pStub); 
	
public:
	CStubOperation_LPipe_NextAsync (CStubAddress_WinMgmt& stubAddr) :
		m_count(0), m_pSink (0), m_pServiceStub (0),
		IStubOperation_LPipe (stubAddr, ENUMERATOR, NEXTASYNC) {}
};

// Anonymous Pipe Skip Operation
class CStubOperation_LPipe_Skip : public IStubOperation_LPipe
{
private:
	long		m_timeout;
	DWORD		m_number;

protected:
	void	DecodeOp (CTransportStream& encodeStream);
    void	Execute (CComLink& comLink, IUnknown *pStub); 
	
public:
	CStubOperation_LPipe_Skip (CStubAddress_WinMgmt& stubAddr) :
		m_timeout (0), m_number(0), 
		IStubOperation_LPipe (stubAddr, ENUMERATOR, SKIP) {}
};

// Anonymous Pipe Call Result Operations.  These are so similar
// we wrap them in one object
class CStubOperation_LPipe_CallResult : public IStubOperation_LPipe
{
private:
	long				m_timeout;
	IWbemClassObject*	m_pStatusObject;	// GetResultObject
	BSTR				m_resultString;		// GetResultString
	long				m_status;			// GetCallStatus

protected:
	void	EncodeOp (CTransportStream& encodeStream);	
	void	DecodeOp (CTransportStream& decodeStream);	
	void	Execute (CComLink& comLink, IUnknown *pStub); 

public:
	CStubOperation_LPipe_CallResult (CStubAddress_WinMgmt& stubAddr, DWORD dwStubFunc) :
		m_timeout (0), m_pStatusObject (0), m_resultString (NULL),
		m_status (0),
		IStubOperation_LPipe (stubAddr, CALLRESULT, dwStubFunc) {}
	virtual ~CStubOperation_LPipe_CallResult () 
	{
		if (m_pStatusObject) m_pStatusObject->Release ();
		SysFreeString (m_resultString);
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\rqueue.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    RQUEUE.CPP

Abstract:

    Declarations for CRequestQueue, which to keep track of calls
    which have not yet been answered.

History:

    a-davj  15-Aug-96   Created.

--*/

#include "precomp.h"
#include "wmishared.h"

// This macro used used ensure that the request queue is valid and to
// get the MUTEX for accessing the request array.

#define GETMUTEX(mutex, badres) \
    if(mutex == NULL || m_RequestContainer == NULL) \
        return badres; \
    dwRet = WbemWaitForSingleObject(mutex,MAX_WAIT_FOR_WRITE); \
    if(dwRet != WAIT_OBJECT_0) \
        return badres;

//***************************************************************************
//
//  CRequestQueue::CRequestQueue
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CRequestQueue :: CRequestQueue () : m_RequestContainer ( NULL ) , m_RequestContainerSize ( 0 )
{
    m_Mutex = CreateMutex ( NULL , FALSE , NULL ) ;

    InitializeCriticalSection(&m_cs);

    int t_FreeSlotIndex ;

    if ( ! ExpandArray ( INITIAL_QUEUE_SIZE , t_FreeSlotIndex ) )
    {
        FreeStuff () ;
    }

    ObjectCreated(OBJECT_TYPE_RQUEUE) ;
}
//***************************************************************************
//
//  CRequestQueue::~CRequestQueue
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CRequestQueue :: ~CRequestQueue ()
{
    FreeStuff () ;
    ObjectDestroyed(OBJECT_TYPE_RQUEUE) ;
}

//***************************************************************************
//
//  void CRequestQueue::FreeStuff
//
//  DESCRIPTION:
//
//  Frees up resources.  Generally used by destructor. 
//  
//***************************************************************************

void CRequestQueue::FreeStuff()
{
    DWORD dwCnt;
    for ( dwCnt = 0 ; dwCnt < m_RequestContainerSize && m_RequestContainer ; dwCnt ++ )
    {
        if ( m_RequestContainer [ dwCnt ].m_Event )
        {
            CloseHandle ( m_RequestContainer [ dwCnt ].m_Event ) ;
        }
    }

    if ( m_Mutex )
        CloseHandle ( m_Mutex ) ;

    DeleteCriticalSection(&m_cs);

    if ( m_RequestContainer )
        delete [] m_RequestContainer ;

    m_Mutex = NULL ;
    m_RequestContainer = NULL ;
    m_RequestContainerSize = 0 ;
}

//***************************************************************************
//
//  DWORD CRequestQueue::dwStatus
//
//  DESCRIPTION:
//
//  Gets the status.
//
//  RETURN VALUE:
//
//  Status, no_error if ok.
//***************************************************************************

DWORD CRequestQueue :: GetStatus ()
{
    return ( m_Mutex && m_RequestContainer ) ? CComLink::no_error : CComLink::failed ;
}

//***************************************************************************
//
//  int CRequestQueue::iGetEmptySlot
//
//  DESCRIPTION:
//
//  Finds an empty slot to be used.  Will expand the array if
//  necessary.
//
//  RETURN VALUE:
//
//  index of empty slot, -1 if error.
//
//***************************************************************************

int CRequestQueue :: GetEmptySlot ()
{
    int iCnt ;

    // find an empty slot in the requests list

    for ( iCnt = 0 ; (DWORD)iCnt < m_RequestContainerSize ; iCnt ++ )
    {
        if ( m_RequestContainer [ iCnt ].m_InUse == FALSE && m_RequestContainer [ iCnt ].m_Event != NULL )
        {
           break;
        }
    }

    // if there was no empty slot, expand the array

    if ( (DWORD) iCnt == m_RequestContainerSize )
    {
        if ( ! ExpandArray ( INITIAL_QUEUE_SIZE , iCnt ) )
        {
            return -1;
        }
    }

    return iCnt ;
}

//***************************************************************************
//
//  BOOL CRequestQueue :: FindByRequestId
//
//  DESCRIPTION:
//
//  Finds a entry by the guid.
//
//  PARAMETERS:
//
//  guidToFind          what to look for
//  pdwEntry            set to index
//
//  RETURN VALUE:
//
//  TRUE if found.
//
//***************************************************************************

BOOL CRequestQueue :: FindByRequestId (

    RequestId a_RequestId ,
    DWORD &pdwEntry
)
{
    DWORD dwCnt ;
    
    for ( dwCnt = 0 ; dwCnt < m_RequestContainerSize ; dwCnt ++ )
    {
        if ( m_RequestContainer [ dwCnt ].m_RequestId == a_RequestId && m_RequestContainer [ dwCnt ].m_InUse )
        {
            pdwEntry = dwCnt ;
            return TRUE ;
        }
    }

    return FALSE ;
}

//***************************************************************************
//
//  BOOL CRequestQueue :: FindByHandle
//
//  DESCRIPTION:
//
//  Finds a entry by the event handle.
//
//  PARAMETERS:
//
//  hEventToFind        what to look for
//  pdwEntry            set to index
//
//  RETURN VALUE:
//
//  TRUE if found.
//  
//***************************************************************************

BOOL CRequestQueue :: FindByHandle (
                        
    HANDLE hEventToFind,
    DWORD &pdwEntry
)
{
    DWORD dwCnt;

    for ( dwCnt = 0 ; dwCnt < m_RequestContainerSize ; dwCnt ++ )
    {
        if ( m_RequestContainer [ dwCnt ].m_Event == hEventToFind && m_RequestContainer [ dwCnt ].m_InUse )
        {
            pdwEntry = dwCnt ;
            return TRUE ;
        }
    }

    return FALSE ;
}
 
//***************************************************************************
//
//  HANDLE CRequestQueue::BeginPacket
//
//  DESCRIPTION:
//
//  Called at the start of a write.  Get a slot, generate a new guid
//  and store the read stream that will be used to store the returned value.
//
//  PARAMETERS:
//
//  pRead               pointer to stream where results are to be stored.
//  pguidID             set to guid to identify the packet.
//
//  RETURN VALUE:
//
//  handle to event that can be set when something happens.
//  NULL if error.
//
//***************************************************************************

HANDLE CRequestQueue::AllocateRequest (

    IN IOperation &a_Operation
)
{
    HANDLE hRet = NULL ;

#if 0
    GETMUTEX(m_Mutex, NULL)
#else
    EnterCriticalSection(&m_cs);
#endif

    int iUse = GetEmptySlot () ;
    if ( iUse != -1 )
    {
        m_RequestContainer [ iUse ].m_InUse = TRUE;
        m_RequestContainer [ iUse ].m_Operation = & a_Operation ;
        m_RequestContainer [ iUse ].m_RequestId = a_Operation.GetRequestId () ;
        m_RequestContainer [ iUse ].m_Status = NO_REPLY_YET;

        // The slots event handle is also to be returned.  This event will
        // be signaled by the read thread when the reply comes, but for now
        // reset it .
        // ================================================================

        hRet = m_RequestContainer [ iUse ].m_Event ;
        ResetEvent ( hRet ) ;
    }

#if 0
    ReleaseMutex ( m_Mutex ) ;
#else
    LeaveCriticalSection(&m_cs);
#endif

    return hRet ;
}

//***************************************************************************
//
//  HANDLE CRequestQueue::BeginPacket
//
//  DESCRIPTION:
//
//  Called at the start of a write.  Get a slot, generate a new guid
//  and store the read stream that will be used to store the returned value.
//
//  PARAMETERS:
//
//  pRead               pointer to stream where results are to be stored.
//  pguidID             set to guid to identify the packet.
//
//  RETURN VALUE:
//
//  handle to event that can be set when something happens.
//  NULL if error.
//
//***************************************************************************

HANDLE CRequestQueue::UnLockedAllocateRequest (

    IN IOperation &a_Operation
)
{
    HANDLE hRet = NULL ;

    int iUse = GetEmptySlot () ;
    if ( iUse != -1 )
    {
        m_RequestContainer [ iUse ].m_InUse = TRUE;
        m_RequestContainer [ iUse ].m_Operation = & a_Operation ;
        m_RequestContainer [ iUse ].m_RequestId = a_Operation.GetRequestId () ;
        m_RequestContainer [ iUse ].m_Status = NO_REPLY_YET;

        // The slots event handle is also to be returned.  This event will
        // be signaled by the read thread when the reply comes, but for now
        // reset it .
        // ================================================================

        hRet = m_RequestContainer [ iUse ].m_Event ;
        ResetEvent ( hRet ) ;
    }

    return hRet ;
}

//***************************************************************************
//
//  DWORD CRequestQueue::GetLastMsg
//
//  DESCRIPTION:
//
//  Called to get the response to a written packet.  Typically used
//  when determining what the result was of sending a message.
//
//  PARAMETERS:
//
//  hEvent              handle used to find the request
//
//  RETURN VALUE:
//
//  Last message received.  See COMLINK.H for a list of the messages.
//  WBEM_E_FAILED is set if there is no last message.
//
//***************************************************************************

DWORD CRequestQueue :: GetRequestStatus ( IN HANDLE a_Event )
{
    DWORD dwRet = WBEM_E_FAILED ;       // Set later on

#if 0
    GETMUTEX(m_Mutex, WBEM_E_FAILED)
#else
    EnterCriticalSection(&m_cs);
#endif

    // find a packet in the list

    DWORD dwCnt;
    if ( FindByHandle ( a_Event , dwCnt ) )
        dwRet = m_RequestContainer [ dwCnt ].m_Status ;

#if 0
    ReleaseMutex ( m_Mutex ) ;
#else
    LeaveCriticalSection(&m_cs);
#endif

    return dwRet ;
}

//***************************************************************************
//
//  DWORD CRequestQueue::DeallocateRequest
//
//  DESCRIPTION:
//
//  Called when packet is done and the caller is through with the
//  slot.
//
//  PARAMETERS:
//
//  hEvent              handle used to find the request
//
//  RETURN VALUE:
//
//  WBEM_E_FAILED if error, otherwise last response value
//
//***************************************************************************

DWORD CRequestQueue :: DeallocateRequest ( IN HANDLE a_Event )
{
    DWORD dwRet = WBEM_E_FAILED ;       // Set later on

#if 0
    GETMUTEX(m_Mutex , WBEM_E_FAILED)
#else
    EnterCriticalSection(&m_cs);
#endif

    // find a packet in the list

    DWORD dwCnt ;
    if ( FindByHandle ( a_Event , dwCnt ) )
    {
        m_RequestContainer [ dwCnt ].m_InUse = FALSE ;
        dwRet = m_RequestContainer [ dwCnt ].m_Status ;
    }

#if 0
    ReleaseMutex ( m_Mutex ) ;
#else
    LeaveCriticalSection(&m_cs);
#endif

    return dwRet ;
}

//***************************************************************************
//
//  DWORD CRequestQueue::DeallocateRequest
//
//  DESCRIPTION:
//
//  Called when packet is done and the caller is through with the
//  slot.
//
//  PARAMETERS:
//
//  hEvent              handle used to find the request
//
//  RETURN VALUE:
//
//  WBEM_E_FAILED if error, otherwise last response value
//
//***************************************************************************

DWORD CRequestQueue :: UnLockedDeallocateRequest ( IN HANDLE a_Event )
{
    DWORD dwRet = WBEM_E_FAILED ;       // Set later on

    // find a packet in the list

    DWORD dwCnt ;
    if ( FindByHandle ( a_Event , dwCnt ) )
    {
        m_RequestContainer [ dwCnt ].m_InUse = FALSE ;
        dwRet = m_RequestContainer [ dwCnt ].m_Status ;
    }

    return dwRet ;
}

//***************************************************************************
//
//  CMemStream * CRequestQueue::GetStream
//
//  DESCRIPTION:
//
//  Called by a read thread when a response comes back.
//
//  PARAMETERS:
//
//  guidPacketID        guid used to find the request
//
//  RETURN VALUE:
//
//  The memory stream that is to be used for the reply, NULL if 
//  error.
//
//***************************************************************************

IOperation *CRequestQueue :: GetOperation ( RequestId a_RequestId )
{
    IOperation *t_Operation = NULL ;

#if 0
    GETMUTEX(m_Mutex, NULL)
#else
    EnterCriticalSection(&m_cs);
#endif


    // find an packet in the list

    DWORD dwCnt ;
    if ( FindByRequestId  ( a_RequestId , dwCnt ) )
        t_Operation = m_RequestContainer [ dwCnt ].m_Operation ;

#if 0
    ReleaseMutex ( m_Mutex ) ;
#else
    LeaveCriticalSection(&m_cs);
#endif

    return t_Operation ;
}

//***************************************************************************
//
//  HANDLE CRequestQueue::SetEventAndType
//
//  DESCRIPTION:
//
//  Called by the read thread in order to set the return code
//  of the call.
//
//  PARAMETERS:
//
//  guidPacketID        guid used to find the request
//  dwType              result 
//
//  RETURN VALUE:
//
//  Handle of event, NULL if the packetID is invalid.
//
//***************************************************************************

HANDLE CRequestQueue :: SetEventAndStatus (

    RequestId a_RequestId ,
    IN DWORD a_Status
)
{
    HANDLE t_Handle = NULL;

#if 0
    GETMUTEX(m_Mutex, NULL)
#else
    EnterCriticalSection(&m_cs);
#endif

    // find an packet in the list

    DWORD dwCnt;
    if( FindByRequestId ( a_RequestId , dwCnt ) )
    {
        t_Handle = m_RequestContainer [ dwCnt ].m_Event ;
        m_RequestContainer[dwCnt].m_Status = a_Status ;

        SetEvent ( t_Handle ) ;
    }

#if 0
    ReleaseMutex ( m_Mutex ) ;
#else
    LeaveCriticalSection(&m_cs);
#endif

    return t_Handle ;
}


//***************************************************************************
//
//  HANDLE CRequestQueue::GetHandle
//
//  DESCRIPTION:
//
//  gets the event handle.
//
//  PARAMETERS:
//
//  guidPacketID        guid used to find the request
//
//  RETURN VALUE:
//
//  event handle, NULL if the packetID is invalid.
//
//***************************************************************************

HANDLE CRequestQueue :: GetHandle ( RequestId a_RequestId )
{
    HANDLE t_Handle = NULL ;

#if 0
    GETMUTEX(m_Mutex, NULL)
#else
    EnterCriticalSection(&m_cs);
#endif

    // find an packet in the list

    DWORD dwCnt;
    if ( FindByRequestId ( a_RequestId , dwCnt ) )
        t_Handle = m_RequestContainer [ dwCnt ].m_Event ;

#if 0
    ReleaseMutex ( m_Mutex ) ;
#else
    LeaveCriticalSection(&m_cs);
#endif

    return t_Handle ;
}

//***************************************************************************
//
//  BOOL CRequestQueue :: ExpandArray
//
//  DESCRIPTION:
//
//  Expands the number of slots that can be used to hold call data.
//   
//  PARAMETERS:
//
//  dwAdditionalEntries number to add
//  piAvailable         set to available slots
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL CRequestQueue :: ExpandArray (

    IN DWORD dwAdditionalEntries ,
    OUT int &piAvailable
)
{
    BOOL bOK = FALSE ;

    // Allocate an array big enough for any existing entries and
    // the new entries.
    // =========================================================

    DWORD dwAllocSize = dwAdditionalEntries + m_RequestContainerSize ;
    Request *pNewRequests = new Request [ dwAllocSize ] ;

    if ( pNewRequests == NULL )
        return FALSE ;

    // For array elements that already exist, copy from the current 
    // storage and for the new elements, set the event handle.
    // ============================================================

    int iCnt ;
    for ( iCnt = 0 ; (DWORD)iCnt < dwAllocSize ; iCnt ++ )
    {
        if ( (DWORD) iCnt < m_RequestContainerSize )
        {
            pNewRequests [ iCnt ] = m_RequestContainer [ iCnt ] ;   // structure copy
        }
        else
        {
            pNewRequests [ iCnt ].m_Event = CreateEvent ( NULL , FALSE , FALSE , NULL ) ;
            if ( pNewRequests [ iCnt ].m_Event )
            {
                // Got at least one event handle.  If it is the first and
                // if the caller is interested, set the pointer to this 
                // slot entry.
                // ======================================================

                if ( ! bOK )
                {
                    piAvailable = iCnt ;
                }

                bOK = TRUE ;         // Added at least one!
            }

            pNewRequests [ iCnt ].m_InUse = FALSE ;
        }
    }

    if ( ! bOK )
    {
        delete [] pNewRequests ;
    }
    else
    {
        if ( m_RequestContainer )
        {
            delete [] m_RequestContainer ;
        }

        m_RequestContainer = pNewRequests ;
        m_RequestContainerSize = dwAllocSize ;
    }

    return bOK ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\pipestbo.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PIPESTBO.CPP

Abstract:

    Declares the stub pipe operation classes

History:

    alanbos  18-Dec-97   Created.

--*/

#include "precomp.h"
#include "wmishared.h"

// CStubOperation_LPipe_CancelAsyncCall
void CStubOperation_LPipe_CancelAsyncCall::Execute (CComLink& comLink, IUnknown *pStub)
{
    IWbemServices *pObj = (IWbemServices *) pStub;
    CStubAddress_WinMgmt sinkAddr (m_pSink);

    // Get the local object sink proxy corresponding to the client sink.
    // If not found don't bother creating one as that would defeat the
    // purpose of CancelAsyncCall.
    CObjectSinkProxy *pNoteProxy = 
                comLink.GetObjectSinkProxy (sinkAddr, pObj, false);

    if (pNoteProxy)
    {
        SetStatus (pObj->CancelAsyncCall ((IWbemObjectSink *) pNoteProxy));
        pNoteProxy->Release (); // balance GetObjectSinkProxy
    }
    else
        SetStatus (WBEM_E_INVALID_PARAMETER);
}

// CStubOperation_LPipe_CreateEnum
void CStubOperation_LPipe_CreateEnum::DecodeOp (CTransportStream& decodeStream)
{
    DWORD dwInSt = CTransportStream::no_error;
    dwInSt |= decodeStream.ReadBSTR (&m_parent);
    dwInSt |= decodeStream.ReadLong (&m_flags);
    DecodeContext (decodeStream);

    if (IsAsync ())
        dwInSt |= decodeStream.ReadDWORD (&m_handler);
    
    if (CTransportStream::no_error != dwInSt)
        SetStatus (WBEM_E_INVALID_STREAM);
}

void CStubOperation_LPipe_CreateEnum::Execute (CComLink& comLink, IUnknown *pStub)
{
    IWbemServices*  pObj = (IWbemServices *) pStub;

    if (IsAsync ())
    {
        CStubAddress_WinMgmt    sinkAddr (m_handler);
        CObjectSinkProxy *pNoteProxy = 
                    comLink.GetObjectSinkProxy (sinkAddr, pObj);
        
        if (pNoteProxy)
        {
            SetStatus ((WBEM_METHOD_CreateClassEnumAsync == m_stubFunc) ?
                    pObj->CreateClassEnumAsync (m_parent, m_flags,
                        GetContext (), pNoteProxy) :
                    pObj->CreateInstanceEnumAsync (m_parent, m_flags,
                        GetContext (), pNoteProxy));
            pNoteProxy->Release ();     // balances GetObjectSinkProxy
        }
        else
            SetStatus (WBEM_E_INVALID_STREAM);
    }
    else
    {
        IEnumWbemClassObject *pEnum = NULL;
        SetStatus ((WBEM_METHOD_CreateClassEnum == m_stubFunc) ?
            pObj->CreateClassEnum (m_parent, m_flags, GetContext (), &pEnum) :
            pObj->CreateInstanceEnum (m_parent, m_flags, GetContext (), &pEnum));

        if (WBEM_NO_ERROR == GetStatus ())
        {
            CStubAddress_WinMgmt stubAddr ( pEnum);
            SetProxyAddress (ENUMERATOR, stubAddr);
            comLink.AddRef2 (pEnum, ENUMERATOR, RELEASEIT);
        }
    }
}

// CStubOperation_LPipe_Delete
void CStubOperation_LPipe_Delete::DecodeOp (CTransportStream& decodeStream)
{
    DWORD dwInSt = CTransportStream::no_error;
    dwInSt |= decodeStream.ReadBSTR (&m_path);
    dwInSt |= decodeStream.ReadLong (&m_flags);
    DecodeContext (decodeStream);

    if (IsAsync ())
        dwInSt |= decodeStream.ReadDWORD (&m_pHandler);
    else
    {
        IWbemCallResult **ppResObj = NULL;
        dwInSt |= decodeStream.ReadLong ((long *) &ppResObj);
        SetResultObjectPP (ppResObj);
    }
    
    if (CTransportStream::no_error != dwInSt)
        SetStatus (WBEM_E_INVALID_STREAM);
}

void CStubOperation_LPipe_Delete::Execute (CComLink& comLink, IUnknown *pStub)
{
    IWbemServices*  pObj = (IWbemServices *) pStub;
        
    if (IsAsync ())
    {
        CStubAddress_WinMgmt    sinkAddr (m_pHandler);
        CObjectSinkProxy *pNoteProxy = 
                    comLink.GetObjectSinkProxy (sinkAddr, pObj);
            
        if (pNoteProxy)
        {
            SetStatus ((WBEM_METHOD_DeleteClassAsync == m_stubFunc) ?
                        pObj->DeleteClassAsync (m_path, m_flags,
                            GetContext (), pNoteProxy) :
                        pObj->DeleteInstanceAsync (m_path, m_flags,
                            GetContext (), pNoteProxy));
            pNoteProxy->Release ();     // Balances GetObjectSinkProxy
        }
        else
            SetStatus (WBEM_E_INVALID_STREAM);
    }
    else
    {
        IWbemCallResult *pResult = NULL;
        
        SetStatus ((WBEM_METHOD_DeleteClass == m_stubFunc) ?
                pObj->DeleteClass (m_path, m_flags, GetContext (), 
                        (GetResultObjectPP ()) ? &pResult : NULL) :
                pObj->DeleteInstance (m_path, m_flags, GetContext (), 
                        (GetResultObjectPP ()) ? &pResult : NULL));
        
        if (pResult)
        {
            CStubAddress_WinMgmt stubAddr ( pResult);
            SetProxyAddress (CALLRESULT, stubAddr);
            comLink.AddRef2 (pResult, CALLRESULT, RELEASEIT);
        }
    }
}

// CStubOperation_LPipe_ExecQuery
void CStubOperation_LPipe_ExecQuery::DecodeOp (CTransportStream& decodeStream)
{
    DWORD dwInSt = CTransportStream::no_error;
    dwInSt |= decodeStream.ReadBSTR (&m_queryLanguage);
    dwInSt |= decodeStream.ReadBSTR (&m_query);
    dwInSt |= decodeStream.ReadLong (&m_flags);
    DecodeContext (decodeStream);

    if (IsAsync ())
        dwInSt |= decodeStream.ReadDWORD (&m_pHandler);
    
    if (CTransportStream::no_error != dwInSt)
        SetStatus (WBEM_E_INVALID_STREAM);
}

void CStubOperation_LPipe_ExecQuery::Execute (CComLink& comLink, IUnknown *pStub)
{
    IWbemServices*  pObj = (IWbemServices *) pStub;
    
    if (IsAsync ())
    {
        CStubAddress_WinMgmt    sinkAddr (m_pHandler);
        CObjectSinkProxy *pNoteProxy = 
                    comLink.GetObjectSinkProxy (sinkAddr, pObj);
        
        if (pNoteProxy)
        {
            SetStatus ((WBEM_METHOD_ExecQueryAsync == m_stubFunc) ?
                pObj->ExecQueryAsync (m_queryLanguage, m_query, 
                    m_flags, GetContext (), pNoteProxy) :
                pObj->ExecNotificationQueryAsync (m_queryLanguage, m_query,
                    m_flags, GetContext (), pNoteProxy)
                        );
            pNoteProxy->Release (); // Balances GetObjectSinkProxy
        }
        else
            SetStatus (WBEM_E_INVALID_STREAM);
    }
    else
    {
        IEnumWbemClassObject *pEnum = NULL;
        SetStatus ((WBEM_METHOD_ExecQuery == m_stubFunc) ?
                pObj->ExecQuery (m_queryLanguage, m_query, 
                    m_flags, GetContext (), &pEnum) :
                pObj->ExecNotificationQuery (m_queryLanguage, m_query, 
                    m_flags, GetContext (), &pEnum)
                    );

        if (WBEM_NO_ERROR == GetStatus ())
        {
            CStubAddress_WinMgmt    stubAddr (pEnum);
            SetProxyAddress (ENUMERATOR, stubAddr);
            comLink.AddRef2 (pEnum, ENUMERATOR, RELEASEIT);
        }
    }
}

// CStubOperation_LPipe_GetObject
void CStubOperation_LPipe_GetObject::EncodeOp (CTransportStream& encodeStream)
{
    if (!IsAsync ())
    {
        if ((WBEM_NO_ERROR == GetStatus ()) && m_pObject) 
        {
            if (CTransportStream::no_error != 
                    ((CWbemObject *) m_pObject)->WriteToStream (&encodeStream))
                SetStatus (WBEM_E_INVALID_STREAM);
        }

        EncodeStubAddress (CALLRESULT, encodeStream);
    }
}

void CStubOperation_LPipe_GetObject::DecodeOp (CTransportStream& decodeStream)
{
    DWORD dwInSt = CTransportStream::no_error;
    dwInSt |= decodeStream.ReadBSTR (&m_path);
    dwInSt |= decodeStream.ReadLong (&m_flags);
    DecodeContext (decodeStream);

    if (IsAsync ())
        dwInSt |= decodeStream.ReadDWORD (&m_pHandler);
    else
    {
        dwInSt |= decodeStream.ReadLong ((long *) &m_pObject);
        IWbemCallResult **ppResObj = NULL;
        dwInSt |= decodeStream.ReadLong ((long *) &ppResObj);
        SetResultObjectPP (ppResObj);
    }
    
    if (CTransportStream::no_error != dwInSt)
        SetStatus (WBEM_E_INVALID_STREAM);
}

void CStubOperation_LPipe_GetObject::Execute (CComLink& comLink, IUnknown *pStub)
{
    IWbemServices*  pObj = (IWbemServices *) pStub;
        
    if (IsAsync ())
    {
        CStubAddress_WinMgmt    sinkAddr (m_pHandler);
        CObjectSinkProxy *pNoteProxy = 
                    comLink.GetObjectSinkProxy (sinkAddr, pObj);
            
        if (pNoteProxy)
        {
            SetStatus (pObj->GetObjectAsync (m_path, m_flags,
                            GetContext (), pNoteProxy));
            pNoteProxy->Release (); // Balances GetObjectSinkProxy
        }
        else
            SetStatus (WBEM_E_INVALID_STREAM);
    }
    else
    {
        IWbemCallResult *pResult = NULL;
        
        SetStatus (pObj->GetObject (m_path, m_flags, GetContext (), 
                        (m_pObject) ? &m_pObject : NULL,                
                        (GetResultObjectPP ()) ? &pResult : NULL));
        
        if (pResult)
        {
            CStubAddress_WinMgmt    stubAddr ( pResult);
            SetProxyAddress (CALLRESULT, stubAddr);
            comLink.AddRef2 (pResult, CALLRESULT, RELEASEIT);
        }
    }

}

// CStubOperation_LPipe_OpenNamespace
void CStubOperation_LPipe_OpenNamespace::EncodeOp (CTransportStream& encodeStream)
{
    if (WBEM_NO_ERROR == GetStatus ())
        EncodeStubAddress (PROVIDER, encodeStream);
    EncodeStubAddress (CALLRESULT, encodeStream);
}

void CStubOperation_LPipe_OpenNamespace::DecodeOp (CTransportStream& decodeStream)
{
    DWORD dwInSt = CTransportStream::no_error;
    dwInSt |= decodeStream.ReadBSTR (&m_path);
    dwInSt |= decodeStream.ReadLong (&m_flags);
    DecodeContext (decodeStream);
    IWbemCallResult **ppResObj = NULL;
    dwInSt |= decodeStream.ReadLong ((long *) &ppResObj);
    SetResultObjectPP (ppResObj);

    if (CTransportStream::no_error != dwInSt)
        SetStatus (WBEM_E_INVALID_STREAM);
}

void CStubOperation_LPipe_OpenNamespace::Execute (CComLink& comLink, IUnknown *pStub)
{
    IWbemServices*  pObj = (IWbemServices *) pStub;
    IWbemCallResult *pResult = NULL;
        
    IWbemServices*  pProv = NULL;   // The new pointer
    SetStatus (pObj->OpenNamespace (m_path, m_flags, GetContext (), 
            &pProv, (GetResultObjectPP ()) ? &pResult : NULL));

    if (WBEM_NO_ERROR == GetStatus ())
    {
        CStubAddress_WinMgmt    stubAddr ( pProv);
        SetProxyAddress (PROVIDER, stubAddr);
        comLink.AddRef2 (pProv, PROVIDER, RELEASEIT);
    }
    
    if (pResult)
    {
        CStubAddress_WinMgmt    stubAddr ( pResult);
        SetProxyAddress (CALLRESULT, stubAddr);
        comLink.AddRef2 (pResult, CALLRESULT, RELEASEIT);
    }
}

// CStubOperation_LPipe_Put
void CStubOperation_LPipe_Put::DecodeOp (CTransportStream& decodeStream)
{
    DWORD dwInSt = CTransportStream::no_error;
    m_pObject = CreateClassObject (&decodeStream);
    dwInSt |= decodeStream.ReadLong (&m_flags);
    DecodeContext (decodeStream);

    if (IsAsync ())
        dwInSt |= decodeStream.ReadDWORD (&m_pHandler);
    else
    {
        IWbemCallResult **ppResObj = NULL;
        dwInSt |= decodeStream.ReadLong ((long *) &ppResObj);
        SetResultObjectPP (ppResObj);
    }

    if (CTransportStream::no_error != dwInSt)
        SetStatus (WBEM_E_INVALID_STREAM);
}

void CStubOperation_LPipe_Put::Execute (CComLink& comLink, IUnknown *pStub)
{
    IWbemServices*  pObj = (IWbemServices *) pStub;
        
    if (IsAsync ())
    {
        CStubAddress_WinMgmt    sinkAddr (m_pHandler);
        CObjectSinkProxy *pNoteProxy = 
                    comLink.GetObjectSinkProxy (sinkAddr, pObj);
            
        if (pNoteProxy)
        {
            SetStatus ((WBEM_METHOD_PutClassAsync == m_stubFunc) ?
                pObj->PutClassAsync (m_pObject, m_flags, GetContext (), 
                                    pNoteProxy) :
                pObj->PutInstanceAsync (m_pObject, m_flags, GetContext (), 
                                    pNoteProxy));
            pNoteProxy->Release (); // Balances GetObjectSinkProxy
        }
        else
            SetStatus (WBEM_E_INVALID_STREAM);
    }
    else
    {
        IWbemCallResult *pResult = NULL;
        
        SetStatus ((WBEM_METHOD_PutClass == m_stubFunc) ?
                    pObj->PutClass (m_pObject, m_flags, GetContext (), 
                        (GetResultObjectPP ()) ? &pResult : NULL) :
                    pObj->PutInstance (m_pObject, m_flags, GetContext (), 
                        (GetResultObjectPP ()) ? &pResult : NULL));
        
        if (pResult)
        {
            CStubAddress_WinMgmt    stubAddr (pResult);
            SetProxyAddress (CALLRESULT, stubAddr);
            comLink.AddRef2 (pResult, CALLRESULT, RELEASEIT);
        }
    }
}

// CStubOperation_LPipe_QueryObjectSink
void CStubOperation_LPipe_QueryObjectSink::Execute (CComLink& comLink, IUnknown *pStub)
{
    IWbemServices*  pObj = (IWbemServices *) pStub;
        
    IWbemObjectSink *pObjectSink = NULL;
    SetStatus (pObj->QueryObjectSink (m_flags, &pObjectSink));

    if (WBEM_NO_ERROR == GetStatus ())
    {
        CStubAddress_WinMgmt    stubAddr ( pObjectSink);
        SetProxyAddress (OBJECTSINK, stubAddr);
        comLink.AddRef2 (pObjectSink, OBJECTSINK, RELEASEIT);
    }
}

// CStubOperation_LPipe_ExecMethod
void CStubOperation_LPipe_ExecMethod::EncodeOp (CTransportStream& encodeStream)
{
    if (!IsAsync ())
    {
        if (WBEM_NO_ERROR == GetStatus () && m_pOutParams)
        {
            if (CTransportStream::no_error != 
                    ((CWbemObject *)m_pOutParams)->WriteToStream (&encodeStream))
                SetStatus (WBEM_E_INVALID_STREAM);
        }

        EncodeStubAddress (CALLRESULT, encodeStream);
    }
}

void CStubOperation_LPipe_ExecMethod::DecodeOp (CTransportStream& decodeStream)
{
    DWORD dwInSt = CTransportStream::no_error;
    dwInSt |= decodeStream.ReadBSTR (&m_path);
    dwInSt |= decodeStream.ReadBSTR (&m_method);
    dwInSt |= decodeStream.ReadLong (&m_flags);
    DecodeContext (decodeStream);

    // In parameters is an optional field
    long inParams = 0;
    dwInSt |= decodeStream.ReadLong (&inParams);

    if (inParams)
        m_pInParams = CreateClassObject (&decodeStream);
    
    if (IsAsync ())
        dwInSt |= decodeStream.ReadDWORD (&m_pHandler);
    else
    {
        dwInSt |= decodeStream.ReadLong ((long *) &m_pOutParams);
        IWbemCallResult **ppResObj = NULL;
        dwInSt |= decodeStream.ReadLong ((long *) &ppResObj);
        SetResultObjectPP (ppResObj);
    }

    if (CTransportStream::no_error != dwInSt)
        SetStatus (WBEM_E_INVALID_STREAM);
}

void CStubOperation_LPipe_ExecMethod::Execute (CComLink& comLink, IUnknown *pStub)
{
    IWbemServices*  pObj = (IWbemServices *) pStub;
        
    if (IsAsync ())
    {
        CStubAddress_WinMgmt    sinkAddr (m_pHandler);
        CObjectSinkProxy *pNoteProxy = 
                    comLink.GetObjectSinkProxy (sinkAddr, pObj);
            
        if (pNoteProxy)
        {
            SetStatus (pObj->ExecMethodAsync (m_path, m_method, m_flags,
                            GetContext (), m_pInParams, pNoteProxy));
            pNoteProxy->Release (); // balances GetObjectSinkProxy
        }
        else
            SetStatus (WBEM_E_INVALID_STREAM);
    }
    else
    {
        IWbemCallResult *pResult = NULL;
        
        SetStatus (pObj->ExecMethod (m_path, m_method, m_flags, GetContext (), 
                        m_pInParams, 
                        (m_pOutParams) ? &m_pOutParams : NULL,              
                        (GetResultObjectPP ()) ? &pResult : NULL));
        
        if (pResult)
        {
            CStubAddress_WinMgmt    stubAddr ( pResult);
            SetProxyAddress (CALLRESULT, stubAddr);
            comLink.AddRef2 (pResult, CALLRESULT, RELEASEIT);
        }
    }
}

// CStubOperation_LPipe_RequestChallenge
void CStubOperation_LPipe_RequestChallenge::DecodeOp (CTransportStream& decodeStream)
{
    DWORD dwInSt = CTransportStream::no_error;
    dwInSt |= decodeStream.ReadBSTR(&m_networkResource);
    dwInSt |= decodeStream.ReadBSTR(&m_user);

    if (CTransportStream::no_error != dwInSt)
        SetStatus (WBEM_E_INVALID_STREAM);
}

void CStubOperation_LPipe_RequestChallenge::EncodeOp (CTransportStream& encodeStream)
{
    if (WBEM_NO_ERROR == GetStatus ())
        encodeStream.WriteBytes (m_nonce, DIGEST_SIZE);
}

void CStubOperation_LPipe_RequestChallenge::Execute (CComLink& comLink, IUnknown *pStub)
{
    SetStatus (((IServerLogin *) pStub)->RequestChallenge 
                                (m_networkResource, m_user, m_nonce));
}

// CStubOperation_LPipe_EstablishPosition
void CStubOperation_LPipe_EstablishPosition::DecodeOp (CTransportStream& decodeStream)
{
    DWORD dwInSt = CTransportStream::no_error;
    dwInSt |= decodeStream.ReadBSTR(&m_clientMachineName);
    dwInSt |= decodeStream.ReadDWORD(&m_processId);

    if (CTransportStream::no_error != dwInSt)
        SetStatus (WBEM_E_INVALID_STREAM);
}

void CStubOperation_LPipe_EstablishPosition::EncodeOp (CTransportStream& encodeStream)
{
    if (WBEM_NO_ERROR == GetStatus ())
        encodeStream.WriteDWORD (m_authEventHandle);
}

void CStubOperation_LPipe_EstablishPosition::Execute (CComLink& comLink, IUnknown *pStub)
{
    SetStatus (((IServerLogin *) pStub)->EstablishPosition 
                                (m_clientMachineName, m_processId, &m_authEventHandle));
}

// CStubOperation_LPipe_WBEMLogin
void CStubOperation_LPipe_WBEMLogin::DecodeOp (CTransportStream& decodeStream)
{
    DWORD dwInSt = CTransportStream::no_error;
    dwInSt |= decodeStream.ReadBSTR(&m_preferredLocale);
    dwInSt |= decodeStream.ReadBytes (m_accessToken, DIGEST_SIZE);
    dwInSt |= decodeStream.ReadLong (&m_flags);
    DecodeContext (decodeStream);

    if (CTransportStream::no_error != dwInSt)
        SetStatus (WBEM_E_INVALID_STREAM);
}

void CStubOperation_LPipe_WBEMLogin::Execute (CComLink& comLink, IUnknown *pStub)
{
    IServerLogin *pObj = (IServerLogin *) pStub;
    IWbemServices *pProv = NULL;    // The new pointer
    SetStatus (pObj->WBEMLogin (m_preferredLocale, m_accessToken, 
                                m_flags, GetContext (), &pProv));

    if (WBEM_NO_ERROR == GetStatus ())
    {
        CStubAddress_WinMgmt    stubAddr ( pProv);
        SetProxyAddress (PROVIDER, stubAddr);
        comLink.AddRef2 (pProv, PROVIDER, RELEASEIT);
    }
}

// CStubOperation_LPipe_SspiPreLogin
void CStubOperation_LPipe_SspiPreLogin::EncodeOp (CTransportStream& encodeStream)
{
    // NB: We don't check for WBEM_NO_ERROR explicitly because
    // there are other S_ codes that can be returned by this call
    if ( ! FAILED ( GetStatus () ) )
    {
        encodeStream.WriteLong (m_outBufSize);
        encodeStream.WriteBytes (m_pOutToken, m_outBufSize);
        encodeStream.WriteDWORD (m_authEventHandle);
    }
}

void CStubOperation_LPipe_SspiPreLogin::DecodeOp (CTransportStream& decodeStream)
{
    DWORD dwInSt = CTransportStream::no_error;
    dwInSt |= decodeStream.ReadLPSTR (&m_pszSSPIPkg);
    dwInSt |= decodeStream.ReadLong (&m_flags);
    dwInSt |= decodeStream.ReadLong (&m_bufSize);

    if ((CTransportStream::no_error == dwInSt) && (0 < m_bufSize))
    {
        if (!(m_pInToken = new BYTE [m_bufSize]))
            SetStatus (WBEM_E_OUT_OF_MEMORY);
        else
            dwInSt |= decodeStream.ReadBytes (m_pInToken, m_bufSize);
    }

    dwInSt |= decodeStream.ReadLong (&m_outBufSize);

    if ((CTransportStream::no_error == dwInSt) && (0 < m_outBufSize))
    {
        if (!(m_pOutToken = new BYTE [m_outBufSize]))
            SetStatus (WBEM_E_OUT_OF_MEMORY);
    }

    dwInSt |= decodeStream.ReadBSTR(&m_clientMachineName);
    dwInSt |= decodeStream.ReadDWORD (&m_dwProcessID);

    if (CTransportStream::no_error != dwInSt)
        SetStatus (WBEM_E_INVALID_STREAM);
}

void CStubOperation_LPipe_SspiPreLogin::Execute (CComLink& comLink, IUnknown *pStub)
{
    SetStatus (((IServerLogin *) pStub)->SspiPreLogin 
                (m_pszSSPIPkg, m_flags,
                 m_bufSize, m_pInToken, m_outBufSize, &m_outBufSize, m_pOutToken, 
                 m_clientMachineName, m_dwProcessID, &m_authEventHandle));
}

// CStubOperation_LPipe_Login
void CStubOperation_LPipe_Login::DecodeOp (CTransportStream& decodeStream)
{
    DWORD dwInSt = CTransportStream::no_error;
    dwInSt |= decodeStream.ReadBSTR(&m_networkResource);
    dwInSt |= decodeStream.ReadBSTR(&m_preferredLocale);
    dwInSt |= decodeStream.ReadBytes (m_accessToken, DIGEST_SIZE);
    dwInSt |= decodeStream.ReadLong (&m_flags);
    DecodeContext (decodeStream);

    if (CTransportStream::no_error != dwInSt)
        SetStatus (WBEM_E_INVALID_STREAM);
}

void CStubOperation_LPipe_Login::Execute (CComLink& comLink, IUnknown *pStub)
{
    IServerLogin *pObj = (IServerLogin *) pStub;
    IWbemServices *pProv = NULL;    // The new pointer
    SetStatus (pObj->Login (m_networkResource, m_preferredLocale,
        m_accessToken, m_flags, GetContext (), &pProv));

    if (WBEM_NO_ERROR == GetStatus ())
    {
        CStubAddress_WinMgmt    stubAddr ( pProv);
        SetProxyAddress (PROVIDER, stubAddr);
        comLink.AddRef2 (pProv, PROVIDER, RELEASEIT);
    }
}

// CStubOperation_LPipe_Reset

void CStubOperation_LPipe_Reset::Execute (CComLink& comLink, IUnknown *pStub)
{
    SetStatus (((IEnumWbemClassObject *) pStub)->Reset ());
}

// CStubOperation_LPipe_Next

void CStubOperation_LPipe_Next::EncodeOp (CTransportStream& encodeStream)
{
    encodeStream.WriteDWORD (m_returned);

    for (DWORD dwLoop = 0; dwLoop < m_returned; dwLoop++)
    {
        ((CWbemObject *)(m_objArray [dwLoop]))->WriteToStream (&encodeStream);
        m_objArray [dwLoop]->Release ();
    }
}

void CStubOperation_LPipe_Next::DecodeOp (CTransportStream& decodeStream)
{
    DWORD dwInSt = CTransportStream::no_error;
    dwInSt |= decodeStream.ReadLong (&m_timeout);
    dwInSt |= decodeStream.ReadDWORD (&m_count);

    if (CTransportStream::no_error != dwInSt)
        SetStatus (WBEM_E_INVALID_STREAM);
    else if (!(m_objArray = (IWbemClassObject **) (new CWbemObject * [m_count])))
        SetStatus (WBEM_E_OUT_OF_MEMORY);
}

void CStubOperation_LPipe_Next::Execute (CComLink& comLink, IUnknown *pStub)
{
    SetStatus (((IEnumWbemClassObject *) pStub)->Next 
                    (m_timeout, m_count, m_objArray, &m_returned));
}

// CStubOperation_LPipe_Clone
void CStubOperation_LPipe_Clone::Execute (CComLink& comLink, IUnknown *pStub)
{
    IEnumWbemClassObject* pEnum = NULL;
    SetStatus (((IEnumWbemClassObject*) pStub)->Clone (&pEnum));

    if (WBEM_NO_ERROR == GetStatus ())
    {
        CStubAddress_WinMgmt    stubAddr ( pEnum);
        SetProxyAddress (ENUMERATOR, stubAddr);
        comLink.AddRef2 (pEnum, ENUMERATOR, RELEASEIT);
    }
}

// CStubOperation_LPipe_NextAsync
void CStubOperation_LPipe_NextAsync::DecodeOp (CTransportStream& decodeStream)
{
    DWORD dwInSt = CTransportStream::no_error;
    dwInSt |= decodeStream.ReadLong(&m_count);
    dwInSt |= decodeStream.ReadDWORD(&m_pSink);
    dwInSt |= decodeStream.ReadDWORD(&m_pServiceStub);

    if (CTransportStream::no_error != dwInSt)
        SetStatus (WBEM_E_INVALID_STREAM);
}

void CStubOperation_LPipe_NextAsync::Execute (CComLink& comLink, IUnknown *pStub)
{
    CStubAddress_WinMgmt    sinkAddr (m_pSink);
    IWbemServices   *pServices = (IWbemServices *) (comLink.GetStub (m_pServiceStub, PROVIDER));

    CObjectSinkProxy *pNoteProxy = comLink.GetObjectSinkProxy (sinkAddr, pServices);

    if (pNoteProxy)
    {
        SetStatus (((IEnumWbemClassObject *) pStub)->NextAsync (m_count, pNoteProxy));
        pNoteProxy->Release (); // balances GetObjectSinkProxy
    }
    else
        SetStatus (WBEM_E_INVALID_STREAM);

    if (pServices)
        pServices->Release ();  // Balances GetStub call above
}

// CStubOperation_LPipe_Skip
void CStubOperation_LPipe_Skip::DecodeOp (CTransportStream& decodeStream)
{
    DWORD dwInSt = CTransportStream::no_error;
    dwInSt |= decodeStream.ReadLong(&m_timeout);
    dwInSt |= decodeStream.ReadDWORD(&m_number);
    if (CTransportStream::no_error != dwInSt)
        SetStatus (WBEM_E_INVALID_STREAM);
}

void CStubOperation_LPipe_Skip::Execute (CComLink& comLink, IUnknown *pStub)
{
    SetStatus (((IEnumWbemClassObject *) pStub)->Skip (m_timeout, m_number));
}

// CStubOperation_LPipe_CallResult
void CStubOperation_LPipe_CallResult::EncodeOp (CTransportStream& encodeStream)
{
    if (WBEM_NO_ERROR == GetStatus ())
    {
        switch (m_stubFunc)
        {
        case GETRESULTOBJECT:
            if (m_pStatusObject && (CTransportStream::no_error != 
                (((CWbemObject *) m_pStatusObject)->WriteToStream (&encodeStream))))
                SetStatus (WBEM_E_INVALID_STREAM);
            break;

        case GETRESULTSTRING:
            encodeStream.WriteBSTR (m_resultString);
            break;

        case GETCALLSTATUS:
            encodeStream.WriteLong (m_status);
            break;

        case GETSERVICES:
            EncodeStubAddress (PROVIDER, encodeStream);
            break;

        }
    }
}   

void CStubOperation_LPipe_CallResult::DecodeOp (CTransportStream& decodeStream)
{
    if (CTransportStream::no_error != decodeStream.ReadLong(&m_timeout))
            SetStatus (WBEM_E_INVALID_STREAM);
}

void CStubOperation_LPipe_CallResult::Execute (CComLink& comLink, IUnknown *pStub)
{
    IWbemCallResult *pObj = (IWbemCallResult *) pStub;

    switch (m_stubFunc)
    {
    case GETRESULTOBJECT:
        SetStatus (pObj->GetResultObject (m_timeout, &m_pStatusObject));
        break;

    case GETRESULTSTRING:
        SetStatus (pObj->GetResultString (m_timeout, &m_resultString));
        break;

    case GETCALLSTATUS:
        SetStatus (pObj->GetCallStatus (m_timeout, &m_status));
        break;

    case GETSERVICES:
        {
            IWbemServices *pProv = NULL;
            SetStatus (pObj->GetResultServices (m_timeout, &pProv));

            if (WBEM_NO_ERROR == GetStatus ())
            {
                CStubAddress_WinMgmt    stubAddr (pProv);
                SetProxyAddress (PROVIDER, stubAddr);
                comLink.AddRef2 (pProv, PROVIDER, RELEASEIT);
            }
        }
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\stbaddcm.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    STBADDCM.H

Abstract:

    Declares the WinMgmt stub address class

History:

	alanbos  08-Jan-97   Created.

--*/

#ifndef _STBADDCM_H_
#define _STBADDCM_H_

class CStubAddress_WinMgmt : public IStubAddress
{
private:
	DWORD		m_dwStubAddress;

public:
	CStubAddress_WinMgmt () : m_dwStubAddress (0) {}
	CStubAddress_WinMgmt (DWORD dwStubAddr) : m_dwStubAddress (dwStubAddr) {}
#ifdef _WIN64
	CStubAddress_WinMgmt (void * pData) 
	{
		unsigned __int64 lTemp = (unsigned __int64)pData;
		m_dwStubAddress = (DWORD)lTemp;
	}
#else
	CStubAddress_WinMgmt (void * pData) : m_dwStubAddress ((DWORD)pData) {}
#endif
	CStubAddress_WinMgmt (CStubAddress_WinMgmt& stubAddr) : 
				m_dwStubAddress (stubAddr.GetRawAddress ()) {}

	DWORD			GetRawAddress () { return m_dwStubAddress; }

	void			Deserialize (CTransportStream& stream) { stream.ReadDWORD (&m_dwStubAddress); }
	void			Serialize (CTransportStream& stream) { stream.WriteDWORD (m_dwStubAddress); }

	IStubAddress*	Clone () { return new CStubAddress_WinMgmt (*this); }
	StubAddressType GetType () { return STUBADDR_WINMGMT; }
	bool			IsValid () { return (0 != m_dwStubAddress); }
	bool			IsEqual (IStubAddress& stubAddr)
	{
		return ((STUBADDR_WINMGMT == stubAddr.GetType ()) &&
				(GetRawAddress () == ((CStubAddress_WinMgmt &) stubAddr).GetRawAddress ()));
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\stubaddr.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    STUBADDR.H

Abstract:

    Declares the fundamental protocol-independent stub address class

History:

	alanbos  08-Jan-97   Created.

--*/

#ifndef _STUBADDR_H_
#define _STUBADDR_H_

enum StubAddressType { STUBADDR_WINMGMT, STUBADDR_HMMP };

// Base class (abstract) for any stub address irrespective
// of interface or protocol.  

class IStubAddress
{
protected:
	inline	IStubAddress () {}
	
public:
	virtual ~IStubAddress () {}

	virtual StubAddressType		GetType () PURE;
	virtual bool	IsValid () PURE;
	virtual bool IsEqual (IStubAddress& stubAddress) PURE;
	virtual IStubAddress* Clone () PURE;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\secfilt.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SECFILT.H

Abstract:

History:

--*/

#ifndef __SECURITY_FILTER
#define __SECURITY_FILTER

#define MD5_DIGEST_LENGTH 16

class CTransportStream ;
class IOperation ;

class ISecurityHelper 
{
public:

	ISecurityHelper () ;

	ISecurityHelper (

		BSTR a_UserName ,
		BSTR a_Password ,
		ULONG a_SecurityLevel
	) ;

	virtual ~ISecurityHelper () ;

	virtual CTransportStream &EncodeWithFilter ( IN CComLink &a_ComLink , IN IOperation &a_InputOperation , OUT CTransportStream &a_OutputStream ) ;
	virtual CTransportStream &DecodeWithFilter ( IN CComLink &a_ComLink , IN CTransportStream &a_InputStream , OUT IOperation &a_OuputOperation ) ;
} ;

class HmmpSecurityHelper : public ISecurityHelper
{
private:
protected:

	BSTR m_UserName ;
	UCHAR m_PasswordDigest [ MD5_DIGEST_LENGTH ] ;
	ULONG m_SecurityLevel ;
	
public:

	HmmpSecurityHelper () ;

	HmmpSecurityHelper (

		BSTR a_UserName ,
		BSTR a_Password ,
		ULONG a_SecurityLevel
	) ;

	HmmpSecurityHelper ( HmmpSecurityHelper &a_Copy ) ;

	HmmpSecurityHelper &operator== ( HmmpSecurityHelper &a_ToCopy ) ;

	~HmmpSecurityHelper () ;

	BSTR GetUserName () ;
	void GetPasswordDigest ( CTransportStream &a_Stream ) ;
	ULONG GetSecurityLevel () ;

	void SetUserName ( BSTR a_UserName ) ;
	void SetPasswordDigest ( UCHAR *a_PasswordDigest ) ;
	void SetSecurityLevel ( ULONG a_SecurityLevel ) ;

	HRESULT ValidateSignature ( CTransportStream &a_InSignature , CTransportStream &a_PartialDecode ) ;
	HRESULT GetSessionKey ( CTransportStream &a_OutStream ) ;
	HRESULT GetAccessToken ( CTransportStream &a_OutStream ) ;
	void InvalidateAccessToken () ;
} ;

inline ISecurityHelper :: ISecurityHelper (

	BSTR a_UserName ,
	BSTR a_Password ,
	ULONG a_SecurityLevel
) 
{
}

inline ISecurityHelper :: ISecurityHelper () 
{
}

inline ISecurityHelper :: ~ISecurityHelper () 
{
}


inline CTransportStream &ISecurityHelper :: EncodeWithFilter ( IN CComLink &a_ComLink , IN IOperation &a_InputOperation , OUT CTransportStream &a_OutputStream ) 
{
	return a_OutputStream ;
} 

inline CTransportStream &ISecurityHelper :: DecodeWithFilter ( IN CComLink &a_ComLink , IN CTransportStream &a_InputStream , OUT IOperation &a_OuputOperation )
{
	return a_InputStream ; 
}

inline HmmpSecurityHelper :: HmmpSecurityHelper () : m_UserName ( NULL ) , m_SecurityLevel ( 0 )
{
}

inline HmmpSecurityHelper :: HmmpSecurityHelper (

	BSTR a_UserName ,
	BSTR a_Password ,
	ULONG a_SecurityLevel

) : m_SecurityLevel ( a_SecurityLevel ) , m_UserName ( NULL ) 
{
	SetUserName ( a_UserName ) ;
}

inline HmmpSecurityHelper :: ~HmmpSecurityHelper ()
{
	if ( m_UserName ) 
		SysFreeString ( m_UserName ) ;
}

inline BSTR HmmpSecurityHelper :: GetUserName () 
{
	return m_UserName ; 
}


inline ULONG HmmpSecurityHelper :: GetSecurityLevel () 
{ 
	return m_SecurityLevel ; 
}

inline void HmmpSecurityHelper :: SetUserName ( BSTR a_UserName ) 
{
	if ( m_UserName ) 
		SysFreeString ( m_UserName ) ; 

	m_UserName = SysAllocString ( a_UserName ) ; 
}

#endif // __SECURITY_FILTER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\thrdpool.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    THRDPOOL.CPP

Abstract:

    Defines the CThrdPool class which provides a pool of threads
    to handle calls.

History:

    a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include "wmishared.h"
#include <cominit.h>

//***************************************************************************
//
//  DWORD WorkerThread
//
//  DESCRIPTION:
//
//  This is where the "worker" threads loop.  Genarally they are 
//  either performing a call, or are waiting for a START or TERMINATE
//  event.  The tread stays here until the TERMINATE event in which case
//  it frees up memory and then terminates itself.
//
//  PARAMETERS:
//
//  pParam              points to arugment structure. 
//
//  RETURN VALUE:
//
//  not used.
//
//***************************************************************************

DWORD WorkerThread ( LPDWORD pParam )
{ 
    WorkerThreadArgs *t_Thread = (WorkerThreadArgs *)pParam;

    InitializeCom ();

    for (;;) 
    {
        DWORD dwRet = WbemWaitForMultipleObjects (

            TERMINATE+1 ,
            t_Thread->m_Events,
            60000
        );

        if(dwRet == WAIT_TIMEOUT)
        {
            t_Thread->m_ThreadPool->PruneIdleThread();
            continue;
        }

        // Check for termination, if that is the case free up and exit.
        // ============================================================

        if(dwRet == WAIT_OBJECT_0 + TERMINATE)
        {
            CloseHandle ( t_Thread->m_Events [START] ) ;
            CloseHandle ( t_Thread->m_Events [TERMINATE] ) ;
            CloseHandle ( t_Thread->m_Events [READY_TO_REPLY] ) ;
            CloseHandle ( t_Thread->m_Events [DONE] ) ;

            CloseHandle ( t_Thread->m_ThreadHandle );

            delete t_Thread ;
            MyCoUninitialize() ;
            return 0;
        }

        if ( dwRet == WAIT_OBJECT_0 + START )
        {
            // Still work to do.  Get the necessary arguments from the read
            // stream and call the stub.
            // ============================================================

            t_Thread->m_ComLink->HandleCall ( *t_Thread->m_Operation ) ;

            gThrdPool.Replying () ;

            // Reset the START event and set the Done event 
            // to indicate that the thread is ready for a new command.
            // =======================================================

            ResetEvent( t_Thread->m_Events [START] ) ;
            t_Thread->m_ComLink->Release2 ( NULL , NONE ) ;
            SetEvent( t_Thread->m_Events [DONE] ) ;
        }
    }

    MyCoUninitialize() ;
    return 0;
}

//***************************************************************************
//
//  CThrdPool::CThrdPool
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CThrdPool::CThrdPool()
{
    InitializeCriticalSection(&m_cs);

#if 0
    m_Mutex = CreateMutex (

        NULL,
        FALSE,
        NULL
    ) ;
#endif
}

CThrdPool::~CThrdPool()
{
#if 0
    CloseHandle ( m_Mutex ) ;
#else
    DeleteCriticalSection(&m_cs);
#endif
}

//***************************************************************************
//
//  void CThrdPool::Free
//
//  DESCRIPTION:
//
//  Called to free all entries.
//
//***************************************************************************

void CThrdPool::Free()
{
    WorkerThreadArgs *t_Thread ;
    int t_Index;

    // Tell all threads to terminate themselves.  They will free up
    // the memory.
    
    for ( t_Index = 0 ; t_Index < m_ThreadContainer.Size () ; t_Index ++ )
    {
        t_Thread = (WorkerThreadArgs *) m_ThreadContainer.GetAt ( t_Index ) ;
        if ( t_Thread )
        {
            HANDLE t_ThreadHandle = t_Thread->m_ThreadHandle ;
            SetEvent ( t_Thread->m_Events [TERMINATE] ) ;

            DWORD dwRet = WbemWaitForSingleObject ( t_ThreadHandle , 1000 ) ;
            if(dwRet != WAIT_OBJECT_0)
            {
                TerminateThread ( t_ThreadHandle , 4 ) ;
            }
        }
    }
}

//***************************************************************************
//
//  BOOL CThrdPool::Busy
//
//  DESCRIPTION:
//
//  Called to check if all the workers are idle.
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//  TRUE if at least on worker thread is doing something.
//
//***************************************************************************

BOOL CThrdPool :: Busy ()
{
    // Get exclusive access
    // ====================

#if 0
    if(m_Mutex == NULL)
    {
        return FALSE;
    }

    DWORD dwRet1 = WbemWaitForSingleObject( m_Mutex , MAX_WAIT_FOR_WRITE ) ;
    if(dwRet1 != WAIT_OBJECT_0)
    {
        return FALSE;
    }

#else
    EnterCriticalSection(&m_cs);
#endif

    // Search the list for a busy entry
    // ================================

    BOOL bRet = FALSE;

    for ( int t_Index = 0 ; t_Index < m_ThreadContainer.Size () ; t_Index ++ )
    {
        WorkerThreadArgs *t_Thread = (WorkerThreadArgs *) m_ThreadContainer.GetAt ( t_Index ) ;
        if(t_Thread)
        {
            DWORD dwRet1 = WbemWaitForSingleObject ( t_Thread->m_Events [START] , 0 ) ;
            DWORD dwRet2 = WbemWaitForSingleObject ( t_Thread->m_Events [READY_TO_REPLY] , 0 ) ;

            if( dwRet1 == WAIT_OBJECT_0 && dwRet2 != WAIT_OBJECT_0 )
            {
                bRet = TRUE;
                break;
            }
        }
    }

#if 0
    ReleaseMutex ( m_Mutex ) ;
#else
    LeaveCriticalSection(&m_cs);
#endif

    return bRet;
}

//***************************************************************************
//
//  BOOL CThrdPool::Replying 
//
//  DESCRIPTION:
//
//  Set to indicate that the worker thread has finished processing it "call"
//  and is now sending back results.
//
//  RETURN VALUE:
//
//  TRUE if it worked.
//
//***************************************************************************

BOOL CThrdPool :: Replying ()
{
    DWORD t_ThreadId = GetCurrentThreadId () ;

    // Get exclusive access
    // ====================

#if 0
    if(m_Mutex == NULL)
    {
        return FALSE;
    }

    DWORD dwRet = WbemWaitForSingleObject ( m_Mutex , MAX_WAIT_FOR_WRITE ) ;
    if(dwRet != WAIT_OBJECT_0)
    {
        return FALSE;
    }
#else
    EnterCriticalSection(&m_cs);
#endif

    // Search the list for a busy entry
    // ================================

    BOOL bRet = FALSE;

    for ( int t_Index = 0 ; t_Index < m_ThreadContainer.Size () ; t_Index++ )
    {
        WorkerThreadArgs *t_Thread = (WorkerThreadArgs *) m_ThreadContainer.GetAt ( t_Index ) ;
        if ( t_Thread && t_Thread ->m_ThreadId == t_ThreadId )
        {
            SetEvent ( t_Thread ->m_Events [READY_TO_REPLY] ) ;
            bRet = TRUE;
            break;
        }
    }

#if 0
    ReleaseMutex(m_Mutex);
#else
    LeaveCriticalSection(&m_cs);
#endif

    return bRet;
}

//***************************************************************************
//
//  BOOL CThrdPool::Execute
//
//  DESCRIPTION:
//
//  Called when there is work to do.  It either finds and idle 
//  thread in the pool or it adds one.  Then it sets the arguements and
//  sets the proper events to indicate that the worker thread can start.
//
//  PARAMETERS:
//
//  pComLink            comlink that the request came over
//  pData               pointer to request data
//  dwDataSize          size of request data
//  guidPacketID        guid to identify this transaction
//
//  RETURN VALUE:
//
//  TRUE if all is well
//
//***************************************************************************

BOOL CThrdPool :: Execute (

    IN CComLink &a_ComLink ,
    IN IOperation &a_Operation 
)
{
    BOOL bRet = FALSE ;

    // Get exclusive access since the array may need updating
    // ======================================================

#if 0
    if(m_Mutex == NULL)
    {
        return FALSE;
    }

    DWORD dwRet = WbemWaitForSingleObject(m_Mutex,MAX_WAIT_FOR_WRITE);
    if(dwRet != WAIT_OBJECT_0)
    {
        return FALSE;
    }
#else
    DWORD dwRet ;
    EnterCriticalSection(&m_cs);    
#endif

    WorkerThreadArgs *t_Thread = NULL ;

    // Search the list for an unused entry
    // ===================================

    for ( int t_Index = 0; t_Index < m_ThreadContainer.Size(); t_Index++)
    {
        t_Thread = ( WorkerThreadArgs * ) m_ThreadContainer.GetAt ( t_Index ) ;
        if( t_Thread )
        {
            dwRet = WbemWaitForSingleObject ( t_Thread->m_Events[DONE] , 0 ) ;
            if ( dwRet == WAIT_OBJECT_0 )
            {
                break;
            }
        }
    }

    // If an entry wasnt found, add one
    // ================================

    if( t_Index == m_ThreadContainer.Size () )
    {
        t_Thread = Add () ;
    }

    if(t_Thread == NULL)
    {
        goto DoCommandCleanup;
    }

    // Got a thread entry, set its arguments and let it run!
    // =====================================================

    t_Thread->m_ComLink = & a_ComLink ;
    t_Thread->m_Operation = & a_Operation ;

    ResetEvent ( t_Thread->m_Events [ READY_TO_REPLY ] ) ;
    ResetEvent ( t_Thread->m_Events [ DONE ] ) ;
    bRet = SetEvent ( t_Thread->m_Events [START ] ) ;

DoCommandCleanup:

#if 0
    ReleaseMutex ( m_Mutex ) ;
#else
    LeaveCriticalSection(&m_cs);
#endif

    return bRet;
}

//***************************************************************************
//
//  void CThrdPool::PruneThreadList
//
//  DESCRIPTION:
//
//  Used to make sure there aren't too many idle threads in the 
//  pool.  
//
//***************************************************************************

void CThrdPool::PruneIdleThread ()
{
    DWORD t_ThreadId = GetCurrentThreadId () ;

    // Get exclusive access since the array may need updating
    // ======================================================

#if 0
    if( m_Mutex == NULL )
    {
        return;
    }

    DWORD dwRet = WbemWaitForSingleObject ( m_Mutex , MAX_WAIT_FOR_WRITE ) ;
    if ( dwRet != WAIT_OBJECT_0 )
    {
        return ;
    }

#else
    DWORD dwRet ;
    EnterCriticalSection(&m_cs);
#endif

    // go through the thread list and find the thread. 
    // ================================================================

    for ( int t_Index = 0 ; t_Index < m_ThreadContainer.Size () ; t_Index ++ )
    {
        WorkerThreadArgs *t_Thread = (WorkerThreadArgs *) m_ThreadContainer.GetAt ( t_Index ) ;
        if ( t_Thread && t_Thread->m_ThreadId == t_ThreadId )
        {
            // double check that it is done before setting the terminate event

            dwRet = WbemWaitForSingleObject ( t_Thread->m_Events [DONE] , 0 ) ;

            if ( dwRet == WAIT_OBJECT_0 )  // we are done
            {
                SetEvent ( t_Thread->m_Events [TERMINATE] ) ;

                m_ThreadContainer.RemoveAt ( t_Index ) ;
                m_ThreadContainer.Compress () ;
            }

            break;          // we are done
        }
    }

#if 0
    ReleaseMutex ( m_Mutex ) ;
#else
    LeaveCriticalSection(&m_cs);
#endif

}

//***************************************************************************
//
//  WorkerThreadArgs * CThrdPool::AddNewEntry
//
//  DESCRIPTION:
//
//  Private function used to add a new thread to the pool.
//
//  RETURN VALUE:
//
//  pointer to WorkerThreadArgs structure, NULL if error.
//
//***************************************************************************

WorkerThreadArgs *CThrdPool :: Add ()
{
    WorkerThreadArgs *t_Thread = new WorkerThreadArgs ;
    if ( t_Thread == NULL )
    {
        return NULL;
    }

    t_Thread->m_ThreadPool = this ;

    t_Thread->m_Events[START]           = CreateEvent (NULL,TRUE,FALSE,NULL) ;
    t_Thread->m_Events[TERMINATE]       = CreateEvent (NULL,TRUE,FALSE,NULL) ;
    t_Thread->m_Events[READY_TO_REPLY]  = CreateEvent (NULL,TRUE,FALSE,NULL) ;
    t_Thread->m_Events[DONE]            = CreateEvent (NULL,TRUE,FALSE,NULL) ;

    if ( t_Thread->m_Events [START] == NULL || 
        t_Thread->m_Events [TERMINATE] == NULL ||
        t_Thread->m_Events [READY_TO_REPLY] == NULL || 
        t_Thread->m_Events [DONE] == NULL)
    {
        goto AddNewEntryCleanup ;
    }

    if ( CFlexArray::no_error != m_ThreadContainer.Add ( t_Thread ) )
    {
        goto AddNewEntryCleanup ;
    }

    t_Thread->m_ThreadHandle = CreateThread ( 

        NULL ,
        0 ,
        ( LPTHREAD_START_ROUTINE ) WorkerThread , 
        ( LPVOID ) t_Thread ,
        0 ,
        & t_Thread->m_ThreadId
    ) ;

    if ( t_Thread->m_ThreadHandle )
    {
        return t_Thread ;        // all is well
    }

/*
 *  Remove this entry.
 */

    m_ThreadContainer.RemoveAt ( m_ThreadContainer.Size () - 1 ) ;

AddNewEntryCleanup: 

    if ( t_Thread->m_Events [START] )
        CloseHandle ( t_Thread->m_Events [START] ) ;

    if ( t_Thread->m_Events[TERMINATE] )
        CloseHandle ( t_Thread->m_Events [TERMINATE] ) ;

    if ( t_Thread->m_Events[DONE] )
        CloseHandle ( t_Thread->m_Events [DONE] ) ;

    delete t_Thread;

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\tcpip.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    TCPIP.H

Abstract:

    Defines the functions used for tcpip transport.

History:

	a-davj  16-june-97   Created.

--*/

/////////////////////////////////////////////////////////////////////
//
//
//
/////////////////////////////////////////////////////////////////////

#ifndef _WBEMTCPIP_
#define _WBEMTCPIP_

//***************************************************************************
//
//  CLASS NAME:
//
//  CComLink_Tcpip
//
//  DESCRIPTION:
//
//  TCPIP implementation of the CComLink.
//
//***************************************************************************

//***************************************************************************
//
//  CLASS NAME:
//
//  CComLink_Tcpip
//
//  DESCRIPTION:
//
//  Unnamed pipe implementation of the CComLink.
//
//***************************************************************************

class CComLink_Tcpip : public CComLink
{
friend DWORD LaunchReadTcpipThread ( LPDWORD pParam ) ;
public:

    CComLink_Tcpip ( 

		LinkType Type ,
		SOCKET a_Socket 
	) ;

// Destructor for Tcpip

	// Sends a COMLINK_MSG_NOTIFY_DESTRUCT to 
	// its partner, if any.
	// Does a Release() on the CMsgHandler as well.

    ~CComLink_Tcpip () ;

    DWORD Call ( IN IOperation &a_Operation ) ;

    DWORD Transmit ( CTransportStream &a_WriteStream ) ;

    DWORD StrobeConnection () ;  

	DWORD ProbeConnection () ;  

	DWORD HandleCall ( IN IOperation &a_Operation ) ;

	DWORD Shutdown () ;

	void DropLink () ;

	CObjectSinkProxy*	CreateObjectSinkProxy (IN IStubAddress& dwStubAddr, 
											   IN IWbemServices* pServices);

private:

    DWORD DoReading () ;

    void ProcessRead ( PACKET_HEADER *ph , BYTE *pData , DWORD dwDataSize ) ;

/*
 *	Tcpip Handles
 */

    SOCKET m_Socket ;			// Handle used to read from PIPE
/*
 *	Thread Handle of Reader thread
 */

    HANDLE m_ReadThread;				// Thread Handle created for Synchronous listening 
    HANDLE m_ReadThreadDoneEvent ;		// Event Handle used to indicate thread has shutdown, based on hTermEvent.

} ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\tcpip.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    TCPIP.CPP

Abstract:

    Defines the functions used for tcpip transport.

History:

    a-davj  16-june-97   Created.

--*/

#include "precomp.h"
#include "wmishared.h"
#include "tcpip.h"

//***************************************************************************
//
//  DWORD LaunchReadTcpipThread
//
//  DESCRIPTION:
//
//  Starting point for anon pipe read thread.
//
//  PARAMETERS:
//
//  pParam              pointer to comlink object
//
//  RETURN VALUE:
//
//  0
//***************************************************************************

DWORD LaunchReadTcpipThread ( LPDWORD pParam )
{
    InitializeCom () ;
    CComLink_Tcpip *t_Com = ( CComLink_Tcpip *) pParam ;

    return t_Com->DoReading () ;
}

//***************************************************************************
//
//  CComLink_Tcpip::CComLink_Tcpip
//
//  DESCRIPTION:
//
//  Constructor.
//
//  PARAMETERS:
//
//  hRead               write handle
//  hWrite              read handle
//  Type                comlink type
//  hTerm               event which can be set to invoke destruction
//
//***************************************************************************

CComLink_Tcpip::CComLink_Tcpip (

    IN LinkType a_Type,
    IN SOCKET a_Socket

) : CComLink ( a_Type ) ,
    m_Socket ( a_Socket ) 
{
    DWORD t_ThreadId ;

    AddRef2 ( NULL , NONE , DONOTHING ) ;

    m_ReadThread = CreateThread (

        NULL,
        0,
        (LPTHREAD_START_ROUTINE) LaunchReadTcpipThread, 
        (LPVOID)this,
        0,
        &t_ThreadId
    ) ;

    m_ReadThreadDoneEvent   = CreateEvent(NULL,TRUE,FALSE,NULL);

    gMaintObj.AddComLink ( this ) ;
}

//***************************************************************************
//
//  CComLink_Tcpip::~CComLink_Tcpip
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CComLink_Tcpip :: ~CComLink_Tcpip ()
{
    DEBUGTRACE((LOG,"\nLocal Tcpip comlink [0x%x] is terminating", this));

    // Stop the read thread

    if(m_ReadThread)
    {
        DWORD dwRet = WbemWaitForSingleObject ( m_ReadThreadDoneEvent , 2000 ) ;
        if ( dwRet != WAIT_OBJECT_0 )
        {
        }

        if ( m_Socket ) 
            closesocket ( m_Socket) ;

        if ( m_ReadThread )
            CloseHandle ( m_ReadThread ) ;

        if ( m_ReadThreadDoneEvent )
            CloseHandle ( m_ReadThreadDoneEvent ) ;

        TerminateThread ( m_ReadThread , 1 ) ;

        return ;
    }

    if ( m_Socket ) 
        closesocket ( m_Socket ) ;

    if ( m_ReadThread )
        CloseHandle ( m_ReadThread ) ;

    if ( m_ReadThreadDoneEvent )
        CloseHandle ( m_ReadThreadDoneEvent ) ;

}

DWORD CComLink_Tcpip :: Call ( IN IOperation &a_Operation )
{
    HRESULT t_Result = WBEM_E_TRANSPORT_FAILURE;

    // Verify that the streams are OK and get a slot in the write queue

    if ( ! SUCCEEDED ( a_Operation.GetStatus () ) )
    {
        t_Result = WBEM_E_INVALID_STREAM;
    }
    else
    {
        BOOL t_ReceivedResponse = FALSE ;

        HANDLE t_EventContainer [ 2 ] ;

        t_EventContainer [ 0 ] = m_WriteQueue.AllocateRequest ( a_Operation ) ;
        if ( ! t_EventContainer [ 0 ] ) 
        {
            t_Result = WBEM_E_OUT_OF_MEMORY ;
        }
        else
        {
            t_EventContainer [ 1 ] = m_TerminationEvent ;

            ResetEvent ( t_EventContainer [ 0 ] ) ;
        
            ISecurityHelper t_Helper ;
            CTransportStream t_WriteStream ;

            bool t_Status = a_Operation.EncodeRequest ( t_WriteStream , t_Helper ) ;
            if ( t_Status ) 
            {
                Transmit ( t_WriteStream ) ;

                DWORD t_Status = WbemWaitForMultipleObjects ( 2 , t_EventContainer , INFINITE ) ;

                // Check for forced termiation
                // ===========================

                switch ( t_Status )
                {
                    case WAIT_OBJECT_0+1:
                    {
                        t_Result = WBEM_E_TRANSPORT_FAILURE;    // Termination event
                    }
                    break ;

                    case WAIT_OBJECT_0:
                    {
                        if ( m_WriteQueue.GetRequestStatus ( t_EventContainer [0] ) == COMLINK_MSG_RETURN ) 
                        {
                            CTransportStream &t_ReadStream = a_Operation.GetDecodeStream ();            
                            t_ReadStream.Reset () ;
                            DWORD t_Position = t_ReadStream.GetCurrentPos () + sizeof ( PACKET_HEADER ) ;
                            t_ReadStream.SetCurrentPos ( t_Position ) ;

                            ISecurityHelper t_Helper ;
                            if ( a_Operation.DecodeResponse ( t_ReadStream , t_Helper ) ) 
                            {
                            }
                            else
                            {
                            }
        
                            // looks good so far. Get the return code

                            t_Result = a_Operation.GetStatus () ;

                        }
                        else if ( m_WriteQueue.GetRequestStatus ( t_EventContainer [0] ) == COMLINK_MSG_RETURN_FATAL_ERROR )
                        {
                // this occures only if the server is out of resources, in that
                // case we dont want to send additional request.
                // ============================================================

                            t_Result = WBEM_E_PROVIDER_FAILURE;
                        }
                        else 
                        {
                            t_Result = WBEM_E_TRANSPORT_FAILURE;
                        }
                    }
                    break ;

                    default:
                    {
                        t_Result = WBEM_E_TRANSPORT_FAILURE;
                    }
                    break ;
                }
            }
        }

        // All done, give up the slot and return.

        m_WriteQueue.DeallocateRequest ( t_EventContainer [ 0 ] ) ;

        a_Operation.SetErrorInfoOnThread () ;
    }

    a_Operation.SetStatus ( t_Result ) ;

    return t_Result ;
}

//***************************************************************************
//
//  int CComLink_Tcpip::Transmit
//
//  DESCRIPTION:
//
//  Transmitts a packet via the anon pipe
//
//  PARAMETERS:
//
//  dwSend              type of package
//  *pSendStream        stream containing data to write
//  guidPacketID        GUILD to identify packet
//  hWrite              write header
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  WBEM_E_TRANSPORT_FAILURE   if write fails
//  otherwise error set by Serialize
//
//***************************************************************************

DWORD CComLink_Tcpip::Transmit ( CTransportStream &a_WriteStream ) 
{
    BOOL t_Status = TRUE ;

#if 0
    DWORD t_Result = WbemWaitForSingleObject ( m_WriteMutex , MAX_WAIT_FOR_WRITE ) ; 
#else
    DWORD t_Result = WAIT_OBJECT_0 ;
    EnterCriticalSection(&m_cs);
#endif

    if ( t_Result == WAIT_OBJECT_0 )
    {
        t_Result = a_WriteStream.Serialize ( (HANDLE)m_Socket ) ;   // Serialise the stream to the pipe
        t_Status = SUCCEEDED ( t_Result ) ;
        if ( ! t_Status ) 
        {
// Set Some internal error
        }
    }
    else
    {
        t_Status = FALSE ;
    }

#if 0
    ReleaseMutex ( m_WriteMutex ) ;
#else
    LeaveCriticalSection(&m_cs);
#endif

    return t_Status ;
}

//***************************************************************************
//
//  CComLink_Tcpip::DoReading
//
//  DESCRIPTION:
//
//  Where the anon pipe read thread lives.
//
//***************************************************************************

DWORD CComLink_Tcpip :: DoReading ()
{
    while ( 1 )
    {
        DWORD t_Result = WbemWaitForSingleObject ( m_TerminationEvent ,  0 ) ;
        if ( t_Result != WAIT_OBJECT_0 ) 
        {
            CTransportStream t_ReadStream ;
            switch ( t_ReadStream.Deserialize ( (HANDLE)m_Socket  ) )
            {
                case CTransportStream :: failed:
                case CTransportStream :: out_of_memory:
                {
                    DWORD t_ErrorResult = GetLastError () ;
                    SetEvent ( m_TerminationEvent ) ;
                    SetEvent ( m_ReadThreadDoneEvent ) ;

                    Release2 ( NULL , NONE ) ;

                    CoUninitialize () ;
                    ExitThread ( 0 ) ;                       // terminate the thread
                }
                break ;

                default:
                {
                    t_ReadStream.Reset () ;
					PACKET_HEADER *t_PacketHeader = (PACKET_HEADER *)
											((BYTE *)t_ReadStream.GetPtr() + t_ReadStream.GetCurrentPos());
 
                    ProcessRead ( 

                        t_PacketHeader , 
                        ( unsigned char * ) t_ReadStream.GetPtr () ,
                        t_ReadStream.Size ()
                    ) ;
                }
                break ;
            }
        }
        else
        {
            SetEvent ( m_ReadThreadDoneEvent ) ;
            Release2 ( NULL , NONE ) ;
            CoUninitialize () ;
            ExitThread ( 0 ) ;                       // terminate the thread
        }
    }

    return 0 ;
}

//***************************************************************************
//
//  void CComLink::ProcessRead
//
//  DESCRIPTION:
//
//  Got a package from our partner.  It could be a response to something
//  we sent, or it could be something initiated in our partner.
//
//  PARAMETERS:
//
//  pPacketHeader       pointer to header object  
//  pData               data to be sent
//  dwDataSize          size of data
//
//  RETURN VALUE:
//
//  
//***************************************************************************

void CComLink_Tcpip :: ProcessRead (

    IN PACKET_HEADER *a_PacketHeader ,
    IN BYTE *a_PayLoadData ,
    IN DWORD a_PayLoadSize
)
{
    m_LastReadTime = GetCurrentTime ();
    
    // bump up the count at the start and restore at the end of this 
    // routine.  This is done so that object wount disappear in the 
    // middle of handling a read.
    //==============================================================

    AddRef2(NULL, NONE, DONOTHING);

    DWORD t_Type = a_PacketHeader->GetType();
    RequestId t_RequestId  = a_PacketHeader->GetRequestId ();

    DEBUGTRACE((LOG,"\nProcessing Read on comlink [0x%x], type is %d RequestId=%d",
                    this, t_Type,t_RequestId));                


    if ( t_Type == COMLINK_MSG_RETURN || t_Type == COMLINK_MSG_RETURN_FATAL_ERROR )
    {
        IOperation *t_Operation = m_WriteQueue.GetOperation ( t_RequestId );
        if ( ! t_Operation )
        {
            Release2 ( NULL , NONE ) ;

            return;                             //todo, else, should bitch
        }

        if ( t_Type == COMLINK_MSG_RETURN )
        {
            CTransportStream &t_ReadStream = t_Operation->GetDecodeStream ();
            t_ReadStream.CMemStream :: Deserialize ( a_PayLoadData , a_PayLoadSize ) ;
        }
        else
        {
            t_Operation->SetStatus ( WBEM_E_PROVIDER_FAILURE ) ;
        }

        m_WriteQueue.SetEventAndStatus ( t_RequestId , t_Type ) ;
    }
    else if ( t_Type == COMLINK_MSG_CALL )    
    {
        // This is a new call. This might be lengthy 
        // and so a thread is created to call the stub.  If the thread is 
        // created, it is responsible for freeing up the allocations and 
        // doing an extra Release on the comlink
        // =================================================================
        
    //  ISecurityHelper t_Helper ;
        CTransportStream t_ReadStream ;
        t_ReadStream.CMemStream :: Deserialize ( a_PayLoadData , a_PayLoadSize ) ;

        t_ReadStream.Reset () ;
        DWORD t_Position = t_ReadStream.GetCurrentPos () + sizeof ( PACKET_HEADER ) ;
        t_ReadStream.SetCurrentPos ( t_Position ) ;

        IOperation *t_Operation = NULL ;
        if ( IOperation_LPipe :: Decode ( *a_PacketHeader , t_ReadStream , &t_Operation ) )
        {
            ISecurityHelper t_Helper ;
            if ( t_Operation->DecodeRequest ( t_ReadStream , t_Helper ) )
            {
                HANDLE t_ReadEvent = m_ReadQueue.AllocateRequest ( *t_Operation );
                if ( t_ReadEvent )
                {
                    BOOL t_Status = gThrdPool.Execute ( 

                        *this , 
                        *t_Operation
                    ) ;

                    if ( t_Status )
                    {
                        return ;
                    }

                // should only be here if some failure, clean up any allocations

                    if ( t_ReadEvent )
                    {
                        m_ReadQueue.DeallocateRequest ( t_ReadEvent ) ;
                    }
                }
            }
            else
            {
            }
        }
    }
    else if ( t_Type == COMLINK_MSG_PING )
    {
// Reply to strobe

        ISecurityHelper t_Helper ;
        COperation_LPipe_Ping t_pingOp (*a_PacketHeader);
        CTransportStream t_WriteStream ;

        if (t_pingOp.EncodeResponse ( t_WriteStream, t_Helper ))
        {
            if ( Transmit ( t_WriteStream ) )
            {
            }
            else
            {
            }
        }
    }
    else if ( t_Type == COMLINK_MSG_PING_ACK )
    {
        // simple ack type
        m_WriteQueue.SetEventAndStatus ( t_RequestId ,t_Type ) ;
    }
    else if ( t_Type == COMLINK_MSG_CALL_NACK )
    {
        // simple ack type
        m_WriteQueue.SetEventAndStatus ( t_RequestId ,t_Type ) ;
    }
    else if ( t_Type == COMLINK_MSG_HEART_BEAT )
    {
        ISecurityHelper t_Helper ;
        COperation_LPipe_Strobe t_StrobeOp (*a_PacketHeader);
        CTransportStream t_WriteStream ;

        if (t_StrobeOp.EncodeResponse ( t_WriteStream, t_Helper ))
        {
            if ( Transmit ( t_WriteStream ) )
            {
            }
            else
            {
            }
        }
    }
    else if ( t_Type == COMLINK_MSG_HEART_BEAT_ACK )
    {
    }
    else if ( t_Type == COMLINK_MSG_NOTIFY_DESTRUCT )
    {
        SetEvent ( m_TerminationEvent ) ;
        gMaintObj.ShutDownComlink ( this ) ;
    }
    else
    {
// ???
    }

    Release2 ( NULL , NONE ) ;
}

//***************************************************************************
//
//  DWORD CComLink::Ping
//
//  DESCRIPTION:
//
//  Sends a simple message and waits for a simple ack.  This is used as a
//  "heart beat" test.
//
//  PARAMETERS:
//
//  hTerm1              First event handle that can be used to stop this call
//  hTerm2              second event handle that can be used to stop this call
//
//  RETURN VALUE:
//
//  S_OK                no error,
//  else set by SendAndWaitSimple
//
//***************************************************************************

DWORD CComLink_Tcpip :: ProbeConnection ()
{
    HRESULT t_Result ;

    ISecurityHelper t_Helper ;

    COperation_LPipe_Ping t_Operation  ;

    HANDLE t_EventContainer [ 2 ] ;

    t_EventContainer [ 0 ] = m_WriteQueue.AllocateRequest ( t_Operation ) ;
    if ( ! t_EventContainer [ 0 ] ) 
    {
        t_Result = WBEM_E_OUT_OF_MEMORY ;
    }
    else
    {
        t_EventContainer [ 1 ] = m_TerminationEvent ;

        ResetEvent ( t_EventContainer [ 0 ] ) ;
    
        ISecurityHelper t_Helper ;
        CTransportStream t_WriteStream ;

        bool t_Status = t_Operation.EncodeRequest ( t_WriteStream , t_Helper ) ;
        if ( t_Status ) 
        {
            Transmit ( t_WriteStream ) ;

            DWORD t_Status = WbemWaitForMultipleObjects ( 2 , t_EventContainer , INFINITE ) ;

            // Check for forced termiation
            // ===========================

            switch ( t_Status )
            {
                case WAIT_OBJECT_0+1:
                {
                    t_Result = WBEM_E_TRANSPORT_FAILURE;    // Termination event
                }
                break ;

                case WAIT_OBJECT_0:
                {
                    if ( m_WriteQueue.GetRequestStatus ( t_EventContainer [0] ) == COMLINK_MSG_PING_ACK && SUCCEEDED ( t_Operation.GetStatus () ) ) 
                    {
                // looks good so far. Get the return code

                    }
                    else if ( m_WriteQueue.GetRequestStatus ( t_EventContainer [0] ) == COMLINK_MSG_RETURN_FATAL_ERROR )
                    {
            // this occures only if the server is out of resources, in that
            // case we dont want to send additional request.
            // ============================================================

                        t_Result = WBEM_E_PROVIDER_FAILURE;
                    }
                    else 
                    {
                        t_Result = WBEM_E_TRANSPORT_FAILURE;
                    }
                }
                break ;

                default:
                {
                    t_Result = WBEM_E_TRANSPORT_FAILURE;
                }
                break ;
            }
        }
        else
        {
            t_Result = WBEM_E_TRANSPORT_FAILURE ;
        }

        // All done, give up the slot and return.

        m_WriteQueue.DeallocateRequest ( t_EventContainer [ 0 ] ) ;

    }

    return t_Result ;
}

//***************************************************************************
//
//  DWORD CComLink::Ping
//
//  DESCRIPTION:
//
//  Sends a simple message and waits for a simple ack.  This is used as a
//  "heart beat" test.
//
//  PARAMETERS:
//
//  hTerm1              First event handle that can be used to stop this call
//  hTerm2              second event handle that can be used to stop this call
//
//  RETURN VALUE:
//
//  S_OK                no error,
//  else set by SendAndWaitSimple
//
//***************************************************************************

DWORD CComLink_Tcpip :: StrobeConnection ()
{
    HRESULT t_Result ;

    ISecurityHelper t_Helper ;

    COperation_LPipe_Strobe t_Operation  ;

    HANDLE t_EventContainer [ 1 ] ;

    t_EventContainer [ 0 ] = m_WriteQueue.AllocateRequest ( t_Operation ) ;
    if ( ! t_EventContainer [ 0 ] ) 
    {
        t_Result = WBEM_E_OUT_OF_MEMORY ;
    }
    else
    {
        ResetEvent ( t_EventContainer [ 0 ] ) ;
    
        ISecurityHelper t_Helper ;
        CTransportStream t_WriteStream ;

        bool t_Status = t_Operation.EncodeRequest ( t_WriteStream , t_Helper ) ;
        if ( t_Status ) 
        {
            Transmit ( t_WriteStream ) ;
        }

        // All done, give up the slot and return.

        m_WriteQueue.DeallocateRequest ( t_EventContainer [ 0 ] ) ;
    }

    return t_Result ;
}

DWORD CComLink_Tcpip :: Shutdown ()
{
    HRESULT t_Result ;

    ISecurityHelper t_Helper ;

    COperation_LPipe_Shutdown t_Operation  ;

    HANDLE t_EventContainer [ 1 ] ;

    t_EventContainer [ 0 ] = m_WriteQueue.AllocateRequest ( t_Operation ) ;
    if ( ! t_EventContainer [ 0 ] ) 
    {
        t_Result = WBEM_E_OUT_OF_MEMORY ;
    }
    else
    {
        ResetEvent ( t_EventContainer [ 0 ] ) ;
    
        ISecurityHelper t_Helper ;
        CTransportStream t_WriteStream ;

        bool t_Status = t_Operation.EncodeRequest ( t_WriteStream , t_Helper ) ;
        if ( t_Status ) 
        {
            Transmit ( t_WriteStream ) ;
        }

        m_WriteQueue.DeallocateRequest ( t_EventContainer [ 0 ] ) ;
    }

    DropLink () ;

    return t_Result ;
}

DWORD CComLink_Tcpip :: HandleCall ( IN IOperation &a_Operation )
{
    a_Operation.HandleCall ( *this ) ;

    ISecurityHelper t_Helper ;
    CTransportStream t_WriteStream ;

    bool t_Status = a_Operation.EncodeResponse ( t_WriteStream , t_Helper ) ;
    if ( t_Status ) 
    {
        Transmit ( t_WriteStream ) ;
    }
    else
    {
    }

    m_ReadQueue.DeallocateRequest ( m_ReadQueue.GetHandle ( a_Operation.GetRequestId () ) ) ;

    HRESULT t_Result = a_Operation.GetStatus () ;

    IOperation *t_Operation = & a_Operation ;

    delete t_Operation ;

    return t_Result ;
}

CObjectSinkProxy* CComLink_Tcpip::CreateObjectSinkProxy (IN IStubAddress& stubAddr,
                                                         IN IWbemServices* pServices)
{
    return new CObjectSinkProxy_LPipe (this, stubAddr, pServices);
}

void CComLink_Tcpip :: DropLink ()
{
    EnterCriticalSection(&m_cs);

    ReleaseStubs () ;

    LeaveCriticalSection(&m_cs);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\thrdpool.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    THRDPOOL.H

Abstract:

	Declares the CThrdPool class.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _thrdpool_H_
#define _thrdpool_H_

#define MAX_IDLE_THREADS 3

class CComLink;

//***************************************************************************
//
//  STRUCT NAME:
//
//  WorkerThreadArgs
//
//  DESCRIPTION:
//
//  Arguments necessary to start up a worker thread.
//
//***************************************************************************

// This structure defines each of the threads/requests

enum EventType {

	START = 0 ,					// Just to clarify that Event Container Index begins at 0
	TERMINATE , 
	READY_TO_REPLY, 
	DONE
};

class CThrdPool;

class WorkerThreadArgs
{
public:

    HANDLE m_Events [DONE+1] ;		// Events Indicating START,READY_TO_REPLY,DONE and TERMINATE
    HANDLE m_ThreadHandle ;			// Thread Handle 
    DWORD m_ThreadId ;				// Thread Identifier
    CThrdPool *m_ThreadPool ;		// Containing Thread Pool

    CComLink *m_ComLink ;			// ComLink to HandleCall
	IOperation *m_Operation ;		// Operation associated with Call.
} ;

//***************************************************************************
//
//  CLASS NAME:
//
//  CThrdPool
//
//  DESCRIPTION:
//
//  provides a pool of threads to handle calls.
//
//***************************************************************************

class CThrdPool 
{
public:

	CThrdPool () ;

	~CThrdPool () ;

	void Free () ;					// Remove all worker threads

	BOOL Execute (

		CComLink &a_ComLink , 
		IOperation &a_Operation

	) ;								// Execute Stub call

	void PruneIdleThread ();		// Remove unused threads

	BOOL Busy () ;					// Check to see if we can close down all threads.

	BOOL Replying  () ;				// Set Worker Thread to indicate that Stub 
									// has completed call and is going to send
									// back results.

private:

	WorkerThreadArgs *Add () ;		// Add worker thread

	CFlexArray m_ThreadContainer ;	// Array of Worker threads

    CRITICAL_SECTION m_cs;

#if 0
	HANDLE m_Mutex;				// Access Control
#endif
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\transtrm.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    TRANSTRM.CPP

Abstract:

    CTransportStream implementation.

    This is a generic data stream for object/interface marshaling.

History:

    a-raymcc    10-Apr-96   Created.
    a-raymcc    06-Jun-96   CArena support.
    a-raymcc    11-Sep-96   Support NULL pointers

--*/

#include "precomp.h"
#include "wmishared.h"
#include <stdio.h>
#include <string.h>
#ifdef TCPIP_MARSHALER
#include <winsock.h>
#endif
#include <strm.h>
#include <transtrm.h>

//***************************************************************************
//
//  CTransportStream::CTransportStream
//
//  Standard constructor.
//
//  PARAMETERS:
//  nFlags
//      auto_delete or no_delete.  If auto_delete, the internal buffer
//      is automatically deallocated at destruct-time.  If no_delete,
//      it is assumed that another object has acquired the m_pBuffer
//      pointer and will deallocate it with m_pArena->Free().
//  pArena
//      The arena to use for allocation/deallocation.  If NULL, the
//      CWin32DefaultArena is used.
//  nInitialSize
//      The initial size of the stream in bytes.
//  nGrowBy
//      How much to grow the internal buffer by when the caller has written
//      past the end-of-stream.
//
//***************************************************************************
// ok
CTransportStream::CTransportStream(
    int nFlags,
    CArena *pArena,
    int nInitialSize,
    int nGrowBy

) : CMemStream ( nFlags,pArena,nInitialSize,nGrowBy)
{
}

//***************************************************************************
//
//  CTransportStream::CTransportStream
//
//  Binding constructor.
//
//***************************************************************************
// ok
CTransportStream::CTransportStream(
    LPVOID pBindingAddress,
    CArena *pArena,
    int nFlags,
    int nGrowBy

) : CMemStream (pBindingAddress,pArena,nFlags,nGrowBy)
{
}

//***************************************************************************
//
//  CTransportStream::CTransportStream
//
//  Copy constructor.
//
//***************************************************************************
// ok
CTransportStream::CTransportStream(CTransportStream &Src) : CMemStream ( Src )
{
}

CTransportStream::~CTransportStream()
{
}

//***************************************************************************
//
//  CTransportStream::operator =
//
//  Note that the arena is not copied as part of the assignment.  This
//  is to allow transfer of objects between arenas.
//
//***************************************************************************
// ok
CTransportStream& CTransportStream::operator =(CTransportStream &Src)
{
    CMemStream :: operator= ( Src ) ;
    return *this;
}

#ifdef TCPIP_MARSHALER
//***************************************************************************
//
//  CTransportStream::Deserialize
//
//  This function deserializes a stream from a Win32 file handle.
//  This function only works for files (including memory mapped files, etc.)
/// and pipes.  It will not work for mailslots since they must be read
//  in one operation.
//
//  PARAMETERS:
//  hFile
//      The Win32 file handle.
//
//  RETURN VALUES:
//  failed, out_of_memory, no_error
//
//***************************************************************************
// ok
int CTransportStream::Deserialize(SOCKET a_Socket,DWORD a_Timeout)
{
    Reset();    

    // Read the header.  Note that we read this separately
    // first before the stream proper.  This is because we
    // don't know how much memory to allocate until we have
    // read the header.
    // ====================================================

    STREAM_HEADER &hdr = *(STREAM_HEADER *) m_pBuffer;
    BOOL bRes;
    DWORD dwRead;

    fd_set t_fdset ;
    FD_ZERO ( & t_fdset ) ;
    FD_SET ( a_Socket , & t_fdset ) ;
    
    timeval t_Timeval ;
    ULONG t_Seconds = a_Timeout / 1000 ;
    ULONG t_Microseconds = ( a_Timeout - ( t_Seconds * 1000 ) ) * 1000 ;
    t_Timeval.tv_sec = t_Seconds ;
    t_Timeval.tv_usec = t_Microseconds ;

    int t_Number = select ( 1 , & t_fdset , NULL , NULL , & t_Timeval ) ;
    if ( t_Number == 0 )
    {
        return timeout ;
    }

    dwRead = recv(a_Socket, (char*) &hdr, sizeof(hdr), 0);
    if (dwRead == SOCKET_ERROR)
    {
        DWORD t_LastError = GetLastError () ;
        return failed;
    }

    if(dwRead == 0)
    {
        return end_of_stream ;
    }

    if (!hdr.Verify())
        return failed;

    DWORD t_ReadLength = hdr.dwLength;

    // Read the rest.
    // ===============
    if (Resize(hdr.dwLength))
        return out_of_memory;

    BYTE *t_ReadPosition = m_pBuffer + sizeof ( hdr ) ;
    DWORD t_Remainder = m_dwSize - dwRead ;

    while ( t_Remainder )
    {
        int t_Number = select ( 1 , & t_fdset , NULL , NULL , & t_Timeval ) ;
        if ( t_Number == 0 )
        {
            return timeout ;
        }

        dwRead = recv(a_Socket, (char*) t_ReadPosition , t_Remainder, 0);
        if (dwRead == SOCKET_ERROR)
        {
            DWORD t_LastError = GetLastError () ;
            return failed;
        }

        if(dwRead == 0)
        {
            return end_of_stream ;
        }

        t_Remainder = t_Remainder - dwRead ;
        t_ReadPosition = t_ReadPosition + dwRead ;
    }

    m_dwEndOfStream = t_ReadLength;

    return no_error;
}

//***************************************************************************
//
//  CTransportStream::Serialize
//
//  Writes the object to a Win32 file.
//
//  PARAMETERS:
//  hFile
//      The Win32 file handle to which to write the object.
//
//  RETURN VALUES:
//  failed, no_error
//
//***************************************************************************
// ok
int CTransportStream::Serialize(SOCKET a_Socket)
{
    UpdateHdr();
    
    // Write body of stream.  This includes the header.
    // ================================================

    DWORD dwWritten = 0;
    dwWritten = send(a_Socket, (char*) m_pBuffer, m_dwEndOfStream, 0);
    if (dwWritten== SOCKET_ERROR)
        return failed;

    return no_error;
}

#endif // TCPIP_MARSHALER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\transtrm.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    TRANSTRM.CPP

Abstract:

    CTransportStream implementation for WBEM.

    This is a thread-safe generic data stream which can be used
    with memory objects, pipes, mailslots, or files.  This is the basic
    object for interface & call marshaling.

    Supported types:
      VT_NULL

      VT_UI1, VT_I1, VT_UI2, VT_I2, VT_UI4, VT_I4, VT_I8, VT_UI8
      VT_R4, VT_R8, VT_BOOL

      VT_LPSTR, VT_LPWSTR, VT_BSTR

      VT_CLSID, VT_UNKNOWN, VT_FILETIME, VT_ERROR, VT_BLOB, VT_PTR

      VT_EMPTY = End of stream

      VT_USERDEFINED      
          VT_EX_VAR
          VT_EX_VARVECTOR

History:

    a-raymcc    10-Apr-96   Created.
    a-raymcc    06-Jun-96   CArena support.
    a-raymcc    11-Sep-96   Support NULL pointers

--*/

#ifndef _TRANSPORTSTRM_H_
#define _TRANSPORTSTRM_H_
#include "corepol.h"

#include <arena.h>
#include <var.h>
#include <wbemutil.h>
#include <strm.h>

class CTransportStream : public CMemStream
{
public:
    
    CTransportStream(
        int nFlags = auto_delete, 
        CArena *pArena = 0,
        int nInitialSize = 512, 
        int nGrowBy = 512
        );

    CTransportStream(
        LPVOID pBindingAddress,
        CArena *pArena,
        int nFlags = auto_delete, 
        int nGrowBy = 512
        );
        
    CTransportStream(CTransportStream &Src);
    CTransportStream &operator =(CTransportStream &Src);
   ~CTransportStream();
        // Releases the arena

#ifdef TCPIP_MARSHALER
    int Deserialize(SOCKET a_Socket, DWORD a_Timeout);
    int Serialize(SOCKET a_Socket);
#endif
};
                            
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\tranutil.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    TRANUTIL.CPP

Abstract:

    General transport specific utilities.

History:

    a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include "wmishared.h"

//***************************************************************************
//
//  CWbemObject * CreateClassObject
//
//  DESCRIPTION:
//
//  Creates a class object.
//
//  PARAMETERS:
//
//  pRead               Memory stream to deserialize the object from
//
//  RETURN VALUE:
//
//  New object, NULL if error.
//
//***************************************************************************

CWbemObject * CreateClassObject(
                        IN CTransportStream * pread)
{

    CWbemObject * pNew = CWbemObject::CreateFromStream(pread);
    if(pNew == NULL)
        return NULL;
    return pNew;

}


//***************************************************************************
//
//  BOOL FinishCommandPacket
//
//  DESCRIPTION:
//
//  Does the cleanup at the end of processing a call.
//
//  PARAMETERS:
//
//  pCom                comlink object to use in order to send results
//  pRead               stream of data set to us
//  pWrite              stream to of data to send back
//  guidPacketID        ID of this transaction
//  hWrite              handle to use for writting data
//
//  RETURN VALUE:
//
//  TRUE if it worked.
//
//***************************************************************************

BOOL FinishCommandPacket(
                        IN CComLink * pCom,
                        IN CTransportStream * pRead,
                        IN CTransportStream * pWrite, 
                        IN GUID guidPacketID, 
                        IN HANDLE hWrite)
{
    return TRUE;
}


//***************************************************************************
//
//  BOOL bOkToUseDCOM
//
//  DESCRIPTION:
//  
//  Checks if DCOM is installed and dcom was around when setup was run.
//
//  RETURN VALUE:
//
//  TRUE if DCOM should be tried
//
//***************************************************************************

BOOL bOkToUseDCOM()
{

    // first check if DCOM Ole dlls are installed.

    if(!IsDcomEnabled())
        return FALSE;

    // for the win95/win98 case, dcom requires tcpip

    if(!IsNT())
    {
        TCHAR * pData;
        Registry r(__TEXT("software\\microsoft\\rpc\\clientprotocols"));
        int iRet = r.GetStr(__TEXT("ncacn_ip_tcp"), &pData);
        if(iRet != 0)
            return FALSE;
        delete pData;
    }
    return TRUE;

}

//***************************************************************************
//
//  void GetMyProtocols
//
//  DESCRIPTION:
//
//  Gets the list of available protocols.
//  
//  PARAMETERS:
//
//  wcMyProtocols       Filled in with the list.
//  bLocal              Indicates if connection is local.
//
//***************************************************************************

void GetMyProtocols(
                        OUT WCHAR * wcMyProtocols, 
                        IN BOOL bLocal)
{
    wcMyProtocols[0] = NULL;

    if(bLocal)
    {
        wcscat(wcMyProtocols,L"A");    // anon pipes are always available
        if(bOkToUseDCOM())
            wcscat(wcMyProtocols,L"D");
    }
    else
    {
    }
    return;
}



//***************************************************************************
//
//  DWORD GetTimeout
//
//  DESCRIPTION:
//
//  Returns the default timeout period.
//
//***************************************************************************

DWORD GetTimeout()
{
    DWORD dwTimeout;
    Registry r(WBEM_REG_WINMGMT);
    DWORD dwRet = r.GetDWORDStr(__TEXT("TimeOutMs"),&dwTimeout);
    if(dwRet != Registry::no_error)
        dwTimeout = TIMEOUT_IN_MS;   // use #define if not in registry
    else
    {
        if ( dwTimeout < TIMEOUT_IN_MS ) 
        {
            dwTimeout = MIN_TIMEOUT_IN_MS ;
        }
    }

    return dwTimeout;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\utils.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    UTILS.H

Abstract:

	Declares some general utilities.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _utils_H_
#define _utils_H_

// These defines and includes allow the use of the MFX character routines
// without having to use MFC
// ======================================================================

#ifdef UNICODE
	inline LPOLESTR T2OLE(LPTSTR lp) { return lp; }
	inline LPTSTR OLE2T(LPOLESTR lp) { return lp; }
#else
	#define T2OLE(lpa) A2W(lpa)
	#define OLE2T(lpo) W2A(lpo)
#endif

#ifndef _DEBUG
#define USES_CONVERSION int _convert; _convert
#else
#define USES_CONVERSION int _convert = 0;
#endif

LPWSTR A2WHelper(LPWSTR lpw, LPCSTR lpa, int nChars);
LPSTR  W2AHelper(LPSTR lpa, LPCWSTR lpw, int nChars);


#define A2W(lpa) (\
	((LPCSTR)lpa == NULL) ? NULL : (\
		_convert = (strlen(lpa)+1),\
		A2WHelper((LPWSTR) alloca(_convert*2), lpa, _convert)\
	)\
)

#define W2A(lpw) (\
	((LPCWSTR)lpw == NULL) ? NULL : (\
		_convert = (wcslen(lpw)+1)*2,\
		W2AHelper((LPSTR) alloca(_convert), lpw, _convert)\
	)\
)

BOOL bVerifyPointer(PVOID pTest);
void MyCoUninitialize();

#define IsSlash(x) (x == L'\\' || x== L'/')

#endif

// These codes used to be defined in wbemcli.IDL.  They are 
// now private to the custom marshalers so we have moved them here.
#define	WBEM_S_PRELOGIN	0x50001
#define WBEM_S_LOGIN	0x50002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\utils.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    UTILS.CPP

Abstract:

    Purpose: Defines various utilities.

History:

    a-davj    14-Aug-96   Created.

--*/

#include "precomp.h"
#include "wmishared.h"

extern bool bServer;


//***************************************************************************
//
//  LPWSTR A2WHelper
//
//  DESCRIPTION:
//
//  used by the A2W and W2A routines which serve to emulate the 
//  MFC character conversion macros.
//
//  PARAMETERS:
//
//  lpw                 pointer to wide character string
//  lpa                 pointer to narrow string
//  nChars              max size of wide character array
//
//  RETURN VALUE:
//
//  poinnter to wide character array, or NULL if bogus arguments
//
//***************************************************************************

LPWSTR A2WHelper(
                        OUT LPWSTR lpw,
                        IN LPCSTR lpa,
                        IN int nChars)
{
    if (lpa == NULL || lpw == NULL)
        return NULL;
    mbstowcs(lpw,lpa,nChars);
    return lpw;
}

//***************************************************************************
//
//  LPSTR W2AHelper
//
//  DESCRIPTION:
//
//  used by the A2W and W2A routines which serve to emulate the 
//  MFC character conversion macros.
//
//  PARAMETERS:
//
//  lpa                 mbs string
//  lpw                 wide character string
//  nChars              max conversion size
//
//  RETURN VALUE:
//
//  pointer to narrow string, or NULL if bogus arguments.
//
//***************************************************************************

LPSTR W2AHelper(
                        IN LPSTR lpa,
                        IN LPCWSTR lpw,
                        IN int nChars)
{
    if (lpw == NULL || lpa == NULL)
        return NULL;
    wcstombs(lpa,lpw,nChars);
    return lpa;
}


//***************************************************************************
//
//  BOOL bVerifyPointer
//
//  DESCRIPTION:
//
//  Simple utility for verifying that an ole object pointer is valid.
//  THIS INCREASES THE OBJECT'S REFERENCE COUNT.
//
//  PARAMETERS:
//
//  pTest               Object to test
//
//  RETURN VALUE:
//
//  TRUE if object is OK.
//***************************************************************************

BOOL bVerifyPointer(
                        IN PVOID pTest)
{
    PVOID pTemp = NULL;
    IUnknown * pIUnknown = (IUnknown *)pTest;
    SCODE sc;
    if(pTest == NULL)
        return FALSE;

    // Do a QI to verify that the object is OK and to bump the
    // reference count if it is.

    sc = pIUnknown->QueryInterface(IID_IUnknown, &pTemp);
    if(sc != S_OK || pTemp == NULL)
    {
        delete pTest;
        return FALSE;
    }
    return TRUE;
}


void MyCoUninitialize()
{
    if(IsNT() && bServer)
        CoUninitialize();
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\tranutil.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    TRANUTIL.H

Abstract:

	Declares some generic transport utilities.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _tranutil_H_
#define _tranutil_H_

#include <fastobj.h>

CWbemObject * CreateClassObject(CTransportStream * pread);
void PossibleCreateResultObject(DWORD dwRet, CTransportStream * pread , IWbemCallResult ** ppResult);

#define INIT_RES_OBJ(pObj) if(pObj) *pObj=NULL;

BOOL FinishCommandPacket(CComLink * pCom,CTransportStream * pRead,CTransportStream * pWrite, GUID guidPacketID, HANDLE hWrite = NULL);

BOOL bOkToUseDCOM();

#define MAJORVERSION           1
#define MINORVERSION           1
void GetMyProtocols(WCHAR * wcMyProtocols, BOOL bLocal);

DWORD GetTimeout();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\shared\wmishared.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PROVSTUB.H

Abstract:

  Master include file

History:

  a-davj  04-Mar-97   Created.

--*/
extern DWORD LOG;
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <assert.h>
#include <time.h>
#include <wbemidl.h>        
#include <wbemcomn.h>
#include <transtrm.h>
#include <cominit.H>
#include <stubaddr.h>
#include <stbaddcm.h>
#include <linklist.h>
#include <winsock.h>
#include <comlink.h>
#include <secfilt.h>
#include <iopn.h>
#include <thrdpool.h>
#include <package.h>
#include <maintobj.h>
#include <utils.h>
#include <pipeopn.h>
#include <cproxy.h>
#include "pipesnkp.h"
#include "pipestbo.h"
#include <tranutil.h>
#include <genutils.h>
#include "..\\stub\\wbemstub.h"
extern MaintObj gMaintObj;
extern CThrdPool gThrdPool;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\stub\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\stub\cftransp.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CFTRANSP.CPP

Abstract:

    Declares the CPipeMarshalerClassFactory class.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _CPipeMarshalerClassFactory_H_
#define _CPipeMarshalerClassFactory_H_

//***************************************************************************
//
// CLASS NAME:
//
// CPipeMarshalerClassFactory 
//
// DESCRIPTION:
//
// Class factory for the CTransp class.  Note that this is virtual base class
// so that the actually created class can be something specific such as 
// a mailslot transport.
//***************************************************************************

class CPipeMarshalerClassFactory : public IClassFactory
{
protected:

	ULONG           m_cRef;

public:

	CPipeMarshalerClassFactory () ;
    ~CPipeMarshalerClassFactory () ;

//IUnknown members

	STDMETHODIMP         QueryInterface ( REFIID , PPVOID ) ;
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void) ;

//IClassFactory members

    STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID , PPVOID);

	STDMETHODIMP         LockServer(BOOL);
} ;

#ifdef TCPIP_MARSHALER

//***************************************************************************
//
// CLASS NAME:
//
// CTcpipMarshalerClassFactory 
//
// DESCRIPTION:
//
// Class factory for the CTransp class.  Note that this is virtual base class
// so that the actually created class can be something specific such as 
// a mailslot transport.
//***************************************************************************

class CTcpipMarshalerClassFactory : public IClassFactory
{
protected:

	ULONG           m_cRef;

public:

	CTcpipMarshalerClassFactory () ;
    ~CTcpipMarshalerClassFactory () ;

//IUnknown members

	STDMETHODIMP         QueryInterface ( REFIID , PPVOID ) ;
    STDMETHODIMP_(ULONG) AddRef(void) ;
    STDMETHODIMP_(ULONG) Release(void) ;

//IClassFactory members

    STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID , PPVOID);

	STDMETHODIMP         LockServer(BOOL);
} ;

#endif

#endif //_CPipeMarshalerClassFactory_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\stub\connpnt.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CONNPNT.H

Abstract:

    Declares the entry point for the thread that watches for new connections.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _connpnt_H_
#define _connpnt_H_


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\stub\connpnt.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CONNPNT.CPP

Abstract:

    Declarations for CInitStub class which implements a special
    stub whose only purpose is for establishing new connections.

History:

    a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include <anonpipe.h>
#ifdef TCPIP_MARSHALER
#include <tcpip.h>
#endif
#include <cominit.h>

#define SAFE_DELETE(px) if((px) != NULL) delete (px);
#define SAFE_CLOSE(hx) if((hx) != NULL) CloseHandle(hx);

struct PipeSharedMemoryMessage
{
    DWORD m_Size ;
    CHAR m_Buffer [ 256 ] ;
} ;

HANDLE g_Mutex = NULL ;
HANDLE g_StartedEvent ;
HANDLE g_ReplyEvent = NULL ;
HANDLE g_RequestEvent = NULL ;
HANDLE g_SharedMemory = NULL ;
PipeSharedMemoryMessage *g_SharedMemoryBuffer = NULL ;

CComLink *CreateAnonPipe (

    IN HANDLE & a_ClientRead ,
    IN HANDLE & a_ClientWrite ,
    IN HANDLE & a_ClientTerm ,
    IN DWORD a_ClientProcessID , 
    IN HRESULT *t_Result 
)
{
    CComLink *t_ComLink = NULL ;

    HANDLE t_ReadPipe1 =  NULL ;
    HANDLE t_WritePipe1 = NULL ;
    HANDLE t_ReadPipe2 =  NULL ;
    HANDLE t_WritePipe2 =  NULL ;

    HANDLE t_ClientProcess = NULL ;

    *t_Result = WBEM_E_OUT_OF_MEMORY;

    DEBUGTRACE((LOG,"\nCreateLocalConn was called, Client proc=0x%x", a_ClientProcessID));
        
    // create two pipes

    if ( CreatePipe ( & t_ReadPipe1 , & t_WritePipe1 , NULL , 0 ) )
    {
        if ( CreatePipe ( & t_ReadPipe2 , & t_WritePipe2 , NULL , 0 ) )
        {
            // get a handle to the other process using its ID

            t_ClientProcess = OpenProcess ( PROCESS_DUP_HANDLE , FALSE , a_ClientProcessID ) ;
            if ( t_ClientProcess == NULL )
            {
                CloseHandle ( t_ReadPipe1 ) ;
                CloseHandle ( t_WritePipe1 ) ;
                CloseHandle ( t_ReadPipe2 ) ;
                CloseHandle ( t_WritePipe2 ) ;

                DEBUGTRACE((LOG,"\nCreateLocalConn failed calling OpenProcess, last error=0x%x",GetLastError()));
            }
            else
            {
                // duplicate a read handle from one pipe and the write handle from
                // the other

                DEBUGTRACE((LOG,"\nCreateLocal is about to duplicate handles"));

                HANDLE t_Process = GetCurrentProcess () ;

                BOOL t_Status = DuplicateHandle ( 

                    t_Process ,
                    t_ReadPipe1 ,
                    t_ClientProcess ,
                    & a_ClientRead ,
                    0 ,
                    FALSE ,
                    DUPLICATE_SAME_ACCESS
                ) ;

                if ( ! t_Status )
                {
                    CloseHandle ( t_ReadPipe1 ) ;
                    CloseHandle ( t_WritePipe1 ) ;
                    CloseHandle ( t_ReadPipe2 ) ;
                    CloseHandle ( t_WritePipe2 ) ;
                    CloseHandle ( t_ClientProcess ) ;
                }
                else
                {
                    t_Status = DuplicateHandle (

                        t_Process , 
                        t_WritePipe2 ,
                        t_ClientProcess ,
                        & a_ClientWrite,
                        0 ,
                        FALSE ,
                        DUPLICATE_SAME_ACCESS
                    ) ;

                    if ( ! t_Status ) 
                    {
                        CloseHandle ( t_ReadPipe1 ) ;
                        CloseHandle ( t_WritePipe1 ) ;
                        CloseHandle ( t_ReadPipe2 ) ;
                        CloseHandle ( t_WritePipe2 ) ;
                        CloseHandle ( a_ClientRead ) ;
                        CloseHandle ( t_ClientProcess ) ;
                    }
                    else
                    {
                        t_Status = DuplicateHandle (

                            t_Process ,
                            t_WritePipe1 ,
                            t_ClientProcess ,
                            & a_ClientTerm ,
                            0 ,
                            FALSE ,
                            DUPLICATE_SAME_ACCESS
                        ) ;

                        if ( ! t_Status )
                        {
                            CloseHandle ( t_ReadPipe1 ) ;
                            CloseHandle ( t_WritePipe1 ) ;
                            CloseHandle ( t_ReadPipe2 ) ;
                            CloseHandle ( t_WritePipe2 ) ;
                            CloseHandle ( a_ClientRead ) ;
                            CloseHandle ( a_ClientWrite ) ;
                            CloseHandle ( t_ClientProcess ) ;
                        }
                        else
                        {

                        // allocate a new CComLink object

                            t_ComLink = new CComLink_LPipe ( NORMALSERVER , t_ReadPipe2, t_WritePipe1, t_WritePipe2); 
                            if ( t_ComLink == NULL )
                            {
                                CloseHandle ( t_ReadPipe1 ) ;
                                CloseHandle ( t_WritePipe1 ) ;
                                CloseHandle ( t_ReadPipe2 ) ;
                                CloseHandle ( t_WritePipe2 ) ;
                                CloseHandle ( a_ClientRead ) ;
                                CloseHandle ( a_ClientWrite ) ;
                                CloseHandle ( a_ClientTerm ) ;
                                CloseHandle ( t_ClientProcess ) ;
                            }
                            else
                            {
                                DEBUGTRACE((LOG,"\nCreateLocal created a pipe with addr of 0x%x",t_ComLink ));

                                CloseHandle ( t_ReadPipe1 ) ;    
                                CloseHandle ( t_ClientProcess ) ;    // dont need this anymore.
            
                                *t_Result = S_OK ;
                            }
                        }
                    }
                }
            }
        }
        else
        {
            CloseHandle ( t_ReadPipe1 ) ;
            CloseHandle ( t_WritePipe1 ) ;
        }
    }
    else
    {   
    }

    return t_ComLink ;
}

void InitialiseConnection (

    CTransportStream *a_Read , 
    CTransportStream *a_Write
)
{
    HRESULT t_Result ;

    DWORD t_ReadStreamStatus = CTransportStream::no_error;
    DWORD t_WriteStreamStatus = CTransportStream::no_error;
    
    // Read the rest of the connection type arguments.
    // Get the initial arguments that are present for all calls.

    DWORD t_ClientProcessID = 0 ;
    
    t_ReadStreamStatus |= a_Read->ReadDWORD ( &t_ClientProcessID ) ;

    if ( t_ReadStreamStatus != CTransportStream::no_error )
    {
        DEBUGTRACE((LOG,"\nCInitStub::InitConnection had failure reading stream."));

        t_Result = WBEM_E_INVALID_STREAM;

        t_WriteStreamStatus |= a_Write->WriteDWORD ( t_Result ) ;
        t_WriteStreamStatus |= a_Write->WriteDWORD ( 0 ) ;
    }
    else
    {   
        // Get an instance of CLSID_WbemLevel1Login.  This is supplied by
        // WINMGMT.exe and is a thin wrapper to the core's inproc level1login.

        DEBUGTRACE((LOG,"\nCInitStub::HandleCall about to call CoCreateInstance"));

        CServerLogin *t_Login = new CServerLogin ;

        if ( t_Login == NULL )
        {
            t_WriteStreamStatus |= a_Write->WriteDWORD ( WBEM_E_OUT_OF_MEMORY ) ;
            t_WriteStreamStatus |= a_Write->WriteDWORD ( 0 ) ;

            DEBUGTRACE((LOG,"\nfailed calling locator RequestLogin, sc = %x",WBEM_E_OUT_OF_MEMORY));
        }
        else
        {
            // setup the output stream as successful and write the provider address
 
            t_WriteStreamStatus |= a_Write->WriteDWORD ( WBEM_NO_ERROR ) ;
            t_WriteStreamStatus |= a_Write->WriteDWORD ( ( DWORD ) t_Login ) ;

            // Create an appropriate transport object

            HANDLE t_ClientRead = NULL;
            HANDLE t_ClientWrite = NULL;
            HANDLE t_ClientTerm = NULL;

            CComLink *t_ComLink = CreateAnonPipe ( t_ClientRead , t_ClientWrite , t_ClientTerm, t_ClientProcessID, &t_Result ) ;
            if ( t_ComLink )
            {
                a_Write->WriteDWORD ( ( DWORD ) t_ClientRead ) ;
                a_Write->WriteDWORD ( ( DWORD ) t_ClientWrite ) ;
                a_Write->WriteDWORD ( ( DWORD ) t_ClientTerm ) ;

                // Set the ref count for the new comlink and and the service to its
                // list of objects.

                t_ComLink->AddRef2 ( t_Login , LOGIN , RELEASEIT ) ;

                t_ComLink->Release2 ( NULL , NONE ) ;  // balances the initial count of 1

                // Send back response including stub, handles etc

                DEBUGTRACE((LOG,"\nCInitStub::HandleCall has hooked up with wbemcore, no error!"));
            }
            else
            {
                if ( t_Login )
                {
                    t_Login->Release();
                }

                a_Write->Reset();

                a_Write->WriteDWORD ( t_Result ) ;
                a_Write->WriteDWORD ( 0 ) ;          // no error object if here
            }
        }
    }
}

void ServiceLocalConnectionRequest ()
{
    CTransportStream t_Read ;
    CTransportStream t_Write ;

    t_Read.CMemStream :: Deserialize ( ( BYTE * ) g_SharedMemoryBuffer->m_Buffer , g_SharedMemoryBuffer->m_Size ) ; 

    InitialiseConnection ( & t_Read, & t_Write ) ;

    BYTE *t_Buffer = NULL ;
    DWORD t_Size = 0 ;

    t_Write.CMemStream :: Serialize ( &t_Buffer , &t_Size ) ; 

    g_SharedMemoryBuffer->m_Size = t_Size ;
    memcpy ( g_SharedMemoryBuffer->m_Buffer , t_Buffer , t_Size ) ;

    HeapFree ( GetProcessHeap () , 0 , t_Buffer ) ;

    ResetEvent ( g_RequestEvent ) ;
    SetEvent( g_ReplyEvent ) ;
}

void PipeWaitingFunction ( HANDLE a_Terminate )
{
    DEBUGTRACE((LOG_WINMGMT,"\nInside the waiting function"));

    HANDLE hArray[2];
    hArray[0] = a_Terminate;
    hArray[1] = g_RequestEvent ;

    while(1)
    {
        DWORD dwObj = WbemWaitForMultipleObjects(2, hArray, INFINITE);
        if(dwObj == 0)      // bail out for terminate event
        {
            DEBUGTRACE((LOG_WINMGMT,"\nGot a termination event"));
            break;
        }
        if(dwObj == WAIT_OBJECT_0 + 1)
        {
            DEBUGTRACE((LOG_WINMGMT,"\nGot a request event"));

            ServiceLocalConnectionRequest () ;
        }
    }
}

DWORD LaunchPipeConnectionThread ( HANDLE a_Parameter )
{
    InitializeCom () ;

    HANDLE t_Terminate = ( HANDLE ) a_Parameter ;
    PipeWaitingFunction ( t_Terminate ) ;
    
    MyCoUninitialize () ;

    return 0 ;
}

HRESULT CreateSharedMemory ()
{
    g_StartedEvent = CreateEvent (NULL , TRUE , FALSE , __TEXT("WBEM_PIPEMARSHALER_STARTED" ) );
    if ( ! g_StartedEvent ) 
    {
        return WBEM_E_FAILED ;
    }

    if ( GetLastError () != ERROR_ALREADY_EXISTS ) 
    {
        SetObjectAccess ( g_StartedEvent ) ;
    }

    g_RequestEvent = CreateEvent (NULL , TRUE , FALSE , __TEXT("WBEM_PIPEMARSHALER_EEQUESTISREADY" )) ;
    if ( ! g_RequestEvent ) 
    {
        CloseHandle ( g_StartedEvent ) ;

        g_StartedEvent = NULL ;

        return WBEM_E_FAILED ;
    }

    SetObjectAccess ( g_RequestEvent ) ;

    g_ReplyEvent = CreateEvent (NULL , TRUE , FALSE , __TEXT("WBEM_PIPEMARSHALER_REPLYISREADY" ) );
    if ( ! g_ReplyEvent ) 
    {
        CloseHandle ( g_StartedEvent ) ;
        CloseHandle ( g_RequestEvent ) ;

        g_StartedEvent = NULL ;
        g_ReplyEvent = NULL ;

        return WBEM_E_FAILED ;
    }

    SetObjectAccess ( g_ReplyEvent ) ;

    g_Mutex = CreateMutex ( NULL , FALSE , __TEXT("WBEM_PIPEMARSHALER_MUTUALEXCLUSION" ) );
    if ( ! g_Mutex ) 
    {
        CloseHandle ( g_StartedEvent ) ;
        CloseHandle ( g_ReplyEvent ) ;
        CloseHandle ( g_RequestEvent ) ;

        g_StartedEvent = NULL ;
        g_ReplyEvent = NULL ;
        g_RequestEvent = NULL ;

        return WBEM_E_FAILED ;
    }

    SetObjectAccess ( g_Mutex ) ;

    g_SharedMemory = CreateFileMapping (

        ( HANDLE ) -1, 
        NULL, 
        PAGE_READWRITE,
        0, 
        sizeof ( PipeSharedMemoryMessage ) , 
        __TEXT("WBEM_PIPEMARSHALER_SHAREDMEMORY")
    );

    SetObjectAccess ( g_SharedMemory ) ;

    if ( ! g_SharedMemory ) 
    {
        CloseHandle ( g_Mutex ) ;
        CloseHandle ( g_StartedEvent ) ;
        CloseHandle ( g_ReplyEvent ) ;
        CloseHandle ( g_RequestEvent ) ;

        g_StartedEvent = NULL ;
        g_ReplyEvent = NULL ;
        g_RequestEvent = NULL ;
        g_Mutex = NULL ;

        return WBEM_E_FAILED ;
    }

    g_SharedMemoryBuffer = ( PipeSharedMemoryMessage * ) MapViewOfFile ( 

        g_SharedMemory , 
        FILE_MAP_WRITE , 
        0 , 
        0 , 
        0 
    ) ;

    if ( ! g_SharedMemoryBuffer )
    {
        CloseHandle ( g_Mutex ) ;
        CloseHandle ( g_StartedEvent ) ;
        CloseHandle ( g_ReplyEvent ) ;
        CloseHandle ( g_RequestEvent ) ;
        CloseHandle ( g_SharedMemory ) ;

        g_StartedEvent = NULL ;
        g_ReplyEvent = NULL ;
        g_RequestEvent = NULL ;
        g_Mutex = NULL ;
        g_SharedMemory = NULL ;

        return WBEM_E_FAILED ;
    }

    SetEvent ( g_StartedEvent ) ;
      
    return S_OK ;
}

void DestroySharedMemory ()
{
    CloseHandle ( g_Mutex ) ;
    CloseHandle ( g_StartedEvent ) ;
    CloseHandle ( g_ReplyEvent ) ;
    CloseHandle ( g_RequestEvent ) ;
    CloseHandle ( g_SharedMemory ) ;

    UnmapViewOfFile ( g_SharedMemoryBuffer ) ;

    g_StartedEvent = NULL ;
    g_ReplyEvent = NULL ;
    g_RequestEvent = NULL ;
    g_Mutex = NULL ;
    g_SharedMemory = NULL ;
}

#ifdef TCPIP_MARSHALER

void TcpipWaitingFunction ( HANDLE a_Terminate )
{
    DEBUGTRACE((LOG_WINMGMT,"\nInside the waiting function"));

    SOCKET t_Socket = socket (AF_INET, SOCK_STREAM, 0);
    if ( t_Socket != SOCKET_ERROR ) 
    {
        struct sockaddr_in t_LocalAddress ;
        t_LocalAddress .sin_family = AF_INET;
        t_LocalAddress.sin_port = htons (4000);
        t_LocalAddress.sin_addr.s_addr = ntohl (INADDR_ANY);

        int t_Status = bind ( t_Socket , ( sockaddr * ) &t_LocalAddress, sizeof(t_LocalAddress) ) ;
        if ( t_Status != SOCKET_ERROR ) 
        {
            t_Status = listen ( t_Socket , SOMAXCONN ) ;        
            if ( t_Status != SOCKET_ERROR ) 
            {
                struct sockaddr_in t_RemoteAddress ;
                int t_RemoteAddressLength = sizeof ( t_RemoteAddress ) ;

                while ( 1 )
                {

                    fd_set t_fdset ;
                    FD_ZERO ( & t_fdset ) ;
                    FD_SET ( t_Socket , & t_fdset ) ;
                    
                    timeval t_Timeval ;
                    ULONG t_Seconds = 30000 / 1000 ;
                    ULONG t_Microseconds = ( 30000 - ( t_Seconds * 1000 ) ) * 1000 ;
                    t_Timeval.tv_sec = t_Seconds ;
                    t_Timeval.tv_usec = t_Microseconds ;

                    int t_Number = select ( 1 , & t_fdset ,NULL , NULL , & t_Timeval ) ;
                    if ( t_Number == 0 )
                    {
                        DWORD t_Status = WbemWaitForMultipleObjects(1, &a_Terminate, 0);
                        if ( t_Status == WAIT_OBJECT_0 )    
                        {
                            break ;
                        }
                    }
                    else
                    {
                        SOCKET t_AcceptedSocket = accept ( t_Socket , ( sockaddr * ) & t_RemoteAddress, &t_RemoteAddressLength ) ;
                        if ( t_AcceptedSocket != SOCKET_ERROR ) 
                        {
                            DWORD t_WriteStreamStatus = CTransportStream::no_error;
                            CTransportStream t_WriteStream ;

                            CServerLogin *t_Login = new CServerLogin ;
                            if ( t_Login )
                            {
                                t_WriteStreamStatus |= t_WriteStream.WriteDWORD ( WBEM_NO_ERROR ) ;
                                t_WriteStreamStatus |= t_WriteStream.WriteDWORD ( ( DWORD ) t_Login ) ;

                                t_WriteStream.Serialize ( t_AcceptedSocket ) ;

                                CComLink *t_ComLink = new CComLink_Tcpip ( NORMALSERVER , t_AcceptedSocket ); 
                                if ( t_ComLink != NULL )
                                {
                                    t_ComLink->AddRef2 ( t_Login , LOGIN , RELEASEIT ) ;

                                    t_ComLink->Release2 ( NULL , NONE ) ;  // balances the initial count of 1
                                }
                            }
                            else
                            {
                                t_WriteStreamStatus |= t_WriteStream.WriteDWORD ( WBEM_E_INVALID_STREAM ) ;
                                t_WriteStreamStatus |= t_WriteStream.WriteDWORD ( 0 ) ;

                                t_WriteStream.Serialize ( t_AcceptedSocket ) ;

                                closesocket ( t_AcceptedSocket ) ;
                            }
                        }
                        else
                        {
                            DWORD t_Error = WSAGetLastError () ;
                            OutputDebugString ( "Accept Failure" ) ;
                            break ;
                        }
                    }
                }
            }
        }

        closesocket ( t_Socket ) ;
    }
}

DWORD LaunchTcpipConnectionThread ( HANDLE a_Parameter )
{
    InitializeCom () ;

    HANDLE t_Terminate = ( HANDLE ) a_Parameter ;   

    BOOL status = FALSE ;
    WORD wVersionRequested;  
    WSADATA wsaData; 

    wVersionRequested = MAKEWORD(1, 1); 
    status = ( WSAStartup ( wVersionRequested , &wsaData ) == 0 ) ;
    if ( status ) 
    {
        TcpipWaitingFunction ( t_Terminate ) ;
        WSACleanup () ;
    }

    MyCoUninitialize () ;

    return 0 ;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\stub\cftransp.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    CFTRANSP.CPP

Abstract:

    Defines the CPipeMarshalerClassFactory class which serves as the class factory for the 
	transport objects.

History:

	a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"

//***************************************************************************
//
//  CPipeMarshalerClassFactory::CPipeMarshalerClassFactory
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CPipeMarshalerClassFactory :: CPipeMarshalerClassFactory () : m_cRef ( 0 )
{
}

//***************************************************************************
//
//  CPipeMarshalerClassFactory::~CPipeMarshalerClassFactory
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CPipeMarshalerClassFactory :: ~CPipeMarshalerClassFactory ()
{
}

//***************************************************************************
// HRESULT CPipeMarshalerClassFactory::QueryInterface
// long CPipeMarshalerClassFactory::AddRef
// long CPipeMarshalerClassFactory::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CPipeMarshalerClassFactory :: QueryInterface (

	IN REFIID riid,
    OUT PPVOID ppv
)
{
    *ppv=NULL;

    if ( IID_IUnknown == riid || IID_IClassFactory == riid )
	{
        *ppv=this ;
	}

    if ( NULL != *ppv )
	{
        ( ( LPUNKNOWN ) *ppv )->AddRef () ;

        return NOERROR ;
    }

    return E_NOINTERFACE ;
}

STDMETHODIMP_(ULONG) CPipeMarshalerClassFactory :: AddRef ()
{
    return ++m_cRef ;
}

STDMETHODIMP_(ULONG) CPipeMarshalerClassFactory :: Release ()
{
    if ( 0L != --m_cRef )
        return m_cRef ;

    delete this ;
    return 0L ;
}

//***************************************************************************
//  CPipeMarshalerClassFactory::CreateInstance
//
//  PURPOSE:
//  Instantiates a provider object returning an interface pointer.  Note
//              that the CreateImpObj routine is always overriden in order
//              to create a particular type of provider.
//
//  PARAMETERS:
//
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
//  RETURN VALUE:
//
//  NOERROR                 if successful
//  E_NOINTERFACE           we cannot support the requested interface.
//  CLASS_E_NOAGGREGATION   Aggregation isnt supported
//  E_OUT_OF_MEMORY         out of memory
//***************************************************************************

STDMETHODIMP CPipeMarshalerClassFactory :: CreateInstance 
(
	IN LPUNKNOWN pUnkOuter,
    IN REFIID riid, 
    OUT PPVOID ppvObj
)
{
    IWbemTransport *pObj ;
    HRESULT         hr ;

    *ppvObj = NULL ;
    hr = E_OUTOFMEMORY ;

    //Verify that a controlling unknown asks for IUnknown

    if (NULL!=pUnkOuter && IID_IUnknown!=riid)
	{
        return CLASS_E_NOAGGREGATION;
	}

	//Create the object.

	pObj = new CPipeMarshaler ;

	if ( NULL == pObj )
	{
		return hr ;
	}

	hr = pObj->QueryInterface ( riid, ppvObj ) ;

	//Kill the object if initial creation or Init failed.

	if (FAILED(hr))
	{
		delete pObj;
	}

    return hr;
}

//***************************************************************************
//  CPipeMarshalerClassFactory::LockServer
//
//  PURPOSE:
//
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
//  PARAMETERS:
//
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
//  RETURN VALUE:
//
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CPipeMarshalerClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
	{
        InterlockedIncrement((long *)&g_cPipeLock);
	}
    else
	{
        InterlockedDecrement((long *)&g_cPipeLock);
	}

    return NOERROR;
}

#ifdef TCPIP_MARSHALER
//***************************************************************************
//
//  CTcpipMarshalerClassFactory::CTcpipMarshalerClassFactory
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CTcpipMarshalerClassFactory :: CTcpipMarshalerClassFactory () : m_cRef ( 0 )
{
}

//***************************************************************************
//
//  CTcpipMarshalerClassFactory::~CTcpipMarshalerClassFactory
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CTcpipMarshalerClassFactory :: ~CTcpipMarshalerClassFactory ()
{
}

//***************************************************************************
// HRESULT CTcpipMarshalerClassFactory::QueryInterface
// long CTcpipMarshalerClassFactory::AddRef
// long CTcpipMarshalerClassFactory::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CTcpipMarshalerClassFactory :: QueryInterface (

	IN REFIID riid,
    OUT PPVOID ppv
)
{
    *ppv=NULL;

    if ( IID_IUnknown == riid || IID_IClassFactory == riid )
	{
        *ppv=this ;
	}

    if ( NULL != *ppv )
	{
        ( ( LPUNKNOWN ) *ppv )->AddRef () ;

        return NOERROR ;
    }

    return E_NOINTERFACE ;
}

STDMETHODIMP_(ULONG) CTcpipMarshalerClassFactory :: AddRef ()
{
    return ++m_cRef ;
}

STDMETHODIMP_(ULONG) CTcpipMarshalerClassFactory :: Release ()
{
    if ( 0L != --m_cRef )
        return m_cRef ;

    delete this ;
    return 0L ;
}

//***************************************************************************
//  CTcpipMarshalerClassFactory::CreateInstance
//
//  PURPOSE:
//  Instantiates a provider object returning an interface pointer.  Note
//              that the CreateImpObj routine is always overriden in order
//              to create a particular type of provider.
//
//  PARAMETERS:
//
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
//  RETURN VALUE:
//
//  NOERROR                 if successful
//  E_NOINTERFACE           we cannot support the requested interface.
//  CLASS_E_NOAGGREGATION   Aggregation isnt supported
//  E_OUT_OF_MEMORY         out of memory
//***************************************************************************

STDMETHODIMP CTcpipMarshalerClassFactory :: CreateInstance 
(
	IN LPUNKNOWN pUnkOuter,
    IN REFIID riid, 
    OUT PPVOID ppvObj
)
{
    IWbemTransport *pObj ;
    HRESULT         hr ;

    *ppvObj = NULL ;
    hr = E_OUTOFMEMORY ;

    //Verify that a controlling unknown asks for IUnknown

    if (NULL!=pUnkOuter && IID_IUnknown!=riid)
	{
        return CLASS_E_NOAGGREGATION;
	}

	//Create the object.

	pObj = new CTcpipMarshaler ;

	if ( NULL == pObj )
	{
		return hr ;
	}

	hr = pObj->QueryInterface ( riid, ppvObj ) ;

	//Kill the object if initial creation or Init failed.

	if (FAILED(hr))
	{
		delete pObj;
	}

    return hr;
}

//***************************************************************************
//  CTcpipMarshalerClassFactory::LockServer
//
//  PURPOSE:
//
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
//  PARAMETERS:
//
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
//  RETURN VALUE:
//
//  HRESULT         NOERROR always.
//***************************************************************************

STDMETHODIMP CTcpipMarshalerClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
	{
        InterlockedIncrement((long *)&g_cTcpipLock);
	}
    else
	{
        InterlockedDecrement((long *)&g_cTcpipLock);
	}

    return NOERROR;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\stub\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/#pragma warning (disable : 4786)
#include <localloc.h>
#include "wmishared.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\stub\pipestbo.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PIPESTBO.H

Abstract:

	Declares the stub pipe operation classes

History:

	alanbos  18-Dec-97   Created.

--*/

#ifndef _PIPESTBO_H_
#define _PIPESTBO_H_

// Anonymous Pipe Cancel Async Call Operation
class CStubOperation_LPipe_CancelAsyncCall : public IStubOperation_LPipe
{
private:
	DWORD	m_pSink;

protected:
	void	DecodeOp (CTransportStream& decodeStream)
	{
		SetStatus ((CTransportStream::no_error == decodeStream.ReadDWORD (&m_pSink)) ?
			WBEM_NO_ERROR : WBEM_E_INVALID_STREAM);
	}
	void Execute (CComLink& comLink, IUnknown *pStub);

public:
	CStubOperation_LPipe_CancelAsyncCall (CStubAddress_WinMgmt& stubAddr) : 
		m_pSink (0), IStubOperation_LPipe (stubAddr, PROVIDER, WBEM_METHOD_CancelAsyncCall) {}
};

// Anonymous Pipe Create Class or Instance Enum Operation
class CStubOperation_LPipe_CreateEnum : public IStubOperation_LPipe
{
private:
	BSTR					m_parent;
	long					m_flags;
	DWORD					m_handler;

protected:
	inline void	EncodeOp (CTransportStream& encodeStream)
	{
		if (!IsAsync () && (WBEM_NO_ERROR == GetStatus ()))
			EncodeStubAddress (ENUMERATOR, encodeStream);
	}
	void	DecodeOp (CTransportStream& decodeStream);
	void	Execute (CComLink& comLink, IUnknown *pStub);

public:
	inline CStubOperation_LPipe_CreateEnum (CStubAddress_WinMgmt& stubAddr, DWORD dwStubFunc, bool isAsync) :
		m_parent (NULL), m_flags (0), m_handler (0),
		IStubOperation_LPipe (stubAddr, PROVIDER, dwStubFunc, isAsync) {}
	inline virtual ~CStubOperation_LPipe_CreateEnum () 
	{
		SysFreeString (m_parent);
	}
};

// Anonymous Pipe Delete Class or Instance Operation
class CStubOperation_LPipe_Delete : public IStubOperation_LPipe
{
private:
	BSTR		m_path;
	long		m_flags;
	DWORD		m_pHandler;

protected:
	void	EncodeOp (CTransportStream& encodeStream)
	{
		if (!IsAsync ())
			EncodeStubAddress (CALLRESULT, encodeStream);
	}
	void	DecodeOp (CTransportStream& decodeStream);
	void	Execute (CComLink& comLink, IUnknown *pStub);
	
public:
	inline CStubOperation_LPipe_Delete (CStubAddress_WinMgmt& stubAddr, DWORD dwStubFunc, bool isAsync) : 
		m_path (NULL), m_flags (0), m_pHandler (0),
		IStubOperation_LPipe (stubAddr, PROVIDER, dwStubFunc, isAsync) {}

	inline virtual ~CStubOperation_LPipe_Delete ()
	{
		SysFreeString (m_path);
	}
};

// Anonymous Pipe Execute (Notification) Query Operation
class CStubOperation_LPipe_ExecQuery : public IStubOperation_LPipe
{
private:
	BSTR		m_queryLanguage;
	BSTR		m_query;
	long		m_flags;
	DWORD		m_pHandler;

protected:
	inline void	EncodeOp (CTransportStream& encodeStream)
	{
		if (!IsAsync () && (WBEM_NO_ERROR == GetStatus ()))
			EncodeStubAddress (ENUMERATOR, encodeStream);
	}
	void	DecodeOp (CTransportStream& decodeStream);
	void	Execute (CComLink& comLink, IUnknown *pStub);
	
public:
	inline CStubOperation_LPipe_ExecQuery (CStubAddress_WinMgmt& stubAddr, DWORD dwStubFunc, bool isAsync) : 
		m_queryLanguage (NULL), m_query (NULL), m_flags (0),
		m_pHandler (0),
		IStubOperation_LPipe (stubAddr, PROVIDER, dwStubFunc, isAsync) {}
	
	inline virtual ~CStubOperation_LPipe_ExecQuery ()
	{
		SysFreeString (m_queryLanguage);
		SysFreeString (m_query);
	}
};

// Anonymous Pipe Get Object Operation
class CStubOperation_LPipe_GetObject : public IStubOperation_LPipe
{
private:
	BSTR		m_path;
	long		m_flags;
	DWORD		m_pHandler;
	IWbemClassObject* m_pObject;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);
	void	Execute (CComLink& comLink, IUnknown *pStub);

public:
	inline CStubOperation_LPipe_GetObject (CStubAddress_WinMgmt& stubAddr, DWORD dwStubFunc, bool isAsync) : 
		m_path (NULL), m_flags (0), m_pHandler (0), m_pObject (NULL),
		IStubOperation_LPipe (stubAddr, PROVIDER, dwStubFunc, isAsync) {}

	inline virtual ~CStubOperation_LPipe_GetObject ()
	{
		SysFreeString (m_path);
		if (m_pObject) m_pObject->Release ();
	}
};

// Anonymous Pipe Open Namespace Operation
class CStubOperation_LPipe_OpenNamespace : public IStubOperation_LPipe
{
private:
	BSTR			m_path;
	long			m_flags;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);
	void	Execute (CComLink& comLink, IUnknown *pStub);

public:
	inline CStubOperation_LPipe_OpenNamespace (CStubAddress_WinMgmt& stubAddr) : 
		m_path (NULL), m_flags (0), 
		IStubOperation_LPipe (stubAddr, PROVIDER, WBEM_METHOD_OpenNamespace) {}

	inline virtual ~CStubOperation_LPipe_OpenNamespace () 
	{
		SysFreeString (m_path);
	}
};

// Anonymous Pipe Put Class or Instance Operation
class CStubOperation_LPipe_Put : public IStubOperation_LPipe
{
private:
	IWbemClassObject FAR*	m_pObject;
	long					m_flags;
	DWORD					m_pHandler;

protected:
	inline void	EncodeOp (CTransportStream& encodeStream)
	{
		if (!IsAsync ())
			EncodeStubAddress (CALLRESULT, encodeStream);
	}
	void	DecodeOp (CTransportStream& decodeStream);
	void	Execute (CComLink& comLink, IUnknown *pStub);
	
public:
	inline CStubOperation_LPipe_Put (CStubAddress_WinMgmt& stubAddr, DWORD dwStubFunc, bool isAsync) : 
		m_pObject (NULL), m_flags (0), m_pHandler (0),
		IStubOperation_LPipe (stubAddr, PROVIDER, dwStubFunc, isAsync) {}
	virtual ~CStubOperation_LPipe_Put () 
	{
		if (m_pObject) m_pObject->Release ();
	}
};

// Anonymous Pipe Query Object Sink Operation
class CStubOperation_LPipe_QueryObjectSink : public IStubOperation_LPipe
{
private:
	long			m_flags;

protected:
	inline void	EncodeOp (CTransportStream& encodeStream)
	{
		if (WBEM_NO_ERROR == GetStatus ())
			EncodeStubAddress (OBJECTSINK, encodeStream);
	}
	inline void	DecodeOp (CTransportStream& decodeStream)
	{
		if (CTransportStream::no_error != decodeStream.ReadLong (&m_flags))
			SetStatus (WBEM_E_INVALID_STREAM);
	}
	void	Execute (CComLink& comLink, IUnknown *pStub);

public:
	inline CStubOperation_LPipe_QueryObjectSink (CStubAddress_WinMgmt& stubAddr) : 
		m_flags (0), 
		IStubOperation_LPipe (stubAddr, PROVIDER, WBEM_METHOD_QueryObjectSink) {}
};

// Anonymous Pipe Execute Method Operation
class CStubOperation_LPipe_ExecMethod : public IStubOperation_LPipe
{
private:
	BSTR					m_path;
	BSTR					m_method;
	long					m_flags;
	IWbemClassObject FAR*	m_pInParams;
	DWORD					m_pHandler;
	IWbemClassObject FAR*	m_pOutParams;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);
	void	Execute (CComLink& comLink, IUnknown *pStub);

public:
	inline CStubOperation_LPipe_ExecMethod (CStubAddress_WinMgmt& stubAddr, DWORD dwStubFunc, bool isAsync) : 
		m_path (NULL), m_method (NULL),	m_flags (0), m_pInParams (NULL), 
		m_pOutParams (NULL), m_pHandler (0),
		IStubOperation_LPipe (stubAddr, PROVIDER, dwStubFunc, isAsync) {}

	inline virtual ~CStubOperation_LPipe_ExecMethod () 
	{
		SysFreeString (m_path);
		SysFreeString (m_method);
		if (m_pInParams) m_pInParams->Release ();
		if (m_pOutParams) m_pOutParams->Release ();
	}
};

// Anonymous Pipe request challenge operation
class CStubOperation_LPipe_RequestChallenge : public IStubOperation_LPipe
{
private:
	BSTR			m_networkResource;
	BSTR			m_user;
	BYTE			m_nonce [DIGEST_SIZE];

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);	
	void	Execute (CComLink& comLink, IUnknown *pStub); 

public:
	CStubOperation_LPipe_RequestChallenge (CStubAddress_WinMgmt& stubAddr) :
		m_networkResource (NULL), m_user (NULL), 
		IStubOperation_LPipe (stubAddr, LOGIN, REQUESTCHALLENGE) {}
	virtual ~CStubOperation_LPipe_RequestChallenge () 
	{
		SysFreeString (m_networkResource);
		SysFreeString (m_user);
	}
};

// Anonymous Pipe establish position operation
class CStubOperation_LPipe_EstablishPosition : public IStubOperation_LPipe
{
private:
	BSTR			m_clientMachineName;
	DWORD			m_processId;
	DWORD			m_authEventHandle;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);	
	void	Execute (CComLink& comLink, IUnknown *pStub); 

public:
	CStubOperation_LPipe_EstablishPosition (CStubAddress_WinMgmt& stubAddr) :
		m_clientMachineName (NULL), m_processId (0), m_authEventHandle (0),
		IStubOperation_LPipe (stubAddr, LOGIN, ESTABLISHPOSITION) {}
	virtual ~CStubOperation_LPipe_EstablishPosition () 
	{
		SysFreeString (m_clientMachineName);
	}
};

// Anonymous Pipe WBEMLogin operation
class CStubOperation_LPipe_WBEMLogin : public IStubOperation_LPipe
{
private:
	BSTR			m_preferredLocale;
	long			m_bytesRead;		// into access token
	BYTE			m_accessToken [DIGEST_SIZE];
    long			m_flags;
    
protected:
	void	EncodeOp (CTransportStream& encodeStream)
	{
		if (WBEM_NO_ERROR == GetStatus ())
			EncodeStubAddress (PROVIDER, encodeStream);
	}
	void	DecodeOp (CTransportStream& decodeStream); 
	void	Execute (CComLink& comLink, IUnknown *pStub); 
	
public:
	CStubOperation_LPipe_WBEMLogin (CStubAddress_WinMgmt& stubAddr) :
		m_bytesRead (0), m_preferredLocale (NULL), m_flags (0), 
		IStubOperation_LPipe (stubAddr, LOGIN, WBEMLOGIN) {}
	virtual ~CStubOperation_LPipe_WBEMLogin () 
	{
		SysFreeString (m_preferredLocale);
	}
};

// Anonymous Pipe SSPI Pre Login operation
class CStubOperation_LPipe_SspiPreLogin : public IStubOperation_LPipe
{
private:
    LPSTR			m_pszSSPIPkg;
    long			m_flags;
    long			m_bufSize;
    byte*			m_pInToken;
    long			m_outBufSize;
    byte*			m_pOutToken;
	long			m_outBufBytes;
	BSTR			m_clientMachineName;
	DWORD			m_dwProcessID; 
	DWORD			m_authEventHandle;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream);
	void	Execute (CComLink& comLink, IUnknown *pStub);

public:
	CStubOperation_LPipe_SspiPreLogin (CStubAddress_WinMgmt& stubAddr) :
		m_pszSSPIPkg (NULL), m_flags (0), m_bufSize (0), 
		m_pInToken (NULL), m_outBufSize (0), m_outBufBytes (0),
		m_pOutToken (NULL), m_dwProcessID (0), 
		m_authEventHandle (0), m_clientMachineName (NULL),
		IStubOperation_LPipe (stubAddr, LOGIN, SSPIPRELOGIN) {}
	virtual ~CStubOperation_LPipe_SspiPreLogin () 
	{
		SysFreeString (m_clientMachineName);
		if (m_pszSSPIPkg) delete m_pszSSPIPkg;
		if (m_pInToken) delete [] m_pInToken;
		if (m_pOutToken) delete [] m_pOutToken;
	}
};

// Anonymous Pipe Login operation
class CStubOperation_LPipe_Login : public IStubOperation_LPipe
{
private:
	BSTR			m_networkResource;
	BSTR			m_preferredLocale;
	long			m_bytesRead;		// into access token
	BYTE			m_accessToken [DIGEST_SIZE];
    long			m_flags;
    
protected:
	void	EncodeOp (CTransportStream& encodeStream)
	{
		if (WBEM_NO_ERROR == GetStatus ())
			EncodeStubAddress (PROVIDER, encodeStream);
	}
	void	DecodeOp (CTransportStream& decodeStream); 
	void	Execute (CComLink& comLink, IUnknown *pStub); 
	
public:
	CStubOperation_LPipe_Login (CStubAddress_WinMgmt& stubAddr) :
		m_networkResource (NULL), m_bytesRead (0),
		m_preferredLocale (NULL), m_flags (0), 
		IStubOperation_LPipe (stubAddr, LOGIN, LOGINBYTOKEN) {}
	virtual ~CStubOperation_LPipe_Login () 
	{
		SysFreeString (m_networkResource);
		SysFreeString (m_preferredLocale);
	}
};

// Anonymous Pipe Reset Operation
class CStubOperation_LPipe_Reset : public IStubOperation_LPipe
{
protected:
	void	Execute (CComLink& comLink, IUnknown *pStub);

public:
	CStubOperation_LPipe_Reset (CStubAddress_WinMgmt& stubAddr) :
		IStubOperation_LPipe (stubAddr, ENUMERATOR, RESET) {}
};

// Anonymous Pipe Next Operation
class CStubOperation_LPipe_Next : public IStubOperation_LPipe
{
private:
	long		m_timeout;
	ULONG		m_count;
	IWbemClassObject**	m_objArray;
	DWORD		m_returned;

protected:
	void	EncodeOp (CTransportStream& encodeStream);
	void	DecodeOp (CTransportStream& decodeStream); 
	void	Execute (CComLink& comLink, IUnknown *pStub);	

public:
	CStubOperation_LPipe_Next (CStubAddress_WinMgmt& stubAddr) :
		m_timeout (0), m_count(0), m_objArray (NULL), m_returned (0),
		IStubOperation_LPipe (stubAddr, ENUMERATOR, NEXT) {}

	~CStubOperation_LPipe_Next () { delete [] m_objArray ; }
};

// Anonymous Pipe Clone Operation
class CStubOperation_LPipe_Clone : public IStubOperation_LPipe
{
protected:
	void	EncodeOp (CTransportStream& encodeStream)
	{
		if (WBEM_NO_ERROR == GetStatus ())
			EncodeStubAddress (ENUMERATOR, encodeStream);
	}
	void	Execute (CComLink& comLink, IUnknown *pStub);
	
public:
	CStubOperation_LPipe_Clone (CStubAddress_WinMgmt& stubAddr) :
		IStubOperation_LPipe (stubAddr, ENUMERATOR, CLONE) {}
};

// Anonymous Pipe NextAsync Operation
class CStubOperation_LPipe_NextAsync : public IStubOperation_LPipe
{
private:
	long		m_count;
	DWORD		m_pSink;
	// This is the local WINMGMT address of the IWbemServices interface
	// from which the enumerator was originally obtained.
	DWORD		m_pServiceStub;

protected:
	void	DecodeOp (CTransportStream& decodeStream);
    void	Execute (CComLink& comLink, IUnknown *pStub); 
	
public:
	CStubOperation_LPipe_NextAsync (CStubAddress_WinMgmt& stubAddr) :
		m_count(0), m_pSink (0), m_pServiceStub (0),
		IStubOperation_LPipe (stubAddr, ENUMERATOR, NEXTASYNC) {}
};

// Anonymous Pipe Skip Operation
class CStubOperation_LPipe_Skip : public IStubOperation_LPipe
{
private:
	long		m_timeout;
	DWORD		m_number;

protected:
	void	DecodeOp (CTransportStream& encodeStream);
    void	Execute (CComLink& comLink, IUnknown *pStub); 
	
public:
	CStubOperation_LPipe_Skip (CStubAddress_WinMgmt& stubAddr) :
		m_timeout (0), m_number(0), 
		IStubOperation_LPipe (stubAddr, ENUMERATOR, SKIP) {}
};

// Anonymous Pipe Call Result Operations.  These are so similar
// we wrap them in one object
class CStubOperation_LPipe_CallResult : public IStubOperation_LPipe
{
private:
	long				m_timeout;
	IWbemClassObject*	m_pStatusObject;	// GetResultObject
	BSTR				m_resultString;		// GetResultString
	long				m_status;			// GetCallStatus

protected:
	void	EncodeOp (CTransportStream& encodeStream);	
	void	DecodeOp (CTransportStream& decodeStream);	
	void	Execute (CComLink& comLink, IUnknown *pStub); 

public:
	CStubOperation_LPipe_CallResult (CStubAddress_WinMgmt& stubAddr, DWORD dwStubFunc) :
		m_timeout (0), m_pStatusObject (0), m_resultString (NULL),
		m_status (0),
		IStubOperation_LPipe (stubAddr, CALLRESULT, dwStubFunc) {}
	virtual ~CStubOperation_LPipe_CallResult () 
	{
		if (m_pStatusObject) m_pStatusObject->Release ();
		SysFreeString (m_resultString);
	}
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\stub\srvlogin.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SRVLOGIN.H

Abstract:

	Declares the CServerLogin

History:

--*/

class CServerLogin : public IServerLogin
{
private:
	long				m_cRef;
	CRITICAL_SECTION	m_cs;
	IWbemLocator		*m_pAuthLocator;
	LPWSTR				m_pszUser;					// User
    LPWSTR				m_pszNetworkResource;		// Namespace
	HANDLE				m_hAuthentEvent;
		
	// The following are used for WBEM authentication & login only
	bool				m_wbemAuthenticationAttempted;

	// The following are used for NTLM authentication & login only
	IWbemServices		*m_pSecNamespace;
	CSSPIServer			*m_pSSPIServer;          // NTLM Only
	CLSID				m_AccessToken;           // WBEM Access Token
	bool				m_ntlmAuthenticationAttempted;

	static LPWSTR		GetMachineName();
    bool				EnsureWBEMAuthenticationInitialized ();
	bool				EnsureNTLMAuthenticationInitialized ();
	bool				VerifyIsLocal ();
	STDMETHODIMP		SetupEventHandle(
							LPWSTR pClientMachineName,
							DWORD processId,
							DWORD *pAuthEventHandle);

public:
	CServerLogin ();
	virtual	~CServerLogin ();

	//Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

	// WBEM authentication methods

    STDMETHODIMP RequestChallenge(
		LPWSTR pNetworkResource,
        LPWSTR pUser,
        WBEM_128BITS Nonce);

	STDMETHODIMP EstablishPosition(
		LPWSTR pClientMachineName,
		DWORD processId,
		DWORD *pAuthEventHandle);

	STDMETHODIMP WBEMLogin(
		LPWSTR pPreferredLocale,
		WBEM_128BITS AccessToken,
		long lFlags,                   // WBEM_LOGIN_TYPE
		IWbemContext *pCtx,              
		IWbemServices **ppNamespace);

	// NTLM authentication methods
    STDMETHODIMP SspiPreLogin( 
        LPSTR pszSSPIPkg,
        long lFlags,
        long lBufSize,
        byte __RPC_FAR *pInToken,
        long lOutBufSize,
        long __RPC_FAR *plOutBufBytes,
        byte __RPC_FAR *pOutToken,
		LPWSTR pClientMachineName,
        DWORD dwProcessId,
        DWORD __RPC_FAR *pAuthEventHandle);
                    
    STDMETHODIMP Login( 
		LPWSTR pNetworkResource,
		LPWSTR pPreferredLocale,
        WBEM_128BITS AccessToken,
        IN LONG lFlags,
        IWbemContext  *pCtx,
        IN OUT IWbemServices  **ppNamespace);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\stub\maindll.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MAINDLL.CPP

Abstract:

    Contains DLL entry points.  Also has code that controls
    when the DLL can be unloaded by tracking the number of
    objects and locks. 

History:

    a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include <initguid.h>

DWORD LOG = LOG_WBEMSTUB;

bool bServer = true;

#ifdef TCPIP_MARSHALER
// {0877AE70-9523-11d1-9367-00AA00A4086C}
DEFINE_GUID(CLSID_WbemTcpip, 
0x877ae70, 0x9523, 0x11d1, 0x93, 0x67, 0x0, 0xaa, 0x0, 0xa4, 0x8, 0x6c);
#endif

//{A4845882-333F-11d0-B724-00AA0062CBB7}
DEFINE_GUID(CLSID_WbemPipe, 0xa4845882, 0x333f, 0x11d0, 0xb7, 0x24, 0x0, 0xaa, 0x00, 0x62, 0xcb, 0xb7);

//Count number of objects and number of locks.

long g_cPipeObj = 0 ;
long g_cPipeLock = 0 ;

#ifdef TCPIP_MARSHALER
long g_cTcpipObj = 0 ;
long g_cTcpipLock = 0 ;
#endif

HMODULE ghModule = NULL ;

MaintObj gMaintObj ( FALSE ) ; 
CThrdPool gThrdPool ;

LONG ObjectTypeTable [ MAX_DEFTRANS_OBJECT_TYPES ] = { 0 } ;

void ShowObjectCounts () ;

void DestroySharedMemory ();

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  Good place for initialization.
//
//  PARAMETERS:
//
//  hInstance           instance handle
//  ulReason            why we are being called
//  pvReserved          reserved
//
//  RETURN VALUE:
//
//  TRUE
//
//***************************************************************************

BOOL WINAPI DllMain (

    IN HINSTANCE hInstance, 
    IN ULONG ulReason,
    LPVOID pvReserved
)
{
    if (DLL_PROCESS_DETACH==ulReason)
    {
        DeleteCriticalSection ( & g_GlobalCriticalSection ) ;
        DestroySharedMemory () ;

        DEBUG_DumpAllocations("C:\\WBEMSTUB.LOG");
        ShowObjectCounts();

        return TRUE;
    }
    else
    {
        if (DLL_PROCESS_ATTACH!=ulReason)
        {
            return TRUE;
        }
        else if (DLL_PROCESS_ATTACH ==ulReason)
        {
            InitializeCriticalSection ( & g_GlobalCriticalSection ) ;
            ghModule = hInstance;
            return TRUE;
        }
    }

    return TRUE;
}

//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//  
//***************************************************************************

STDAPI DllGetClassObject (

    IN REFCLSID rclsid, 
    IN REFIID riid, 
    OUT PPVOID ppv 
)
{
    HRESULT hr;

    IUnknown *pObj = NULL ;

    if ( CLSID_WbemPipe == rclsid )
    {
        pObj = new CPipeMarshalerClassFactory ;
    }
#ifdef TCPIP_MARSHALER
    else if ( CLSID_WbemTcpip == rclsid )
    {
        pObj = new CTcpipMarshalerClassFactory ;
    }
#endif
    else
    {
        return E_FAIL ;
    }

    if ( NULL == pObj )
    {
        return ResultFromScode ( E_OUTOFMEMORY ) ;
    }

    hr = pObj->QueryInterface ( riid , ppv ) ;

    if ( FAILED ( hr ) )
    {
        delete pObj ;
    }

    return hr ;
}

//***************************************************************************
//
//  STDAPI DllCanUnloadNow
//
//  DESCRIPTION:
//
//  Answers if the DLL can be freed, that is, if there are no
//  references to anything this DLL provides.
//
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//  
//***************************************************************************

extern BOOL g_InitialisationComplete ;
extern BOOL g_PipeInitialisationComplete ;
#ifdef TCPIP_MARSHALER
extern BOOL g_TcpipInitialisationComplete ;
#endif

STDAPI DllCanUnloadNow ()
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the 
    // class factory.
    
#ifdef TCPIP_MARSHALER
    sc = ( 0L == g_cPipeObj && 0L == g_cPipeLock && 0L == g_cTcpipObj && 0L == g_cTcpipLock ) ? S_OK : S_FALSE ;
#else
    sc = ( 0L == g_cPipeObj && 0L == g_cPipeLock && 0L ) ? S_OK : S_FALSE ;
#endif
    if ( sc == S_OK )
    {
        gThrdPool.Free () ;

        SetEvent ( g_Terminate ) ;
        CloseHandle ( g_Terminate ) ;

        g_InitialisationComplete = FALSE ;
        g_PipeInitialisationComplete = FALSE ;

#ifdef TCPIP_MARSHALER
        g_TcpipInitialisationComplete = FALSE ;
#endif
    }

    return ResultFromScode ( sc ) ;
}

//***************************************************************************
//
//  ObjectCreated
//
//  DESCRIPTION:
//
//  Keeps track of object creation.
//
//  PARAMETERS:
//
//  dwType              type of object created.
//
//***************************************************************************

void ObjectCreated( IN DWORD dwType )
{
    if(dwType < MAX_DEFTRANS_OBJECT_TYPES)
        InterlockedIncrement(&ObjectTypeTable[dwType]);
}

//***************************************************************************
//
//  void ObjectDestroyed
//
//  DESCRIPTION:
//
//  Keeps track of object deletion.
//
//  PARAMETERS:
//
//  dwType              type of object created.
//
//***************************************************************************

void ObjectDestroyed( IN DWORD dwType )
{
    if(dwType < MAX_DEFTRANS_OBJECT_TYPES)
        InterlockedDecrement(&ObjectTypeTable[dwType]);
}


//***************************************************************************
//
//  void ShowObjectCounts
//
//  DESCRIPTION:
//
//  Dumps out the object count.  Used during shutdown to detect leaks.
//
//***************************************************************************

void ShowObjectCounts ()
{
    DEBUGTRACE((LOG,"\n---COM Object Ref Count Info for marshalling client---\n"));
    DEBUGTRACE((LOG,"Active Pipe Objects = %d\n", g_cPipeObj));
    DEBUGTRACE((LOG,"Server Pipe locks   = %d\n", g_cPipeLock));

#ifdef TCPIP_MARSHALER
    DEBUGTRACE((LOG,"Active Tcpip Objects = %d\n", g_cTcpipObj));
    DEBUGTRACE((LOG,"Server Tcpip locks   = %d\n", g_cTcpipLock));
#endif

    DEBUGTRACE((LOG,"Object counts by type:\n"));

    DEBUGTRACE((LOG,"IWbemLocator counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_LOCATOR]));
    DEBUGTRACE((LOG,"IWbemClassObject counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_CLSOBJ]));
    DEBUGTRACE((LOG,"IWbemService counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_PROVIDER]));
    DEBUGTRACE((LOG,"IWbemQualifier counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_QUALIFIER]));
    DEBUGTRACE((LOG,"IEnumWbemClassObject counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_OBJENUM]));
    DEBUGTRACE((LOG,"IClassFactory counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_FACTORY]));

    DEBUGTRACE((LOG,"OBJECT_TYPE_OBJSINKPROXY counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_OBJSINKPROXY]));
    DEBUGTRACE((LOG,"OBJECT_TYPE_COMLINK counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_COMLINK]));
    DEBUGTRACE((LOG,"OBJECT_TYPE_CSTUB counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_CSTUB]));
    DEBUGTRACE((LOG,"OBJECT_TYPE_RQUEUE counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_RQUEUE]));
    DEBUGTRACE((LOG,"OBJECT_TYPE_PACKET_HEADER counts = %d\n",
        ObjectTypeTable[OBJECT_TYPE_PACKET_HEADER]));
             
    DEBUGTRACE((LOG,"---End of ref count dump---\n"));
}

//***************************************************************************
//
// AddTransportEntry
//
// Purpose: Adds transport section entries in the registry
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

SCODE AddTransportEntry(CLSID clsid, TCHAR * pShortName, TCHAR * pDesc, TCHAR * pVersion)
{

    HKEY h1 = NULL, h2 = NULL, h3 = NULL, h4 = NULL, h5 = NULL;
    DWORD dwDisp;
    DWORD dwStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, __TEXT("SOFTWARE\\MICROSOFT"),
                        0, KEY_ALL_ACCESS, &h1);

    dwStatus = RegCreateKeyEx(h1, __TEXT("WBEM"), 0, 0, 0, KEY_ALL_ACCESS,
        0, &h2, &dwDisp);
    
    if(dwStatus == 0)
        dwStatus = RegCreateKeyEx(h2, __TEXT("Cimom"), 0, 0, 0, KEY_ALL_ACCESS,
            0, &h3, &dwDisp);
 
    if(dwStatus == 0)
        dwStatus = RegCreateKeyEx(h3, __TEXT("Transports"), 0, 0, 0, KEY_ALL_ACCESS,
            0, &h4, &dwDisp);

    if(dwStatus == 0)
        dwStatus = RegCreateKeyEx(h4, pShortName, 0, 0, 0, KEY_ALL_ACCESS,
            0, &h5, &dwDisp);

    if(dwStatus == 0)
    {
        dwStatus = RegSetValueEx(h5, __TEXT("Enabled"), 0, REG_SZ, (BYTE *)"1", 2);
        dwStatus = RegSetValueEx(h5, __TEXT("Name"), 0, REG_SZ, (BYTE *)pShortName, lstrlen(pShortName) + 1);
        dwStatus = RegSetValueEx(h5, __TEXT("Version"), 0, REG_SZ, (BYTE *)pVersion, lstrlen(pVersion)+1);
            
        char       szID[50];
        WCHAR      wcID[50];
        // Create the guid.

        if(StringFromGUID2(clsid, wcID, 50))
        {
            wcstombs(szID, wcID, 50);
            dwStatus = RegSetValueEx(h5, __TEXT("CLSID"), 0, REG_SZ, (BYTE *)szID, strlen(szID)+1);
        }

    }

    if(h5)
        RegCloseKey(h5);
    if(h4)
        RegCloseKey(h4);
    if(h3)
        RegCloseKey(h3);
    if(h2)
        RegCloseKey(h2);
    if(h1)
        RegCloseKey(h1);

    return S_OK;
}

//***************************************************************************
//
// RemoveTransportEntry
//
// Purpose: Removes transport section entries in the registry
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

SCODE RemoveTransportEntry(TCHAR * pShortName)
{
    DWORD dwRet;
    HKEY hKey;
    TCHAR cKey[MAX_PATH];
    lstrcpy(cKey, WBEM_REG_WINMGMT __TEXT("\\transports"));

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, cKey, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,pShortName);
        RegCloseKey(hKey);
    }

    lstrcpy(cKey, WBEM_REG_WINMGMT);

    dwRet = RegOpenKey(HKEY_LOCAL_MACHINE, cKey, &hKey);
    if(dwRet == NO_ERROR)
    {
        RegDeleteKey(hKey,__TEXT("transports"));
        RegCloseKey(hKey);
    }
    return S_OK;
}
//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{ 
    RegisterDLL(ghModule, CLSID_WbemPipe,  __TEXT("WBEM Anon Pipe Transport"), __TEXT("Both"), NULL);
#ifdef TCPIP_MARSHALER
    RegisterDLL(ghModule, CLSID_WbemTcpip,  __TEXT("WBEM Tcpip Transport"), __TEXT("Both"), NULL);
#endif
    AddTransportEntry(CLSID_WbemPipe, __TEXT("AnonPipes"),__TEXT("WBEM Anon Pipe Transport"), __TEXT("1.0"));
#ifdef TCPIP_MARSHALER
    AddTransportEntry(CLSID_WbemTcpip, __TEXT("Tcpip"),__TEXT("WBEM Tcpip Transport"), __TEXT("1.0"));
#endif
 
   return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    UnRegisterDLL(CLSID_WbemPipe, NULL);
#ifdef TCPIP_MARSHALER
    UnRegisterDLL(CLSID_WbemTcpip, NULL);
#endif
    RemoveTransportEntry(__TEXT("AnonPipes"));
#ifdef TCPIP_MARSHALER
    RemoveTransportEntry(__TEXT("Tcpip"));
#endif

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\stub\transp.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    TRANSP.H

Abstract:

	Declares the CTransp Class

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _Transp_H_
#define _Transp_H_

//***************************************************************************
//
// CLASS NAME:
//
// CTransp 
//
// DESCRIPTION:
//
//
//***************************************************************************

class CPipeMarshaler : public IWbemTransport
{
protected:

    ULONG m_cRef ;         //Object reference count
	HANDLE m_ConnectionThread ;

	CRITICAL_SECTION m_cs;

    public:

    CPipeMarshaler () ;
    ~CPipeMarshaler () ;


//Non-delegating object IUnknown

	STDMETHODIMP         QueryInterface(REFIID, PPVOID);

    STDMETHODIMP_(ULONG) AddRef(void) ;

    STDMETHODIMP_(ULONG) Release(void) ;

    /* IWbemTransport methods */

    STDMETHODIMP		Initialize() ;

};

#if 0
class CTcpipMarshaler : public IWbemTransport
{
protected:

    ULONG m_cRef ;         //Object reference count
	HANDLE m_ConnectionThread ;

	CRITICAL_SECTION m_cs;

    public:

    CTcpipMarshaler () ;
    ~CTcpipMarshaler () ;


//Non-delegating object IUnknown

	STDMETHODIMP         QueryInterface(REFIID, PPVOID);

    STDMETHODIMP_(ULONG) AddRef(void) ;

    STDMETHODIMP_(ULONG) Release(void) ;

    /* IWbemTransport methods */

    STDMETHODIMP		Initialize() ;

};
#endif

#endif //_Transp_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\stub\transp.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    TRANSP.CPP

Abstract:

	Defines the CPipeMarshaler class.

History:

	a-davj  9-27-95   Created.

--*/

#include "precomp.h"
#include "cominit.h"

extern LONG ObjectTypeTable[MAX_DEFTRANS_OBJECT_TYPES];

CRITICAL_SECTION g_GlobalCriticalSection ;
BOOL g_InitialisationComplete = FALSE ;
BOOL g_PipeInitialisationComplete = FALSE ;
BOOL g_TcpipInitialisationComplete = FALSE ;

extern DWORD LaunchTcpipConnectionThread ( HANDLE a_Terminate ) ;
extern DWORD LaunchPipeConnectionThread ( HANDLE a_Terminate ) ;
extern HRESULT CreateSharedMemory () ;

//***************************************************************************
//
//  CPipeMarshaler::CPipeMarshaler
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CPipeMarshaler :: CPipeMarshaler () : m_cRef ( 0 ) 
{
    InitializeCriticalSection ( & m_cs ) ; 

    InterlockedIncrement((LONG *) &g_cPipeObj);

}

//***************************************************************************
//
//  CPipeMarshaler::~CPipeMarshaler
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CPipeMarshaler::~CPipeMarshaler()
{
    DeleteCriticalSection ( &m_cs ) ;

    InterlockedDecrement((LONG *) &g_cPipeObj);

}

//***************************************************************************
// HRESULT CPipeMarshaler::QueryInterface
// long CPipeMarshaler::AddRef
// long CPipeMarshaler::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CPipeMarshaler :: QueryInterface (

	IN REFIID riid, 
    OUT PPVOID ppv
)
{
    *ppv=NULL;
    
    // The only calls for IUnknown are either in a nonaggregated
    // case or when created in an aggregation, so in either case
    // always return our IUnknown for IID_IUnknown.

    if ( IID_IUnknown == riid || IID_IWbemTransport == riid )
	{
        *ppv = this ;
	}

    if ( NULL != *ppv )
	{
        ( ( LPUNKNOWN ) *ppv )->AddRef () ;
        return NOERROR ;
    }

    return ResultFromScode ( E_NOINTERFACE ) ;
}

STDMETHODIMP_(ULONG) CPipeMarshaler :: AddRef ()
{
    InterlockedIncrement ( ( long * ) & m_cRef ) ;
    return m_cRef ;
}

STDMETHODIMP_(ULONG) CPipeMarshaler :: Release ()
{
    static BOOL bFirstTime = TRUE;

    EnterCriticalSection ( & m_cs ) ;

    if ( 0L != --m_cRef )
    {
        LeaveCriticalSection ( & m_cs ) ;
        return m_cRef ;
    }

    if ( bFirstTime )
    {
        if ( g_Terminate )
        {
            SetEvent ( g_Terminate ) ;
            int ii;
            for(ii = 0; ii < 5; ii++)
            {
                if(ObjectTypeTable[OBJECT_TYPE_COMLINK] > 0)
                    Sleep(1000);
                else
                    break;
            }
        }
    }

    bFirstTime = FALSE ;

    LeaveCriticalSection ( & m_cs ) ;

    delete this ;
    return 0 ;
}

//***************************************************************************
//
//  SCODE CPipeMarshaler::Initialize
//
//  DESCRIPTION:
//
//  Inintialization routine.
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  WBEM_E_INVALID_PARAMETER  null argument error
//  else possible return from MoreInit
//
//***************************************************************************

SCODE CPipeMarshaler :: Initialize ()
{
	EnterCriticalSection ( & g_GlobalCriticalSection ) ;

	if ( ! g_InitialisationComplete )
	{
		g_InitialisationComplete = TRUE ;
        g_Terminate = CreateEvent(NULL,TRUE,FALSE,NULL);

		gMaintObj.StartClientThreadIfNeeded () ;
	}

	if ( ! g_PipeInitialisationComplete ) 
	{
		g_PipeInitialisationComplete = TRUE ;

		CreateSharedMemory () ;

		DWORD t_ThreadId ;

		m_ConnectionThread = CreateThread (

			NULL,
			0,
			(LPTHREAD_START_ROUTINE) LaunchPipeConnectionThread, 
			(LPVOID)g_Terminate,
			0,
			&t_ThreadId
		) ;

		CloseHandle ( m_ConnectionThread ) ;
	}

	LeaveCriticalSection ( & g_GlobalCriticalSection ) ;

	return S_OK ;
}

#if 0 
//***************************************************************************
//
//  CTcpipMarshaler::CTcpipMarshaler
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CTcpipMarshaler :: CTcpipMarshaler () : m_cRef ( 0 ) 
{
    InitializeCriticalSection ( & m_cs ) ; 

    InterlockedIncrement((LONG *) &g_cTcpipObj);

}

//***************************************************************************
//
//  CTcpipMarshaler::~CTcpipMarshaler
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CTcpipMarshaler::~CTcpipMarshaler()
{
    DeleteCriticalSection ( &m_cs ) ;

    InterlockedDecrement((LONG *) &g_cTcpipObj);

}

//***************************************************************************
// HRESULT CTcpipMarshaler::QueryInterface
// long CTcpipMarshaler::AddRef
// long CTcpipMarshaler::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CTcpipMarshaler :: QueryInterface (

	IN REFIID riid, 
    OUT PPVOID ppv
)
{
    *ppv=NULL;
    
    // The only calls for IUnknown are either in a nonaggregated
    // case or when created in an aggregation, so in either case
    // always return our IUnknown for IID_IUnknown.

    if ( IID_IUnknown == riid || IID_IWbemTransport == riid )
	{
        *ppv = this ;
	}

    if ( NULL != *ppv )
	{
        ( ( LPUNKNOWN ) *ppv )->AddRef () ;
        return NOERROR ;
    }

    return ResultFromScode ( E_NOINTERFACE ) ;
}

STDMETHODIMP_(ULONG) CTcpipMarshaler :: AddRef ()
{
    InterlockedIncrement ( ( long * ) & m_cRef ) ;
    return m_cRef ;
}

STDMETHODIMP_(ULONG) CTcpipMarshaler :: Release ()
{
    static BOOL bFirstTime = TRUE;

    EnterCriticalSection ( & m_cs ) ;

    if ( 0L != --m_cRef )
    {
        LeaveCriticalSection ( & m_cs ) ;
        return m_cRef ;
    }

    if ( bFirstTime )
    {
        if ( g_Terminate )
        {
            SetEvent ( g_Terminate ) ;
            int ii;
            for(ii = 0; ii < 5; ii++)
            {
                if(ObjectTypeTable[OBJECT_TYPE_COMLINK] > 0)
                    Sleep(1000);
                else
                    break;
            }
        }
    }

    bFirstTime = FALSE ;

    LeaveCriticalSection ( & m_cs ) ;

    delete this ;
    return 0 ;
}

//***************************************************************************
//
//  SCODE CTcpipMarshaler::Initialize
//
//  DESCRIPTION:
//
//  Inintialization routine.
//
//  PARAMETERS:
//
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  WBEM_E_INVALID_PARAMETER  null argument error
//  else possible return from MoreInit
//
//***************************************************************************

SCODE CTcpipMarshaler :: Initialize ()
{
	EnterCriticalSection ( & g_GlobalCriticalSection ) ;

	if ( ! g_InitialisationComplete )
	{
		g_InitialisationComplete = TRUE ;
        g_Terminate = CreateEvent(NULL,TRUE,FALSE,NULL);

		gMaintObj.StartClientThreadIfNeeded () ;
	}

	if ( ! g_TcpipInitialisationComplete ) 
	{
		g_TcpipInitialisationComplete = TRUE ;

		DWORD t_ThreadId ;

		m_ConnectionThread = CreateThread (

			NULL,
			0,
			(LPTHREAD_START_ROUTINE) LaunchTcpipConnectionThread, 
			(LPVOID)g_Terminate,
			0,
			&t_ThreadId
		) ;

		CloseHandle ( m_ConnectionThread ) ;
	}

	LeaveCriticalSection ( & g_GlobalCriticalSection ) ;

	return S_OK ;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\stub\userinf.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    USERINF.CPP

Abstract:

	User information for WBEM Login (used by LOGIN.CPP)

History:

	raymcc      07-Aug-97       Created.

--*/


#include "precomp.h"

#include <oahelp.inl>

//***************************************************************************
//
//***************************************************************************

CWbemUserInfo::CWbemUserInfo()
{
    m_pszNtlmDomain = NULL;
}

//***************************************************************************
//
//***************************************************************************

CWbemUserInfo::~CWbemUserInfo()
{
    delete [] m_pszNtlmDomain;
}

//***************************************************************************
//
//***************************************************************************

static LPWSTR GetExpandedSlashes(LPWSTR pszUserName)
{
    WCHAR wcBuff[MAX_PATH];
    memset(wcBuff,0,MAX_PATH*2);
    WCHAR * pTo;
    for(pTo = wcBuff; *pszUserName; pTo++, pszUserName++)
    {
        if(*pszUserName == '\\')
        {
            *pTo = '\\';
            pTo++;
        }
        *pTo = *pszUserName;
    }

    return Macro_CloneLPWSTR(wcBuff);
}

//***************************************************************************
//
//***************************************************************************

void CWbemUserInfo::SetNtlmDomain(
    LPWSTR pszDomain
    )
{
    m_pszNtlmDomain = Macro_CloneLPWSTR(pszDomain);
}


//***************************************************************************
//
//***************************************************************************

bool CWbemUserInfo::GetNTLMUser(
    LPWSTR pszUser1,
    IWbemServices *pSecNs,
    CWbemUserInfo &userInfo
    )
{
    if (pszUser1 == 0 || pSecNs == 0)
        return false;

    LPWSTR pszUser = GetExpandedSlashes(pszUser1);

    wchar_t PathStr[256];
    swprintf(PathStr, L"__NTLMUser=\"%s\"", pszUser);

    IWbemClassObject *pObj = NULL;

    HRESULT hRes = pSecNs->GetObject(
        CBSTR(PathStr),         // Path to the user
        0,                      // No flags
        0,                      // No context
        &pObj,
        0
        );

	if (WBEM_NO_ERROR != hRes)
		return false;

    // Set the domain into the user info..
    // =======================================================
    CVARIANT vDomain;
	pObj->Get(CBSTR(L"Domain"), 0, vDomain, 0, 0);
    userInfo.SetNtlmDomain(vDomain);
	pObj->Release ();
    
    delete [] pszUser;

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\trantest\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\stub\userinf.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    USERINF.H

Abstract:

	User information for WBEM Login (used by LOGIN.CPP)

History:

	raymcc      07-Aug-97       Created.

--*/

#ifndef _USERINF_H_
#define _USERINF_H_

class CWbemUserInfo
{
private:
    LPWSTR  m_pszNtlmDomain;

    void SetNtlmDomain(
        LPWSTR pszDomain
        );

public:

    static bool GetNTLMUser(
        LPWSTR pszUser,
        IWbemServices *pSecNs,
        CWbemUserInfo &pObj
        );

    CWbemUserInfo();
    ~CWbemUserInfo();

    const LPWSTR GetNtlmDomain() { return m_pszNtlmDomain; }

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\stub\srvlogin.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    SRVLOGIN.CPP

Abstract:

	Defines the CServerLogin object.  This is used to provide the stub
	for proxied authentication/login calls.

History:

	alanbos  21-Jan-98   Created.

--*/

#include "precomp.h"

//***************************************************************************
//
//  CServerLogin::CServerLogin
//
//  DESCRIPTION:
//
//  Constructor
//
//  PARAMETERS:
//
//***************************************************************************

CServerLogin::CServerLogin()
{
    m_cRef = 1;
	m_pAuthLocator = NULL;
	m_pSecNamespace = NULL;
	m_pSSPIServer = NULL;
	m_hAuthentEvent = 0;
	m_pszUser = NULL;
	m_pszNetworkResource = NULL;
	memset(&m_AccessToken, 0, sizeof(CLSID));
	m_wbemAuthenticationAttempted = false;
	m_ntlmAuthenticationAttempted = false;

	InitializeCriticalSection(&m_cs);
    return;
}

//***************************************************************************
//
//  CServerLogin::~CServerLogin
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CServerLogin::~CServerLogin(void)
{
	EnterCriticalSection(&m_cs);

	delete m_pSSPIServer;
	delete [] m_pszUser;
	delete [] m_pszNetworkResource;

	if (m_pAuthLocator)
		m_pAuthLocator->Release ();

	if (m_pSecNamespace)
		m_pSecNamespace->Release ();

	if (m_hAuthentEvent)
        CloseHandle(m_hAuthentEvent);

	LeaveCriticalSection(&m_cs);
    DeleteCriticalSection(&m_cs);
}

//***************************************************************************
// HRESULT CServerLogin::QueryInterface
// long CServerLogin::AddRef
// long CServerLogin::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CServerLogin::QueryInterface(
                        REFIID riid,
                        PPVOID ppv)
{
    *ppv=NULL;
    if (IID_IUnknown==riid)
        *ppv=this;

    if (NULL!=*ppv) {
        AddRef();
        return NOERROR;
        }
    else
        return E_NOINTERFACE;
}


STDMETHODIMP_(ULONG) CServerLogin::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CServerLogin::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;

    delete this;
    return 0;
}

//***************************************************************************
//
//  HRESULT CServerLogin::EnsureWBEMAuthenticationInitialized
//
//  DESCRIPTION:
//
//  Checks whether conditions are right for WBEM authentication.  Currently
//	this is only allowed on Win95.  We also have to ensure we get an
//	authenticated WBEM locator interface.
//
//  PARAMETERS:
//
//  None
//
//  RETURN VALUE:
//
//  true	if and only if authentication successfully initialized
//
//***************************************************************************

bool CServerLogin::EnsureWBEMAuthenticationInitialized()
{
	EnterCriticalSection(&m_cs);
	bool result = false;

	if (m_wbemAuthenticationAttempted)
		result = (NULL != m_pAuthLocator);
	else
	{
		m_wbemAuthenticationAttempted = true;

		// Only Win95 supports this authentication mechanism
		if (IsWin95 ())
		{
DEBUGTRACE((LOG,"\nCalling CoCreateInstance"));

			HRESULT hRes = CoCreateInstance (CLSID_WbemAuthenticatedLocator,
							NULL, CLSCTX_INPROC_SERVER,
							IID_IWbemLocator, (void **) &m_pAuthLocator);

			if (SUCCEEDED(hRes) && m_pAuthLocator)
			{
				result = true;	
DEBUGTRACE((LOG,"\nSucceeded for CoCreateInstance"));
			}
			else
			{
DEBUGTRACE((LOG,"\nFailed for CoCreateInstance"));
			}
		}
	}

	LeaveCriticalSection(&m_cs);
	return result;
}

//***************************************************************************
//
//  HRESULT CServerLogin::RequestChallenge
//
//  DESCRIPTION:
//
//  Asks for a challenge so that a login can be done.  Note that currently
//	the implementation only records the namespace and user, and does not
//	issue a challenge.
//
//  PARAMETERS:
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR  if no error,
//	WBEM_E_FAILED	if could not initialize WBEM authentication
//
//***************************************************************************

STDMETHODIMP CServerLogin::RequestChallenge(
			LPWSTR pNetworkResource,
            LPWSTR pUser,
            WBEM_128BITS Nonce)
{
	if (!EnsureWBEMAuthenticationInitialized ()) 
		return WBEM_E_FAILED;
	
	// Record the namespace & user name
	m_pszNetworkResource = Macro_CloneLPWSTR(pNetworkResource);
	m_pszUser = Macro_CloneLPWSTR(pUser);

	return WBEM_NO_ERROR;
}

//***************************************************************************
//
//  HRESULT CServerLogin::EstablishPosition
//
//  DESCRIPTION:
//
//  Establish the position
//
//  PARAMETERS:
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR  if no error,
//  else various provider/transport failures.  
//
//***************************************************************************

STDMETHODIMP CServerLogin::EstablishPosition(
		LPWSTR wszMachineName,
		DWORD dwProcessId,
		DWORD *pAuthEventHandle)
{
	return (EnsureWBEMAuthenticationInitialized ()) ?
		SetupEventHandle (wszMachineName, dwProcessId, pAuthEventHandle) :
		WBEM_E_FAILED;
}

//***************************************************************************
//
//  CreateUnsecuredEvent
//
//***************************************************************************
static BOOL CreateUnsecuredEvent(
    IN  DWORD dwPID,
    OUT HANDLE *phLocal,
    OUT HANDLE *phRemote
    )
{
    BOOL bRetVal = FALSE;
    HANDLE hTargetProcess = 0;    
	HANDLE hEvent = 0;
    PSECURITY_DESCRIPTOR pSD = 0;
    SECURITY_ATTRIBUTES sa;
    memset(&sa, 0, sizeof(SECURITY_ATTRIBUTES));
    HANDLE hTargetProcessHandle = 0;
    BOOL bRes;
    
    if (dwPID == 0 || phLocal == 0 || phRemote == 0)
        goto Exit;

    *phLocal = 0;
    *phRemote = 0;

    // Get a handle to the partner process.
    // ====================================

    hTargetProcess = OpenProcess(PROCESS_DUP_HANDLE, FALSE, dwPID);

    if (hTargetProcess == 0)
        goto Exit;

    // If we are on NT, we have to allow all processes access to this
    // event.
    // ==============================================================

    if (IsNT())
    {
        pSD = (PSECURITY_DESCRIPTOR)CWin32DefaultArena::WbemMemAlloc(SECURITY_DESCRIPTOR_MIN_LENGTH);

        if(pSD == NULL)
            goto Exit;

		ZeroMemory(pSD, SECURITY_DESCRIPTOR_MIN_LENGTH);

        if(!InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION))
            goto Exit;

        if(!SetSecurityDescriptorDacl(pSD, TRUE, NULL, TRUE))
            goto Exit;

        sa.nLength = sizeof(SECURITY_ATTRIBUTES);
        sa.lpSecurityDescriptor = pSD;
        sa.bInheritHandle = FALSE;
		hEvent = CreateEvent(&sa, 0, 0, 0);
    }
	else
		hEvent = CreateEvent(NULL, 0, 0, 0);

    if (hEvent == 0)
        goto Exit;

    // Now that we have the event handle, we duplicate it into the
    // target process.
    // ===========================================================

    bRes = DuplicateHandle(GetCurrentProcess(), hEvent, hTargetProcess,
        &hTargetProcessHandle, SYNCHRONIZE, FALSE, DUPLICATE_SAME_ACCESS
        );

    if (!bRes)
        goto Exit;

    *phLocal =  hEvent;
    *phRemote = hTargetProcessHandle;

    bRetVal = TRUE;

Exit:
    if (hTargetProcess) CloseHandle(hTargetProcess);        
    if (pSD) CWin32DefaultArena::WbemMemFree(pSD);
    if (!bRetVal && hEvent != 0) CloseHandle(hEvent);
    if (!bRetVal && hTargetProcessHandle != 0) CloseHandle(hTargetProcessHandle);
    
    return bRetVal;
}

STDMETHODIMP CServerLogin::SetupEventHandle (
		LPWSTR wszMachineName,
		DWORD dwProcessId,
		DWORD *pAuthEventHandle)
{
	EnterCriticalSection(&m_cs);
	HRESULT	hRes = WBEM_NO_ERROR;

	// Set an event to prove client is local, if need be.
    // Check if the client's purported machine name matches ours
	// =========================================================
	if(_wcsicmp(wszMachineName, GetMachineName()))
	{
		// Didn't match --- remote client
		// ==============================
	    *pAuthEventHandle = 0;
    }
	else
	{
		// Matched. Create and return an unsecured event
		// =============================================
		HANDLE hEvent, hRemoteEvent;
		BOOL bRes = CreateUnsecuredEvent(dwProcessId, &hEvent, &hRemoteEvent);

		if (bRes)
		{
			m_hAuthentEvent = hEvent;                   // Our copy
			*pAuthEventHandle = (DWORD) hRemoteEvent;   // Send back to caller
		}
		else
		{
			// Client lied about process id.
			// =============================
			hRes = WBEM_E_ACCESS_DENIED;
		}
	}

	LeaveCriticalSection(&m_cs);
	return hRes;
}

//***************************************************************************
//
//  FindSlash
//
//  A local for finding the first '\\' or '/' in a string.  Returns null
//  if it doesnt find one.
//
//***************************************************************************
WCHAR * FindSlash(LPWSTR pTest)
{
    if(pTest == NULL)
        return NULL;
    for(;*pTest;pTest++)
        if(IsSlash(*pTest))
            return pTest;
    return NULL;
}

static LPWSTR LocateNamespaceSubstring(LPWSTR pSrc)
{
    LPWSTR pszNamespace;
    if (IsSlash(pSrc[0]) && IsSlash(pSrc[1]))
    {
          // Find the next slash
          // ===================
          WCHAR* pwcNextSlash = FindSlash(pSrc+2);

          if (pwcNextSlash == NULL)
              return NULL;

          pszNamespace = pwcNextSlash+1;
    }
    else
        pszNamespace = pSrc;

    return pszNamespace;
}

//***************************************************************************
//
//  HRESULT CServerLogin::WBEMLogin
//
//  DESCRIPTION:
//
//  Perform a WBEM-authenticated login
//
//  PARAMETERS:
//
//  pNonce              Set to 16 byte value.  Must be freed via CoTaskMemFree()
//
//  RETURN VALUE:
//
//  WBEM_NO_ERROR  if no error,
//  else various provider/transport failures.  
//
//***************************************************************************

HRESULT CServerLogin::WBEMLogin(
			LPWSTR pPreferredLocale,
			WBEM_128BITS AccessToken,
			long lFlags,                                  
			IWbemContext *pCtx,              
			IWbemServices **ppNamespace
        )
{
    *ppNamespace = NULL;       // default

	if (!EnsureWBEMAuthenticationInitialized ())
		return WBEM_E_FAILED;

	// We only allow local login with WBEM authentication 
	if ((lFlags & WBEM_AUTHENTICATION_METHOD_MASK) != WBEM_FLAG_LOCAL_LOGIN)
		return WBEM_E_ACCESS_DENIED;

	// The client claims to be local, so let's check
	if (!VerifyIsLocal ())
		return WBEM_E_ACCESS_DENIED;

    // Locate the requested namespace. 
    // ==================================================
    LPWSTR pszNamespace = LocateNamespaceSubstring(m_pszNetworkResource);
    if (NULL == pszNamespace)
		return WBEM_E_INVALID_NAMESPACE;

	return m_pAuthLocator->ConnectServer (pszNamespace, m_pszUser, 
						NULL, pPreferredLocale, lFlags, NULL, pCtx, ppNamespace);
}

//***************************************************************************
//
//  bool CServerLogin::VerifyIsLocal
//
//  DESCRIPTION:
//
//  Establish the client is indeed as local as they claim to be
//
//  PARAMETERS:
//
//  None
//
//  RETURN VALUE:
//
//  true	if and only if the client is really local
//
//***************************************************************************

bool	CServerLogin::VerifyIsLocal ()
{
	EnterCriticalSection(&m_cs);
	bool result = false;

	// Client must have asked for an authentication event handle
	if (0 != m_hAuthentEvent)
		result = (WAIT_OBJECT_0 == WbemWaitForSingleObject(m_hAuthentEvent, 0));

	LeaveCriticalSection(&m_cs);
	return result;
}
    
    
bool CServerLogin::EnsureNTLMAuthenticationInitialized()
{
	EnterCriticalSection(&m_cs);

	bool result = false;

	if (m_ntlmAuthenticationAttempted)
		result = ((NULL != m_pSecNamespace) &&
				  (NULL != m_pAuthLocator));
	else
	{
		m_wbemAuthenticationAttempted = true;
		IWbemLocator *pAdminLocator = NULL;

		// Get the admin locator
		HRESULT hRes = CoCreateInstance (CLSID_WbemAdministrativeLocator,
			NULL, CLSCTX_INPROC_SERVER,
			IID_IWbemLocator, (void **) &pAdminLocator);

		if (SUCCEEDED(hRes) && pAdminLocator)
		{
			// Now get the connection to the security namespace
			hRes = pAdminLocator->ConnectServer (L"root/security",
						NULL, NULL, NULL, 0, NULL, NULL, &m_pSecNamespace);

			if (SUCCEEDED(hRes) && m_pSecNamespace)
			{
				// Finally get ourselves an authenticated locator
				hRes = CoCreateInstance (CLSID_WbemAuthenticatedLocator,
						NULL, CLSCTX_INPROC_SERVER,
						IID_IWbemLocator, (void **) &m_pAuthLocator);

				if (SUCCEEDED(hRes) && m_pAuthLocator)
				{
					result = true;
					m_ntlmAuthenticationAttempted = true ;
				}
				else
				{
					m_pSecNamespace->Release () ;
					m_pSecNamespace = NULL ;
				}
			}

        	pAdminLocator->Release ();
		}
	}

	LeaveCriticalSection(&m_cs);
    return result;
}

LPWSTR CServerLogin::GetMachineName()
{
    static wchar_t ThisMachine[MAX_COMPUTERNAME_LENGTH+1];
    static BOOL bFirstCall = TRUE;
    
    if (bFirstCall)
    {
        char ThisMachineA[MAX_COMPUTERNAME_LENGTH+1];
        DWORD dwSize = sizeof(ThisMachineA);
        GetComputerNameA(ThisMachineA, &dwSize);
        bFirstCall = FALSE;
        swprintf(ThisMachine, L"%S", ThisMachineA);
    }
    
    return ThisMachine;
}

//***************************************************************************
//
//  CServerLogin::SspiPreLogin
//
//  Called during the first phases of the NTLM login sequence.
//
//  Parameters:
//  <pszSSPIPkg>            Must be "NTLM" for now.
//  <lFlags>                Reserved.
//  <lBufSize>              The size of the <pInToken> array.
//  <lOutBufSize>           The size of the output buffer.
//  <plOutBufBytes>         Receives the number of bytes returned.
//  <pOutToken>             Receives the NTLM challenge.
//	<wszMachineName>			Client Machine Name
//  <dwProcessId>           The process ID for local login verification.
//  <pAuthEventHandle>      Used for local login verification.
//
//  Return values:
//
//  WBEM_E_FAILED            SSPI internal failure. Proceed to WBEM.
//  WBEM_E_INVALID_PARAMETER Invalid pointer or other parameter.
//  WBEM_S_PRELOGIN          Call PreLogin again.
//  WBEM_S_LOGIN             Call Login next time.
//  WBEM_E_ACCESS_DENIED     NTLM has officially denied access.
//
//***************************************************************************

HRESULT CServerLogin::SspiPreLogin(
    LPSTR  pszSSPIPkg,
    long   lFlags,
    long   lBufSize,
    byte  *pInToken,
    long   lOutBufSize,
    long  *plOutBufBytes,
    byte  *pOutToken,
	LPWSTR wszMachineName,
    DWORD  dwProcessId,
    DWORD *pAuthEventHandle
    )
{
    // Make sure SSPI is initialized.
    // ==============================
    if (!CSSPI::Initialize())
        return WBEM_E_FAILED;

    // Ensure security database is open.
    // =================================
    if (!EnsureNTLMAuthenticationInitialized())
        return WBEM_E_FAILED;

    // Validate some parameters.
    // =========================
    if (pInToken == 0 || pOutToken == 0 || lBufSize == 0 || lOutBufSize == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Verify the package is supported for server-side connections.
    // ============================================================
    if (CSSPI::ServerSupport(pszSSPIPkg) == FALSE)
        WBEM_E_NOT_SUPPORTED;

    // Initialize the SSPI server instance.
    // =====================================
    if (NULL == m_pSSPIServer)
    {
        m_pSSPIServer = _new CSSPIServer(pszSSPIPkg);

        if (m_pSSPIServer->GetStatus() != CSSPIServer::Waiting)
            return WBEM_E_FAILED;

        LPBYTE pOutBuf = 0;
        DWORD  dwOutBufSize = 0;

        DWORD dwRes= m_pSSPIServer->ContinueClientLogin(
            pInToken,
            lBufSize,
            &pOutBuf,
            &dwOutBufSize
            );

        if (dwRes != CSSPIServer::LoginContinue)
            return WBEM_E_ACCESS_DENIED;

        memcpy(pOutToken, pOutBuf, dwOutBufSize);
        *plOutBufBytes = (long) dwOutBufSize;
        delete [] pOutBuf;

		return (SUCCEEDED (SetupEventHandle (wszMachineName, dwProcessId,pAuthEventHandle))) 
				 ? WBEM_S_PRELOGIN :WBEM_E_ACCESS_DENIED;
    }

    // If here, then it is the second call.
    // ====================================
    if (m_pSSPIServer->GetStatus() != CSSPIServer::LoginContinue)
        return WBEM_E_FAILED;

    LPBYTE pOutBuf = 0;
    DWORD  dwOutBufSize = 0;

    DWORD dwRes= m_pSSPIServer->ContinueClientLogin(
        pInToken,
        lBufSize,
        &pOutBuf,
        &dwOutBufSize
        );

    if (dwRes == CSSPIServer::AccessDenied)
        return WBEM_E_ACCESS_DENIED;

    if (dwRes)
        return WBEM_E_FAILED;


    // If here, the user has passed through the SSPI gauntlet.
    // Now get the user name.
    // =======================================================

    LPSTR pszUser = 0;
    BOOL bRes = m_pSSPIServer->QueryUserInfo(&pszUser);

    if (!bRes)
        return WBEM_E_ACCESS_DENIED;

	int len = strlen (pszUser);
    m_pszUser = new wchar_t [len + 1];
	mbstowcs(m_pszUser, pszUser, len + 1);  // Convert to UNICODE
    delete [] pszUser;
    pszUser = 0;
    
    // If here, the user is who he claims to be, but has not been authenticated. 
    // We will allow or deny access in the Login() call. We issue a 
    // 'temporary' access token to this user.
    // =========================================================================

    dwRes = m_pSSPIServer->IssueLoginToken(m_AccessToken);

    if (dwRes != CSSPIServer::NoError)
        return WBEM_E_FAILED;

    memcpy(pOutToken, &m_AccessToken, sizeof(CLSID));
    *plOutBufBytes = sizeof(CLSID);
    return WBEM_S_LOGIN;
}

//***************************************************************************
//
//  CServerLogin::Login
//
//  Called during the second phases of the NTLM login sequence.
//
//  Parameters:
//
//  Return values:
//
//
//***************************************************************************
// ok

HRESULT CServerLogin::Login(
    LPWSTR pNetworkResource,
    LPWSTR pPreferredLocale,
    WBEM_128BITS AccessToken,
    LONG lFlags,
    IWbemContext *pCtx,
    IWbemServices **ppNamespace
    )
{
    DWORD dwSecFlags = 0;
        
    DEBUGTRACE((LOG,
        "CALL CServerLogin::Login\n"
        "   pNetworkResource = %S\n"
        "   pPreferredLocale = %S\n"
        "   AccessToken = 0x%X\n"
        "   lFlags = 0x%X\n",
        pNetworkResource,
        pPreferredLocale,
        AccessToken,
        lFlags
        ));

    *ppNamespace = NULL;       // default

	// Ensure security database is open.
    // =================================
    if (!EnsureNTLMAuthenticationInitialized())
        return WBEM_E_FAILED;

    // If the client claims to be local, verify this
	if ((lFlags & WBEM_AUTHENTICATION_METHOD_MASK) == WBEM_FLAG_LOCAL_LOGIN)
	{
		if (!VerifyIsLocal ())
			return WBEM_E_ACCESS_DENIED;
	}

    // Locate the requested namespace. 
    // ==================================================
    LPWSTR pszNamespace = LocateNamespaceSubstring(pNetworkResource);
    if (NULL == pszNamespace)
		return WBEM_E_INVALID_NAMESPACE;

    // We now have the namespace in question in <pszNamespace>.
    // We next 'authenticate' the user based on the login method.
    // ==========================================================
    if (memcmp(AccessToken, &m_AccessToken, sizeof(CLSID)) != 0)
	    return WBEM_E_ACCESS_DENIED;

    // Grab the ns and hand it back to the caller.
    // ===========================================
	return m_pAuthLocator->ConnectServer (pszNamespace, m_pszUser, 
						NULL, pPreferredLocale, lFlags, NULL, pCtx, ppNamespace);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\stub\wmishared.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PRECOMP.H

Abstract:

    Master include file.

History:

    a-davj  04-Mar-97   Created.

--*/

extern DWORD LOG;

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <assert.h>
#include <wbemutil.h>
#include <dbgalloc.h>
#include <wbemidl.h> 
#include <wbemcomn.h>
#include <transtrm.h>
#include <cominit.H>       
#include "wbemstub.h"
#include "stubaddr.h"
#include "stbaddcm.h"
#include <linklist.h>
#include <winsock.h>
#include <comlink.h>
#include <secfilt.h>
#include <iopn.h>
#include <thrdpool.h>
#include <package.h>
#include <maintobj.h>
#include <utils.h>
#include <pipeopn.h>
#include <tranutil.h>
#include <genutils.h>
#include <cproxy.h>
#include "connpnt.h"
#include "cftransp.h"
#include "transp.h"
#include "pipestbo.h"
#include "pipesnkp.h"
#include <csspi.h>
#include "srvlogin.h"

extern MaintObj gMaintObj;
extern CThrdPool gThrdPool;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\stub\wbemstub.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WBEMSTUB.H

Abstract:

	Declares some constants and global variables.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _wbemstub_H_
#define _wbemstub_H_

// These define objects in addition to the object types defined in
// WBEM.  The first group, upto but NOT including comlink, are Ole
// objects and the second group has object types that are tracked
// just for keeping track of leaks

enum { OBJECT_TYPE_COMLINK = MAX_OBJECT_TYPES, OBJECT_TYPE_CSTUB,OBJECT_TYPE_RQUEUE,
	OBJECT_TYPE_PACKET_HEADER,
	OBJECT_TYPE_OBJSINKPROXY ,MAX_DEFTRANS_OBJECT_TYPES};

#define MARSHALER_STUB

typedef LPVOID * PPVOID;                   

extern long       g_cPipeObj;
extern long       g_cPipeLock;
extern long       g_cTcpipObj;
extern long       g_cTcpipLock;

extern CRITICAL_SECTION g_GlobalCriticalSection ;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\trantest\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#pragma warning (disable : 4786)
#include <localloc.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\trantest\notify.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    NOTIFY.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <wbemidl.h>
#include "notify.h"

HANDLE gAsyncTest;
DWORD gClassCnt;
BOOL bVerbose = FALSE;

/////////////////////////////////////////////////////////////////////////
//
CNotify::CNotify()
{
    m_cRef=1;
    return;
}

CNotify::~CNotify(void)
{
    SetEvent(gAsyncTest);
    return;
}

BOOL CNotify::Init(void)
{
    //Nothing to do.
    return TRUE;
}

//***************************************************************************
//
// CNotify::QueryInterface
// CNotify::AddRef
// CNotify::Release
//
// Purpose:
//  IUnknown members for CNotify object.
//***************************************************************************

SCODE GetAttString(IWbemClassObject FAR* pClassInt, LPWSTR pPropName, 
                                            LPWSTR pAttName);

STDMETHODIMP CNotify::QueryInterface(REFIID riid, PPVOID ppv)
{
    *ppv=NULL;

    /*
     * The only calls for IUnknown are either in a nonaggregated
     * case or when created in an aggregation, so in either case
     * always return our IUnknown for IID_IUnknown.
     */
    if (IID_IUnknown==riid || IID_IWbemObjectSink == riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) CNotify::AddRef(void)
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CNotify::Release(void)
{
    if (0L!=--m_cRef)
        return m_cRef;

    /*
     * Tell the housing that an object is going away so it can
     * shut down if appropriate.
     */
    

    ///  delete this; we keep this around for many tests!!!
    return 0;
}
SCODE CNotify::GetTypeInfoCount(UINT FAR* pctinfo)
{
    return WBEM_E_NOT_SUPPORTED;
}

SCODE CNotify::GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo)
{
    return WBEM_E_NOT_SUPPORTED;
}

SCODE CNotify::GetIDsOfNames(
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid)
{
    return WBEM_E_NOT_SUPPORTED;
}

SCODE CNotify::Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr)
{
    return WBEM_E_NOT_SUPPORTED;
}


SCODE CNotify::Indicate(long lObjectCount, IWbemClassObject FAR* FAR* pObjArray)
{
    long lCnt;

    for(lCnt = 0; lCnt < lObjectCount; lCnt++)
    {
        IWbemClassObject * pNewInst = pObjArray[lCnt];

        gClassCnt++;

 //       pNewInst->Release();
    }
    return  S_OK;
}

SCODE CNotify::SetStatus( 
            /* [in] */ long lFlags,
            /* [in] */ long lParam,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam)
{

    printf("  %d classes ", gClassCnt);
    SetEvent(gAsyncTest);
    return  S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\trantest\trantest.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    TRANTEST.CPP

Abstract:

    Purpose: Exercises the various transports both locally and remotely.

History:

--*/

#include "precomp.h"
#include <stdio.h>
#include <assert.h>
#include <time.h>
#include <wbemidl.h> 
#include <objidl.h>
#include "notify.h"
#include "cominit.h"

extern HANDLE gAsyncTest;
extern DWORD gClassCnt;
extern BOOL bVerbose;
IWbemClassObject * gpError;
BSTR bstrUser;
BSTR bstrPassword;

#define BUFF_SIZE 256
SCODE sc;
#define ASYNC_WAIT 60000

CNotify gNotify;
#define MAX_MACH 10

char Machines[MAX_MACH][MAX_PATH];
int iRemote = 0;
char cUser[MAX_PATH];
char cPassword[MAX_PATH];
char cRemProt[20] = "D";
char cLocalProt[20] = "AD";
int iNumRepeat = 1;
int iFlags = 0;


//***************************************************************************
//
//  int Trace
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//  *fmt                format string.  Ex "%s hello %d"
//  ...                 argument list.  Ex cpTest, 23
//
//  RETURN VALUE:
//
//  size of output in characters.
//***************************************************************************

int Trace(
                        const char *fmt,
                        ...)
{

    static BOOL bFileDontWork = FALSE;
    FILE *fp = NULL;

    char *buffer = new char[2048];

    va_list argptr;
    int cnt;
    va_start(argptr, fmt);
    cnt = _vsnprintf(buffer, 2048, fmt, argptr);
    va_end(argptr);

    printf("%s", buffer);
 

    delete buffer;
    return cnt;
}


//***************************************************************************
//
// printvar
//
// Purpose: Prints out a VARIANTARG bstr value.
//
//***************************************************************************

void printvar(char * pText,VARIANTARG * pVar)
{
    char cStuff[BUFF_SIZE];
    if(pVar->vt == VT_BSTR) {
        wcstombs(cStuff,pVar->bstrVal,256);
        Trace("\n%s is %s",pText,cStuff);
        }
}

//***************************************************************************
//
// ListClasses
//
// Purpose:  Shows use of CreateSyncClassEnum and the use of the enumerator. 
//
//***************************************************************************

void ListClasses(IWbemServices * pProv)
{
    IWbemClassObject * pNewInst[100];
    int iClassObj = 0;
    DWORD dwStart = GetTickCount();
    IEnumWbemClassObject FAR* pIEnum = NULL;
    sc = pProv->CreateClassEnum(NULL,0l,NULL, &pIEnum);        
    if(sc != S_OK)
    {
        Trace(" - CreateClassEnum failed, sc = 0x%0x", sc);
        exit(1);
    }

    SetInterfaceSecurity(pIEnum, NULL, bstrUser, bstrPassword, pProv);

    while (sc == S_OK) 
    {
        ULONG uRet;
        for(int i = 0; i < 100; i++)
            pNewInst[i] = 0;
        sc = pIEnum->Next(-1,100,pNewInst,&uRet);
        if(!SUCCEEDED(sc) || uRet < 1)
            break;

        for(unsigned uObj = 0; uObj < uRet; uObj++)
        {
            iClassObj++;

            VARIANT var;
            VariantInit(&var);      // sets type to empty

            sc = (pNewInst[uObj])->Get(L"__Class",0,&var,NULL,NULL);
            if(bVerbose)
                printvar("__Class",&var);
            VariantClear(&var);
            (pNewInst[uObj])->Release();
        }
    }
    if(pIEnum)
       pIEnum->Release();
    if(iClassObj > 0)
    {
        Trace("\n - sync test got %d objects in %d ms -", iClassObj, GetTickCount() - dwStart);
    }
    else
    {
        Trace(" - sync test failed -");
        exit(1);
    }
}

//***************************************************************************
//
// CreateClassEnumAsynTest
//
//***************************************************************************

void CreateClassEnumAsynTest(IWbemServices * pProv)
{
    SCODE sc;
    DWORD dwRet;
    DWORD dwStart = GetTickCount();

    Trace("\n - Async test ");

    ResetEvent(gAsyncTest);
    gClassCnt = 0;
    gNotify.AddRef();
    sc = pProv->CreateClassEnumAsync(NULL,0, NULL, &gNotify);
    dwRet = WaitForSingleObject(gAsyncTest,ASYNC_WAIT);
    if(dwRet != WAIT_OBJECT_0)
    {
        Trace("\n async wait timed out");
        exit(1);
    }
    Trace("in %d ms - ", GetTickCount() - dwStart);
}

//***************************************************************************
//
// ProcessArgs
//
// Purpose:  Processes the command line arguments.
//
//***************************************************************************


BOOL ProcessArgs(int iArgc,char ** argv)
{
    cPassword[0] = 0;

    for(int iArg = 1; iArg < iArgc; iArg++)
    {
        if(argv[iArg][0] != '/' && argv[iArg][0] != '-')
        {
            if(iRemote+1 >= MAX_MACH)
            {
                Trace("\nError, max of %d machine names", MAX_MACH);
                return FALSE;
            }
            lstrcpy(Machines[iRemote++], argv[iArg]);
        }
        else if (toupper(argv[iArg][1]) == 'U')
        {
            lstrcpy(cUser, argv[iArg]+2);
            WCHAR wTemp[100];
            mbstowcs(wTemp, cUser, 100);
            bstrUser = SysAllocString(wTemp);
        }
        else if (toupper(argv[iArg][1]) == 'P')
        {
            lstrcpy(cPassword, argv[iArg]+2);
            WCHAR wTemp[100];
            mbstowcs(wTemp, cPassword, 100);
            bstrPassword = SysAllocString(wTemp);
        }

        else if (toupper(argv[iArg][1]) == 'N')
        {
            iNumRepeat = atoi(argv[iArg]+2);
            if(iNumRepeat < 1 || iNumRepeat > 10000000)
            {
                Trace("\nThe number of repeats - %d - is invalid", iNumRepeat);
                return FALSE;
            }
        }
        else
        {
            Trace("\nUsage TranTest [/U<User>] [/P<Password>] [/R<remoteprotcols]");
            Trace("\n               [/L<localProtocols>] [/N<numberOfCalls>] [/F<loginflags>]RemotesMachine....");
            Trace("\n\n Example c:>TranTest /N3 /UAdministrator a-davj");
            return FALSE;
        }
    }

    return TRUE;
}

//***************************************************************************
//
// TestIt
//
// Purpose:  Connects up and then runs a few tests.
//
//***************************************************************************


void TestIt(   IWbemLocator *pLocator, char * pMachine)
{

    IWbemServices *pSession = 0;


    // Connect up with the server

    WCHAR wPath[MAX_PATH];
    if(pMachine)
    {
        WCHAR wMachine[MAX_PATH];
        mbstowcs(wMachine, pMachine, MAX_PATH);
        wcscpy(wPath, L"\\\\");
        wcscat(wPath, wMachine);
        wcscat(wPath, L"\\");
    }
    else
        wPath[0] = 0;
    wcscat(wPath, L"root\\default");

    BSTR path = SysAllocString(wPath);

    sc = pLocator->ConnectServer(path, bstrUser, bstrPassword,0,iFlags,NULL,NULL,&pSession);
    SysFreeString(path);

    if(sc != S_OK)
    {
        printf("\n ConnectServer failed, sc = 0x%x", sc);
        return;
    }

    // do the tests
    ListClasses(pSession);
    CreateClassEnumAsynTest(pSession);
    pSession->Release();

}


//***************************************************************************
//
// main
//
// Purpose: Initialized Ole, calls some test code, cleans up and exits.
//
//***************************************************************************

BOOL g_bInProc = FALSE;
 
int __cdecl main(int iArgCnt, char ** argv)
{
    BOOL bVerbose = FALSE;
    gAsyncTest = CreateEvent(NULL,FALSE,FALSE,NULL);

    IWbemLocator *pLocator = 0;
    IWbemClassObject * pInst = NULL;

    if(!ProcessArgs(iArgCnt, argv))
        exit(1);

    HRESULT hr = InitializeCom();

    if (hr != S_OK)
    {
        Trace("\nOle Initialization failed.\n");
        return -1;
    }

    hr = InitializeSecurity(NULL, -1, NULL, NULL, 
                                RPC_C_AUTHN_LEVEL_NONE, 
                                RPC_C_IMP_LEVEL_IDENTIFY, 
                                NULL, EOAC_NONE, 0);

    
    // OLE initialization. 
    // =================== 

    LPUNKNOWN punk = NULL;


    // Hook up with the locator.  If this does not work, make sure that the
    // provider's registry entries are OK.

        sc = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, (LPVOID *) &pLocator);

        if(sc != S_OK)
        {
            Trace("\nCoCreateInstance failed!!!! sc = 0x%0x",sc);
            return 1;
        }

        for(int iNum = 0; iNum < iNumRepeat; iNum++)
        {

            // Get time.
    
            char timebuf[64];
            time_t now = time(0);
            struct tm *local = localtime(&now);
            strcpy(timebuf, asctime(local));
            timebuf[strlen(timebuf) - 1] = 0;   // O
    
            // Get Computer Name

            char cName[MAX_COMPUTERNAME_LENGTH +1];
            DWORD dwlen = MAX_COMPUTERNAME_LENGTH +1;
            BOOL bRet = GetComputerName(cName, &dwlen);

            Trace("\n\nStarting test %d of %d at %s running on machine %s",
                iNum+1, iNumRepeat, timebuf, cName);


            for(int iMachine = 0; iMachine < iRemote; iMachine++)
            {
                Trace("\n\nDoing remote test to machine %s",
                    Machines[iMachine]);

                TestIt(pLocator, Machines[iMachine]);
            }


        }
       pLocator->Release(); 

    CoUninitialize();
    Trace("Terminating normally\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\trantest\notify.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    NOTIFY.H

Abstract:

History:

--*/

#define PPVOID void **

class CNotify : public IWbemObjectSink
    {
    protected:
        ULONG           m_cRef;         //Object reference count

    public:
        ULONG GetCount(void){return m_cRef;};
        CNotify();
        ~CNotify(void);
        BOOL Init(void);
        
        //Non-delegating object IUnknown
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

    STDMETHOD(GetTypeInfoCount)(THIS_ UINT FAR* pctinfo);

    STDMETHOD(GetTypeInfo)(
      THIS_
      UINT itinfo,
      LCID lcid,
      ITypeInfo FAR* FAR* pptinfo);

    STDMETHOD(GetIDsOfNames)(
      THIS_
      REFIID riid,
      OLECHAR FAR* FAR* rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID FAR* rgdispid);

    STDMETHOD(Invoke)(
      THIS_
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS FAR* pdispparams,
      VARIANT FAR* pvarResult,
      EXCEPINFO FAR* pexcepinfo,
      UINT FAR* puArgErr);

    /* IWbemNotify methods */

	    HRESULT STDMETHODCALLTYPE Indicate( 
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObjArray);
        
        HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ long lFlags,
            /* [in] */ long lParam,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam);
     
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\classfac.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CLASSFAC.CPP

Abstract:

    Contains the class factory.  This creates objects when
    connections are requested.

History:

    a-davj  04-Mar-97   Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <wbemint.h>
#include <reg.h>
#include <umi.h>
#include "wbemprox.h"
#include "locator.h"
#include "cprovloc.h"
#include "comtrans.h"
#include "localadd.h"
#include "dssvexwrap.h"

//***************************************************************************
//
// CLocatorFactory::CLocatorFactory
//
// DESCRIPTION:
//
// Constructor
//
//***************************************************************************

CLocatorFactory::CLocatorFactory(DWORD dwType)
{
    m_cRef=0L;
    m_dwType = dwType;
    ObjectCreated(CLASS_FACTORY);
    return;
}

//***************************************************************************
//
// CLocatorFactory::~CLocatorFactory
//
// DESCRIPTION:
//
// Destructor
//
//***************************************************************************

CLocatorFactory::~CLocatorFactory(void)
{
    ObjectDestroyed(CLASS_FACTORY);
    return;
}

//***************************************************************************
//
// CLocatorFactory::QueryInterface
// CLocatorFactory::AddRef
// CLocatorFactory::Release
//
// Purpose: Standard Ole routines needed for all interfaces
//
//***************************************************************************


STDMETHODIMP CLocatorFactory::QueryInterface(REFIID riid
    , PPVOID ppv)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
        *ppv=this;

    if (NULL!=*ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
        }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CLocatorFactory::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CLocatorFactory::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;

    delete this;
    return 0L;
}

//***************************************************************************
//
//  SCODE CLocatorFactory::CreateInstance
//
//  Description: 
//
//  Instantiates a Provider object returning an interface pointer.
//
//  Parameters:
//
//  pUnkOuter       LPUNKNOWN to the controlling IUnknown if we are
//                  being used in an aggregation.
//  riid            REFIID identifying the interface the caller
//                  desires to have for the new object.
//  ppvObj          PPVOID in which to store the desired
//                  interface pointer for the new object.
//
// Return Value:
//  HRESULT         NOERROR if successful, otherwise E_NOINTERFACE
//                  if we cannot support the requested interface.
//***************************************************************************

STDMETHODIMP CLocatorFactory::CreateInstance(
                        IN LPUNKNOWN pUnkOuter,
                        IN REFIID riid, 
                        OUT PPVOID ppvObj)
{
    IUnknown *   pObj = NULL;
    HRESULT             hr;

    *ppvObj=NULL;
    hr=E_OUTOFMEMORY;

    // This object doesnt support aggregation.

    if (NULL!=pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    //Create the object passing function to notify on destruction.
    
    if(m_dwType == LOCATOR)
        pObj=new CLocator();
    else if(m_dwType == DCOMTRAN)
        pObj=(IWbemClientTransport *)new CDCOMTrans();
    else if(m_dwType == LOCALADDR)
        pObj=new CLocalAdd();
    else if(m_dwType == CONNECTION)
        pObj=new CConnection();
//    else if(m_dwType == DSSVEX)
//        pObj=(IWbemServicesEx*) new CDSSvcExWrapper();
    else if(m_dwType == ADMINLOC)
        pObj= new CProviderLoc(ADMINLOC);
    else if(m_dwType == AUTHLOC)
        pObj= new CProviderLoc(AUTHLOC);
    else if(m_dwType == UNAUTHLOC)
        pObj= new CProviderLoc(UNAUTHLOC);

    if (NULL==pObj)
        return hr;

    hr=pObj->QueryInterface(riid, ppvObj);

    //Kill the object if initial creation or Init failed.
    if (FAILED(hr))
        delete pObj;
    return hr;
}

//***************************************************************************
//
//  SCODE CLocatorFactory::LockServer
//
//  Description:
//
//  Increments or decrements the lock count of the DLL.  If the
//  lock count goes to zero and there are no objects, the DLL
//  is allowed to unload.  See DllCanUnloadNow.
//
//  Parameters:
//
//  fLock           BOOL specifying whether to increment or
//                  decrement the lock count.
//
//  Return Value:
// 
//  HRESULT         NOERROR always.
//***************************************************************************


STDMETHODIMP CLocatorFactory::LockServer(IN BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((long *)&g_cLock);
    else
        InterlockedDecrement((long *)&g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\trantest\testagft\main.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MAIN.CPP

Abstract:

History:

--*/

#define _WIN32_WINNT    0x0400

#include "precomp.h"
#include <stdio.h>
#include <objbase.h>

#include <time.h>
#include <locale.h>
#include <wbemidl.h>

#include <cominit.h>
#include <wbemcomn.h>

IWbemLocator    *g_pLocator = NULL;


DWORD WINAPI ThreadFunc (LPVOID lpvThreadParm)
{
    InitializeCom ();
    IStream *pStream = (IStream *) lpvThreadParm;
    IWbemServices *pService = NULL;

    if (S_OK == CoGetInterfaceAndReleaseStream (pStream, 
            IID_IWbemServices, (LPVOID*) &pService))
    {
        IWbemClassObject *pClass = NULL;
        if (WBEM_NO_ERROR == pService->GetObject (L"__Namespace", 0, NULL, &pClass, NULL))
        {
            pClass->Release ();
        }

        pService->Release ();
    }

    CoUninitialize ();
    return 0;
}

int WINAPI WinMain (HINSTANCE hInst,
    HINSTANCE hPrevInst,
    PSTR szCmdLine,
    int iCmdShow)
{
    InitializeCom ();

    if (S_OK != CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, (LPVOID *) &g_pLocator))
    {
        CoUninitialize ();
        return -1;
    }

    // Connect to root\default
    IWbemServices   *pService = NULL;
    if (S_OK != g_pLocator->ConnectServer (L"root/default", NULL, NULL, NULL,
                0, NULL, NULL, &pService))
    {
        CoUninitialize ();
        return -1;
    }

    // Create a thread to perform an operation on the IWbemServices pointer
    HANDLE  hThreads [1];
    DWORD   dwThreadId = 0;

    // Marshal the interface across threads
    IStream *pStream = NULL;
        
    HRESULT hRes = CoMarshalInterThreadInterfaceInStream (IID_IWbemServices, 
                (IUnknown *) pService, &pStream);
 
    hThreads [0] = CreateThread (NULL, 0, ThreadFunc, (LPVOID) pStream, 0, &dwThreadId);

    // Wait for the thread to complete
    WaitForMultipleObjects (1, hThreads, TRUE, INFINITE);
    CloseHandle (hThreads [0]);

    pService->Release ();
    g_pLocator->Release ();

    CoUninitialize ();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\comtrans.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    COMTRANS.CPP

Abstract:

    Connects via COM

History:

    a-davj  13-Jan-98   Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <wbemint.h>
//#include "corepol.h"
#include <reg.h>
#include <wbemutil.h>
#include <objidl.h>
#include <cominit.h>
#include "wbemprox.h"
#include "comtrans.h"
#include "proxutil.h"
#include <winntsec.h>
#include <genutils.h>
//#include <winntsec.h>
#include <arrtempl.h>
#include <umi.h>
#include <wmiutils.h>
#include "dscallres.h"
#include "reqobjs.h"
#include "dssvexwrap.h"
#include "utils.h"

//***************************************************************************
//
//  CDCOMTrans::CDCOMTrans
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CDCOMTrans::CDCOMTrans()
{
    m_cRef=0;
    m_pLevel1 = NULL;
    m_pConnection = NULL;
    m_pUnk = NULL;              // dont free
    InterlockedIncrement(&g_cObj);
    m_bInitialized = TRUE;
}

//***************************************************************************
//
//  CDCOMTrans::~CDCOMTrans
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CDCOMTrans::~CDCOMTrans(void)
{
    if(m_pLevel1)
        m_pLevel1->Release();
    if(m_pConnection)
        m_pConnection->Release();
    InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CDCOMTrans::QueryInterface
// long CDCOMTrans::AddRef
// long CDCOMTrans::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CDCOMTrans::QueryInterface (

    IN REFIID riid,
    OUT PPVOID ppv
)
{
    *ppv=NULL;


    if (m_bInitialized && (IID_IUnknown==riid || riid == IID_IWbemClientTransport))
        *ppv=(IWbemClientTransport *)this;
	else if(riid == IID_IWbemConnection)
		*ppv=(IWbemConnection *)this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

bool IsImpersonating(SECURITY_IMPERSONATION_LEVEL &impLevel)
{
    HANDLE hThreadToken;
    bool bImpersonating = false;
    if(OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE,
                                &hThreadToken))
    {

        DWORD dwBytesReturned = 0;
        if(GetTokenInformation(
            hThreadToken,
            TokenImpersonationLevel,
            &impLevel,
            sizeof(DWORD),
            &dwBytesReturned
            ) && ((SecurityImpersonation == impLevel) ||
                   (SecurityDelegation == impLevel)))
                bImpersonating = true;
        CloseHandle(hThreadToken);
    }
    return bImpersonating;
}

//***************************************************************************
//
//  IsLocalConnection(IWbemLevel1Login * pLogin)
//
//  DESCRIPTION:
//
//  Querries the server to see if this is a local connection.  This is done
//  by creating a event and asking the server to set it.  This will only work
//  if the server is the same box.
//
//  RETURN VALUE:
//
//  true if the server is the same box.
//
//***************************************************************************

bool IsLocalConnection(IUnknown * pLogin, bool bSet, BSTR PrincipalArg, bool bAuthenticate,
             COAUTHIDENTITY *pauthident, bool bImpersonatingThread, BSTR UserArg)
{
    bool bRet = false;
    IWbemLoginHelper * pLoginHelper = NULL;
    SCODE sc = pLogin->QueryInterface(IID_IWbemLoginHelper, (void **)&pLoginHelper);
    if(sc != S_OK)
        return false;

    if(bSet)
        sc = WbemSetProxyBlanket(
                            pLoginHelper,
                            (PrincipalArg) ? 16 : RPC_C_AUTHN_WINNT,
                            RPC_C_AUTHZ_NONE,
                            PrincipalArg,
                            (bAuthenticate) ? RPC_C_AUTHN_LEVEL_DEFAULT : RPC_C_AUTHN_LEVEL_NONE,
                            RPC_C_IMP_LEVEL_IMPERSONATE,
                            pauthident,
                            (bImpersonatingThread && !UserArg && IsW2KOrMore ()) ? EOAC_STATIC_CLOAKING : EOAC_NONE);

    CReleaseMe rm(pLoginHelper);
    GUID  guid;

    // The name of the event will be a guid

    sc = CoCreateGuid(&guid);
    if(sc != S_OK)
        return false;
    WCHAR      wcID[50];
    if(0 ==StringFromGUID2(guid, wcID, 50))
        return false;

    char cID[50];
    wcstombs(cID, wcID, 50);
    // Create the event and set its security so that all can access
#ifdef UNICODE
    HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, wcID);
#else
    HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, cID);
#endif
    if(hEvent == NULL)
        return false;
    SetObjectAccess(hEvent);
    CCloseMe cm(hEvent);

    // Ask the server to set the event.

    sc = pLoginHelper->SetEvent(cID);
    if(sc == S_OK)
    {
        DWORD dwRes = WaitForSingleObject(hEvent, 0);
        if(dwRes == WAIT_OBJECT_0)
            return true;
    }
    return false;

}

//***************************************************************************
//
//  SetClientIdentity
//
//  DESCRIPTION:
//
//  Passes the machine name and process id to the server.  Failure is not
//  serious since this is debugging type info in any case.
//
//***************************************************************************

void  SetClientIdentity(IUnknown * pLogin, bool bSet, BSTR PrincipalArg, bool bAuthenticate,
             COAUTHIDENTITY *pauthident, bool bImpersonatingThread, BSTR UserArg)
{
    bool bRet = false;
    IWbemLoginClientID * pLoginHelper = NULL;
    SCODE sc = pLogin->QueryInterface(IID_IWbemLoginClientID, (void **)&pLoginHelper);
    if(sc != S_OK)
        return;

    if(bSet)
        sc = WbemSetProxyBlanket(
                            pLoginHelper,
                            (PrincipalArg) ? 16 : RPC_C_AUTHN_WINNT,
                            RPC_C_AUTHZ_NONE,
                            PrincipalArg,
                            (bAuthenticate) ? RPC_C_AUTHN_LEVEL_DEFAULT : RPC_C_AUTHN_LEVEL_NONE,
                            RPC_C_IMP_LEVEL_IMPERSONATE,
                            pauthident,
                            (bImpersonatingThread && !UserArg && IsW2KOrMore ()) ? EOAC_STATIC_CLOAKING : EOAC_NONE);

    CReleaseMe rm(pLoginHelper);
    TCHAR tcMyName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;
    if(!GetComputerName(tcMyName,&dwSize))
        return;
    long lProcID = GetCurrentProcessId();
    pLoginHelper->SetClientInfo(tcMyName, lProcID, 0); 
}

SCODE CDCOMTrans::DoConnection(         
            BSTR NetworkResource,               
            BSTR User,
            BSTR Password,
            BSTR Locale,
            long lFlags,                 
            BSTR Authority,                  
            IWbemContext *pCtx,                 
            REFIID riid,
            void **pInterface,
            bool bUseLevel1Login)
{
	HRESULT hr = DoActualConnection(NetworkResource, User, Password, Locale,
            lFlags, Authority, pCtx, riid, pInterface, bUseLevel1Login);

	if(hr == 0x800706be)
	{
        ERRORTRACE((LOG_WBEMPROX,"Initial connection failed with 0x800706be, retrying\n"));
		Sleep(5000);
 		hr = DoActualConnection(NetworkResource, User, Password, Locale,
            lFlags, Authority, pCtx, riid, pInterface, bUseLevel1Login);
	}
	return hr;
}

SCODE CDCOMTrans::DoActualConnection(         
            BSTR NetworkResource,               
            BSTR User,
            BSTR Password,
            BSTR Locale,
            long lFlags,                 
            BSTR Authority,                  
            IWbemContext *pCtx,                 
            REFIID riid,
            void **pInterface,
            bool bUseLevel1Login)
{

    BSTR AuthArg = NULL, UserArg = NULL, PrincipalArg = NULL;
    LPWSTR pNTDomain = NULL;
    bool bAuthenticate = true;
    bool bSet = false;
    char *szUser = NULL, * szDomain = NULL, *szPassword = NULL;

	SCODE sc = WBEM_E_FAILED;

	// The GetDSNs handles the paths that are ds specific.  If it returns true,
	// then we are done.

	//postponed till Blackcomb if(GetDSNs(User, Password, lFlags, NetworkResource, (IWbemServices **)pInterface, sc, pCtx))
	//postponed till Blackcomb 	return sc;

    sc = DetermineLoginTypeEx(AuthArg, UserArg, PrincipalArg, Authority, User);
    if(sc != S_OK)
    {
        ERRORTRACE((LOG_WBEMPROX, "Cannot determine Login type, Authority = %S, User = %S\n",Authority, User));
        return sc;
    }

    // Determine if it is local

    WCHAR *t_ServerMachine = ExtractMachineName ( NetworkResource ) ;
    if ( t_ServerMachine == NULL )
    {
        ERRORTRACE((LOG_WBEMPROX, "Cannot extract machine name -%S-\n", NetworkResource));
        return WBEM_E_INVALID_PARAMETER ;
    }
    CVectorDeleteMe<WCHAR> dm(t_ServerMachine);
    BOOL t_Local = bAreWeLocal ( t_ServerMachine ) ;

    SECURITY_IMPERSONATION_LEVEL impLevel = SecurityImpersonation;
    bool bImpersonatingThread = IsImpersonating (impLevel);
    bool bCredentialsSpecified = (UserArg || AuthArg || Password);

    // Setup the authentication structures

    COSERVERINFO si;
    si.pwszName = t_ServerMachine;
    si.dwReserved1 = 0;
    si.dwReserved2 = 0;
    si.pAuthInfo = NULL;

    COAUTHINFO ai;

    if(bCredentialsSpecified)
        si.pAuthInfo = &ai;
    else
        si.pAuthInfo = NULL;

    ai.dwAuthzSvc = RPC_C_AUTHZ_NONE;
    if(PrincipalArg)
    {
        ai.dwAuthnSvc = 16;             // kerberos,  hard coded due to header file bug!
        ai.pwszServerPrincName = PrincipalArg;
    }
    else
    {
        ai.dwAuthnSvc = RPC_C_AUTHN_WINNT;
        ai.pwszServerPrincName = NULL;
    }
    ai.dwAuthnLevel = RPC_C_AUTHN_LEVEL_DEFAULT;
    ai.dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
    ai.dwCapabilities = 0;

    COAUTHIDENTITY authident;
    ai.pAuthIdentityData = &authident;

    // Load up the structure.
    memset((void *)&authident,0,sizeof(COAUTHIDENTITY));
    if(IsNT())
    {
        if(UserArg)
        {
            authident.UserLength = wcslen(UserArg);
            authident.User = (LPWSTR)UserArg;
        }
        if(AuthArg)
        {
            authident.DomainLength = wcslen(AuthArg);
            authident.Domain = (LPWSTR)AuthArg;
        }
        if(Password)
        {
            authident.PasswordLength = wcslen(Password);
            authident.Password = (LPWSTR)Password;
        }
        authident.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
    }
    else
    {
        // Fill in the indentity structure

        if(UserArg)
        {
        	szUser = new char[MAX_PATH+1];
        	if(szUser == NULL)
        		return WBEM_E_OUT_OF_MEMORY;
            wcstombs(szUser, UserArg, MAX_PATH);
            authident.UserLength = strlen(szUser);
            authident.User = (LPWSTR)szUser;
        }
        if(AuthArg)
        {
        	szDomain = new char[MAX_PATH+1]; 
        	if(szDomain == NULL)
        	{
				delete [] szUser;        		
        		return WBEM_E_OUT_OF_MEMORY;
        	}
            wcstombs(szDomain, AuthArg, MAX_PATH);
            authident.DomainLength = strlen(szDomain);
            authident.Domain = (LPWSTR)szDomain;
        }
        if(Password)
        {
        	szPassword = new char[MAX_PATH+1]; 
        	if(szPassword == NULL)
        	{
				delete [] szUser; 
				delete [] szDomain;
        		return WBEM_E_OUT_OF_MEMORY;
        	}
            wcstombs(szPassword, Password, MAX_PATH);
            authident.PasswordLength = strlen(szPassword);
            authident.Password = (LPWSTR)szPassword;
        }
        authident.Flags = SEC_WINNT_AUTH_IDENTITY_ANSI;
    }
    CVectorDeleteMe<char> dm1(szUser);
    CVectorDeleteMe<char> dm2(szDomain);
    CVectorDeleteMe<char> dm3(szUser);
    

    // Nt 4.0 rpc crashes if given a null domain name along with a valid user name
	// [marioh, NT RAID: 239135, 03/03/2001]
    /*if(authident.DomainLength == 0 && authident.UserLength > 0 && IsNT())
    {

        CNtSid::SidType st = CNtSid::CURRENT_USER;
        if(bImpersonatingThread)
            st = CNtSid::CURRENT_THREAD;
        CNtSid sid(st);
        DWORD dwRet = sid.GetInfo(NULL, &pNTDomain, NULL);
        if(dwRet == 0)
        {
            authident.DomainLength = wcslen(pNTDomain);
            authident.Domain = (LPWSTR)pNTDomain;
        }
    }*/

    // Nt 4.0 rpc crashes if given a null domain and null user name along with a password

    if(authident.DomainLength == 0 && authident.UserLength == 0 && authident.PasswordLength > 0
                && IsNT() && !IsW2KOrMore())
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    // Get the IWbemLevel1Login pointer

    sc = DoCCI(&si ,t_Local, bUseLevel1Login, lFlags);

    if((sc == 0x800706d3 || sc == 0x800706ba) && !t_Local)
    {
        // If we are going to a stand alone dcom box, try again with the authentication level lowered

        ai.dwAuthnLevel = RPC_C_AUTHN_LEVEL_NONE;
        SCODE hr = DoCCI(&si ,t_Local, bUseLevel1Login, lFlags);
        if(hr == S_OK)
        {
            sc = S_OK;
            bAuthenticate = false;
        }
    }
    if(sc == 0x80080005 && t_Local)
    {
        // special patch for the case where win98 occasionally loses its class factory registration;

        HANDLE hNeedRegistration = OpenEvent(EVENT_MODIFY_STATE , FALSE, TEXT("WINMGMT_NEED_REGISTRATION"));
        HANDLE hRegistrationDone = OpenEvent(EVENT_MODIFY_STATE , FALSE, TEXT("WINMGMT_REGISTRATION_DONE"));
        if(hNeedRegistration && hRegistrationDone)
        {
            ResetEvent(hRegistrationDone);
            SetEvent(hNeedRegistration);
            WaitForSingleObject(hRegistrationDone, 30000);
            sc = DoCCI(&si ,t_Local, bUseLevel1Login,lFlags);
            CloseHandle(hNeedRegistration);
            CloseHandle(hRegistrationDone);
        }

    }

    if(sc != S_OK)
        goto cleanup;

    // Do the security negotiation

    if(!t_Local)
    {
        // Suppress the SetBlanket call if we are on a Win2K delegation-level thread with implicit credentials
        if (!(bImpersonatingThread && IsW2KOrMore() && !bCredentialsSpecified && (SecurityDelegation == impLevel)))
        {
            // Note that if we are on a Win2K impersonating thread with no user specified
            // we should allow DCOM to use whatever EOAC capabilities are set up for this
            // application.  This allows remote connections with NULL User/Password but
            // non-NULL authority to succeed.

            sc = WbemSetProxyBlanket(
                            m_pUnk,
                            (PrincipalArg) ? 16 : RPC_C_AUTHN_WINNT,
                            RPC_C_AUTHZ_NONE,
                            PrincipalArg,
                            (bAuthenticate) ? RPC_C_AUTHN_LEVEL_DEFAULT : RPC_C_AUTHN_LEVEL_NONE,
                            RPC_C_IMP_LEVEL_IMPERSONATE,
                            (bCredentialsSpecified) ? &authident : NULL,
                            (bImpersonatingThread && !UserArg && IsW2KOrMore ()) ? EOAC_STATIC_CLOAKING : EOAC_NONE);

            bSet = true;
            if(sc != S_OK)
            {
                ERRORTRACE((LOG_WBEMPROX,"Error setting Level1 login interface security pointer, return code is 0x%x\n", sc));
                goto cleanup;
            }
        }
    }
	else
	{
		// if impersonating and nt5, then set cloaking

		if(bImpersonatingThread && IsW2KOrMore())
		{
			sc = WbemSetProxyBlanket(
						    m_pUnk,
							RPC_C_AUTHN_WINNT,
							RPC_C_AUTHZ_NONE,
						    PrincipalArg,
						    (bAuthenticate) ? RPC_C_AUTHN_LEVEL_DEFAULT : RPC_C_AUTHN_LEVEL_NONE,
						    RPC_C_IMP_LEVEL_IMPERSONATE,
                            NULL,
							EOAC_STATIC_CLOAKING);	
			if(sc != S_OK && sc != 0x80004002)  // no such interface is ok since you get that when
                                                // called inproc!
			{
				ERRORTRACE((LOG_WBEMPROX,"Error setting Level1 login interface security pointer, return code is 0x%x\n", sc));
				goto cleanup;
			}
		}

	}

    SetClientIdentity(m_pUnk, bSet, PrincipalArg, 
                                 bAuthenticate, &authident, bImpersonatingThread, UserArg);
    if(bCredentialsSpecified &&
        IsLocalConnection(m_pUnk, bSet, PrincipalArg, 
                                 bAuthenticate, &authident, bImpersonatingThread, UserArg))
    {
        ERRORTRACE((LOG_WBEMPROX,"Credentials were specified for a local connections\n"));
        sc = WBEM_E_LOCAL_CREDENTIALS;
        goto cleanup;
    }

    // The MAX_WAIT flag only applies to CoCreateInstanceEx, get rid of it
    
    lFlags = lFlags & ~WBEM_FLAG_CONNECT_USE_MAX_WAIT;
    if(m_pLevel1)
        sc = m_pLevel1->NTLMLogin(NetworkResource, Locale, lFlags, pCtx,(IWbemServices**) pInterface);
    else
        sc = m_pConnection->ConnectorLogin(NetworkResource, Locale, lFlags, 
                                                            pCtx, riid, pInterface);

    if(sc == 0x800706d3 && !t_Local)
    {
        // If we are going to a stand alone dcom box, try again with the authentication level lowered

        HRESULT hr;
        if(m_pLevel1)
            hr = m_pLevel1->NTLMLogin(NetworkResource, Locale, lFlags, pCtx, (IWbemServices**)pInterface);
        else
            hr = m_pConnection->ConnectorLogin(NetworkResource, Locale, lFlags, 
                                                            pCtx, riid, pInterface);
        if(hr == S_OK)
        {
            sc = S_OK;
            SetInterfaceSecurity((IUnknown *)*pInterface, &authident, false);
        }
    }

    if((sc != S_OK) && (sc != WBEM_E_INVALID_NAMESPACE))
            ERRORTRACE((LOG_WBEMPROX,"NTLMLogin resulted in hr = 0x%x\n", sc));
    else
cleanup:
    if(UserArg)
        SysFreeString(UserArg);
    if(PrincipalArg)
        SysFreeString(PrincipalArg);
    if(AuthArg)
        SysFreeString(AuthArg);
    if(pNTDomain)
        delete pNTDomain;
    return sc;
}


//***************************************************************************
//
//  SCODE CDCOMTrans::ConnectServer
//
//  DESCRIPTION:
//
//  Connects up to either local or remote WBEM Server.  Returns
//  standard SCODE and more importantly sets the address of an initial
//  stub pointer.
//
//  PARAMETERS:
//
//  AddressType             Not used
//  dwBinaryAddressLength   Not used
//  pbBinaryAddress         Not used
//
//  NetworkResource     Namespace path
//  User                User name
//  Password            password
//  LocaleId            language locale
//  lFlags              flags
//  Authority           domain
//  ppProv              set to provdider proxy
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************


SCODE CDCOMTrans::ConnectServer (
    IN    BSTR AddressType,
    IN    DWORD dwBinaryAddressLength,
    IN    BYTE* pbBinaryAddress,

    IN BSTR NetworkResource,
    IN BSTR User,
    IN BSTR Password,
    IN BSTR LocaleId,
    IN long lFlags,
    IN BSTR Authority,
    IWbemContext __RPC_FAR *pCtx,
    OUT IWbemServices FAR* FAR* ppProv
)
{
	return DoConnection(NetworkResource, User, Password, LocaleId, lFlags,                 
            Authority, pCtx, IID_IWbemServices, (void **)ppProv, true);                 
}

struct WaitThreadArg
{
	DWORD m_dwThreadId;
	HANDLE m_hTerminate;
};

DWORD WINAPI TimeoutThreadRoutine(LPVOID lpParameter)
{

    WaitThreadArg * pReq = (WaitThreadArg *)lpParameter;
    DWORD dwRet = WaitForSingleObject(pReq->m_hTerminate, 60000);
    if(dwRet == WAIT_TIMEOUT)
    {
        HRESULT hr = CoInitializeEx(NULL,COINIT_MULTITHREADED ); 
        if(FAILED(hr))
           return 1;
        ICancelMethodCalls * px = NULL;
        hr = CoGetCancelObject(pReq->m_dwThreadId, IID_ICancelMethodCalls,
        	(void **)&px);
        if(SUCCEEDED(hr))
        {
        	hr = px->Cancel(0);
        	px->Release();
        }
        CoUninitialize();
    }
    return 0;
}

//***************************************************************************
//
//  DoCCI
//
//  DESCRIPTION:
//
//  Connects up to WBEM via DCOM.  But before making the call, a thread cancel
//  thread may be created to handle the case where we try to connect up
//  to a box which is hanging
//
//  PARAMETERS:
//
//  NetworkResource     Namespze path
//  ppLogin             set to Login proxy
//  bLocal              Indicates if connection is local
//  lFlags				Mainly used for WBEM_FLAG_CONNECT_USE_MAX_WAIT flag
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE CDCOMTrans::DoCCI (IN COSERVERINFO * psi, IN BOOL bLocal, bool bUseLevel1Login,long lFlags )
{

	if(lFlags & WBEM_FLAG_CONNECT_USE_MAX_WAIT)
	{
		// special case.  we want to spawn off a thread that will kill of our
		// request if it takes too long

		WaitThreadArg arg;
        arg.m_hTerminate = CreateEvent(NULL, FALSE, FALSE, NULL);
        if(arg.m_hTerminate == NULL)
        	return WBEM_E_OUT_OF_MEMORY;
        CCloseMe cm(arg.m_hTerminate);
        arg.m_dwThreadId = GetCurrentThreadId();

        DWORD dwIDLikeIcare;
        HRESULT hr = CoEnableCallCancellation(NULL);
        if(FAILED(hr))
            return hr;
        HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)TimeoutThreadRoutine, 
                                     (LPVOID)&arg, 0, &dwIDLikeIcare);
	    if(hThread == NULL)
	    {
    		CoDisableCallCancellation(NULL);						
		    return WBEM_E_OUT_OF_MEMORY;
	    }
		CCloseMe cm2(hThread);
		hr = DoActualCCI (psi, bLocal, bUseLevel1Login,
						lFlags & ~WBEM_FLAG_CONNECT_USE_MAX_WAIT );
		CoDisableCallCancellation(NULL);						
		SetEvent(arg.m_hTerminate);
		WaitForSingleObject(hThread, INFINITE);
		return hr;
	}
	else
    	return DoActualCCI (psi, bLocal, bUseLevel1Login, lFlags );

}

//***************************************************************************
//
//  DoActualCCI
//
//  DESCRIPTION:
//
//  Connects up to WBEM via DCOM.
//
//  PARAMETERS:
//
//  NetworkResource     Namespze path
//  ppLogin             set to Login proxy
//  bLocal              Indicates if connection is local
//  lFlags				Not used
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE CDCOMTrans::DoActualCCI (IN COSERVERINFO * psi, IN BOOL bLocal, bool bUseLevel1Login,long lFlags )
{
    HRESULT t_Result ;
    MULTI_QI   mqi;


    if(bUseLevel1Login)
        mqi.pIID = &IID_IWbemLevel1Login;
    else
        mqi.pIID = &IID_IWbemConnectorLogin;
    mqi.pItf = 0;
    mqi.hr = 0;

    t_Result = CoCreateInstanceEx (
        CLSID_WbemLevel1Login,
        NULL,
        CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER,
        ( bLocal ) ? NULL : psi ,
        1,
        &mqi
    );

    if ( t_Result == S_OK )
    {
        if(bUseLevel1Login)
             m_pLevel1 = (IWbemLevel1Login*) mqi.pItf ;
        else
             m_pConnection = (IWbemConnectorLogin*) mqi.pItf;
        m_pUnk = mqi.pItf;      // just a copy, dont release!
        DEBUGTRACE((LOG_WBEMPROX,"ConnectViaDCOM, CoCreateInstanceEx resulted in hr = 0x%x\n", t_Result ));
    }
    else
    {
        ERRORTRACE((LOG_WBEMPROX,"ConnectViaDCOM, CoCreateInstanceEx resulted in hr = 0x%x\n", t_Result ));
    }

    return t_Result ;
}

SCODE CDCOMTrans::Open(
        /* [in] */ const BSTR strObject,
        /* [in] */ const BSTR User,
        /* [in] */ const BSTR Password,
        /* [in] */ const BSTR Locale,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pInterface,
        /* [out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *pCallRes)
{

/*	// parse the path and get its info

    IWbemPath *pParser = 0;
	IWbemPathKeyList * pKeyList = NULL;
	IWbemServices * pServ = NULL;	

    SCODE sc = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemPath, (LPVOID *) &pParser);
    if(FAILED(sc))
        return sc;

    sc = pParser->SetText(WBEMPATH_CREATE_ACCEPT_ALL | WBEMPATH_TREAT_SINGLE_IDENT_AS_NS, strObject);
    if(FAILED(sc))
        return sc;

	unsigned __int64 ull;
	sc = pParser->GetInfo(0,&ull);
    if(FAILED(sc))
        return sc;

	// if the path is for the ds providers, special case them

	if((ull & WBEMPATH_INFO_NATIVE_PATH) || (ull & WBEMPATH_INFO_WMI_PATH))
	{
	
		IUmiURL * pUrlPath = NULL;
		sc = pParser->QueryInterface(IID_IUmiURL, (void **) &pUrlPath);
		if(FAILED(sc))
			return sc;
		CReleaseMe rm(pUrlPath);

		// if the clsid is a ds provider

		CLSID clsid;
		sc = GetProviderCLSID(clsid, pUrlPath);
		if(SUCCEEDED(sc))
		{
			sc = ConnectServer (NULL, 0, NULL, strObject, User, Password, Locale,
							lFlags, NULL, pCtx, &pServ);
			if(SUCCEEDED(sc))
			{
				sc =  pServ->QueryInterface(riid, pInterface);
				pServ->Release();
			}
			return sc;
		}
	}

	// Get the namespace path

	DWORD dwLen = wcslen(strObject) + 20;	// a bit extra for \\. and null terminator
	DWORD dwSize = dwLen;
	WCHAR * pNamespace = new WCHAR[dwLen];
	if(pNamespace == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	CDeleteMe<WCHAR> dm(pNamespace);
	sc = pParser->GetText(WBEMPATH_GET_SERVER_AND_NAMESPACE_ONLY, &dwSize, pNamespace);
    if(FAILED(sc))
        return sc;
*/
	// Get the actual namespace

    SCODE sc = S_OK;
	VARIANT var;
	VariantInit(&var);
	if(pCtx)
		sc = pCtx->GetValue(L"__authority", 0, &var);
    if(SUCCEEDED(sc) && pCtx)
	{
		sc = DoConnection (strObject, User, Password, Locale, 
					lFlags, var.bstrVal, pCtx, riid, pInterface, false); 
		VariantClear(&var);
	}
	else
		sc = DoConnection (strObject, User, Password, Locale, 
						lFlags, NULL, pCtx,  riid, pInterface, false); 
/*    if(FAILED(sc))
        return sc;
	CReleaseMe rm(pServ);

	// If path type is a namespace, then just return that

	if(WBEMPATH_INFO_SERVER_NAMESPACE_ONLY & ull)
		return pServ->QueryInterface(riid, pInterface);

	// otherwise, get the object path

	IWbemClassObject * pObj = NULL;
	dwSize = dwLen;
	sc = pParser->GetText(WBEMPATH_GET_RELATIVE_ONLY, &dwSize, pNamespace);
    if(FAILED(sc))
        return sc;

	BSTR strObjectPath = SysAllocString(pNamespace);
	if(strObjectPath == NULL)
		return WBEM_E_OUT_OF_MEMORY;

	sc = pServ->GetObject(strObjectPath, lFlags, pCtx, &pObj, NULL);
	SysFreeString(strObjectPath);
    if(FAILED(sc))
        return sc;

	return pObj->QueryInterface(riid, pInterface);
    */
    return sc;

}

SCODE CDCOMTrans::OpenAsync(
        /* [in] */ const BSTR strObject,
        /* [in] */ const BSTR strUser,
        /* [in] */ const BSTR strPassword,
        /* [in] */ const BSTR strLocale,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler)
{
	return WBEM_E_FAILED;
}

SCODE CDCOMTrans::Cancel(
        /* [in] */ long lFlags,
        /* [in] */ IWbemObjectSinkEx __RPC_FAR *pHandler)
{
	return WBEM_E_FAILED;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\comtrans.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    COMTRANS.H

Abstract:

    Declares the COM based transport class.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _DCOMTran_H_
#define _DCOMTran_H_

typedef void ** PPVOID;

//***************************************************************************
//
//  CLASS NAME:
//
//  CDCOMTran
//
//  DESCRIPTION:
//
//  Implements the DCOM version of CCOMTrans class.
//
//***************************************************************************

class CDCOMTrans : public IWbemClientTransport, public IWbemConnection
{
protected:
        long            m_cRef;         //Object reference count
        IWbemLevel1Login * m_pLevel1;
        IWbemConnectorLogin  * m_pConnection;
        IUnknown * m_pUnk;      // just a copy of m_pLevel1 or m_pConnection,
        BOOL m_bInitialized;
    
public:
    CDCOMTrans();
    ~CDCOMTrans();

    SCODE DoCCI (
    	IN COSERVERINFO *psi ,
        IN BOOL a_Local,
            bool bUseLevel1Login,long lFlags);

    SCODE DoActualCCI (
    	IN COSERVERINFO *psi ,
        IN BOOL a_Local,
            bool bUseLevel1Login,long lFlags);

    SCODE DoConnection(         
            BSTR NetworkResource,               
            BSTR User,
            BSTR Password,
            BSTR Locale,
            long lSecurityFlags,                 
            BSTR Authority,                  
            IWbemContext *pCtx,                 
            REFIID riid,
            void **pInterface,
            bool bUseLevel1Login);
            
    SCODE DoActualConnection(         
            BSTR NetworkResource,               
            BSTR User,
            BSTR Password,
            BSTR Locale,
            long lSecurityFlags,                 
            BSTR Authority,                  
            IWbemContext *pCtx,                 
            REFIID riid,
            void **pInterface,
            bool bUseLevel1Login);

    //Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void)
	{
		InterlockedIncrement(&m_cRef);
		return m_cRef;
	}

    STDMETHODIMP_(ULONG) Release(void)
	{
		long lTemp = InterlockedDecrement(&m_cRef);
		if (0!= lTemp)
			return lTemp;
		delete this;
		return 0;
	}


	/* iWbemLocator methods */

	STDMETHOD(ConnectServer)(THIS_         
            BSTR AddressType,               
            DWORD dwBinaryAddressLength,
            BYTE* pbBinaryAddress,

            BSTR NetworkResource,               
            BSTR User,
            BSTR Password,
            BSTR Locale,
            long lSecurityFlags,                 
            BSTR Authority,                  
            IWbemContext *pCtx,                 
            IWbemServices **ppNamespace);

	/* IWbemConnection methods */

    virtual HRESULT STDMETHODCALLTYPE Open( 
        /* [in] */ const BSTR strObject,
        /* [in] */ const BSTR strUser,
        /* [in] */ const BSTR strPassword,
        /* [in] */ const BSTR strLocale,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pInterface,
        /* [out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *pCallRes);
    
    virtual HRESULT STDMETHODCALLTYPE OpenAsync( 
        /* [in] */ const BSTR strObject,
        /* [in] */ const BSTR strUser,
        /* [in] */ const BSTR strPassword,
        /* [in] */ const BSTR strLocale,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE Cancel( 
        /* [in] */ long lFlags,
        /* [in] */ IWbemObjectSinkEx __RPC_FAR *pHandler);

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\dscallres.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    DSCALLRES.CPP

Abstract:

    Call Result Class

History:

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <wbemint.h>
#include "dscallres.h"

#pragma warning(disable:4355)

CDSCallResult::CDSCallResult()
{
    m_pResObj = NULL;
    m_strResult = NULL;
    m_pResNamespace = NULL;
	m_hres = S_OK;
    m_lRef = 1;
	m_hDoneEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
}


CDSCallResult::~CDSCallResult()
{
    if(m_pResObj)
        m_pResObj->Release();
    m_pResObj = NULL;

    if(m_pResNamespace)
        m_pResNamespace->Release();
    m_pResNamespace = NULL;

	if(m_strResult)
		SysFreeString(m_strResult);
    m_strResult = NULL;
	if(m_hDoneEvent)
		CloseHandle(m_hDoneEvent);
}


HRESULT CDSCallResult::SetResultObject(IWbemClassObject* pResObj)
{

    // Store data
    // ==========

    m_pResObj = pResObj;
    if(pResObj)
        pResObj->AddRef();
    return WBEM_S_NO_ERROR;
}


void CDSCallResult::SetResultString(LPWSTR wszRes)
{
	if(m_strResult)
		SysFreeString(m_strResult);
    m_strResult = SysAllocString(wszRes);
}

void CDSCallResult::SetResultServices(IWbemServices* pRes)
{
    if(m_pResNamespace)
        m_pResNamespace->Release();
    m_pResNamespace = pRes;
    if(pRes)
        pRes->AddRef();
}

void SetHRESULT(HRESULT hr){};

void CDSCallResult::SetHRESULT(HRESULT hr)
{
	m_hres = hr;
	if(m_hDoneEvent)
		SetEvent(m_hDoneEvent);
}


STDMETHODIMP CDSCallResult::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemCallResult  || riid == IID_IWbemCallResultEx)
    {
        AddRef();
        *ppv = (void*)this;
        return S_OK;
    }
    else return E_NOINTERFACE;
}


STDMETHODIMP CDSCallResult::GetResultObject(long lTimeout,
                                          IWbemClassObject** ppObj)
{
    if((lTimeout < 0 && lTimeout != -1) || ppObj == NULL)
        return WBEM_E_INVALID_PARAMETER;

    *ppObj = NULL;
	HRESULT hRes = TestIfDone(lTimeout);
	if(hRes != S_OK)
		return hRes;

    if(m_pResObj)
    {
        *ppObj = m_pResObj;
        m_pResObj->AddRef();
        return WBEM_S_NO_ERROR;
    }
    else
    {
        *ppObj = NULL;
        return WBEM_E_FAILED;
    }
}

STDMETHODIMP CDSCallResult::GetResultString(long lTimeout, BSTR* pstr)
{
    if((lTimeout < 0 && lTimeout != -1) || pstr == NULL)
        return WBEM_E_INVALID_PARAMETER;

    *pstr = NULL;
	HRESULT hRes = TestIfDone(lTimeout);
	if(hRes != S_OK)
		return hRes;

    if(m_strResult)
    {
        *pstr = SysAllocString(m_strResult);
        return WBEM_S_NO_ERROR;
    }
    else
    {
        *pstr = NULL;
        return WBEM_E_INVALID_OPERATION;
    }
}

STDMETHODIMP CDSCallResult::GetCallStatus(long lTimeout, long* plStatus)
{
    if(lTimeout < 0 && lTimeout != -1 || plStatus == NULL)
        return WBEM_E_INVALID_PARAMETER;
	HRESULT hRes = TestIfDone(lTimeout);
	if(hRes != S_OK)
		return hRes;

    *plStatus = m_hres;
    return WBEM_S_NO_ERROR;
}

STDMETHODIMP CDSCallResult::GetResultServices(long lTimeout,
                                            IWbemServices** ppServices)
{

    if((lTimeout < 0 && lTimeout != -1) || ppServices == NULL)
        return WBEM_E_INVALID_PARAMETER;
    *ppServices = NULL;
	HRESULT hRes = TestIfDone(lTimeout);
	if(hRes != S_OK)
		return hRes;

    if(m_pResNamespace)
    {
        *ppServices = m_pResNamespace;
        m_pResNamespace->AddRef();
        return WBEM_S_NO_ERROR;
    }
    else
    {
        *ppServices = NULL;
        return WBEM_E_INVALID_OPERATION;
    }
}


STDMETHODIMP CDSCallResult::GetResult(
        long lTimeout,
        long lFlags,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvResult
        )
{
    if((lTimeout < 0 && lTimeout != -1) || ppvResult == NULL)
        return WBEM_E_INVALID_PARAMETER;

	HRESULT hRes = TestIfDone(lTimeout);
	if(hRes != S_OK)
		return hRes;
	if(FAILED(m_hres))
		return m_hres;
	if((riid == IID_IWbemServices || riid == IID_IWbemServicesEx) && m_pResNamespace)
		return m_pResNamespace->QueryInterface(riid, (void **)ppvResult);
	else
		if(m_pResObj)
			return m_pResObj->QueryInterface(riid, (void **)ppvResult);
	return WBEM_E_FAILED;
}


HRESULT CDSCallResult::TestIfDone(long lTimeout)
{
	if(m_hDoneEvent == NULL)
		return WBEM_E_FAILED;

	long lRes = WaitForSingleObject(m_hDoneEvent, lTimeout);
	if(lRes == WAIT_OBJECT_0)
		return S_OK;
	else 
		return WBEM_S_TIMEDOUT;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\cprovloc.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CPROVLOC.H

Abstract:

	Declares the CProviderLoc class.

History:

	davj  30-Oct-00   Created.

--*/

#ifndef _cprovloc_H_
#define _cprovloc_H_

typedef void ** PPVOID;


//***************************************************************************
//
//  CLASS NAME:
//
//  CProviderLoc
//
//  DESCRIPTION:
//
//  Implements the IWbemLocator interface.  This support the formally inproc
//  logins used by providers.  
//
//***************************************************************************

class CProviderLoc : public IWbemLocator
    {
    protected:
        long            m_cRef;         //Object reference count
        DWORD           m_dwType;
    public:
    
    CProviderLoc(DWORD dwType);
    ~CProviderLoc(void);

    //Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void)
	{
		InterlockedIncrement(&m_cRef);
		return m_cRef;
	}
    STDMETHODIMP_(ULONG) Release(void)
	{
		long lTemp = InterlockedDecrement(&m_cRef);
		if (0L!=lTemp)
			return lTemp;
		delete this;
		return 0;
	}
 
	/* iWbemLocator methods */
	STDMETHOD(ConnectServer)(THIS_ const BSTR NetworkResource, const BSTR User, 
     const BSTR Password, const BSTR lLocaleId, long lFlags, const BSTR Authority,
     IWbemContext __RPC_FAR *pCtx,
     IWbemServices FAR* FAR* ppNamespace);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\dsenum.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    DSENUM.H

Abstract:

	Defines the class implementing IEnumWbemClassObject interface.

	Classes defined:

		CEnumWbemClassObject

History:

	davj        28-Mar-00       Created.

--*/

#ifndef _DSENUM_H_
#define _DSENUM_H_

//#pragma warning(disable : 4355)

class CCollection;
class CEnumInterface : public IEnumWbemClassObject
{
protected:
    long m_lRef;
	CCollection * m_pColl;
	long m_lNextRecord;
	HANDLE m_hNotifyEvent;
	CRITICAL_SECTION  m_cs;

public:
    CEnumInterface();
    ~CEnumInterface();
	void SetCollector(CCollection * pCol);

    STDMETHOD_(ULONG, AddRef)() {return InterlockedIncrement(&m_lRef);}
    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0)
            delete this;
        return lRef;
    }
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

    STDMETHOD(Reset)();
    STDMETHOD(Next)(long lTimeout, ULONG uCount,  
        IWbemClassObject** apObj, ULONG FAR* puReturned);
    STDMETHOD(NextAsync)(ULONG uCount, IWbemObjectSink* pSink);
    STDMETHOD(Clone)(IEnumWbemClassObject** pEnum);
    STDMETHOD(Skip)(long lTimeout, ULONG nNum);

};

struct NotifySink
{
	NotifySink(IWbemObjectSink * pSink, long first, long last)
	{
		m_pSink = pSink;
		m_pSink->AddRef();
		m_lFirstRecord = first;
		m_lLastRecord = last;
	}
	~NotifySink(){m_pSink->Release();};

	IWbemObjectSink * m_pSink;
	long m_lFirstRecord;
	long m_lLastRecord;
};

struct InterfaceToBeNofified
{

	InterfaceToBeNofified(HANDLE hToNotify, long lLast){m_hDoneEvent = hToNotify; m_lLastRecord = lLast;};
	~InterfaceToBeNofified(){CloseHandle(m_hDoneEvent);};
	HANDLE m_hDoneEvent;
	long m_lLastRecord;
};

class CCollection : public IUnknown
{
protected:
    long m_lRef;
	CFlexArray m_SinksToBeNotified;
	CFlexArray m_InterfacesToBeNotifid;
	CFlexArray m_Objects;
	CRITICAL_SECTION  m_cs;
	bool m_bDone;
	HRESULT m_hr;

public:
	long GetRecords(long lFirstRecord, long lLastRecord, long * plNumReturned, IWbemClassObject **apObjects, HRESULT* phr);
	HRESULT NotifyAtNumber(HANDLE hForCollToClose, long lLastRecord);
	HRESULT AddObjectsToList(IWbemClassObject **Array, long lNumObj);
	HRESULT AddSink(long lFirst, long lLast, IWbemObjectSink * pSink);
	void SetDone(HRESULT hr);
	CCollection();
	~CCollection();

    STDMETHOD_(ULONG, AddRef)() {return InterlockedIncrement(&m_lRef);}
    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0)
            delete this;
        return lRef;
    }
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

};
struct CCreateInstanceEnumRequest
{
	IUmiCursor *  m_pCursor;
	long m_lFlags;
	CEnumInterface * m_pEnum;
	IWbemObjectSink * m_pSink;
	CCollection * m_pColl;
	bool m_bAsync;
	long m_lSecurityFlags;
	CCreateInstanceEnumRequest(IUmiCursor *  pCursor, long lFlags, CEnumInterface * pEnum, 
		IWbemObjectSink * pSink, CCollection * pColl, long lSecurityFlags); 
	~CCreateInstanceEnumRequest();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\dscallres.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    DSCALLRES.H

Abstract:

    Call Result Class

History:

--*/

#ifndef __DSCALL_RESULT__H_
#define __DSCALL_RESULT__H_

class CDSCallResult : public IWbemCallResultEx
{
protected:
    long m_lRef;
    IWbemClassObject* m_pResObj;
    BSTR m_strResult;
    IWbemServices* m_pResNamespace;
	HRESULT m_hres;
	HANDLE m_hDoneEvent;

public:
    STDMETHOD_(ULONG, AddRef)() {return InterlockedIncrement(&m_lRef);}
    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0)
            delete this;
        return lRef;
    }
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

    STDMETHOD(GetResultObject)(long lTimeout, IWbemClassObject** ppObj);
    STDMETHOD(GetResultString)(long lTimeout, BSTR* pstr);
    STDMETHOD(GetCallStatus)(long lTimeout, long* plStatus);
    STDMETHOD(GetResultServices)(long lTimeout, IWbemServices** ppServices);

    virtual HRESULT STDMETHODCALLTYPE GetResult(
            /* [in] */ long lTimeout,
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvResult
            );

public:
    CDSCallResult();
    ~CDSCallResult();

	HRESULT TestIfDone(long lTimeout);
    void SetResultString(LPWSTR wszRes);
    void SetResultServices(IWbemServices* pRes);
    HRESULT SetResultObject(IWbemClassObject* pRes);
	void SetHRESULT(HRESULT hr);
};



#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\dssvexwrap.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    DSSVEXWRAP.CPP

Abstract:

    IWbemServicesEx Delegator

History:

	davj  14-Mar-00   Created.

--*/

#include "precomp.h"
#include <genutils.h>
#include <umi.h>
#include <wbemint.h>
#include <wmiutils.h>
//#include <adsiid.h>
#include "dscallres.h"
#include "dssvexwrap.h"
#include "dsenum.h"
#include "wbemprox.h"
#include "reqobjs.h"
#include "utils.h"
#include "dsumicont.h"

#define WINNTSTR L"WINNT"
#define ADSISTR L"ADSI"

HRESULT SetProplistFromContext(IWbemContext *pContext, IUmiPropList *pPropList)
{

    if(pContext == NULL || pPropList == NULL)
        return S_OK;                        // contexts are optional

	UMI_PROPERTY UmiProp;
	UMI_PROPERTY_VALUES UmiPropVals;
	UmiProp.uType = UMI_TYPE_LPWSTR;
	UmiProp.uCount = 1;
    UmiPropVals.uCount = 1;
    UmiPropVals.pPropArray = &UmiProp;

    // Set the values in the context object

    pContext->BeginEnumeration(0);
    BSTR bstr = NULL;
    VARIANT var;
    VariantInit(&var);

    // Get the first value from the context object

    HRESULT hr = pContext->Next(0, &bstr, &var);
    while( WBEM_S_NO_ERROR == hr )
    {
        switch(var.vt)      // todo, this covers the current known type, but more may be needed
        {
        case VT_I4:
    	    UmiProp.uType = UMI_TYPE_I4;
            break;
        case VT_BOOL:
	        UmiProp.uType = UMI_TYPE_BOOL;
            break;
        case VT_BSTR:
	        UmiProp.uType = UMI_TYPE_LPWSTR;
            break;
        default:
            SysFreeString(bstr);
            VariantClear(&var);
            return WBEM_E_INVALID_PARAMETER;                
        }
	    UmiProp.uCount = 1;
	    UmiProp.uOperationType = UMI_OPERATION_UPDATE;
        UmiProp.pszPropertyName = bstr;
        UmiProp.pUMIValue = (UMI_VALUE *) &var.lVal;
        UmiPropVals.uCount = 1;
        UmiPropVals.pPropArray = &UmiProp;
        hr = pPropList->Put(bstr, 0, &UmiPropVals);
        SysFreeString(bstr);
        bstr = NULL;
        VariantClear(&var);
        if(FAILED(hr))
            return hr;
        hr = pContext->Next(0, &bstr, &var);
    }
    pContext->EndEnumeration();
    return hr;
}

//***************************************************************************
//
//  CDSSvcExWrapper::CDSSvcExWrapper
//  ~CDSSvcExWrapper::CDSSvcExWrapper
//
//  DESCRIPTION:
//
//  Constructor and destructor.  The main things to take care of are the 
//  old style proxy, and the channel
//
//  RETURN VALUE:
//
//  S_OK                all is well
//
//***************************************************************************

CDSSvcExWrapper::CDSSvcExWrapper()
{
	m_pUmiContainer = NULL;
	m_cRef = 0;
	m_pWbemComBinding = NULL;
	ObjectCreated( DSSVEX );
}

CDSSvcExWrapper::~CDSSvcExWrapper()
{
	if(m_pUmiContainer)
	{
		m_pUmiContainer->Release();
		m_pUmiContainer = NULL;
	}

	if ( NULL != m_pWbemComBinding )
	{
		m_pWbemComBinding->Release();
		m_pWbemComBinding = NULL;
	}

	ObjectDestroyed( DSSVEX );

}

STDMETHODIMP CDSSvcExWrapper::QueryInterface (

    IN REFIID riid,
    OUT void ** ppv
)
{
    *ppv=NULL;

    
    if (IID_IUnknown==riid || riid == IID_IWbemServicesEx || riid == IID_IWbemServices  )
	{
        *ppv = (IWbemServicesEx*) this;
	}
    else if ( riid == IID__IUmiSvcExWrapper )
	{
        *ppv = (_IUmiSvcExWrapper*) this;
	}
	else if ( IID_IWbemComBinding == riid )
	{
		// Do this in a critical section
		CInCritSec	ics( &m_cs );

		// If we don't have a UMI Com Binding pointer, we should instantiate it now.
		// We will aggregate the interface

		if ( NULL == m_pWbemComBinding )
		{
			HRESULT	hr = CoCreateInstance( CLSID__UmiComBinding, (IWbemServicesEx*) this, CLSCTX_INPROC_SERVER, IID_IUnknown, (void**) &m_pWbemComBinding );

			if ( FAILED( hr ) )
			{
				return hr;
			}
		}

		if ( NULL != m_pWbemComBinding )
		{
			return m_pWbemComBinding->QueryInterface( IID_IWbemComBinding, ppv );
		}

		return ResultFromScode(E_NOINTERFACE);

	}

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP CDSSvcExWrapper::ConnectToProvider( LPCWSTR User, LPCWSTR Password, IUnknown * pUnkPath, REFCLSID clsid, IWbemContext *pCtx,
												IUnknown** ppUnk )
{
	IUmiURL*	pPath = NULL;

	HRESULT hr = pUnkPath->QueryInterface( IID_IUmiURL, (void**) &pPath );
	CReleaseMe	rmPath( pPath );

	if ( FAILED( hr ) )
	{
		return hr;
	}

    IUmiConnection *pIUmiConn = NULL;
    IUmiPropList *pIUmiPropList = NULL;
	UMI_PROPERTY umiProp;

	if(pPath == NULL)
		return WBEM_E_INVALID_PARAMETER;

	// Get the connection object;

	hr = CoCreateInstance(
				clsid,
				NULL,
				CLSCTX_INPROC_SERVER,
				IID_IUmiConnection,
				(void **) &pIUmiConn
				); 
	if(FAILED(hr))
	{
		ERRORTRACE((LOG_WBEMPROX, "Cannot CoCreate the connection object, return code = 0x%x\n",hr)); 
		return hr;
	}

	CReleaseMe rm(pIUmiConn);

	hr = pIUmiConn->GetInterfacePropList(0, &pIUmiPropList);
	if(FAILED(hr))
	{
		ERRORTRACE((LOG_WBEMPROX, "GetInterfacePropList on connection failed, return code = 0x%x\n",hr)); 
		return hr;
	}
    CReleaseMe rm2(pIUmiPropList);

    hr = SetProplistFromContext(pCtx, pIUmiPropList);
	if(FAILED(hr))
		return hr;

    //the following is needed if the user/password is being specified

	if(User || Password)
	{

		UMI_PROPERTY UmiProp;
		UmiProp.uType = UMI_TYPE_LPWSTR;
		UmiProp.uCount = 1;
		UmiProp.uOperationType = UMI_OPERATION_UPDATE;
		UmiProp.pszPropertyName = NULL;
  
        // allocate a temp buffer big enough to hold the larger of the two

        DWORD dwSize = 0;
        if(User)
            dwSize = wcslen(User)+1;
        if(Password)
        {
            if((wcslen(Password)+1) > dwSize)
                dwSize = wcslen(Password)+1;
        }
		WCHAR * pTmpString = new WCHAR[dwSize];
		if(NULL == pTmpString)
			return WBEM_E_OUT_OF_MEMORY;
        CDeleteMe<WCHAR> dm(pTmpString);

        // Set up the property structure

		UMI_PROPERTY_VALUES UmiPropVals;
		UmiPropVals.uCount = 1;
		UmiPropVals.pPropArray = &UmiProp;

		if(User)
		{
			wcscpy(pTmpString, User);
			UmiProp.pUMIValue = (UMI_VALUE *) &pTmpString;              // setting user name
			UmiProp.pszPropertyName = L"__USERID";
			hr = pIUmiPropList->Put(
					  L"__USERID",
					  0,
					  &UmiPropVals
					  );

			if(FAILED(hr))
			{
				ERRORTRACE((LOG_WBEMPROX, "Put username failed, return code = 0x%x\n",hr)); 
				return hr;
			}
		}
		if(Password)
		{
			wcscpy(pTmpString, Password);
			UmiProp.pUMIValue = (UMI_VALUE *) &pTmpString;              // setting user name
			UmiProp.pszPropertyName = L"__PASSWORD";
			hr = pIUmiPropList->Put(
					  L"__PASSWORD",
					  0,
					  &UmiPropVals
					  );

			if(FAILED(hr))
			{
				ERRORTRACE((LOG_WBEMPROX, "Put password failed, return code = 0x%x\n",hr)); 
				return hr;
			}
		}
	}

   // where the actual container is retrieved

	ULONG uLen = 256;
	WCHAR wServerName[256];         //todo, get rid of these once ajay can handle umi
	WCHAR wFullName[256];           //todo, ditto

	IUmiContainer*	pUmiContainer = NULL;

    hr = pIUmiConn->Open(
         pPath,                       // winnt://davj1,computer
         0,
         IID_IUmiContainer,
         (void **) &pUmiContainer
         );
	CReleaseMe	rmContainer( pUmiContainer );

    if(FAILED(hr))
    {
		ERRORTRACE((LOG_WBEMPROX, "Open Conection failed, return code = 0x%x\n",hr));
    }

	// For the ds providers, create a special wrapper.

	else if(clsid == CLSID_LDAPConnectionObject || clsid == CLSID_WinNTConnectionObject)
	{
		CDsUmiContainer * pNew = new CDsUmiContainer;
		if(pNew == NULL)
			return WBEM_E_OUT_OF_MEMORY;
		hr = pNew->SetInterface(pUmiContainer, pPath, pIUmiConn);	// takes ownership of m_pUmiContainer
		if(SUCCEEDED(hr))
		{
			hr = pNew->QueryInterface(IID_IUmiContainer, (void **)&m_pUmiContainer);

			if ( SUCCEEDED( hr ) )
			{
				hr = pUmiContainer->QueryInterface( IID_IUnknown, (void**) ppUnk );
			}
		}
	}
    return hr;
}

STDMETHODIMP CDSSvcExWrapper::SetContainer( long lFlags, IUnknown* pContainer )
{

	// Make sure the supplied container has the proper interface pointer
	IUmiContainer*	pUmiContainer = NULL;
	HRESULT hr = pContainer->QueryInterface( IID_IUmiContainer, (void**) &pUmiContainer );
	if(FAILED(hr))
		return hr;
	CReleaseMe	rmContainer( pUmiContainer );


	// If the SetDirect flag is set, we will just set the interface pointer
	// directly and we are done!
	if ( lFlags & UMISVCEX_WRAPPER_FLAG_SETDIRECT )
	{
		m_pUmiContainer = pUmiContainer;
		m_pUmiContainer->AddRef();
		return S_OK;
	}

	// We need a path parser
	IWbemPath*	pParser = NULL;
	hr = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
				IID_IWbemPath, (LPVOID *) &pParser);
	if(FAILED(hr))
		return hr;
	CReleaseMe rm1(pParser);

	IUmiURL*	pPath = NULL;
	hr = pParser->QueryInterface(IID_IUmiURL, (void **)&pPath);
	if(FAILED(hr))
		return hr;
	CReleaseMe rm2(pPath);

	// Now we need to get the URL of the Container object, and create a Connection object for
	// the URL

	IUmiPropList*	pPropList = NULL;

	// The __URL contains the actual path to the container.  From there we can determine which provider we
	// need to create a connection for.

	hr = pUmiContainer->GetInterfacePropList( 0L, &pPropList );
	CReleaseMe	rm(pPropList);

	UMI_PROPERTY_VALUES* pPropValues = NULL;

	if ( SUCCEEDED( hr ) )
		hr = pPropList->Get(L"__URL", 0, &pPropValues);

	if(FAILED(hr))
		return hr;

    UMI_PROPERTY *pProp;
	pProp = pPropValues->pPropArray;   //  wcValue

	// Grab the class container.	
	
	LPWSTR * ppStr = (LPWSTR *)pProp->pUMIValue;
	LPWSTR	pwcsPath = *ppStr;

	// Use the path parser for this
	CLSID	clsidUmi;
	hr = pPath->Set( 0, pwcsPath);

	if ( SUCCEEDED( hr ) )
	{
		// Which one is it?
		WCHAR wNamespace[50];
		DWORD dwSize = 50;
		hr = pPath->GetRootNamespace(&dwSize, wNamespace);
		if( SUCCEEDED(hr) )
		{

			// Determine if it is one of the well know ds namespaces

			if(_wcsicmp(wNamespace, L"WINNT") == 0)
			{
				clsidUmi = CLSID_WinNTConnectionObject;
			}	
			else if(_wcsicmp(wNamespace, L"LDAP") == 0)
			{	
				clsidUmi = CLSID_LDAPConnectionObject;
			}
			else
			{
				hr = WBEM_E_INVALID_OPERATION;
			}

		}	// IF GetRootNamespace

	}	// IF SetPath

	// cleanup
	pPropList->FreeMemory( 0L, pPropValues );

	if ( FAILED( hr ) )
	{
		return hr;
	}

    IUmiConnection *pIUmiConn = NULL;

	// Now create the connection object;

	hr = CoCreateInstance(
				clsidUmi,
				NULL,
				CLSCTX_INPROC_SERVER,
				IID_IUmiConnection,
				(void **) &pIUmiConn
				); 
	if(FAILED(hr))
	{
		ERRORTRACE((LOG_WBEMPROX, "Cannot CoCreate the connection object, return code = 0x%x\n",hr)); 
		return hr;
	}
	CReleaseMe	rmConn( pIUmiConn );

	// Now create the actual container object and
	// set the interfaces properly
	CDsUmiContainer * pNew = new CDsUmiContainer;
	if(pNew == NULL)
		return WBEM_E_OUT_OF_MEMORY;

	if ( SUCCEEDED( hr ) )
	{
		
		hr = pNew->SetInterface(pUmiContainer, pPath, pIUmiConn);	// takes ownership of m_pUmiContainer
		if(SUCCEEDED(hr))
		{
			hr = pNew->QueryInterface(IID_IUmiContainer, (void **)&m_pUmiContainer);
		}

	}	// IF QI

	return hr;

}

HRESULT CDSSvcExWrapper::ConnectToDS(LPCWSTR User, LPCWSTR Password, IUmiURL * pPath, CLSID &clsid, IWbemContext *pCtx)
{
	HRESULT hr;
    IUmiConnection *pIUmiConn = NULL;
    IUmiPropList *pIUmiPropList = NULL;
	UMI_PROPERTY umiProp;

	if(pPath == NULL)
		return WBEM_E_INVALID_PARAMETER;

	// Get the connection object;

	hr = CoCreateInstance(
				clsid,
				NULL,
				CLSCTX_INPROC_SERVER,
				IID_IUmiConnection,
				(void **) &pIUmiConn
				); 
	if(FAILED(hr))
	{
		ERRORTRACE((LOG_WBEMPROX, "Cannot CoCreate the connection object, return code = 0x%x\n",hr)); 
		return hr;
	}

	CReleaseMe rm(pIUmiConn);

	hr = pIUmiConn->GetInterfacePropList(0, &pIUmiPropList);
	if(FAILED(hr))
	{
		ERRORTRACE((LOG_WBEMPROX, "GetInterfacePropList on connection failed, return code = 0x%x\n",hr)); 
		return hr;
	}
    CReleaseMe rm2(pIUmiPropList);

    hr = SetProplistFromContext(pCtx, pIUmiPropList);
	if(FAILED(hr))
		return hr;

    //the following is needed if the user/password is being specified

	if(User || Password)
	{

		UMI_PROPERTY UmiProp;
		UmiProp.uType = UMI_TYPE_LPWSTR;
		UmiProp.uCount = 1;
		UmiProp.uOperationType = UMI_OPERATION_UPDATE;
		UmiProp.pszPropertyName = NULL;
  
        // allocate a temp buffer big enough to hold the larger of the two

        DWORD dwSize = 0;
        if(User)
            dwSize = wcslen(User)+1;
        if(Password)
        {
            if((wcslen(Password)+1) > dwSize)
                dwSize = wcslen(Password)+1;
        }
		WCHAR * pTmpString = new WCHAR[dwSize];
		if(NULL == pTmpString)
			return WBEM_E_OUT_OF_MEMORY;
        CDeleteMe<WCHAR> dm(pTmpString);

        // Set up the property structure

		UMI_PROPERTY_VALUES UmiPropVals;
		UmiPropVals.uCount = 1;
		UmiPropVals.pPropArray = &UmiProp;

		if(User)
		{
			wcscpy(pTmpString, User);
			UmiProp.pUMIValue = (UMI_VALUE *) &pTmpString;              // setting user name
			UmiProp.pszPropertyName = L"__USERID";
			hr = pIUmiPropList->Put(
					  L"__USERID",
					  0,
					  &UmiPropVals
					  );

			if(FAILED(hr))
			{
				ERRORTRACE((LOG_WBEMPROX, "Put username failed, return code = 0x%x\n",hr)); 
				return hr;
			}
		}
		if(Password)
		{
			wcscpy(pTmpString, Password);
			UmiProp.pUMIValue = (UMI_VALUE *) &pTmpString;              // setting user name
			UmiProp.pszPropertyName = L"__PASSWORD";
			hr = pIUmiPropList->Put(
					  L"__PASSWORD",
					  0,
					  &UmiPropVals
					  );

			if(FAILED(hr))
			{
				ERRORTRACE((LOG_WBEMPROX, "Put password failed, return code = 0x%x\n",hr)); 
				return hr;
			}
		}
	}

   // where the actual container is retrieved

	ULONG uLen = 256;
	WCHAR wServerName[256];         //todo, get rid of these once ajay can handle umi
	WCHAR wFullName[256];           //todo, ditto

    hr = pIUmiConn->Open(
         pPath,                       // winnt://davj1,computer
         0,
         IID_IUmiContainer,
         (void **) &m_pUmiContainer
         );
    if(FAILED(hr))
    {
		ERRORTRACE((LOG_WBEMPROX, "Open Conection failed, return code = 0x%x\n",hr));
    }

	// For the ds providers, create a special wrapper.

	else if(clsid == CLSID_LDAPConnectionObject || clsid == CLSID_WinNTConnectionObject)
	{
		CDsUmiContainer * pNew = new CDsUmiContainer;
		if(pNew == NULL)
			return WBEM_E_OUT_OF_MEMORY;
		hr = pNew->SetInterface(m_pUmiContainer, pPath, pIUmiConn);	// takes ownership of m_pUmiContainer
		if(SUCCEEDED(hr))
		{
			hr = pNew->QueryInterface(IID_IUmiContainer, (void **)&m_pUmiContainer);
		}
	}
    return hr;
}

// If the security descriptor flag is set, this call will interpret the context and return the appropriate Security Descriptor
// flags to the client

#define	NUM_SECURITY_CONTEXT_FLAGS	4

LPCWSTR	g_apContextSecurity[NUM_SECURITY_CONTEXT_FLAGS] = { L"INCLUDE_OWNER", L"INCLUDE_DACL", L"INCLUDE_SACL", L"INCLUDE_GROUP" };
long	g_alSecurityFlags[NUM_SECURITY_CONTEXT_FLAGS] = { UMI_FLAG_OWNER_SECURITY_INFORMATION, UMI_FLAG_DACL_SECURITY_INFORMATION,
														UMI_FLAG_SACL_SECURITY_INFORMATION, UMI_FLAG_GROUP_SECURITY_INFORMATION };

HRESULT	CDSSvcExWrapper::CheckSecuritySettings( long lFlags, IWbemContext* pContext, long* plSecFlags, BOOL fPut )
{
	HRESULT	hr = WBEM_S_NO_ERROR;

	// Start with 0
	*plSecFlags = 0L;

	if ( lFlags & WBEM_FLAG_USE_SECURITY_DESCRIPTOR )
	{
		if ( NULL != pContext )
		{
			VARIANT	v;

			for ( UINT uCtr = 0; SUCCEEDED( hr ) && uCtr < NUM_SECURITY_CONTEXT_FLAGS; uCtr++ )
			{
				hr = pContext->GetValue( g_apContextSecurity[uCtr], 0L, &v );
				
				if ( SUCCEEDED( hr ) )
				{
					if ( V_VT( &v ) == VT_BOOL && V_BOOL( &v ) == VARIANT_TRUE )
					{
						*plSecFlags |= g_alSecurityFlags[uCtr];
					}
				}
				// Not found is okay
				else if ( WBEM_E_NOT_FOUND == hr )
				{
					hr = WBEM_S_NO_ERROR;
				}

			}	// FOR enum the values

			// If we didn't set any flags, this is also an error
			if ( 0L == *plSecFlags )
			{
				hr = WBEM_E_INVALID_PARAMETER;
			}
			else if ( !fPut )
			{
				// If we're not doing a put, set the the security flag
				*plSecFlags |= UMIOBJECT_WRAPPER_FLAG_SECURITY;
			}

		}
		else
		{
			hr = WBEM_E_INVALID_PARAMETER;
		}

	}
	else if ( fPut )
	{
		// If we're putting an object and the use descriptor flag is not specified, we need to tell UMI
		// not to let security through, so set the special flag

		*plSecFlags = UMI_DONT_COMMIT_SECURITY_DESCRIPTOR;
	}

	return hr;
}

STDMETHODIMP CDSSvcExWrapper::OpenNamespace(
		const BSTR Namespace, LONG lFlags, IWbemContext* pContext, IWbemServices** ppNewNamespace,
		IWbemCallResult** ppResult
		)
{
	CDSCallResult * pCallRes = NULL;
	HRESULT hr = AllocateCallResult(ppResult, &pCallRes);
	if(FAILED(hr))
		return hr;
	return OpenPreCall(Namespace, lFlags, pContext, ppNewNamespace, NULL, pCallRes, NULL);
}

STDMETHODIMP CDSSvcExWrapper::Open(
    /* [in] */ const BSTR strScope,
    /* [in] */ const BSTR strParam,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemServicesEx __RPC_FAR *__RPC_FAR *ppScope,
    /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppResult)
{
	CDSCallResult * pCallRes = NULL;
	HRESULT hr = AllocateCallResultEx(ppResult, &pCallRes);
	if(FAILED(hr))
		return hr;
	return OpenPreCall(strScope, lFlags, pCtx, NULL, ppScope, pCallRes, NULL);
}

STDMETHODIMP CDSSvcExWrapper::OpenAsync(
    /* [in] */ const BSTR strScope,
    /* [in] */ const BSTR strParam,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler)
{
	return OpenPreCall(strScope, lFlags, pCtx, NULL, NULL, NULL, pResponseHandler);
}

HRESULT CDSSvcExWrapper::OpenPreCall(const BSTR Path,  long lFlags, IWbemContext* pContext,
								IWbemServices** ppNewNamespace, IWbemServicesEx **ppScope,
								CDSCallResult * pCallRes, 
								IWbemObjectSinkEx* pResponseHandler)

{

	if(Path == NULL)
		return WBEM_E_INVALID_PARAMETER;

	if(m_pUmiContainer == NULL)
		return WBEM_E_FAILED;

	IUmiURL * pNewCont = NULL;
    HRESULT hr = CreateURL(Path, 0L, &pNewCont);
    if(FAILED(hr))
		return hr;
    CReleaseMe rm(pNewCont);

	long	lSecurityFlags = 0L;
	hr = CheckSecuritySettings( lFlags, pContext, &lSecurityFlags, FALSE );
	if(FAILED(hr))
		return hr;

	bool bAsync = pResponseHandler || (pCallRes && (lFlags & WBEM_FLAG_RETURN_IMMEDIATELY));
	COpenRequest * pReq = new COpenRequest(pNewCont, lFlags, pContext, ppNewNamespace, ppScope,  
												pCallRes, pResponseHandler, bAsync,
												 m_pUmiContainer, lSecurityFlags);
	return CreateThreadOrCallDirectly(bAsync, pReq);

}

STDMETHODIMP CDSSvcExWrapper::CancelAsyncCall(IWbemObjectSink* pSink)
{
		return WBEM_E_NOT_AVAILABLE;
}

STDMETHODIMP CDSSvcExWrapper::QueryObjectSink(long lFlags, IWbemObjectSink** ppResponseHandler)
{
		return WBEM_E_NOT_AVAILABLE;
}

STDMETHODIMP CDSSvcExWrapper::ExecQuery(const BSTR QueryLanguage, const BSTR Query, long lFlags,
	IWbemContext* pContext, IEnumWbemClassObject** ppEnum)
{
	return  ExecQueryPreCall(QueryLanguage, Query, lFlags, pContext, ppEnum ,NULL);
}

STDMETHODIMP CDSSvcExWrapper::ExecQueryAsync(const BSTR QueryFormat, const BSTR Query, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
	return ExecQueryPreCall(QueryFormat, Query, lFlags, pContext, NULL , pResponseHandler);
}

CLSID LDAPQuery = {0xcd5d4d76, 0xa818,0x4f95, 0xb9, 0x58,0x79,0x70,0xfd,0x94,0x12,0xca};
/*
// Interface properties for query object.
//
INTF_PROP_DATA IntfPropsQuery[]=
{
    { TEXT("__SEARCH_SCOPE"), OPERATION_CODE_READWRITE, UMI_TYPE_I4,
         FALSE, {LDAP_SCOPE_SUBTREE} },
    { TEXT("__PADS_SEARCHPREF_ASYNCHRONOUS"), OPERATION_CODE_READWRITE,
        UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_SEARCHPREF_DEREF_ALIASES"), OPERATION_CODE_READWRITE,
         UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_SEARCHPREF_SIZE_LIMIT"), OPERATION_CODE_READWRITE,
         UMI_TYPE_I4, FALSE, {0}},
    { TEXT("__PADS_SEARCHPREF_TIME_LIMIT"), OPERATION_CODE_READWRITE,
         UMI_TYPE_I4, FALSE, {0}},
    { TEXT("__PADS_SEARCHPREF_ATTRIBTYPES_ONLY"), OPERATION_CODE_READWRITE,
         UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_SEARCHPREF_TIMEOUT"), OPERATION_CODE_READWRITE,
         UMI_TYPE_I4, FALSE, {0}},
    { TEXT("__PADS_SEARCHPREF_PAGESIZE"), OPERATION_CODE_READWRITE,
         UMI_TYPE_I4, FALSE, {0}},
    { TEXT("__PADS_SEARCHPREF_PAGED_TIME_LIMIT"), OPERATION_CODE_READWRITE,
         UMI_TYPE_I4, FALSE, {0}},
    { TEXT("__PADS_SEARCHPREF_CHASE_REFERRALS"), OPERATION_CODE_READWRITE,
         UMI_TYPE_I4, FALSE, {ADS_CHASE_REFERRALS_EXTERNAL}},
    //
    // BugBug do we keep this similar to IDirectorySearch or do we not cache.
    //
    { TEXT("__PADS_SEARCHPREF_CACHE_RESULTS"), OPERATION_CODE_READWRITE,
         UMI_TYPE_BOOL, FALSE, {TRUE}},
    { TEXT("__PADS_SEARCHPREF_TOMBSTONE"), OPERATION_CODE_READWRITE,
         UMI_TYPE_BOOL, FALSE, {FALSE}},
    { TEXT("__PADS_SEARCHPREF_FILTER"), OPERATION_CODE_READWRITE,
         UMI_TYPE_LPWSTR, FALSE, {0}},
    { TEXT("__PADS_SEARCHPREF_ATTRIBUTES"), OPERATION_CODE_READWRITE,
         UMI_TYPE_LPWSTR, TRUE, {0}},
    { NULL, 0, 0, FALSE, {0}} // end of data marker
};
*/

HRESULT CDSSvcExWrapper::ExecQueryPreCall(const BSTR QueryFormat, const BSTR Query, long lFlags, 
                                           IWbemContext* pContext, IEnumWbemClassObject** ppEnum , 
                                           IWbemObjectSink* pSink)
{
	if(QueryFormat == NULL ||  Query == NULL || (ppEnum == NULL && pSink == NULL))
		return WBEM_E_INVALID_PARAMETER;

    // get the ldap query object

    IUmiQuery *pUmiQuery = NULL;
    HRESULT hr = CoCreateInstance(
             LDAPQuery,
             NULL,
             CLSCTX_INPROC_SERVER,
             IID_IUmiQuery,
             (void **) &pUmiQuery
             );

   	if(FAILED(hr))
		return hr;
    CReleaseMe rm1(pUmiQuery);

    // Get the query objects prop list

    IUmiPropList *pPropList = NULL;
    hr = pUmiQuery->GetInterfacePropList(0, &pPropList);
   	if(FAILED(hr))
		return hr;
    CReleaseMe rm2(pPropList);

    // set the query

	UMI_PROPERTY UmiProp;
	UMI_PROPERTY_VALUES UmiPropVals;
	UmiProp.uType = UMI_TYPE_LPWSTR;
	UmiProp.uCount = 1;
	UmiProp.uOperationType = UMI_OPERATION_UPDATE;
    UmiProp.pszPropertyName = L"__PADS_SEARCHPREF_FILTER";
    UmiProp.pUMIValue = (UMI_VALUE *) &Query;
    UmiPropVals.uCount = 1;
    UmiPropVals.pPropArray = &UmiProp;
//    hr = pPropList->Put(L"__PADS_SEARCHPREF_FILTER", 0, &UmiPropVals);
//	if(FAILED(hr))
//		return hr;

	// Set the query

	pUmiQuery->Set(QueryFormat, 0, Query);

    hr = SetProplistFromContext(pContext, pPropList);
	if(FAILED(hr))
		return hr;

	long	lSecurityFlags = 0L;
	hr = CheckSecuritySettings( lFlags, pContext, &lSecurityFlags, FALSE );
	if(FAILED(hr))
		return hr;

    IUmiCursor * pCursor = NULL;
    hr = m_pUmiContainer->ExecQuery(pUmiQuery, 0, IID_IUmiCursor, (void **)&pCursor);
	if(FAILED(hr))
		return hr;

    return EnumerateCursor(pCursor, lFlags, ppEnum, pSink, lSecurityFlags);
}

STDMETHODIMP CDSSvcExWrapper::ExecNotificationQuery(const BSTR QueryLanguage, const BSTR Query,
	long lFlags, IWbemContext* pContext, IEnumWbemClassObject** ppEnum)
{
		return WBEM_E_NOT_AVAILABLE;
}

STDMETHODIMP CDSSvcExWrapper::ExecNotificationQueryAsync(const BSTR QueryFormat, const BSTR Query,
	long lFlags, IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
		return WBEM_E_NOT_AVAILABLE;
}

STDMETHODIMP CDSSvcExWrapper::ExecMethod(const BSTR ObjectPath, const BSTR MethodName, long lFlags,
	IWbemContext *pCtx, IWbemClassObject *pInParams,
	IWbemClassObject **ppOutParams, IWbemCallResult  **ppCallResult)
{
		return WBEM_E_NOT_AVAILABLE;
}

STDMETHODIMP CDSSvcExWrapper::ExecMethodAsync(const BSTR ObjectPath, const BSTR MethodName, long lFlags,
	IWbemContext *pCtx, IWbemClassObject *pInParams,
	IWbemObjectSink* pResponseHandler)
{
		return WBEM_E_NOT_AVAILABLE;
}

STDMETHODIMP CDSSvcExWrapper::Add(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult)
{
		return WBEM_E_NOT_AVAILABLE;
}

STDMETHODIMP CDSSvcExWrapper::AddAsync(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
		return WBEM_E_NOT_AVAILABLE;
}

STDMETHODIMP CDSSvcExWrapper::Remove(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult)
{
		return WBEM_E_NOT_AVAILABLE;
}

STDMETHODIMP CDSSvcExWrapper::RemoveAsync(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
		return WBEM_E_NOT_AVAILABLE;
}


STDMETHODIMP CDSSvcExWrapper::GetObjectSecurity(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvResult,
    /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult)
{
		return WBEM_E_NOT_AVAILABLE;
}

STDMETHODIMP CDSSvcExWrapper::GetObjectSecurityAsync(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ REFIID RequestedIID,
    /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler)
{
		return WBEM_E_NOT_AVAILABLE;
}

STDMETHODIMP CDSSvcExWrapper::PutObjectSecurity(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ void __RPC_FAR *pSecurityObject,
    /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult)
{
		return WBEM_E_NOT_AVAILABLE;
}

STDMETHODIMP CDSSvcExWrapper::PutObjectSecurityAsync(
    /* [in] */ const BSTR strObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ REFIID riid,
    /* [iid_is][in] */ void __RPC_FAR *pSecurityObject,
    /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler)
{
		return WBEM_E_NOT_AVAILABLE;
}


STDMETHODIMP CDSSvcExWrapper::Copy( 
            /* [in] */ const BSTR strSourceObjectPath,
            /* [in] */ const BSTR strDestObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult)
{
		return WBEM_E_NOT_AVAILABLE;
}

        
STDMETHODIMP CDSSvcExWrapper::CopyAsync( 
            /* [in] */ const BSTR strSourceObjectPath,
            /* [in] */ const BSTR strDestObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler)
{
		return WBEM_E_NOT_AVAILABLE;
}

STDMETHODIMP CDSSvcExWrapper::GetObject(const BSTR ObjectPath, long lFlags, IWbemContext* pContext,
	IWbemClassObject** ppObject, IWbemCallResult** ppResult)
{
	CDSCallResult * pCallRes = NULL;
	HRESULT hr = AllocateCallResult(ppResult, &pCallRes);
	if(FAILED(hr))
		return hr;
	return GetObjectPreCall(ObjectPath, lFlags, pContext, ppObject, pCallRes, NULL);
}

STDMETHODIMP CDSSvcExWrapper::GetObjectAsync(const BSTR ObjectPath, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
	return GetObjectPreCall(ObjectPath, lFlags, pContext, NULL, NULL, pResponseHandler);
}


HRESULT CDSSvcExWrapper::GetObjectPreCall(const BSTR ObjectPath, long lFlags, IWbemContext* pContext, 
								IWbemClassObject** ppObject ,CDSCallResult * pCallRes, 
								IWbemObjectSink* pResponseHandler)
{
	if(m_pUmiContainer == NULL)
		return WBEM_E_FAILED;

	long	lSecurityFlags = 0L;
	HRESULT hr = CheckSecuritySettings( lFlags, pContext, &lSecurityFlags, FALSE );
	if(FAILED(hr))
		return hr;

    IUmiURL * pPathURL = NULL;
    hr = CreateURL(ObjectPath, UMIPATH_CREATE_AS_EITHER, &pPathURL);
    if(FAILED(hr))
		return hr;
    CReleaseMe rm(pPathURL);

	bool bAsync = pResponseHandler || (pCallRes && (lFlags & WBEM_FLAG_RETURN_IMMEDIATELY));
	CGetObjectRequest * pReq = new CGetObjectRequest(pPathURL, lFlags, ppObject, 
												pCallRes, pResponseHandler, bAsync,
												 m_pUmiContainer, lSecurityFlags);
	return CreateThreadOrCallDirectly(bAsync, pReq);
}


STDMETHODIMP CDSSvcExWrapper::CreateClassEnum(const BSTR Superclass, long lFlags,
	IWbemContext* pContext, IEnumWbemClassObject** ppEnum)
{
	return  CreateEnumPreCall(L"Class", lFlags, pContext, ppEnum ,NULL, true);
}

STDMETHODIMP CDSSvcExWrapper::CreateClassEnumAsync(const BSTR Superclass, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
	return CreateEnumPreCall(L"Class", lFlags, pContext, NULL , pResponseHandler, true);
}

STDMETHODIMP CDSSvcExWrapper::CreateInstanceEnum(const BSTR Class, long lFlags,
	IWbemContext* pContext, IEnumWbemClassObject** ppEnum)
{
	return  CreateEnumPreCall(Class, lFlags, pContext, ppEnum ,NULL, false );
}

STDMETHODIMP CDSSvcExWrapper::CreateInstanceEnumAsync(const BSTR Class, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
	return CreateEnumPreCall(Class, lFlags, pContext, NULL , pResponseHandler, false);
}


HRESULT CDSSvcExWrapper::CreateEnumPreCall(const BSTR Class, long lFlags, IWbemContext* pContext, 
											   IEnumWbemClassObject** ppEnum , IWbemObjectSink* pSink,
											   bool bClass)
{
	if(Class == NULL ||  (ppEnum == NULL && pSink == NULL))
		return WBEM_E_INVALID_PARAMETER;

    // allocate a buffer to hold the filter string

	int iLen = wcslen(Class)+1;
	WCHAR * pTmpString = new WCHAR[iLen];
	if(pTmpString == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	CDeleteMe<WCHAR> dm(pTmpString);

    // Create the cursor

	IUmiCursor * pCursor = NULL;
    HRESULT hr;
	hr = m_pUmiContainer->CreateEnum(
              NULL,
              (bClass) ? UMI_OPERATION_CLASS : UMI_OPERATION_INSTANCE,
              IID_IUmiCursor,
              (void **) &pCursor
              );
    if(FAILED(hr))
		return hr;
	CReleaseMe rm(pCursor);

    // Use the prop list to set the filter so that only the right instances are
    // returned.  For class enumeration, it is left as null

    IUmiPropList *pIUmiPropList;
    hr = pCursor->GetInterfacePropList(0, &pIUmiPropList);
    if(FAILED(hr))
		return hr;
	CReleaseMe rm2(pIUmiPropList);

    wcscpy(pTmpString, Class);
	UMI_PROPERTY UmiProp;
	UMI_PROPERTY_VALUES UmiPropVals;
	UmiProp.uType = UMI_TYPE_LPWSTR;
	UmiProp.uCount = 1;
	UmiProp.uOperationType = UMI_OPERATION_UPDATE;

	// LDAP provider require this, so just give it to them.

    UmiProp.pszPropertyName = L"__FILTER";

    UmiProp.pUMIValue = (UMI_VALUE *) &pTmpString;
    UmiPropVals.uCount = 1;
    UmiPropVals.pPropArray = &UmiProp;

    hr = pIUmiPropList->Put(
              L"__FILTER",
              0,
              &UmiPropVals
              );
	if(FAILED(hr))
		return hr;

	long	lSecurityFlags = 0L;
	hr = CheckSecuritySettings( lFlags, pContext, &lSecurityFlags, FALSE );
	if(FAILED(hr))
		return hr;

    return EnumerateCursor(pCursor, lFlags, ppEnum, pSink, lSecurityFlags);
}

HRESULT CDSSvcExWrapper::EnumerateCursor(IUmiCursor * pCursor, long lFlags, 
								IEnumWbemClassObject** ppEnum , 
								IWbemObjectSink* pSink, long lSecurityFlags )
{
    HRESULT hr;

    // If an enumerator wrapper is required, create it now.  This is not
    // needed for the asyn case

	CEnumInterface * pEnum = NULL;
	if(ppEnum)
	{
		pEnum = new CEnumInterface();	// Created with a ref count of 1
		if(pEnum == NULL)
			return WBEM_E_OUT_OF_MEMORY;
	}
	CReleaseMe rm33(pEnum);
	
	// Create the collection object.  That holds the data as it comes back
    // from the lower layers.  

	CCollection * pColl = new CCollection;
	if(pColl == NULL)
	{
		return WBEM_E_OUT_OF_MEMORY;
	}
	CReleaseMe rm22(pColl);			// contructor sets count to 1;

	if(pSink)
	{
		// if async, add the main sink to the list of sinks to be notified when
        // data is available.

		pColl->AddSink(0, -1, pSink);

	}
	else
	{
		// if enuerate, make sure the CEnumInterface has a ref count on the collection
        // This allows the connection to be used long after the retrieval thread has finished.

		pEnum->SetCollector(pColl); 
	}

	// this gets deleted by CreateEnumThreadRoutine

	CCreateInstanceEnumRequest * pReq = new CCreateInstanceEnumRequest(pCursor, lFlags, pEnum, pSink, pColl, lSecurityFlags); 
	if(pReq == NULL)
		return WBEM_E_OUT_OF_MEMORY;

	if(pSink || (lFlags & WBEM_FLAG_RETURN_IMMEDIATELY))
	{
		// Do the async version

        DWORD dwIDLikeIcare;
		pReq->m_bAsync = true;
		HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)CreateEnumThreadRoutine, 
                                 (LPVOID)pReq, 0, &dwIDLikeIcare);
		if(hThread == NULL)
		{
			delete pReq;            // normally deleted by the CreateEnumThreadRoutine
			return WBEM_E_FAILED;
		}
		else
		{
			CloseHandle(hThread);
			if(ppEnum)
			{
				pEnum->AddRef();
				*ppEnum = pEnum;
			}
			return S_OK;
		}
	}
	else
	{

        // Sync version.  Just call the routine directly

		hr = CreateEnumThreadRoutine((LPVOID)pReq);
		if(SUCCEEDED(hr) && ppEnum)
		{
			pEnum->AddRef();
			*ppEnum = pEnum;
		}
	}

	return hr;

}

STDMETHODIMP CDSSvcExWrapper::RefreshObject(
    /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppResult)
{

	CDSCallResult * pCallRes = NULL;
	HRESULT hr = AllocateCallResultEx(ppResult, &pCallRes);
	if(FAILED(hr))
		return hr;
	return RefreshObjectPreCall(pTarget, lFlags, pCallRes, NULL);
}

STDMETHODIMP CDSSvcExWrapper::RefreshObjectAsync(
    /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler)
{
	return RefreshObjectPreCall(pTarget, lFlags, NULL, pResponseHandler);
}

HRESULT CDSSvcExWrapper::RefreshObjectPreCall(IWbemClassObject** ppObject, long lFlags,  
								CDSCallResult * pCallRes, 
								IWbemObjectSink* pResponseHandler)
{
	if(ppObject == NULL || *ppObject == NULL)
		return WBEM_E_INVALID_PARAMETER;

	bool bAsync = pResponseHandler || (pCallRes && (lFlags & WBEM_FLAG_RETURN_IMMEDIATELY));
	CRefreshObjectRequest * pReq = new CRefreshObjectRequest(ppObject, lFlags,  
												pCallRes, pResponseHandler, bAsync,
												 m_pUmiContainer);
	return CreateThreadOrCallDirectly(bAsync, pReq);
}


STDMETHODIMP CDSSvcExWrapper::PutClass(IWbemClassObject* pObject, long lFlags,
	IWbemContext* pContext, IWbemCallResult** ppResult)
{
	CDSCallResult * pCallRes = NULL;
	HRESULT hr = AllocateCallResult(ppResult, &pCallRes);
	if(FAILED(hr))
		return hr;
	return PutObjectPreCall(pObject, lFlags, pContext, pCallRes, NULL);
}

STDMETHODIMP CDSSvcExWrapper::PutClassAsync(IWbemClassObject* pObject, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
	return PutObjectPreCall(pObject, lFlags, pContext, NULL, pResponseHandler);
}

STDMETHODIMP CDSSvcExWrapper::PutInstance(IWbemClassObject* pInst, long lFlags,
	IWbemContext* pContext, IWbemCallResult** ppResult)
{
	CDSCallResult * pCallRes = NULL;
	HRESULT hr = AllocateCallResult(ppResult, &pCallRes);
	if(FAILED(hr))
		return hr;
	return PutObjectPreCall(pInst, lFlags, pContext, pCallRes, NULL);
}

STDMETHODIMP CDSSvcExWrapper::PutInstanceAsync(IWbemClassObject* pInst, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
	return PutObjectPreCall(pInst, lFlags, pContext, NULL, pResponseHandler);
}

HRESULT CDSSvcExWrapper::PutObjectPreCall(IWbemClassObject * pClass, long lFlags, IWbemContext* pContext, 
								CDSCallResult * pCallRes, 
								IWbemObjectSink* pResponseHandler)
{

	if(pClass == NULL)
		return WBEM_E_INVALID_PARAMETER;

	long	lSecurityFlags = 0L;
	HRESULT hr = CheckSecuritySettings( lFlags, pContext, &lSecurityFlags, TRUE );
	if(FAILED(hr))
		return hr;

	bool bAsync = pResponseHandler || (pCallRes && (lFlags & WBEM_FLAG_RETURN_IMMEDIATELY));
	CPutObjectRequest * pReq = new CPutObjectRequest(pClass, lFlags, pContext,   
												pCallRes, pResponseHandler, bAsync,
												 m_pUmiContainer, lSecurityFlags);
	return CreateThreadOrCallDirectly(bAsync, pReq);
}

STDMETHODIMP CDSSvcExWrapper::DeleteClass(const BSTR Class, long lFlags, IWbemContext* pContext,
	IWbemCallResult** ppResult)
{
	CDSCallResult * pCallRes = NULL;
	HRESULT hr = AllocateCallResult(ppResult, &pCallRes);
	if(FAILED(hr))
		return hr;
	return DeleteObjectPreCall(Class, lFlags, pContext, pCallRes, NULL, true);
}

STDMETHODIMP CDSSvcExWrapper::DeleteClassAsync(const BSTR Class, long lFlags, IWbemContext* pContext,
	IWbemObjectSink* pResponseHandler)
{
	return DeleteObjectPreCall(Class, lFlags, pContext, NULL, pResponseHandler, true);
}

STDMETHODIMP CDSSvcExWrapper::DeleteInstance(const BSTR ObjectPath, long lFlags,
	IWbemContext* pContext, IWbemCallResult** ppResult)
{
	CDSCallResult * pCallRes = NULL;
	HRESULT hr = AllocateCallResult(ppResult, &pCallRes);
	if(FAILED(hr))
		return hr;
	return DeleteObjectPreCall(ObjectPath, lFlags, pContext, pCallRes, NULL, false);
}

STDMETHODIMP CDSSvcExWrapper::DeleteInstanceAsync(const BSTR ObjectPath, long lFlags,
	IWbemContext* pContext, IWbemObjectSink* pResponseHandler)
{
	return DeleteObjectPreCall(ObjectPath, lFlags, pContext, NULL, pResponseHandler, false);
}

HRESULT CDSSvcExWrapper::DeleteObjectPreCall(const BSTR Class, long lFlags, IWbemContext* pContext, 
								CDSCallResult * pCallRes, 
								IWbemObjectSink* pResponseHandler, bool bClass)
{
	if(Class == NULL)
		return WBEM_E_INVALID_PARAMETER;

	IUmiURL * pURL = NULL;
    HRESULT hr = CreateURL(Class, 0L, &pURL);
    if(FAILED(hr))
		return hr;
    CReleaseMe rm(pURL);

	bool bAsync = pResponseHandler || (pCallRes && (lFlags & WBEM_FLAG_RETURN_IMMEDIATELY));
	CDeleteObjectRequest * pReq = new CDeleteObjectRequest(pURL, lFlags, pContext,   
												pCallRes, pResponseHandler, bAsync,
												 m_pUmiContainer, bClass);
	return CreateThreadOrCallDirectly(bAsync, pReq);

}

STDMETHODIMP CDSSvcExWrapper::RenameObject(
    /* [in] */ const BSTR strOldObjectPath,
    /* [in] */ const BSTR strNewObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult)
{
	CDSCallResult * pCallRes = NULL;
	HRESULT hr = AllocateCallResultEx(ppCallResult, &pCallRes);
	if(FAILED(hr))
		return hr;
	return RenameObjectPreCall(strOldObjectPath, strNewObjectPath, lFlags, pCtx, pCallRes, NULL);

}

STDMETHODIMP CDSSvcExWrapper::RenameObjectAsync(
    /* [in] */ const BSTR strOldObjectPath,
    /* [in] */ const BSTR strNewObjectPath,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pCtx,
    /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler)
{
	return RenameObjectPreCall(strOldObjectPath, strNewObjectPath, lFlags, pCtx, NULL, pResponseHandler);
}

HRESULT CDSSvcExWrapper::RenameObjectPreCall(const BSTR OldPath, const BSTR NewPath, long lFlags, IWbemContext* pContext, 
								CDSCallResult * pCallRes, 
								IWbemObjectSink* pResponseHandler)
{
	if(m_pUmiContainer == NULL)
		return WBEM_E_FAILED;
	if(OldPath == NULL || NewPath == NULL)
		return WBEM_E_INVALID_PARAMETER;

	if(lFlags != 0 && lFlags != WBEM_FLAG_RETURN_IMMEDIATELY)
		return WBEM_E_INVALID_PARAMETER;

	long lFlagsForAdsi = lFlags & ~WBEM_FLAG_RETURN_IMMEDIATELY;

	IUmiURL * pOldPathURL = NULL;
    HRESULT hr = CreateURL(OldPath, 0, &pOldPathURL);
    if(FAILED(hr))
		return hr;
    CReleaseMe rm1(pOldPathURL);

	IUmiURL * pNewPathURL = NULL;
    hr = CreateURL(NewPath, 0, &pNewPathURL);
    if(FAILED(hr))
		return hr;
    CReleaseMe rm2(pNewPathURL);

	bool bAsync = pResponseHandler || (pCallRes && (lFlags & WBEM_FLAG_RETURN_IMMEDIATELY));
	CRenameObjectRequest * pReq = new CRenameObjectRequest(pOldPathURL, pNewPathURL, lFlagsForAdsi, pContext,   
												pCallRes, pResponseHandler, bAsync,
												 m_pUmiContainer);
	return CreateThreadOrCallDirectly(bAsync, pReq);
}

BOOL IsInstance(const BSTR Path)
{
    IUmiURL * pPathURL = NULL;
    HRESULT hr = CreateURL(Path, UMIPATH_CREATE_AS_EITHER, &pPathURL);
    if(FAILED(hr))
		FALSE;
    CReleaseMe rm(pPathURL);
    ULONGLONG uInfo;
    hr = pPathURL->GetPathInfo(0, &uInfo); 
    if(SUCCEEDED(hr) && (uInfo & UMIPATH_INFO_INSTANCE_PATH))
        return TRUE;
    else
        return FALSE;
}

STDMETHODIMP CDSSvcExWrapper::DeleteObject(
	/* [in] */ const BSTR strObjectPath,
	/* [in] */ long lFlags,
	/* [in] */ IWbemContext* pCtx,
	/* [out, OPTIONAL] */ IWbemCallResult** ppCallResult
	)
{

    if(IsInstance(strObjectPath))
        return DeleteInstance(strObjectPath, lFlags, pCtx, ppCallResult);
    else
        return WBEM_E_INVALID_PARAMETER;
}

STDMETHODIMP CDSSvcExWrapper::DeleteObjectAsync(
	/* [in] */ const BSTR strObjectPath,
	/* [in] */ long lFlags,
	/* [in] */ IWbemContext* pCtx,
	/* [in] */ IWbemObjectSink* pResponseHandler
	)
{
    if(IsInstance(strObjectPath))
        return DeleteClassAsync(strObjectPath, lFlags, pCtx, pResponseHandler);
    else
        return WBEM_E_INVALID_PARAMETER;
}

STDMETHODIMP CDSSvcExWrapper::PutObject(
	/* [in] */ IWbemClassObject* pObj,
	/* [in] */ long lFlags,
	/* [in] */ IWbemContext* pCtx,
	/* [out, OPTIONAL] */ IWbemCallResult** ppCallResult
	)
{
	CDSCallResult * pCallRes = NULL;
	HRESULT hr = AllocateCallResult(ppCallResult, &pCallRes);
	if(FAILED(hr))
		return hr;
	return PutObjectPreCall(pObj, lFlags, pCtx, pCallRes, NULL);
}

STDMETHODIMP CDSSvcExWrapper::PutObjectAsync(
	/* [in] */ IWbemClassObject* pObj,
	/* [in] */ long lFlags,
	/* [in] */ IWbemContext* pCtx,
	/* [in] */ IWbemObjectSink* pResponseHandler
	)
{
	return PutObjectPreCall(pObj, lFlags, pCtx, NULL, pResponseHandler);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\cprovloc.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CPROVLOC.CPP

Abstract:

    Defines the CProviderLoc object

History:

    davj  30-Oct-00   Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <wbemint.h>
//#include "corepol.h"
#include <reg.h>
#include <wbemutil.h>
#include <wbemprox.h>
#include <flexarry.h>
#include "sinkwrap.h"
#include "cprovloc.h"
#include "proxutil.h"
#include "comtrans.h"
#include <arrtempl.h>

#define IsSlash(x) (x == L'\\' || x== L'/')

//***************************************************************************
//
//  CProviderLoc::CProviderLoc
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CProviderLoc::CProviderLoc(DWORD dwType)
{
    m_cRef=0;
    InterlockedIncrement(&g_cObj);
    m_dwType = dwType;
}

//***************************************************************************
//
//  CProviderLoc::~CProviderLoc
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CProviderLoc::~CProviderLoc(void)
{
    InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CProviderLoc::QueryInterface
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CProviderLoc::QueryInterface (

    IN REFIID riid,
    OUT PPVOID ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || riid == IID_IWbemLocator)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


//***************************************************************************
//
//  SCODE CProviderLoc::ConnectServer
//
//  DESCRIPTION:
//
//  Connects up to either local or remote WBEM Server.  Returns
//  standard SCODE and more importantly sets the address of an initial
//  stub pointer.
//
//  PARAMETERS:
//
//  NetworkResource     Namespace path
//  User                User name
//  Password            password
//  LocaleId            language locale
//  lFlags              flags
//  Authority           domain
//  ppProv              set to provdider proxy
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE CProviderLoc::ConnectServer (
    IN const BSTR NetworkResource,
    IN const BSTR User,
    IN const BSTR Password,
    IN const BSTR LocaleId,
    IN long lFlags,
    IN const BSTR Authority,
    IWbemContext __RPC_FAR *pCtx,
    OUT IWbemServices FAR* FAR* ppProv
)
{
    SCODE sc = S_OK;
    BOOL bOutOfProc = FALSE;            // Set below
    IWbemLocator * pActualLocator = NULL;
    IWbemLevel1Login * pLevel1 = NULL;
    if(NetworkResource == NULL || ppProv == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // make sure they are not specifying a server

    LPWSTR ObjectPath = NetworkResource;
    if (IsSlash(ObjectPath[0]) && IsSlash(ObjectPath[1]))
    {
        if(!IsSlash(ObjectPath[3]) || ObjectPath[2] != L'.')
            return WBEM_E_INVALID_PARAMETER;
    }

    // Get the normal login pointer.

    sc = CoCreateInstance(CLSID_WbemLevel1Login, NULL, 
           CLSCTX_LOCAL_SERVER | CLSCTX_INPROC_SERVER, IID_IWbemLevel1Login,(void **)&pLevel1);
    
    if(FAILED(sc))
        return sc;
    CReleaseMe rm(pLevel1);

    // determine if winmgmt is inproc.  Do so by checking if there is an IClientSecurity interface

    IClientSecurity * pCliSec = NULL;
    sc = pLevel1->QueryInterface(IID_IClientSecurity, (void **)&pCliSec);
    if(SUCCEEDED(sc) && pCliSec)
    {
        // We are out of proc, then use the current dcomtrans logic

        pCliSec->Release();
        CDCOMTrans * pDcomTrans = new CDCOMTrans;
        if(pDcomTrans == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        pDcomTrans->AddRef();
        sc = pDcomTrans->DoConnection(NetworkResource, User, Password, LocaleId, lFlags,                 
                Authority, pCtx, IID_IWbemServices, (void **)ppProv, TRUE);
        pDcomTrans->Release();
        return sc;
    }

    // If we are inproc, get the class from wbemcore.dll and forward the call on to it.

    switch(m_dwType)
    {
    case ADMINLOC:
        sc = CoCreateInstance(CLSID_ActualWbemAdministrativeLocator, NULL, 
                    CLSCTX_INPROC_SERVER, IID_IWbemLocator,(void **)&pActualLocator);
        break;
    case AUTHLOC:
        sc = CoCreateInstance(CLSID_ActualWbemAuthenticatedLocator, NULL, 
                    CLSCTX_INPROC_SERVER, IID_IWbemLocator,(void **)&pActualLocator);
        break;
    case UNAUTHLOC:
        sc = CoCreateInstance(CLSID_ActualWbemUnauthenticatedLocator, NULL, 
                    CLSCTX_INPROC_SERVER, IID_IWbemLocator,(void **)&pActualLocator);
        break;
    default:
        return WBEM_E_FAILED;
    }

    if(FAILED(sc))
        return sc;
    CReleaseMe rm3(pActualLocator);
    sc = pActualLocator->ConnectServer(NetworkResource, User, Password, LocaleId,
                                lFlags, Authority, pCtx, ppProv);
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\dsenum.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    DSENUM.CPP

Abstract:

    Implements the class implementing IEnumWbemClassObject interface.

    Classes defined:

        CEnumWbemClassObject

History:

    davj        28-Mar-00       Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <wbemint.h>
#include <umi.h>
#include <arrtempl.h>
#include <sync.h>
#include "dsenum.h"



CEnumInterface::CEnumInterface()
{
	m_lRef = 1;
	m_pColl = NULL;
	m_lNextRecord = 0;
	m_hNotifyEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
	InitializeCriticalSection(&m_cs);
}


CEnumInterface::~CEnumInterface()
{
	if(m_pColl)
		m_pColl->Release();
	m_pColl = NULL;
	CloseHandle(m_hNotifyEvent);
	DeleteCriticalSection(&m_cs);
}

void CEnumInterface::SetCollector(CCollection * pCol)
{
	m_pColl = pCol;
	m_pColl->AddRef();
}

SCODE CEnumInterface::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if (IID_IUnknown==riid || IID_IEnumWbemClassObject == riid)
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP CEnumInterface::Reset()
{
	CInCritSec ics(&m_cs);
	m_lNextRecord = 0;
	return S_OK;
}

typedef IUnknown * PUNK;

STDMETHODIMP CEnumInterface::Next(long lTimeout, ULONG uCount,
                IWbemClassObject** apObj, ULONG* puReturned)
{
	CInCritSec ics(&m_cs);
    *puReturned = 0;
	HRESULT hr;
    if(lTimeout < 0 && lTimeout != -1)
        return WBEM_E_INVALID_PARAMETER;
	long lLastNeeded = m_lNextRecord+uCount-1;
	long lNumReturned;
	long lRet = m_pColl->GetRecords(m_lNextRecord, lLastNeeded, &lNumReturned, apObj, &hr);
	m_lNextRecord += lNumReturned;
	*puReturned = lNumReturned;
	HANDLE hForCollToClose;

	switch (lRet)
	{
	case 0:				// got everything we asked for
	case 1:				// got some, no more is available
		*puReturned = lNumReturned;
		return hr;
	case 2:				// got some, but more may be coming
		if(lTimeout == 0)
		{
			// dont want to wait, leave now
			*puReturned = lNumReturned;
			return hr;
		}
		DuplicateHandle(GetCurrentProcess(), m_hNotifyEvent, GetCurrentProcess(),
						&hForCollToClose, EVENT_ALL_ACCESS, FALSE, 0);

		m_pColl->NotifyAtNumber(hForCollToClose, lLastNeeded);
		WaitForSingleObject(m_hNotifyEvent, lTimeout);
		lRet = m_pColl->GetRecords(m_lNextRecord, lLastNeeded, &lNumReturned, apObj+lNumReturned, &hr);
		m_lNextRecord += lNumReturned;
		*puReturned += lNumReturned;
		
	case 3:				// error, give up and go away
		return hr;
	}	
	return hr;
}

HRESULT CEnumInterface::NextAsync(ULONG uCount, IWbemObjectSink* pSink)
{
	CInCritSec ics(&m_cs);
    if(pSink == NULL)
        return WBEM_E_INVALID_PARAMETER;
	HRESULT hr = m_pColl->AddSink(m_lNextRecord,m_lNextRecord + uCount -1, pSink);
	if(SUCCEEDED(hr))
		m_lNextRecord += uCount;
	return hr;
}

STDMETHODIMP CEnumInterface::Clone(IEnumWbemClassObject** ppEnum)
{
	CInCritSec ics(&m_cs);
	CEnumInterface * pEnum = new CEnumInterface();	// Created with a ref count of 1
	if(pEnum == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	*ppEnum = pEnum;
	pEnum->SetCollector(m_pColl);
	pEnum->m_lNextRecord = m_lNextRecord;
	return S_OK;
}

typedef IWbemClassObject * PWCO;

HRESULT CEnumInterface::Skip(long lTimeout, ULONG nNum)
{
	CInCritSec ics(&m_cs);
	PWCO * pArray = new PWCO[nNum];
	if(pArray == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	CDeleteMe<PWCO> dm1(pArray);

	ULONG uReturned;
	HRESULT hr = Next(lTimeout, nNum, pArray, &uReturned);
	if(hr == S_OK)
	{
		for(DWORD dwCnt = 0; dwCnt < uReturned; dwCnt++)
			pArray[dwCnt]->Release();
	}
	return WBEM_E_NOT_AVAILABLE;
}


CCollection::CCollection()
{
	m_lRef = 1;
	InitializeCriticalSection(&m_cs);
	m_bDone = false;
	m_hr = S_OK;
}


CCollection::~CCollection()
{
	DWORD dwCnt;
	for(dwCnt = 0; dwCnt < m_SinksToBeNotified.Size(); dwCnt++)
	{
		NotifySink * pDel = (NotifySink *)m_SinksToBeNotified.GetAt(dwCnt);
		delete pDel;
	}
	for(dwCnt = 0; dwCnt < m_InterfacesToBeNotifid.Size(); dwCnt++)
	{
		InterfaceToBeNofified * pDel = (InterfaceToBeNofified *)m_InterfacesToBeNotifid.GetAt(dwCnt);
		delete pDel;
	}
	for(dwCnt = 0; dwCnt < m_Objects.Size(); dwCnt++)
	{
		IWbemClassObject * pRel = (IWbemClassObject *)m_Objects.GetAt(dwCnt);
		pRel->Release();
	}
	DeleteCriticalSection(&m_cs);
}

//***************************************************************************
//
//  See objenum.h for documentation.
//
//***************************************************************************

SCODE CCollection::QueryInterface(REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    if (IID_IUnknown==riid)
    {
        *ppvObj = this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

long CCollection::GetRecords(long lFirstRecord, long lLastRecord, long * plNumReturned, 
							 IWbemClassObject **apObjects, HRESULT * phr)
{
	CInCritSec ics(&m_cs);
	long lBuffSize = m_Objects.Size();
	long lNumRet = 0;
	for(DWORD dwCnt = lFirstRecord; dwCnt <= lLastRecord; dwCnt++)
	{
		if(dwCnt >= lBuffSize)
			break;
		IWbemClassObject * pObj = (IWbemClassObject *)m_Objects.GetAt(dwCnt);
		pObj->AddRef();
		apObjects[lNumRet] = pObj;		
		lNumRet++;
	}
	*plNumReturned = lNumRet;
	long lNumRequested = lLastRecord - lFirstRecord +1;
	if(lNumRet == lNumRequested)
	{
		*phr = S_OK;
		return 0;
	}
	if(m_bDone)
	{
		*phr = WBEM_S_FALSE;
		return 1;
	}
	else
	{
		*phr = WBEM_S_TIMEDOUT;
		return 2;
	}
}
HRESULT CCollection::NotifyAtNumber(HANDLE hForCollToClose, long lLastRecord)
{
	CInCritSec ics(&m_cs);
	InterfaceToBeNofified * pNew = new InterfaceToBeNofified(hForCollToClose, lLastRecord);
	if(pNew == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	m_InterfacesToBeNotifid.Add(pNew);
	return S_OK;
}

HRESULT CCollection::AddObjectsToList(IWbemClassObject **Array, long lNumObj)
{
	CInCritSec ics(&m_cs);

	long lFirst = m_Objects.Size();
	long lLast = lFirst + lNumObj -1;

	long lCollPos = m_Objects.Size();

	// Add to the list.

	for(long lCurr = 0; lCurr < lNumObj; lCurr++, lCollPos++)
	{
		IWbemClassObject * pObj = Array[lCurr];
		m_Objects.Add(pObj);

		// Go through the list of sinks and notify any that want this

		for(DWORD dwSink = 0; dwSink < m_SinksToBeNotified.Size(); dwSink++)
		{
			NotifySink * pCurr = (NotifySink *)m_SinksToBeNotified.GetAt(dwSink);
			if(lCollPos >= pCurr->m_lFirstRecord && 
			   (lCollPos <= pCurr->m_lLastRecord || pCurr->m_lLastRecord == -1))
				pCurr->m_pSink->Indicate(1, &pObj);
		}
	}

	// Go through the list of Next/skip calls that are waiting

	for(DWORD dwInt = 0; dwInt < m_InterfacesToBeNotifid.Size(); dwInt++)
	{
		InterfaceToBeNofified * pCurr = (InterfaceToBeNofified *)m_InterfacesToBeNotifid.GetAt(dwInt);
		if(lCollPos >= pCurr->m_lLastRecord)
		{
			SetEvent(pCurr->m_hDoneEvent);
			delete pCurr;
			m_InterfacesToBeNotifid.RemoveAt(dwInt);
			dwInt--;
		}
	}
	return S_OK;
}

HRESULT CCollection::AddSink(long lFirst, long lLast, IWbemObjectSink * pSink)
{
	CInCritSec ics(&m_cs);
	NotifySink * pNew = new NotifySink(pSink, lFirst, lLast);
	if(pNew == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	m_SinksToBeNotified.Add(pNew);
	// do an indicate for all the stuff we already have
	
	
	for(DWORD dwCnt = 0; dwCnt < m_Objects.Size(); dwCnt++)
	{
		if(dwCnt >= lFirst && (dwCnt <= lLast || lLast == -1))
		{
			PWCO pObj = (PWCO)m_Objects.GetAt(dwCnt);
			pSink->Indicate(1, &pObj);
		}
	}

	return S_OK;

}

void CCollection::SetDone(HRESULT hr)
{
	CInCritSec ics(&m_cs);
	m_hr = hr;
	m_bDone = true;

	// Set status for all the sinks

	for(DWORD dwSink = 0; dwSink < m_SinksToBeNotified.Size(); dwSink++)
	{
		NotifySink * pCurr = (NotifySink *)m_SinksToBeNotified.GetAt(dwSink);
		pCurr->m_pSink->SetStatus(0, hr, NULL, NULL);
		delete pCurr;
		m_SinksToBeNotified.RemoveAt(dwSink);
		dwSink--;
	}

	// Go through the list of Next/skip calls that are waiting

	for(DWORD dwInt = 0; dwInt < m_InterfacesToBeNotifid.Size(); dwInt++)
	{
		InterfaceToBeNofified * pCurr = (InterfaceToBeNofified *)m_InterfacesToBeNotifid.GetAt(dwInt);
		SetEvent(pCurr->m_hDoneEvent);
		delete pCurr;
		m_InterfacesToBeNotifid.RemoveAt(dwInt);
		dwInt--;
	}
	return;

}

CCreateInstanceEnumRequest::CCreateInstanceEnumRequest(IUmiCursor *  pCursor, long lFlags, 
													   CEnumInterface * pEnum, IWbemObjectSink * pSink,
													   CCollection * pColl, long lSecurityFlags)
{
	m_pCursor = pCursor;
	if(m_pCursor)
		m_pCursor->AddRef();
	m_lFlags = lFlags;
	m_pEnum = pEnum;
	if(m_pEnum)
		m_pEnum->AddRef();
	m_pSink = pSink;
	if(m_pSink)
		m_pSink->AddRef();
	m_pColl = pColl;
	if(m_pColl)
		m_pColl->AddRef();
	m_bAsync = false;
	m_lSecurityFlags = lSecurityFlags;
}

CCreateInstanceEnumRequest::~CCreateInstanceEnumRequest()
{
	if(m_pCursor)
		m_pCursor->Release();
	if(m_pEnum)
		m_pEnum->Release();
	if(m_pSink)
		m_pSink->Release();
	if(m_pColl)
		m_pColl->Release();
	m_pCursor = NULL;
	m_pEnum = NULL;
	m_pSink = NULL;
	m_pColl = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\dsumicont.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    DSUMICONT.H

Abstract:

   Defines the CDsUmiWrapCallResult class which hides some implementation
   specific detains of the DS teams implementation of the UMI

History:

--*/

#ifndef __DSUMICONT_RESULT__H_
#define __DSUMICONT_RESULT__H_

class CDsUmiContainer : public IUmiContainer, public _IUmiDsWrapper
{
protected:
    long m_lRef;
    IUmiContainer *m_pUmiContainer;
    IUmiContainer *m_pUmiClassContainer;
	IUmiConnection *m_pIUmiConn;
public:

	// IUnknown

    STDMETHOD_(ULONG, AddRef)() {return InterlockedIncrement(&m_lRef);}
    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0)
            delete this;
        return lRef;
    }
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);

	// IUmiPropList

    HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
    HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
    HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
    HRESULT STDMETHODCALLTYPE GetAs( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
    HRESULT STDMETHODCALLTYPE FreeMemory( 
            ULONG uReserved,
            LPVOID pMem);
        
    HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
    HRESULT STDMETHODCALLTYPE GetProps( 
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
    HRESULT STDMETHODCALLTYPE PutProps( 
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
    HRESULT STDMETHODCALLTYPE PutFrom( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
  
	// IUmiBaseObject

    HRESULT STDMETHODCALLTYPE GetLastStatus( 
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
    HRESULT STDMETHODCALLTYPE GetInterfacePropList( 
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);



	// IUmiObject

	HRESULT STDMETHODCALLTYPE Clone( 
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);
        
    HRESULT STDMETHODCALLTYPE Refresh( 
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uNameCount,
            /* [in] */ LPWSTR __RPC_FAR *pszNames);
        
    HRESULT STDMETHODCALLTYPE CopyTo(
			/* [in] */ ULONG uFlags,
			/* [in] */ IUmiURL *pURL,
			/* [in] */ REFIID riid,
			/* [out, iid_is(riid)] */ LPVOID *pCopy);

    HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ ULONG uFlags);

	// IUmiContainer

    HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes);
        
    HRESULT STDMETHODCALLTYPE PutObject( 
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out][in] */ void __RPC_FAR *pObj);
        
    HRESULT STDMETHODCALLTYPE DeleteObject( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [optional][in] */ ULONG uFlags);
        
    HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiObject __RPC_FAR *__RPC_FAR *pNewObj);
        
    HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pOldURL,
            /* [in] */ IUmiURL __RPC_FAR *pNewURL);
        
    HRESULT STDMETHODCALLTYPE CreateEnum( 
            /* [in] */ IUmiURL __RPC_FAR *pszEnumContext,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvEnum);
        
    HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ IUmiQuery __RPC_FAR *pQuery,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppResult);

    STDMETHOD(GetRealContainer)( IUnknown** pUnk );
			

public:
    CDsUmiContainer();
    ~CDsUmiContainer();
	HRESULT SetInterface(IUmiContainer * pUmiContainer, IUmiURL * pPath, IUmiConnection *pIUmiConn);
};



#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\dsumicont.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    DSUMICONT.CPP

Abstract:

    Call Result Class

History:

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <wbemint.h>
#include <umi.h>
#include <arrtempl.h>
#include <wbemutil.h>
#include "DsUmiCont.h"

#pragma warning(disable:4355)

HRESULT ConvertClassPath(IUmiURL * pPath)
{

    ULONG uLength = 0;

	// Read the class name, it is something like "user"

	HRESULT hr = pPath->GetLeafName(&uLength, NULL);
	if(FAILED(hr))
		return hr;
	WCHAR * pClassName = new WCHAR[uLength];
	if(pClassName == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	CDeleteMe<WCHAR> dm(pClassName);

	hr = pPath->GetLeafName(&uLength, pClassName);
	if(FAILED(hr))
		return hr;

	// Now set the path to "class.name=user"

	IUmiURLKeyList * pKeyList;
	hr = pPath->GetKeyList(&pKeyList);
	if(FAILED(hr))
		return hr;
	CReleaseMe rm(pKeyList);
	hr = pKeyList->SetKey(L"name", pClassName);
	if(FAILED(hr))
		return hr;
	return pPath->SetLeafName(L"class");
}

CDsUmiContainer::CDsUmiContainer()
{
    m_pUmiContainer = NULL;
    m_pUmiClassContainer = NULL;
	m_pIUmiConn = NULL;
	m_lRef = 0;
}


CDsUmiContainer::~CDsUmiContainer()
{
    if(m_pUmiContainer)
		m_pUmiContainer->Release();
    if(m_pUmiClassContainer)
		m_pUmiClassContainer->Release();
	if(m_pIUmiConn)
		m_pIUmiConn->Release();
}

HRESULT CDsUmiContainer::SetInterface(IUmiContainer * pUmiContainer, IUmiURL * pPath, 
													IUmiConnection *pIUmiConn)
{
	HRESULT hr;

	if(pUmiContainer == NULL || pPath == NULL || pIUmiConn == NULL)
		return WBEM_E_INVALID_PARAMETER;
	m_pUmiContainer = pUmiContainer;
	m_pUmiContainer->AddRef();

	m_pIUmiConn = pIUmiConn;
	m_pIUmiConn->AddRef();

    UMI_PROPERTY_VALUES * pPropValues;

	IUmiPropList*	pPropList = NULL;

	// The _Schema property in the interface property list will contain the actual
	// path to the schema for the container.  The schema path would properly be
	// obtained by an interface property from the connection.  In the meantime
	// we will get this value and march forwards through it until we find the
	// word schema and assume that is the path to the schema container.

	hr = m_pUmiContainer->GetInterfacePropList( 0L, &pPropList );
	CReleaseMe	rm(pPropList);

	// Inability to get the schema container is not a critical failure
	if ( SUCCEEDED( hr ) )
		hr = pPropList->Get(L"__PADS_SCHEMA_CONTAINER_PATH", 0, &pPropValues);

	if(FAILED(hr))
	{
		ERRORTRACE((LOG_WBEMPROX, "Get Schema Container Path failed, return code = 0x%x\n",hr)); 
		return WBEM_S_NO_ERROR;
	}

    UMI_PROPERTY *pProp;
	pProp = pPropValues->pPropArray;   //  wcValue

	// Grab the class container.	
	
	LPWSTR * ppStr = (LPWSTR *)pProp->pUMIValue;
	LPWSTR	pwcsSchema = *ppStr;
	
	pPath->Set( 0, pwcsSchema);

    hr = m_pIUmiConn->Open(
         pPath,
         0,
         IID_IUmiContainer,
         (void **) &m_pUmiClassContainer
         );

	// Inability to connect to the schema container is not a critical failure
	if(FAILED(hr))
	{
		ERRORTRACE((LOG_WBEMPROX, "Connecting to schema container failed, return code = 0x%x\n",hr)); 
		return WBEM_S_NO_ERROR;
	}
	
	return S_OK;
}

STDMETHODIMP CDsUmiContainer::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IUmiContainer)
    {
        AddRef();
        *ppv = (IUmiContainer*)this;
        return S_OK;
    }
    else if(riid == IID__IUmiDsWrapper )
    {
        AddRef();
        *ppv = (_IUmiDsWrapper*)this;
        return S_OK;
    }
    else return E_NOINTERFACE;
}

HRESULT CDsUmiContainer::Put( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp)
{
	IUmiPropList * pTemp = m_pUmiContainer;
	return pTemp->Put(pszName, uFlags, pProp);
}

        
HRESULT CDsUmiContainer::Get( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp)
{
	return m_pUmiContainer->Get(pszName, uFlags, pProp);
}
        
HRESULT CDsUmiContainer::GetAt( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem)
{
	return m_pUmiContainer->GetAt(pszName, uFlags, uBufferLength, pExistingMem);
}
        
HRESULT CDsUmiContainer::GetAs( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp)
{
	return m_pUmiContainer->GetAs(pszName, uFlags, uCoercionType, pProp);
}
        
HRESULT CDsUmiContainer::FreeMemory( 
            ULONG uReserved,
            LPVOID pMem)
{
	return m_pUmiContainer->FreeMemory(uReserved, pMem);
}
        
HRESULT CDsUmiContainer::Delete( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags)
{
	IUmiPropList * pTemp = m_pUmiContainer;
	return pTemp->Delete(pszName, uFlags);
}
        
HRESULT CDsUmiContainer::GetProps( 
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps)
{
	return m_pUmiContainer->GetProps(pszNames, uNameCount, uFlags, pProps);
}
        
HRESULT CDsUmiContainer::PutProps( 
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps)
{
	return m_pUmiContainer->PutProps(pszNames, uNameCount, uFlags, pProps);

}
        
HRESULT CDsUmiContainer::PutFrom( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem)
{
	return m_pUmiContainer->PutFrom(pszName, uFlags, uBufferLength, pExistingMem);
}
  
// IUmiBaseObject

HRESULT CDsUmiContainer::GetLastStatus( 
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj)
{
	return m_pUmiContainer->GetLastStatus(uFlags, puSpecificStatus, riid, pStatusObj);
}
        
HRESULT CDsUmiContainer::GetInterfacePropList( 
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList)
{
	return m_pUmiContainer->GetInterfacePropList(uFlags, pPropList);
}


	// IUmiObject

HRESULT CDsUmiContainer::Clone( 
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy)
{
	return m_pUmiContainer->Clone(uFlags, riid, pCopy);
}
        
HRESULT CDsUmiContainer::Refresh( 
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uNameCount,
            /* [in] */ LPWSTR __RPC_FAR *pszNames)
{
	return m_pUmiContainer->Refresh(uFlags, uNameCount, pszNames);
}
        
HRESULT CDsUmiContainer::CopyTo(
		/* [in] */ ULONG uFlags,
		/* [in] */ IUmiURL *pURL,
		/* [in] */ REFIID riid,
		/* [out, iid_is(riid)] */ LPVOID *pCopy)
{
	return m_pUmiContainer->CopyTo(uFlags, pURL, riid, pCopy);
}

HRESULT CDsUmiContainer::Commit( 
            /* [in] */ ULONG uFlags)
{
	return m_pUmiContainer->Commit(uFlags);
}


HRESULT CDsUmiContainer::Open( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes)
{
	BOOL bClass = uFlags & UMI_OPERATION_CLASS;
	uFlags = uFlags & ~(UMI_OPERATION_CLASS|UMI_OPERATION_INSTANCE);

	if(bClass)
	{
		// Can't do a schema operation if we don't have a schema container
		if ( NULL == m_pUmiClassContainer )
		{
			return WBEM_E_NO_SCHEMA;
		}

		HRESULT hr = ConvertClassPath(pURL);
		if(FAILED(hr))
			return hr;
		return m_pUmiClassContainer->Open(pURL,uFlags,TargetIID,ppvRes);
	}
	else
	{
		// Two cases, we are either getting an object or a container

		if(TargetIID != IID_IUmiContainer)
			return m_pUmiContainer->Open(pURL,uFlags,TargetIID,ppvRes);
		else
		{
			IUmiContainer * pCont = NULL;
			HRESULT hr = m_pUmiContainer->Open(pURL,uFlags,TargetIID,(void **)&pCont);
			if(FAILED(hr))
				return hr;
			CReleaseMe rm(pCont);
			CDsUmiContainer * pNew = new CDsUmiContainer();
			if(pNew == NULL)
				return WBEM_E_OUT_OF_MEMORY;
			hr = pNew->SetInterface(pCont, pURL, m_pIUmiConn);
			if(FAILED(hr))
			{
				delete pNew;
				return hr;
			}
			return pNew->QueryInterface(IID_IUmiContainer, ppvRes);
		}
	}
}
        
HRESULT CDsUmiContainer::PutObject(            
			/* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out][in] */ void __RPC_FAR *pObj)
{
	return m_pUmiContainer->PutObject(uFlags,TargetIID,pObj);
}
        
HRESULT CDsUmiContainer::DeleteObject( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [optional][in] */ ULONG uFlags)
{
	BOOL bClass = uFlags & UMI_OPERATION_CLASS;
	uFlags = uFlags & ~(UMI_OPERATION_CLASS|UMI_OPERATION_INSTANCE);

	if(bClass)
	{
		// Can't do a schema operation if we don't have a schema container
		if ( NULL == m_pUmiClassContainer )
		{
			return WBEM_E_NO_SCHEMA;
		}

		return m_pUmiClassContainer->DeleteObject(pURL,uFlags);
	}
	else
	{
		return m_pUmiContainer->DeleteObject(pURL,uFlags);
	}
}
        
HRESULT CDsUmiContainer::Create( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiObject __RPC_FAR *__RPC_FAR *pNewObj)
{
	BOOL bClass = uFlags & UMI_OPERATION_CLASS;
	uFlags = uFlags & ~(UMI_OPERATION_CLASS|UMI_OPERATION_INSTANCE);

	if(bClass)
	{
		// Can't do a schema operation if we don't have a schema container
		if ( NULL == m_pUmiClassContainer )
		{
			return WBEM_E_NO_SCHEMA;
		}

		return m_pUmiClassContainer->Create(pURL,uFlags,pNewObj);
	}
	else
	{
		return m_pUmiContainer->Create(pURL,uFlags,pNewObj);
	}
}
        
HRESULT CDsUmiContainer::Move( 
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pOldURL,
            /* [in] */ IUmiURL __RPC_FAR *pNewURL)
{
	return m_pUmiContainer->Move(uFlags,pOldURL,pNewURL);
}
        
HRESULT CDsUmiContainer::CreateEnum( 
            /* [in] */ IUmiURL __RPC_FAR *pszEnumContext,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvEnum)
{
	BOOL bClass = uFlags & UMI_OPERATION_CLASS;
	uFlags = uFlags & ~(UMI_OPERATION_CLASS|UMI_OPERATION_INSTANCE);

	if(bClass)
	{
		// Can't do a schema operation if we don't have a schema container
		if ( NULL == m_pUmiClassContainer )
		{
			return WBEM_E_NO_SCHEMA;
		}

		return m_pUmiClassContainer->CreateEnum(pszEnumContext,uFlags,TargetIID,ppvEnum);
	}
	else
	{
		return m_pUmiContainer->CreateEnum(pszEnumContext,uFlags,TargetIID,ppvEnum);
	}
}
        
HRESULT CDsUmiContainer::ExecQuery( 
            /* [in] */ IUmiQuery __RPC_FAR *pQuery,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppResult)
{
	return m_pUmiContainer->ExecQuery(pQuery,uFlags,TargetIID,ppResult);
}

STDMETHODIMP CDsUmiContainer::GetRealContainer( IUnknown** pUnk	)
{
	return m_pUmiContainer->QueryInterface( IID_IUnknown, (void**) pUnk );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\localadd.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    LOCALADD.H

Abstract:

    Declares the COM based transport class.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _LocalAdd_H_
#define _LocalAdd_H_

typedef void ** PPVOID;

//***************************************************************************
//
//  CLASS NAME:
//
//  CLocalAdd
//
//  DESCRIPTION:
//
//  Support local machine address resolution
//
//***************************************************************************

class CLocalAdd : public IWbemAddressResolution
{
    protected:
        long            m_cRef;         //Object reference count
   public:
    
    CLocalAdd();
    ~CLocalAdd(void);

    //Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    

	/* IWbemAddressResolution methods */
       
    virtual HRESULT STDMETHODCALLTYPE Resolve( 
            /* [in] */ LPWSTR pszNamespacePath,
            /* [out] */ LPWSTR pszAddressType,
            /* [out] */ DWORD __RPC_FAR *pdwAddressLength,
            /* [out] */ BYTE __RPC_FAR **pbBinaryAddress);
 
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\localadd.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    COMTRANS.CPP

Abstract:

    Connects via COM

History:

    a-davj  13-Jan-98   Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
//#include "corepol.h"
#include <reg.h>
#include <wbemutil.h>
#include <cominit.h>
#include "wbemprox.h"
#include "localadd.h"
#include <genutils.h>
#include "proxutil.h"

DEFINE_GUID(UUID_LocalAddrType, 
0xa1044803, 0x8f7e, 0x11d1, 0x9e, 0x7c, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0xa8);

//***************************************************************************
//
//  CLocalAdd::CLocalAdd
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CLocalAdd::CLocalAdd()
{
    m_cRef=0;
    InterlockedIncrement(&g_cObj);
    ObjectCreated(LOCALADDR);
}

//***************************************************************************
//
//  CLocalAdd::~CLocalAdd
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CLocalAdd::~CLocalAdd(void)
{
    InterlockedDecrement(&g_cObj);
    ObjectDestroyed(LOCALADDR);
}

//***************************************************************************
// HRESULT CLocalAdd::QueryInterface
// long CLocalAdd::AddRef
// long CLocalAdd::Release
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CLocalAdd::QueryInterface (

    IN REFIID riid,
    OUT PPVOID ppv
)
{
    *ppv=NULL;

    
    if (IID_IUnknown==riid || riid == IID_IWbemAddressResolution)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

STDMETHODIMP_(ULONG) CLocalAdd::AddRef(void)
{
    InterlockedIncrement(&m_cRef);
    return m_cRef;
}

STDMETHODIMP_(ULONG) CLocalAdd::Release(void)
{
    InterlockedDecrement(&m_cRef);
    if (0L!=m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

      
SCODE CLocalAdd::Resolve( 
            /* [in] */ LPWSTR pszNamespacePath,
            /* [out] */ LPWSTR pszAddressType,
            /* [out] */ DWORD __RPC_FAR *pdwAddressLength,
            /* [out] */ BYTE __RPC_FAR **pbBinaryAddress)
{

    GUID gAddr;

    CLSIDFromString(pszAddressType, &gAddr);

    if(pszNamespacePath == NULL || pdwAddressLength== NULL || pbBinaryAddress == NULL
        || gAddr != UUID_LocalAddrType)
        return WBEM_E_INVALID_PARAMETER;

        // Determine if it is local

    WCHAR *t_ServerMachine = ExtractMachineName ( pszNamespacePath) ;
    if ( t_ServerMachine == NULL )
    {
        return WBEM_E_INVALID_PARAMETER ;
    }
    BOOL t_Local = bAreWeLocal ( t_ServerMachine ) ;
    delete t_ServerMachine;

    if(t_Local == FALSE)
        return WBEM_E_FAILED;

    *pbBinaryAddress = (BYTE *)CoTaskMemAlloc(8);
    if(*pbBinaryAddress == NULL)
        return WBEM_E_FAILED;

    wcscpy((LPWSTR)*pbBinaryAddress, L"\\\\.");
    *pdwAddressLength = 8;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\dssvexwrap.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    DSSVEXWRAP.H

Abstract:

    Hides the ADSI interface behind a IWbemServices pointer

History:

	davj  14-Mar-00   Created.

--*/

#ifndef __DSSVEXWRAP_H__
#define __DSSVEXWRAP_H__

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>
#include <sync.h>

//***************************************************************************
//
//  class CWbemSvcExWrapper
//
//  DESCRIPTION:
//
//  This class wraps an IWbemServicesEx interface.
//
//***************************************************************************

class CDSSvcExWrapper : public IWbemServicesEx, public _IUmiSvcExWrapper
{
protected:
	CCritSec		m_cs;
    IUmiContainer *m_pUmiContainer;
	IUnknown*		m_pWbemComBinding;
	long m_cRef;
public:
    CDSSvcExWrapper();
	virtual ~CDSSvcExWrapper(); 

    // Helper functions

	HRESULT ConnectToDS(LPCWSTR User, LPCWSTR Password, IUmiURL * pPath, CLSID &clsid, IWbemContext *pCtx);

	HRESULT GetObjectPreCall(const BSTR ObjectPath, long lFlags, IWbemContext* pContext, 
								IWbemClassObject** ppObject ,CDSCallResult * pCallRes, 
								IWbemObjectSink* pResponseHandler);
	
	HRESULT RefreshObjectPreCall(IWbemClassObject** ppObject, long lFlags,  
								CDSCallResult * pCallRes, IWbemObjectSink* pResponseHandler);

	HRESULT CreateEnumPreCall(const BSTR Class, long lFlags, IWbemContext* pContext, 
								IEnumWbemClassObject** ppEnum , 
								IWbemObjectSink* pSink, bool bClass);

    HRESULT EnumerateCursor(IUmiCursor * pCursor, long lFlags, 
								IEnumWbemClassObject** ppEnum , 
								IWbemObjectSink* pSink, long lSecurityFlags);

	HRESULT PutObjectPreCall(IWbemClassObject * pClass, long lFlags, IWbemContext* pContext, 
								CDSCallResult * pCallRes, 
								IWbemObjectSink* pResponseHandler);
	HRESULT DeleteObjectPreCall(const BSTR ObjectPath, long lFlags, IWbemContext* pContext, 
								CDSCallResult * pCallRes, 
								IWbemObjectSink* pResponseHandler, bool bClass);
	HRESULT RenameObjectPreCall(const BSTR OldPath, const BSTR NewPath, long lFlags, IWbemContext* pContext, 
								CDSCallResult * pCallRes, 
								IWbemObjectSink* pResponseHandler);

	HRESULT OpenPreCall(const BSTR Path,  long lFlags, IWbemContext* pContext,
								IWbemServices** ppNewNamespace, IWbemServicesEx **ppScope,
								CDSCallResult * pCallRes, 
								IWbemObjectSinkEx* pResponseHandler);

    HRESULT ExecQueryPreCall(const BSTR QueryFormat, const BSTR Query, long lFlags, 
                                           IWbemContext* pContext, IEnumWbemClassObject** ppEnum , 
                                           IWbemObjectSink* pSink);

	HRESULT	CheckSecuritySettings( long lFlags, IWbemContext* pContext, long* plSecFlags, BOOL fPut = FALSE );

	void SetContainer(IUmiContainer * pCont){m_pUmiContainer = pCont; pCont->AddRef();};

    //Non-delegating object IUnknown
    
    STDMETHODIMP         QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void)
	{
		InterlockedIncrement(&m_cRef);
		return m_cRef;
	}

    STDMETHODIMP_(ULONG) Release(void)
	{
		long lTemp = InterlockedDecrement(&m_cRef);
		if (0!= lTemp)
			return lTemp;
		delete this;
		return 0;
	}

	// IWbemServicesEx

	STDMETHOD(OpenNamespace)(
			const BSTR Namespace,
			LONG lFlags,
			IWbemContext* pContext,
			IWbemServices** ppNewNamespace,
			IWbemCallResult** ppResult
			);

	STDMETHOD(CancelAsyncCall)(IWbemObjectSink* pSink);
	STDMETHOD(QueryObjectSink)(long lFlags, IWbemObjectSink** ppResponseHandler);

	STDMETHOD(GetObject)(const BSTR ObjectPath, long lFlags, IWbemContext* pContext,
		IWbemClassObject** ppObject, IWbemCallResult** ppResult);
	STDMETHOD(GetObjectAsync)(const BSTR ObjectPath, long lFlags,
		IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

	STDMETHOD(PutClass)(IWbemClassObject* pObject, long lFlags,
		IWbemContext* pContext, IWbemCallResult** ppResult);
	STDMETHOD(PutClassAsync)(IWbemClassObject* pObject, long lFlags,
		IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

	STDMETHOD(DeleteClass)(const BSTR Class, long lFlags, IWbemContext* pContext,
		IWbemCallResult** ppResult);
	STDMETHOD(DeleteClassAsync)(const BSTR Class, long lFlags, IWbemContext* pContext,
		IWbemObjectSink* pResponseHandler);

	STDMETHOD(CreateClassEnum)(const BSTR Superclass, long lFlags,
		IWbemContext* pContext, IEnumWbemClassObject** ppEnum);
	STDMETHOD(CreateClassEnumAsync)(const BSTR Superclass, long lFlags,
		IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

	STDMETHOD(PutInstance)(IWbemClassObject* pInst, long lFlags,
		IWbemContext* pContext, IWbemCallResult** ppResult);
	STDMETHOD(PutInstanceAsync)(IWbemClassObject* pInst, long lFlags,
		IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

	STDMETHOD(DeleteInstance)(const BSTR ObjectPath, long lFlags,
		IWbemContext* pContext, IWbemCallResult** ppResult);
	STDMETHOD(DeleteInstanceAsync)(const BSTR ObjectPath, long lFlags,
		IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

	STDMETHOD(CreateInstanceEnum)(const BSTR Class, long lFlags,
		IWbemContext* pContext, IEnumWbemClassObject** ppEnum);
	STDMETHOD(CreateInstanceEnumAsync)(const BSTR Class, long lFlags,
		IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

	STDMETHOD(ExecQuery)(const BSTR QueryLanguage, const BSTR Query, long lFlags,
		IWbemContext* pContext, IEnumWbemClassObject** ppEnum);
	STDMETHOD(ExecQueryAsync)(const BSTR QueryFormat, const BSTR Query, long lFlags,
		IWbemContext* pContext, IWbemObjectSink* pResponseHandler);
	STDMETHOD(ExecNotificationQuery)(const BSTR QueryLanguage, const BSTR Query,
		long lFlags, IWbemContext* pContext, IEnumWbemClassObject** ppEnum);
	STDMETHOD(ExecNotificationQueryAsync)(const BSTR QueryFormat, const BSTR Query,
		long lFlags, IWbemContext* pContext, IWbemObjectSink* pResponseHandler);

	STDMETHOD(ExecMethod)(const BSTR ObjectPath, const BSTR MethodName, long lFlags,
		IWbemContext *pCtx, IWbemClassObject *pInParams,
		IWbemClassObject **ppOutParams, IWbemCallResult  **ppCallResult);
	STDMETHOD(ExecMethodAsync)(const BSTR ObjectPath, const BSTR MethodName, long lFlags,
		IWbemContext *pCtx, IWbemClassObject *pInParams,
		IWbemObjectSink* pResponseHandler);

    STDMETHOD(Open)(
        /* [in] */ const BSTR strScope,
        /* [in] */ const BSTR strParam,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemServicesEx __RPC_FAR *__RPC_FAR *ppScope,
        /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppResult);

    STDMETHOD(OpenAsync)(
        /* [in] */ const BSTR strScope,
        /* [in] */ const BSTR strParam,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler);

    STDMETHOD(Add)(
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult);

    STDMETHOD(AddAsync)(
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    STDMETHOD(Remove)(
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult);

    STDMETHOD(RemoveAsync)(
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    STDMETHOD(RefreshObject)(
        /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult);

    STDMETHOD(RefreshObjectAsync)(
        /* [out][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *pTarget,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler);

    STDMETHOD(RenameObject)(
        /* [in] */ const BSTR strOldObjectPath,
        /* [in] */ const BSTR strNewObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult);

    STDMETHOD(RenameObjectAsync)(
        /* [in] */ const BSTR strOldObjectPath,
        /* [in] */ const BSTR strNewObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler);

    STDMETHOD(GetObjectSecurity)(
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID TargetIID,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvResult,
        /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult);

    STDMETHOD(GetObjectSecurityAsync)(
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID RequestedIID,
        /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler);

    STDMETHOD(PutObjectSecurity)(
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [iid_is][in] */ void __RPC_FAR *pSecurityObject,
        /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult);

    STDMETHOD(PutObjectSecurityAsync)(
        /* [in] */ const BSTR strObjectPath,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [iid_is][in] */ void __RPC_FAR *pSecurityObject,
        /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler);

        virtual HRESULT STDMETHODCALLTYPE Copy( 
            /* [in] */ const BSTR strSourceObjectPath,
            /* [in] */ const BSTR strDestObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppCallResult);
        
        virtual HRESULT STDMETHODCALLTYPE CopyAsync( 
            /* [in] */ const BSTR strSourceObjectPath,
            /* [in] */ const BSTR strDestObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler);

		virtual HRESULT STDMETHODCALLTYPE DeleteObject(
			/* [in] */ const BSTR strObjectPath,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext* pCtx,
			/* [out, OPTIONAL] */ IWbemCallResult** ppCallResult
			);

		virtual HRESULT STDMETHODCALLTYPE DeleteObjectAsync(
			/* [in] */ const BSTR strObjectPath,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext* pCtx,
			/* [in] */ IWbemObjectSink* pResponseHandler
			);


		virtual HRESULT STDMETHODCALLTYPE PutObject(
			/* [in] */ IWbemClassObject* pObj,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext* pCtx,
			/* [out, OPTIONAL] */ IWbemCallResult** ppCallResult
			);

		virtual HRESULT STDMETHODCALLTYPE PutObjectAsync(
			/* [in] */ IWbemClassObject* pObj,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext* pCtx,
			/* [in] */ IWbemObjectSink* pResponseHandler
			);

		// Initialization function for connections
		STDMETHOD(ConnectToProvider)( LPCWSTR User, LPCWSTR Password, IUnknown * pUnkPath, REFCLSID clsid, IWbemContext *pCtx,
									   IUnknown** pUnk );

		// Hands the connection to the wrapper
		STDMETHOD(SetContainer)( long lFlags, IUnknown* pContainer );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\locator.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    LOCATOR.CPP

Abstract:

    Defines the Locator object

History:

    a-davj  15-Aug-96   Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <wbemint.h>
//#include "corepol.h"
#include <reg.h>
#include <wbemutil.h>
#include <wbemprox.h>
#include <flexarry.h>
#include "sinkwrap.h"
#include "locator.h"
#include "proxutil.h"
#include "comtrans.h"
#include <arrtempl.h>
#include "dscallres.h"
#include "umi.h"
#include "reqobjs.h"
#include "utils.h"
#include "SinkWrap.h"

void FreeAndClear(LPBYTE & pbBinaryAddress, LPWSTR & pAddrType)
{
	if(pbBinaryAddress)
		CoTaskMemFree(pbBinaryAddress);
	pbBinaryAddress = NULL;
	if(pAddrType)
		delete(pAddrType);
	pAddrType = NULL;
}

CModuleList::CModuleList()
{
    DWORD dwSize = 0;
    Registry rTranMods(HKEY_LOCAL_MACHINE, KEY_READ, pModTranPath);
    m_pTranModList = new CMultStr(rTranMods.GetMultiStr(__TEXT("Stack Order"), dwSize));
	m_pAddrTypeList = NULL;		// only used for dependent modules.
}

CModuleList::~CModuleList()
{
	if(m_pTranModList)
		delete m_pTranModList;
	if(m_pAddrTypeList)
		delete m_pAddrTypeList;
}

SCODE CModuleList::GetNextModule(REFIID firstChoiceIID, PPVOID pFirstChoice,
						REFIID SecondChoiceIID, PPVOID pSecondChoice,
						REFIID ThirdChoiceIID, PPVOID pThirdChoice,
						REFIID FourthChoiceIID, PPVOID pFourthChoice,
						DWORD * pdwBinaryAddressLength,
                        LPBYTE * pbBinaryAddress,
						LPWSTR * ppwszAddrType, LPWSTR NetworkResource)
{
    if(m_pTranModList == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    TCHAR * pAddrType = NULL;
	*pbBinaryAddress = NULL;
	*ppwszAddrType = NULL;
	*pFirstChoice = NULL;
	*pSecondChoice = NULL;
	bool bDependent;
	SCODE sc;
	bool bGettingNewModule = true;
    while (1)
    {

		pAddrType = NULL;

		// Usually, we get the next module in the list.  But, if we have a
		// dependent module which has a list of address resolution modules,
		// that takes precedance.  Normally, the list is empty and we end up
		// advancing through the module list.

		if(m_pAddrTypeList)
		{
			pAddrType = m_pAddrTypeList->GetNext();
			if(pAddrType == NULL)
			{
				delete m_pAddrTypeList;			// end of list, not needed anymore
				m_pAddrTypeList = NULL;
			}
		}
		if(pAddrType == NULL)
		{
			bGettingNewModule = true;
			m_pszTranModCLSID = m_pTranModList->GetNext();
		}
		else
			bGettingNewModule = false;

		if(m_pszTranModCLSID == NULL)
			return WBEM_E_TRANSPORT_FAILURE;

        // Open the registry key for the transport module

         TCHAR cTemp[MAX_PATH+1];
         lstrcpy(cTemp, pModTranPath);
         lstrcat(cTemp, __TEXT("\\"));
         lstrcat(cTemp, m_pszTranModCLSID);
         Registry rCurrentMod(HKEY_LOCAL_MACHINE, KEY_READ,cTemp);
        
         DWORD dwIndependent;
         long lRes = rCurrentMod.GetDWORD(__TEXT("Independent"), &dwIndependent);
         if(lRes != ERROR_SUCCESS)
             continue;
		 if(dwIndependent != 1)
			 bDependent = true;
		 else
			 bDependent = false;

		 // If we are dependent and the module was just loaded, then create the address list

         if(bDependent && bGettingNewModule)
		 {
			 DWORD dwSize;
			 TCHAR * pAddrType = rCurrentMod.GetMultiStr(__TEXT("Supported Address Types"), dwSize);
			 if(pAddrType)
				m_pAddrTypeList = new CMultStr(pAddrType);
			 else
				 continue;
			 if(m_pAddrTypeList == NULL)
				 return WBEM_E_OUT_OF_MEMORY;
			 pAddrType = m_pAddrTypeList->GetNext();
			 if(pAddrType == NULL)
				 continue;
		 }

		 // If we are dependent, get the address info

		 if(bDependent)
		 {
			sc = GetResolvedAddress(pAddrType, NetworkResource, pdwBinaryAddressLength,
                        pbBinaryAddress);
			if(FAILED(sc))
				continue;
			int iLen = lstrlen(pAddrType)+1;
			*ppwszAddrType = new WCHAR[iLen];
			if(*ppwszAddrType == NULL)
			{
				CoTaskMemFree(pbBinaryAddress);
				pbBinaryAddress = NULL;
				return WBEM_E_OUT_OF_MEMORY;
			}
#ifndef UNICODE			
			mbstowcs(*ppwszAddrType, pAddrType, iLen);
#else
            lstrcpy(*ppwszAddrType,pAddrType);
#endif
		 }

		// Get the CLSID of the module which is the same as the subkey name

		CLSID clsid;
		sc = CreateGUIDFromLPTSTR(m_pszTranModCLSID, &clsid);
		if(sc != S_OK)
		{
			FreeAndClear(*pbBinaryAddress, *ppwszAddrType);
			return sc;
		}

		// Load up the module
		
		IUnknown * pUnk = NULL;
		sc = CoCreateInstance (
				clsid, 
				0 , 
				CLSCTX_INPROC_SERVER ,
				IID_IUnknown , 
				(LPVOID *) &pUnk);
		if(FAILED(sc))
		{
			FreeAndClear(*pbBinaryAddress, *ppwszAddrType);
			continue;
		}
		CReleaseMe rm(pUnk);

		// return either the first or second choice;

		sc = pUnk->QueryInterface(firstChoiceIID, pFirstChoice);
		if(SUCCEEDED(sc))
			return sc;
		sc = pUnk->QueryInterface(SecondChoiceIID, pSecondChoice);
		if(SUCCEEDED(sc))
			return sc;

		// there may or may not be a 3rd and 4th choice

		if(pThirdChoice)
		{
			sc = pUnk->QueryInterface(ThirdChoiceIID, pThirdChoice);
			if(SUCCEEDED(sc))
				return sc;
		}
		if(pFourthChoice)
		{
			sc = pUnk->QueryInterface(FourthChoiceIID, pFourthChoice);
			if(SUCCEEDED(sc))
				return sc;
		}

		FreeAndClear(*pbBinaryAddress, *ppwszAddrType);
    }

}

//***************************************************************************
//
//  SCODE CModuleList::LoadAddTryTheAddrModule
//
//  DESCRIPTION:
//
//  Loads up an address resolution modules and lets it try to resolve the 
//  namespace address.
//
//  PARAMETERS:
//
//  pszAddModClsid          CLSID of the module
//  Namespace
//  pAddrType               GUID indicating the type desired, ex: IP address
//  pdwBinaryAddressLength  If it works, the module sets this to size of data
//  pbBinaryAddress         If it works, set points to the address data.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE CModuleList::LoadAddTryTheAddrModule(IN LPTSTR pszAddModClsid,
                                   IN LPWSTR Namespace,
                                   IN LPTSTR pAddrType,
                                   OUT DWORD * pdwBinaryAddressLength,
                                   OUT LPBYTE *ppbBinaryAddress)
{

    if(pAddrType == NULL || Namespace == NULL || pszAddModClsid == NULL ||
        pdwBinaryAddressLength == NULL || ppbBinaryAddress == NULL)
            return WBEM_E_INVALID_PARAMETER;

    IWbemAddressResolution * pAddRes = NULL;

    // Get the CLSID of the module which is the same as the subkey name

    CLSID clsid;
    SCODE sc = CreateGUIDFromLPTSTR(pszAddModClsid, &clsid);
    if(sc != S_OK)
        return sc;

    // Load up the module

    sc = CoCreateInstance (
            clsid, 
            0 , 
            CLSCTX_INPROC_SERVER ,
            IID_IWbemAddressResolution , 
            (LPVOID *) &pAddRes);
    if(sc != S_OK)
    {
        ERRORTRACE((LOG_WBEMPROX, "Error loading addr resolution module %s, "
                   "return code is 0x%x\n", pszAddModClsid, sc));
        return sc;
    }

#ifdef UNICODE
    wchar_t *wcAddrType = pAddrType;
#else
    wchar_t *wcAddrType = new wchar_t[(strlen(pAddrType) + 1)];
    mbstowcs(wcAddrType, pAddrType, (strlen(pAddrType) + 1) * sizeof(wchar_t));
    CDeleteMe<wchar_t> delMe(wcAddrType);
#endif
            
    sc = pAddRes->Resolve(Namespace, wcAddrType,
                       pdwBinaryAddressLength,ppbBinaryAddress);
    pAddRes->Release();
    return sc;
}

//***************************************************************************
//
//  SCODE CModuleList::GetResolvedAddress
//
//  DESCRIPTION:
//
//  Used to resolve an address.  This goes through the list of address
//  resolution modules and finds the first one that supports a address
//  type and then gets that module to resolve it.
//
//  PARAMETERS:
//
//  pAddrType               GUID indicating the type desired, ex: IP address
//  Namespace
//  pdwBinaryAddressLength  If it works, the module sets this to size of data
//  pbBinaryAddress         If it works, set points to the address data.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE CModuleList::GetResolvedAddress(
                                   IN LPTSTR pAddrType,
                                   IN LPWSTR pNamespace,
                                   OUT DWORD * pdwBinaryAddressLength,
                                   OUT LPBYTE *pbBinaryAddress)
{

    DWORD dwSize;

    // Get the address resolution module stack

    Registry rAddrMods(HKEY_LOCAL_MACHINE, KEY_READ, pAddResPath);
    CMultStr StackList(rAddrMods.GetMultiStr(__TEXT("Stack Order"), dwSize));
    TCHAR * pStackEntry;
    while (pStackEntry = StackList.GetNext())
    {
        // For a module in the stack, get its registry subkey
        
        TCHAR pAddModRegPath[MAX_PATH];
        wsprintf(pAddModRegPath, __TEXT("%s\\%s"), pAddResPath, pStackEntry);
        Registry rSingleAddMod(HKEY_LOCAL_MACHINE, KEY_READ, pAddModRegPath);

        // Check if the module supports this address type

        CMultStr AddList(rSingleAddMod.GetMultiStr(__TEXT("Supported Address Types"), dwSize));
        TCHAR *pAddEntry; 
        while (pAddEntry = AddList.GetNext())
        {
            if(!lstrcmpi(pAddEntry, pAddrType))
            {
                SCODE sc = LoadAddTryTheAddrModule(pStackEntry, pNamespace, 
                    pAddrType, pdwBinaryAddressLength, pbBinaryAddress);
                if(sc == S_OK)
                    return sc;
            }
        }
    }
    return WBEM_E_FAILED;           // Looks like a stetup problem!
}


//***************************************************************************
//
//  CLocator::CLocator
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CLocator::CLocator()
{
    m_cRef=0;
    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CLocator::~CLocator
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CLocator::~CLocator(void)
{
    InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CLocator::QueryInterface
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CLocator::QueryInterface (

    IN REFIID riid,
    OUT PPVOID ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || riid == IID_IWbemLocator)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

HRESULT GetCloneOrCopy(const BSTR Authority, IWbemContext *pCtx, IWbemContext **pCopy)
{
	SCODE sc;
	if(pCtx == NULL)
	{
		// create a context 
		
		sc = CoCreateInstance(CLSID_WbemContext, NULL, CLSCTX_INPROC_SERVER, 
				IID_IWbemContext, (void**)pCopy);

	}
	else
	{
		// clone the context

		sc = pCtx->Clone(pCopy);
	}

	if(SUCCEEDED(sc))
	{

		// Set the authority value

		VARIANT var;
		var.vt = VT_BSTR;
		var.bstrVal = Authority;	// dont clear since owned by caller!
		sc = (*pCopy)->SetValue(L"__authority", 0, &var);
		if(FAILED(sc))
			(*pCopy)->Release();
	}
	return sc;
}

//***************************************************************************
//
//  SCODE CLocator::ConnectServer
//
//  DESCRIPTION:
//
//  Connects up to either local or remote WBEM Server.  Returns
//  standard SCODE and more importantly sets the address of an initial
//  stub pointer.
//
//  PARAMETERS:
//
//  NetworkResource     Namespace path
//  User                User name
//  Password            password
//  LocaleId            language locale
//  lFlags              flags
//  Authority           domain
//  ppProv              set to provdider proxy
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  else error listed in WBEMSVC.H
//
//***************************************************************************

SCODE CLocator::ConnectServer (

    IN const BSTR NetworkResource,
    IN const BSTR User,
    IN const BSTR Password,
    IN const BSTR LocaleId,
    IN long lFlags,
    IN const BSTR Authority,
    IWbemContext __RPC_FAR *pCtx,
    OUT IWbemServices FAR* FAR* ppProv
)
{

    long lRes;
    SCODE sc = WBEM_E_TRANSPORT_FAILURE;
    
    // Verify the arguments

    if(NetworkResource == NULL || ppProv == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // Loop through the modules.

	CModuleList ModList;
	IWbemLocator * pLoc = NULL;
	IWbemClientTransport * pCliTran = NULL;
	IWbemConnection * pConnection = NULL;
	IWbemClientConnectionTransport * pCliConnTran = NULL;
	DWORD dwLen;
	BYTE * pBuffer = NULL;
	WCHAR * pwszAddrType = NULL;
    while (S_OK == ModList.GetNextModule(IID_IWbemLocator, (void **)&pLoc, 
		                                 IID_IWbemClientTransport, (void **)&pCliTran,
										 IID_IWbemConnection, (void **)&pConnection, 
		                                 IID_IWbemClientConnectionTransport, (void **)&pCliConnTran,
										 &dwLen, &pBuffer, &pwszAddrType, NetworkResource))
    {

		if(pLoc)
		{
			sc = pLoc->ConnectServer(NetworkResource, User, Password, LocaleId,
                    lFlags, Authority, pCtx, ppProv);
			pLoc->Release();
			pLoc = NULL;
		}
		else if(pCliTran)
		{
			sc = pCliTran->ConnectServer(pwszAddrType, dwLen, pBuffer, NetworkResource, User, 
					Password, LocaleId, lFlags, Authority, pCtx, ppProv);
			pCliTran->Release();
			pCliTran = NULL;
		}
		else if(pConnection)
		{
			if(Authority)
			{
				IWbemContext * pCopy = NULL;
				sc = GetCloneOrCopy(Authority, pCtx, &pCopy);		
				if(SUCCEEDED(sc))
				{
					CReleaseMe rm(pCopy);
					sc = pConnection->Open(NetworkResource, User, Password, LocaleId,
							lFlags, pCopy, IID_IWbemServices, (void **)ppProv, NULL);

				}
			}
			else
				sc = pConnection->Open(NetworkResource, User, Password, LocaleId,
                    lFlags, pCtx, IID_IWbemServices, (void **)ppProv, NULL);
			pConnection->Release();
			pConnection = NULL;

		}
		else if(pCliConnTran)
		{
			//todo, take the authority argument and bundle it into the context

			if(Authority)
			{
				IWbemContext * pCopy = NULL;
				sc = GetCloneOrCopy(Authority, pCtx, &pCopy);		
				if(SUCCEEDED(sc))
				{
					CReleaseMe rm(pCopy);
					sc = pCliConnTran->Open(pwszAddrType, dwLen, pBuffer, NetworkResource, User, 
						Password, LocaleId, lFlags, pCopy, IID_IWbemServices, (void **)ppProv, NULL);

				}

			}
			else
				sc = pCliConnTran->Open(pwszAddrType, dwLen, pBuffer, NetworkResource, User, 
					Password, LocaleId, lFlags, pCtx, IID_IWbemServices, (void **)ppProv, NULL);
			pCliConnTran->Release();
			pCliConnTran = NULL;
		}

		FreeAndClear(pBuffer, pwszAddrType);

        if(sc == WBEM_E_ACCESS_DENIED)
        {
            ERRORTRACE((LOG_WBEMPROX,"Access denied was returned, giving up!\n"));
            return sc;
        }
        else if(sc == WBEM_E_FATAL_TRANSPORT_ERROR)
        {
            ERRORTRACE((LOG_WBEMPROX,"Transport indicated that connection is futile, giving up!\n"));
            return sc;
        }
        if(sc == S_OK)
            break;
    }

    return sc;
}

//***************************************************************************
//
//  CConnection::CConnection
//
//  DESCRIPTION:
//
//  Constructor.
//
//***************************************************************************

CConnection::CConnection()
{
    m_cRef=0;
    InterlockedIncrement(&g_cObj);
}

//***************************************************************************
//
//  CConnection::~CConnection
//
//  DESCRIPTION:
//
//  Destructor.
//  
//***************************************************************************

CConnection::~CConnection(void)
{
    InterlockedDecrement(&g_cObj);
}

//***************************************************************************
// HRESULT CConnection::QueryInterface
//
// DESCRIPTION:
//
// Standard Com IUNKNOWN functions.
//
//***************************************************************************

STDMETHODIMP CConnection::QueryInterface (

    IN REFIID riid,
    OUT PPVOID ppv
)
{
    *ppv=NULL;

    if (IID_IUnknown==riid || riid == IID_IWbemConnection)
        *ppv=this;

    if (NULL!=*ppv)
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}

SCODE CConnection::Open( 
        /* [in] */ const BSTR strObject,
        /* [in] */ const BSTR User,
        /* [in] */ const BSTR Password,
        /* [in] */ const BSTR LocaleId,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pInterface,
        /* [out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *ppResult)
{
	if(strObject == NULL)
		return WBEM_E_INVALID_PARAMETER;
    if(pInterface == NULL && ppResult == NULL)
		return WBEM_E_INVALID_PARAMETER;

	return CConnOpenPreCall(strObject, User, Password, LocaleId, lFlags, pCtx, riid, 
                     pInterface, ppResult, NULL);
}
    

SCODE CConnection::OpenAsync( 
        /* [in] */ const BSTR Object,
        /* [in] */ const BSTR User,
        /* [in] */ const BSTR Password,
        /* [in] */ const BSTR Locale,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler)
{
	if(Object == NULL || pResponseHandler == NULL)
		return WBEM_E_INVALID_PARAMETER;

	return CConnOpenPreCall(Object, User, Password, Locale, lFlags, pCtx, riid, 
                    NULL, NULL, pResponseHandler);
}

SCODE CConnection::CConnOpenPreCall(
        const BSTR Object,
        const BSTR User,
        const BSTR Password,
        const BSTR Locale,
        long lFlags,
        IWbemContext __RPC_FAR *pCtx,
        REFIID riid,
		void **pInterface,
        IWbemCallResultEx ** ppCallRes, 
		IWbemObjectSinkEx * pSinkWrap)
{
    BOOL bSemiSync = (ppCallRes && pInterface == NULL);
	BOOL bAsync = (pSinkWrap || bSemiSync);

	// create the request

	if(bAsync)
	{
        HANDLE hInitDone = NULL;
        if(bSemiSync)
        {
            hInitDone = CreateEvent(NULL, FALSE, FALSE, NULL);
            if(hInitDone == NULL)
                return WBEM_E_OUT_OF_MEMORY;
        }

        LPSTREAM pCallResStream = NULL;
		COpen * pNew = new COpen(this, Object, User, Password, Locale, lFlags, pCtx, riid, 
														pInterface,
                                                        (ppCallRes) ? &pCallResStream : NULL, 
                                                        pSinkWrap, hInitDone);
		if(pNew == NULL)
			return WBEM_E_OUT_OF_MEMORY;

		SCODE sc = pNew->GetStatus();
		if(FAILED(sc))
		{
			delete pNew;
			return sc;
		}

	    // create the thread

        DWORD dwIDLikeIcare;
        HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)OpenThreadRoutine, 
                                     (LPVOID)pNew, 0, &dwIDLikeIcare);
	    if(hThread == NULL)
	    {
		    delete pNew;
		    return WBEM_E_FAILED;
	    }
	    else
	    {
		    CloseHandle(hThread);

            // if it is semisync, then wait for the event an unmarshall the pointer

            if(bSemiSync)
            {
                WaitForSingleObject(hInitDone, INFINITE);
                CloseHandle(hInitDone);
                sc = CoGetInterfaceAndReleaseStream(
                    pCallResStream,                //Pointer to the stream from which the object is to be marshaled
                    IID_IWbemCallResultEx,    //Reference to the identifier of the interface
                    (void **)ppCallRes);       //Address of output variable that receives the interface
                return sc;
            }
            else
		        return S_OK;
	    }
	}
    else
        return ActualOpen(Object, User, Password, Locale, lFlags, pCtx,
							riid, pInterface, NULL);

}

DWORD WINAPI OpenThreadRoutine(LPVOID lpParameter)
{
	ComThreadInit ci(TRUE);
	IUnknown * pUnk = NULL;
    COpen * pReq = (COpen *)lpParameter;
	SCODE sc = S_OK;
    pReq->UnMarshal();
	if(pReq->m_pSink)
		sc = g_SinkCollection.AddToList(pReq->m_pSink);
	if(SUCCEEDED(sc))
	{
		sc = pReq->m_pConn->ActualOpen(
			pReq->m_strObject,
			pReq->m_strUser,
			pReq->m_strPassword,
			pReq->m_strLocale,
			pReq->m_lFlags,
			pReq->m_pCtx,
			pReq->m_riid,
			(void **)&pUnk,
			pReq->m_pSink);
		if(pReq->m_pSink)
			g_SinkCollection.RemoveFromList(pReq->m_pSink);
	}

	if(pReq->m_pSink)
    {
		if(SUCCEEDED(sc))
            pReq->m_pSink->Set(0, pReq->m_riid, pUnk);
	    pReq->m_pSink->SetStatus(0, sc, 0, 0);
    }
    else
    {
		if(SUCCEEDED(sc))
        {    
            IWbemClassObject * pObj = NULL;
            sc = pUnk->QueryInterface(IID_IWbemClassObject, (void **)&pObj);
            if(SUCCEEDED(sc))
            {
                pReq->m_pCallRes->SetResultObject(pObj);
                pObj->Release();
            }
            else
            {
                IWbemServices * pServ = NULL;
                sc = pUnk->QueryInterface(IID_IWbemServicesEx, (void **)&pServ);
                if(SUCCEEDED(sc))
                {
                    pReq->m_pCallRes->SetResultServices(pServ);
                    pServ->Release();
                }
            }
        }
        pReq->m_pCallRes->SetHRESULT(sc);
    }
	delete pReq;
    return 0;
}

SCODE CConnection::ActualOpen( 
        /* [in] */ const BSTR strObject,
        /* [in] */ const BSTR User,
        /* [in] */ const BSTR Password,
        /* [in] */ const BSTR LocaleId,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pInterface,
		CSinkWrap * pSinkWrap)
{
    long lRes;
    SCODE sc = WBEM_E_TRANSPORT_FAILURE;
    
    // Verify the arguments

    if(strObject == NULL || pInterface == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // Loop through the modules.

	CModuleList ModList;
	IWbemConnection * pLoc = NULL;
	IWbemClientConnectionTransport * pCliTran = NULL;
	DWORD dwLen;
	BYTE * pBuffer = NULL;
	WCHAR * pwszAddrType = NULL;
    while (S_OK == ModList.GetNextModule(IID_IWbemConnection, (void **)&pLoc, 
		                                 IID_IWbemClientConnectionTransport, (void **)&pCliTran, 
										 IID_IUnknown, NULL, IID_IUnknown, NULL,
										 &dwLen, &pBuffer, &pwszAddrType, strObject))
    {

		if(pLoc)
		{
			if(pSinkWrap)
				sc = pSinkWrap->SetIWbemConnection(pLoc);
			else
				sc =S_OK;
			if(SUCCEEDED(sc))
				sc = pLoc->Open(strObject, User, Password, LocaleId,
                    lFlags, pCtx, riid, pInterface, NULL);
			if(pSinkWrap)
				pSinkWrap->ReleaseTransportPointers();
			pLoc->Release();
			pLoc = NULL;
		}
		else if(pCliTran)
		{
			if(pSinkWrap)
				sc = pSinkWrap->SetIWbemClientConnectionTransport(pCliTran);
			else
				sc =S_OK;
			if(SUCCEEDED(sc))
				sc = pCliTran->Open(pwszAddrType, dwLen, pBuffer, strObject, User, 
					Password, LocaleId, lFlags, pCtx, riid, pInterface, NULL);
			if(pSinkWrap)
				pSinkWrap->ReleaseTransportPointers();
			pCliTran->Release();
			pCliTran = NULL;
		}

		FreeAndClear(pBuffer, pwszAddrType);

        if(sc == WBEM_E_ACCESS_DENIED)
        {
            ERRORTRACE((LOG_WBEMPROX,"Access denied was returned, giving up!\n"));
            return sc;
        }
        else if(sc == WBEM_E_FATAL_TRANSPORT_ERROR)
        {
            ERRORTRACE((LOG_WBEMPROX,"Transport indicated that connection is futile, giving up!\n"));
            return sc;
        }
        if(sc == S_OK)
            break;
    }

    return sc;
}

SCODE CConnection::Cancel( 
        /* [in] */ long lFlags,
        /* [in] */ IWbemObjectSinkEx __RPC_FAR *pHandler)
{
	return g_SinkCollection.CancelCallsForSink(pHandler);
}

//***************************************************************************
//
//  CLASS NAME:
//
//  COpen
//
//  DESCRIPTION:
//
//  Special request used for IWmiConnect::Open
//
//***************************************************************************


COpen::COpen(CConnection * pConn,
        const BSTR strObject,
        const BSTR strUser,
        const BSTR strPassword,
        const BSTR strLocale,
        long lFlags,
        IWbemContext *pContext,
        REFIID riid,
		void ** pInterface,
		LPSTREAM * ppCallResStream,
        IWbemObjectSinkEx  *pSink,
        HANDLE hInitialized) : m_riid(riid), m_hInitDoneEvent(hInitialized)
{
    HRESULT hRes;
	m_Status = S_OK;
	m_pConn = pConn;
	m_pInterface = pInterface;
	m_pConn->AddRef();
	m_strObject = SysAllocString(strObject);
	if(m_strObject == NULL)
		m_Status = WBEM_E_OUT_OF_MEMORY;
    
	m_strUser = NULL;
	if(strUser)
	{
		m_strUser = SysAllocString(strUser);
		if(m_strUser == NULL)
			m_Status = WBEM_E_OUT_OF_MEMORY;
	}

	m_strPassword = NULL;
	if(strPassword)
	{
		m_strPassword = SysAllocString(strPassword);
		if(m_strPassword == NULL)
			m_Status = WBEM_E_OUT_OF_MEMORY;
	}

	m_strLocale = NULL;
	if(strLocale)
	{
		m_strLocale = SysAllocString(strLocale);
		if(m_strLocale == NULL)
			m_Status = WBEM_E_OUT_OF_MEMORY;
	}

    m_lFlags = lFlags;
    
    m_pContextStream = NULL;
    m_pCtx = NULL;
    m_pSink = NULL;
    m_pSinkStream = NULL;
    m_pCallRes = NULL;
    m_ppCallResStream = ppCallResStream;
    if(pSink)
    {
        pSink->AddRef();
        hRes = CoMarshalInterThreadInterfaceInStream(
            IID_IWbemObjectSinkEx,     //Reference to the identifier of the interface
            pSink,  //Pointer to the interface to be marshaled
            &m_pSinkStream); //Address of output variable that receives the 
                       // IStream interface pointer for the marshaled 
                       // interface
    }
    if(pContext)
    {
        pContext->AddRef();
        hRes = CoMarshalInterThreadInterfaceInStream(
            IID_IWbemContext,     //Reference to the identifier of the interface
            pContext,  //Pointer to the interface to be marshaled
            &m_pContextStream); //Address of output variable that receives the 
                       // IStream interface pointer for the marshaled 
                       // interface
    }


}

HRESULT COpen::UnMarshal()
{
    HRESULT hRes = S_OK;
    if(m_pSinkStream)
    {
        IWbemObjectSinkEx * pSink = NULL;
        hRes = CoGetInterfaceAndReleaseStream(
            m_pSinkStream,                //Pointer to the stream from which the object is to be marshaled
            IID_IWbemObjectSinkEx,    //Reference to the identifier of the interface
            (void **)&pSink);       //Address of output variable that receives the interface
        if(FAILED(hRes))
             return hRes;
	    m_pSink = new CSinkWrap(pSink);
	    if(m_pSink == NULL)
		    return WBEM_E_OUT_OF_MEMORY;
    }
    if(m_pContextStream)
    {
        IWbemContext * pContext = NULL;
         hRes = CoGetInterfaceAndReleaseStream(
            m_pContextStream,                //Pointer to the stream from which the object is to be marshaled
            IID_IWbemContext,    //Reference to the identifier of the interface
            (void **)&m_pCtx);       //Address of output variable that receives the interface
    }

    if(m_ppCallResStream)
    {

        // This is the opposite case, we create the pointer here and marshall it back to the
        // calling thread

        m_pCallRes = new CDSCallResult();
	    if(m_pCallRes == NULL)
		    return WBEM_E_OUT_OF_MEMORY;    // addref?

        m_pCallRes->AddRef();
        hRes = CoMarshalInterThreadInterfaceInStream(
            IID_IWbemCallResultEx,     //Reference to the identifier of the interface
            m_pCallRes,  //Pointer to the interface to be marshaled
            m_ppCallResStream); //Address of output variable that receives the 

        if(m_hInitDoneEvent)
            SetEvent(m_hInitDoneEvent);
    }
    return hRes;
}

COpen::~COpen()
{
	m_pConn->Release();
	if(m_strObject)
		SysFreeString(m_strObject);
	if(m_strUser)
		SysFreeString(m_strUser);
	if(m_strPassword)
		SysFreeString(m_strPassword);
	if(m_strLocale)
		SysFreeString(m_strLocale);

	if(m_pCtx)
		m_pCtx->Release();
	if(m_pCallRes)
		m_pCallRes->Release();
	if(m_pSink)
		m_pSink->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\proxutil.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    PROXUTIL.H

Abstract:

    Declares the CLocator class.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _proxutil_H_
#define _proxutil_H_

void CreateLPTSTRFromGUID(IN GUID guid, IN OUT TCHAR * pNarrow, IN DWORD dwSize);
SCODE CreateGUIDFromLPTSTR(IN LPTSTR pszGuid, CLSID * pClsid);
void AddGUIDToStackOrder(LPTSTR szGUID, Registry & reg);
void AddDisplayName(Registry & reg, GUID guid, LPTSTR pDescription);



class CMultStr
{
private:
    TCHAR * m_pData;
    TCHAR * m_pNext;
public:
    CMultStr(TCHAR * pInit);
    ~CMultStr();
    TCHAR * GetNext();
};

class ComThreadInit
{
protected:
	DWORD m_InitCount;
public:
	ComThreadInit(bool bInitThread);
	~ComThreadInit();
};

extern TCHAR * pAddResPath;
extern TCHAR * pModTranPath;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\maindll.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MAINDLL.CPP

Abstract:

    Contains DLL entry points.  Also has code that controls
    when the DLL can be unloaded by tracking the number of
    objects and locks.

History:

    a-davj  15-Aug-96   Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <wbemutil.h>
#include <genutils.h>
#include <cominit.h>
#include <reg.h>
#include "wbemprox.h"
#include "proxutil.h"
#include <initguid.h>
#include <wbemint.h>

TCHAR * pDCOMName = __TEXT("WBEM DCOM Transport V1");
TCHAR * pLocalAddr = __TEXT("WBEM Local Address Resolution Module");

// {A2F7D6C1-8DCD-11d1-9E7C-00C04FC324A8}  display name for dcom transport
DEFINE_GUID(UUID_DCOMName, 
0xa2f7d6c1, 0x8dcd, 0x11d1, 0x9e, 0x7c, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0xa8);

// {A1044802-8F7E-11d1-9E7C-00C04FC324A8}  display name for local address resolution
DEFINE_GUID(UUID_LocalAddResName, 
0xa1044802, 0x8f7e, 0x11d1, 0x9e, 0x7c, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0xa8);

// {A1044803-8F7E-11d1-9E7C-00C04FC324A8}  GUID to identify local 
DEFINE_GUID(UUID_LocalAddrType, 
0xa1044803, 0x8f7e, 0x11d1, 0x9e, 0x7c, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0xa8);

// {A1044804-8F7E-11d1-9E7C-00C04FC324A8}  display name of local addr type
DEFINE_GUID(UUID_LocalAddrTypeName,      
0xa1044804, 0x8f7e, 0x11d1, 0x9e, 0x7c, 0x0, 0xc0, 0x4f, 0xc3, 0x24, 0xa8);

DEFINE_GUID(CLSID_WinNTConnectionObject,0x7992c6eb,0xd142,0x4332,0x83,0x1e,0x31,0x54,0xc5,0x0a,0x83,0x16);
DEFINE_GUID(CLSID_LDAPConnectionObject,0x7da2a9c4,0x0c46,0x43bd,0xb0,0x4e,0xd9,0x2b,0x1b,0xe2,0x7c,0x45);

//Count number of objects and number of locks.

long       g_cObj=0;
ULONG       g_cLock=0;
HMODULE ghModule;

// used to keep track of allocated objects.

static LONG ObjectTypeTable[MAX_CLIENT_OBJECT_TYPES+1];

void ShowObjectCounts();

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  Good place for initialization.
//
//  PARAMETERS:
//
//  hInstance           instance handle
//  ulReason            why we are being called
//  pvReserved          reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain(
                        IN HINSTANCE hInstance,
                        IN ULONG ulReason,
                        LPVOID pvReserved)
{
    if(ghModule == NULL)
    {
        ghModule = hInstance;

		DisableThreadLibraryCalls ( hInstance ) ;
    }
    if (DLL_PROCESS_DETACH==ulReason)
    {
        ShowObjectCounts();
        return TRUE;
    }
    else
    {
        if (DLL_PROCESS_ATTACH!=ulReason)
        {
        }
    }

    return TRUE;
}

//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//  
//***************************************************************************

STDAPI DllGetClassObject(
                        IN REFCLSID rclsid,
                        IN REFIID riid,
                        OUT PPVOID ppv)
{
    HRESULT hr;
    CLocatorFactory *pObj = NULL;

    if (CLSID_WbemLocator == rclsid)
        pObj=new CLocatorFactory(LOCATOR);
    else if(CLSID_WbemDCOMTransport == rclsid)
        pObj=new CLocatorFactory(DCOMTRAN);
    else if(CLSID_WbemLocalAddrRes == rclsid)
        pObj=new CLocatorFactory(LOCALADDR);
    else if(CLSID_WbemConnection == rclsid)
        pObj=new CLocatorFactory(CONNECTION);
//    else if(CLSID__DSSvcExWrap == rclsid)
//        pObj=new CLocatorFactory(DSSVEX);
    else if(CLSID_WbemAdministrativeLocator == rclsid)
        pObj=new CLocatorFactory(ADMINLOC);
    else if(CLSID_WbemAuthenticatedLocator == rclsid)
        pObj=new CLocatorFactory(AUTHLOC);
    else if(CLSID_WbemUnauthenticatedLocator == rclsid)
        pObj=new CLocatorFactory(UNAUTHLOC);

    if(pObj == NULL)
        return E_FAIL;

    if (NULL==pObj)
        return ResultFromScode(E_OUTOFMEMORY);

    hr=pObj->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//  STDAPI DllCanUnloadNow
//
//  DESCRIPTION:
//
//  Answers if the DLL can be freed, that is, if there are no
//  references to anything this DLL provides.
//
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//  
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the
    // class factory.

    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return ResultFromScode(sc);
}

//***************************************************************************
//
//  ObjectCreated
//
//  DESCRIPTION:
//
//  Keeps track of object creation.
//
//  PARAMETERS:
//
//  dwType              type of object created.
//
//***************************************************************************

void ObjectCreated(OBJTYPE dwType)
{
    if(dwType < MAX_CLIENT_OBJECT_TYPES)
        InterlockedIncrement((LONG *) &g_cObj);
    if(dwType < MAX_CLIENT_OBJECT_TYPES)
        InterlockedIncrement(&ObjectTypeTable[dwType]);
}

//***************************************************************************
//
//  void ObjectDestroyed
//
//  DESCRIPTION:
//
//  Keeps track of object deletion.
//
//  PARAMETERS:
//
//  dwType              type of object created.
//
//***************************************************************************

void ObjectDestroyed(OBJTYPE dwType)
{
    if(dwType < MAX_CLIENT_OBJECT_TYPES)
        InterlockedDecrement((LONG *) &g_cObj);
    if(dwType < MAX_CLIENT_OBJECT_TYPES)
        InterlockedDecrement(&ObjectTypeTable[dwType]);
}


//***************************************************************************
//
//  void ShowObjectCounts
//
//  DESCRIPTION:
//
//  Dumps out the object count.  Used during shutdown to detect leaks.
//
//***************************************************************************

void ShowObjectCounts()
{
       
    DEBUGTRACE((LOG_WBEMPROX,"---COM Object Ref Count Info for marshalling client---\n"));
    DEBUGTRACE((LOG_WBEMPROX,"Active Objects = %d\n", g_cObj));
    DEBUGTRACE((LOG_WBEMPROX,"Server locks   = %d\n", g_cLock));

    DEBUGTRACE((LOG_WBEMPROX,"Object counts by type:\n"));
    for(DWORD dwCnt = 0; dwCnt < MAX_CLIENT_OBJECT_TYPES; dwCnt++)
    {
        DEBUGTRACE((LOG_WBEMPROX,"Object type %d has count of %d:\n", dwCnt,ObjectTypeTable[dwCnt] ));

    }


    DEBUGTRACE((LOG_WBEMPROX,"---End of ref count dump---\n"));
}


//***************************************************************************
//
// CreateNetTranModEntries
//
// Purpose: Creates the registry entries for the Network Transport Modules
//
//***************************************************************************

void CreateNetTranModEntries()
{


    // If there is no dcom then we are done.

    if(!IsDcomEnabled())
        return;

    // create a narrow string version of the DCOM transport CLSID

    TCHAR szDcomGUID[GUID_SIZE];
    szDcomGUID[0] = 0;
    CreateLPTSTRFromGUID(CLSID_WbemDCOMTransport, szDcomGUID, GUID_SIZE);


    // The StackOrder value is a multistring list of the CLSIDs of the network
    // transports.  Create it with a single entry if it doesnt already exist, or
    // just put DCOM at the from of the list if it doesnt exist.

    Registry reg(pModTranPath);
    AddGUIDToStackOrder(szDcomGUID, reg);

    // Now add an entry for dcom

    reg.MoveToSubkey(szDcomGUID);
    reg.SetStr(__TEXT("Name"), pDCOMName);
    reg.SetDWORD(__TEXT("Independent"), 1);

    AddDisplayName(reg, UUID_DCOMName, pDCOMName);
}

//***************************************************************************
//
// CreateAddResModEntries
//
// Purpose: Creates the registry entries for the Address Resolution Modules
//
//***************************************************************************

void CreateAddResModEntries()
{
    // create a narrow string version of the local name resolver CLSID

    TCHAR szLocalAddRes[GUID_SIZE] = __TEXT("");
    CreateLPTSTRFromGUID(CLSID_WbemLocalAddrRes, szLocalAddRes, GUID_SIZE);


    // The StackOrder value is a multistring list of the CLSIDs of the network
    // transports.  Create it with a single entry if it doesnt already exist, or
    // just put DCOM at the from of the list if it doesnt exist.

    Registry reg(pAddResPath);
    AddGUIDToStackOrder(szLocalAddRes, reg);


    // Now add an entry for local address resolution module
    // It will contain
    // "Name"         REG_SZ,     documentary name
    // "Display Name" REG_SZ,     GUID of display name in localization key
    // "Supporte Address Type" REG_MULTI_SZ:  <GUIDs of address types supported>

    reg.MoveToSubkey(szLocalAddRes);
    reg.SetStr(__TEXT("Name"), pLocalAddr);
    TCHAR cSupportedTypes[GUID_SIZE+1];
    memset(cSupportedTypes, 0, GUID_SIZE+1);
    CreateLPTSTRFromGUID(UUID_LocalAddrType, cSupportedTypes, GUID_SIZE);
    reg.SetMultiStr(__TEXT("Supported Address Types"), cSupportedTypes, GUID_SIZE+1);

    AddDisplayName(reg, UUID_LocalAddResName, pLocalAddr);

}

//***************************************************************************
//
// CreateAddrTypesList
//
// Purpose: Creates the address types list
//
//***************************************************************************

void CreateAddrTypesList()
{
    // create a narrow string LocalMachine addr CLSID

    TCHAR szLocalType[GUID_SIZE];
    CreateLPTSTRFromGUID(UUID_LocalAddrType, szLocalType, GUID_SIZE);
    Registry reg(WBEM_REG_WBEM __TEXT("\\TRANSPORTS\\AddressTypes\\"));
    reg.MoveToSubkey(szLocalType);

    // Now add an entry for local address type
    // It will contain
    // "Description"         REG_SZ,     documentary name
    // "Display Name" REG_SZ,     GUID of display name in localization key

    reg.SetStr(__TEXT("Description"), __TEXT("Local Machine"));
    AddDisplayName(reg, UUID_LocalAddrTypeName, __TEXT("Local Machine"));

}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

#define LocatorPROGID __TEXT("WBEMComLocator")
#define ConnectionPROGID __TEXT("WBEMComConnection")

STDAPI DllRegisterServer(void)
{ 
   RegisterDLL(ghModule, CLSID_WbemLocator, __TEXT("WBEM Locator"), __TEXT("Both"), LocatorPROGID);
   RegisterDLL(ghModule, CLSID_WbemConnection, __TEXT("WBEM Connection"), __TEXT("Both"), ConnectionPROGID);
   RegisterDLL(ghModule, CLSID_WbemDCOMTransport, pDCOMName, __TEXT("Both"), NULL);
   RegisterDLL(ghModule, CLSID_WbemLocalAddrRes, pLocalAddr, __TEXT("Both"), NULL);
//   RegisterDLL(ghModule, CLSID__DSSvcExWrap, __TEXT("UMI ServicesEx Wrapper"), __TEXT("Both"), NULL);

   RegisterDLL(ghModule, CLSID_WbemAdministrativeLocator, __TEXT(""), __TEXT("Both"), NULL);
   RegisterDLL(ghModule, CLSID_WbemAuthenticatedLocator, __TEXT(""), __TEXT("Both"), NULL);
   RegisterDLL(ghModule, CLSID_WbemUnauthenticatedLocator, __TEXT(""), __TEXT("Both"), NULL);

   CreateNetTranModEntries();
   CreateAddResModEntries();
   CreateAddrTypesList();
   return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    UnRegisterDLL(CLSID_WbemLocator,LocatorPROGID);
    UnRegisterDLL(CLSID_WbemConnection,ConnectionPROGID);
    UnRegisterDLL(CLSID_WbemDCOMTransport,NULL);
    UnRegisterDLL(CLSID_WbemLocalAddrRes,NULL);
//	UnRegisterDLL(CLSID__DSSvcExWrap, NULL);
    UnRegisterDLL(CLSID_WbemAdministrativeLocator, NULL);
    UnRegisterDLL(CLSID_WbemAuthenticatedLocator, NULL);
    UnRegisterDLL(CLSID_WbemUnauthenticatedLocator, NULL);
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\proxutil.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    PROXUTIL.CPP

Abstract:

    Contains utilities used by the proxy code.

History:

    a-davj  15-Jan-98   Created.

--*/

#include "precomp.h"
#include <wbemidl.h>
//#include "corepol.h"
#include <wbemutil.h>
#include <genutils.h>
#include <reg.h>
#include "proxutil.h"
#include "wbemprox.h"

TCHAR * pAddResPath = WBEM_REG_WBEM __TEXT("\\TRANSPORTS\\Address Resolution Modules");
TCHAR * pModTranPath = WBEM_REG_WBEM __TEXT("\\TRANSPORTS\\Network Transport Modules");


//***************************************************************************
//
// CreateLPTSTRFromGUID
//
// Purpose: Creates narrow string version of a guid
//
//***************************************************************************

void CreateLPTSTRFromGUID(IN GUID guid, IN OUT TCHAR * pNarrow, IN DWORD dwSize)
{
    WCHAR      wcID[GUID_SIZE];
    if(0 ==StringFromGUID2(guid, wcID, GUID_SIZE))
        return;

#ifdef UNICODE
    lstrcpyn(pNarrow, wcID, dwSize);
#else
    wcstombs(pNarrow, wcID, dwSize);
#endif

}

//***************************************************************************
//
// CreateGUIDFromLPSTR
//
// Purpose: Create GUID from a Narrow string
//
//***************************************************************************

SCODE CreateGUIDFromLPTSTR(IN LPTSTR pszGuid, CLSID * pClsid)
{
    if(pszGuid == NULL)
        return WBEM_E_FAILED;

    WCHAR wClsid[GUID_SIZE];
#ifdef UNICODE
    lstrcpy(wClsid, pszGuid);
#else
    mbstowcs(wClsid, pszGuid, GUID_SIZE);
#endif
    return  CLSIDFromString(wClsid, pClsid);
}

//***************************************************************************
//
// AddGUIDToStackOrder
//
// Purpose: Inserts a GUID into the "Stack Order" multistring.
//
//***************************************************************************

void AddGUIDToStackOrder(LPTSTR szGUID, Registry & reg)
{
    long lRes;
    DWORD dwSize = 0;
    TCHAR * pData = NULL;
    pData = reg.GetMultiStr(__TEXT("Stack Order"), dwSize);

    if(pData)
    {
        // The value already exists.  Allocate enough data to store the data.
    
        TCHAR * pTest;
        for(pTest = pData; *pTest; pTest += lstrlen(pTest) + 1)
            if(!lstrcmpi(pTest, szGUID))
                break;
        if(*pTest == NULL)
        {
            // our isnt in the list, add it

            DWORD dwDataSize = DWORD(pTest - pData + 1);
            TCHAR * pNew = new TCHAR[dwDataSize + GUID_SIZE];
            lstrcpy(pNew, szGUID);
            memcpy(pNew + GUID_SIZE, pData, sizeof(TCHAR)*dwDataSize);
            lRes = reg.SetMultiStr(__TEXT("Stack Order"), pNew, sizeof(TCHAR)*(dwDataSize + GUID_SIZE));
            delete []pNew;
         }

         delete []pData;
    }
    else
    {
        // The value does not exist.  Create it with just our entry in it

        TCHAR * pNew = new TCHAR[GUID_SIZE + 1];
        lstrcpy(pNew, szGUID);
        pNew[GUID_SIZE] = 0;            // put in the double null which is needed for REG_MULTI_SZ
        lRes = reg.SetMultiStr(__TEXT("Stack Order"), pNew, sizeof(TCHAR)*(GUID_SIZE + 1));
        delete []pNew;
    }
}

//***************************************************************************
//
// AddDisplayName
//
// Purpose: Adds a "Display Name" string to the registry which will contain the
// guid of the internationalization string.  It then adds the string to the 
// english part of the internationization table.
//
//***************************************************************************

void AddDisplayName(Registry & reg, GUID guid, LPTSTR pDescription)
{
    TCHAR cGuid[GUID_SIZE];
    cGuid[0] = 0;
    CreateLPTSTRFromGUID(guid, cGuid, GUID_SIZE);
    reg.SetStr(__TEXT("Display Name"), cGuid);

    Registry reglang(WBEM_REG_WBEM __TEXT("\\TRANSPORTS\\Localizations\\409"));
    reglang.SetStr(cGuid, pDescription);
}

CMultStr::CMultStr(TCHAR * pInit)
{
    m_pData = pInit;
    m_pNext = pInit;
}
CMultStr::~CMultStr()
{
    if(m_pData)
        delete m_pData;
}

TCHAR * CMultStr::GetNext()
{
    if(m_pNext == NULL || *m_pNext == 0)
        return NULL;
    TCHAR * pRet = m_pNext;
    if(m_pNext)
        m_pNext += lstrlen(m_pNext) + 1;
    return pRet;
}

ComThreadInit::ComThreadInit(bool bInitThread)
{
	m_InitCount = 0;
	if(bInitThread)
	{
		HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
		if(SUCCEEDED(hr))
			m_InitCount++;
		if(hr == S_FALSE)
		{
			hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED );
			if(SUCCEEDED(hr))
				m_InitCount++;
		}
	}
}

ComThreadInit::~ComThreadInit()
{
	for(DWORD dwCnt = 0; dwCnt < m_InitCount; dwCnt++)
		CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\locator.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    LOCATOR.H

Abstract:

	Declares the CLocator class.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _locator_H_
#define _locator_H_

typedef void ** PPVOID;

class CMultStr;
class CModuleList
{
public:

	CModuleList();
	~CModuleList();
    SCODE LoadAddTryTheAddrModule(IN LPTSTR pszAddModClsid,
                                   IN LPWSTR Namespace,
                                   IN LPTSTR pAddrType,
                                   OUT DWORD * pdwBinaryAddressLength,
                                   OUT LPBYTE * pbBinaryAddress);

    SCODE GetResolvedAddress(IN LPTSTR pAddrType, IN LPWSTR pNamespace,
                                   OUT DWORD * pdwBinaryAddressLength,
                                   OUT LPBYTE *pbBinaryAddress);

	SCODE GetNextModule(REFIID firstChoiceIID, PPVOID pFirstChoice,
						REFIID SecondChoiceIID, PPVOID pSecondChoice,
						REFIID ThirdChoiceIID, PPVOID pThirdChoice,
						REFIID FourthChoiceIID, PPVOID pFourthChoice,
						DWORD * pdwBinaryAddressLength,
                        LPBYTE * pbBinaryAddress,
						LPWSTR * ppwszAddrType, LPWSTR NetworkResource);
protected:
	CMultStr * m_pTranModList;
	CMultStr * m_pAddrTypeList;
    TCHAR * m_pszTranModCLSID;

};

class CDSCallResult;
//***************************************************************************
//
//  CLASS NAME:
//
//  CLocator
//
//  DESCRIPTION:
//
//  Implements the IWbemLocator interface.  This class is what the client gets
//  when it initially hooks up to the Wbemprox.dll.  The ConnectServer function
//  is what get the communication between client and server started.
//
//***************************************************************************

class CLocator : public IWbemLocator
    {
    protected:
        long            m_cRef;         //Object reference count
    public:
    
    CLocator();
    ~CLocator(void);

    BOOL Init(void);

    //Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void)
	{
		InterlockedIncrement(&m_cRef);
		return m_cRef;
	}
    STDMETHODIMP_(ULONG) Release(void)
	{
		long lTemp = InterlockedDecrement(&m_cRef);
		if (0L!=lTemp)
			return lTemp;
		delete this;
		return 0;
	}
 
	/* iWbemLocator methods */
	STDMETHOD(ConnectServer)(THIS_ const BSTR NetworkResource, const BSTR User, 
     const BSTR Password, const BSTR lLocaleId, long lFlags, const BSTR Authority,
     IWbemContext __RPC_FAR *pCtx,
     IWbemServices FAR* FAR* ppNamespace);

};

class CSinkWrap;

class CConnection : public IWbemConnection
    {
    protected:
        long            m_cRef;         //Object reference count
    public:
    
    CConnection();
    ~CConnection(void);

    BOOL Init(void);

	SCODE CConnOpenPreCall(
        const BSTR Object,
        const BSTR User,
        const BSTR Password,
        const BSTR Locale,
        long lFlags,
        IWbemContext __RPC_FAR *pCtx,
        REFIID riid,
		void **pInterface,
        IWbemCallResultEx ** ppCallRes, 
		IWbemObjectSinkEx * pSinkWrap);

	SCODE ActualOpen( 
        /* [in] */ const BSTR strObject,
        /* [in] */ const BSTR User,
        /* [in] */ const BSTR Password,
        /* [in] */ const BSTR LocaleId,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pInterface,
		CSinkWrap * pSinkWrap);

	//Non-delegating object IUnknown
    STDMETHODIMP         QueryInterface(REFIID, PPVOID);
    STDMETHODIMP_(ULONG) AddRef(void)
	{
		InterlockedIncrement(&m_cRef);
		return m_cRef;
	}
    STDMETHODIMP_(ULONG) Release(void)
	{
		long lTemp = InterlockedDecrement(&m_cRef);
		if (0L!=lTemp)
			return lTemp;
		delete this;
		return 0;
	}

    virtual HRESULT STDMETHODCALLTYPE Open( 
        /* [in] */ const BSTR strObject,
        /* [in] */ const BSTR strUser,
        /* [in] */ const BSTR strPassword,
        /* [in] */ const BSTR strLocale,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *pInterface,
        /* [out] */ IWbemCallResultEx __RPC_FAR *__RPC_FAR *pCallRes);
    
    virtual HRESULT STDMETHODCALLTYPE OpenAsync( 
        /* [in] */ const BSTR strObject,
        /* [in] */ const BSTR strUser,
        /* [in] */ const BSTR strPassword,
        /* [in] */ const BSTR strLocale,
        /* [in] */ long lFlags,
        /* [in] */ IWbemContext __RPC_FAR *pCtx,
        /* [in] */ REFIID riid,
        /* [in] */ IWbemObjectSinkEx __RPC_FAR *pResponseHandler);
    
    virtual HRESULT STDMETHODCALLTYPE Cancel( 
        /* [in] */ long lFlags,
        /* [in] */ IWbemObjectSinkEx __RPC_FAR *pHandler);

};

//***************************************************************************
//
//  CLASS NAME:
//
//  COpen
//
//  DESCRIPTION:
//
//  Special request used for IWmiConnect::Open
//
//***************************************************************************

class CConnection;

struct COpen
{

public:
		CConnection * m_pConn;
        BSTR m_strObject;
        BSTR m_strUser;
        BSTR m_strPassword;
        BSTR m_strLocale;
        long m_lFlags;
        IWbemContext *m_pCtx;
		CDSCallResult * m_pCallRes; 
        IID m_riid;
		void ** m_pInterface;
        CSinkWrap * m_pSink;
        LPSTREAM m_pSinkStream;
        LPSTREAM *m_ppCallResStream;
        LPSTREAM m_pContextStream;
		DWORD m_Status;
        HANDLE m_hInitDoneEvent;
	
	COpen(CConnection * pConn,
        const BSTR strObject,
        const BSTR strUser,
        const BSTR strPassword,
        const BSTR strLocale,
        long lFlags,
        IWbemContext *pCtx,
        REFIID riid,
		void ** pInterface,
		LPSTREAM *ppCallResStream, 
        IWbemObjectSinkEx * pSink,
        HANDLE hInitialized);

	~COpen();
	DWORD GetStatus(){return m_Status;};
    HRESULT UnMarshal();
};
DWORD WINAPI OpenThreadRoutine(LPVOID lpParameter);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mc\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\reqobjs.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ReqObjs.H

Abstract:

    Implements the CRequest class and the classes derived from it.  These classes are used
    to encasulate a method so that the method can be executed asynchronously.

History:

	davj  14-Mar-00   Created.

--*/

#ifndef __REQUEST_OBJECTS__H_
#define __REQUEST_OBJECTS__H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CRequest
//
//  DESCRIPTION:
//
//  Virtual base class for the actual requests.  This holds data common to all
//  requests.
//
//***************************************************************************

class CRequest
{

public:
	CRequest(CDSCallResult * pCallRes, IWbemObjectSink * pResponseHandler, bool bAsync, IUmiContainer *  pUmiContainer,
			long lSecurityFlags = 0L);
	virtual ~CRequest();
	virtual HRESULT Execute();
	IUmiContainer *  m_pUmiContainer;
	CDSCallResult * m_pCallRes;
	IWbemObjectSink * m_pSink;
	bool m_bAsync;
	long	m_lSecurityFlags;

};

//***************************************************************************
//
//  CLASS NAME:
//
//  CDeleteObjectRequest
//
//  DESCRIPTION:
//
//  Deletes classes or instances
//
//***************************************************************************

class CDeleteObjectRequest : public CRequest
{

public:
	IUmiURL *m_pPath;
	long m_lFlags;
	bool m_bClass;
	CDeleteObjectRequest(IUmiURL *pURL,long lFlags, IWbemContext * pContext,
						CDSCallResult * pCallRes, IWbemObjectSink * pResponseHandler, 
						bool bAsync, IUmiContainer *  pUmiContainer, bool bClass);


	~CDeleteObjectRequest();
	HRESULT Execute();
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CGetObjectRequest
//
//  DESCRIPTION:
//
//  Implements "GetObject"
//
//***************************************************************************

class CGetObjectRequest : public CRequest
{

public:
	IUmiURL *m_pPath;
	long m_lFlags;
	IWbemClassObject ** m_ppObject; 
	CGetObjectRequest(IUmiURL *pPathURL,long lFlags,IWbemClassObject ** ppObject, 
												CDSCallResult * pCallRes, IWbemObjectSink * pResponseHandler, 
												bool bAsync, IUmiContainer *  pUmiContainer, long lSecurityFlags);


	~CGetObjectRequest();
	HRESULT Execute();
};

//***************************************************************************
//
//  CLASS NAME:
//
//  COpenRequest
//
//  DESCRIPTION:
//
//  Implements OpenNamespace and Open
//
//***************************************************************************

class COpenRequest : public CRequest
{

public:
	IUmiURL *m_pPath;
	long m_lFlags;
	IWbemServices** m_ppNewNamespace;
	IWbemServicesEx **m_ppScope;
	COpenRequest(IUmiURL *pPathURL,long lFlags,IWbemContext * pContext, 
					IWbemServices** ppNewNamespace, IWbemServicesEx **ppScope,
					CDSCallResult * pCallRes, IWbemObjectSinkEx * pResponseHandler, 
					bool bAsync, IUmiContainer *  pUmiContainer, long lSecurityFlags);


	~COpenRequest();
	HRESULT Execute();
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CPutObjectRequest
//
//  DESCRIPTION:
//
//  Implements PutInstance and PutClass
//
//***************************************************************************

class CPutObjectRequest : public CRequest
{

public:
	long m_lFlags;
	IWbemClassObject * m_pObject; 
	CPutObjectRequest(IWbemClassObject * pClass,long lFlags, IWbemContext * pContext, 
						CDSCallResult * pCallRes, IWbemObjectSink * pResponseHandler, 
						bool bAsync, IUmiContainer *  pUmiContainer, long lSecurityFlags);

	~CPutObjectRequest();
	HRESULT Execute();
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CRefreshObjectRequest
//
//  DESCRIPTION:
//
//  Implements refresh
//
//***************************************************************************

class CRefreshObjectRequest : public CRequest
{

public:
	long m_lFlags;
	IWbemClassObject ** m_ppObject; 
	CRefreshObjectRequest(IWbemClassObject ** ppObject,long lFlags, 
						CDSCallResult * pCallRes, IWbemObjectSink * pResponseHandler, 
						bool bAsync, IUmiContainer *  pUmiContainer);


	~CRefreshObjectRequest();
	HRESULT Execute();
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CRenameObjectRequest
//
//  DESCRIPTION:
//
//  Implements Rename
//
//***************************************************************************

class CRenameObjectRequest : public CRequest
{

public:
	long m_lFlags;
	IUmiURL *m_pOldPath;
	IUmiURL *m_pNewPath;
	CRenameObjectRequest(IUmiURL *pURLOld, IUmiURL *pURLNew,long lFlags, IWbemContext * pContext,
						CDSCallResult * pCallRes, IWbemObjectSink * pResponseHandler, 
						bool bAsync, IUmiContainer *  pUmiContainer);


	~CRenameObjectRequest();
	HRESULT Execute();
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\reqobjs.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    ReqObjs.cpp

Abstract:

    Implements the CRequest class and the classes derived from it.  These classes are used
    to encasulate a method so that the method can be executed asynchronously.

History:

	davj  14-Mar-00   Created.

--*/

#include "precomp.h"
#include <genutils.h>
#include <umi.h>
#include <wbemint.h>
#include <wmiutils.h>
//#include <adsiid.h>
#include "dscallres.h"
#include "dssvexwrap.h"
#include "dsenum.h"
#include "wbemprox.h"
#include "locator.h"
#include "dsenum.h"
#include "reqobjs.h"
#include "utils.h"

#pragma warning(disable:4355)

//***************************************************************************
//
//  CLASS NAME:
//
//  CRequest
//
//  DESCRIPTION:
//
//  Virtual base class for the actual requests.  This holds data common to all
//  requests.
//
//***************************************************************************

CRequest::CRequest(CDSCallResult * pCallRes, IWbemObjectSink * pResponseHandler, 
												bool bAsync, IUmiContainer *  pUmiContainer, long lSecurityFlags)
{
	m_pCallRes = pCallRes;
	if(m_pCallRes)
		m_pCallRes->AddRef();
	m_pSink =  pResponseHandler;
	if(m_pSink)
		m_pSink->AddRef();
	m_bAsync = bAsync;
	m_pUmiContainer = pUmiContainer;
	if(m_pUmiContainer)
		m_pUmiContainer->AddRef();
	m_lSecurityFlags = lSecurityFlags;
}

CRequest::~CRequest()
{
	if(m_pCallRes)
		m_pCallRes->Release();
	if(m_pSink)
		m_pSink->Release();
	if(m_pUmiContainer)
		m_pUmiContainer->Release();
}

HRESULT CRequest::Execute()
{
	return WBEM_E_FAILED;
}

//***************************************************************************
//
//  CLASS NAME:
//
//  CDeleteObjectRequest
//
//  DESCRIPTION:
//
//  Deletes classes or instances
//
//***************************************************************************

CDeleteObjectRequest::CDeleteObjectRequest(IUmiURL *pURL,long lFlags, IWbemContext * pContext,
												CDSCallResult * pCallRes, IWbemObjectSink * pResponseHandler, 
												bool bAsync, IUmiContainer *  pUmiContainer,bool bClass) : 
									CRequest(pCallRes, pResponseHandler, bAsync, pUmiContainer)

{
	m_bClass = bClass;
	m_lFlags = lFlags;
	m_pPath = pURL; 
	if(m_pPath)
		m_pPath->AddRef();
}

CDeleteObjectRequest::~CDeleteObjectRequest()
{
	if(m_pPath)
		m_pPath->Release();
}

HRESULT CDeleteObjectRequest::Execute()
{
	return m_pUmiContainer->DeleteObject(m_pPath, (m_bClass) ? UMI_OPERATION_CLASS : UMI_OPERATION_INSTANCE);
}

//***************************************************************************
//
//  CLASS NAME:
//
//  CGetObjectRequest
//
//  DESCRIPTION:
//
//  Implements "GetObject"
//
//***************************************************************************

CGetObjectRequest::CGetObjectRequest(IUmiURL *pPathURL,long lFlags,IWbemClassObject ** ppObject, 
												CDSCallResult * pCallRes, IWbemObjectSink * pResponseHandler, 
												bool bAsync, IUmiContainer *  pUmiContainer, long lSecurityFlags) : 
									CRequest(pCallRes, pResponseHandler, bAsync, pUmiContainer, lSecurityFlags)

{
	m_pPath = pPathURL;
	if(m_pPath)
		m_pPath->AddRef();
	m_lFlags = lFlags;
	m_ppObject = ppObject; 
}

CGetObjectRequest::~CGetObjectRequest()
{
	if(m_pPath)
		m_pPath->Release();
}

HRESULT CGetObjectRequest::Execute()
{

	// Do some analysis on the path.  Figure out if it is empty, or points
    // to a class

	DWORD dwSize;
	HRESULT hr = m_pPath->Get(0, &dwSize, NULL);
	if(FAILED(hr))
		return hr;
	ULONGLONG lType;
	hr = m_pPath->GetPathInfo(0, &lType);
	if(FAILED(hr))
		return hr;
	BOOL bInstance = (lType & UMIPATH_INFO_INSTANCE_PATH);

    // Based on the path, create a new, or open an existing object

    IUmiObject * pUmiObject = NULL;
	if(dwSize == 0)
	{
		// create an empty class

		hr = m_pUmiContainer->Create(
				 m_pPath,
				 UMI_OPERATION_CLASS,
				 &pUmiObject
				 );
	}
	else if(m_lFlags & WBEM_FLAG_SPAWN_INSTANCE)
    {
        // Spawn an instance of a class

		hr = m_pUmiContainer->Create(
				 m_pPath,
				 UMI_OPERATION_INSTANCE,
				 &pUmiObject
				 );
    }
	else
    {
        // Get a particular instance

		hr = m_pUmiContainer->Open(
				 m_pPath,
				 (bInstance) ? UMI_OPERATION_INSTANCE : UMI_OPERATION_CLASS,
				 IID_IUmiObject,
				 (void **) &pUmiObject
				 );
    }
	if(FAILED(hr))
		return hr;

    CReleaseMe rm(pUmiObject);


    // Create the wrapper factory and spawn and create a wrapper

	_IWmiObjectFactory*	pFactory = NULL;
	hr = CoCreateInstance( CLSID__WmiObjectFactory, NULL, CLSCTX_INPROC_SERVER, 
														IID__IWmiObjectFactory, (void**) &pFactory );
	if(FAILED(hr))
		return hr;
	CReleaseMe rm11(pFactory);

	_IWbemUMIObjectWrapper*	pObjWrapper = NULL;
	hr = pFactory->Create( NULL, 0L, CLSID__WbemUMIObjectWrapper, IID__IWbemUMIObjectWrapper, (void**) &pObjWrapper );
	if(FAILED(hr))
		return hr;

	CReleaseMe rm2(pObjWrapper);		// add ref is done if rest goes well

    // stick the umi object into the wrapper

	hr = pObjWrapper->SetObject( m_lSecurityFlags, pUmiObject );
	if(FAILED(hr))
		return hr;

    // Get an IWbemClassObject pointer and return it

	IWbemClassObject * pObj = NULL;
	hr = pObjWrapper->QueryInterface(IID_IWbemClassObject, (void**)&pObj);
	if(FAILED(hr))
		return hr;
	if(m_pSink)
	{
		m_pSink->Indicate(1, &pObj);
		pObj->Release();
	}
	else if(m_pCallRes && m_bAsync)
	{
		m_pCallRes->SetResultObject(pObj);
		pObj->Release();
	}
	else if(m_ppObject)
	{
		*(m_ppObject) = pObj;
	}
	else
		hr = WBEM_E_INVALID_PARAMETER;
	return hr;
}

//***************************************************************************
//
//  CLASS NAME:
//
//  COpenRequest
//
//  DESCRIPTION:
//
//  Implements OpenNamespace and Open
//
//***************************************************************************

COpenRequest::COpenRequest(IUmiURL *pPathURL,long lFlags,IWbemContext * pContext, 
					IWbemServices** ppNewNamespace, IWbemServicesEx **ppScope,
					CDSCallResult * pCallRes, IWbemObjectSinkEx * pResponseHandler, 
					bool bAsync, IUmiContainer *  pUmiContainer, long lSecurityFlags )
					: CRequest(pCallRes, pResponseHandler, bAsync, pUmiContainer, lSecurityFlags )
{
	m_pPath = pPathURL;
	if(m_pPath)
		m_pPath->AddRef();
	m_lFlags = lFlags;
	m_ppNewNamespace = ppNewNamespace;
	m_ppScope = ppScope;
}

COpenRequest::~COpenRequest()
{
	if(m_pPath)
		m_pPath->Release();
}


HRESULT COpenRequest::Execute()
{
    IUmiContainer *pUmiContainer;

	HRESULT hr = m_pUmiContainer->Open(
				 m_pPath,
				 0,
    	          IID_IUmiContainer,
				 (void **) &pUmiContainer
				 );
	if(FAILED(hr))
		return hr;
	CReleaseMe rm(pUmiContainer);

	// Create a factory from which we will retrieve a wrapper object
	_IWmiObjectFactory*	pFactory = NULL;
	hr = CoCreateInstance( CLSID__WmiObjectFactory, NULL, CLSCTX_INPROC_SERVER, 
														IID__IWmiObjectFactory, (void**) &pFactory );
	if(FAILED(hr))
		return FALSE;
	CReleaseMe rm11(pFactory);

	// Create a wrapper and tie the container to it.  This will agregate the correct interfaces.
	_IWbemUMIObjectWrapper*	pObjWrapper = NULL;
	hr = pFactory->Create( NULL, 0L, CLSID__WbemUMIObjectWrapper, IID__IWbemUMIObjectWrapper, (void**) &pObjWrapper );
	CReleaseMe	rmWrap( pObjWrapper );

	if ( SUCCEEDED( hr ) )
	{
		IUnknown*	pUnk = NULL;
		hr = pUmiContainer->QueryInterface( IID_IUnknown, (void**) &pUnk );
		CReleaseMe	rm2( pUnk );

		if ( SUCCEEDED( hr ) )
		{
			hr = pObjWrapper->SetObject( UMIOBJECT_WRAPPER_FLAG_CONTAINER | m_lSecurityFlags, pUnk );
		}
	}

	// Quit if inappropriate
	if ( FAILED( hr ) )
	{
		return hr;
	}

	if(m_pSink)
	{
		IWbemObjectSinkEx * pSinkEx = NULL;
		hr = m_pSink->QueryInterface(IID_IWbemObjectSinkEx, (void **)pSinkEx);
	    if(FAILED(hr))
		    return hr;
		pSinkEx->Set(0,IID_IWbemServicesEx, &pObjWrapper);
		pSinkEx->Release();
	}
	else if(m_pCallRes && m_bAsync)
	{
		IWbemServices*	pSvc = NULL;
		hr = pObjWrapper->QueryInterface(IID_IWbemServices, (void **)&pSvc);
		if ( SUCCEEDED( hr ) )
		{
			m_pCallRes->SetResultServices(pSvc);
		}	// IF QI
	}
	else if(m_ppNewNamespace)
	{
		hr = pObjWrapper->QueryInterface(IID_IWbemServices, (void **)m_ppNewNamespace);
	}
	else if(m_ppScope)
	{
		hr = pObjWrapper->QueryInterface(IID_IWbemServicesEx, (void **)m_ppScope);
	}
	else
		hr = WBEM_E_INVALID_PARAMETER;
	return hr;


}

//***************************************************************************
//
//  CLASS NAME:
//
//  CPutObjectRequest
//
//  DESCRIPTION:
//
//  Implements PutInstance and PutClass
//
//***************************************************************************

CPutObjectRequest::CPutObjectRequest(IWbemClassObject * pObject, long lFlags, IWbemContext * pContext,
												CDSCallResult * pCallRes, IWbemObjectSink * pResponseHandler, 
												bool bAsync, IUmiContainer *  pUmiContainer, long lSecurityFlags ) : 
									CRequest(pCallRes, pResponseHandler, bAsync, pUmiContainer, lSecurityFlags)

{
	m_lFlags = lFlags;
	m_pObject = pObject; 
	if(m_pObject)
		pObject->AddRef();
}

CPutObjectRequest::~CPutObjectRequest()
{
	if(m_pObject)
		m_pObject->Release();
}

HRESULT CPutObjectRequest::Execute()
{
	IUmiObject * pUmiObj = NULL;
	HRESULT hr = m_pObject->QueryInterface(IID_IUmiObject, (void **)&pUmiObj);
	if(FAILED(hr))
		return hr;
	hr = pUmiObj->Commit( m_lSecurityFlags );
	pUmiObj->Release();
	return hr;
}

//***************************************************************************
//
//  CLASS NAME:
//
//  CRefreshObjectRequest
//
//  DESCRIPTION:
//
//  Implements refresh
//
//***************************************************************************

CRefreshObjectRequest::CRefreshObjectRequest(IWbemClassObject ** ppObject, long lFlags,
												CDSCallResult * pCallRes, IWbemObjectSink * pResponseHandler, 
												bool bAsync, IUmiContainer *  pUmiContainer) : 
									CRequest(pCallRes, pResponseHandler, bAsync, pUmiContainer)

{
	m_lFlags = lFlags;
	m_ppObject = ppObject; 
	if(*m_ppObject)
		(*ppObject)->AddRef();
}

CRefreshObjectRequest::~CRefreshObjectRequest()
{
	if(*m_ppObject)
		(*m_ppObject)->Release();
}

HRESULT CRefreshObjectRequest::Execute()
{

	IUmiObject * pUmi = NULL;
	HRESULT hr = (*m_ppObject)->QueryInterface(IID_IUmiObject, (void **)&pUmi);
	if(SUCCEEDED(hr))
	{
		hr = pUmi->Refresh(0,0, NULL);
        pUmi->Release();
	}

	return hr;
}

//***************************************************************************
//
//  CLASS NAME:
//
//  CRenameObjectRequest
//
//  DESCRIPTION:
//
//  Implements Rename
//
//***************************************************************************

CRenameObjectRequest::CRenameObjectRequest(IUmiURL *pURLOld, IUmiURL *pURLNew,long lFlags, 
										        IWbemContext * pContext,
												CDSCallResult * pCallRes, IWbemObjectSink * pResponseHandler, 
												bool bAsync, IUmiContainer *  pUmiContainer) : 
									CRequest(pCallRes, pResponseHandler, bAsync, pUmiContainer)

{
	m_lFlags = lFlags;
	m_pOldPath = pURLOld;
	if(m_pOldPath)
		m_pOldPath->AddRef();

	m_pNewPath = pURLNew;
	if(m_pNewPath)
		m_pNewPath->AddRef();
}

CRenameObjectRequest::~CRenameObjectRequest()
{
	if(m_pOldPath)
		m_pOldPath->Release();
	if(m_pNewPath)
		m_pNewPath->Release();
}

HRESULT CRenameObjectRequest::Execute()
{
	return m_pUmiContainer->Move(m_lFlags, m_pOldPath, m_pNewPath);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\sinkwrap.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SinkWrap.CPP

Abstract:

    Defines the classes needed to wrap IWbemObjectSink objects.

History:

--*/

#include "precomp.h"
#include <wbemidl.h>
#include <wbemint.h>
#include <flexarry.h>
#include <sync.h>
#include "sinkwrap.h"

//#pragma warning(disable:4355)


CSinkCollection g_SinkCollection;

CSinkWrap::CSinkWrap(IWbemObjectSinkEx * pActualSink)
{
    m_lRef = 1;
	m_bCanceled = false;
	m_bFinished = false;
	m_pActualSink = pActualSink;
	m_pIWbemClientConnectionTransport = NULL;
	m_pIWbemConnection = NULL;
}


CSinkWrap::~CSinkWrap()
{
	if(m_pActualSink)
		m_pActualSink->Release();
	ReleaseTransportPointers();
}

STDMETHODIMP CSinkWrap::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemObjectSink  || riid == IID_IWbemObjectSinkEx)
    {
        AddRef();
        *ppv = (void*)this;
        return S_OK;
    }
    else return E_NOINTERFACE;
}


HRESULT CSinkWrap::Indicate( 
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray)
{
	CInCritSec ics(&g_SinkCollection.m_cs);
	if(!m_bCanceled)
		return m_pActualSink->Indicate(lObjectCount, apObjArray);
	else
		return WBEM_E_CALL_CANCELLED;
}
        
HRESULT CSinkWrap::SetStatus( 
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam)
{
	CInCritSec ics(&g_SinkCollection.m_cs);
	if(lFlags == WBEM_STATUS_COMPLETE)
		m_bFinished = true;
	if(!m_bCanceled)
		return m_pActualSink->SetStatus(lFlags, hResult, strParam, pObjParam);
	else
		return WBEM_E_CALL_CANCELLED;

}
        
	// IWbemObjectSinkEx functions

HRESULT CSinkWrap::Set( 
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ void __RPC_FAR *pComObject)
{
	CInCritSec ics(&g_SinkCollection.m_cs);
	if(!m_bCanceled)
		return m_pActualSink->Set(lFlags, riid, pComObject);
	else
		return WBEM_E_CALL_CANCELLED;
}

HRESULT CSinkWrap::SetIWbemClientConnectionTransport(
									IWbemClientConnectionTransport * pClientConnTran)
{
	CInCritSec ics(&g_SinkCollection.m_cs);
	ReleaseTransportPointers();
	if(m_bCanceled)
		return WBEM_E_CALL_CANCELLED;
	m_pIWbemClientConnectionTransport = pClientConnTran;
	m_pIWbemClientConnectionTransport->AddRef();
	return S_OK;
}

HRESULT CSinkWrap::SetIWbemConnection(IWbemConnection * pConnection)
{
	CInCritSec ics(&g_SinkCollection.m_cs);
	ReleaseTransportPointers();
	if(m_bCanceled)
		return WBEM_E_CALL_CANCELLED;
	m_pIWbemConnection = pConnection;
	m_pIWbemConnection->AddRef();
	return S_OK;
}
void CSinkWrap::ReleaseTransportPointers()
{
	CInCritSec ics(&g_SinkCollection.m_cs);
	if(m_pIWbemConnection)
		m_pIWbemConnection->Release();
	if(m_pIWbemClientConnectionTransport)
		m_pIWbemClientConnectionTransport->Release();

	m_pIWbemConnection = NULL;
	m_pIWbemClientConnectionTransport = NULL;

}
void CSinkWrap::CancelIfOriginalSinkMatches(IWbemObjectSinkEx * pOrigSink)
{
	CInCritSec ics(&g_SinkCollection.m_cs);
	if(pOrigSink == m_pActualSink)
	{
		if(!m_bFinished)
		{
			if(m_pIWbemConnection)
				m_pIWbemConnection->Cancel(0, this);
			if(m_pIWbemClientConnectionTransport)
				m_pIWbemClientConnectionTransport->Cancel(0, this);
			ReleaseTransportPointers();
			SetStatus(WBEM_STATUS_COMPLETE, WBEM_E_CALL_CANCELLED, NULL, NULL);
		}
		m_bCanceled = true;
	}
}

// note that the CSinkCollection is ment to be a global and thus does not need to be freed

CSinkCollection::CSinkCollection()
{
	InitializeCriticalSection(&m_cs);
}	

CSinkCollection::~CSinkCollection()
{
	DeleteCriticalSection(&m_cs);
}	

HRESULT CSinkCollection::CancelCallsForSink(IWbemObjectSinkEx * pOrigSink)
{
	CInCritSec ics(&m_cs);
	for(long lCnt = 0; lCnt < m_ActiveSinks.Size(); lCnt++)
	{
		CSinkWrap * pCurr = (CSinkWrap *)m_ActiveSinks.GetAt(lCnt);
		pCurr->CancelIfOriginalSinkMatches(pOrigSink);
	}
	return S_OK;
}

HRESULT CSinkCollection::AddToList(CSinkWrap * pAdd)
{
	CInCritSec ics(&m_cs);
	m_ActiveSinks.Add(pAdd);
	pAdd->AddRef();
	return S_OK;
}

void CSinkCollection::RemoveFromList(CSinkWrap * pRemove)
{
	CInCritSec ics(&m_cs);
	for(long lCnt = 0; lCnt < m_ActiveSinks.Size(); lCnt++)
	{
		CSinkWrap * pCurr = (CSinkWrap *)m_ActiveSinks.GetAt(lCnt);
		if(pCurr == pRemove)
		{
			pCurr->Release();
			m_ActiveSinks.RemoveAt(lCnt);
			return;
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\wbemprox.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    WBEMPROX.H

Abstract:

    Genral purpose include file.

History:

	a-davj  04-Mar-97   Created.

--*/

#ifndef _WBEMPROX_H_
#define _WBEMPROX_H_

typedef LPVOID * PPVOID;

// These variables keep track of when the module can be unloaded

extern long       g_cObj;
extern ULONG       g_cLock;

// This enumerator defines objects created and destroyed by this dll.

enum OBJTYPE{CLASS_FACTORY = 0, LOCATOR, DCOMTRAN, LOCALADDR, CONNECTION, DSSVEX, ADMINLOC,
             AUTHLOC, UNAUTHLOC, MAX_CLIENT_OBJECT_TYPES};

void ObjectCreated(OBJTYPE dwType);
void ObjectDestroyed(OBJTYPE dwType);

#define GUID_SIZE 39

//***************************************************************************
//
//  CLASS NAME:
//
//  CLogin
//
//  DESCRIPTION:
//
//  A wrapper for the IWbemLevel1Login interface.  
//
//***************************************************************************

class CLogin: public IWbemLevel1Login
    {
    protected:
        long        m_cRef;         //Object reference count
		IWbemLevel1Login * m_pLogin;
		SCODE MakeSureWeHaveAPointer(LPWSTR pNetworkResource, LPWSTR pUser);
		DWORD m_dwType;

    public:
        CLogin();
        ~CLogin(void);
		DWORD GetType(void){return m_dwType;};

        //Non-delegating object IUnknown
      
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        STDMETHODIMP RequestChallenge(
			LPWSTR pNetworkResource,
            LPWSTR pUser,
            WBEM_128BITS Nonce,
			DWORD dwProcessID, DWORD * pAuthEventHandle);

        STDMETHODIMP SspiPreLogin( 
            LPWSTR pNetworkResource,
            LPSTR pszSSPIPkg,
            long lFlags,
            long lBufSize,
            byte __RPC_FAR *pInToken,
            long lOutBufSize,
            long __RPC_FAR *plOutBufBytes,
            byte __RPC_FAR *pOutToken,
            DWORD dwProcessId,
            DWORD __RPC_FAR *pAuthEventHandle);  
                        
        STDMETHODIMP Login( 
			LPWSTR pNetworkResource,
            LPWSTR TokenType,
			LPWSTR pPreferredLocale,
            WBEM_128BITS AccessToken,
            IN LONG lFlags,
            IWbemContext  *pCtx,
            IN OUT IWbemServices  **ppNamespace);

        STDMETHODIMP InvalidateAccessToken( 
            /* [unique][in] */ WBEM_128BITS AccessToken,
            /* [in] */ long lFlags);
};


//***************************************************************************
//
//  CLASS NAME:
//
//  CLocatorFactory
//
//  DESCRIPTION:
//
//  Class factory for the CLocator class.
//
//***************************************************************************

class CLocatorFactory : public IClassFactory
    {
    protected:
        long           m_cRef;
        DWORD          m_dwType;
    public:
        CLocatorFactory(DWORD dwType);
        ~CLocatorFactory(void);

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID, PPVOID);
        STDMETHODIMP_(ULONG) AddRef(void);
        STDMETHODIMP_(ULONG) Release(void);

        //IClassFactory members
        STDMETHODIMP         CreateInstance(LPUNKNOWN, REFIID
                                 , PPVOID);
        STDMETHODIMP         LockServer(BOOL);
    };

DEFINE_GUID(CLSID_WinNTConnectionObject,0x7992c6eb,0xd142,0x4332,0x83,0x1e,0x31,0x54,0xc5,0x0a,0x83,0x16);
DEFINE_GUID(CLSID_LDAPConnectionObject,0x7da2a9c4,0x0c46,0x43bd,0xb0,0x4e,0xd9,0x2b,0x1b,0xe2,0x7c,0x45);
    
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\utils.cpp ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    utils.CPP

Abstract:

    various helper functions used by the ds wrapper

History:

	davj  14-Mar-00   Created.

--*/

#include "precomp.h"
#include <genutils.h>
#include <wbemint.h>
#include <umi.h>
#include <wmiutils.h>
//#include <adsiid.h>
#include "dscallres.h"
#include "dssvexwrap.h"
#include "dsenum.h"
#include "wbemprox.h"
#include "reqobjs.h"
#include "utils.h"
#include "proxutil.h"

#define WINNTSTR L"WINNT"
#define ADSISTR L"ADSI"


HRESULT AllocateCallResult(IWbemCallResult** ppResult, CDSCallResult ** ppCallRes)
{
	if(ppResult == NULL)
		return S_OK;
	*ppCallRes = new CDSCallResult();
	if(*ppCallRes == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	*ppResult = *ppCallRes;
	return S_OK;
}

HRESULT AllocateCallResultEx(IWbemCallResultEx** ppResult, CDSCallResult ** ppCallRes)
{
	if(ppResult == NULL)
		return S_OK;
	*ppCallRes = new CDSCallResult();
	if(*ppCallRes == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	*ppResult = *ppCallRes;
	return S_OK;
}


DWORD WINAPI CreateEnumThreadRoutine(LPVOID lpParameter)
{
	CCreateInstanceEnumRequest * pReq = (CCreateInstanceEnumRequest *)lpParameter;
	HRESULT hr;
	bool bNeedComInit = pReq->m_bAsync;
	ComThreadInit ci(bNeedComInit);

	CDeleteMe<CCreateInstanceEnumRequest> dm0(pReq);

	// Create the wrapper factory

	_IWmiObjectFactory*	pFactory = NULL;
	hr = CoCreateInstance( CLSID__WmiObjectFactory, NULL, CLSCTX_INPROC_SERVER, 
														IID__IWmiObjectFactory, (void**) &pFactory );
	CReleaseMe	rm( pFactory );

	if(FAILED(hr))
	{
		pReq->m_pColl->SetDone(hr);
		return 1;
	}

	long lNumRead = 0;

	// While not done,
	while (1)
	{

		// read 10 entries from cursor

		// todo, this isnt right since they should not be allocating

		DWORD dwReturned;
		IUmiObject ** pUseMe = NULL;
		hr = pReq->m_pCursor->Next(10, &dwReturned, (void **)&pUseMe);

		if(FAILED(hr) || dwReturned == 0)
			break;

		IUnknown * pUnk = NULL;

		if(FAILED(hr))
			return hr;
		lNumRead += dwReturned;

		// wrap the returned objects
		
		IWbemClassObject * Array[10];
		for(DWORD dwCnt = 0; dwCnt < dwReturned; dwCnt++)
		{
			IUmiObject * pUmi = pUseMe[dwCnt];
			CReleaseMe	rmUmi( pUmi );

			_IWbemUMIObjectWrapper*	pObjWrapper = NULL;
			hr = pFactory->Create( NULL, 0L, CLSID__WbemUMIObjectWrapper, 
								   IID__IWbemUMIObjectWrapper, (void**) &pObjWrapper );
			if(FAILED(hr))
				return hr;

			hr = pObjWrapper->SetObject( pReq->m_lSecurityFlags, pUmi);
			if(FAILED(hr))
				return hr;
			pObjWrapper->QueryInterface(IID_IWbemClassObject, (void**)&Array[dwCnt]);

			pObjWrapper->Release();
		}  

		// add to the collection, the collection takes ownership.

		pReq->m_pColl->AddObjectsToList(Array, dwReturned);


	}

	pReq->m_pColl->SetDone(S_OK);
	return 0;
}


HRESULT CreateThreadOrCallDirectly(bool bAsync, CRequest * pReq)
{
	if(pReq == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	if(bAsync)
	{
        DWORD dwIDLikeIcare;
        HANDLE hThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)LaunchExecuteThreadRoutine, 
                                     (LPVOID)pReq, 0, &dwIDLikeIcare);
		if(hThread == NULL)
			return WBEM_E_FAILED;
		else
		{
			CloseHandle(hThread);
			return S_OK;
		}
	}
	else
	{
		HRESULT hr = pReq->Execute();
		delete pReq;
		return hr;
	}
}

HRESULT CreateURL(WCHAR const * pPath, long lFlags, IUmiURL ** ppUrl)
{
    IUmiURL * pNew = NULL;
    HRESULT hr = CoCreateInstance(CLSID_UmiDefURL, 0, CLSCTX_INPROC_SERVER,
          IID_IUmiURL, (LPVOID *) &pNew);
    if(FAILED(hr))
		return hr;

    hr = pNew->Set(lFlags, pPath);
    if(FAILED(hr))
		return hr;
    *ppUrl = pNew;
    return S_OK;
}

bool Equal(LPCWSTR first, LPCWSTR second, int iLen)
{
	if(first == NULL || second == NULL)
		return false;
	if(wcslen(first) < iLen || wcslen(second) < iLen)
		return false;
	for (int i = 0; i < iLen; i++, first++, second++)
	{
		if(towupper(*first) != towupper(*second))
			return false;
	}
	return true;
}


BOOL GetDSNs(LPCWSTR User, LPCWSTR Password,long lFlags,LPCWSTR NetworkResource, 
			 IWbemServices ** ppProv, HRESULT & sc, IWbemContext *pCtx)
{
	sc = WBEM_E_FAILED;

	// Look at the path, leave if it isnt ds

	if(NetworkResource == NULL || wcslen(NetworkResource) < 4)
		return FALSE;

	IUmiURL * pUrlPath = NULL;

	// Handle either paths starting with UMI: or those that dont

	if(Equal(NetworkResource, L"UMI:", 4))
	{
		sc = CoCreateInstance(CLSID_UmiDefURL, 0, CLSCTX_INPROC_SERVER,
				IID_IUmiURL, (LPVOID *) &pUrlPath);
		if(FAILED(sc))
			return FALSE;

		sc = pUrlPath->Set(0, NetworkResource);
		if(FAILED(sc))
		{
			pUrlPath->Release();
			return FALSE;
		}
	}
	else if(Equal(NetworkResource, L"UMILDAP:", 8) || Equal(NetworkResource, L"UMIWINNT:", 9))
	{
		sc = CoCreateInstance(CLSID_UmiDefURL, 0, CLSCTX_INPROC_SERVER,
				IID_IUmiURL, (LPVOID *) &pUrlPath);
		if(FAILED(sc))
			return FALSE;

		sc = pUrlPath->Set(0x8000, NetworkResource);
		if(FAILED(sc))
		{
			pUrlPath->Release();
			return FALSE;
		}
	}
	else
	{
		IWbemPath *pParser = 0;
		sc = CoCreateInstance(CLSID_WbemDefPath, 0, CLSCTX_INPROC_SERVER,
				IID_IWbemPath, (LPVOID *) &pParser);
		if(FAILED(sc))
			return FALSE;
		CReleaseMe rm2(pParser);
		sc = pParser->SetText(WBEMPATH_CREATE_ACCEPT_ALL, NetworkResource);
		if(FAILED(sc))
			return FALSE;
		sc = pParser->QueryInterface(IID_IUmiURL, (void **)&pUrlPath);
		if(FAILED(sc))
			return FALSE;
	}

	// At this point we have a umi path

	CReleaseMe rm3(pUrlPath);
	CLSID clsid;
	sc = GetProviderCLSID(clsid, pUrlPath);
	if(FAILED(sc))
		return FALSE;

	_IWmiObjectFactory*	pFactory = NULL;
	sc = CoCreateInstance( CLSID__WmiObjectFactory, NULL, CLSCTX_INPROC_SERVER, 
														IID__IWmiObjectFactory, (void**) &pFactory );
	if(FAILED(sc))
		return FALSE;
	CReleaseMe rm11(pFactory);

	// It is, so always return true after this point, the the scode may well be an error
	_IWbemUMIObjectWrapper*	pObjWrapper = NULL;
	sc = pFactory->Create( NULL, 0L, CLSID__WbemUMIObjectWrapper, IID__IWbemUMIObjectWrapper, (void**) &pObjWrapper );
	CReleaseMe	rmWrap( pObjWrapper );

	if ( SUCCEEDED( sc ) )
	{
		sc = pObjWrapper->ConnectToProvider(User, Password, pUrlPath, clsid, pCtx);

		if ( SUCCEEDED( sc ) )
		{
			sc = pObjWrapper->QueryInterface(IID_IWbemServices, (void **)ppProv);
		}
	}

	return ( S_OK == sc );

/*
	CDSSvcExWrapper * pNew = new CDSSvcExWrapper;
	if(pNew == NULL)
	{
		sc = WBEM_E_OUT_OF_MEMORY;
		return TRUE;
	}

	sc = pNew->ConnectToDS(User, Password, pUrlPath, clsid, pCtx);
	if(FAILED(sc))
	{
		delete pNew;
		return TRUE;
	}
	sc = pNew->QueryInterface(IID_IWbemServices, (void **)ppProv);
	if(FAILED(sc))
	{
		delete pNew;
		return TRUE;
	}
	else
		return TRUE;
*/

}

HRESULT GetProviderCLSID(CLSID & clsid, IUmiURL * pUrlPath)
{

	HRESULT hr;
	ULONGLONG uLLProperties;
	hr = pUrlPath->GetPathInfo(0, &uLLProperties);
	if(FAILED(hr))
		return hr;

	if(uLLProperties & UMIPATH_INFO_NATIVE_STRING)
	{
		// the path is native.   In that case, do a hard coded check

		DWORD dwTextSize;
		hr = pUrlPath->Get(0, &dwTextSize, NULL);
		if(FAILED(hr))
			return hr;
		WCHAR * pNew = new WCHAR[dwTextSize];
		if(pNew == NULL)
			return WBEM_E_OUT_OF_MEMORY;
		CDeleteMe<WCHAR> dm(pNew);
		hr = pUrlPath->Get(0, &dwTextSize, pNew);
		if(FAILED(hr))
			return hr;
		if(Equal(pNew, L"UMILDAP:", 8))
		{
			clsid = CLSID_LDAPConnectionObject;
			return S_OK;
		}
			
		else if(Equal(pNew, L"UMIWINNT:", 9))
		{
			clsid = CLSID_WinNTConnectionObject;
			return S_OK;
		}
		else
			return WBEM_E_INVALID_PARAMETER;
	}

	
	// At this point we have a valid umi path

	WCHAR wNamespace[50];
	DWORD dwSize = 50;
    hr = pUrlPath->GetRootNamespace(&dwSize, wNamespace);
	if(FAILED(hr))
		return hr;

	// Determine if it is one of the well know ds namespaces

	if(_wcsicmp(wNamespace, L"WINNT") == 0)
	{
		clsid = CLSID_WinNTConnectionObject;
		return S_OK;
	}	
	else if(_wcsicmp(wNamespace, L"LDAP") == 0)
	{	
		clsid = CLSID_LDAPConnectionObject;
		return S_OK;
	}
	return WBEM_E_INVALID_PARAMETER;
}


DWORD WINAPI LaunchExecuteThreadRoutine(LPVOID lpParameter)
{
	ComThreadInit ci(true);
    CRequest * pReq = (CRequest *)lpParameter;
	HRESULT hr = pReq->Execute();
	if(pReq->m_pSink)
		pReq->m_pSink->SetStatus(0, hr, 0, 0);
	else if(pReq->m_pCallRes && pReq->m_bAsync)
	{
		pReq->m_pCallRes->SetHRESULT(hr);
	}

	delete pReq;
    return 0;
}




HRESULT SetResultCode(IWbemCallResult** ppResult, HRESULT hr)
{

	CDSCallResult * pRes = new CDSCallResult();
	if(pRes == NULL)
		return WBEM_E_OUT_OF_MEMORY;
	else
	{
		*ppResult = pRes;
		pRes->SetHRESULT(hr);
		return S_OK;
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\sinkwrap.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    SinkWrap.H

Abstract:

    Declares the classes needed to wrap IWbemObjectSink objects

History:

--*/

#ifndef __SINKWRAP_H
#define __SINKWRAP_H

class CSinkWrap : public IWbemObjectSinkEx
{
protected:
    long m_lRef;
	bool m_bCanceled;
	bool m_bFinished;
	IWbemObjectSinkEx * m_pActualSink;
	IWbemClientConnectionTransport * m_pIWbemClientConnectionTransport;
	IWbemConnection * m_pIWbemConnection;

public:
    STDMETHOD_(ULONG, AddRef)() {return InterlockedIncrement(&m_lRef);}
    STDMETHOD_(ULONG, Release)()
    {
        long lRef = InterlockedDecrement(&m_lRef);
        if(lRef == 0)
            delete this;
        return lRef;
    }
    STDMETHOD(QueryInterface)(REFIID riid, void** ppv);


	// IWbemObjectSink functions

    HRESULT STDMETHODCALLTYPE Indicate( 
            /* [in] */ long lObjectCount,
            /* [size_is][in] */ IWbemClassObject __RPC_FAR *__RPC_FAR *apObjArray);
        
    HRESULT STDMETHODCALLTYPE SetStatus( 
            /* [in] */ long lFlags,
            /* [in] */ HRESULT hResult,
            /* [in] */ BSTR strParam,
            /* [in] */ IWbemClassObject __RPC_FAR *pObjParam);
        
	// IWbemObjectSinkEx functions

    HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ long lFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][in] */ void __RPC_FAR *pComObject);


public:
    CSinkWrap(IWbemObjectSinkEx * pActualSink);
    ~CSinkWrap();
	HRESULT SetIWbemClientConnectionTransport(IWbemClientConnectionTransport * pClientConnTran);
	HRESULT SetIWbemConnection(IWbemConnection * pConnection);
	void ReleaseTransportPointers();
	void CancelIfOriginalSinkMatches(IWbemObjectSinkEx * pOrigSink);
};

class CSinkCollection
{
protected:
	CFlexArray m_ActiveSinks;
public:
	CSinkCollection();
	~CSinkCollection();

	CRITICAL_SECTION m_cs;
	HRESULT CancelCallsForSink(IWbemObjectSinkEx * pOrigSink);
	HRESULT AddToList(CSinkWrap * pAdd);
	void RemoveFromList(CSinkWrap * pRemove);
};

extern CSinkCollection g_SinkCollection;

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\marshalers\wbemprox\utils.h ===
/*++

Copyright (C) 2000-2001 Microsoft Corporation

Module Name:

    UTILS.H

Abstract:

    various helper functions used by the ds wrapper

History:

	davj  14-Mar-00   Created.

--*/

#ifndef __UTILS_H__
#define __UTILS_H__

#include <unk.h>
#include <wbemidl.h>
#include <wbemint.h>
#include <wbemcomn.h>


HRESULT AllocateCallResult(IWbemCallResult** ppResult, CDSCallResult ** ppCallRes);

HRESULT AllocateCallResultEx(IWbemCallResultEx** ppResult, CDSCallResult ** ppCallRes);

DWORD WINAPI CreateEnumThreadRoutine(LPVOID lpParameter);

HRESULT CreateThreadOrCallDirectly(bool bAsync, CRequest * pReq);

HRESULT CreateURL(WCHAR const * pPath, long lFlags, IUmiURL **);

bool Equal(LPCWSTR first, LPCWSTR second, int iLen);

BOOL GetDSNs(LPCWSTR User, LPCWSTR Password,long lFlags,LPCWSTR NetworkResource, 
			 IWbemServices ** ppProv, HRESULT & scRet, IWbemContext *pCtx);

HRESULT GetProviderCLSID(CLSID & clsid, IUmiURL * pUrlPath);

DWORD WINAPI LaunchExecuteThreadRoutine(LPVOID lpParameter);

HRESULT SetResultCode(IWbemCallResult** ppResult, HRESULT hr);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\minimfc\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\minimfc\array_p.cpp ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    ARRAY_P.CPP

Abstract:

History:

--*/


// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized Array
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.


#include "precomp.h"

#define ASSERT_VALID(x)
#define ASSERT(x)


/////////////////////////////////////////////////////////////////////////////

CPtrArray::CPtrArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CPtrArray::~CPtrArray()
{
    ASSERT_VALID(this);

    delete (BYTE*) m_pData;
}

BOOL CPtrArray::SetSize(int nNewSize, int nGrowBy /* = -1 */)
{
    ASSERT_VALID(this);
    ASSERT(nNewSize >= 0);

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        delete (BYTE *) m_pData;
        m_pData = NULL;
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        ASSERT((long)nNewSize * sizeof(void*) <= SIZE_T_MAX);  // no overflow
#endif
        m_pData = (void**) new BYTE[nNewSize * sizeof(void*)];
        if(m_pData == NULL)
            return FALSE;

        memset(m_pData, 0, nNewSize * sizeof(void*));  // zero fill

        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*));

        }

        m_nSize = nNewSize;
    }
    else
    {
        // Otherwise grow array
        int nNewMax;
        if (nNewSize < m_nMaxSize + m_nGrowBy)
            nNewMax = m_nMaxSize + m_nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

#ifdef SIZE_T_MAX
        ASSERT((long)nNewMax * sizeof(void*) <= SIZE_T_MAX);  // no overflow
#endif
        void** pNewData = (void**) new BYTE[nNewMax * sizeof(void*)];
        if(pNewData == NULL)
            return FALSE;

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(void*));

        // construct remaining elements
        ASSERT(nNewSize > m_nSize);

        memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(void*));


        // get rid of old stuff (note: no destructors called)
        delete (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
    return TRUE;
}

void CPtrArray::FreeExtra()
{
    ASSERT_VALID(this);

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        ASSERT((long)m_nSize * sizeof(void*) <= SIZE_T_MAX);  // no overflow
#endif
        void** pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (void**) new BYTE[m_nSize * sizeof(void*)];
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(void*));
        }

        // get rid of old stuff (note: no destructors called)
        delete (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

/////////////////////////////////////////////////////////////////////////////

BOOL CPtrArray::SetAtGrow(int nIndex, void* newElement)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);

    if (nIndex >= m_nSize)
    {
        if(!SetSize(nIndex+1))
            return FALSE;
    }
    m_pData[nIndex] = newElement;
    return TRUE;
}

void CPtrArray::InsertAt(int nIndex, void* newElement, int nCount /*=1*/)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);    // will expand to meet need
    ASSERT(nCount > 0);     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount);  // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(void*));

        // re-init slots we copied from

        memset(&m_pData[nIndex], 0, nCount * sizeof(void*));

    }

    // insert new value in the gap
    ASSERT(nIndex + nCount <= m_nSize);
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

void CPtrArray::RemoveAt(int nIndex, int nCount /* = 1 */)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);
    ASSERT(nCount >= 0);
    ASSERT(nIndex + nCount <= m_nSize);

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);

    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(void*));
    m_nSize -= nCount;
}

void CPtrArray::InsertAt(int nStartIndex, CPtrArray* pNewArray)
{
    ASSERT_VALID(this);
    ASSERT(pNewArray != NULL);
    ASSERT(pNewArray->IsKindOf(RUNTIME_CLASS(CPtrArray)));
    ASSERT_VALID(pNewArray);
    ASSERT(nStartIndex >= 0);

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}

/////////////////////////////////////////////////////////////////////////////
// Serialization


/////////////////////////////////////////////////////////////////////////////
// Diagnostics

/* 
#ifdef _DEBUG
void CPtrArray::Dump(CDumpContext& dc) const
{
    ASSERT_VALID(this);

#define MAKESTRING(x) #x
    AFX_DUMP1(dc, "a " MAKESTRING(CPtrArray) " with ", m_nSize);
    AFX_DUMP0(dc, " elements");
#undef MAKESTRING
    if (dc.GetDepth() > 0)
    {
        AFX_DUMP0(dc, "\n");
        for (int i = 0; i < m_nSize; i++)
        {
            AFX_DUMP1(dc, "\n\t[", i);
            AFX_DUMP1(dc, "] = ", m_pData[i]);
        }
    }
}

void CPtrArray::AssertValid() const
{
    CObject::AssertValid();
    if (m_pData == NULL)
    {
        ASSERT(m_nSize == 0);
        ASSERT(m_nMaxSize == 0);
    }
    else
    {
        ASSERT(m_nSize >= 0);
        ASSERT(m_nMaxSize >= 0);
        ASSERT(m_nSize <= m_nMaxSize);
        ASSERT(AfxIsValidAddress(m_pData, m_nMaxSize * sizeof(void*)));
    }
}
#endif //_DEBUG
*/
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\minimfc\array_w.cpp ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    ARRAY_W.CPP

Abstract:

History:

--*/


// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized Array
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.

#include "precomp.h"

#define ASSERT(x)
#define ASSERT_VALID(x)



/////////////////////////////////////////////////////////////////////////////

CWordArray::CWordArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CWordArray::~CWordArray()
{
    ASSERT_VALID(this);

    delete (BYTE*)m_pData;
}

void CWordArray::SetSize(int nNewSize, int nGrowBy /* = -1 */)
{
    ASSERT_VALID(this);
    ASSERT(nNewSize >= 0);

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        delete (BYTE*)m_pData;
        m_pData = NULL;
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        ASSERT((long)nNewSize * sizeof(WORD) <= SIZE_T_MAX);  // no overflow
#endif
        m_pData = (WORD*) new BYTE[nNewSize * sizeof(WORD)];

        memset(m_pData, 0, nNewSize * sizeof(WORD));  // zero fill

        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(WORD));

        }

        m_nSize = nNewSize;
    }
    else
    {
        // Otherwise grow array
        int nNewMax;
        if (nNewSize < m_nMaxSize + m_nGrowBy)
            nNewMax = m_nMaxSize + m_nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

#ifdef SIZE_T_MAX
        ASSERT((long)nNewMax * sizeof(WORD) <= SIZE_T_MAX);  // no overflow
#endif
        WORD* pNewData = (WORD*) new BYTE[nNewMax * sizeof(WORD)];

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(WORD));

        // construct remaining elements
        ASSERT(nNewSize > m_nSize);

        memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(WORD));


        // get rid of old stuff (note: no destructors called)
        delete (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

void CWordArray::FreeExtra()
{
    ASSERT_VALID(this);

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        ASSERT((long)m_nSize * sizeof(WORD) <= SIZE_T_MAX);  // no overflow
#endif
        WORD* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (WORD*) new BYTE[m_nSize * sizeof(WORD)];
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(WORD));
        }

        // get rid of old stuff (note: no destructors called)
        delete (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

/////////////////////////////////////////////////////////////////////////////

void CWordArray::SetAtGrow(int nIndex, WORD newElement)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);

    if (nIndex >= m_nSize)
        SetSize(nIndex+1);
    m_pData[nIndex] = newElement;
}

void CWordArray::InsertAt(int nIndex, WORD newElement, int nCount /*=1*/)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);    // will expand to meet need
    ASSERT(nCount > 0);     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount);  // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(WORD));

        // re-init slots we copied from

        memset(&m_pData[nIndex], 0, nCount * sizeof(WORD));

    }

    // insert new value in the gap
    ASSERT(nIndex + nCount <= m_nSize);
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

void CWordArray::RemoveAt(int nIndex, int nCount /* = 1 */)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);
    ASSERT(nCount >= 0);
    ASSERT(nIndex + nCount <= m_nSize);

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);

    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(WORD));
    m_nSize -= nCount;
}

void CWordArray::InsertAt(int nStartIndex, CWordArray* pNewArray)
{
    ASSERT_VALID(this);
    ASSERT(pNewArray != NULL);
    ASSERT(pNewArray->IsKindOf(RUNTIME_CLASS(CWordArray)));
    ASSERT_VALID(pNewArray);
    ASSERT(nStartIndex >= 0);

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\minimfc\array_s.cpp ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    ARRAY_S.CPP

Abstract:

History:

--*/


// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

/////////////////////////////////////////////////////////////////////////////
//
// Implementation of parameterized Array
//
/////////////////////////////////////////////////////////////////////////////
// NOTE: we allocate an array of 'm_nMaxSize' elements, but only
//  the current size 'm_nSize' contains properly constructed
//  objects.


#include "precomp.h"

#define ASSERT_VALID(x)
#define ASSERT(x)


#include "elements.h"  // used for special creation

static void  ConstructElements(CString* pNewData, int nCount)
{
    ASSERT(nCount >= 0);

    while (nCount--)
    {
        ConstructElement(pNewData);
        pNewData++;
    }
}

static void  DestructElements(CString* pOldData, int nCount)
{
    ASSERT(nCount >= 0);

    while (nCount--)
    {
        pOldData->Empty();
        pOldData++;
    }
}

/////////////////////////////////////////////////////////////////////////////

CStringArray::CStringArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CStringArray::~CStringArray()
{
    ASSERT_VALID(this);


    DestructElements(m_pData, m_nSize);
    delete (BYTE*)m_pData;
}

void CStringArray::SetSize(int nNewSize, int nGrowBy /* = -1 */)
{
    ASSERT_VALID(this);
    ASSERT(nNewSize >= 0);

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing

        DestructElements(m_pData, m_nSize);
        delete (BYTE*)m_pData;
        m_pData = NULL;
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        ASSERT((long)nNewSize * sizeof(CString) <= SIZE_T_MAX);  // no overflow
#endif
        m_pData = (CString*) new BYTE[nNewSize * sizeof(CString)];

        ConstructElements(m_pData, nNewSize);

        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            ConstructElements(&m_pData[m_nSize], nNewSize-m_nSize);

        }

        else if (m_nSize > nNewSize)  // destroy the old elements
            DestructElements(&m_pData[nNewSize], m_nSize-nNewSize);

        m_nSize = nNewSize;
    }
    else
    {
        // Otherwise grow array
        int nNewMax;
        if (nNewSize < m_nMaxSize + m_nGrowBy)
            nNewMax = m_nMaxSize + m_nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

#ifdef SIZE_T_MAX
        ASSERT((long)nNewMax * sizeof(CString) <= SIZE_T_MAX);  // no overflow
#endif
        CString* pNewData = (CString*) new BYTE[nNewMax * sizeof(CString)];

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(CString));

        // construct remaining elements
        ASSERT(nNewSize > m_nSize);

        ConstructElements(&pNewData[m_nSize], nNewSize-m_nSize);


        // get rid of old stuff (note: no destructors called)
        delete (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

void CStringArray::FreeExtra()
{
    ASSERT_VALID(this);

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        ASSERT((long)m_nSize * sizeof(CString) <= SIZE_T_MAX);  // no overflow
#endif
        CString* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (CString*) new BYTE[m_nSize * sizeof(CString)];
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(CString));
        }

        // get rid of old stuff (note: no destructors called)
        delete (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

/////////////////////////////////////////////////////////////////////////////

void CStringArray::SetAtGrow(int nIndex, const char* newElement)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);

    if (nIndex >= m_nSize)
        SetSize(nIndex+1);
    m_pData[nIndex] = newElement;
}

void CStringArray::InsertAt(int nIndex, const char* newElement, int nCount /*=1*/)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);    // will expand to meet need
    ASSERT(nCount > 0);     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount);  // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(CString));

        // re-init slots we copied from

        ConstructElements(&m_pData[nIndex], nCount);

    }

    // insert new value in the gap
    ASSERT(nIndex + nCount <= m_nSize);
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

void CStringArray::RemoveAt(int nIndex, int nCount /* = 1 */)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);
    ASSERT(nCount >= 0);
    ASSERT(nIndex + nCount <= m_nSize);

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);

    DestructElements(&m_pData[nIndex], nCount);

    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(CString));
    m_nSize -= nCount;
}

void CStringArray::InsertAt(int nStartIndex, CStringArray* pNewArray)
{
    ASSERT_VALID(this);
    ASSERT(pNewArray != NULL);
    ASSERT(pNewArray->IsKindOf(RUNTIME_CLASS(CStringArray)));
    ASSERT_VALID(pNewArray);
    ASSERT(nStartIndex >= 0);

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\minimfc\array_d.cpp ===
/*++

Copyright (C) 1994-2001 Microsoft Corporation

Module Name:

    ARRAY_D.CPP

Abstract:

    MiniAFX implementation.  09/25/94 TSE.

History:

--*/


#include "precomp.h"

#define ASSERT(x)
#define ASSERT_VALID(x)


/////////////////////////////////////////////////////////////////////////////

CDWordArray::CDWordArray()
{
    m_pData = NULL;
    m_nSize = m_nMaxSize = m_nGrowBy = 0;
}

CDWordArray::~CDWordArray()
{
    ASSERT_VALID(this);

    delete (BYTE*)m_pData;
}

void CDWordArray::SetSize(int nNewSize, int nGrowBy /* = -1 */)
{
    ASSERT_VALID(this);
    ASSERT(nNewSize >= 0);

    if (nGrowBy != -1)
        m_nGrowBy = nGrowBy;  // set new size

    if (nNewSize == 0)
    {
        // shrink to nothing
        delete (BYTE*)m_pData;
        m_pData = NULL;
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        // create one with exact size
#ifdef SIZE_T_MAX
        ASSERT((long)nNewSize * sizeof(DWORD) <= SIZE_T_MAX);  // no overflow
#endif
        m_pData = (DWORD*) new BYTE[nNewSize * sizeof(DWORD)];

        memset(m_pData, 0, nNewSize * sizeof(DWORD));  // zero fill

        m_nSize = m_nMaxSize = nNewSize;
    }
    else if (nNewSize <= m_nMaxSize)
    {
        // it fits
        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            memset(&m_pData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(DWORD));

        }

        m_nSize = nNewSize;
    }
    else
    {
        // Otherwise grow array
        int nNewMax;
        if (nNewSize < m_nMaxSize + m_nGrowBy)
            nNewMax = m_nMaxSize + m_nGrowBy;  // granularity
        else
            nNewMax = nNewSize;  // no slush

#ifdef SIZE_T_MAX
        ASSERT((long)nNewMax * sizeof(DWORD) <= SIZE_T_MAX);  // no overflow
#endif
        DWORD* pNewData = (DWORD*) new BYTE[nNewMax * sizeof(DWORD)];

        // copy new data from old
        memcpy(pNewData, m_pData, m_nSize * sizeof(DWORD));

        // construct remaining elements
        ASSERT(nNewSize > m_nSize);

        memset(&pNewData[m_nSize], 0, (nNewSize-m_nSize) * sizeof(DWORD));


        // get rid of old stuff (note: no destructors called)
        delete (BYTE*)m_pData;
        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }
}

void CDWordArray::FreeExtra()
{
    ASSERT_VALID(this);

    if (m_nSize != m_nMaxSize)
    {
        // shrink to desired size
#ifdef SIZE_T_MAX
        ASSERT((long)m_nSize * sizeof(DWORD) <= SIZE_T_MAX);  // no overflow
#endif
        DWORD* pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (DWORD*) new BYTE[m_nSize * sizeof(DWORD)];
            // copy new data from old
            memcpy(pNewData, m_pData, m_nSize * sizeof(DWORD));
        }

        // get rid of old stuff (note: no destructors called)
        delete (BYTE*)m_pData;
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }
}

/////////////////////////////////////////////////////////////////////////////

void CDWordArray::SetAtGrow(int nIndex, DWORD newElement)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);

    if (nIndex >= m_nSize)
        SetSize(nIndex+1);
    m_pData[nIndex] = newElement;
}

void CDWordArray::InsertAt(int nIndex, DWORD newElement, int nCount /*=1*/)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);    // will expand to meet need
    ASSERT(nCount > 0);     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        // adding after the end of the array
        SetSize(nIndex + nCount);  // grow so nIndex is valid
    }
    else
    {
        // inserting in the middle of the array
        int nOldSize = m_nSize;
        SetSize(m_nSize + nCount);  // grow it to new size
        // shift old data up to fill gap
        memmove(&m_pData[nIndex+nCount], &m_pData[nIndex],
            (nOldSize-nIndex) * sizeof(DWORD));

        // re-init slots we copied from

        memset(&m_pData[nIndex], 0, nCount * sizeof(DWORD));

    }

    // insert new value in the gap
    ASSERT(nIndex + nCount <= m_nSize);
    while (nCount--)
        m_pData[nIndex++] = newElement;
}

void CDWordArray::RemoveAt(int nIndex, int nCount /* = 1 */)
{
    ASSERT_VALID(this);
    ASSERT(nIndex >= 0);
    ASSERT(nCount >= 0);
    ASSERT(nIndex + nCount <= m_nSize);

    // just remove a range
    int nMoveCount = m_nSize - (nIndex + nCount);

    if (nMoveCount)
        memcpy(&m_pData[nIndex], &m_pData[nIndex + nCount],
            nMoveCount * sizeof(DWORD));
    m_nSize -= nCount;
}

void CDWordArray::InsertAt(int nStartIndex, CDWordArray* pNewArray)
{
    ASSERT_VALID(this);
    ASSERT(pNewArray != NULL);
    ASSERT(pNewArray->IsKindOf(RUNTIME_CLASS(CDWordArray)));
    ASSERT_VALID(pNewArray);
    ASSERT(nStartIndex >= 0);

    if (pNewArray->GetSize() > 0)
    {
        InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize());
        for (int i = 0; i < pNewArray->GetSize(); i++)
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\minimfc\elements.h ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    ELEMENTS.H

Abstract:

History:

--*/

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

// Collection implementation helpers

/*
* The short story:
*   this file contains inline functions that make up the building blocks
*   for implementing the string versions of standard parameterized
*   collection shapes
*
* The long story:
*   Because the implementation of collection classes moves objects around
*   in various ways, it is very inefficient to use only generic C++ constructs.
*   For example, in order to grow an array of FOO objects by one element,
*   you would be forced to allocate a new array of appropriate size, calling
*   the FOO constructor on every element.  Then copy the original array, element
*   by element using a possibly overloaded assignment operator.  Finally destroy
*   the original array element by element.
*   For built-in data types (WORD, DWORD, pointer types), this is complete
*   overkill.  For non-trivial classes (eg: CString in particular) this is
*   a terrible implementation.
*
*   The bottom line: we have to special routines for doing construction
*   and destruction of arrays of special elements - in particular CStrings.
*   The standard templates are parameterized on 'HAS_CREATE' which is
*   non-zero if the collection implementation requires a special
*   construct and destruct function.
*
*   Please note that these are inline overloaded operators, and do not have
*   any form of runtime polymorphism (i.e. nothing is 'virtual').
*/

/////////////////////////////////////////////////////////////////////////////
// Special implementations for CStrings
// it is faster to bit-wise copy a CString than to call an official
//   constructor - since an empty CString can be bit-wise copied

extern const CString afxEmptyString;

static inline void ConstructElement(CString* pNewData)
{
	memcpy(pNewData, &afxEmptyString, sizeof(CString));
}

static inline void DestructElement(CString* pOldData)
{
	pOldData->Empty();
}

/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\minimfc\plex.h ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    PLEX.H

Abstract:

History:

--*/

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#ifndef __PLEX_H__
#define __PLEX_H__

struct CPlex    // warning variable length structure
{
	CPlex* pNext;
	UINT nMax;
	UINT nCur;
	/* BYTE data[maxNum*elementSize]; */

	void* data() { return this+1; }

	static CPlex* Create(CPlex*& head, UINT nMax, UINT cbElement);
			// like 'calloc' but no zero fill
			// may throw memory exceptions

	void FreeDataChain();       // free this one and links
};


#endif //__PLEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\minimfc\plex.cpp ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    PLEX.CPP

Abstract:

History:

--*/

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"

#define ASSERT(x)
#define ASSERT_VALID(x)

#include "plex.h"


CPlex* CPlex::Create(CPlex*& pHead, UINT nMax, UINT cbElement)
{
    ASSERT(nMax > 0 && cbElement > 0);
    CPlex* p = (CPlex*) new BYTE[sizeof(CPlex) + nMax * cbElement];
            // may throw exception
    p->nMax = nMax;
    p->nCur = 0;
    p->pNext = pHead;
    pHead = p;  // change head (adds in reverse order for simplicity)
    return p;
}

void CPlex::FreeDataChain()     // free this one and links
{
    CPlex* p = this;
    while (p != NULL)
    {
        BYTE* bytes = (BYTE*) p;
        CPlex* pNext = p->pNext;
        delete bytes;
        p = pNext;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\minimfc\strcore1.cpp ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    STRCORE1.CPP

Abstract:

History:

--*/

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.

#include "precomp.h"

#define ASSERT(x)
#define ASSERT_VALID(x)



/////////////////////////////////////////////////////////////////////////////
// static class data, special inlines

char  _afxChNil = '\0';

// For an empty string, m_???Data will point here
// (note: avoids a lot of NULL pointer tests when we call standard
//  C runtime libraries

extern const CString  afxEmptyString;
        // for creating empty key strings
const CString  afxEmptyString;

void CString::Init()
{
    m_nDataLength = m_nAllocLength = 0;
    m_pchData = (char*)&_afxChNil;
}

// declared static
void CString::SafeDelete(char* pch)
{
    if (pch != (char*)&_afxChNil)
        delete pch;
}

//////////////////////////////////////////////////////////////////////////////
// Construction/Destruction

CString::CString()
{
    Init();
}

CString::CString(const CString& stringSrc)
{
    // if constructing a CString from another CString, we make a copy of the
    // original string data to enforce value semantics (i.e. each string
    // gets a copy of its own

    stringSrc.AllocCopy(*this, stringSrc.m_nDataLength, 0, 0);
}

void CString::AllocBuffer(int nLen)
 // always allocate one extra character for '\0' termination
 // assumes [optimistically] that data length will equal allocation length
{
    ASSERT(nLen >= 0);
    ASSERT(nLen <= INT_MAX - 1);    // max size (enough room for 1 extra)

    if (nLen == 0)
    {
        Init();
    }
    else
    {
        m_pchData = new char[nLen+1];       // may throw an exception
        m_pchData[nLen] = '\0';
        m_nDataLength = nLen;
        m_nAllocLength = nLen;
    }
}

void CString::Empty()
{
    SafeDelete(m_pchData);
    Init();
    ASSERT(m_nDataLength == 0);
    ASSERT(m_nAllocLength == 0);
}

CString::~CString()
 //  free any attached data
{
    SafeDelete(m_pchData);
}

//////////////////////////////////////////////////////////////////////////////
// Helpers for the rest of the implementation

void CString::AllocCopy(CString& dest, int nCopyLen, int nCopyIndex,
     int nExtraLen) const
{
    // will clone the data attached to this string
    // allocating 'nExtraLen' characters
    // Places results in uninitialized string 'dest'
    // Will copy the part or all of original data to start of new string

    int nNewLen = nCopyLen + nExtraLen;

    if (nNewLen == 0)
    {
        dest.Init();
    }
    else
    {
        dest.AllocBuffer(nNewLen);
        memcpy(dest.m_pchData, &m_pchData[nCopyIndex], nCopyLen);
    }
}

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(const char* psz)
{
    int nLen;
    if ((nLen = strlen(psz)) == 0)
        Init();
    else
    {
        AllocBuffer(nLen);
        memcpy(m_pchData, psz, nLen);
    }
}

//////////////////////////////////////////////////////////////////////////////
// Diagnostic support
/*
#ifdef _DEBUG
CDumpContext&  operator <<(CDumpContext& dc, const CString& string)
{
    dc << string.m_pchData;
    return dc;
}
#endif //_DEBUG
*/
//////////////////////////////////////////////////////////////////////////////
// Assignment operators
//  All assign a new value to the string
//      (a) first see if the buffer is big enough
//      (b) if enough room, copy on top of old buffer, set size and type
//      (c) otherwise free old string data, and create a new one
//
//  All routines return the new string (but as a 'const CString&' so that
//      assigning it again will cause a copy, eg: s1 = s2 = "hi there".
//

void CString::AssignCopy(int nSrcLen, const char* pszSrcData)
{
    // check if it will fit
    if (nSrcLen > m_nAllocLength)
    {
        // it won't fit, allocate another one
        Empty();
        AllocBuffer(nSrcLen);
    }
    if (nSrcLen != 0)
        memcpy(m_pchData, pszSrcData, nSrcLen);
    m_nDataLength = nSrcLen;
    m_pchData[nSrcLen] = '\0';
}

const CString& CString::operator =(const CString& stringSrc)
{
    AssignCopy(stringSrc.m_nDataLength, stringSrc.m_pchData);
    return *this;
}

const CString& CString::operator =(const char* psz)
{
    AssignCopy(strlen(psz), psz);
    return *this;
}


//////////////////////////////////////////////////////////////////////////////
// concatenation

// NOTE: "operator +" is done as friend functions for simplicity
//      There are three variants:
//          CString + CString
// and for ? = char, const char*
//          CString + ?
//          ? + CString

void CString::ConcatCopy(int nSrc1Len, const char* pszSrc1Data,
        int nSrc2Len, const char* pszSrc2Data)
{
  // -- master concatenation routine
  // Concatenate two sources
  // -- assume that 'this' is a new CString object

    int nNewLen = nSrc1Len + nSrc2Len;
    AllocBuffer(nNewLen);
    memcpy(m_pchData, pszSrc1Data, nSrc1Len);
    memcpy(&m_pchData[nSrc1Len], pszSrc2Data, nSrc2Len);
}

CString  operator +(const CString& string1, const CString& string2)
{
    CString s;
    s.ConcatCopy(string1.m_nDataLength, string1.m_pchData,
        string2.m_nDataLength, string2.m_pchData);
    return s;
}

CString  operator +(const CString& string, const char* psz)
{
    CString s;
    s.ConcatCopy(string.m_nDataLength, string.m_pchData, strlen(psz), psz);
    return s;
}


CString  operator +(const char* psz, const CString& string)
{
    CString s;
    s.ConcatCopy(strlen(psz), psz, string.m_nDataLength, string.m_pchData);
    return s;
}

///////////////////////////////////////////////////////////////////////////////
// Advanced direct buffer access

char* CString::GetBuffer(int nMinBufLength)
{
    ASSERT(nMinBufLength >= 0);

    if (nMinBufLength > m_nAllocLength)
    {
        // we have to grow the buffer
        char* pszOldData = m_pchData;
        int nOldLen = m_nDataLength;        // AllocBuffer will tromp it

        AllocBuffer(nMinBufLength);
        memcpy(m_pchData, pszOldData, nOldLen);
        m_nDataLength = nOldLen;
        m_pchData[m_nDataLength] = '\0';

        SafeDelete(pszOldData);
    }

    // return a pointer to the character storage for this string
    ASSERT(m_pchData != NULL);
    return m_pchData;
}

void CString::ReleaseBuffer(int nNewLength)
{
    if (nNewLength == -1)
        nNewLength = strlen(m_pchData); // zero terminated

    ASSERT(nNewLength <= m_nAllocLength);
    m_nDataLength = nNewLength;
    m_pchData[m_nDataLength] = '\0';
}

char* CString::GetBufferSetLength(int nNewLength)
{
    ASSERT(nNewLength >= 0);

    GetBuffer(nNewLength);
    m_nDataLength = nNewLength;
    m_pchData[m_nDataLength] = '\0';
    return m_pchData;
}

///////////////////////////////////////////////////////////////////////////////
// Commonly used routines (rarely used routines in STREX.CPP)

int CString::Find(char ch) const
{
    // find first single character
    char* psz;
#ifdef _WINDOWS
    if (afxData.bDBCS)
    {
        LPSTR lpsz = _AfxStrChr(m_pchData, ch);
        return (lpsz == NULL) ? -1
            : (int)((char*)_AfxGetPtrFromFarPtr(lpsz) - m_pchData);
    }
    else
#endif
        psz = strchr(m_pchData, ch);

    // return -1 if not found and index otherwise
    return (psz == NULL) ? -1 : (int)(psz - m_pchData);
}

int CString::FindOneOf(const char* pszCharSet) const
{
    ASSERT(pszCharSet != NULL);
#ifdef _WINDOWS
    if (afxData.bDBCS)
    {
        for (char* psz = m_pchData; *psz != '\0'; psz = _AfxAnsiNext(psz))
        {
            for (const char* pch = pszCharSet; *pch != '\0'; pch = _AfxAnsiNext(pch))
            {
                if (*psz == *pch &&     // Match SBC or Lead byte
                   (!_AfxIsDBCSLeadByte(*psz) || psz[1] == pch[1]))
                {
                    return (int)(psz - m_pchData);
                }
            }
        }
        return -1;  // not found
    }
    else
#endif
    {
        char* psz = (char*) strpbrk(m_pchData, pszCharSet);
        return (psz == NULL) ? -1 : (int)(psz - m_pchData);
    }
}

///////////////////////////////////////////////////////////////////////////////
// Additional constructors for far string data

#ifdef _DATA
CString::CString(LPCSTR lpsz)
{
    int nLen;
    if (lpsz == NULL || (nLen = lstrlen(lpsz)) == 0)
    {
        Init();
    }
    else
    {
        AllocBuffer(nLen);
        _fmemcpy(m_pchData, lpsz, nLen);
    }
}
#endif //_DATA
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\minimfc\miniafx.h ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    MINIAFX.H

Abstract:

History:

--*/


///////////////////////////////////////////////////////////////////////////
//
//  MINIAFX.H
//
//  MFC Subset declarations.
//
//  CString, CWordArray, CDWordArray, CPtrArray, CStringArray, CPtrList
//
//  09/25/94    TSE
//
///////////////////////////////////////////////////////////////////////////

#ifndef _MINIAFX_H_
#define _MINIAFX_H_

#include <stdio.h>
#include <string.h>


typedef void*      POSITION;   // abstract iteration position

#ifndef DWORD
  typedef unsigned char  BYTE;   // 8-bit unsigned entity
  typedef unsigned short WORD;   // 16-bit unsigned number
  typedef unsigned int   UINT;   // machine sized unsigned number (preferred)
  typedef long           LONG;   // 32-bit signed number
  typedef unsigned long  DWORD;  // 32-bit unsigned number
  typedef int            BOOL;   // BOOLean (0 or !=0)
  typedef char *      LPSTR;  // far pointer to a string
  typedef const char * LPCSTR; // far pointer to a read-only string
#endif

#ifndef NULL
#define NULL 0
#endif

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif



////////////////////////////////////////////////////////////////////////////

class CString
{
public:

// Constructors
	CString();
	CString(const CString& stringSrc);
	CString(char ch, int nRepeat = 1);
	CString(const char* psz);
	CString(const char* pch, int nLength);
   ~CString();

// Attributes & Operations

	// as an array of characters
	int GetLength() const { return m_nDataLength; }

	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	char GetAt(int nIndex) const;       // 0 based
	char operator[](int nIndex) const;  // same as GetAt
	void SetAt(int nIndex, char ch);
	operator const char*() const       // as a C string
	{ return (const char*)m_pchData; }

	// overloaded assignment
	const CString& operator=(const CString& stringSrc);
	const CString& operator=(char ch);
	const CString& operator=(const char* psz);

	// string concatenation
	const CString& operator+=(const CString& string);
	const CString& operator+=(char ch);
	const CString& operator+=(const char* psz);

	friend CString  operator+(const CString& string1,
			const CString& string2);
	friend CString  operator+(const CString& string, char ch);
	friend CString  operator+(char ch, const CString& string);
	friend CString  operator+(const CString& string, const char* psz);
	friend CString  operator+(const char* psz, const CString& string);

	// string comparison
	int Compare(const char* psz) const;         // straight character
	int CompareNoCase(const char* psz) const;   // ignore case
	int Collate(const char* psz) const;         // NLS aware

	// simple sub-string extraction
	CString Mid(int nFirst, int nCount) const;
	CString Mid(int nFirst) const;
	CString Left(int nCount) const;
	CString Right(int nCount) const;

	CString SpanIncluding(const char* pszCharSet) const;
	CString SpanExcluding(const char* pszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(char ch) const;                    // like "C" strchr
	int ReverseFind(char ch) const;
	int FindOneOf(const char* pszCharSet) const;

	// look for a specific sub-string
	int Find(const char* pszSub) const;         // like "C" strstr

	// Windows support

#ifdef _WINDOWS
	BOOL LoadString(UINT nID);          // load from string resource
										// 255 chars max
	// ANSI<->OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();
#endif //_WINDOWS

	// Access to string implementation buffer as "C" character array
	char* GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	char* GetBufferSetLength(int nNewLength);

// Implementation
public:
	int GetAllocLength() const;
protected:
	// lengths/sizes in characters
	//  (note: an extra character is always allocated)
	char* m_pchData;            // actual string (zero terminated)
	int m_nDataLength;          // does not include terminating 0
	int m_nAllocLength;         // does not include terminating 0

	// implementation helpers
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, const char* pszSrcData);
	void ConcatCopy(int nSrc1Len, const char* pszSrc1Data, int nSrc2Len, const char* pszSrc2Data);
	void ConcatInPlace(int nSrcLen, const char* pszSrcData);
	static void SafeDelete(char* pch);
	static int SafeStrlen(const char* psz);
};


// Compare helpers
BOOL  operator==(const CString& s1, const CString& s2);
BOOL  operator==(const CString& s1, const char* s2);
BOOL  operator==(const char* s1, const CString& s2);
BOOL  operator!=(const CString& s1, const CString& s2);
BOOL  operator!=(const CString& s1, const char* s2);
BOOL  operator!=(const char* s1, const CString& s2);
BOOL  operator<(const CString& s1, const CString& s2);
BOOL  operator<(const CString& s1, const char* s2);
BOOL  operator<(const char* s1, const CString& s2);
BOOL  operator>(const CString& s1, const CString& s2);
BOOL  operator>(const CString& s1, const char* s2);
BOOL  operator>(const char* s1, const CString& s2);
BOOL  operator<=(const CString& s1, const CString& s2);
BOOL  operator<=(const CString& s1, const char* s2);
BOOL  operator<=(const char* s1, const CString& s2);
BOOL  operator>=(const CString& s1, const CString& s2);
BOOL  operator>=(const CString& s1, const char* s2);
BOOL  operator>=(const char* s1, const CString& s2);


////////////////////////////////////////////////////////////////////////////

class CDWordArray
{
public:

// Construction
	CDWordArray();

// Attributes
	int GetSize() const { return m_nSize; }
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	DWORD GetAt(int nIndex) const { return m_pData[nIndex]; }

	void SetAt(int nIndex, DWORD newElement)
	   {	m_pData[nIndex] = newElement; }
           
	DWORD& ElementAt(int nIndex);

	// Potentially growing the array
	void SetAtGrow(int nIndex, DWORD newElement);
	int Add(DWORD newElement);

	// overloaded operator helpers
	DWORD operator[](int nIndex) const;
	DWORD& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, DWORD newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CDWordArray* pNewArray);

// Implementation
protected:
	DWORD* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CDWordArray();
};


////////////////////////////////////////////////////////////////////////////

class CPtrArray
{
public:

// Construction
	CPtrArray();

// Attributes
	int GetSize() const { return m_nSize; }
	int GetUpperBound() const;
	BOOL SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	void* GetAt(int nIndex) const { return m_pData[nIndex]; }

	void SetAt(int nIndex, void* newElement)
	{ m_pData[nIndex] = newElement; }
        
	void*& ElementAt(int nIndex);

	// Potentially growing the array
	BOOL SetAtGrow(int nIndex, void* newElement);

    // returns -1 if failure

	int Add(void* newElement)
	  { int nIndex = m_nSize;
		if(SetAtGrow(nIndex, newElement))
    		return nIndex; 
        else
            return -1;
    }

	// overloaded operator helpers
	void* operator[](int nIndex) const;
	void*& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, void* newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CPtrArray* pNewArray);

// Implementation
protected:
	void** m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CPtrArray();
};


////////////////////////////////////////////////////////////////////////////

class CStringArray 
{

public:

// Construction
	CStringArray();

// Attributes
	int GetSize() const { return m_nSize; }
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();


	// Accessing elements
	CString GetAt(int nIndex) const { return m_pData[nIndex]; }

	void SetAt(int nIndex, const char* newElement)
	{ m_pData[nIndex] = newElement; }

	CString& ElementAt(int nIndex)
	{ return m_pData[nIndex]; }
        
	// Potentially growing the array
	void SetAtGrow(int nIndex, const char* newElement);
	int Add(const char* newElement)
	{ int nIndex = m_nSize;
	      SetAtGrow(nIndex, newElement);
		  return nIndex; }

	// overloaded operator helpers
	CString operator[](int nIndex) const
	{ return GetAt(nIndex); }
        
	CString& operator[](int nIndex)
      	{ return ElementAt(nIndex); }

	// Operations that move elements around
	void InsertAt(int nIndex, const char* newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CStringArray* pNewArray);

// Implementation
protected:
	CString* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CStringArray();
};

////////////////////////////////////////////////////////////////////////////

class CWordArray 
{
public:

// Construction
	CWordArray();

// Attributes
	int GetSize() const { return m_nSize; }
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	WORD GetAt(int nIndex) const { return m_pData[nIndex]; }
	void SetAt(int nIndex, WORD newElement)
     	{ m_pData[nIndex] = newElement; }
	WORD& ElementAt(int nIndex);

	// Potentially growing the array
	void SetAtGrow(int nIndex, WORD newElement);
	int Add(WORD newElement);

	// overloaded operator helpers
	WORD operator[](int nIndex) const;
	WORD& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, WORD newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CWordArray* pNewArray);

// Implementation
protected:
	WORD* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CWordArray();
};



/////////////////////////////////////////////////////////////////////////////

class CPtrList
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		void* data;
	};
public:

// Construction
	CPtrList(int nBlockSize=10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	void*& GetHead();
	void* GetHead() const;
	void*& GetTail();
	void* GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	void* RemoveHead();
	void* RemoveTail();

	// add before head or after tail
	POSITION AddHead(void* newElement);
	POSITION AddTail(void* newElement);

	// add another list of elements before head or after tail
	void AddHead(CPtrList* pNewList);
	void AddTail(CPtrList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	void*& GetNext(POSITION& rPosition); // return *Position++
	void* GetNext(POSITION& rPosition) const; // return *Position++
	void*& GetPrev(POSITION& rPosition); // return *Position--
	void* GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	void*& GetAt(POSITION position);
	void* GetAt(POSITION position) const;
	void SetAt(POSITION pos, void* newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, void* newElement);
	POSITION InsertAfter(POSITION position, void* newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(void* searchValue, POSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	POSITION FindIndex(int nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CPtrList();
};



//-----------------------------------------------------------------
// Inlines from AFX.INL and AFXCOLL.INL
//

#define _AFX_INLINE inline
#define _AFXCOLL_INLINE inline

// CString

_AFX_INLINE int CString::GetAllocLength() const
	{ return m_nAllocLength; }
_AFX_INLINE BOOL CString::IsEmpty() const
	{ return m_nDataLength == 0; }
//_AFX_INLINE int CString::SafeStrlen(const char* psz)
//	{ return (psz == NULL) ? NULL : strlen(psz); }

#ifndef _WINDOWS
_AFX_INLINE int CString::Compare(const char* psz) const
	{ return strcmp(m_pchData, psz); }
_AFX_INLINE int CString::CompareNoCase(const char* psz) const
	{ return stricmp(m_pchData, psz); }
_AFX_INLINE int CString::Collate(const char* psz) const
	{ return strcoll(m_pchData, psz); }
_AFX_INLINE void CString::MakeUpper()
	{ strupr(m_pchData); }
_AFX_INLINE void CString::MakeLower()
	{ strlwr(m_pchData); }
// Windows version in AFXWIN.H
#endif //!_WINDOWS

_AFX_INLINE void CString::MakeReverse()
	{ strrev(m_pchData); }
_AFX_INLINE char CString::GetAt(int nIndex) const
	{
		return m_pchData[nIndex];
	}
_AFX_INLINE char CString::operator[](int nIndex) const
	{
		return m_pchData[nIndex];
	}
_AFX_INLINE void CString::SetAt(int nIndex, char ch)
	{
		m_pchData[nIndex] = ch;
	}

_AFX_INLINE BOOL  operator==(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) == 0; }

_AFX_INLINE BOOL  operator==(const CString& s1, const char* s2)
	{ return s1.Compare(s2) == 0; }

_AFX_INLINE BOOL  operator==(const char* s1, const CString& s2)
	{ return s2.Compare(s1) == 0; }

_AFX_INLINE BOOL  operator!=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) != 0; }

_AFX_INLINE BOOL  operator!=(const CString& s1, const char* s2)
	{ return s1.Compare(s2) != 0; }

_AFX_INLINE BOOL  operator!=(const char* s1, const CString& s2)
	{ return s2.Compare(s1) != 0; }

_AFX_INLINE BOOL  operator<(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) < 0; }
_AFX_INLINE BOOL  operator<(const CString& s1, const char* s2)
	{ return s1.Compare(s2) < 0; }
_AFX_INLINE BOOL  operator<(const char* s1, const CString& s2)
	{ return s2.Compare(s1) > 0; }
_AFX_INLINE BOOL  operator>(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) > 0; }
_AFX_INLINE BOOL  operator>(const CString& s1, const char* s2)
	{ return s1.Compare(s2) > 0; }
_AFX_INLINE BOOL  operator>(const char* s1, const CString& s2)
	{ return s2.Compare(s1) < 0; }
_AFX_INLINE BOOL  operator<=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) <= 0; }
_AFX_INLINE BOOL  operator<=(const CString& s1, const char* s2)
	{ return s1.Compare(s2) <= 0; }
_AFX_INLINE BOOL  operator<=(const char* s1, const CString& s2)
	{ return s2.Compare(s1) >= 0; }
_AFX_INLINE BOOL  operator>=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) >= 0; }
_AFX_INLINE BOOL  operator>=(const CString& s1, const char* s2)
	{ return s1.Compare(s2) >= 0; }
_AFX_INLINE BOOL  operator>=(const char* s1, const CString& s2)
	{ return s2.Compare(s1) <= 0; }

/////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CWordArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CWordArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE WORD& CWordArray::ElementAt(int nIndex)
	{ return m_pData[nIndex]; }
_AFXCOLL_INLINE int CWordArray::Add(WORD newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
_AFXCOLL_INLINE WORD CWordArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE WORD& CWordArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CDWordArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CDWordArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE DWORD& CDWordArray::ElementAt(int nIndex)
	{ return m_pData[nIndex]; }
_AFXCOLL_INLINE int CDWordArray::Add(DWORD newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
_AFXCOLL_INLINE DWORD CDWordArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE DWORD& CDWordArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CPtrArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CPtrArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE void*& CPtrArray::ElementAt(int nIndex)
	{ return m_pData[nIndex]; }
_AFXCOLL_INLINE void* CPtrArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE void*& CPtrArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CStringArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CStringArray::RemoveAll()
	{ SetSize(0); }


////////////////////////////////////////////////////////////////////////////


_AFXCOLL_INLINE int CPtrList::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CPtrList::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void*& CPtrList::GetHead()
	{ return m_pNodeHead->data; }
_AFXCOLL_INLINE void* CPtrList::GetHead() const
	{ return m_pNodeHead->data; }
_AFXCOLL_INLINE void*& CPtrList::GetTail()
	{ return m_pNodeTail->data; }

_AFXCOLL_INLINE void* CPtrList::GetTail() const
	{ return m_pNodeTail->data; }

_AFXCOLL_INLINE POSITION CPtrList::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }

_AFXCOLL_INLINE POSITION CPtrList::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }

_AFXCOLL_INLINE void*& CPtrList::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }

_AFXCOLL_INLINE void* CPtrList::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }

_AFXCOLL_INLINE void*& CPtrList::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }

_AFXCOLL_INLINE void* CPtrList::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }

_AFXCOLL_INLINE void*& CPtrList::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		return pNode->data; }

_AFXCOLL_INLINE void* CPtrList::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		return pNode->data; }

_AFXCOLL_INLINE void CPtrList::SetAt(POSITION pos, void* newElement)
	{ CNode* pNode = (CNode*) pos;
		pNode->data = newElement; }



////////////////////////////////////////////////////////////////////////////


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcompiler\bmof.c ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    BMOF.C

Abstract:

    Structures and helper functions for naviagating a BMOF file.

History:

    a-davj  14-April-97   Created.

--*/

#include "precomp.h"
#include <string.h>
#include "bmof.h"
#include <wbemutil.h>

//***************************************************************************
//
//  int ITypeSize
//
//  DESCRIPTION:
//
//  Gets the number of bytes acutally used to store
//  a variant type.  0 if the type is unknown 
//
//  PARAMETERS:
//
//  vtTest      Type in question.
//
//
//  RETURN VALUE:
//
//  see description
//
//***************************************************************************

int iTypeSize(
        IN DWORD vtTest)
{
    int iRet;
    vtTest &= ~ VT_ARRAY; // get rid of possible array bit
    vtTest &= ~ VT_BYREF; // get rid of possible byref bit

    switch (vtTest) {
        case VT_UI1:
        case VT_LPSTR:
            iRet = 1;
            break;
        case VT_LPWSTR:
        case VT_BSTR:
        case VT_I2:
            iRet = 2;
            break;
        case VT_I4:
        case VT_R4:
            iRet = 4;
            break;
        case VT_R8:
            iRet = 8;
            break;
        case VT_BOOL:
            iRet = sizeof(VARIANT_BOOL);
            break;
        case VT_ERROR:
            iRet = sizeof(SCODE);
            break;
        case VT_CY:
            iRet = sizeof(CY);
            break;
        case VT_DATE:
            iRet = sizeof(DATE);
            break;

        default:
            iRet = 0;
        }
    return iRet;
}


//***************************************************************************
//
//  CBMOFQualList * CreateQualList
//
//  DESCRIPTION:
//
//  Create a CBMOFQualList object which serves as a wrapper.
//
//  PARAMETERS:
//
//  pwql                 pointer to the WBEM_Qualifier structure in the binary
//                      MOF.
//
//  RETURN VALUE:
//
//  Pointer to CBMOFQualList structure that servers as a wrapper.  NULL 
//  if error.  This must be freed via BMOFFree() when no longer needed.
//
//
//***************************************************************************

CBMOFQualList * CreateQualList(WBEM_QualifierList *pwql)
{

    CBMOFQualList * pRet = NULL;
    if(pwql == NULL)
      return NULL;

    
    pRet = (CBMOFQualList *)BMOFAlloc(sizeof (CBMOFQualList));
    if(pRet != NULL)
    {
        pRet->m_pql = pwql;
        pRet->m_pInfo = (WBEM_Qualifier *)
            ((BYTE *)pRet->m_pql + sizeof(WBEM_QualifierList));;
        ResetQualList(pRet);
    }
    return pRet;
}


//***************************************************************************
//
//  void ResetQualList
//
//  DESCRIPTION:
//
//  Resets CBMOFQualList stucture to point to the first entry.
//
//  PARAMETERS:
//
//  pql                 structure to be reset     
//
//***************************************************************************

void ResetQualList(CBMOFQualList * pql)
{
   if(pql)
   {
      pql->m_CurrQual = 0;
      pql->m_pCurr = pql->m_pInfo;
   }
}

//***************************************************************************
//
//  BOOL NextQual
//
//  DESCRIPTION:
//
//  Gets the name and value of the next qualifier in the list.
//
//  PARAMETERS:
//
//  pql                 Input, points to CBMOFQualList object with data
//  ppName              Output, if functions succeeds, this points to a 
//                      WCHAR string that the caller must free.  May be
//                      NULL if caller doesnt want name.
//  pItem               Input/Output, if set, points to a data item structure
//                      which will be updated to point to the qualifier data.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//
//***************************************************************************

BOOL NextQual(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem)
{
    BYTE * pInfo;
    BOOL bRet = TRUE;

    if(pql == NULL || pql->m_CurrQual++ >= pql->m_pql->dwNumQualifiers)
        return FALSE;
 
    pInfo = (BYTE *)pql->m_pCurr + sizeof(WBEM_Qualifier);
    
    if(ppName)
      SetName(ppName, pInfo, pql->m_pCurr->dwOffsetName);

    if(pInfo)
      bRet = SetValue(pItem, pInfo, pql->m_pCurr->dwOffsetValue, 
                        pql->m_pCurr->dwType);

    // advance to next
    pql->m_pCurr = (WBEM_Qualifier *)((BYTE *)pql->m_pCurr + pql->m_pCurr->dwLength);
    return bRet;
}


//***************************************************************************
//
//  BOOL FindQual
//
//  DESCRIPTION:
//
//  Searches for a qualifier with a given name.  The search is case 
//  insensitive
//
//  PARAMETERS:
//
//  pql                 Input, pointer to qualifier list
//  pName               Input, Name to be searched for.
//  pItem               Input/Output, if successful set to point to the data.
//
//  RETURN VALUE:
//
//  True if OK.
//
//***************************************************************************

BOOL FindQual(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem)
{
    DWORD dwCnt;
    WBEM_Qualifier * pQual = pql->m_pInfo;
    for(dwCnt = 0; dwCnt < pql->m_pql->dwNumQualifiers; dwCnt++)
    {
        WCHAR * pTest;
        BOOL bMatch;
        BYTE * pInfo = (BYTE *)pQual + sizeof(WBEM_Qualifier);
        if(!SetName(&pTest, pInfo, pQual->dwOffsetName))
            return FALSE;

        bMatch = !_wcsicmp(pTest, pName);
        BMOFFree(pTest);
        if(bMatch)
        {
            return SetValue(pItem, pInfo, pQual->dwOffsetValue, pQual->dwType);
        }
        pQual = (WBEM_Qualifier *)((BYTE *)pQual + pQual->dwLength);
    }
    return FALSE;
}


//***************************************************************************
//
//  BOOL SetValue
//
//  DESCRIPTION:
//
//  Sets up a CBMOFDataItem structure to point to a value in the BMOF.
//
//  PARAMETERS:
//
//  pItem               Input/Output, item to be set
//  pInfo               Input, start of information block
//  dwOffset            Input, offset to actual data.
//  dwType              Input data type.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL SetValue(CBMOFDataItem * pItem, BYTE * pInfo, DWORD dwOffset, DWORD dwType)
{

    if(pItem == NULL || pInfo == NULL)
        return FALSE;

    pItem->m_dwType = dwType;

    // Check for NULL case.  This is how uninitialized data is stored.

    if(dwOffset == 0xffffffff)
        pItem->m_pData = NULL;
    else
        pItem->m_pData = pInfo + dwOffset;

    return TRUE;
}

//***************************************************************************
//
//  BOOL SetName
//
//  DESCRIPTION:
//
//  Gets a name out of an information block.  
//
//  PARAMETERS:
//
//  ppName              Input/Output.  On successful return, will point to a 
//                      WCHAR string containing the name.  This MUST be freed
//                      by the caller via BMOFFree()!
//  pInfo               Input, start of information block
//  dwOffset            Input, offset to actual data.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//***************************************************************************

BOOL SetName(WCHAR ** ppName, BYTE * pInfo, DWORD dwOffset)
{
    WCHAR * pName;
    if(ppName == NULL || pInfo == NULL || dwOffset == 0xffffffff)
        return FALSE;

    pName = (WCHAR *)(pInfo + dwOffset);   // point to string in info block
    *ppName = (WCHAR *)BMOFAlloc(2*(wcslen(pName) + 1));
    if(*ppName == NULL)
        return FALSE;
    wcscpy(*ppName, pName);
    return TRUE;
}

//***************************************************************************
//
//  CBMOFObj * CreateObj
//
//  DESCRIPTION:
//
//  Create a CBMOFObj structure which wraps a WBEM_Object
//
//  PARAMETERS:
//
//  pwob                Input, structure to be wrapped
//
//  RETURN VALUE:
//
//  pointer to wrapper structure.  NULL if error.  This must be freed via
//  BMOFFree() when no longer needed.
//
//***************************************************************************

CBMOFObj * CreateObj(WBEM_Object * pwob)
{
    CBMOFObj * pRet = (CBMOFObj *)BMOFAlloc(sizeof(CBMOFObj));
    if(pRet)
     {
        pRet->m_pob = pwob;
        pRet->m_pInfo = ((BYTE *)pwob) + sizeof(WBEM_Object);
        pRet->m_ppl = (WBEM_PropertyList*)(pRet->m_pInfo +
                                        pwob->dwOffsetPropertyList);
        pRet->m_pml = (WBEM_PropertyList*)(pRet->m_pInfo +
                                        pwob->dwOffsetMethodList);
        ResetObj(pRet);
     }
    return pRet;
}


//***************************************************************************
//
//  void ResetObj
//
//  DESCRIPTION:
//
//  Resets a CBMOFObj structure so that it points to its first property.
//
//  PARAMETERS:
//
//  pob                 Input/Output, stucture to be reset.
//
//***************************************************************************

void ResetObj(CBMOFObj * pob)
{
   if(pob)
   {
      pob->m_CurrProp = 0; 
      pob->m_pCurrProp = (WBEM_Property *) ((BYTE *)pob->m_ppl +
                                    sizeof(WBEM_PropertyList));
      pob->m_CurrMeth = 0; 
      pob->m_pCurrMeth = (WBEM_Property *) ((BYTE *)pob->m_pml +
                                    sizeof(WBEM_PropertyList));
   }
}

//***************************************************************************
//
//  CBMOFQualList * GetQualList
//
//  DESCRIPTION:
//
//  Returns a CBMOFQualList structure which wraps the objects qualifier list.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//
//  RETURN VALUE:
//
//  Pointer to CBMOFQualList stucture.  NULL if error.  Note that this must
//  be freed by the caller via BMOFFree()
//
//***************************************************************************

CBMOFQualList * GetQualList(CBMOFObj * pob)
{

    WBEM_QualifierList *pql;
    if(pob->m_pob->dwOffsetQualifierList == 0xffffffff)
        return NULL;
    pql = (WBEM_QualifierList *)((BYTE *)pob->m_pInfo+
                            pob->m_pob->dwOffsetQualifierList);
    return CreateQualList(pql);
}


//***************************************************************************
//
//  CBMOFQualList * GetPropQualList
//  CBMOFQualList * GetMethQualList
//
//  DESCRIPTION:
//
//  Returns a CBMOFQualList structure which wraps a property or 
//  methods qualifier list.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  pName               Input.  Property name.  Note that this is case
//                      insensitive.
//
//  RETURN VALUE:
//
//  Pointer to CBMOFQualList stucture.  NULL if error.  Note that this must
//  be freed by the caller via BMOFFree()
//
//***************************************************************************

CBMOFQualList * GetPropOrMethQualList(WBEM_Property * pProp)
{
    if(pProp == NULL)
        return NULL;
    if(pProp->dwOffsetQualifierSet == 0xffffffff)
        return NULL;
    return CreateQualList((WBEM_QualifierList *)(
                                    (BYTE *)pProp + sizeof(WBEM_Property)+ 
                                    pProp->dwOffsetQualifierSet));
}

CBMOFQualList * GetPropQualList(CBMOFObj * pob, WCHAR * pName)
{
    WBEM_Property * pProp = FindPropPtr(pob, pName);
    return GetPropOrMethQualList(pProp);
}

CBMOFQualList * GetMethQualList(CBMOFObj * pob, WCHAR * pName)
{
    WBEM_Property * pProp = FindMethPtr(pob, pName);
    return GetPropOrMethQualList(pProp);
}

//***************************************************************************
//
//  BOOL NextProp
//  BOOL NextMet
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  ppName              Output, if functions succeeds, this points to a 
//                      WCHAR string that the caller must free.  May be
//                      NULL if caller doesnt want name.
//  pItem               Input/Output, if set, points to a data item structure
//                      which will be updated to point to the qualifier data.
///
//  RETURN VALUE:
//
//  TRUE if OK.
//***************************************************************************

BOOL Info(WBEM_Property * pPropOrMeth, WCHAR ** ppName, CBMOFDataItem * pItem)
{
    BYTE * pInfo;
    BOOL bRet = TRUE;
    if(pPropOrMeth == NULL)
        return FALSE;

    pInfo = (BYTE *)pPropOrMeth + sizeof(WBEM_Property);
    if(ppName)
       SetName(ppName, pInfo, pPropOrMeth->dwOffsetName);
    if(pItem)
       bRet = SetValue(pItem, pInfo, 
                        pPropOrMeth->dwOffsetValue, 
                        pPropOrMeth->dwType);
    return bRet;
}

BOOL NextProp(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem)
{
    BOOL bRet = TRUE;

    if(pob == FALSE || pob->m_CurrProp++ >= pob->m_ppl->dwNumberOfProperties)
        return FALSE;

    Info(pob->m_pCurrProp, ppName, pItem);

    // advance pointer to next property.

    pob->m_pCurrProp = (WBEM_Property *)
                        ((BYTE *)pob->m_pCurrProp + pob->m_pCurrProp->dwLength);                     
    return bRet;
}

BOOL NextMeth(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem)
{
    BOOL bRet = TRUE;

    if(pob == FALSE || pob->m_CurrMeth++ >= pob->m_pml->dwNumberOfProperties)
        return FALSE;

    Info(pob->m_pCurrMeth, ppName, pItem);

    // advance pointer to next method.

    pob->m_pCurrMeth = (WBEM_Property *)
                        ((BYTE *)pob->m_pCurrMeth + pob->m_pCurrMeth->dwLength);                     
    return bRet;
}

//***************************************************************************
//
//  BOOL FindProp
//  BOOL FindMeth
//
//  DESCRIPTION:
//
//  Sets a CBMOFDataItem structure to point to a properties data.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  pName               Input. Name to be use for case insensitve search.
//  pItem               Input/Output.  Data item stucture to be updated.
//
//  RETURN VALUE:
//
//  True if found.
//
//***************************************************************************

BOOL FindProp(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem)
{
    WBEM_Property * pProp = FindPropPtr(pob, pName);
    return Info(pProp, NULL, pItem);
}

BOOL FindMeth(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem)
{
    WBEM_Property * pProp = FindMethPtr(pob, pName);
    return Info(pProp, NULL, pItem);
}

//***************************************************************************
//
//  BOOL GetName
//
//  DESCRIPTION:
//
//  Gets the name of an object.  This is works be returning the "__Class"
//  property.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  ppName              Input/Output.  Points to a WCHAR string which
//                      has the name.  The caller MUST free this via
//                      BMOFFree()
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL GetName(CBMOFObj * pob, WCHAR ** ppName)
{
    CBMOFDataItem Item;
    BOOL bRet = FALSE, bFound;
    if(pob == NULL || ppName == NULL)
        return FALSE;

    bFound = FindProp(pob, L"__Class", &Item);
    if(!bFound)
        return FALSE;
    if(Item.m_dwType == VT_BSTR  && ppName)
    {
        bRet = GetData(&Item, (BYTE *)ppName, NULL);
    }
    return bRet;
}


//***************************************************************************
//
//  DWORD GetType
//
//  DESCRIPTION:
//
//  Returns an objects type.  A 0 indicates a class while a 1 indicates an 
//  instance.  A 0xffffffff if passed a null pointer.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  
//
//  RETURN VALUE:
//
//  See description.
//
//***************************************************************************

DWORD GetType(CBMOFObj * pob)
{
   if(pob)
      return pob->m_pob->dwType;
   else
      return 0xFFFFFFFF;
}

//***************************************************************************
//
//  WBEM_Property * FindPropPtr
//  WBEM_Property * FindMethPtr
//
//  DESCRIPTION:
//
//  Returns a WBEM_Property stucture pointer for a particular property or
//  method given its name.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  pName               Input.  Name of property.  Comparison is case
//                      insensitive.
//
//  RETURN VALUE:
//
//  pointer to WBEM_Property, NULL if it cant be found.
//
//***************************************************************************

WBEM_Property *  Search(BYTE * pList, DWORD dwListSize, WCHAR * pName)
{
    DWORD dwCnt;
    WBEM_Property * pProp = NULL;

    // point to first property structure

    pProp = (WBEM_Property *)(pList + sizeof(WBEM_PropertyList));

    for(dwCnt = 0; dwCnt < dwListSize; dwCnt++)
    {
        WCHAR * pTest;
        BOOL bMatch;

        // point to the property's name and retrieve it

        BYTE * pInfo = (BYTE *)pProp + sizeof(WBEM_Property);
        if(!SetName(&pTest, pInfo, pProp->dwOffsetName))
            return NULL;
        bMatch = !_wcsicmp(pTest, pName);
        BMOFFree(pTest);

        // If we have a match, return

        if(bMatch)
            return pProp;
        
        pProp = (WBEM_Property *)((BYTE *)pProp + pProp->dwLength);
    }
    return NULL;


}

WBEM_Property * FindPropPtr(CBMOFObj * pob, WCHAR * pName)
{
    if(pob == NULL || pName == NULL)
      return NULL;

    // point to first property structure

    return Search((BYTE *)pob->m_ppl, pob->m_ppl->dwNumberOfProperties, pName);
}

WBEM_Property * FindMethPtr(CBMOFObj * pob, WCHAR * pName)
{
    if(pob == NULL || pName == NULL)
      return NULL;

    // point to first property structure

    return Search((BYTE *)pob->m_pml, pob->m_pml->dwNumberOfProperties, pName);
}


//***************************************************************************
//
//  CBMOFObjList * CreateObjList
//
//  DESCRIPTION:
//
//  Create a CBMOFObjList structure which wraps a BMOF file.
//
//  PARAMETERS:
//
//  pBuff                Input, points to start of BMOF file.
//
//  RETURN VALUE:
//
//  pointer to wrapper structure.  NULL if error.  This must be freed via
//  BMOFFree() when no longer needed.
//
//***************************************************************************

CBMOFObjList * CreateObjList(BYTE * pBuff)
{
    CBMOFObjList * pRet = (CBMOFObjList * )BMOFAlloc(sizeof(CBMOFObjList));
    if(pRet)
    {
        pRet->m_pol = (WBEM_Binary_MOF *)pBuff;
        pRet->m_pInfo = (WBEM_Object *)
                   ((BYTE *)pBuff + sizeof(WBEM_Binary_MOF));
        ResetObjList(pRet);
    }
    return pRet;
}


//***************************************************************************
//
//  void ResetObjList
//
//  DESCRIPTION:
//
//  Resets a CBMOFObjList structure so that it points to its first object.
//
//  PARAMETERS:
//
//  pol                 Input/Output, stucture to be reset.
//
//***************************************************************************

void ResetObjList(CBMOFObjList * pol)
{
   if(pol)
   {
      pol->m_pCurrObj = pol->m_pInfo;
      pol->m_CurrObj = 0;
   }
}

//***************************************************************************
//
//  CBMOFObj * NextObj
//
//  DESCRIPTION:
//
//  Gets the next object in the list.
//
//  PARAMETERS:
//
//  pol                 Input. Pointer to CBMOFObjList object
//
//  RETURN VALUE:
//
//  Pointer to a CBMOFObj stucture which can be use to access the object
//  information.  NULL if error.  Note that the caller MUST Free this via
//  BMOFFree().
//
//***************************************************************************

CBMOFObj * NextObj(CBMOFObjList *pol)
{
    CBMOFObj * pRet;

    if(pol == NULL || pol->m_CurrObj++ >= pol->m_pol->dwNumberOfObjects)
        return NULL;
    
    pRet = CreateObj(pol->m_pCurrObj);
    pol->m_pCurrObj = (WBEM_Object *)((BYTE *)pol->m_pCurrObj + pol->m_pCurrObj->dwLength);
    return pRet;
}


//***************************************************************************
//
//  CBMOFObj * FindObj
//
//  DESCRIPTION:
//
//  Searches the object list for the first object which has a "__className"
//  property.  The search is case insensitive. 
//
//  PARAMETERS:
//
//  pol                 Input. Pointer to CBMOFObjList object
//  pName               Input. Name of object being searched for
//
//  RETURN VALUE:
//
//  Pointer to a CBMOFObj stucture which can be use to access the object
//  information.  NULL if error.  Note that the caller MUST Free this via
//  BMOFFree().
//
//***************************************************************************

CBMOFObj * FindObj(CBMOFObjList *pol, WCHAR * pName)
{
    DWORD dwCnt;
    WBEM_Object * pob;

    if(pol->m_pol == NULL || pName == NULL)
        return NULL;
    
    pob = pol->m_pInfo;
    for(dwCnt = 0; dwCnt < pol->m_pol->dwNumberOfObjects; dwCnt)
    {
        WCHAR * pwcName = NULL;
        BOOL bMatch = FALSE;

        CBMOFObj * pRet = CreateObj(pob);
         if(pRet == NULL)
            return NULL;
        if(GetName(pRet,&pwcName))
            bMatch = TRUE;
        if(pwcName)
            BMOFFree(pwcName);

        // If we found it, return it, otherwise free object and advance

        if(bMatch)
            return pRet;
        BMOFFree(pRet);
        pob = (WBEM_Object *)((BYTE *)pob + pob->dwLength);
    }
    return NULL; 
}


//***************************************************************************
//
//  int GetNumDimensions
//
//  DESCRIPTION:
//
//  Returns the number of dimensions for a data item.
//
//  PARAMETERS:
//
//  pItem               Input.  Item in question.
//
//  RETURN VALUE:
//  -1 if bogus argument, or if the data item doesnt hold data which would
//     be the case for uninitialized properties.
//  0  if non array argument
//  n  Number of dimensions.  Currently only single dimension arrays are
//     supported.
//
//***************************************************************************

int GetNumDimensions(CBMOFDataItem * pItem)
{
   unsigned long * pdwTemp;
   if(pItem == NULL)
      return -1;
   if(!(pItem->m_dwType & VT_ARRAY))
      return 0;
   if(pItem->m_pData == NULL)
      return -1;

   pdwTemp = (unsigned long *)pItem->m_pData;
   pdwTemp++;        // skip past total size
   return *pdwTemp;
}


//***************************************************************************
//
//  int GetNumElements
//
//  DESCRIPTION:
//
//  Gets the number of elements for an array dimension.  Note that 1 is the
//  first dimenstion.  Currently, only scalars and 1 dimensional arrays are
//  supported.
//
//  PARAMETERS:
//
//  pItem               Input.  Data item in question.
//  lDim                Input.  Dimension in question.  The most significent
//                      (and for now only) dimension is 0.
//
//  RETURN VALUE:
//
//  Number of array elements.  Note that scalars will return -1.
//  
//***************************************************************************

int GetNumElements(CBMOFDataItem * pItem, long lDim)
{
   int iCnt; DWORD * pdwTemp;
   int lNumDim = GetNumDimensions(pItem);
   if(lNumDim == -1 || lDim > lNumDim)
      return -1;
   pdwTemp = (unsigned long *)pItem->m_pData;
   pdwTemp++;                          // skip total size
   pdwTemp++;                          // skip number of dimensions
   for(iCnt = 0; iCnt < lDim; iCnt++)
      pdwTemp++;
   return *pdwTemp;
}
 

//***************************************************************************
//
//  BYTE * GetDataElemPtr
//
//  DESCRIPTION:
//
//  Used to get the pointer to a particular data element.  Note that this is
//  usually used internally.
//
//  PARAMETERS:
//
//  pItem               Input.  Data item to use.
//  plDims              Input.  Pointer to array of dimension values.  Note
//                      that currenly only a single dimension is supported.
//  vtSimple            Input.  Variant type of the data with the VT_ARRAY 
//                      and VT_BYREF bits cleared.              
//
//  RETURN VALUE:
//

//  pointer to the data.
//***************************************************************************

BYTE * GetDataElemPtr(CBMOFDataItem * pItem, long * plDims, DWORD vtSimple)
{
   int iNumDim;
   DWORD dwTotalDataSize;
   BYTE * pEndOfData;
   DWORD * pdwCurr;
   DWORD * pdwCurrObj;
   BYTE * pRow;
   int iCnt;

   // first check the number of dimensions.

   iNumDim = GetNumDimensions(pItem);
   if(iNumDim == -1)
      return NULL;
   if(iNumDim == 0)           // simple case of scalar argument
      return pItem->m_pData;

   // for arrays, the data block starts off with this form, 
   // dwtotalsize, dwNumDimenstions, dwMostSigDimension... dwLeastSigDimension
   // Since currently only 1 dimensional arrays are supported, a 5 element
   // array would start with
   // dwSize, 1, 5

   pdwCurr = (DWORD *)pItem->m_pData;
   dwTotalDataSize = *pdwCurr;
   pEndOfData = pItem->m_pData + dwTotalDataSize;
   pdwCurr+= 2;      // skip to dimension list
   pdwCurr += iNumDim;  // skip of dimension sizes.

   while((BYTE *)pdwCurr < pEndOfData)
   {
      // Each row has the format 
      // dwSizeOfRow, MostSigDimension ... dwLeastSignificentDimension+1,data
      // For a one dimensional array, it would just be
      // dwSizeOfRow, data


      DWORD dwRowSize = *pdwCurr;

      // test if this row is ok.  Each row of data will have 
      // a set of Indicies for each higher dimension.   

      for(iCnt = 0; iCnt < iNumDim-1; iCnt++)
      {
         DWORD * pRowInd = pdwCurr +1 + iCnt;
         if((long)*pRowInd != plDims[iCnt])
            break;

      }
      if(iCnt >= iNumDim -1)
      {
         break;                  // found the row.
      }

      // go to the next row

      pdwCurr = (DWORD *)((BYTE *)pdwCurr + dwRowSize);

   }

   if((BYTE *)pdwCurr >= pEndOfData)
      return NULL;

   pRow = (BYTE *)(pdwCurr + 1 + iNumDim -1);
   for(iCnt = 0; iCnt < plDims[iNumDim-1]; iCnt++)
   {
      if(vtSimple == VT_BSTR)
         pRow += 2*(wcslen((WCHAR *)pRow)+1);
      else if(vtSimple == VT_EMBEDDED_OBJECT)
      {
         // Each embedded object starts off with its own size

         pdwCurrObj = (DWORD *)pRow;
         pRow += *pdwCurrObj;

      }
      else 
         pRow += iTypeSize(vtSimple); 
   }

   return pRow;

}


//***************************************************************************
//
//  int GetData
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//  pItem               Input.  Data item to use.
//  pRet                Input/Output.  Pointer to where the data is to be
//                      copied.  For simple data, such as ints, this can just
//                      be a pointer to an int.  For BSTRs, or embedded 
//                      objects, this is treated as a pointer to a pointer 
//                      and it is the responsibility of the caller to free 
//                      the strings via BMOFFree().
//  plDims              Input.  Pointer to array of dimension values.  Note
//                      that currenly only a single dimension is supported.
//                      The first element in any dimension is 0.
//  RETURN VALUE:
//
//  Number of bytes of data.
//***************************************************************************

int GetData(CBMOFDataItem * pItem, BYTE * pRet, long * plDims)
{
   DWORD dwSimple;
   BYTE * pData;
   long * pLong = (long *)pRet;     // easier for returning strings and embedded objs.
   dwSimple = pItem->m_dwType &~ VT_ARRAY &~VT_BYREF;
   pData = GetDataElemPtr(pItem, plDims, dwSimple);
   if(pData == NULL)
      return 0;
   if(dwSimple == VT_BSTR)
   {

      // For strings, a new WCHAR buffer is returned.  Note that 
      // SysAllocString isnt used so as to avoid any Ole dependencies.

      BYTE * pStr;
      DWORD dwSize = 2*(wcslen((WCHAR *)pData)+1);
      
      pStr = BMOFAlloc(dwSize);
      *pLong = (long)pStr;
      wcscpy((WCHAR *)pStr, (WCHAR *)pData);
      return dwSize;
   }
   else if(dwSimple == VT_EMBEDDED_OBJECT)
   {

      // This is the embedded object case.
      *pLong = (long) CreateObj((WBEM_Object *)pData);
      return sizeof(long);
   }
   else
   {
      memcpy((void *)pRet, (void *)pData, iTypeSize(dwSimple)); 
      return iTypeSize(dwSimple);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\minimfc\strex.cpp ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    STREX.CPP

Abstract:

History:

--*/

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "precomp.h"

#define ASSERT(x)
#define ASSERT_VALID(x)

//////////////////////////////////////////////////////////////////////////////
// More sophisticated construction

CString::CString(char ch, int nLength)
{
    ASSERT(!_AfxIsDBCSLeadByte(ch));    // can't create a lead byte string
    if (nLength < 1)
        // return empty string if invalid repeat count
        Init();
    else
    {
        AllocBuffer(nLength);
        memset(m_pchData, ch, nLength);
    }
}


CString::CString(const char* pch, int nLength)
{
    if (nLength == 0)
        Init();
    else
    {
        ASSERT(pch != NULL);
        AllocBuffer(nLength);
        memcpy(m_pchData, pch, nLength);
    }
}

//////////////////////////////////////////////////////////////////////////////
// Additional constructors for far string data

#ifdef _NEARDATA

CString::CString(LPCSTR lpch, int nLen)
{
    if (nLen == 0)
        Init();
    else
    {
        AllocBuffer(nLen);
        _fmemcpy(m_pchData, lpch, nLen);
    }
}

#endif //_NEARDATA

//////////////////////////////////////////////////////////////////////////////
// Assignment operators

const CString& CString::operator =(char ch)
{
    ASSERT(!_AfxIsDBCSLeadByte(ch));    // can't set single lead byte
    AssignCopy(1, &ch);
    return *this;
}

//////////////////////////////////////////////////////////////////////////////
// less common string expressions

CString  operator +(const CString& string1, char ch)
{
    CString s;
    s.ConcatCopy(string1.m_nDataLength, string1.m_pchData, 1, &ch);
    return s;
}


CString  operator +(char ch, const CString& string)
{
    CString s;
    s.ConcatCopy(1, &ch, string.m_nDataLength, string.m_pchData);
    return s;
}

//////////////////////////////////////////////////////////////////////////////
// Very simple sub-string extraction

CString CString::Mid(int nFirst) const
{
    return Mid(nFirst, m_nDataLength - nFirst);
}

CString CString::Mid(int nFirst, int nCount) const
{
    ASSERT(nFirst >= 0);
    ASSERT(nCount >= 0);

    // out-of-bounds requests return sensible things
    if (nFirst + nCount > m_nDataLength)
        nCount = m_nDataLength - nFirst;
    if (nFirst > m_nDataLength)
        nCount = 0;

    CString dest;
    AllocCopy(dest, nCount, nFirst, 0);
    return dest;
}

CString CString::Right(int nCount) const
{
    ASSERT(nCount >= 0);

    if (nCount > m_nDataLength)
        nCount = m_nDataLength;

    CString dest;
    AllocCopy(dest, nCount, m_nDataLength-nCount, 0);
    return dest;
}

CString CString::Left(int nCount) const
{
    ASSERT(nCount >= 0);

    if (nCount > m_nDataLength)
        nCount = m_nDataLength;

    CString dest;
    AllocCopy(dest, nCount, 0, 0);
    return dest;
}

// strspn equivalent
CString CString::SpanIncluding(const char* pszCharSet) const
{
    ASSERT(pszCharSet != NULL);
    return Left(strspn(m_pchData, pszCharSet));
}

// strcspn equivalent
CString CString::SpanExcluding(const char* pszCharSet) const
{
    ASSERT(pszCharSet != NULL);
    return Left(strcspn(m_pchData, pszCharSet));
}

//////////////////////////////////////////////////////////////////////////////
// Finding

int CString::ReverseFind(char ch) const
{
    char* psz;
#ifdef _WINDOWS
    if (afxData.bDBCS)
    {
        // compare forward remembering the last match
        char* pszLast = NULL;
        psz = m_pchData;
        while (*psz != '\0')
        {
            if (*psz == ch)
                pszLast = psz;
            psz = _AfxAnsiNext(psz);
        }
        psz = pszLast;
    }
    else
#endif
        psz = (char*)strrchr(m_pchData, ch);

    return (psz == NULL) ? -1 : (int)(psz - m_pchData);
}

// find a sub-string (like strstr)
int CString::Find(const char* pszSub) const
{
    ASSERT(pszSub != NULL);
    char* psz;

#ifdef _WINDOWS
    if (afxData.bDBCS)
    {
        for (psz = m_pchData; TRUE; psz = _AfxAnsiNext(psz))
        {
            // stop looking if at end of string
            if (*psz == '\0')
            {
                psz = NULL;
                break;
            }

            // compare the substring against current position
            const char* psz1 = psz;
            const char* psz2 = pszSub;
            while (*psz2 == *psz1 && *psz2 != '\0')
                ++psz1, ++psz2;

            // continue looking unless there was a match
            if (*psz2 == '\0')
                break;
        }
    }
    else
#endif
        psz = (char*)strstr(m_pchData, pszSub);

    // return -1 for not found, distance from beginning otherwise
    return (psz == NULL) ? -1 : (int)(psz - m_pchData);
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\minimfc\strcore2.cpp ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    STRCORE2.CPP

Abstract:

History:

--*/

// This is a part of the Microsoft Foundation Classes C++ library.
// Copyright (C) 1992-1993 Microsoft Corporation
// All rights reserved.
//
// This source code is only intended as a supplement to the
// Microsoft Foundation Classes Reference and Microsoft
// QuickHelp and/or WinHelp documentation provided with the library.
// See these sources for detailed information regarding the
// Microsoft Foundation Classes product.


#include "precomp.h"

#define ASSERT(x)
#define ASSERT_VALID(x)


#define SafeStrlen strlen

//////////////////////////////////////////////////////////////////////////////
// concatenate in place

void CString::ConcatInPlace(int nSrcLen, const char* pszSrcData)
{
    //  -- the main routine for += operators

    // if the buffer is too small, or we have a width mis-match, just
    //   allocate a new buffer (slow but sure)
    if (m_nDataLength + nSrcLen > m_nAllocLength)
    {
        // we have to grow the buffer, use the Concat in place routine
        char* pszOldData = m_pchData;
        ConcatCopy(m_nDataLength, pszOldData, nSrcLen, pszSrcData);
        ASSERT(pszOldData != NULL);
        SafeDelete(pszOldData);
    }
    else
    {
        // fast concatenation when buffer big enough
        memcpy(&m_pchData[m_nDataLength], pszSrcData, nSrcLen);
        m_nDataLength += nSrcLen;
    }
    ASSERT(m_nDataLength <= m_nAllocLength);
    m_pchData[m_nDataLength] = '\0';
}

const CString& CString::operator +=(const char* psz)
{
    ConcatInPlace(SafeStrlen(psz), psz);
    return *this;
}

const CString& CString::operator +=(char ch)
{
    ConcatInPlace(1, &ch);
    return *this;
}

const CString& CString::operator +=(const CString& string)
{
    ConcatInPlace(string.m_nDataLength, string.m_pchData);
    return *this;
}

///////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcompiler\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcompiler\bmof.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    BMOF.H

Abstract:

	Describes the format of binary MOF files.  In addition, it defines some
	structures which specify the details of the format and also defines some
	addtional structures and helper functions for navigating a BMOF file.

History:

	a-davj  14-April-97   Created.

--*/

#ifndef __BMOF__
#define __BMOF__


#ifdef __cplusplus
extern "C" {
#endif

//  Binary mof files contain a large blob of data which consists of stuctures
//  which contain other structures, etc.  The layout of that blob is detailed in
//  the following comments.  However, the binary files are compressed and always
//  starts off with the following DWORDS
//  [Signature] [Compression Type, Always 1] [Compressed size] [Expanded size] The blob follows!
//  An example of decompressing the file is in test.c
//
//   The following is a BNF description of the structures that make up
//   a BMOF file and also serve to illustrate the basic layout of WBEM
//   objects.
//  
//  --A MOF is zero or more objects
//  
//  WBEM_Binary_MOF ::= WBEM_Object*; 
//  
//  --An object is a qualifier list (applying to the entire object) and
//  --a property list
//  
//  WBEM_Object ::= WBEM_QualifierList WBEM_PropertyList;
//  
//  --A property list is zero or more properties
//     
//  WBEM_PropertyList ::= WBEM_Property*;   / zero or more properties
//  
//  --A property is a set of qualifiers applying to the property, and
//  --a type, a name, and a value
//  
//  WBEM_Property ::= WBEM_QualifierList* <type> <name> <value>;
//  
//  --A qualifier list is zero or more qualifiers
//  
//  WBEM_QualifierList ::= WBEM_Qualifier*;   -- zero or more qualifiers
//  
//  --A qualifier is a type, a name, and a value. However, the supported types
//  --are not as extensive as for properties.
//  
//  WBEM_Qualifier ::= <type> <name> <value>;
//  
//  
//  Note that a qualifier set (a list of qualifiers) can be applied
//  to the entire object or to individual properties. However, qualifiers
//  cannot be applied to other qualifiers:
//  
//      object = quals + props
//      prop = quals + name + value
//      qual = name + value
//  
//  Information such as the name of a class, the super class, etc., are coded
//  as property values.  Finding the value of the property __CLASS, for example,
//  gives the name of the class.  All properties beginning with a double
//  underscore are well-known system properties common to all WBEM objects.
//  All other properties are user-defined.
//  
//  The list of predefined properties is found in WBEM documentation.
//  
//  Offsets are relative to their owning structure, not absolute to the
//  entire encoding image.  This allows moving the subcomponents around
//  without rencoding everything.
//  
//  Note that an offset of 0xFFFFFFFF indicates that the field is not used.
//  
//  Both properties and qualifiers have value fields which contain data based
//  on Ole Automation types.  Qualifiers are simple types (no arrays or 
//  embedded objects) while property values might contain arrays and/or 
//  embedded objects.  
//
//  One difference from Ole is that BSTRs are actually stored as WCHAR 
//  strings even if the data type is marked as BSTR.  
//
//  In addition, some qualifiers or properties are actually aliases which 
//  must be resolved later.  Aliases are stored as BSTR values and the type
//  field is set to VT_BSTR | VT_BYREF.  An array of alias strings is a bit
//  more complicated since not all the elements need be aliases.  In the array
//  case, each actual alias string is prepended with a L'$' while each 
//  "regular" string is prepended by a L' '.
//
//  Currently, only scalars and single dimensional arrays are supported.
//  However, the BMOF file layout is designed so as to accommodate multi-
//  dimensional array in the future.  For array data, the data is layout out
//
//  ArrayData ::= ArrayHeaderData + RowOfData*; 
//
//  The ArrayHeaderData has the form;
//  dwtotalsize, dwNumDimenstions, dwMostSigDimension... dwLeastSigDimension
// 
//  Currently only 1 dimensional arrays are supported, a 5 element
//  array would start with;
//  dwSize, 1, 5
//
//  After the header, one or more rows would follow.  A row represents the
//  "most rapidly changing" data.  Currently, there is only one row.
//
//  The row format is;
//
//  dwSizeOfRow, MostSigDimension ... dwLeastSignificentDimension+1,data
//  For a one dimensional array, it would just be
//  dwSizeOfRow, Data
//

// Each Binary MOF file starts off with these signature bytes.

#define BMOF_SIG 0x424d4f46

// The following structures exactly describe the contents of a BMOF file.
// These can be used to navigate the file using the various offsets and
// lots of casting.  

typedef struct 
{
    DWORD dwSignature;          // four characters, BMOF
    DWORD dwLength;
    DWORD dwVersion;            // 0x1
    DWORD dwEncoding;           // 0x1 = little endian, DWORD-aligned, no compression

    DWORD dwNumberOfObjects;    // Total classes and instances in MOF

    // BYTE Info[];             // Blob containing array of WBEM_Object structs
                                // First object is at offset 0.
}WBEM_Binary_MOF;

typedef struct                  // Describes a class or instance
{
    DWORD dwLength;
    DWORD dwOffsetQualifierList;
    DWORD dwOffsetPropertyList;
    DWORD dwOffsetMethodList;
    DWORD dwType;               // 0 = class, 1 = instance
    
    //  BYTE Info[];            // Blob of qualifier set and properties
}WBEM_Object;

typedef struct 
{
    DWORD dwLength;
    DWORD dwNumberOfProperties;
    
    //  BYTE Info[];                // Blob with all properties placed end-to-end    
}WBEM_PropertyList;
                                                                   
typedef struct 
{
    DWORD dwLength;             // Length of this struct
    DWORD dwType;               // A VT_ type from WTYPES.H (VT_I4, VT_UI8, etc)
    DWORD dwOffsetName;         // Offset in <Info> of the null-terminated name.
    DWORD dwOffsetValue;        // Offset in <Info> of the value.
    DWORD dwOffsetQualifierSet; // 
        
    
    //  BYTE  Info[];           // Contains qualifier set, name, and value
}WBEM_Property;

// Rough encoding example for a string:
//
// dwLength = 10;
// dwType   = VT_LPWSTR;    
// dwOffsetName  = 0;
// dwOffsetValue = 8;
// dwOffsetQualifierSet = 0xFFFFFFFF;   // Indicates not used
//
// Info[] = "CounterValue\0<default value>\0";


typedef struct       
{
    DWORD dwLength;
    DWORD dwNumQualifiers;
    //  BYTE Info[];                // Array of WBEM_Qualifiers placed end-to-end
}WBEM_QualifierList;


typedef struct 
{
    DWORD dwLength;         // Length of this struct
    DWORD dwType;           // A VT_ type from WTYPES.H (VT_I4, VT_UI8, etc)
    DWORD dwOffsetName;     // Offset in <Info> of the null-terminated name.
    DWORD dwOffsetValue;    // Offset in <Info> of the value.
    //  BYTE  Info[];   
}WBEM_Qualifier;


// These structures and the helper functions that go with them can be used
// to easily navigate a BMOF file.  These structures "wrap" the above 
// structures so as to provide features such as searching and enumeration.

typedef struct 
{
    WBEM_QualifierList * m_pql;
    WBEM_Qualifier * m_pInfo;
    DWORD m_CurrQual;
    WBEM_Qualifier * m_pCurr;

}CBMOFQualList;

typedef struct 
{
    WBEM_Object * m_pob;
    BYTE * m_pInfo;
    WBEM_PropertyList * m_ppl;
    DWORD m_CurrProp;
    WBEM_Property * m_pCurrProp;

    WBEM_PropertyList * m_pml;
    DWORD m_CurrMeth;
    WBEM_Property * m_pCurrMeth;

}CBMOFObj;

typedef struct 
{
    WBEM_Binary_MOF * m_pol;
    DWORD m_CurrObj;
    WBEM_Object * m_pInfo;
    WBEM_Object * m_pCurrObj;   
}CBMOFObjList;


typedef struct 
{
    BYTE * m_pData;
    DWORD  m_dwType;
}CBMOFDataItem;

// Using any of the following help functions requires that these two 
// functions be provided in another module and allow independence from
// any particular allocation method.

void * BMOFAlloc(size_t Size);
void BMOFFree(void * pFree);


// These functions wrap the object list and provider for enumeration of
// the objects.

CBMOFObjList * CreateObjList(BYTE * pBuff);
void ResetObjList(CBMOFObjList * pol);
CBMOFObj * NextObj(CBMOFObjList *pol);
CBMOFObj * FindObj(CBMOFObjList *pol, WCHAR * pName);

// These functions allow access to the parts of a class or instance object

void ResetObj(CBMOFObj * pol);
CBMOFQualList * GetQualList(CBMOFObj * pol);
CBMOFQualList * GetPropQualList(CBMOFObj * pol, WCHAR * pName);
CBMOFQualList * GetMethQualList(CBMOFObj * pol, WCHAR * pName);
BOOL NextProp(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem);
BOOL NextMeth(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem);
BOOL FindProp(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem);
BOOL FindMeth(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem);
BOOL GetName(CBMOFObj * pob, WCHAR ** ppName);
DWORD GetType(CBMOFObj * pob);
WBEM_Property * FindPropPtr(CBMOFObj * pob, WCHAR * pName);
WBEM_Property * FindMethPtr(CBMOFObj * pob, WCHAR * pName);

//  These functions provide easy access to a qualifier list.

void ResetQualList(CBMOFQualList * pql);
BOOL NextQual(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem);
BOOL FindQual(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem);

// These functions provide easy access to a data item.  Note that data items
// might be stored in arrays.

int GetNumDimensions(CBMOFDataItem *);
int GetNumElements(CBMOFDataItem *, long lDim);
int GetData(CBMOFDataItem *, BYTE * pRet, long * plDims);

// These functions are mainly useful to the above helper functions

int iTypeSize(DWORD vtTest);
BOOL SetValue(CBMOFDataItem * pItem, BYTE * pInfo, DWORD dwOffset, DWORD dwType);
BOOL SetName(WCHAR ** ppName, BYTE * pInfo, DWORD dwOffset);
CBMOFQualList * CreateQualList(WBEM_QualifierList *pql);
CBMOFObj * CreateObj(WBEM_Object * pob);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\minimfc\precomp.h ===
/*++

Copyright (C) 1992-2001 Microsoft Corporation

Module Name:

    MINIAFX.H

Abstract:

  MFC Subset declarations.

  CString, CWordArray, CDWordArray, CPtrArray, CStringArray, CPtrList

History:

  09/25/94    TSE

--*/

#ifndef _MINIAFX_H_
#define _MINIAFX_H_

#include <stdio.h>
#include <string.h>

typedef void*      POSITION;   // abstract iteration position

#ifndef DWORD
  typedef unsigned char  BYTE;   // 8-bit unsigned entity
  typedef unsigned short WORD;   // 16-bit unsigned number
  typedef unsigned int   UINT;   // machine sized unsigned number (preferred)
  typedef long           LONG;   // 32-bit signed number
  typedef unsigned long  DWORD;  // 32-bit unsigned number
  typedef int            BOOL;   // BOOLean (0 or !=0)
  typedef char *      LPSTR;  // far pointer to a string
  typedef const char * LPCSTR; // far pointer to a read-only string
#endif

#ifndef NULL
#define NULL 0
#endif

#ifndef TRUE
#define TRUE 1
#endif

#ifndef FALSE
#define FALSE 0
#endif



////////////////////////////////////////////////////////////////////////////

class CString
{
public:

// Constructors
	CString();
	CString(const CString& stringSrc);
	CString(char ch, int nRepeat = 1);
	CString(const char* psz);
	CString(const char* pch, int nLength);
   ~CString();

// Attributes & Operations

	// as an array of characters
	int GetLength() const { return m_nDataLength; }

	BOOL IsEmpty() const;
	void Empty();                       // free up the data

	char GetAt(int nIndex) const;       // 0 based
	char operator[](int nIndex) const;  // same as GetAt
	void SetAt(int nIndex, char ch);
	operator const char*() const       // as a C string
	{ return (const char*)m_pchData; }

	// overloaded assignment
	const CString& operator=(const CString& stringSrc);
	const CString& operator=(char ch);
	const CString& operator=(const char* psz);

	// string concatenation
	const CString& operator+=(const CString& string);
	const CString& operator+=(char ch);
	const CString& operator+=(const char* psz);

	friend CString  operator+(const CString& string1,
			const CString& string2);
	friend CString  operator+(const CString& string, char ch);
	friend CString  operator+(char ch, const CString& string);
	friend CString  operator+(const CString& string, const char* psz);
	friend CString  operator+(const char* psz, const CString& string);

	// string comparison
	int Compare(const char* psz) const;         // straight character
	int CompareNoCase(const char* psz) const;   // ignore case
	int Collate(const char* psz) const;         // NLS aware

	// simple sub-string extraction
	CString Mid(int nFirst, int nCount) const;
	CString Mid(int nFirst) const;
	CString Left(int nCount) const;
	CString Right(int nCount) const;

	CString SpanIncluding(const char* pszCharSet) const;
	CString SpanExcluding(const char* pszCharSet) const;

	// upper/lower/reverse conversion
	void MakeUpper();
	void MakeLower();
	void MakeReverse();

	// searching (return starting index, or -1 if not found)
	// look for a single character match
	int Find(char ch) const;                    // like "C" strchr
	int ReverseFind(char ch) const;
	int FindOneOf(const char* pszCharSet) const;

	// look for a specific sub-string
	int Find(const char* pszSub) const;         // like "C" strstr

	// Windows support

#ifdef _WINDOWS
	BOOL LoadString(UINT nID);          // load from string resource
										// 255 chars max
	// ANSI<->OEM support (convert string in place)
	void AnsiToOem();
	void OemToAnsi();
#endif //_WINDOWS

	// Access to string implementation buffer as "C" character array
	char* GetBuffer(int nMinBufLength);
	void ReleaseBuffer(int nNewLength = -1);
	char* GetBufferSetLength(int nNewLength);

// Implementation
public:
	int GetAllocLength() const;
protected:
	// lengths/sizes in characters
	//  (note: an extra character is always allocated)
	char* m_pchData;            // actual string (zero terminated)
	int m_nDataLength;          // does not include terminating 0
	int m_nAllocLength;         // does not include terminating 0

	// implementation helpers
	void Init();
	void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
	void AllocBuffer(int nLen);
	void AssignCopy(int nSrcLen, const char* pszSrcData);
	void ConcatCopy(int nSrc1Len, const char* pszSrc1Data, int nSrc2Len, const char* pszSrc2Data);
	void ConcatInPlace(int nSrcLen, const char* pszSrcData);
	static void SafeDelete(char* pch);
	static int SafeStrlen(const char* psz);
};


// Compare helpers
BOOL  operator==(const CString& s1, const CString& s2);
BOOL  operator==(const CString& s1, const char* s2);
BOOL  operator==(const char* s1, const CString& s2);
BOOL  operator!=(const CString& s1, const CString& s2);
BOOL  operator!=(const CString& s1, const char* s2);
BOOL  operator!=(const char* s1, const CString& s2);
BOOL  operator<(const CString& s1, const CString& s2);
BOOL  operator<(const CString& s1, const char* s2);
BOOL  operator<(const char* s1, const CString& s2);
BOOL  operator>(const CString& s1, const CString& s2);
BOOL  operator>(const CString& s1, const char* s2);
BOOL  operator>(const char* s1, const CString& s2);
BOOL  operator<=(const CString& s1, const CString& s2);
BOOL  operator<=(const CString& s1, const char* s2);
BOOL  operator<=(const char* s1, const CString& s2);
BOOL  operator>=(const CString& s1, const CString& s2);
BOOL  operator>=(const CString& s1, const char* s2);
BOOL  operator>=(const char* s1, const CString& s2);


////////////////////////////////////////////////////////////////////////////

class CDWordArray
{
public:

// Construction
	CDWordArray();

// Attributes
	int GetSize() const { return m_nSize; }
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	DWORD GetAt(int nIndex) const { return m_pData[nIndex]; }

	void SetAt(int nIndex, DWORD newElement)
	   {	m_pData[nIndex] = newElement; }

	DWORD& ElementAt(int nIndex);

	// Potentially growing the array
	void SetAtGrow(int nIndex, DWORD newElement);
	int Add(DWORD newElement);

	// overloaded operator helpers
	DWORD operator[](int nIndex) const;
	DWORD& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, DWORD newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CDWordArray* pNewArray);

// Implementation
protected:
	DWORD* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CDWordArray();
};


////////////////////////////////////////////////////////////////////////////

class CPtrArray
{
public:

// Construction
	CPtrArray();

// Attributes
	int GetSize() const { return m_nSize; }
	int GetUpperBound() const;
	BOOL SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	void* GetAt(int nIndex) const { return m_pData[nIndex]; }

	void SetAt(int nIndex, void* newElement)
	{ m_pData[nIndex] = newElement; }

	void*& ElementAt(int nIndex);

	// Potentially growing the array
	BOOL SetAtGrow(int nIndex, void* newElement);

	int Add(void* newElement)
	{ int nIndex = m_nSize;
		if(SetAtGrow(nIndex, newElement))
    		return nIndex; 
        else
            return -1;
    }

	// overloaded operator helpers
	void* operator[](int nIndex) const;
	void*& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, void* newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CPtrArray* pNewArray);

// Implementation
protected:
	void** m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CPtrArray();
};


////////////////////////////////////////////////////////////////////////////

class CStringArray
{

public:

// Construction
	CStringArray();

// Attributes
	int GetSize() const { return m_nSize; }
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();


	// Accessing elements
	CString GetAt(int nIndex) const { return m_pData[nIndex]; }

	void SetAt(int nIndex, const char* newElement)
	{ m_pData[nIndex] = newElement; }

	CString& ElementAt(int nIndex)
	{ return m_pData[nIndex]; }

	// Potentially growing the array
	void SetAtGrow(int nIndex, const char* newElement);
	int Add(const char* newElement)
	{ int nIndex = m_nSize;
	      SetAtGrow(nIndex, newElement);
		  return nIndex; }

	// overloaded operator helpers
	CString operator[](int nIndex) const
	{ return GetAt(nIndex); }

	CString& operator[](int nIndex)
      	{ return ElementAt(nIndex); }

	// Operations that move elements around
	void InsertAt(int nIndex, const char* newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CStringArray* pNewArray);

// Implementation
protected:
	CString* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CStringArray();
};

////////////////////////////////////////////////////////////////////////////

class CWordArray
{
public:

// Construction
	CWordArray();

// Attributes
	int GetSize() const { return m_nSize; }
	int GetUpperBound() const;
	void SetSize(int nNewSize, int nGrowBy = -1);

// Operations
	// Clean up
	void FreeExtra();
	void RemoveAll();

	// Accessing elements
	WORD GetAt(int nIndex) const { return m_pData[nIndex]; }
	void SetAt(int nIndex, WORD newElement)
     	{ m_pData[nIndex] = newElement; }
	WORD& ElementAt(int nIndex);

	// Potentially growing the array
	void SetAtGrow(int nIndex, WORD newElement);
	int Add(WORD newElement);

	// overloaded operator helpers
	WORD operator[](int nIndex) const;
	WORD& operator[](int nIndex);

	// Operations that move elements around
	void InsertAt(int nIndex, WORD newElement, int nCount = 1);
	void RemoveAt(int nIndex, int nCount = 1);
	void InsertAt(int nStartIndex, CWordArray* pNewArray);

// Implementation
protected:
	WORD* m_pData;   // the actual array of data
	int m_nSize;     // # of elements (upperBound - 1)
	int m_nMaxSize;  // max allocated
	int m_nGrowBy;   // grow amount

public:
	~CWordArray();
};



/////////////////////////////////////////////////////////////////////////////

class CPtrList
{
protected:
	struct CNode
	{
		CNode* pNext;
		CNode* pPrev;
		void* data;
	};
public:

// Construction
	CPtrList(int nBlockSize=10);

// Attributes (head and tail)
	// count of elements
	int GetCount() const;
	BOOL IsEmpty() const;

	// peek at head or tail
	void*& GetHead();
	void* GetHead() const;
	void*& GetTail();
	void* GetTail() const;

// Operations
	// get head or tail (and remove it) - don't call on empty list !
	void* RemoveHead();
	void* RemoveTail();

	// add before head or after tail
	POSITION AddHead(void* newElement);
	POSITION AddTail(void* newElement);

	// add another list of elements before head or after tail
	void AddHead(CPtrList* pNewList);
	void AddTail(CPtrList* pNewList);

	// remove all elements
	void RemoveAll();

	// iteration
	POSITION GetHeadPosition() const;
	POSITION GetTailPosition() const;
	void*& GetNext(POSITION& rPosition); // return *Position++
	void* GetNext(POSITION& rPosition) const; // return *Position++
	void*& GetPrev(POSITION& rPosition); // return *Position--
	void* GetPrev(POSITION& rPosition) const; // return *Position--

	// getting/modifying an element at a given position
	void*& GetAt(POSITION position);
	void* GetAt(POSITION position) const;
	void SetAt(POSITION pos, void* newElement);
	void RemoveAt(POSITION position);

	// inserting before or after a given position
	POSITION InsertBefore(POSITION position, void* newElement);
	POSITION InsertAfter(POSITION position, void* newElement);

	// helper functions (note: O(n) speed)
	POSITION Find(void* searchValue, POSITION startAfter = NULL) const;
						// defaults to starting at the HEAD
						// return NULL if not found
	POSITION FindIndex(int nIndex) const;
						// get the 'nIndex'th element (may return NULL)

// Implementation
protected:
	CNode* m_pNodeHead;
	CNode* m_pNodeTail;
	int m_nCount;
	CNode* m_pNodeFree;
	struct CPlex* m_pBlocks;
	int m_nBlockSize;

	CNode* NewNode(CNode*, CNode*);
	void FreeNode(CNode*);

public:
	~CPtrList();
};



//-----------------------------------------------------------------
// Inlines from AFX.INL and AFXCOLL.INL
//

#define _AFX_INLINE inline
#define _AFXCOLL_INLINE inline

// CString

_AFX_INLINE int CString::GetAllocLength() const
	{ return m_nAllocLength; }
_AFX_INLINE BOOL CString::IsEmpty() const
	{ return m_nDataLength == 0; }
//_AFX_INLINE int CString::SafeStrlen(const char* psz)
//	{ return (psz == NULL) ? NULL : strlen(psz); }

#ifndef _WINDOWS
_AFX_INLINE int CString::Compare(const char* psz) const
	{ return strcmp(m_pchData, psz); }
_AFX_INLINE int CString::CompareNoCase(const char* psz) const
	{ return stricmp(m_pchData, psz); }
_AFX_INLINE int CString::Collate(const char* psz) const
	{ return strcoll(m_pchData, psz); }
_AFX_INLINE void CString::MakeUpper()
	{ strupr(m_pchData); }
_AFX_INLINE void CString::MakeLower()
	{ strlwr(m_pchData); }
// Windows version in AFXWIN.H
#endif //!_WINDOWS

_AFX_INLINE void CString::MakeReverse()
	{ strrev(m_pchData); }
_AFX_INLINE char CString::GetAt(int nIndex) const
	{
		return m_pchData[nIndex];
	}
_AFX_INLINE char CString::operator[](int nIndex) const
	{
		return m_pchData[nIndex];
	}
_AFX_INLINE void CString::SetAt(int nIndex, char ch)
	{
		m_pchData[nIndex] = ch;
	}

_AFX_INLINE BOOL  operator==(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) == 0; }

_AFX_INLINE BOOL  operator==(const CString& s1, const char* s2)
	{ return s1.Compare(s2) == 0; }

_AFX_INLINE BOOL  operator==(const char* s1, const CString& s2)
	{ return s2.Compare(s1) == 0; }

_AFX_INLINE BOOL  operator!=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) != 0; }

_AFX_INLINE BOOL  operator!=(const CString& s1, const char* s2)
	{ return s1.Compare(s2) != 0; }

_AFX_INLINE BOOL  operator!=(const char* s1, const CString& s2)
	{ return s2.Compare(s1) != 0; }

_AFX_INLINE BOOL  operator<(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) < 0; }
_AFX_INLINE BOOL  operator<(const CString& s1, const char* s2)
	{ return s1.Compare(s2) < 0; }
_AFX_INLINE BOOL  operator<(const char* s1, const CString& s2)
	{ return s2.Compare(s1) > 0; }
_AFX_INLINE BOOL  operator>(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) > 0; }
_AFX_INLINE BOOL  operator>(const CString& s1, const char* s2)
	{ return s1.Compare(s2) > 0; }
_AFX_INLINE BOOL  operator>(const char* s1, const CString& s2)
	{ return s2.Compare(s1) < 0; }
_AFX_INLINE BOOL  operator<=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) <= 0; }
_AFX_INLINE BOOL  operator<=(const CString& s1, const char* s2)
	{ return s1.Compare(s2) <= 0; }
_AFX_INLINE BOOL  operator<=(const char* s1, const CString& s2)
	{ return s2.Compare(s1) >= 0; }
_AFX_INLINE BOOL  operator>=(const CString& s1, const CString& s2)
	{ return s1.Compare(s2) >= 0; }
_AFX_INLINE BOOL  operator>=(const CString& s1, const char* s2)
	{ return s1.Compare(s2) >= 0; }
_AFX_INLINE BOOL  operator>=(const char* s1, const CString& s2)
	{ return s2.Compare(s1) <= 0; }

/////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CWordArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CWordArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE WORD& CWordArray::ElementAt(int nIndex)
	{ return m_pData[nIndex]; }
_AFXCOLL_INLINE int CWordArray::Add(WORD newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
_AFXCOLL_INLINE WORD CWordArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE WORD& CWordArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CDWordArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CDWordArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE DWORD& CDWordArray::ElementAt(int nIndex)
	{ return m_pData[nIndex]; }
_AFXCOLL_INLINE int CDWordArray::Add(DWORD newElement)
	{ int nIndex = m_nSize;
		SetAtGrow(nIndex, newElement);
		return nIndex; }
_AFXCOLL_INLINE DWORD CDWordArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE DWORD& CDWordArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CPtrArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CPtrArray::RemoveAll()
	{ SetSize(0); }
_AFXCOLL_INLINE void*& CPtrArray::ElementAt(int nIndex)
	{ return m_pData[nIndex]; }
_AFXCOLL_INLINE void* CPtrArray::operator[](int nIndex) const
	{ return GetAt(nIndex); }
_AFXCOLL_INLINE void*& CPtrArray::operator[](int nIndex)
	{ return ElementAt(nIndex); }


////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////

_AFXCOLL_INLINE int CStringArray::GetUpperBound() const
	{ return m_nSize-1; }
_AFXCOLL_INLINE void CStringArray::RemoveAll()
	{ SetSize(0); }


////////////////////////////////////////////////////////////////////////////


_AFXCOLL_INLINE int CPtrList::GetCount() const
	{ return m_nCount; }
_AFXCOLL_INLINE BOOL CPtrList::IsEmpty() const
	{ return m_nCount == 0; }
_AFXCOLL_INLINE void*& CPtrList::GetHead()
	{ return m_pNodeHead->data; }
_AFXCOLL_INLINE void* CPtrList::GetHead() const
	{ return m_pNodeHead->data; }
_AFXCOLL_INLINE void*& CPtrList::GetTail()
	{ return m_pNodeTail->data; }

_AFXCOLL_INLINE void* CPtrList::GetTail() const
	{ return m_pNodeTail->data; }

_AFXCOLL_INLINE POSITION CPtrList::GetHeadPosition() const
	{ return (POSITION) m_pNodeHead; }

_AFXCOLL_INLINE POSITION CPtrList::GetTailPosition() const
	{ return (POSITION) m_pNodeTail; }

_AFXCOLL_INLINE void*& CPtrList::GetNext(POSITION& rPosition) // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }

_AFXCOLL_INLINE void* CPtrList::GetNext(POSITION& rPosition) const // return *Position++
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pNext;
		return pNode->data; }

_AFXCOLL_INLINE void*& CPtrList::GetPrev(POSITION& rPosition) // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }

_AFXCOLL_INLINE void* CPtrList::GetPrev(POSITION& rPosition) const // return *Position--
	{ CNode* pNode = (CNode*) rPosition;
		rPosition = (POSITION) pNode->pPrev;
		return pNode->data; }

_AFXCOLL_INLINE void*& CPtrList::GetAt(POSITION position)
	{ CNode* pNode = (CNode*) position;
		return pNode->data; }

_AFXCOLL_INLINE void* CPtrList::GetAt(POSITION position) const
	{ CNode* pNode = (CNode*) position;
		return pNode->data; }

_AFXCOLL_INLINE void CPtrList::SetAt(POSITION pos, void* newElement)
	{ CNode* pNode = (CNode*) pos;
		pNode->data = newElement; }



////////////////////////////////////////////////////////////////////////////


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcompiler\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcompiler\mrcicode.h ===
/*++

Copyright (C) 1994-2001 Microsoft Corporation

Module Name:

    MRCICODE.H

Abstract:

	MRCI 1 & MRCI 2 maxcompress and decompress functions

History:

--*/

#ifdef BIT16
#define     FAR     _far
#else
#ifndef FAR
#define     FAR
#endif
#endif

#ifdef __cplusplus
extern "C"
{
#endif

extern unsigned Mrci1MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax);

extern unsigned Mrci1Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax);

extern unsigned Mrci2MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax);

extern unsigned Mrci2Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcompiler\mrcicode.c ===
/*++

Copyright (C) 1994-2001 Microsoft Corporation

Module Name:

    MRCICODE.C

Abstract:

	MRCI 1 & MRCI 2 maxcompress and decompress functions

History:

--*/

#include "mrcicode.h"                   /* prototype verification */

#define NDEBUG                          /* turn off assertions */
#include <assert.h>                     /* use NDEBUG to inhibit */
#include <setjmp.h>                     /* fast overflow recovery */

#define LOGCHASH        (13)            /* Log of max. no. of hash buckets */
#define CHASH           (1U << LOGCHASH) /* Reasonably large table */

#define hash(w)         ((w) & (CHASH - 1))
                                        /* Simply toss the high-order bits */
#define word(p)         ((p)[0] + (((p)[1]) << 8))
                                        /* Return word at location */

#define BITMASK(x)      ((1 << x) - 1)  /* returns lower 'x' bits set */

#define LOGDISPSMALL    (6)             /* Number of bits in small disp */
#define LOGDISPMED      (8)             /* Number of bits in medium disp */
#define LOGDISPBIG      (12)            /* Number of bits in big displacement */

#define MAXDISPSMALL    ((1 << LOGDISPSMALL) - 1)
                                        /* Maximum small displacement */
#define MAXDISPMED      ((1 << LOGDISPMED) + MAXDISPSMALL)
                                        /* Maximum medium displacement */
#define MAXDISPBIG      ((1 << LOGDISPBIG) + MAXDISPMED)
                                        /* Maximum big displacement */

#define MINDISPSMALL    (0)             /* Minimum small displacement */
#define MINDISPMED      (MAXDISPSMALL + 1)
                                        /* Minimum medium displacement */
#define MINDISPBIG      (MAXDISPMED + 1)/* Minimum big displacement */

#define DISPMAX         (MAXDISPBIG - 1)/* MAXDISPBIG is our end marker */

#define MINMATCH1       (2)             /* Minimum match length for MRCI1 */
#define MINMATCH2       (3)             /* Minimum match length for MRCI2 */
#define MAXMATCH        (512)           /* Maximum match length */

#define EOB             (0)             /* length used to mean end of block */

#define SECTOR          (512)           /* blocking factor */

#define SIG_SIZE        (4)             /* # of block type prefix bytes */


/* local variables */

#ifdef BIT16
#define     FARBSS      _far
#else
#define     FARBSS
#endif

static unsigned abits;                  /* Array of bits */
static unsigned cbitsleft;              /* Number of bits in abits */
static unsigned char FAR *pCompressed;  /* pointer into compressed data */
static unsigned cCompressed;            /* # bytes remaining @ pCompressed */
static jmp_buf bailout;                 /* longjmp if cCompressed exceeded */

static unsigned FARBSS ahash[CHASH];    /* Hash table */
static unsigned FARBSS alink[MAXDISPBIG];  /* Links */


/* compression internal functions */

#ifdef BIT16
#define  FAST  _near _pascal            /* speed up local calls */
#else
#define  FAST
#endif

static void FAST inithash(void);
static void FAST charbuf(unsigned c);
static void FAST putbits(unsigned bits,unsigned cbits);
static void FAST outlength(unsigned cb);

static void FAST mrci1outsingle(unsigned ch);
static void FAST mrci1outstring(unsigned disp,unsigned cb);

static void FAST mrci2outsingle(unsigned ch);
static void FAST mrci2outstring(unsigned disp,unsigned cb);


/* decompression internal functions */

static unsigned FAST getbit(void);
static unsigned FAST getbits(unsigned cbits);
static void FAST expandstring(unsigned char FAR **ppchout,unsigned disp,
        unsigned cb);


/*
 *  (compress) Reset the hash tables between blocks.
 */

static void FAST inithash(void)
{
    unsigned FAR *entry;
    int i;

    entry = ahash;
    i = CHASH;

    do
    {
        *entry++ = (unsigned) -1;       /* Mark all entries as empty */
    } while (--i);
}


/*
 *  (compress) Add a character to compressed output buffer.
 */

static void FAST charbuf(unsigned c)
{
    if (cCompressed-- == 0)             /* make sure there's room */
    {
        longjmp(bailout,1);             /* Data expanding! */
    }

    *pCompressed++ = (unsigned char) c; /* Put character into buffer */
}


/*
 *  (compress) Write n bits to the compressed bitstream.
 */

static void FAST putbits(unsigned ab,unsigned cbits)
{
    do                                  /* Loop to emit bits */
    {
        if (cbits > cbitsleft)          /* if not enough space */
        {
            cbits -= cbitsleft;         /* doing partial */

            abits |= (ab << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            ab >>= cbitsleft;           /* clip sent bits */

            charbuf(abits);             /* Emit the buffer */
            cbitsleft = 8;              /* Reset buffer count */
            abits = 0;                  /* Reset buffer */
        }
        else                            /* can do all in one pass */
        {
            abits |= ((ab & BITMASK(cbits)) << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            cbitsleft -= cbits;         /* used up some buffer */

            if (cbitsleft == 0)         /* If buffer full */
            {
                charbuf(abits);         /* Emit the buffer */
                cbitsleft = 8;          /* Reset buffer count */
                abits = 0;              /* Reset buffer */
            }

            break;                      /* we've done all cbits */
        }
    } while (cbits);                    /* repeat until done */
}


/*
 *  (compress) Encode a length into the compressed stream.
 */

static void FAST outlength(unsigned cb)
{
    unsigned alogbits, clogbits;
    unsigned avaluebits, cvaluebits;

    assert(cb >= 2);                    /* Length must be at least two */
    assert(cb <= MAXMATCH);

    if (cb <= 2)
    {
        alogbits = 1;
        clogbits = 1;
        cvaluebits = 0;
    }
    else if (cb <= 4)
    {
        alogbits = 1 << 1;
        clogbits = 2;
        avaluebits = cb - 3;
        cvaluebits = 1;
    }
    else if (cb <= 8)
    {
        alogbits = 1 << 2;
        clogbits = 3;
        avaluebits = cb - 5;
        cvaluebits = 2;
    }
    else if (cb <= 16)
    {
        alogbits = 1 << 3;
        clogbits = 4;
        avaluebits = cb - 9;
        cvaluebits = 3;
    }
    else if (cb <= 32)
    {
        alogbits = 1 << 4;
        clogbits = 5;
        avaluebits = cb - 17;
        cvaluebits = 4;
    }
    else if (cb <= 64)
    {
        alogbits = 1 << 5;
        clogbits = 6;
        avaluebits = cb - 33;
        cvaluebits = 5;
    }
    else if (cb <= 128)
    {
        alogbits = 1 << 6;
        clogbits = 7;
        avaluebits = cb - 65;
        cvaluebits = 6;
    }
    else if (cb <= 256)
    {
        alogbits = 1 << 7;
        clogbits = 8;
        avaluebits = cb - 129;
        cvaluebits = 7;
    }
    else /* (cb <= 512) */
    {
        alogbits = 1 << 8;
        clogbits = 9;
        avaluebits = cb - 257;
        cvaluebits = 8;
    }

    putbits(alogbits,clogbits);

    if (cvaluebits)
    {
        putbits(avaluebits,cvaluebits);
    }
}


/*
 *  (MRCI1 compress) Encode a literal into the compressed stream.
 */

static void FAST mrci1outsingle(unsigned ch)
{
    ch = (ch << 2) | ((ch & 0x80) ? 1 : 2);

    putbits(ch,9);
}


/*
 *  (MRCI2 compress) Encode a literal into the compressed stream.
 */

static void FAST mrci2outsingle(unsigned ch)
{
    if (ch & 0x80)
    {
        putbits((ch << 2) | 3,9);
    }
    else
    {
        putbits(ch << 1,8);
    }
}


/*
 *  (MRCI1 compress) Encode a match into the compressed stream.
 */

static void FAST mrci1outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH1) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 2),LOGDISPSMALL + 2);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 3) | 3,LOGDISPMED + 3);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 3) | 7,LOGDISPBIG + 3);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb);                  /* Emit the match length */
    }
}


/*
 *  (MRCI2 compress) Encode a match into the compressed stream.
 */

static void FAST mrci2outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH2) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 3) | 1,LOGDISPSMALL + 3);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 4) | 5,LOGDISPMED + 4);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 4) | 13,LOGDISPBIG + 4);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb - 1);              /* Emit the match length */
    }
}


/*
 *  (MRCI1) MaxCompress
 */

unsigned Mrci1MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char FAR *pch;             /* Char pointer */
    unsigned char FAR *pch2;            /* Char pointer */
    unsigned char FAR *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'D';
    *pCompressed++ = 'S';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data expanded */
    }

    cchbest = 0;                        /* no match yet */
    icur = 0;                           /* Initialize */

    for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
    {
        assert(cchbest == 0);           /* must always start with no match */

        if (cch > cchunc)
        {
            cch = cchunc;               /* limit to exact req count */
        }

        pchend = &pchbase[cch];         /* Remember end of buffer */

        while (icur < cch)              /* While at least two chars left */
        {
            /* update hash tables for this character */

            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */

            /* walk hash chain looking for matches */

            while (ilink < icur && icur - ilink <= DISPMAX)
            {                           /* While link is valid and in range */
                pch = &pchbase[icur];   /* Point at first byte */
                pch2 = &pchbase[ilink]; /* Point at first byte */

                if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
                {                       /* If we have a possible best match */
                    pch += 2;           /* Skip first pair */
                    pch2 += 2;          /* Skip first pair */

                    while (pch <= pchend)  /* Loop to find end of match */
                    {
                        if (*pch != *pch2++)
                        {
                            break;      /* Break if mismatch */
                        }
                        pch++;          /* Skip matching character */
                    }

                    if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
                    {                   /* If new best match */
                        cchbest = cchmatch;  /* Remember length */
                        ibest = ilink;  /* Remember position */

                        assert((pch-1) <= pchend);

                        if (pch > pchend)
                        {
                            break;      /* Break if we can't do any better */
                        }
                    }
                }

                assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
                        (alink[ilink % MAXDISPBIG] < ilink));

                ilink = alink[ilink % MAXDISPBIG];
                                        /* Get next link */
            }   /* until end of hash chain reached */

            if (cchbest >= MINMATCH1)   /* If we have a string match */
            {
                mrci1outstring(icur - ibest,cchbest);
                                        /* Describe matching string */
#ifdef VXD
                if (icur + cchbest >= cch )  /* If end of sector reached */
#else
                if (icur + cchbest >= cchunc)  /* If end of buffer reached */
#endif
                {
                    icur += cchbest;    /* Advance the index */
                    cchbest = 0;        /* reset for next match */
                    break;              /* Done if buffer exhausted */
                }

                icur++;                 /* Skip to first unhashed pair */
#ifdef VXD
                /* avoid re-seeding all of a big match */

                if (cchbest > MAXDISPSMALL)
                {                       /* If big match */
                    icur += cchbest - MAXDISPSMALL - 1;
                                        /* Skip ahead */
                    cchbest = MAXDISPSMALL + 1;
                                        /* Use shorter length */
                }
#endif
                /* update hash tables for each add't char in string */

                ibest = icur % MAXDISPBIG;  /* Get current link table index */

                while (--cchbest != 0)  /* Loop to reseed link table */
                {
                    ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
                    ilink = ahash[ihash];  /* Get link index */
                    ahash[ihash] = icur++;  /* Remember position */
                    alink[ibest] = ilink;  /* Chain on rest of list */

                    if (++ibest < MAXDISPBIG)
                    {
                        continue;       /* Loop if we haven't wrapped yet */
                    }

                    ibest = 0;          /* Wrap to zero */
                }

                assert(cchbest == 0);   /* Counter must be 0 */
            }
            else
            {
                mrci1outsingle(pchbase[icur++]);
                                        /* Else output single character */
                cchbest = 0;            /* Reset counter */
            }
        }

        assert(icur == cch || icur == cch + 1);
                                        /* Must be at or past last character */
        if (icur == cch)
        {
#ifndef VXD
            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */
#endif
            mrci1outsingle(pchbase[icur++]);  /* Output last character */
        }

        assert(icur == cch + 1);        /* Must be past last character */

        mrci1outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
    }

    if (cbitsleft != 8)
    {
        charbuf(abits);                 /* Flush bit buffer */
    }

    if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
    {
        return((unsigned) -1);          /* data expanded or not smaller */
    }

    return(pCompressed - pchcmpBase);   /* Return compressed size */
}


/*
 *  (MRCI2) MaxCompress
 */

unsigned Mrci2MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char FAR *pch;             /* Char pointer */
    unsigned char FAR *pch2;            /* Char pointer */
    unsigned char FAR *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'J';
    *pCompressed++ = 'M';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data expanded */
    }

    cchbest = 0;                        /* no match yet */
    icur = 0;                           /* Initialize */

    for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
    {
        assert(cchbest == 0);           /* must always start with no match */

        if (cch > cchunc)
        {
            cch = cchunc;               /* limit to exact req count */
        }

        pchend = &pchbase[cch];         /* Remember end of buffer */

        while (icur < cch)              /* While at least two chars left */
        {
            /* update hash tables for this character */

            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */

            /* walk hash chain looking for matches */

            while (ilink < icur && icur - ilink <= DISPMAX)
            {                           /* While link is valid and in range */
                pch = &pchbase[icur];   /* Point at first byte */
                pch2 = &pchbase[ilink]; /* Point at first byte */

                if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
                {                       /* If we have a possible best match */
                    pch += 2;           /* Skip first pair */
                    pch2 += 2;          /* Skip first pair */

                    while (pch <= pchend)  /* Loop to find end of match */
                    {
                        if (*pch != *pch2++)
                        {
                            break;      /* Break if mismatch */
                        }
                        pch++;          /* Skip matching character */
                    }

                    if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
                    {                   /* If new best match */
                        cchbest = cchmatch;  /* Remember length */
                        ibest = ilink;  /* Remember position */

                        assert((pch-1) <= pchend);

                        if (pch > pchend)
                        {
                            break;      /* Break if we can't do any better */
                        }
                    }
                }

                assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
                        (alink[ilink % MAXDISPBIG] < ilink));

                ilink = alink[ilink % MAXDISPBIG];
                                        /* Get next link */
            }   /* until end of hash chain reached */

            if (cchbest >= MINMATCH2)   /* If we have a string match */
            {
                mrci2outstring(icur - ibest,cchbest);
                                        /* Describe matching string */
#ifdef VXD
                if (icur + cchbest >= cch )  /* If end of sector reached */
#else
                if (icur + cchbest >= cchunc)  /* If end of buffer reached */
#endif
                {
                    icur += cchbest;    /* Advance the index */
                    cchbest = 0;        /* reset for next match */
                    break;              /* Done if buffer exhausted */
                }

                icur++;                 /* Skip to first unhashed pair */
#ifdef VXD
                /* avoid re-seeding all of a big match */

                if (cchbest > MAXDISPSMALL)
                {                       /* If big match */
                    icur += cchbest - MAXDISPSMALL - 1;
                                        /* Skip ahead */
                    cchbest = MAXDISPSMALL + 1;
                                        /* Use shorter length */
                }
#endif
                /* update hash tables for each add't char in string */

                ibest = icur % MAXDISPBIG;  /* Get current link table index */

                while (--cchbest != 0)  /* Loop to reseed link table */
                {
                    ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
                    ilink = ahash[ihash];  /* Get link index */
                    ahash[ihash] = icur++;  /* Remember position */
                    alink[ibest] = ilink;  /* Chain on rest of list */

                    if (++ibest < MAXDISPBIG)
                    {
                        continue;       /* Loop if we haven't wrapped yet */
                    }

                    ibest = 0;          /* Wrap to zero */
                }

                assert(cchbest == 0);   /* Counter must be 0 */
            }
            else
            {
                mrci2outsingle(pchbase[icur++]);
                                        /* Else output single character */
                cchbest = 0;            /* Reset counter */
            }
        }

        assert(icur == cch || icur == cch + 1);
                                        /* Must be at or past last character */
        if (icur == cch)
        {
#ifndef VXD
            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */
#endif
            mrci2outsingle(pchbase[icur++]);  /* Output last character */
        }

        assert(icur == cch + 1);        /* Must be past last character */

        mrci2outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
    }

    if (cbitsleft != 8)
    {
        charbuf(abits);                 /* Flush bit buffer */
    }

    if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
    {
        return((unsigned) -1);          /* data expanded or not smaller */
    }

    return(pCompressed - pchcmpBase);   /* Return compressed size */
}


/*
 *  (decompress) Get a single bit from the compressed input stream.
 */

static unsigned FAST getbit(void)
{
    unsigned bit;                       /* Bit */

    if (cbitsleft)                      /* If bits available */
    {
        cbitsleft--;                    /* Decrement bit count */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }
    else                                /* no bits available */
    {
        if (cCompressed-- == 0)         /* If buffer empty */
        {
            longjmp(bailout,1);         /* input overrun */
        }

        cbitsleft = 7;                  /* Reset count */

        abits = *pCompressed++;         /* Get a byte */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }

    return(bit);                        /* Return the bit */
}


/*
 *  (decompress) Get multiple bits from the compressed input stream.
 */

static unsigned FAST getbits(unsigned cbits)
{
    unsigned bits;                      /* Bits to return */
    unsigned cbitsdone;                 /* number of bits added so far */
    unsigned cbitsneeded;               /* number of bits still needed */

    if (cbits <= cbitsleft)             /* If we have enough bits */
    {
        bits = abits;                   /* Get the bits */
        cbitsleft -= cbits;             /* Decrement bit count */
        abits >>= cbits;                /* Remove used bits */
    }
    else                                /* If we'll need to read more bits */
    {
        bits = 0;                       /* No bits set yet */
        cbitsdone = 0;                  /* no bits added yet */
        cbitsneeded = cbits;            /* bits needed */

        do
        {
            if (cbitsleft == 0)         /* If no bits ready */
            {
                if (cCompressed-- == 0) /* count down used */
                {
                    longjmp(bailout,1); /* if input overrun */
                }

                cbitsleft = 8;          /* Reset count */

                abits = *pCompressed++;  /* Get 8 new bits */
            }

            bits |= (abits << cbitsdone);  /* copy bits for output */

            if (cbitsleft >= cbitsneeded)  /* if enough now */
            {
                cbitsleft -= cbitsneeded;  /* reduce bits remaining available */
                abits >>= cbitsneeded;  /* discard used bits */
                break;                  /* got them */
            }
            else                        /* if not enough yet */
            {
                cbitsneeded -= cbitsleft;  /* reduce bits still needed */
                cbitsdone += cbitsleft;  /* increase shift for future bits */
                cbitsleft = 0;          /* reduce bits remaining available */
            }
        } while (cbitsneeded);          /* go back if more bits needed */
    }

    return(bits & BITMASK(cbits));      /* Return the bits */
}


/*
 *  (decompress) Expand a match.
 *
 *  Note: source overwrite is required (so we can't memcpy or memmove)
 */

static void FAST expandstring(unsigned char FAR **ppchout,unsigned disp,
        unsigned cb)
{
    unsigned char FAR *source;
    unsigned char FAR *target;

    assert(cb != 0);

    target = *ppchout;                  /* where the bytes go */
    source = target - disp;             /* where the bytes come from */

    *ppchout += cb;                     /* Update the output pointer */

    while (cb--)
    {
        *target++ = *source++;
    }
}


/*
 *  (MRCI1) Decompress
 */

unsigned Mrci1Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax)
{
    unsigned b;                         /* A byte */
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char FAR *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'D') || (*pCompressed++ != 'S'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    for (;;)
    {
        b = getbits(2);                 /* get two bits */

        if (b == 1)                     /* If single byte 128..255 */
        {                               /* Get the rest of byte */
            *pchout++ = (unsigned char) (getbits(7) | 0x80);
            continue;                   /* Next token */
        }

        if (b == 2)                     /* If single byte 0..127 */
        {                               /* Get the rest of byte */
            *pchout++ = (unsigned char) getbits(7);
            continue;                   /* Next token */
        }

        if (b == 0)
        {
            disp = getbits(6) + MINDISPSMALL;
        }
        else  /* b == 3 */
        {
            if (getbit() == 0)
            {
                disp = getbits(8) + MINDISPMED;
            }
            else
            {
                disp = getbits(12) + MINDISPBIG;
            }
        }

        if (disp == MAXDISPBIG)
        {
            if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
            {
                break;                  /* End marker found */
            }
            else
            {
                continue;               /* End sector found */
            }
        }

        length = 0;                     /* Initialize */

        while (getbit() == 0)
        {
            length++;                   /* Count the leading zeroes */
        }

        assert(b <= 15);                /* Cannot be too big */

        if (length)
        {
            length = getbits(length) + (1 << length) + 1;
        }
        else
        {
            length = 2;
        }

        expandstring(&pchout,disp,length);  /* Copy the match */
    }

    return((pchout - pchdecBase));      /* Return decompressed size */
}


/*
 *  (MRCI2) Decompress
 */

unsigned Mrci2Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax)
{
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char FAR *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'J') || (*pCompressed++ != 'M'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    for (;;)
    {
        if (getbit() == 0)              /* literal 00..7F */
        {
            *pchout++ = (unsigned char) getbits(7);

            continue;                   /* Next token */
        }

        if (getbit() == 1)              /* literal 80..FF */
        {
            *pchout++ = (unsigned char)(getbits(7) | 0x80);

            continue;                   /* Next token */
        }

        if (getbit() == 0)
        {
            disp = getbits(6) + MINDISPSMALL;
        }
        else
        {
            if (getbit() == 0)
            {
                disp = getbits(8) + MINDISPMED;
            }
            else
            {
                disp = getbits(12) + MINDISPBIG;
            }
        }

        if (disp == MAXDISPBIG)
        {
            if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
            {
                break;                  /* End marker found */
            }
            else
            {
                continue;               /* End sector found */
            }
        }

        length = 0;                     /* Initialize */

        while (getbit() == 0)
        {
            length++;                   /* Count the leading zeroes */
        }

        assert(length <= 15);           /* Cannot be too big */

        if (length)
        {
            length = getbits(length) + (1 << length) + 1;
        }
        else
        {
            length = 2;
        }

        expandstring(&pchout,disp,length + 1);  /* Copy the match */
    }

    return((pchout - pchdecBase));      /* Return decompressed size */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcompiler\mofutils.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MOFUTILS.H

Abstract:

	Declares the MOFUTILS functions.

History:

	a-davj  13-July-97   Created.

--*/

#ifndef __MOFUTILS__H_
#define __MOFUTILS__H_


int Trace(bool bError, DWORD dwID, ...);
void PrintUsage();
BOOL GetVerInfo(TCHAR * pResStringName, TCHAR * pRes, DWORD dwResSize);
BOOL bGetString(char * pIn, WCHAR * pOut);
bool ValidFlags(bool bClass, long lFlags);

class IntString
{
    TCHAR *m_pString;
public:
	 IntString(DWORD dwID);
	~IntString();
    operator TCHAR *() { return m_pString; } 
};

HRESULT ExtractFromResource(
    IMofCompiler * pCompiler,
    LPWSTR pwsResourceName,
    LPWSTR FileName,
    LPWSTR ServerAndNamespace,
    LPWSTR User,
    LPWSTR Authority,
    LPWSTR Password,
    LONG lOptionFlags,             // autocomp, check, etc
    LONG lClassFlags,
    LONG lInstanceFlags,
    WBEM_COMPILE_STATUS_INFO * pInfo,
    BOOL bUseLocale,
    WORD wLocaleId        
        );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcompiler\test\mrcicode.h ===
/*++

Copyright (C) 1994-2001 Microsoft Corporation

Module Name:

    MRCICODE.H

Abstract:

	MRCI 1 & MRCI 2 maxcompress and decompress functions

History:

--*/

#ifdef BIT16
#define     FAR     _far
#else
#ifndef FAR
#define     FAR
#endif
#endif

#ifdef __cplusplus
extern "C"
{
#endif

extern unsigned Mrci1MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax);

extern unsigned Mrci1Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax);

extern unsigned Mrci2MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax);

extern unsigned Mrci2Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcompiler\mofutils.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MOFUTILSD.CPP

Abstract:

    Support of trace output and internationalized strings.

History:

    a-davj  13-July-97   Created.

--*/

#include "precomp.h"
#include <reg.h>
#include "strings.h"
#include <stdio.h>
#include <stdarg.h>
#include <wbemutil.h>
#include <wbemcli.h>
#include <bmof.h>
#include <mrciclass.h>
#include <arrtempl.h>
#include <scopeguard.h>
#include "mofutils.h"

TCHAR JustInCase = 0;
 
//***************************************************************************
//
//  int Trace
//
//  DESCRIPTION:
//
//  Allows for the output function (printf in this case) to be overridden.
//
//  PARAMETERS:
//
//  *fmt                format string.  Ex "%s hello %d"
//  ...                 argument list.  Ex cpTest, 23
//
//  RETURN VALUE:
//
//  size of output in characters.
//***************************************************************************

int Trace(bool bError, DWORD dwID, ...)
{

    IntString is(dwID);
    TCHAR * fmt = is;

    TCHAR *buffer = new TCHAR[2048];
    if(buffer == NULL)
        return 0;
    char *buffer2 = new char[4096];
    if(buffer2 == NULL)
    {
        delete buffer;
        return 0;
    }

    va_list argptr;
    int cnt;
    va_start(argptr, dwID);

#ifdef UNICODE
    cnt = _vsnwprintf(buffer, 2048, fmt, argptr);
#else
    cnt = _vsnprintf(buffer, 2048, fmt, argptr);
#endif
    va_end(argptr);
    CharToOem(buffer, buffer2);

    printf("%s", buffer2);
    if(bError)
        ERRORTRACE((LOG_MOFCOMP,"%s", buffer2));
    else
        DEBUGTRACE((LOG_MOFCOMP,"%s", buffer2));

    delete buffer;
    delete buffer2;
    return cnt;
}

void PrintUsage()
{
    Trace(false, USAGE1);
    Trace(false, USAGE1A);
    Trace(false, USAGE1B);
    Trace(false, USAGE1C);
    Trace(false, USAGE1D);
    Trace(false, USAGE1E);
    Trace(false, USAGE1F);
    Trace(false, USAGE2);
    Trace(false, USAGE3);
    Trace(false, USAGE4);
    Trace(false, USAGE4a);
    Trace(false, USAGE4b);
    Trace(false, USAGE5);
    Trace(false, USAGE6);
    Trace(false, USAGE7);
    Trace(false, USAGE8);
    Trace(false, USAGE9);
    Trace(false, USAGE10);
    Trace(false, USAGE11);
    Trace(false, USAGE12);
    Trace(false, USAGE12A);
    Trace(false, USAGE12B);
    Trace(false, USAGE12C);
    Trace(false, USAGE12D);
    Trace(false, USAGE12E);
    Trace(false, USAGE13);
    Trace(false, USAGE14);
}
//******************************************************************************
//
//  See GETVER.H for documentation
//
//******************************************************************************
BOOL GetVerInfo(TCHAR * pResStringName, 
                        TCHAR * pRes, DWORD dwResSize)
{
    // Extract Version informatio

    DWORD dwTemp, dwSize = MAX_PATH;
    TCHAR cName[MAX_PATH];
    BOOL bRet = FALSE;
    HINSTANCE hInst = GetModuleHandle(NULL);
    long lSize = GetModuleFileName(hInst, cName, MAX_PATH); 
    if(lSize == 0)
        return FALSE;
    lSize = GetFileVersionInfoSize(cName, &dwTemp);
    if(lSize < 1)
        return FALSE;
    
    BYTE * pBlock = new BYTE[lSize];
    if(pBlock != NULL)
    {
        bRet = GetFileVersionInfo(cName, NULL, lSize, pBlock);

        if(bRet)
        {
            TCHAR lpSubBlock[MAX_PATH];
            TCHAR * lpBuffer = NULL;
            UINT wBuffSize = MAX_PATH;

            short * piStuff; 
            bRet = VerQueryValue(pBlock, TEXT("\\VarFileInfo\\Translation") , (void**)&piStuff, &wBuffSize);
            if(bRet)
            {
                wsprintf(lpSubBlock,TEXT("\\StringFileInfo\\%04x%04x\\%ls"),piStuff[0], piStuff[1],L"ProductVersion");
                bRet = VerQueryValue(pBlock, lpSubBlock, (void**)&lpBuffer, &wBuffSize);
            }
            if(bRet == FALSE)
            {
                // Try again in english
                wsprintf(lpSubBlock,TEXT("\\StringFileInfo\\040904E4\\%ls"),pResStringName);                        
                bRet = VerQueryValue(pBlock, lpSubBlock,(void**)&lpBuffer, &wBuffSize);
            }
            if(bRet)
                lstrcpyn(pRes, lpBuffer, dwResSize);
        }

        delete pBlock;
    }
    return bRet;
}


IntString::IntString(DWORD dwID)
{
    DWORD dwSize, dwRet;

    for(dwSize = 128; dwSize < 4096; dwSize *= 2)
    {
        m_pString = new TCHAR[dwSize];
        if(m_pString == NULL)
        {
            m_pString = &JustInCase;     // should never happen!
            return; 
        }
        dwRet = LoadString( GetModuleHandle(NULL), dwID, m_pString, dwSize);

        // Check for failure to load

        if(dwRet == 0)
        {
            delete m_pString;
			m_pString = &JustInCase;     // should never happen!
            return; 
        }
        // Check for the case where the buffer was too small

        if((dwRet + 1) >= dwSize)
            delete m_pString;
        else
            return;             // all is well!
    }
}

IntString::~IntString()
{
    if(m_pString != &JustInCase)
        delete(m_pString);
}
 
//***************************************************************************
//
//  BOOL bGetString
//
//  DESCRIPTION:
//
//  Converts a command line argument into a WCHAR string.  Note that the arugment is 
//  of the form /X:stuff.  This is passed a pointer to the colon.
//
//  PARAMETERS:
//
//  pArg                Input, pointer to the colon
//  pOut                Points the the output buffer where the data is to be copied.
//                      IT IS ASSUMED THAT pOut points to a buffer of MAX_PATH length
//
//
//  RETURN VALUE:
//
//  TRUE if OK
//
//***************************************************************************

BOOL bGetString(char * pIn, WCHAR * pOut)
{
    if(pIn == NULL)
        return FALSE;
    if(*pIn != ':')
    {
        PrintUsage();
        return FALSE;
    }
    pIn++;          // skip passed the colon
    int iLen = mbstowcs(NULL, pIn, strlen(pIn)+1);
    if(iLen > MAX_PATH-1)
    {
        PrintUsage();
        return FALSE;
    }
    
    int iRet = mbstowcs(pOut, pIn, MAX_PATH-1);
    if(iRet < 1)
    {
        PrintUsage();
        return FALSE;
    }
    return TRUE;
}
//***************************************************************************
//
//  ValidFlags.
//
//***************************************************************************

bool ValidFlags(bool bClass, long lFlags)
{
    if(bClass)
        return  ((lFlags == WBEM_FLAG_CREATE_OR_UPDATE) ||
             (lFlags == WBEM_FLAG_UPDATE_ONLY) ||
             (lFlags == WBEM_FLAG_CREATE_ONLY) ||
             (lFlags == WBEM_FLAG_UPDATE_SAFE_MODE) ||
             (lFlags == WBEM_FLAG_UPDATE_FORCE_MODE) ||
             (lFlags == (WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_UPDATE_SAFE_MODE)) ||
             (lFlags == (WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_UPDATE_FORCE_MODE)));
    else
        return 
        ((lFlags == WBEM_FLAG_CREATE_OR_UPDATE) ||
             (lFlags == WBEM_FLAG_UPDATE_ONLY) ||
             (lFlags == WBEM_FLAG_CREATE_ONLY));
}

HRESULT ExtractFromResource(
    IMofCompiler * pCompiler,
        LPWSTR pwsResourceName,
        [in, string] LPWSTR FileName,
        [in, string] LPWSTR ServerAndNamespace,
        [in, string] LPWSTR User,
        [in, string] LPWSTR Authority,
        [in, string] LPWSTR Password,
        [in] LONG lOptionFlags,             // autocomp, check, etc
        [in] LONG lClassFlags,
        [in] LONG lInstanceFlags,
        [in, out] WBEM_COMPILE_STATUS_INFO * pInfo,
        BOOL bUseLocal,
        WORD wLocaleId        
        )
{

    pInfo->lPhaseError = 1;        // 0, 1, 2, or 3 matching current return value
    pInfo->hRes = 0;            // Actual error
    pInfo->ObjectNum = 0;
    pInfo->FirstLine = 0;
    pInfo->LastLine = 0;
    pInfo->dwOutFlags = 0;

    // load the driver that has the resource

    HRESULT hr; 
    HINSTANCE hInst;
    HRSRC hSrc = NULL;
    HGLOBAL hResource;

    // load up the library as a datafile
    
    hInst = LoadLibraryEx(FileName,NULL,LOAD_LIBRARY_AS_DATAFILE);
    if( hInst == NULL )
    {
        pInfo->hRes = GetLastError();
        return pInfo->hRes;
    }

    ON_BLOCK_EXIT(FreeLibrary, hInst);
    
    // Get the handle to the resource

    if( bUseLocal)
    {
        hSrc = FindResourceEx(hInst,pwsResourceName, L"MOFDATA",wLocaleId);
    }
    else
    {
        hSrc = FindResource(hInst,pwsResourceName, L"MOFDATA");
    }
    if( hSrc == NULL )
    {
        pInfo->hRes = GetLastError();
        return pInfo->hRes;
    }

    // Get a pointer to the resource
    hResource = LoadResource( hInst,hSrc);
    if(hResource == NULL)
    {
        pInfo->hRes = GetLastError();
        return pInfo->hRes;
    }
    
    BYTE * pRes = (BYTE *)LockResource(hResource);
    DWORD dwSize = SizeofResource(hInst,hSrc);
    if(pRes == NULL)
    {
        pInfo->hRes = GetLastError();
        return pInfo->hRes;
    }

    // finally do the actual compile
    
    hr = pCompiler->CompileBuffer(
                                                        dwSize,
                                                        pRes,
                                                        ServerAndNamespace,
                                                        User,
                                                        Authority,
                                                        Password,
                                                        lOptionFlags,
                                                        lClassFlags,
                                                        lInstanceFlags,
                                                       pInfo);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcompiler\strings.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    STRINGS.H

Abstract:

	Resource definitions

History:

--*/


#define USAGE1 0
#define USAGE1A USAGE1+1
#define USAGE1B USAGE1A+1
#define USAGE1C USAGE1B+1
#define USAGE1D USAGE1C+1
#define USAGE1E USAGE1D+1
#define USAGE1F  USAGE1E+1
#define USAGE2  USAGE1F+1
#define USAGE3  USAGE2+1
#define USAGE4  USAGE3+1
#define USAGE4a  USAGE4+1
#define USAGE4b  USAGE4a+1
#define USAGE5  USAGE4b+1
#define USAGE6  USAGE5+1
#define USAGE7  USAGE6+1
#define USAGE8  USAGE7+1
#define USAGE9  USAGE8+1
#define USAGE10 USAGE9+1
#define USAGE11 USAGE10+1
#define USAGE12  USAGE11+1
#define USAGE12A  USAGE12+1
#define USAGE12B  USAGE12A+1
#define USAGE12C  USAGE12B+1
#define USAGE12D  USAGE12C+1
#define USAGE12E  USAGE12D+1

#define USAGE13  USAGE12E+1
#define USAGE14  USAGE13+1
#define WMI_ARG_ERROR  USAGE14+1
#define PARSING_MSG     WMI_ARG_ERROR+1
#define FILE_NOT_FOUND  PARSING_MSG+1
#define WMI_NOT_SETUP FILE_NOT_FOUND+1

#define  SUCCESS WMI_NOT_SETUP+1
#define  DONE SUCCESS+1
#define  WMI_LAUNCH_ERROR DONE+1
#define LONGVERSION WMI_LAUNCH_ERROR+1
#define SHORTVERSION LONGVERSION+1
#define COPYRIGHT SHORTVERSION+1
#define CCI_ERROR   COPYRIGHT+1
#define COMINIT_ERROR CCI_ERROR+1
#define COMPILER_ERROR COMINIT_ERROR+1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcompiler\mofcomp.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MOFCOMP.CPP

Abstract:

    Entry points for the WBEM MOF compiler.

History:

    a-davj  12-April-97   Added WMI support.

--*/

#include "precomp.h"
#include <stdio.h>
#include <locale.h>
#include <initguid.h>
#include <wbemidl.h>
#include <winver.h>
#include <cominit.h>
#include <wbemutil.h>
#include <wbemcli.h>
#include <mofcomp.h>
#include <cominit.h>
#include <objidl.h>
#include "mofutils.h"
#include "strings.h"
char cFileName[MAX_PATH];
WCHAR wFileName[MAX_PATH+1];
WCHAR wTempFileName[MAX_PATH];
WCHAR wBMOFFileName[MAX_PATH];
WCHAR wResourceName[MAX_PATH];

int __cdecl main(int argc, char** argv)
{ 
    BOOL bExtractResource = FALSE;
    BOOL bUseLocal = FALSE;
    WORD wLocaleId = 0;
    cFileName[0] = 0;
    wFileName[0] = 0;
    wTempFileName[0] = 0;
    wBMOFFileName[0]= 0;
    wResourceName[0] = 0;
    bool bBmofSet = false;

    // Set locale so that strings are correctly processed.
    // ===================================================
    setlocale(LC_ALL, "");    

    HRESULT hres;
    SCODE sc;

    // Parse command line arguments
    // ============================
    WCHAR UserName[MAX_PATH];
    WCHAR Password[MAX_PATH];
    WCHAR * pPassword = NULL;
    WCHAR Authority[MAX_PATH];
    WCHAR wszDefault[MAX_PATH];

    TCHAR pVersion[100];
    BOOL bRet = GetVerInfo(TEXT("ProductVersion"), pVersion, 100); 
    if(bRet)
    Trace(false, LONGVERSION, pVersion);
    else
    Trace(false, SHORTVERSION);
    Trace(false, COPYRIGHT);
    if(argc < 2)
    {
        PrintUsage();
        return 1;
    }

    // Set locale so that strings are correctly processed.
    // ===================================================
    setlocale(LC_ALL, "");    

    // Init buffers for command line args.
    // ===================================
    UserName[0] = 0;
    Password[0] = 0;
    Authority[0] = 0;
    wszDefault[0] = 0;
    long lLoginFlags = 0;

    // This scope is defined so that the local variables, such as the PARSE 
    // object are destroyed before CoUninitialize is called.

    char cBMOFOutputName[MAX_PATH] = "";

    // Parse command line arguments
    // ============================

    bool bClassFlagsHardcoded = false;
    bool bInstanceFlagsHardcoded = false;
    long lClassFlags = 0;
    long lInstanceFlags = 0;
    long lOptionFlags = WBEM_FLAG_CONSOLE_PRINT;
    
    for(int i = 1; i < argc-1; i++)
    {
        char *pcCurrArg = argv[i] + 1; 
        if(argv[i][0] != '-' && argv[i][0] != '/')
        {
            PrintUsage();
            return 1;
        }
        if(!_stricmp(pcCurrArg, "check"))
        {
            lOptionFlags |= WBEM_FLAG_CHECK_ONLY;
        }
        else if(!_stricmp(pcCurrArg, "AUTORECOVER"))
        {
            lOptionFlags |= WBEM_FLAG_AUTORECOVER;
        }
        else if(!_strnicmp(pcCurrArg, "er:", 3))
        {
            if(strlen(pcCurrArg) <=3)
            {
                PrintUsage();
                return 1;
            }
            bExtractResource = true;
            mbstowcs(wResourceName, pcCurrArg+3, MAX_PATH);
        }
        else if(toupper(pcCurrArg[0]) == 'L' && pcCurrArg[1] == ':')
        {
            bUseLocal = TRUE;
            wLocaleId = (WORD)atoi(&pcCurrArg[2]);
        }
        else if(!_stricmp(pcCurrArg, "WMI"))
        {
            HINSTANCE hLib  = LoadLibraryEx(TEXT("wmimofck.exe"), NULL, LOAD_LIBRARY_AS_DATAFILE);
            if(hLib == NULL)
            {
                Trace(true, WMI_NOT_SETUP);
                return 1;
            }
            else FreeLibrary(hLib);
            lOptionFlags |= WBEM_FLAG_WMI_CHECK;
        }
        else if(!_stricmp(pcCurrArg, "class:updateonly"))
        {
            lClassFlags |= WBEM_FLAG_UPDATE_ONLY;
        }
        else if(!_stricmp(pcCurrArg, "class:createonly"))
        {
            lClassFlags |= WBEM_FLAG_CREATE_ONLY;
        }
        else if(!_stricmp(pcCurrArg, "class:safeupdate"))
        {
            lClassFlags |= WBEM_FLAG_UPDATE_SAFE_MODE;
        }
        else if(!_stricmp(pcCurrArg, "class:forceupdate"))
        {
            lClassFlags |= WBEM_FLAG_UPDATE_FORCE_MODE;
        }
        else if(!_stricmp(pcCurrArg, "instance:updateonly"))
        {
            if(lInstanceFlags != 0)
            {
            PrintUsage();
            return 1;
            }
            lInstanceFlags = WBEM_FLAG_UPDATE_ONLY;
        }
        else if(!_stricmp(pcCurrArg, "instance:createonly"))
        {
            if(lInstanceFlags != 0)
            {
            PrintUsage();
            return 1;
            }
            lInstanceFlags = WBEM_FLAG_CREATE_ONLY;
        }
        else if(!_strnicmp(pcCurrArg, "Amendment:", 10))
        {
            if(strlen(pcCurrArg) <=10)
            {
                PrintUsage();
                return 1;
            }
            strcat(cBMOFOutputName, ",a");
            strcat(cBMOFOutputName, pcCurrArg+10);
            mbstowcs(wBMOFFileName, cBMOFOutputName, MAX_PATH);
            lOptionFlags |= WBEM_FLAG_SPLIT_FILES;
        }
        else if(!_strnicmp(pcCurrArg, "mof:", 4))
        {
            if(strlen(pcCurrArg) <=4)
            {
                PrintUsage();
                return 1;
            }
            strcat(cBMOFOutputName, ",n");
            strcat(cBMOFOutputName, pcCurrArg+4);
            mbstowcs(wBMOFFileName, cBMOFOutputName, MAX_PATH);
            lOptionFlags |= WBEM_FLAG_SPLIT_FILES;
        }
        else if(!_strnicmp(pcCurrArg, "mfl:", 4))
        {
            if(strlen(pcCurrArg) <=4)
            {
                PrintUsage();
                return 1;
            }
            strcat(cBMOFOutputName, ",l");
            strcat(cBMOFOutputName, pcCurrArg+4);
            mbstowcs(wBMOFFileName, cBMOFOutputName, MAX_PATH);
            lOptionFlags |= WBEM_FLAG_SPLIT_FILES;
        }
        else if(toupper(pcCurrArg[0]) == 'C' && pcCurrArg[1] == ':')
        {
            if(lClassFlags != 0)
            {
            PrintUsage();
            return 1;
            }
                bClassFlagsHardcoded = true;
            lClassFlags = atol(&pcCurrArg[2]);
        }
        else if(toupper(pcCurrArg[0]) == 'I' && pcCurrArg[1] == ':')
        {
            if(lInstanceFlags != 0)
            {
            PrintUsage();
            return 1;
            }
                bInstanceFlagsHardcoded = true;
            lInstanceFlags = atol(&pcCurrArg[2]);
        }
        else if(toupper(*pcCurrArg) == 'N')
        {
            if(!bGetString(argv[i]+2, wszDefault))
            return 1;
        }
        else if(toupper(*pcCurrArg) == 'B')
        {
            if(strlen(argv[i]) <=3 || argv[i][2] != ':' || wcslen(wBMOFFileName))
            {
                PrintUsage();
                return 1;
            }
            strcpy(cBMOFOutputName, argv[i]+3);
            mbstowcs(wBMOFFileName, cBMOFOutputName, MAX_PATH);
            bBmofSet = true;
        }
        else if(toupper(*pcCurrArg) == 'U')
        {
            if(!bGetString(argv[i]+2, UserName))
            return 1;
        }
        else if(toupper(*pcCurrArg) == 'P')
        {
            // Allow for blank password
    
            char * pArg = argv[i];
            if(pArg[2] != ':' || pArg[3] != 0)         // Dont use bGetString for empty password case
            if(!bGetString(argv[i]+2, Password))
                return 1;
            pPassword = Password;
        }
        else if(toupper(*pcCurrArg) == 'A')
        {
            if(!bGetString(argv[i]+2, Authority))
            return 1;
        }

        else
        {
            PrintUsage();
            return 1;
        }
    }


    // Do a sanity check of the flags chosen

    if((bClassFlagsHardcoded == false && !ValidFlags(true, lClassFlags)) || 
       (bInstanceFlagsHardcoded == false && !ValidFlags(false, lInstanceFlags)))
    {
        PrintUsage();
        return 1;
    }

    if((lOptionFlags & WBEM_FLAG_WMI_CHECK) && strlen(cBMOFOutputName) < 1)
    {
        Trace(true, WMI_ARG_ERROR);
        return 1;
    }
    if(strcmp(argv[argc-1], "-?") == 0 || strcmp(argv[argc-1], "/?") == 0)
    {
        PrintUsage();
        return 1;
    }
    if((lOptionFlags & WBEM_FLAG_SPLIT_FILES) && bBmofSet)
    {
        PrintUsage();
        return 1;
    }
    

    // display the file name and make sure it is a valid file

    strcpy(cFileName, argv[argc-1]);
    mbstowcs(wTempFileName, argv[argc-1], MAX_PATH);
	DWORD nRes = ExpandEnvironmentStrings(wTempFileName,
										  wFileName,
										  FILENAME_MAX);
    if(nRes == 0)
        lstrcpy(wFileName, wTempFileName);

    if(GetFileAttributesW(wFileName) == 0xFFFFFFFF)
    {
        Trace(true, FILE_NOT_FOUND, wFileName);
        return 1;
    }


    hres = InitializeCom();
    if(FAILED(hres))
    {
        Trace(true, COMINIT_ERROR, hres);
        return 3;
    }

    WBEM_COMPILE_STATUS_INFO info;
    hres = InitializeSecurity(NULL, -1, NULL, NULL, 
                                RPC_C_AUTHN_LEVEL_DEFAULT, 
                                RPC_C_IMP_LEVEL_IDENTIFY, 
                                NULL, EOAC_NONE, 0);

    IMofCompiler * pCompiler = NULL;
    sc = CoCreateInstance(CLSID_MofCompiler, 0, CLSCTX_INPROC_SERVER,
                                    IID_IMofCompiler, (LPVOID *) &pCompiler);
    
    // special fix that will self register the mofd.dll if it isnt already registered

    if(sc != S_OK)
    {
        HRESULT (STDAPICALLTYPE *pFunc)(void);
        HINSTANCE hLib = LoadLibrary(TEXT("mofd.dll"));
        if(hLib)
        {
            pFunc = (HRESULT (STDAPICALLTYPE *)(void))GetProcAddress(hLib, "DllRegisterServer");
            if(pFunc)
            {
                pFunc();
                sc = CoCreateInstance(CLSID_MofCompiler, 0, CLSCTX_INPROC_SERVER,
                                    IID_IMofCompiler, (LPVOID *) &pCompiler);
            }
            FreeLibrary(hLib);
        }
    }
    
    if(sc == S_OK)
    {
        if(strlen(cBMOFOutputName) > 0)
            sc = pCompiler->CreateBMOF( wFileName, wBMOFFileName, wszDefault,
                        lOptionFlags, lClassFlags,
                            lInstanceFlags, &info);
        else if (bExtractResource)
            sc = ExtractFromResource(pCompiler, wResourceName, wFileName, wszDefault, 
                            UserName, Authority, pPassword, lOptionFlags, lClassFlags,
                            lInstanceFlags, &info,
                            bUseLocal,
                            wLocaleId);
        else
            sc = pCompiler->CompileFile(wFileName, wszDefault, UserName, 
                            Authority, pPassword, lOptionFlags, lClassFlags,
                            lInstanceFlags, &info);
        if(sc != S_OK)
            Trace(true, COMPILER_ERROR, info.hRes);

        pCompiler->Release();
        
    }
    else
    {
        Trace(true, CCI_ERROR, sc);
        return 3;
    }

    CoUninitialize();

    if(sc == S_OK)
    {
        Trace(true, DONE);
        return 0;
    }
    else
        return info.lPhaseError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcompiler\test\bmof.c ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    BMOF.C

Abstract:

    Structures and helper functions for naviagating a BMOF file.

History:

    a-davj  14-April-97   Created.

--*/

#include <windows.h>
#include <oleauto.h>
#include <string.h>
#include "bmof.h"
#include <wbemutil.h>

int wmi_unaligned_wcslen( LPCWSTR wszString )
{
    BYTE*   pbData = (BYTE*) wszString;
	int i;

    // Walk the string looking for two 0 bytes next to each other.
    for( i =0; !(!*(pbData) && !*(pbData+1) ); pbData+=2, i++ );

    return i;
}

WCHAR* wmi_unaligned_wcscpy( WCHAR* wszDest, LPCWSTR wszSource )
{
    int nLen = wmi_unaligned_wcslen( wszSource );

    // Account for the NULL terminator when copying
    CopyMemory( (BYTE*) wszDest, (BYTE*) wszSource, (nLen+1) * 2 );

    return wszDest;
}

//***************************************************************************
//
//  BOOL LookupFlavor
//
//  DESCRIPTION:
//
//  Looks in the flavor table to see if a qualifier has a flavor.
//
//  PARAMETERS:
//
//  pQual      Pointer to the qualifier.
//  pdwFlavor  Pointer to where the return value is put
//  pBuff      Pointer to the main buffer.  I.e. "BMOF...."
//  pToFar	   Pointer to 1 past the last byte in the buffer
//
//
//  RETURN VALUE:
//
//  TRUE if there is a flavor.  Note that failure is normal
//
//***************************************************************************

BOOL LookupFlavor(BYTE * pQual, DWORD * pdwFlavor, BYTE * pBuff, BYTE * pToFar)
{
    UNALIGNED DWORD * pTemp;
    BYTE * pFlavorBlob;
    DWORD dwNumPairs;
    UNALIGNED DWORD * pOffset;
    UNALIGNED DWORD * pFlavor;
    DWORD dwMyOffset;
    DWORD dwCnt;

    *pdwFlavor = 0;

    // Calculate the pointer of the start of the flavor data

    pTemp = (DWORD * )pBuff;
    pTemp++;                            // point to the original blob size
    pFlavorBlob = pBuff + *pTemp;

	// Dont even try past the end of memory

	if(pToFar == NULL)
		return FALSE;

	if(pFlavorBlob + 16 >= pToFar)
		return FALSE;

    // Check if the flavor blob is valid, it should start off with the 
    // characters "BMOFQUALFLAVOR11"

    if(memcmp(pFlavorBlob, "BMOFQUALFLAVOR11", 16))
        return FALSE;                               // Not really a problem since it may be old file
    
    // The flavor part of the file has the format 
    // DWORD dwNumPair, followed by pairs of dwords;
    // offset, flavor

    // Determine the number of pairs

    pFlavorBlob+= 16;
    pTemp = (DWORD *)pFlavorBlob;
    dwNumPairs = *pTemp;              // Number of offset/value pairs
    if(dwNumPairs < 1)
        return FALSE;

    // point to the first offset/flavor pair

    pOffset = pTemp+1;
    pFlavor = pOffset+1;

    // Determine the offset we are looking for.  That is the pointer to the qualifier minus
    // the pointer to the start of the block;

    dwMyOffset = (DWORD)(pQual - pBuff);

    for(dwCnt = 0; dwCnt < dwNumPairs; dwCnt++)
    {
        if(dwMyOffset == *pOffset)
        {
            *pdwFlavor = *pFlavor;
        }
        if(dwMyOffset < *pOffset)
            return FALSE;
        pOffset += 2;
        pFlavor += 2;
    }
    return FALSE;
}

//***************************************************************************
//
//  int ITypeSize
//
//  DESCRIPTION:
//
//  Gets the number of bytes acutally used to store
//  a variant type.  0 if the type is unknown
//
//  PARAMETERS:
//
//  vtTest      Type in question.
//
//
//  RETURN VALUE:
//
//  see description
//
//***************************************************************************

int iTypeSize(
        IN DWORD vtTest)
{
    int iRet;
    vtTest &= ~ VT_ARRAY; // get rid of possible array bit
    vtTest &= ~ VT_BYREF; // get rid of possible byref bit

    switch (vtTest) {
        case VT_UI1:
        case VT_LPSTR:
            iRet = 1;
            break;
        case VT_LPWSTR:
        case VT_BSTR:
        case VT_I2:
            iRet = 2;
            break;
        case VT_I4:
        case VT_R4:
            iRet = 4;
            break;
        case VT_R8:
            iRet = 8;
            break;
        case VT_BOOL:
            iRet = sizeof(VARIANT_BOOL);
            break;
        case VT_ERROR:
            iRet = sizeof(SCODE);
            break;
        case VT_CY:
            iRet = sizeof(CY);
            break;
        case VT_DATE:
            iRet = sizeof(DATE);
            break;

        default:
            iRet = 0;
        }
    return iRet;
}


//***************************************************************************
//
//  CBMOFQualList * CreateQualList
//
//  DESCRIPTION:
//
//  Create a CBMOFQualList object which serves as a wrapper.
//
//  PARAMETERS:
//
//  pwql                 pointer to the WBEM_Qualifier structure in the binary
//                      MOF.
//
//  RETURN VALUE:
//
//  Pointer to CBMOFQualList structure that servers as a wrapper.  NULL
//  if error.  This must be freed via BMOFFree() when no longer needed.
//
//
//***************************************************************************

CBMOFQualList * CreateQualList(UNALIGNED WBEM_QualifierList *pwql)
{

    CBMOFQualList * pRet = NULL;
    if(pwql == NULL)
      return NULL;


    pRet = (CBMOFQualList *)BMOFAlloc(sizeof (CBMOFQualList));
    if(pRet != NULL)
    {
        pRet->m_pql = pwql;
        pRet->m_pInfo = (UNALIGNED WBEM_Qualifier *)
            ((BYTE *)pRet->m_pql + sizeof(WBEM_QualifierList));;
        ResetQualList(pRet);
    }
    return pRet;
}


//***************************************************************************
//
//  void ResetQualList
//
//  DESCRIPTION:
//
//  Resets CBMOFQualList stucture to point to the first entry.
//
//  PARAMETERS:
//
//  pql                 structure to be reset
//
//***************************************************************************

void ResetQualList(CBMOFQualList * pql)
{
   if(pql)
   {
      pql->m_CurrQual = 0;
      pql->m_pCurr = pql->m_pInfo;
   }
}

//***************************************************************************
//
//  BOOL NextQual
//
//  DESCRIPTION:
//
//  Gets the name and value of the next qualifier in the list.
//
//  PARAMETERS:
//
//  pql                 Input, points to CBMOFQualList object with data
//  ppName              Output, if functions succeeds, this points to a 
//                      WCHAR string that the caller must free.  May be
//                      NULL if caller doesnt want name.
//  pItem               Input/Output, if set, points to a data item structure
//                      which will be updated to point to the qualifier data.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//
//***************************************************************************

BOOL NextQual(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem)
{
    return NextQualEx(pql, ppName, pItem, NULL, NULL, NULL);
}


//***************************************************************************
//
//  BOOL NextQualEx
//
//  DESCRIPTION:
//
//  Gets the name and value of the next qualifier in the list.
//
//  PARAMETERS:
//
//  pql                 Input, points to CBMOFQualList object with data
//  ppName              Output, if functions succeeds, this points to a 
//                      WCHAR string that the caller must free.  May be
//                      NULL if caller doesnt want name.
//  pItem               Input/Output, if set, points to a data item structure
//                      which will be updated to point to the qualifier data.
//  pdwFlavor           optional, pointer to where the flavor value is to be copied
//                      if not null, then pBuff must be set!
//  pBuff               Pointer to the starting byte of the whole blob.  Same as 
//                      whats copied to CreateObjList.
//  pToFar              Pointer to one past the end of the memory buffer
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//
//***************************************************************************

BOOL NextQualEx(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem,
                                            DWORD * pdwFlavor, BYTE * pBuff, BYTE * pToFar)
{
    BYTE * pInfo;
    BOOL bRet = TRUE;

    if(pql == NULL || pql->m_CurrQual++ >= pql->m_pql->dwNumQualifiers)
        return FALSE;

    if(pdwFlavor && pBuff)
        LookupFlavor((BYTE *)pql->m_pCurr, pdwFlavor, pBuff, pToFar);
 
    pInfo = (BYTE *)pql->m_pCurr + sizeof(WBEM_Qualifier);
    
    if(ppName)
      SetName(ppName, pInfo, pql->m_pCurr->dwOffsetName);

    if(pInfo)
      bRet = SetValue(pItem, pInfo, pql->m_pCurr->dwOffsetValue, 
                        pql->m_pCurr->dwType);

    // advance to next
    pql->m_pCurr = (UNALIGNED WBEM_Qualifier *)((BYTE *)pql->m_pCurr + pql->m_pCurr->dwLength);
    return bRet;
}

//***************************************************************************
//
//  BOOL FindQual
//
//  DESCRIPTION:
//
//  Searches for a qualifier with a given name.  The search is case 
//  insensitive
//
//  PARAMETERS:
//
//  pql                 Input, pointer to qualifier list
//  pName               Input, Name to be searched for.
//  pItem               Input/Output, if successful set to point to the data.
//
//  RETURN VALUE:
//
//  True if OK.
//
//***************************************************************************

BOOL FindQual(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem)
{
    return FindQualEx(pql, pName, pItem, NULL, NULL, NULL);
}

//***************************************************************************
//
//  BOOL FindQualEx
//
//  DESCRIPTION:
//
//  Searches for a qualifier with a given name.  The search is case 
//  insensitive
//
//  PARAMETERS:
//
//  pql                 Input, pointer to qualifier list
//  pName               Input, Name to be searched for.
//  pItem               Input/Output, if successful set to point to the data.
//  pdwFlavor           optional, pointer to where the flavor value is to be copied
//                      if not null, then pBuff must be set!
//  pBuff               Pointer to the starting byte of the whole blob.  Same as 
//                      whats copied to CreateObjList.
//
//  RETURN VALUE:
//
//  True if OK.
//
//***************************************************************************

BOOL FindQualEx(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem, 
                                          DWORD * pdwFlavor, BYTE * pBuff, BYTE * pToFar)
{
    DWORD dwCnt;
    UNALIGNED WBEM_Qualifier * pQual = pql->m_pInfo;
    for(dwCnt = 0; dwCnt < pql->m_pql->dwNumQualifiers; dwCnt++)
    {
        WCHAR * pTest;
        BOOL bMatch;
        BYTE * pInfo = (BYTE *)pQual + sizeof(WBEM_Qualifier);
        if(!SetName(&pTest, pInfo, pQual->dwOffsetName))
            return FALSE;

        bMatch = !_wcsicmp(pTest, pName);
        BMOFFree(pTest);
        if(bMatch)
        {
            if(pdwFlavor && pBuff)
                LookupFlavor((BYTE *)pQual, pdwFlavor, pBuff, pToFar);
            return SetValue(pItem, pInfo, pQual->dwOffsetValue, pQual->dwType);
        }
        pQual = (UNALIGNED WBEM_Qualifier *)((BYTE *)pQual + pQual->dwLength);
    }
    return FALSE;
}

//***************************************************************************
//
//  BOOL SetValue
//
//  DESCRIPTION:
//
//  Sets up a CBMOFDataItem structure to point to a value in the BMOF.
//
//  PARAMETERS:
//
//  pItem               Input/Output, item to be set
//  pInfo               Input, start of information block
//  dwOffset            Input, offset to actual data.
//  dwType              Input data type.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL SetValue(CBMOFDataItem * pItem, BYTE * pInfo, DWORD dwOffset, DWORD dwType)
{

    if(pItem == NULL || pInfo == NULL)
        return FALSE;

    pItem->m_dwType = dwType;

    // Check for NULL case.  This is how uninitialized data is stored.

    if(dwOffset == 0xffffffff)
        pItem->m_pData = NULL;
    else
        pItem->m_pData = pInfo + dwOffset;

    return TRUE;
}

//***************************************************************************
//
//  BOOL SetName
//
//  DESCRIPTION:
//
//  Gets a name out of an information block.
//
//  PARAMETERS:
//
//  ppName              Input/Output.  On successful return, will point to a
//                      WCHAR string containing the name.  This MUST be freed
//                      by the caller via BMOFFree()!
//  pInfo               Input, start of information block
//  dwOffset            Input, offset to actual data.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//***************************************************************************

BOOL SetName(WCHAR ** ppName, BYTE * pInfo, DWORD dwOffset)
{
    UNALIGNED WCHAR * pName;
    if(ppName == NULL || pInfo == NULL || dwOffset == 0xffffffff)
        return FALSE;

    pName = (UNALIGNED WCHAR *)(pInfo + dwOffset);   // point to string in info block
    *ppName = (WCHAR *)BMOFAlloc(2*(wmi_unaligned_wcslen((LPWSTR)pName) + 1));
    if(*ppName == NULL)
        return FALSE;
    wmi_unaligned_wcscpy(*ppName, (LPWSTR)pName);
    return TRUE;
}

//***************************************************************************
//
//  CBMOFObj * CreateObj
//
//  DESCRIPTION:
//
//  Create a CBMOFObj structure which wraps a WBEM_Object
//
//  PARAMETERS:
//
//  pwob                Input, structure to be wrapped
//
//  RETURN VALUE:
//
//  pointer to wrapper structure.  NULL if error.  This must be freed via
//  BMOFFree() when no longer needed.
//
//***************************************************************************

CBMOFObj * CreateObj(UNALIGNED WBEM_Object * pwob)
{
    CBMOFObj * pRet = (CBMOFObj *)BMOFAlloc(sizeof(CBMOFObj));
    if(pRet)
     {
        pRet->m_pob = pwob;
        pRet->m_pInfo = ((BYTE *)pwob) + sizeof(WBEM_Object);
        pRet->m_ppl = (WBEM_PropertyList*)(pRet->m_pInfo +
                                        pwob->dwOffsetPropertyList);
        pRet->m_pml = (WBEM_PropertyList*)(pRet->m_pInfo +
                                        pwob->dwOffsetMethodList);
        ResetObj(pRet);
     }
    return pRet;
}


//***************************************************************************
//
//  void ResetObj
//
//  DESCRIPTION:
//
//  Resets a CBMOFObj structure so that it points to its first property.
//
//  PARAMETERS:
//
//  pob                 Input/Output, stucture to be reset.
//
//***************************************************************************

void ResetObj(CBMOFObj * pob)
{
   if(pob)
   {
      pob->m_CurrProp = 0;
      pob->m_pCurrProp = (UNALIGNED WBEM_Property *) ((BYTE *)pob->m_ppl +
                                    sizeof(WBEM_PropertyList));
      pob->m_CurrMeth = 0;
      pob->m_pCurrMeth = (UNALIGNED WBEM_Property *) ((BYTE *)pob->m_pml +
                                    sizeof(WBEM_PropertyList));
   }
}

//***************************************************************************
//
//  CBMOFQualList * GetQualList
//
//  DESCRIPTION:
//
//  Returns a CBMOFQualList structure which wraps the objects qualifier list.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//
//  RETURN VALUE:
//
//  Pointer to CBMOFQualList stucture.  NULL if error.  Note that this must
//  be freed by the caller via BMOFFree()
//
//***************************************************************************

CBMOFQualList * GetQualList(CBMOFObj * pob)
{

    UNALIGNED WBEM_QualifierList *pql;
    if(pob->m_pob->dwOffsetQualifierList == 0xffffffff)
        return NULL;
    pql = (UNALIGNED WBEM_QualifierList *)((BYTE *)pob->m_pInfo+
                            pob->m_pob->dwOffsetQualifierList);
    return CreateQualList(pql);
}


//***************************************************************************
//
//  CBMOFQualList * GetPropQualList
//  CBMOFQualList * GetMethQualList
//
//  DESCRIPTION:
//
//  Returns a CBMOFQualList structure which wraps a property or
//  methods qualifier list.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  pName               Input.  Property name.  Note that this is case
//                      insensitive.
//
//  RETURN VALUE:
//
//  Pointer to CBMOFQualList stucture.  NULL if error.  Note that this must
//  be freed by the caller via BMOFFree()
//
//***************************************************************************

CBMOFQualList * GetPropOrMethQualList(UNALIGNED WBEM_Property * pProp)
{
    if(pProp == NULL)
        return NULL;
    if(pProp->dwOffsetQualifierSet == 0xffffffff)
        return NULL;
    return CreateQualList((UNALIGNED WBEM_QualifierList *)(
                                    (BYTE *)pProp + sizeof(WBEM_Property)+
                                    pProp->dwOffsetQualifierSet));
}

CBMOFQualList * GetPropQualList(CBMOFObj * pob, WCHAR * pName)
{
    UNALIGNED WBEM_Property * pProp = FindPropPtr(pob, pName);
    return GetPropOrMethQualList(pProp);
}

CBMOFQualList * GetMethQualList(CBMOFObj * pob, WCHAR * pName)
{
    UNALIGNED WBEM_Property * pProp = FindMethPtr(pob, pName);
    return GetPropOrMethQualList(pProp);
}

//***************************************************************************
//
//  BOOL NextProp
//  BOOL NextMet
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  ppName              Output, if functions succeeds, this points to a
//                      WCHAR string that the caller must free.  May be
//                      NULL if caller doesnt want name.
//  pItem               Input/Output, if set, points to a data item structure
//                      which will be updated to point to the qualifier data.
///
//  RETURN VALUE:
//
//  TRUE if OK.
//***************************************************************************

BOOL Info(UNALIGNED WBEM_Property * pPropOrMeth, WCHAR ** ppName, CBMOFDataItem * pItem)
{
    BYTE * pInfo;
    BOOL bRet = TRUE;
    if(pPropOrMeth == NULL)
        return FALSE;

    pInfo = (BYTE *)pPropOrMeth + sizeof(WBEM_Property);
    if(ppName)
       SetName(ppName, pInfo, pPropOrMeth->dwOffsetName);
    if(pItem)
       bRet = SetValue(pItem, pInfo,
                        pPropOrMeth->dwOffsetValue,
                        pPropOrMeth->dwType);
    return bRet;
}

BOOL NextProp(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem)
{
    BOOL bRet = TRUE;

    if(pob == FALSE || pob->m_CurrProp++ >= pob->m_ppl->dwNumberOfProperties)
        return FALSE;

    Info(pob->m_pCurrProp, ppName, pItem);

    // advance pointer to next property.

    pob->m_pCurrProp = (UNALIGNED WBEM_Property *)
                        ((BYTE *)pob->m_pCurrProp + pob->m_pCurrProp->dwLength);
    return bRet;
}

BOOL NextMeth(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem)
{
    BOOL bRet = TRUE;

    if(pob == FALSE || pob->m_CurrMeth++ >= pob->m_pml->dwNumberOfProperties)
        return FALSE;

    Info(pob->m_pCurrMeth, ppName, pItem);

    // advance pointer to next method.

    pob->m_pCurrMeth = (UNALIGNED WBEM_Property *)
                        ((BYTE *)pob->m_pCurrMeth + pob->m_pCurrMeth->dwLength);
    return bRet;
}

//***************************************************************************
//
//  BOOL FindProp
//  BOOL FindMeth
//
//  DESCRIPTION:
//
//  Sets a CBMOFDataItem structure to point to a properties data.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  pName               Input. Name to be use for case insensitve search.
//  pItem               Input/Output.  Data item stucture to be updated.
//
//  RETURN VALUE:
//
//  True if found.
//
//***************************************************************************

BOOL FindProp(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem)
{
    UNALIGNED WBEM_Property * pProp = FindPropPtr(pob, pName);
    return Info(pProp, NULL, pItem);
}

BOOL FindMeth(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem)
{
    UNALIGNED WBEM_Property * pProp = FindMethPtr(pob, pName);
    return Info(pProp, NULL, pItem);
}

//***************************************************************************
//
//  BOOL GetName
//
//  DESCRIPTION:
//
//  Gets the name of an object.  This is works be returning the "__Class"
//  property.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  ppName              Input/Output.  Points to a WCHAR string which
//                      has the name.  The caller MUST free this via
//                      BMOFFree()
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL GetName(CBMOFObj * pob, WCHAR ** ppName)
{
    CBMOFDataItem Item;
    BOOL bRet = FALSE, bFound;
    if(pob == NULL || ppName == NULL)
        return FALSE;

    bFound = FindProp(pob, L"__Class", &Item);
    if(!bFound)
        return FALSE;
    if(Item.m_dwType == VT_BSTR  && ppName)
    {
        bRet = GetData(&Item, (BYTE *)ppName, NULL);
    }
    return bRet;
}


//***************************************************************************
//
//  DWORD GetType
//
//  DESCRIPTION:
//
//  Returns an objects type.  A 0 indicates a class while a 1 indicates an
//  instance.  A 0xffffffff if passed a null pointer.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//
//
//  RETURN VALUE:
//
//  See description.
//
//***************************************************************************

DWORD GetType(CBMOFObj * pob)
{
   if(pob)
      return pob->m_pob->dwType;
   else
      return 0xFFFFFFFF;
}

//***************************************************************************
//
//  WBEM_Property * FindPropPtr
//  WBEM_Property * FindMethPtr
//
//  DESCRIPTION:
//
//  Returns a WBEM_Property stucture pointer for a particular property or
//  method given its name.
//
//  PARAMETERS:
//
//  pob                 Input.  Structure which wraps the object.
//  pName               Input.  Name of property.  Comparison is case
//                      insensitive.
//
//  RETURN VALUE:
//
//  pointer to WBEM_Property, NULL if it cant be found.
//
//***************************************************************************

UNALIGNED WBEM_Property *  Search(BYTE * pList, DWORD dwListSize, WCHAR * pName)
{
    DWORD dwCnt;
    UNALIGNED WBEM_Property * pProp = NULL;

    // point to first property structure

    pProp = (UNALIGNED WBEM_Property *)(pList + sizeof(WBEM_PropertyList));

    for(dwCnt = 0; dwCnt < dwListSize; dwCnt++)
    {
        WCHAR * pTest;
        BOOL bMatch;

        // point to the property's name and retrieve it

        BYTE * pInfo = (BYTE *)pProp + sizeof(WBEM_Property);
        if(!SetName(&pTest, pInfo, pProp->dwOffsetName))
            return NULL;
        bMatch = !_wcsicmp(pTest, pName);
        BMOFFree(pTest);

        // If we have a match, return

        if(bMatch)
            return pProp;

        pProp = (UNALIGNED WBEM_Property *)((BYTE *)pProp + pProp->dwLength);
    }
    return NULL;
}

UNALIGNED WBEM_Property * FindPropPtr(CBMOFObj * pob, WCHAR * pName)
{
    if(pob == NULL || pName == NULL)
      return NULL;

    // point to first property structure

    return Search((BYTE *)pob->m_ppl, pob->m_ppl->dwNumberOfProperties, pName);
}

UNALIGNED WBEM_Property * FindMethPtr(CBMOFObj * pob, WCHAR * pName)
{
    if(pob == NULL || pName == NULL)
      return NULL;

    // point to first property structure

    return Search((BYTE *)pob->m_pml, pob->m_pml->dwNumberOfProperties, pName);
}


//***************************************************************************
//
//  CBMOFObjList * CreateObjList
//
//  DESCRIPTION:
//
//  Create a CBMOFObjList structure which wraps a BMOF file.
//
//  PARAMETERS:
//
//  pBuff                Input, points to start of BMOF file.
//
//  RETURN VALUE:
//
//  pointer to wrapper structure.  NULL if error.  This must be freed via
//  BMOFFree() when no longer needed.
//
//***************************************************************************

CBMOFObjList * CreateObjList(BYTE * pBuff)
{
    CBMOFObjList * pRet = (CBMOFObjList * )BMOFAlloc(sizeof(CBMOFObjList));
    if(pRet)
    {
        pRet->m_pol = (WBEM_Binary_MOF *)pBuff;
        pRet->m_pInfo = (WBEM_Object *)
                   ((BYTE *)pBuff + sizeof(WBEM_Binary_MOF));
        ResetObjList(pRet);
    }
    return pRet;
}


//***************************************************************************
//
//  void ResetObjList
//
//  DESCRIPTION:
//
//  Resets a CBMOFObjList structure so that it points to its first object.
//
//  PARAMETERS:
//
//  pol                 Input/Output, stucture to be reset.
//
//***************************************************************************

void ResetObjList(CBMOFObjList * pol)
{
   if(pol)
   {
      pol->m_pCurrObj = pol->m_pInfo;
      pol->m_CurrObj = 0;
   }
}

//***************************************************************************
//
//  CBMOFObj * NextObj
//
//  DESCRIPTION:
//
//  Gets the next object in the list.
//
//  PARAMETERS:
//
//  pol                 Input. Pointer to CBMOFObjList object
//
//  RETURN VALUE:
//
//  Pointer to a CBMOFObj stucture which can be use to access the object
//  information.  NULL if error.  Note that the caller MUST Free this via
//  BMOFFree().
//
//***************************************************************************

CBMOFObj * NextObj(CBMOFObjList *pol)
{
    CBMOFObj * pRet;

    if(pol == NULL || pol->m_CurrObj++ >= pol->m_pol->dwNumberOfObjects)
        return NULL;

    pRet = CreateObj(pol->m_pCurrObj);
    pol->m_pCurrObj = (UNALIGNED WBEM_Object *)((BYTE *)pol->m_pCurrObj + pol->m_pCurrObj->dwLength);
    return pRet;
}


//***************************************************************************
//
//  CBMOFObj * FindObj
//
//  DESCRIPTION:
//
//  Searches the object list for the first object which has a "__className"
//  property.  The search is case insensitive.
//
//  PARAMETERS:
//
//  pol                 Input. Pointer to CBMOFObjList object
//  pName               Input. Name of object being searched for
//
//  RETURN VALUE:
//
//  Pointer to a CBMOFObj stucture which can be use to access the object
//  information.  NULL if error.  Note that the caller MUST Free this via
//  BMOFFree().
//
//***************************************************************************

CBMOFObj * FindObj(CBMOFObjList *pol, WCHAR * pName)
{
    DWORD dwCnt;
    UNALIGNED WBEM_Object * pob;

    if(pol->m_pol == NULL || pName == NULL)
        return NULL;

    pob = pol->m_pInfo;
    for(dwCnt = 0; dwCnt < pol->m_pol->dwNumberOfObjects; dwCnt)
    {
        WCHAR * pwcName = NULL;
        BOOL bMatch = FALSE;

        CBMOFObj * pRet = CreateObj(pob);
         if(pRet == NULL)
            return NULL;
        if(GetName(pRet,&pwcName))
            bMatch = TRUE;
        if(pwcName)
            BMOFFree(pwcName);

        // If we found it, return it, otherwise free object and advance

        if(bMatch)
            return pRet;
        BMOFFree(pRet);
        pob = (UNALIGNED WBEM_Object *)((BYTE *)pob + pob->dwLength);
    }
    return NULL;
}


//***************************************************************************
//
//  int GetNumDimensions
//
//  DESCRIPTION:
//
//  Returns the number of dimensions for a data item.
//
//  PARAMETERS:
//
//  pItem               Input.  Item in question.
//
//  RETURN VALUE:
//  -1 if bogus argument, or if the data item doesnt hold data which would
//     be the case for uninitialized properties.
//  0  if non array argument
//  n  Number of dimensions.  Currently only single dimension arrays are
//     supported.
//
//***************************************************************************

int GetNumDimensions(CBMOFDataItem * pItem)
{
   UNALIGNED unsigned long * pdwTemp;
   if(pItem == NULL)
      return -1;
   if(!(pItem->m_dwType & VT_ARRAY))
      return 0;
   if(pItem->m_pData == NULL)
      return -1;

   pdwTemp = (unsigned long *)pItem->m_pData;
   pdwTemp++;        // skip past total size
   return *pdwTemp;
}


//***************************************************************************
//
//  int GetNumElements
//
//  DESCRIPTION:
//
//  Gets the number of elements for an array dimension.  Note that 1 is the
//  first dimenstion.  Currently, only scalars and 1 dimensional arrays are
//  supported.
//
//  PARAMETERS:
//
//  pItem               Input.  Data item in question.
//  lDim                Input.  Dimension in question.  The most significent
//                      (and for now only) dimension is 0.
//
//  RETURN VALUE:
//
//  Number of array elements.  Note that scalars will return -1.
//
//***************************************************************************

int GetNumElements(CBMOFDataItem * pItem, long lDim)
{
   int iCnt; UNALIGNED DWORD * pdwTemp;
   int lNumDim = GetNumDimensions(pItem);
   if(lNumDim == -1 || lDim > lNumDim)
      return -1;
   pdwTemp = (UNALIGNED unsigned long *)pItem->m_pData;
   pdwTemp++;                          // skip total size
   pdwTemp++;                          // skip number of dimensions
   for(iCnt = 0; iCnt < lDim; iCnt++)
      pdwTemp++;
   return *pdwTemp;
}


//***************************************************************************
//
//  BYTE * GetDataElemPtr
//
//  DESCRIPTION:
//
//  Used to get the pointer to a particular data element.  Note that this is
//  usually used internally.
//
//  PARAMETERS:
//
//  pItem               Input.  Data item to use.
//  plDims              Input.  Pointer to array of dimension values.  Note
//                      that currenly only a single dimension is supported.
//  vtSimple            Input.  Variant type of the data with the VT_ARRAY
//                      and VT_BYREF bits cleared.
//
//  RETURN VALUE:
//

//  pointer to the data.
//***************************************************************************

BYTE * GetDataElemPtr(CBMOFDataItem * pItem, long * plDims, DWORD vtSimple)
{
   int iNumDim;
   DWORD dwTotalDataSize;
   BYTE * pEndOfData;
   UNALIGNED DWORD * pdwCurr;
   UNALIGNED DWORD * pdwCurrObj;
   BYTE * pRow;
   int iCnt;

   // first check the number of dimensions.

   iNumDim = GetNumDimensions(pItem);
   if(iNumDim == -1)
      return NULL;
   if(iNumDim == 0)           // simple case of scalar argument
      return pItem->m_pData;

   // for arrays, the data block starts off with this form,
   // dwtotalsize, dwNumDimenstions, dwMostSigDimension... dwLeastSigDimension
   // Since currently only 1 dimensional arrays are supported, a 5 element
   // array would start with
   // dwSize, 1, 5

   pdwCurr = (UNALIGNED DWORD *)pItem->m_pData;
   dwTotalDataSize = *pdwCurr;
   pEndOfData = pItem->m_pData + dwTotalDataSize;
   pdwCurr+= 2;      // skip to dimension list
   pdwCurr += iNumDim;  // skip of dimension sizes.

   while((BYTE *)pdwCurr < pEndOfData)
   {
      // Each row has the format
      // dwSizeOfRow, MostSigDimension ... dwLeastSignificentDimension+1,data
      // For a one dimensional array, it would just be
      // dwSizeOfRow, data


      DWORD dwRowSize = *pdwCurr;

      // test if this row is ok.  Each row of data will have
      // a set of Indicies for each higher dimension.

      for(iCnt = 0; iCnt < iNumDim-1; iCnt++)
      {
         UNALIGNED DWORD * pRowInd = pdwCurr +1 + iCnt;
         if((long)*pRowInd != plDims[iCnt])
            break;

      }
      if(iCnt >= iNumDim -1)
      {
         break;                  // found the row.
      }

      // go to the next row

      pdwCurr = (UNALIGNED DWORD *)((BYTE *)pdwCurr + dwRowSize);

   }

   if((BYTE *)pdwCurr >= pEndOfData)
      return NULL;

   pRow = (BYTE *)(pdwCurr + 1 + iNumDim -1);
   for(iCnt = 0; iCnt < plDims[iNumDim-1]; iCnt++)
   {
      if(vtSimple == VT_BSTR)
         pRow += 2*(wmi_unaligned_wcslen((WCHAR *)pRow)+1);
      else if(vtSimple == VT_EMBEDDED_OBJECT)
      {
         // Each embedded object starts off with its own size

         pdwCurrObj = (DWORD *)pRow;
         pRow += *pdwCurrObj;

      }
      else
         pRow += iTypeSize(vtSimple);
   }

   return pRow;

}


//***************************************************************************
//
//  int GetData
//
//  DESCRIPTION:
//
//
//  PARAMETERS:
//
//  pItem               Input.  Data item to use.
//  pRet                Input/Output.  Pointer to where the data is to be
//                      copied.  For simple data, such as ints, this can just
//                      be a pointer to an int.  For BSTRs, or embedded
//                      objects, this is treated as a pointer to a pointer
//                      and it is the responsibility of the caller to free
//                      the strings via BMOFFree().
//  plDims              Input.  Pointer to array of dimension values.  Note
//                      that currenly only a single dimension is supported.
//                      The first element in any dimension is 0.
//  RETURN VALUE:
//
//  Number of bytes of data.
//***************************************************************************

int GetData(CBMOFDataItem * pItem, BYTE * pRet, long * plDims)
{
   DWORD dwSimple;
   BYTE * pData;
   CBMOFObj * pObjRet = NULL;
   dwSimple = pItem->m_dwType &~ VT_ARRAY &~VT_BYREF;
   pData = GetDataElemPtr(pItem, plDims, dwSimple);
   if(pData == NULL)
      return 0;
   if(dwSimple == VT_BSTR)
   {

      // For strings, a new WCHAR buffer is returned.  Note that
      // SysAllocString isnt used so as to avoid any Ole dependencies.

      BYTE * pStr;
      DWORD dwSize = 2*(wmi_unaligned_wcslen((WCHAR *)pData)+1);

      pStr = BMOFAlloc(dwSize);
      memcpy((void *)pRet, &pStr, sizeof(void *));
      wmi_unaligned_wcscpy((WCHAR *)pStr, (WCHAR *)pData);
      return dwSize;
   }
   else if(dwSimple == VT_EMBEDDED_OBJECT)
   {

      // This is the embedded object case.
      pObjRet = CreateObj((UNALIGNED WBEM_Object *)pData);
      memcpy((void *)pRet, &pObjRet, sizeof(void *));

      return sizeof(void *);
   }
   else
   {
      memcpy((void *)pRet, (void *)pData, iTypeSize(dwSimple));
      return iTypeSize(dwSimple);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcompiler\test\bmof.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    BMOF.H

Abstract:

	Describes the format of binary MOF files.  In addition, it defines some
	structures which specify the details of the format and also defines some
	addtional structures and helper functions for navigating a BMOF file.

History:

	a-davj  14-April-97   Created.

--*/

#ifndef __BMOF__
#define __BMOF__


#ifdef __cplusplus
extern "C" {
#endif

//  Binary mof files contain a large blob of data which consists of stuctures
//  which contain other structures, etc.  The layout of that blob is detailed in
//  the following comments.  However, the binary files are compressed and always
//  starts off with the following DWORDS
//  [Signature] [Compression Type, Always 1] [Compressed size] [Expanded size] The blob follows!
//  An example of decompressing the file is in test.c
//
//   The following is a BNF description of the structures that make up
//   a BMOF file and also serve to illustrate the basic layout of WBEM
//   objects.
//  
//  --A MOF is zero or more objects
//  
//  WBEM_Binary_MOF ::= WBEM_Object*; 
//  
//  --An object is a qualifier list (applying to the entire object) and
//  --a property list
//  
//  WBEM_Object ::= WBEM_QualifierList WBEM_PropertyList;
//  
//  --A property list is zero or more properties
//     
//  WBEM_PropertyList ::= WBEM_Property*;   / zero or more properties
//  
//  --A property is a set of qualifiers applying to the property, and
//  --a type, a name, and a value
//  
//  WBEM_Property ::= WBEM_QualifierList* <type> <name> <value>;
//  
//  --A qualifier list is zero or more qualifiers
//  
//  WBEM_QualifierList ::= WBEM_Qualifier*;   -- zero or more qualifiers
//  
//  --A qualifier is a type, a name, and a value. However, the supported types
//  --are not as extensive as for properties.
//  
//  WBEM_Qualifier ::= <type> <name> <value>;
//  
//  
//  Note that a qualifier set (a list of qualifiers) can be applied
//  to the entire object or to individual properties. However, qualifiers
//  cannot be applied to other qualifiers:
//  
//      object = quals + props
//      prop = quals + name + value
//      qual = name + value
//  
//  Information such as the name of a class, the super class, etc., are coded
//  as property values.  Finding the value of the property __CLASS, for example,
//  gives the name of the class.  All properties beginning with a double
//  underscore are well-known system properties common to all WBEM objects.
//  All other properties are user-defined.
//  
//  The list of predefined properties is found in WBEM documentation.
//  
//  Offsets are relative to their owning structure, not absolute to the
//  entire encoding image.  This allows moving the subcomponents around
//  without rencoding everything.
//  
//  Note that an offset of 0xFFFFFFFF indicates that the field is not used.
//  
//  Both properties and qualifiers have value fields which contain data based
//  on Ole Automation types.  Qualifiers are simple types (no arrays or 
//  embedded objects) while property values might contain arrays and/or 
//  embedded objects.  
//
//  One difference from Ole is that BSTRs are actually stored as WCHAR 
//  strings even if the data type is marked as BSTR.  
//
//  In addition, some qualifiers or properties are actually aliases which 
//  must be resolved later.  Aliases are stored as BSTR values and the type
//  field is set to VT_BSTR | VT_BYREF.  An array of alias strings is a bit
//  more complicated since not all the elements need be aliases.  In the array
//  case, each actual alias string is prepended with a L'$' while each 
//  "regular" string is prepended by a L' '.
//
//  Currently, only scalars and single dimensional arrays are supported.
//  However, the BMOF file layout is designed so as to accommodate multi-
//  dimensional array in the future.  For array data, the data is layout out
//
//  ArrayData ::= ArrayHeaderData + RowOfData*; 
//
//  The ArrayHeaderData has the form;
//  dwtotalsize, dwNumDimenstions, dwMostSigDimension... dwLeastSigDimension
// 
//  Currently only 1 dimensional arrays are supported, a 5 element
//  array would start with;
//  dwSize, 1, 5
//
//  After the header, one or more rows would follow.  A row represents the
//  "most rapidly changing" data.  Currently, there is only one row.
//
//  The row format is;
//
//  dwSizeOfRow, MostSigDimension ... dwLeastSignificentDimension+1,data
//  For a one dimensional array, it would just be
//  dwSizeOfRow, Data
//

//  The extension  for supporting qualifier flavors is to add the following data after the current blob.
//  
//  typedef struct 
//  {
//      WCHAR wcSignature;          // the string BMOFQUALFLAVOR11
//      DWORD dwNumPair;
//      // BYTE FlavorInfo[];             // Blob containing array of WBEM_Object structs
//  }WBEM_Binary_FLAVOR;
//  
//  The FlavorInfo blob will be a series of DWORD pairs of the form
//  
//  Typedef struct
//  {
//  	DWORD dwOffsetInOriginalBlob;
//  	DWORD dwFlavor;
//  }

// Each Binary MOF file starts off with these signature bytes.

#define BMOF_SIG 0x424d4f46

// The following structures exactly describe the contents of a BMOF file.
// These can be used to navigate the file using the various offsets and
// lots of casting.  

typedef struct 
{
    DWORD dwSignature;          // four characters, BMOF
    DWORD dwLength;
    DWORD dwVersion;            // 0x1
    DWORD dwEncoding;           // 0x1 = little endian, DWORD-aligned, no compression

    DWORD dwNumberOfObjects;    // Total classes and instances in MOF

    // BYTE Info[];             // Blob containing array of WBEM_Object structs
                                // First object is at offset 0.
}WBEM_Binary_MOF;

typedef struct                  // Describes a class or instance
{
    DWORD dwLength;
    DWORD dwOffsetQualifierList;
    DWORD dwOffsetPropertyList;
    DWORD dwOffsetMethodList;
    DWORD dwType;               // 0 = class, 1 = instance
    
    //  BYTE Info[];            // Blob of qualifier set and properties
}WBEM_Object;

typedef struct 
{
    DWORD dwLength;
    DWORD dwNumberOfProperties;
    
    //  BYTE Info[];                // Blob with all properties placed end-to-end    
}WBEM_PropertyList;
                                                                   
typedef struct 
{
    DWORD dwLength;             // Length of this struct
    DWORD dwType;               // A VT_ type from WTYPES.H (VT_I4, VT_UI8, etc)
    DWORD dwOffsetName;         // Offset in <Info> of the null-terminated name.
    DWORD dwOffsetValue;        // Offset in <Info> of the value.
    DWORD dwOffsetQualifierSet; // 
        
    
    //  BYTE  Info[];           // Contains qualifier set, name, and value
}WBEM_Property;

// Rough encoding example for a string:
//
// dwLength = 10;
// dwType   = VT_LPWSTR;    
// dwOffsetName  = 0;
// dwOffsetValue = 8;
// dwOffsetQualifierSet = 0xFFFFFFFF;   // Indicates not used
//
// Info[] = "CounterValue\0<default value>\0";


typedef struct       
{
    DWORD dwLength;
    DWORD dwNumQualifiers;
    //  BYTE Info[];                // Array of WBEM_Qualifiers placed end-to-end
}WBEM_QualifierList;


typedef struct 
{
    DWORD dwLength;         // Length of this struct
    DWORD dwType;           // A VT_ type from WTYPES.H (VT_I4, VT_UI8, etc)
    DWORD dwOffsetName;     // Offset in <Info> of the null-terminated name.
    DWORD dwOffsetValue;    // Offset in <Info> of the value.
    //  BYTE  Info[];   
}WBEM_Qualifier;


// These structures and the helper functions that go with them can be used
// to easily navigate a BMOF file.  These structures "wrap" the above 
// structures so as to provide features such as searching and enumeration.

typedef struct 
{
    UNALIGNED WBEM_QualifierList * m_pql;
    UNALIGNED WBEM_Qualifier * m_pInfo;
    DWORD m_CurrQual;
    UNALIGNED WBEM_Qualifier * m_pCurr;

}CBMOFQualList;

typedef struct 
{
    UNALIGNED WBEM_Object * m_pob;
    BYTE * m_pInfo;
    UNALIGNED WBEM_PropertyList * m_ppl;
    DWORD m_CurrProp;
    UNALIGNED WBEM_Property * m_pCurrProp;

    UNALIGNED WBEM_PropertyList * m_pml;
    DWORD m_CurrMeth;
    UNALIGNED WBEM_Property * m_pCurrMeth;

}CBMOFObj;

typedef struct 
{
    WBEM_Binary_MOF * m_pol;
    DWORD m_CurrObj;
    UNALIGNED WBEM_Object * m_pInfo;
    UNALIGNED WBEM_Object * m_pCurrObj;   
}CBMOFObjList;


typedef struct 
{
    BYTE * m_pData;
    DWORD  m_dwType;
}CBMOFDataItem;

// Using any of the following help functions requires that these two 
// functions be provided in another module and allow independence from
// any particular allocation method.

void * BMOFAlloc(size_t Size);
void BMOFFree(void * pFree);


// These functions wrap the object list and provider for enumeration of
// the objects.

CBMOFObjList * CreateObjList(BYTE * pBuff);
void ResetObjList(CBMOFObjList * pol);
CBMOFObj * NextObj(CBMOFObjList *pol);
CBMOFObj * FindObj(CBMOFObjList *pol, WCHAR * pName);

// These functions allow access to the parts of a class or instance object

void ResetObj(CBMOFObj * pol);
CBMOFQualList * GetQualList(CBMOFObj * pol);
CBMOFQualList * GetPropQualList(CBMOFObj * pol, WCHAR * pName);
CBMOFQualList * GetMethQualList(CBMOFObj * pol, WCHAR * pName);
BOOL NextProp(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem);
BOOL NextMeth(CBMOFObj * pob, WCHAR ** ppName, CBMOFDataItem * pItem);
BOOL FindProp(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem);
BOOL FindMeth(CBMOFObj * pob, WCHAR * pName, CBMOFDataItem * pItem);
BOOL GetName(CBMOFObj * pob, WCHAR ** ppName);
DWORD GetType(CBMOFObj * pob);
UNALIGNED WBEM_Property * FindPropPtr(CBMOFObj * pob, WCHAR * pName);
UNALIGNED WBEM_Property * FindMethPtr(CBMOFObj * pob, WCHAR * pName);

//  These functions provide easy access to a qualifier list.

void ResetQualList(CBMOFQualList * pql);
BOOL NextQual(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem);
BOOL NextQualEx(CBMOFQualList * pql,WCHAR ** ppName, CBMOFDataItem * pItem, 
                                            DWORD * pdwFlavor, BYTE * pBuff, 
											BYTE * pToFar);
BOOL FindQual(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem);
BOOL FindQualEx(CBMOFQualList * pql,WCHAR * pName, CBMOFDataItem * pItem, 
                                            DWORD * pdwFlavor, BYTE * pBuff,
											BYTE * pToFar);

// These functions provide easy access to a data item.  Note that data items
// might be stored in arrays.

int GetNumDimensions(CBMOFDataItem *);
int GetNumElements(CBMOFDataItem *, long lDim);
int GetData(CBMOFDataItem *, BYTE * pRet, long * plDims);

// These functions are mainly useful to the above helper functions

int iTypeSize(DWORD vtTest);
BOOL SetValue(CBMOFDataItem * pItem, BYTE * pInfo, DWORD dwOffset, DWORD dwType);
BOOL SetName(WCHAR ** ppName, BYTE * pInfo, DWORD dwOffset);
CBMOFQualList * CreateQualList(UNALIGNED WBEM_QualifierList *pql);
CBMOFObj * CreateObj(UNALIGNED WBEM_Object * pob);


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcompiler\test.c ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    TEST.C

Abstract:

    Demonstration program for dumping out Binary Managed Object Format (BMOF) 
    data.

History:

    a-davj  14-April-97   Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include <io.h> 
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>

#include "bmof.h"
#include "mrcicode.h"

void DisplayObject(CBMOFObj * po);

//***************************************************************************
//
//  void * BMOFAlloc
//
//  DESCRIPTION:
//
//  Provides allocation service for BMOF.C.  This allows users to choose
//  the allocation method that is used.
//
//  PARAMETERS:
//
//  Size                Input.  Size of allocation in bytes.
//
//  RETURN VALUE:
//
//  pointer to new data.  NULL if allocation failed.
//
//***************************************************************************

void * BMOFAlloc(size_t Size)
{
   return malloc(Size);
}

//***************************************************************************
//
//  void BMOFFree
//
//  DESCRIPTION:
//
//  Provides allocation service for BMOF.C.  This frees what ever was
//  allocated via BMOFAlloc.
//
//  PARAMETERS:
//
//  pointer to memory to be freed.
//
//***************************************************************************

void BMOFFree(void * pFree)
{
   free(pFree);
}

//***************************************************************************
//
//  void DisplayVariant
//
//  DESCRIPTION:
//
//  Displays VARIANT data.  Note that this is only done in this sample for
//  convienence, and using OLE is NOT necessary.
//
//  PARAMETERS:
//
//  pvar                Input.  Pointer to VARIANT which is to be displayed.
//                      It is assumed that the variant type is simple, I.E.
//                      neither the VT_ARRAY or VT_BYREF bits are set.
//
//***************************************************************************

void DisplayVariant(VARIANT * pvar)
{
    SCODE sc;
    VARIANT vTemp;

    // Uninitialized data will have a VT_NULL type.

    if(pvar->vt == VT_NULL)
    {
        printf(" data is NULL");
        return;
    }

     // String types can just be dumped.

     if(pvar->vt == VT_BSTR)
     {
        printf("value is %S",pvar->bstrVal);
         return;
     }
     else if(pvar->vt == VT_UNKNOWN)
     {
        CBMOFObj * pObj;
        printf(" got an embedded object");
        pObj = (CBMOFObj *)pvar->bstrVal;
        DisplayObject(pObj);
        return;
     }

    // For non string data, convert the infomation to a bstr and display it.

    VariantInit(&vTemp);
    sc = VariantChangeTypeEx(&vTemp, pvar,0,0, VT_BSTR);
    if(sc == S_OK)
    {
        printf("value is %S",vTemp.bstrVal);
    }
    else
        printf(" Couldnt convert type 0x%x, error code 0x%x", pvar->vt, sc);
    VariantClear(&vTemp);
}

//***************************************************************************
//
//  void DisplayData
//
//  DESCRIPTION:
//
//  Displays the data held in a data item.  Note that Ole is use just for 
//  ease of use and is optional.
//
//  PARAMETERS:
//
//  pItem               Input.  Item to be displayed.
//
//***************************************************************************

void DisplayData(CBMOFDataItem * pItem)
{
    DWORD dwType, dwSimpleType;
    long lNumDim, lCnt;
    long lFirstDim;
    VARIANT var;

   // Determine the data type and clear out the variant

    dwType = pItem->m_dwType;
    printf("\nData type is 0x%x ", dwType);
    dwSimpleType = dwType & ~VT_ARRAY & ~VT_BYREF;
    memset((void *)&var.lVal, 0, 8);

    lNumDim = GetNumDimensions(pItem);
  
    if(lNumDim == 0)    
    {
      // handle the simple scalar case.  Note that uninitialized properties
      // will not have data.

        if(GetData(pItem, (BYTE *)&(var.lVal), NULL))
        {
            var.vt = (VARTYPE)dwSimpleType;
            DisplayVariant(&var);

            // Note the GetData does not use OLE to allocate BSTRs
            // and so we need to use our own freeing routine here.

            if(var.vt == VT_BSTR)
               BMOFFree(var.bstrVal);
        }
        else
            printf(" NULL ");
    }
    else if(lNumDim == 1)
    {
        // For the array case, just loop getting each element.
        // Start by getting the number of elements

        lFirstDim = GetNumElements(pItem, 0);
        if(lFirstDim < 1)
        {
            printf("\n CANT DISPLAY, BOGUS DIMENSION");
            return;
        }
        printf("\n");
        for(lCnt = 0; lCnt < lFirstDim; lCnt++)
        {
            if(GetData(pItem, (BYTE *)&(var.lVal), &lCnt))
            {
                var.vt = (VARTYPE)dwSimpleType;
                DisplayVariant(&var);

               // Note the GetData does not use OLE to allocate BSTRs
               // and so we need to use our own freeing routine here.

               if(var.vt == VT_BSTR)
                  BMOFFree(var.bstrVal);
               printf("\n");
            }
            else
                printf(" NULL ");
        }
    }
    else if(lNumDim == -1)
    {
        printf("\n Undefined array");
        return;
    }
    else
    {
        // Currently multidimension arrays are not supported.

        printf("\n CANT DISPLAY, TOO MANY DIMEMSIONS");
        return;
    }


    return;
}

//***************************************************************************
//
//  void DisplayQualList
//
//  DESCRIPTION:
//
//  Helper routine for displaying a qualifier list.
//
//  PARAMETERS:
//
//  pql                 Input.  Pointer to structure which wraps the 
//                      qualifier list.
//
//***************************************************************************

void DisplayQualList(CBMOFQualList * pql)
{
    WCHAR * pName = NULL;
    CBMOFDataItem Item;
    ResetQualList(pql);
    printf("\nDisplaying qual list");
    

    while(NextQual(pql, &pName, &Item))
    {
        printf("\nQualifier name is -%S- ",pName);
        DisplayData(&Item);
        BMOFFree(pName);
    }
}


//***************************************************************************
//
//  void DisplayObject
//
//  DESCRIPTION:
//
//  Helper routine for displaying a class or instance.
//
//  PARAMETERS:
//
//  po                  Input.  Pointer to structure that wraps the object.
//
//***************************************************************************

void DisplayObject(CBMOFObj * po)
{
    CBMOFQualList * pql;
    CBMOFDataItem Item;
    WCHAR * pName = NULL;
    BOOL bfirstmethod = TRUE;

    // Display the objects name, its type (Is it a class or instance), and
    // display the qualifier set which is attached to the object.

    if(GetName(po, &pName))
    {
        printf("\n\nLooking at object %S",pName);
        BMOFFree(pName);
    }
    printf("\nThe objects type is 0x%x", GetType(po));
    pql = GetQualList(po);
    if(pql)
    {
        DisplayQualList(pql);
        BMOFFree(pql);
        pql = NULL;
    }
    
    // Display each property and it associated qualifier list

    ResetObj(po);
    printf("\nDisplaying prop list");
    
    while(NextProp(po, &pName, &Item))
    {
        printf("\n\nProperty name is -%S- type is 0x%x",pName, Item.m_dwType);
        DisplayData(&Item);
        pql = GetPropQualList(po, pName);
        if(pql)
        {
            DisplayQualList(pql);
            BMOFFree(pql);
            pql = NULL;
        }

        BMOFFree(pName);
    }

    while(NextMeth(po, &pName, &Item))
    {

        if(bfirstmethod)
            printf("\nDisplaying method list");
        bfirstmethod = FALSE;

        printf("\n\nMethod name is -%S- type is 0x%x",pName, Item.m_dwType);
        DisplayData(&Item);
        pql = GetPropQualList(po, pName);
        if(pql)
        {
            DisplayQualList(pql);
            BMOFFree(pql);
            pql = NULL;
        }

        BMOFFree(pName);
    }

}

//***************************************************************************
//
//  BYTE * ReadBMOFFile
//
//  DESCRIPTION:
//
//  Opens and decompresses the binary mof file
//
//  PARAMETERS:
//
//  pFileName           Input.  Pointer to structure that wraps the object.
//
//  RETURN VALUE:
//
//  pointer to the binary mof data.  This should be freed using "free".  Note that
//  NULL is returned for all errors.
//
//***************************************************************************

BYTE * ReadBMOFFile(char * pFileName)
{
    int fh1 = -1;
    int iRet;
    DWORD dwCompType, dwCompressedSize, dwExpandedSize, dwSig, dwResSize;
    BYTE * pCompressed = NULL;
    BYTE * pExpanded = NULL;

    fh1 = _open(pFileName, _O_BINARY | _O_RDONLY);
    if(fh1 == -1)
    {
        printf("\nCould not open the file %s", pFileName);
        return NULL;
    }

    // get the signature, compression type, and the sizes

    iRet = _read(fh1, &dwSig, sizeof(DWORD));
    if((DWORD)iRet != sizeof(DWORD))
    {
        printf("\nError reading file");
        _close(fh1);
        return NULL;
    }

    iRet = _read(fh1, &dwCompType, sizeof(DWORD));
    iRet = _read(fh1, &dwCompressedSize, sizeof(DWORD));
    iRet = _read(fh1, &dwExpandedSize, sizeof(DWORD));

    // make sure the signature is valid and that the compression type is one 
    // we understand!

    if(dwSig != BMOF_SIG ||dwCompType != 1)
    {
        _close(fh1);
        return NULL;
    }

    // Allocate storage for the compressed data and
    // expanded data

    pCompressed = malloc(dwCompressedSize);
    pExpanded = malloc(dwExpandedSize);
    if(pCompressed == NULL || pExpanded == NULL)
    {
        _close(fh1);
        return NULL;
    }

    // Read the compressed data.

    iRet = _read(fh1, pCompressed, dwCompressedSize);
    if((DWORD)iRet != dwCompressedSize)
    {
        printf("\nError reading data");
        free(pExpanded);
        free(pCompressed);
        return NULL;
    }

    _close(fh1);

    // Decompress the data

    dwResSize = Mrci1Decompress(pCompressed, dwCompressedSize, pExpanded, dwExpandedSize);
    free(pCompressed);

    if(dwResSize != dwExpandedSize)
    {
        printf("\nError expanding data!!!");
        free(pExpanded);
        return NULL;
    }
    return pExpanded;
}

//***************************************************************************
//
//  int main
//
//  DESCRIPTION:
//
//  Entry point.
//
//  COMMAND LINE ARGUMENT:
//
//  This program should be launced with a single argument which is the
//  name of the file which contains the BMOF.
//
//  RETURN VALUE:
//
//  0 if OK, 1 if error.
//
//***************************************************************************

int main(int argc, char ** argv)
{
    BYTE * pTest;
    CBMOFObjList * pol;
    CBMOFObj * po;

    // check the command line

    if(argc < 2)
    {
        printf("\nusage: test BMOFFILE\nwhere BMOFFILE is the binary mof file to dump");
        return 1;
    }

    pTest = ReadBMOFFile(argv[1]);

    if(pTest == NULL)
    {
       printf("\nterminating abnormally, could not read binary mof");
       return 1;
    }

    // Now use the helper functions to dump out the file.  Create an object
    // list structure and use it to enumerate the objects.

    pol = CreateObjList(pTest);
    if(pol == NULL)
    {
       return 1;
    }
    printf("\nThe number of objects is %d",pol->m_pol->dwNumberOfObjects);

    ResetObjList (pol);
    while(po = NextObj(pol))
    {
        DisplayObject(po);
        BMOFFree(po);
    }

    BMOFFree(pol);

    free(pTest);
    printf("\nTerminating normally\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcompiler\test\test.c ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    TEST.C

Abstract:

    Demonstration program for dumping out Binary Managed Object Format (BMOF) 
    data.

History:

    a-davj  14-April-97   Created.

--*/
#include <ole2.h>
#include <windows.h>
#include <stdio.h>
#include <io.h> 
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <malloc.h>
#include "bmof.h"
#include "mrcicode.h"
#include <oaidl.h>
void DisplayObject(CBMOFObj * po);

//***************************************************************************
//
//  void * BMOFAlloc
//
//  DESCRIPTION:
//
//  Provides allocation service for BMOF.C.  This allows users to choose
//  the allocation method that is used.
//
//  PARAMETERS:
//
//  Size                Input.  Size of allocation in bytes.
//
//  RETURN VALUE:
//
//  pointer to new data.  NULL if allocation failed.
//
//***************************************************************************

void * BMOFAlloc(size_t Size)
{
   return malloc(Size);
}

//***************************************************************************
//
//  void BMOFFree
//
//  DESCRIPTION:
//
//  Provides allocation service for BMOF.C.  This frees what ever was
//  allocated via BMOFAlloc.
//
//  PARAMETERS:
//
//  pointer to memory to be freed.
//
//***************************************************************************

void BMOFFree(void * pFree)
{
   free(pFree);
}

//***************************************************************************
//
//  void DisplayVariant
//
//  DESCRIPTION:
//
//  Displays VARIANT data.  Note that this is only done in this sample for
//  convienence, and using OLE is NOT necessary.
//
//  PARAMETERS:
//
//  pvar                Input.  Pointer to VARIANT which is to be displayed.
//                      It is assumed that the variant type is simple, I.E.
//                      neither the VT_ARRAY or VT_BYREF bits are set.
//
//***************************************************************************

void DisplayVariant(VARIANT * pvar)
{
    SCODE sc;
    VARIANT vTemp;

    // Uninitialized data will have a VT_NULL type.

    if(pvar->vt == VT_NULL)
    {
        printf(" data is NULL");
        return;
    }

     // String types can just be dumped.

     if(pvar->vt == VT_BSTR)
     {
        printf("value is %S",pvar->bstrVal);
         return;
     }
     else if(pvar->vt == VT_UNKNOWN)
     {
        CBMOFObj * pObj;
        printf(" got an embedded object");
        pObj = (CBMOFObj *)pvar->bstrVal;
        DisplayObject(pObj);
        return;
     }

    // For non string data, convert the infomation to a bstr and display it.

    VariantInit(&vTemp);
    sc = VariantChangeTypeEx(&vTemp, pvar,0,0, VT_BSTR);
    if(sc == S_OK)
    {
        printf("value is %S",vTemp.bstrVal);
    }
    else
        printf(" Couldnt convert type 0x%x, error code 0x%x", pvar->vt, sc);
    VariantClear(&vTemp);
}

//***************************************************************************
//
//  void DisplayData
//
//  DESCRIPTION:
//
//  Displays the data held in a data item.  Note that Ole is use just for 
//  ease of use and is optional.
//
//  PARAMETERS:
//
//  pItem               Input.  Item to be displayed.
//
//***************************************************************************

void DisplayData(CBMOFDataItem * pItem)
{
    DWORD dwType, dwSimpleType;
    long lNumDim, lCnt;
    long lFirstDim;
    VARIANT var;

   // Determine the data type and clear out the variant

    dwType = pItem->m_dwType;
    printf("\nData type is 0x%x ", dwType);
    dwSimpleType = dwType & ~VT_ARRAY & ~VT_BYREF;
    memset((void *)&var.lVal, 0, 8);

    lNumDim = GetNumDimensions(pItem);
  
    if(lNumDim == 0)    
    {
      // handle the simple scalar case.  Note that uninitialized properties
      // will not have data.

        if(GetData(pItem, (BYTE *)&(var.lVal), NULL))
        {
            var.vt = (VARTYPE)dwSimpleType;
            DisplayVariant(&var);

            // Note the GetData does not use OLE to allocate BSTRs
            // and so we need to use our own freeing routine here.

            if(var.vt == VT_BSTR)
               BMOFFree(var.bstrVal);
        }
        else
            printf(" NULL ");
    }
    else if(lNumDim == 1)
    {
        // For the array case, just loop getting each element.
        // Start by getting the number of elements

        lFirstDim = GetNumElements(pItem, 0);
        if(lFirstDim < 1)
        {
            printf("\n CANT DISPLAY, BOGUS DIMENSION");
            return;
        }
        printf("\n");
        for(lCnt = 0; lCnt < lFirstDim; lCnt++)
        {
            if(GetData(pItem, (BYTE *)&(var.lVal), &lCnt))
            {
                var.vt = (VARTYPE)dwSimpleType;
                DisplayVariant(&var);

               // Note the GetData does not use OLE to allocate BSTRs
               // and so we need to use our own freeing routine here.

               if(var.vt == VT_BSTR)
                  BMOFFree(var.bstrVal);
               printf("\n");
            }
            else
                printf(" NULL ");
        }
    }
    else if(lNumDim == -1)
    {
        printf("\n Undefined array");
        return;
    }
    else
    {
        // Currently multidimension arrays are not supported.

        printf("\n CANT DISPLAY, TOO MANY DIMEMSIONS");
        return;
    }


    return;
}

//***************************************************************************
//
//  void DisplayQualList
//
//  DESCRIPTION:
//
//  Helper routine for displaying a qualifier list.
//
//  PARAMETERS:
//
//  pql                 Input.  Pointer to structure which wraps the 
//                      qualifier list.
//
//***************************************************************************

void DisplayQualList(CBMOFQualList * pql)
{
    WCHAR * pName = NULL;
    CBMOFDataItem Item;
    ResetQualList(pql);
    printf("\nDisplaying qual list");
    

    while(NextQual(pql, &pName, &Item))
    {
        printf("\nQualifier name is -%S- ",pName);
        DisplayData(&Item);
        BMOFFree(pName);
    }
}


//***************************************************************************
//
//  void DisplayObject
//
//  DESCRIPTION:
//
//  Helper routine for displaying a class or instance.
//
//  PARAMETERS:
//
//  po                  Input.  Pointer to structure that wraps the object.
//
//***************************************************************************

void DisplayObject(CBMOFObj * po)
{
    CBMOFQualList * pql;
    CBMOFDataItem Item;
    WCHAR * pName = NULL;
    BOOL bfirstmethod = TRUE;

    // Display the objects name, its type (Is it a class or instance), and
    // display the qualifier set which is attached to the object.

    if(GetName(po, &pName))
    {
        printf("\n\nLooking at object %S",pName);
        BMOFFree(pName);
    }
    printf("\nThe objects type is 0x%x", GetType(po));
    pql = GetQualList(po);
    if(pql)
    {
        DisplayQualList(pql);
        BMOFFree(pql);
        pql = NULL;
    }
    
    // Display each property and it associated qualifier list

    ResetObj(po);
    printf("\nDisplaying prop list");
    
    while(NextProp(po, &pName, &Item))
    {
        printf("\n\nProperty name is -%S- type is 0x%x",pName, Item.m_dwType);
        DisplayData(&Item);
        pql = GetPropQualList(po, pName);
        if(pql)
        {
            DisplayQualList(pql);
            BMOFFree(pql);
            pql = NULL;
        }

        BMOFFree(pName);
    }

    while(NextMeth(po, &pName, &Item))
    {

        if(bfirstmethod)
            printf("\nDisplaying method list");
        bfirstmethod = FALSE;

        printf("\n\nMethod name is -%S- type is 0x%x",pName, Item.m_dwType);
        DisplayData(&Item);
        pql = GetPropQualList(po, pName);
        if(pql)
        {
            DisplayQualList(pql);
            BMOFFree(pql);
            pql = NULL;
        }

        BMOFFree(pName);
    }

}

//***************************************************************************
//
//  BYTE * ReadBMOFFile
//
//  DESCRIPTION:
//
//  Opens and decompresses the binary mof file
//
//  PARAMETERS:
//
//  pFileName           Input.  Pointer to structure that wraps the object.
//
//  RETURN VALUE:
//
//  pointer to the binary mof data.  This should be freed using "free".  Note that
//  NULL is returned for all errors.
//
//***************************************************************************

BYTE * ReadBMOFFile(char * pFileName)
{
    int fh1 = -1;
    int iRet;
    DWORD dwCompType, dwCompressedSize, dwExpandedSize, dwSig, dwResSize;
    BYTE * pCompressed = NULL;
    BYTE * pExpanded = NULL;

    fh1 = _open(pFileName, _O_BINARY | _O_RDONLY);
    if(fh1 == -1)
    {
        printf("\nCould not open the file %s", pFileName);
        return NULL;
    }

    // get the signature, compression type, and the sizes

    iRet = _read(fh1, &dwSig, sizeof(DWORD));
    if((DWORD)iRet != sizeof(DWORD))
    {
        printf("\nError reading file");
        _close(fh1);
        return NULL;
    }

    iRet = _read(fh1, &dwCompType, sizeof(DWORD));
    iRet = _read(fh1, &dwCompressedSize, sizeof(DWORD));
    iRet = _read(fh1, &dwExpandedSize, sizeof(DWORD));

    // make sure the signature is valid and that the compression type is one 
    // we understand!

    if(dwSig != BMOF_SIG ||dwCompType != 1)
    {
        _close(fh1);
        return NULL;
    }

    // Allocate storage for the compressed data and
    // expanded data

    pCompressed = malloc(dwCompressedSize);
    pExpanded = malloc(dwExpandedSize);
    if(pCompressed == NULL || pExpanded == NULL)
    {
        _close(fh1);
        return NULL;
    }

    // Read the compressed data.

    iRet = _read(fh1, pCompressed, dwCompressedSize);
    if((DWORD)iRet != dwCompressedSize)
    {
        printf("\nError reading data");
        free(pExpanded);
        free(pCompressed);
        return NULL;
    }

    _close(fh1);

    // Decompress the data

    dwResSize = Mrci1Decompress(pCompressed, dwCompressedSize, pExpanded, dwExpandedSize);
    free(pCompressed);

    if(dwResSize != dwExpandedSize)
    {
        printf("\nError expanding data!!!");
        free(pExpanded);
        return NULL;
    }
    return pExpanded;
}

//***************************************************************************
//
//  int main
//
//  DESCRIPTION:
//
//  Entry point.
//
//  COMMAND LINE ARGUMENT:
//
//  This program should be launced with a single argument which is the
//  name of the file which contains the BMOF.
//
//  RETURN VALUE:
//
//  0 if OK, 1 if error.
//
//***************************************************************************

int __cdecl main(int argc, char ** argv)
{
    BYTE * pTest;
    CBMOFObjList * pol;
    CBMOFObj * po;

    // check the command line

    if(argc < 2)
    {
        printf("\nusage: test BMOFFILE\nwhere BMOFFILE is the binary mof file to dump");
        return 1;
    }

    pTest = ReadBMOFFile(argv[1]);

    if(pTest == NULL)
    {
       printf("\nterminating abnormally, could not read binary mof");
       return 1;
    }

    // Now use the helper functions to dump out the file.  Create an object
    // list structure and use it to enumerate the objects.

    pol = CreateObjList(pTest);
    if(pol == NULL)
    {
       return 1;
    }
    printf("\nThe number of objects is %d",pol->m_pol->dwNumberOfObjects);

    ResetObjList (pol);
    while(po = NextObj(pol))
    {
        DisplayObject(po);
        BMOFFree(po);
    }

    BMOFFree(pol);

    free(pTest);
    printf("\nTerminating normally\n");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\bmofchck.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    BMOFCHCK.CPP

Abstract:

    Has test to determine if a binary mof is aligned.  Note that the file has
    not been tested and is not currently a part of mofcomp.  This exists as a
    backup in case the current fixes are not bullet proof.
    
History:

    davj  27-Nov-00   Created.

--*/
 
#include "precomp.h"
#include <wbemutil.h>
#include <genutils.h>
#include "trace.h"
#include "bmof.h"

BOOL IsValidObject(WBEM_Object * pObject);

BOOL IsValidQualifier(WBEM_Qualifier *pQual)
{
	if(pQual->dwLength & 3)
	{
		ERRORTRACE((LOG_MOFCOMP,"IsValidQualifier: qualifer has invalid size\n"));
		return FALSE;
	}
	if(pQual->dwOffsetName & 3)
	{
		ERRORTRACE((LOG_MOFCOMP,"IsValidQualifier: qualifer has invalid name offset\n"));
		return FALSE;
	}
	if(pQual->dwOffsetValue & 3)
	{
		ERRORTRACE((LOG_MOFCOMP,"IsValidQualifier: qualifer has invalid value offset\n"));
		return FALSE;
	}
	return TRUE;
}
BOOL IsValidQualList(WBEM_QualifierList *pQualList)
{
	DWORD dwNumQual, dwCnt;
	WBEM_Qualifier *pQual;

	if(pQualList->dwLength & 3)
	{
		ERRORTRACE((LOG_MOFCOMP,"IsValidQualList: Object has bad size\n"));
		return FALSE;
	}
	
	dwNumQual = pQualList->dwNumQualifiers;
	if(dwNumQual == 0)
		return TRUE;
	pQual = (WBEM_Qualifier *)((PBYTE)pQualList + sizeof(WBEM_QualifierList));
	
	for(dwCnt = 0; dwCnt < dwNumQual; dwCnt++)
	{
		if(!IsValidQualifier(pQual))
			return FALSE;
		pQual = (WBEM_Qualifier *)((BYTE *)pQual + pQual->dwLength);
	}
	return TRUE;
}

BOOL IsValidEmbeddedObject(PBYTE pByte)
{
	WBEM_Object * pObject;
	pObject = (WBEM_Object *)pByte;
	return IsValidObject(pObject);

}

BOOL IsValidEmbeddedObjectArray(PBYTE pByte)
{
	DWORD * pArrayInfo;
	pArrayInfo = (DWORD *)pByte;
	DWORD dwNumObj, dwCnt;
	WBEM_Object * pObject;

	// check the total size

	if(*pArrayInfo & 3)
	{
		ERRORTRACE((LOG_MOFCOMP,"IsValidEmbeddedObjectArray: total size is invalid length\n"));
		return FALSE;
	}

	// check the number of rows.  Currently only 1 is supported
	
	pArrayInfo++;
	if(*pArrayInfo != 1)
	{
		ERRORTRACE((LOG_MOFCOMP,"IsValidEmbeddedObjectArray: Invalid number of rows\n"));
		return FALSE;
	}

	// Get the number of objects

	pArrayInfo++;
	dwNumObj = *pArrayInfo;

	// Start into the row.  It starts off with the total size

	pArrayInfo++;
	if(*pArrayInfo & 3)
	{
		ERRORTRACE((LOG_MOFCOMP,"IsValidEmbeddedObjectArray: first row size is invalid\n"));
		return FALSE;
		
	}

	// Test each object

	pArrayInfo++;		// now points to first object
	
	pObject = (WBEM_Object *)(pArrayInfo);
	for(dwCnt = 0; dwCnt < dwNumObj; dwCnt++)
	{
		if(!IsValidObject(pObject))
			return FALSE;
		pObject = (WBEM_Object *)((PBYTE *)pObject + pObject->dwLength);
	}
	return TRUE;	

}

BOOL IsValidProperty(WBEM_Property *pProperty, BOOL bProperty)
{
    WBEM_QualifierList *pQualList;
	BYTE * pValue;
	if(pProperty->dwLength & 3)
	{
		ERRORTRACE((LOG_MOFCOMP,"IsValidProperty: property has invalid length\n"));
		return FALSE;
	}
	if(pProperty->dwOffsetName != 0xffffffff)
	{
		if(pProperty->dwOffsetName & 3)
		{
			ERRORTRACE((LOG_MOFCOMP,"IsValidProperty: property has invalid name offset\n"));
			return FALSE;
		}
	}

	if(pProperty->dwOffsetQualifierSet != 0xffffffff)
	{
		if(pProperty->dwOffsetQualifierSet & 3)
		{
			ERRORTRACE((LOG_MOFCOMP,"IsValidProperty: property has qual list offset\n"));
			return FALSE;
		}
    	pQualList = (UNALIGNED WBEM_QualifierList *)((BYTE *)pProperty +
    	                    sizeof(WBEM_Property) +
                            pProperty->dwOffsetQualifierSet);
        if(!IsValidQualList(pQualList))
        	return FALSE;
		
	}

	if(pProperty->dwOffsetValue != 0xffffffff)
	{
		if(pProperty->dwOffsetValue & 3)
		{
			ERRORTRACE((LOG_MOFCOMP,"IsValidProperty: property has invalid value offset\n"));
			return FALSE;
		}
    	pValue = ((BYTE *)pProperty +
    	                    sizeof(WBEM_Property) +
                            pProperty->dwOffsetValue);

		if(pProperty->dwType == VT_DISPATCH)
			return IsValidEmbeddedObject(pValue);
		else if(pProperty->dwType == (VT_DISPATCH | VT_ARRAY))
			return IsValidEmbeddedObjectArray(pValue);
	}
	return TRUE;
}
BOOL IsValidPropList(WBEM_PropertyList *pPropList, BOOL bProperty)
{
	DWORD dwNumProp, dwCnt;
	WBEM_Property *pProperty;

	if(pPropList->dwLength & 3)
	{
		ERRORTRACE((LOG_MOFCOMP,"IsValidPropList: Object has bad size\n"));
		return FALSE;
	}

	dwNumProp = pPropList->dwNumberOfProperties;
	if(dwNumProp == 0)
		return TRUE;
	pProperty = (WBEM_Property *)((PBYTE)pPropList + sizeof(WBEM_PropertyList));
	
	for(dwCnt = 0; dwCnt < dwNumProp; dwCnt++)
	{
		if(!IsValidProperty(pProperty, bProperty))
			return FALSE;
		pProperty = (WBEM_Property *)((BYTE *)pProperty + pProperty->dwLength);
	}
	return TRUE;
}


BOOL IsValidObject(WBEM_Object * pObject)
{
    WBEM_QualifierList *pQualList;
    WBEM_PropertyList * pPropList;
    WBEM_PropertyList * pMethodList;
    
	if(pObject->dwLength & 3)
	{
		ERRORTRACE((LOG_MOFCOMP,"IsValidObject: Object has bad size\n"));
		return FALSE;
	}

    // Check the qualifier list
    
    if(pObject->dwOffsetQualifierList != 0xffffffff)
    {
    	if(pObject->dwOffsetQualifierList & 3)
    	{
			ERRORTRACE((LOG_MOFCOMP,"IsValidObject: Qual list has bad offset\n"));
			return FALSE;
    	}
    	pQualList = (UNALIGNED WBEM_QualifierList *)((BYTE *)pObject +
    	                    sizeof(WBEM_Object) +
                            pObject->dwOffsetQualifierList);
        if(!IsValidQualList(pQualList))
        	return FALSE;
    }

	// check the property list
	
	if(pObject->dwOffsetPropertyList != 0xffffffff)
	{
    	if(pObject->dwOffsetPropertyList & 3)
    	{
			ERRORTRACE((LOG_MOFCOMP,"IsValidObject: Property list has bad offset\n"));
			return FALSE;
    	}
		pPropList = (WBEM_PropertyList *)((BYTE *)pObject +
    	                    sizeof(WBEM_Object) +
                            pObject->dwOffsetPropertyList);
        if(!IsValidPropList(pPropList, TRUE))
        	return FALSE;
	}

	// check the method list
	
	if(pObject->dwOffsetMethodList != 0xffffffff)
	{
    	if(pObject->dwOffsetMethodList & 3)
    	{
			ERRORTRACE((LOG_MOFCOMP,"IsValidObject: Method list has bad offset\n"));
			return FALSE;
    	}
		pMethodList = (WBEM_PropertyList *)((BYTE *)pObject +
    	                    sizeof(WBEM_Object) +
                            pObject->dwOffsetMethodList);
        if(!IsValidPropList(pMethodList, FALSE))
        	return FALSE;
	}
		return TRUE;
}

//***************************************************************************
//
//  IsValidBMOF.
//
//  DESCRIPTION:
//
//  Checks to make sure that a binary mof is properly aligned on
//  4 byte boundaries.  Note that this is not really necessary for
//  32 bit windows.
//
//  PARAMETERS:
//
//  pBuffer               Pointer to uncompressed binary mof data.
//
//  RETURN:
//
//  TRUE if all is well.
//
//***************************************************************************

BOOL IsValidBMOF(BYTE * pData)
{
	WBEM_Binary_MOF * pBinaryMof;
	DWORD dwNumObj, dwCnt;
	WBEM_Object * pObject;
	if(pData == NULL)
		return FALSE;
	try
	{
	
		pBinaryMof = (WBEM_Binary_MOF *)pData;
		dwNumObj = pBinaryMof->dwNumberOfObjects;
		if(dwNumObj == 0)
			return TRUE;
		pObject = (WBEM_Object *)(pData + sizeof(WBEM_Binary_MOF));
		for(dwCnt = 0; dwCnt < dwNumObj; dwCnt++)
		{
			if(!IsValidObject(pObject))
				return FALSE;
			pObject = (WBEM_Object *)((PBYTE *)pObject + pObject->dwLength);
		}
		
	}
	catch(...)
	{
		ERRORTRACE((LOG_MOFCOMP,"BINARY MOF had exception while checking for alignment\n"));
	    return FALSE; 
	}

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\bmofhelp.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    BMOFHELP.H

Abstract:

	Defines some helper functions for compiling binarary mofs.

History:

	a-davj  13-JULY-97   Created.

--*/

#ifndef _bmofhelp_H_
#define _bmofhelp_H_

#include "trace.h"

BOOL ConvertBufferIntoIntermediateForm(CMofData * pOutput, BYTE * pBuff, PDBG pDbg, BYTE * pBmofToFar);

// These are not typically used by any code except that in BMOFHELP.CPP

BOOL BMOFParseObj(CMofData * pOutput, CBMOFObj * pObj, VARIANT * pVar, BOOL bMethodArg, PDBG pDbg);
BOOL BMOFToVariant(CMofData * pOutput, CBMOFDataItem * pData, VARIANT * pVar, BOOL & bAliasRef, BOOL bMethodArg, PDBG pDbg);
CMoQualifierArray *  CreateQual(CMofData * pOutput, CBMOFQualList * pql, CMObject * pObj,LPCWSTR wszPropName, PDBG pDbg);
SCODE ConvertValue(CMoProperty * pProp, VARIANT * pSrc, BOOL bAliasRef);
HRESULT AddAliasReplaceValue(CMoValue & Value, const WCHAR * pAlias);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcompiler\test\mrcicode.c ===
/*++

Copyright (C) 1994-2001 Microsoft Corporation

Module Name:

    MRCICODE.C

Abstract:

	MRCI 1 & MRCI 2 maxcompress and decompress functions

History:

--*/

#include "mrcicode.h"                   /* prototype verification */

//#define NDEBUG                          /* turn off assertions */
#include <assert.h>                     /* use NDEBUG to inhibit */
#include <setjmp.h>                     /* fast overflow recovery */

#define LOGCHASH        (13)            /* Log of max. no. of hash buckets */
#define CHASH           (1U << LOGCHASH) /* Reasonably large table */

#define hash(w)         ((w) & (CHASH - 1))
                                        /* Simply toss the high-order bits */
#define word(p)         ((p)[0] + (((p)[1]) << 8))
                                        /* Return word at location */

#define BITMASK(x)      ((1 << x) - 1)  /* returns lower 'x' bits set */

#define LOGDISPSMALL    (6)             /* Number of bits in small disp */
#define LOGDISPMED      (8)             /* Number of bits in medium disp */
#define LOGDISPBIG      (12)            /* Number of bits in big displacement */

#define MAXDISPSMALL    ((1 << LOGDISPSMALL) - 1)
                                        /* Maximum small displacement */
#define MAXDISPMED      ((1 << LOGDISPMED) + MAXDISPSMALL)
                                        /* Maximum medium displacement */
#define MAXDISPBIG      ((1 << LOGDISPBIG) + MAXDISPMED)
                                        /* Maximum big displacement */

#define MINDISPSMALL    (0)             /* Minimum small displacement */
#define MINDISPMED      (MAXDISPSMALL + 1)
                                        /* Minimum medium displacement */
#define MINDISPBIG      (MAXDISPMED + 1)/* Minimum big displacement */

#define DISPMAX         (MAXDISPBIG - 1)/* MAXDISPBIG is our end marker */

#define MINMATCH1       (2)             /* Minimum match length for MRCI1 */
#define MINMATCH2       (3)             /* Minimum match length for MRCI2 */
#define MAXMATCH        (512)           /* Maximum match length */

#define EOB             (0)             /* length used to mean end of block */

#define SECTOR          (512)           /* blocking factor */

#define SIG_SIZE        (4)             /* # of block type prefix bytes */


/* local variables */

#ifdef BIT16
#define     FARBSS      _far
#else
#define     FARBSS
#endif

static unsigned abits;                  /* Array of bits */
static unsigned cbitsleft;              /* Number of bits in abits */
static unsigned char FAR *pCompressed;  /* pointer into compressed data */
static unsigned cCompressed;            /* # bytes remaining @ pCompressed */
static jmp_buf bailout;                 /* longjmp if cCompressed exceeded */

static unsigned FARBSS ahash[CHASH];    /* Hash table */
static unsigned FARBSS alink[MAXDISPBIG];  /* Links */


/* compression internal functions */

#ifdef BIT16
#define  FAST  _near _pascal            /* speed up local calls */
#else
#define  FAST
#endif

static void FAST inithash(void);
static void FAST charbuf(unsigned c);
static void FAST putbits(unsigned bits,unsigned cbits);
static void FAST outlength(unsigned cb);

static void FAST mrci1outsingle(unsigned ch);
static void FAST mrci1outstring(unsigned disp,unsigned cb);

static void FAST mrci2outsingle(unsigned ch);
static void FAST mrci2outstring(unsigned disp,unsigned cb);


/* decompression internal functions */

static unsigned FAST getbit(void);
static unsigned FAST getbits(unsigned cbits);
static void FAST expandstring(unsigned char FAR **ppchout,unsigned disp,
        unsigned cb);


/*
 *  (compress) Reset the hash tables between blocks.
 */

static void FAST inithash(void)
{
    unsigned FAR *entry;
    int i;

    entry = ahash;
    i = CHASH;

    do
    {
        *entry++ = (unsigned) -1;       /* Mark all entries as empty */
    } while (--i);
}


/*
 *  (compress) Add a character to compressed output buffer.
 */

static void FAST charbuf(unsigned c)
{
    if (cCompressed-- == 0)             /* make sure there's room */
    {
        longjmp(bailout,1);             /* Data expanding! */
    }

    *pCompressed++ = (unsigned char) c; /* Put character into buffer */
}


/*
 *  (compress) Write n bits to the compressed bitstream.
 */

static void FAST putbits(unsigned ab,unsigned cbits)
{
    do                                  /* Loop to emit bits */
    {
        if (cbits > cbitsleft)          /* if not enough space */
        {
            cbits -= cbitsleft;         /* doing partial */

            abits |= (ab << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            ab >>= cbitsleft;           /* clip sent bits */

            charbuf(abits);             /* Emit the buffer */
            cbitsleft = 8;              /* Reset buffer count */
            abits = 0;                  /* Reset buffer */
        }
        else                            /* can do all in one pass */
        {
            abits |= ((ab & BITMASK(cbits)) << (8 - cbitsleft));
                                        /* Put bits in output buffer */

            cbitsleft -= cbits;         /* used up some buffer */

            if (cbitsleft == 0)         /* If buffer full */
            {
                charbuf(abits);         /* Emit the buffer */
                cbitsleft = 8;          /* Reset buffer count */
                abits = 0;              /* Reset buffer */
            }

            break;                      /* we've done all cbits */
        }
    } while (cbits);                    /* repeat until done */
}


/*
 *  (compress) Encode a length into the compressed stream.
 */

static void FAST outlength(unsigned cb)
{
    unsigned alogbits, clogbits;
    unsigned avaluebits, cvaluebits;

    assert(cb >= 2);                    /* Length must be at least two */
    assert(cb <= MAXMATCH);

    if (cb <= 2)
    {
        alogbits = 1;
        clogbits = 1;
        cvaluebits = 0;
    }
    else if (cb <= 4)
    {
        alogbits = 1 << 1;
        clogbits = 2;
        avaluebits = cb - 3;
        cvaluebits = 1;
    }
    else if (cb <= 8)
    {
        alogbits = 1 << 2;
        clogbits = 3;
        avaluebits = cb - 5;
        cvaluebits = 2;
    }
    else if (cb <= 16)
    {
        alogbits = 1 << 3;
        clogbits = 4;
        avaluebits = cb - 9;
        cvaluebits = 3;
    }
    else if (cb <= 32)
    {
        alogbits = 1 << 4;
        clogbits = 5;
        avaluebits = cb - 17;
        cvaluebits = 4;
    }
    else if (cb <= 64)
    {
        alogbits = 1 << 5;
        clogbits = 6;
        avaluebits = cb - 33;
        cvaluebits = 5;
    }
    else if (cb <= 128)
    {
        alogbits = 1 << 6;
        clogbits = 7;
        avaluebits = cb - 65;
        cvaluebits = 6;
    }
    else if (cb <= 256)
    {
        alogbits = 1 << 7;
        clogbits = 8;
        avaluebits = cb - 129;
        cvaluebits = 7;
    }
    else /* (cb <= 512) */
    {
        alogbits = 1 << 8;
        clogbits = 9;
        avaluebits = cb - 257;
        cvaluebits = 8;
    }

    putbits(alogbits,clogbits);

    if (cvaluebits)
    {
        putbits(avaluebits,cvaluebits);
    }
}


/*
 *  (MRCI1 compress) Encode a literal into the compressed stream.
 */

static void FAST mrci1outsingle(unsigned ch)
{
    ch = (ch << 2) | ((ch & 0x80) ? 1 : 2);

    putbits(ch,9);
}


/*
 *  (MRCI2 compress) Encode a literal into the compressed stream.
 */

static void FAST mrci2outsingle(unsigned ch)
{
    if (ch & 0x80)
    {
        putbits((ch << 2) | 3,9);
    }
    else
    {
        putbits(ch << 1,8);
    }
}


/*
 *  (MRCI1 compress) Encode a match into the compressed stream.
 */

static void FAST mrci1outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH1) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 2),LOGDISPSMALL + 2);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 3) | 3,LOGDISPMED + 3);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 3) | 7,LOGDISPBIG + 3);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb);                  /* Emit the match length */
    }
}


/*
 *  (MRCI2 compress) Encode a match into the compressed stream.
 */

static void FAST mrci2outstring(unsigned disp,unsigned cb)
{
    assert(((cb >= MINMATCH2) && (disp != 0) && (disp < MAXDISPBIG)) ||
            ((cb == EOB) && (disp == MAXDISPBIG)));

    if (disp <= MAXDISPSMALL)
    {
        putbits(((disp - MINDISPSMALL) << 3) | 1,LOGDISPSMALL + 3);
                                        /* Put small displacement */
    }
    else if (disp <= MAXDISPMED)
    {
        putbits(((disp - MINDISPMED) << 4) | 5,LOGDISPMED + 4);
                                        /* Put medium displacement */
    }
    else
    {
        putbits(((disp - MINDISPBIG) << 4) | 13,LOGDISPBIG + 4);
                                        /* Put big displacement */
    }

    if (cb != EOB)                      /* If not an end marker */
    {
        outlength(cb - 1);              /* Emit the match length */
    }
}


/*
 *  (MRCI1) MaxCompress
 */

unsigned Mrci1MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char FAR *pch;             /* Char pointer */
    unsigned char FAR *pch2;            /* Char pointer */
    unsigned char FAR *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'D';
    *pCompressed++ = 'S';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data expanded */
    }

    cchbest = 0;                        /* no match yet */
    icur = 0;                           /* Initialize */

    for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
    {
        assert(cchbest == 0);           /* must always start with no match */

        if (cch > cchunc)
        {
            cch = cchunc;               /* limit to exact req count */
        }

        pchend = &pchbase[cch];         /* Remember end of buffer */

        while (icur < cch)              /* While at least two chars left */
        {
            /* update hash tables for this character */

            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */

            /* walk hash chain looking for matches */

            while (ilink < icur && icur - ilink <= DISPMAX)
            {                           /* While link is valid and in range */
                pch = &pchbase[icur];   /* Point at first byte */
                pch2 = &pchbase[ilink]; /* Point at first byte */

                if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
                {                       /* If we have a possible best match */
                    pch += 2;           /* Skip first pair */
                    pch2 += 2;          /* Skip first pair */

                    while (pch <= pchend)  /* Loop to find end of match */
                    {
                        if (*pch != *pch2++)
                        {
                            break;      /* Break if mismatch */
                        }
                        pch++;          /* Skip matching character */
                    }

                    if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
                    {                   /* If new best match */
                        cchbest = cchmatch;  /* Remember length */
                        ibest = ilink;  /* Remember position */

                        assert((pch-1) <= pchend);

                        if (pch > pchend)
                        {
                            break;      /* Break if we can't do any better */
                        }
                    }
                }

                assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
                        (alink[ilink % MAXDISPBIG] < ilink));

                ilink = alink[ilink % MAXDISPBIG];
                                        /* Get next link */
            }   /* until end of hash chain reached */

            if (cchbest >= MINMATCH1)   /* If we have a string match */
            {
                mrci1outstring(icur - ibest,cchbest);
                                        /* Describe matching string */
#ifdef VXD
                if (icur + cchbest >= cch )  /* If end of sector reached */
#else
                if (icur + cchbest >= cchunc)  /* If end of buffer reached */
#endif
                {
                    icur += cchbest;    /* Advance the index */
                    cchbest = 0;        /* reset for next match */
                    break;              /* Done if buffer exhausted */
                }

                icur++;                 /* Skip to first unhashed pair */
#ifdef VXD
                /* avoid re-seeding all of a big match */

                if (cchbest > MAXDISPSMALL)
                {                       /* If big match */
                    icur += cchbest - MAXDISPSMALL - 1;
                                        /* Skip ahead */
                    cchbest = MAXDISPSMALL + 1;
                                        /* Use shorter length */
                }
#endif
                /* update hash tables for each add't char in string */

                ibest = icur % MAXDISPBIG;  /* Get current link table index */

                while (--cchbest != 0)  /* Loop to reseed link table */
                {
                    ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
                    ilink = ahash[ihash];  /* Get link index */
                    ahash[ihash] = icur++;  /* Remember position */
                    alink[ibest] = ilink;  /* Chain on rest of list */

                    if (++ibest < MAXDISPBIG)
                    {
                        continue;       /* Loop if we haven't wrapped yet */
                    }

                    ibest = 0;          /* Wrap to zero */
                }

                assert(cchbest == 0);   /* Counter must be 0 */
            }
            else
            {
                mrci1outsingle(pchbase[icur++]);
                                        /* Else output single character */
                cchbest = 0;            /* Reset counter */
            }
        }

        assert(icur == cch || icur == cch + 1);
                                        /* Must be at or past last character */
        if (icur == cch)
        {
#ifndef VXD
            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */
#endif
            mrci1outsingle(pchbase[icur++]);  /* Output last character */
        }

        assert(icur == cch + 1);        /* Must be past last character */

        mrci1outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
    }

    if (cbitsleft != 8)
    {
        charbuf(abits);                 /* Flush bit buffer */
    }

    if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
    {
        return((unsigned) -1);          /* data expanded or not smaller */
    }

    return(pCompressed - pchcmpBase);   /* Return compressed size */
}


/*
 *  (MRCI2) MaxCompress
 */

unsigned Mrci2MaxCompress(unsigned char FAR *pchbase,unsigned cchunc,
        unsigned char FAR *pchcmpBase,unsigned cchcmpMax)
{
    unsigned cchbest;                   /* Length of best match */
    unsigned cchmatch;                  /* Length of this match */
    unsigned ibest;                     /* Position of best match */
    unsigned icur;                      /* Current position */
    unsigned ihash;                     /* Hash table index */
    unsigned ilink;                     /* Link index */
    unsigned char FAR *pch;             /* Char pointer */
    unsigned char FAR *pch2;            /* Char pointer */
    unsigned char FAR *pchend;          /* End of input (-> last valid) */
    unsigned cch;                       /* per-pass limit */

    cbitsleft = 8;                      /* Buffer is empty */
    abits = 0;
    pCompressed = pchcmpBase;           /* Initialize pointer */

    if (cchunc < cchcmpMax)
    {
        cCompressed = cchunc;           /* limit to source size */
    }
    else
    {
        cCompressed = cchcmpMax;        /* limit to max size offered */
    }

    if (cCompressed < SIG_SIZE)
    {
        return((unsigned) -1);
    }

    *pCompressed++ = 'J';
    *pCompressed++ = 'M';
    *pCompressed++ = '\x00';
    *pCompressed++ = '\x01';

    cCompressed -= SIG_SIZE;

    pch = pchbase;                      /* Initialize */

    if (cchunc-- == 0)
    {
        return(0);                      /* Do nothing to empty buffer */
    }

    inithash();                         /* Initialize tables */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data expanded */
    }

    cchbest = 0;                        /* no match yet */
    icur = 0;                           /* Initialize */

    for (cch = SECTOR - 1; cch <= (cchunc + SECTOR - 1); cch += SECTOR)
    {
        assert(cchbest == 0);           /* must always start with no match */

        if (cch > cchunc)
        {
            cch = cchunc;               /* limit to exact req count */
        }

        pchend = &pchbase[cch];         /* Remember end of buffer */

        while (icur < cch)              /* While at least two chars left */
        {
            /* update hash tables for this character */

            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */

            /* walk hash chain looking for matches */

            while (ilink < icur && icur - ilink <= DISPMAX)
            {                           /* While link is valid and in range */
                pch = &pchbase[icur];   /* Point at first byte */
                pch2 = &pchbase[ilink]; /* Point at first byte */

                if (pch[cchbest] == pch2[cchbest] && word(pch) == word(pch2))
                {                       /* If we have a possible best match */
                    pch += 2;           /* Skip first pair */
                    pch2 += 2;          /* Skip first pair */

                    while (pch <= pchend)  /* Loop to find end of match */
                    {
                        if (*pch != *pch2++)
                        {
                            break;      /* Break if mismatch */
                        }
                        pch++;          /* Skip matching character */
                    }

                    if ((cchmatch = (unsigned)(pch - pchbase) - icur) > cchbest)
                    {                   /* If new best match */
                        cchbest = cchmatch;  /* Remember length */
                        ibest = ilink;  /* Remember position */

                        assert((pch-1) <= pchend);

                        if (pch > pchend)
                        {
                            break;      /* Break if we can't do any better */
                        }
                    }
                }

                assert((alink[ilink % MAXDISPBIG] == (unsigned) -1) ||
                        (alink[ilink % MAXDISPBIG] < ilink));

                ilink = alink[ilink % MAXDISPBIG];
                                        /* Get next link */
            }   /* until end of hash chain reached */

            if (cchbest >= MINMATCH2)   /* If we have a string match */
            {
                mrci2outstring(icur - ibest,cchbest);
                                        /* Describe matching string */
#ifdef VXD
                if (icur + cchbest >= cch )  /* If end of sector reached */
#else
                if (icur + cchbest >= cchunc)  /* If end of buffer reached */
#endif
                {
                    icur += cchbest;    /* Advance the index */
                    cchbest = 0;        /* reset for next match */
                    break;              /* Done if buffer exhausted */
                }

                icur++;                 /* Skip to first unhashed pair */
#ifdef VXD
                /* avoid re-seeding all of a big match */

                if (cchbest > MAXDISPSMALL)
                {                       /* If big match */
                    icur += cchbest - MAXDISPSMALL - 1;
                                        /* Skip ahead */
                    cchbest = MAXDISPSMALL + 1;
                                        /* Use shorter length */
                }
#endif
                /* update hash tables for each add't char in string */

                ibest = icur % MAXDISPBIG;  /* Get current link table index */

                while (--cchbest != 0)  /* Loop to reseed link table */
                {
                    ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
                    ilink = ahash[ihash];  /* Get link index */
                    ahash[ihash] = icur++;  /* Remember position */
                    alink[ibest] = ilink;  /* Chain on rest of list */

                    if (++ibest < MAXDISPBIG)
                    {
                        continue;       /* Loop if we haven't wrapped yet */
                    }

                    ibest = 0;          /* Wrap to zero */
                }

                assert(cchbest == 0);   /* Counter must be 0 */
            }
            else
            {
                mrci2outsingle(pchbase[icur++]);
                                        /* Else output single character */
                cchbest = 0;            /* Reset counter */
            }
        }

        assert(icur == cch || icur == cch + 1);
                                        /* Must be at or past last character */
        if (icur == cch)
        {
#ifndef VXD
            ihash = hash(word(&pchbase[icur]));
                                        /* Get hash index */
            ilink = ahash[ihash];       /* Get link index */
            ahash[ihash] = icur;        /* Remember position */
            alink[icur % MAXDISPBIG] = ilink;
                                        /* Chain on rest of list */
#endif
            mrci2outsingle(pchbase[icur++]);  /* Output last character */
        }

        assert(icur == cch + 1);        /* Must be past last character */

        mrci2outstring(MAXDISPBIG,EOB);  /* Put out an end marker */
    }

    if (cbitsleft != 8)
    {
        charbuf(abits);                 /* Flush bit buffer */
    }

    if ((unsigned) (pCompressed - pchcmpBase) > cchunc)
    {
        return((unsigned) -1);          /* data expanded or not smaller */
    }

    return(pCompressed - pchcmpBase);   /* Return compressed size */
}


/*
 *  (decompress) Get a single bit from the compressed input stream.
 */

static unsigned FAST getbit(void)
{
    unsigned bit;                       /* Bit */

    if (cbitsleft)                      /* If bits available */
    {
        cbitsleft--;                    /* Decrement bit count */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }
    else                                /* no bits available */
    {
        if (cCompressed-- == 0)         /* If buffer empty */
        {
            longjmp(bailout,1);         /* input overrun */
        }

        cbitsleft = 7;                  /* Reset count */

        abits = *pCompressed++;         /* Get a byte */

        bit = abits & 1;                /* Get a bit */

        abits >>= 1;                    /* Remove it */
    }

    return(bit);                        /* Return the bit */
}


/*
 *  (decompress) Get multiple bits from the compressed input stream.
 */

static unsigned FAST getbits(unsigned cbits)
{
    unsigned bits;                      /* Bits to return */
    unsigned cbitsdone;                 /* number of bits added so far */
    unsigned cbitsneeded;               /* number of bits still needed */

    if (cbits <= cbitsleft)             /* If we have enough bits */
    {
        bits = abits;                   /* Get the bits */
        cbitsleft -= cbits;             /* Decrement bit count */
        abits >>= cbits;                /* Remove used bits */
    }
    else                                /* If we'll need to read more bits */
    {
        bits = 0;                       /* No bits set yet */
        cbitsdone = 0;                  /* no bits added yet */
        cbitsneeded = cbits;            /* bits needed */

        do
        {
            if (cbitsleft == 0)         /* If no bits ready */
            {
                if (cCompressed-- == 0) /* count down used */
                {
                    longjmp(bailout,1); /* if input overrun */
                }

                cbitsleft = 8;          /* Reset count */

                abits = *pCompressed++;  /* Get 8 new bits */
            }

            bits |= (abits << cbitsdone);  /* copy bits for output */

            if (cbitsleft >= cbitsneeded)  /* if enough now */
            {
                cbitsleft -= cbitsneeded;  /* reduce bits remaining available */
                abits >>= cbitsneeded;  /* discard used bits */
                break;                  /* got them */
            }
            else                        /* if not enough yet */
            {
                cbitsneeded -= cbitsleft;  /* reduce bits still needed */
                cbitsdone += cbitsleft;  /* increase shift for future bits */
                cbitsleft = 0;          /* reduce bits remaining available */
            }
        } while (cbitsneeded);          /* go back if more bits needed */
    }

    return(bits & BITMASK(cbits));      /* Return the bits */
}


/*
 *  (decompress) Expand a match.
 *
 *  Note: source overwrite is required (so we can't memcpy or memmove)
 */

static void FAST expandstring(unsigned char FAR **ppchout,unsigned disp,
        unsigned cb)
{
    unsigned char FAR *source;
    unsigned char FAR *target;

    assert(cb != 0);

    target = *ppchout;                  /* where the bytes go */
    source = target - disp;             /* where the bytes come from */

    *ppchout += cb;                     /* Update the output pointer */

    while (cb--)
    {
        *target++ = *source++;
    }
}


/*
 *  (MRCI1) Decompress
 */

unsigned Mrci1Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax)
{
    unsigned b;                         /* A byte */
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char FAR *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'D') || (*pCompressed++ != 'S'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    for (;;)
    {
        b = getbits(2);                 /* get two bits */

        if (b == 1)                     /* If single byte 128..255 */
        {                               /* Get the rest of byte */
            *pchout++ = (unsigned char) (getbits(7) | 0x80);
            continue;                   /* Next token */
        }

        if (b == 2)                     /* If single byte 0..127 */
        {                               /* Get the rest of byte */
            *pchout++ = (unsigned char) getbits(7);
            continue;                   /* Next token */
        }

        if (b == 0)
        {
            disp = getbits(6) + MINDISPSMALL;
        }
        else  /* b == 3 */
        {
            if (getbit() == 0)
            {
                disp = getbits(8) + MINDISPMED;
            }
            else
            {
                disp = getbits(12) + MINDISPBIG;
            }
        }

        if (disp == MAXDISPBIG)
        {
            if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
            {
                break;                  /* End marker found */
            }
            else
            {
                continue;               /* End sector found */
            }
        }

        length = 0;                     /* Initialize */

        while (getbit() == 0)
        {
            length++;                   /* Count the leading zeroes */
        }

        assert(b <= 15);                /* Cannot be too big */

        if (length)
        {
            length = getbits(length) + (1 << length) + 1;
        }
        else
        {
            length = 2;
        }

        expandstring(&pchout,disp,length);  /* Copy the match */
    }

    return((pchout - pchdecBase));      /* Return decompressed size */
}


/*
 *  (MRCI2) Decompress
 */

unsigned Mrci2Decompress(unsigned char FAR *pchin,unsigned cchin,
        unsigned char FAR *pchdecBase,unsigned cchdecMax)
{
    unsigned length;                    /* Length of match */
    unsigned disp;                      /* Displacement */
    unsigned char FAR *pchout;          /* Output buffer pointer */

    abits = 0;                          /* Bit buffer is empty */
    cbitsleft = 0;                      /* No bits read yet */
    pCompressed = pchin;                /* setup source pointer */
    cCompressed = cchin;                /* setup source counter */

    if ((cCompressed <= SIG_SIZE) ||    /* must have a signature */
            (*pCompressed++ != 'J') || (*pCompressed++ != 'M'))
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    pCompressed += 2;                   /* ignore flags */
    cCompressed -= SIG_SIZE;

    pchout = pchdecBase;                /* Point at output buffer */

    if (setjmp(bailout) != 0)           /* If failure */
    {
        return((unsigned) -1);          /* Data corrupted */
    }

    for (;;)
    {
        if (getbit() == 0)              /* literal 00..7F */
        {
            *pchout++ = (unsigned char) getbits(7);

            continue;                   /* Next token */
        }

        if (getbit() == 1)              /* literal 80..FF */
        {
            *pchout++ = (unsigned char)(getbits(7) | 0x80);

            continue;                   /* Next token */
        }

        if (getbit() == 0)
        {
            disp = getbits(6) + MINDISPSMALL;
        }
        else
        {
            if (getbit() == 0)
            {
                disp = getbits(8) + MINDISPMED;
            }
            else
            {
                disp = getbits(12) + MINDISPBIG;
            }
        }

        if (disp == MAXDISPBIG)
        {
            if ((unsigned) (pchout - pchdecBase) >= cchdecMax)
            {
                break;                  /* End marker found */
            }
            else
            {
                continue;               /* End sector found */
            }
        }

        length = 0;                     /* Initialize */

        while (getbit() == 0)
        {
            length++;                   /* Count the leading zeroes */
        }

        assert(length <= 15);           /* Cannot be too big */

        if (length)
        {
            length = getbits(length) + (1 << length) + 1;
        }
        else
        {
            length = 2;
        }

        expandstring(&pchout,disp,length + 1);  /* Copy the match */
    }

    return((pchout - pchdecBase));      /* Return decompressed size */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\cbmofout.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CBMOFOUT.CPP

Abstract:

    Declares the CBMOFOut class.

History:

    a-davj  06-April-97   Created.

--*/

#include "precomp.h"
#include "wstring.h"
#include "mofout.h"
#include "mofdata.h"
#include "bmof.h"
#include "cbmofout.h"
#include "trace.h"
#include "strings.h"
#include <wbemutil.h>

//***************************************************************************
//
//  CBMOFOut::CBMOFOut
//
//  DESCRIPTION:
//
//  Constructor.  Save the eventual destination name and writes the initial
//  structure out to the buffer.  NOTE THAT TYPICALLY THE BMOFFileName will
//  be NULL and this object will not do anything.  That deals with the 99%
//  of mofs that are not WMI!
//
//  PARAMETERS:
//
//  BMOFFileName        Name of file to eventually write to.
//
//***************************************************************************

CBMOFOut::CBMOFOut(
                   IN LPTSTR BMOFFileName, PDBG pDbg) : m_OutBuff(pDbg)
{
    m_pDbg = pDbg;
    m_BinMof.dwSignature = BMOF_SIG;              // spells BMOF
    m_BinMof.dwLength = sizeof(WBEM_Binary_MOF);     // updated at end
    m_BinMof.dwVersion = 1;            // 0x1
    m_BinMof.dwEncoding = 1;           // 0x1 = little endian, DWORD-aligned, no compression
    m_BinMof.dwNumberOfObjects = 0;    // Total classes and instances in MOF


    if(BMOFFileName && lstrlen(BMOFFileName) > 0)
    {
        m_pFile = new TCHAR[lstrlen(BMOFFileName) + 1];
        if(m_pFile)
        {
            lstrcpy(m_pFile, BMOFFileName);
            m_OutBuff.AppendBytes((BYTE *)&m_BinMof, sizeof(WBEM_Binary_MOF));
        }
    }
    else 
        m_pFile = NULL;


}
//***************************************************************************
//
//  CBMOFOut::~CBMOFOut
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CBMOFOut::~CBMOFOut()
{
    if(m_pFile)
        delete m_pFile;
}


//***************************************************************************
//
//  DWORD CBMOFOut::AddClass
//
//  DESCRIPTION:
//
//  Adds a class to the BMOF buffer.
//
//  PARAMETERS:
//
//  pObject             pointer to class object.  
//  bEmbedded           TRUE if object is embedded.
//
//  RETURN VALUE:
//
//  Number of bytes written.
//
//***************************************************************************

DWORD CBMOFOut::AddClass(
                        IN CMObject * pObject,
                        IN BOOL bEmbedded)
{
    DWORD dwStartingOffset = m_OutBuff.GetOffset();
    CMoQualifierArray * pQualifierSet = NULL;
    if(!m_pFile)
        return 0;
    WBEM_Object wo;

    wo.dwLength = sizeof(WBEM_Object);       // updated later
    wo.dwOffsetQualifierList = 0xffffffff;
    wo.dwOffsetPropertyList = 0xffffffff;
    wo.dwOffsetMethodList = 0xffffffff;
    wo.dwType = (pObject->IsInstance()) ? 1 : 0;   // 0 = class, 1 = instance

    m_OutBuff.AppendBytes((BYTE *)&wo, sizeof(WBEM_Object));
    DWORD dwStartInfoOffset = m_OutBuff.GetOffset();


    // Write class qualifier

    pQualifierSet = pObject->GetQualifiers();
    if(pQualifierSet)
    {
        wo.dwOffsetQualifierList = m_OutBuff.GetOffset() - dwStartInfoOffset;
        AddQualSet(pQualifierSet);
    }

    wo.dwOffsetPropertyList = m_OutBuff.GetOffset() - dwStartInfoOffset;
    AddPropSet(pObject);

    wo.dwOffsetMethodList = m_OutBuff.GetOffset() - dwStartInfoOffset;
    AddMethSet(pObject);

    wo.dwLength = m_OutBuff.GetOffset() - dwStartingOffset;
    m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&wo, sizeof(WBEM_Object));

    // If the object is not embedded, update the structure that keeps track 
    // of top level objects.

    if(!bEmbedded)
    {
        m_BinMof.dwNumberOfObjects++;
        m_BinMof.dwLength = m_OutBuff.GetOffset();
        m_OutBuff.WriteBytes(0, (BYTE *)&m_BinMof, 
                            sizeof(WBEM_Binary_MOF));
    }

    return wo.dwLength;
}

//***************************************************************************
//
//  DWORD CBMOFOut::AddQualSet
//
//  DESCRIPTION:
//
//  Adds a qualifier set to the BMOF buffer.
//
//  PARAMETERS:
//
//  pQualifierSet       pointer to qualifier object. 
//
//  RETURN VALUE:
//
//  Number of bytes written.
//
//***************************************************************************

DWORD CBMOFOut::AddQualSet(
                        IN CMoQualifierArray * pQualifierSet)
{
    DWORD dwStartingOffset = m_OutBuff.GetOffset();
    WBEM_QualifierList ql;
    ql.dwLength = sizeof(WBEM_QualifierList);
    ql.dwNumQualifiers = 0;

    m_OutBuff.AppendBytes((BYTE *)&ql, sizeof(WBEM_QualifierList));
    BSTR bstr = NULL;
    VARIANT var;
    VariantInit(&var);

    int i;
    for(i = 0; i < pQualifierSet->GetSize(); i++)
    {
        CMoQualifier * pQual = pQualifierSet->GetAt(i);
        if(pQual)
        {
            ql.dwNumQualifiers++;
            AddQualifier(pQual->GetName(), pQual->GetpVar(), pQual);
        }
    }
    
    ql.dwLength = m_OutBuff.GetOffset() - dwStartingOffset;
    m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&ql, 
                                    sizeof(WBEM_QualifierList));
    return ql.dwLength;
}

//***************************************************************************
//
//  DWORD CBMOFOut::AddPropSet
//
//  DESCRIPTION:
//
//  Adds the property set to the BMOF buffer.
//
//  PARAMETERS:
//
//  pObject          pointer to class object.
//
//  RETURN VALUE:
//
//  Number of bytess written
//
//***************************************************************************

DWORD CBMOFOut::AddPropSet(
                        IN CMObject * pObject)
{
    DWORD dwStartingOffset = m_OutBuff.GetOffset();
    WBEM_PropertyList pl;

    BSTR bstr = NULL;
    VARIANT var;
    VariantInit(&var);
    IWbemQualifierSet* pQual = NULL;

    pl.dwLength = sizeof(WBEM_PropertyList);       // updated later
    pl.dwNumberOfProperties = 0;
    m_OutBuff.AppendBytes((BYTE *)&pl, sizeof(WBEM_PropertyList));

    // Loop through the properties

    int i;
    for(i = 0; i < pObject->GetNumProperties(); i++)
    {
        CMoProperty * pProp = pObject->GetProperty(i);
        if(pProp && pProp->IsValueProperty())
        {
            pl.dwNumberOfProperties++;
            CMoQualifierArray * pQual = pProp->GetQualifiers();
            AddProp(pProp->GetName(), pProp->GetpVar(), pQual,pProp->GetType(),pProp);
        }
    }
    
    // Store the class name and possibly the parent name as properties.

    VariantInit(&var);
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(pObject->GetClassName()); 
    AddProp(L"__CLASS", &var, NULL,VT_BSTR,NULL);
    pl.dwNumberOfProperties++;
    VariantClear(&var);

    if(pObject->GetNamespace() && wcslen(pObject->GetNamespace()) > 0)
    {
        VariantInit(&var);
        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString(pObject->GetNamespace()); 
        AddProp(L"__NAMESPACE", &var, NULL,VT_BSTR,NULL);
        pl.dwNumberOfProperties++;
        VariantClear(&var);
    }

    if(pObject->GetClassFlags() != 0)
    {
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = pObject->GetClassFlags(); 
        AddProp(L"__CLASSFLAGS", &var, NULL,VT_I4,NULL);
        pl.dwNumberOfProperties++;
        VariantClear(&var);
    }
    if(pObject->GetInstanceFlags() != 0)
    {
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = pObject->GetInstanceFlags(); 
        AddProp(L"__INSTANCEFLAGS", &var, NULL,VT_I4,NULL);
        pl.dwNumberOfProperties++;
        VariantClear(&var);
    }

    if(pObject->GetAlias() && wcslen(pObject->GetAlias()) > 0)
    {
        VariantInit(&var);
        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString(pObject->GetAlias()); 
        AddProp(L"__ALIAS", &var, NULL,VT_BSTR,NULL);
        pl.dwNumberOfProperties++;
        VariantClear(&var);
    }

    if(!pObject->IsInstance())
    {
        CMoClass * pClass = (CMoClass * )pObject;
        var.vt = VT_BSTR;
        if(pClass->GetParentName() && wcslen(pClass->GetParentName()) > 0)
        {
            var.bstrVal = SysAllocString(pClass->GetParentName()); 
            AddProp(L"__SUPERCLASS", &var, NULL,VT_BSTR,NULL);
            pl.dwNumberOfProperties++;
            VariantClear(&var);
        }
    };

    
    pl.dwLength = m_OutBuff.GetOffset() - dwStartingOffset;
    m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&pl, 
                                    sizeof(WBEM_PropertyList));
    return pl.dwLength;
}

//***************************************************************************
//
//  DWORD CBMOFOut::AddMethSet
//
//  DESCRIPTION:
//
//  Adds the method set to the BMOF buffer.
//
//  PARAMETERS:
//
//  pObject          pointer to class object.
//
//  RETURN VALUE:
//
//  Number of bytess written
//
//***************************************************************************

DWORD CBMOFOut::AddMethSet(
                        IN CMObject * pObject)
{
    DWORD dwStartingOffset = m_OutBuff.GetOffset();
    WBEM_PropertyList ml;
    SCODE sc;

    IWbemQualifierSet* pQual = NULL;

    ml.dwLength = sizeof(WBEM_PropertyList);       // updated later
    ml.dwNumberOfProperties = 0;
    m_OutBuff.AppendBytes((BYTE *)&ml, sizeof(WBEM_PropertyList));

    // Loop through the properties

    int i;
    for(i = 0; i < pObject->GetNumProperties(); i++)
    {
        CMoProperty * pProp = pObject->GetProperty(i);
        if(pProp && !pProp->IsValueProperty())
        {
            ml.dwNumberOfProperties++;
            CMoQualifierArray * pQual = pProp->GetQualifiers();

            // Create a variant that has an array of embedded object for each of out
            // input and output arg sets

            CMethodProperty * pMeth = (CMethodProperty *)pProp;
            VARIANT vSet;
            if(pMeth->GetInObj() || pMeth->GetOutObj())
            {
                vSet.vt = VT_ARRAY | VT_EMBEDDED_OBJECT;

                SAFEARRAYBOUND aBounds[1];
                
                // Note the you might have either inputs, or ouputs, or both

                if(pMeth->GetInObj() && pMeth->GetOutObj())
                    aBounds[0].cElements = 2;
                else
                    aBounds[0].cElements = 1;
                aBounds[0].lLbound = 0;
#ifdef _WIN64
                vSet.parray = SafeArrayCreate(VT_R8, 1, aBounds);
#else
                vSet.parray = SafeArrayCreate(VT_I4, 1, aBounds);
#endif
                if(vSet.parray == NULL)
                    return FALSE;
                long lIndex = 0;
                VARIANT var;

                if(pMeth->GetInObj())
                {
                    var.punkVal = (IUnknown *)pMeth->GetInObj();
                    sc = SafeArrayPutElement(vSet.parray, &lIndex, &var.punkVal);
                    lIndex = 1;
                }
                if(pMeth->GetOutObj())
                {
                    var.punkVal = (IUnknown *)pMeth->GetOutObj();
                    sc = SafeArrayPutElement(vSet.parray, &lIndex, &var.punkVal);
                }
            }
            else
                vSet.vt = VT_NULL;
            AddProp(pProp->GetName(), &vSet, pQual,pProp->GetType(),pProp);
        }
    }
    
    ml.dwLength = m_OutBuff.GetOffset() - dwStartingOffset;
    m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&ml, 
                                    sizeof(WBEM_PropertyList));
    return ml.dwLength;
}

//***************************************************************************
//
//  DWORD CBMOFOut::AddProp
//
//  DESCRIPTION:
//
//  Adds a single property to the BMOF buffer.
//
//  PARAMETERS:
//
//  bstr                property name
//  pvar                variant containing value
//  pQual               pointer to qualifier set if any.  Caller will release.
//  dwType              data type.  Note that the variant might have type
//                      VT_NULL if the property doesnt have a value.
//  RETURN VALUE:
//
//  Number of bytes written
//
//***************************************************************************

DWORD CBMOFOut::AddProp(
                        IN BSTR bstr, 
                        IN VARIANT * pvar, 
                        IN CMoQualifierArray * pQual,
                        IN DWORD dwType,
                        IN CMoProperty * pProp)
{
    DWORD dwStartingOffset = m_OutBuff.GetOffset();
    WBEM_Property prop;
    prop.dwLength = sizeof(WBEM_Property);
    if(pvar->vt == VT_NULL || pvar->vt == VT_EMPTY)
        prop.dwType = dwType;
    else
        prop.dwType = pvar->vt;

    prop.dwOffsetName = 0xffffffff;
    prop.dwOffsetValue = 0xffffffff;
    prop.dwOffsetQualifierSet = 0xffffffff;
    m_OutBuff.AppendBytes((BYTE *)&prop, sizeof(WBEM_Property));

    DWORD dwStartInfoOffset =  m_OutBuff.GetOffset();

    if(bstr)
    {
        prop.dwOffsetName = m_OutBuff.GetOffset() - dwStartInfoOffset;
        m_OutBuff.WriteBSTR(bstr);
    }
    
    if(pvar->vt != VT_EMPTY && pvar->vt != VT_NULL)
    {
        prop.dwOffsetValue = m_OutBuff.GetOffset() - dwStartInfoOffset;
        if(pProp)
        {
            CMoValue& Value = pProp->AccessValue();
            AddVariant(pvar, &Value);
            prop.dwType = pvar->vt;
        }
        else 
            AddVariant(pvar, NULL);
    }

    if(pQual)
    {
        prop.dwOffsetQualifierSet = m_OutBuff.GetOffset() - dwStartInfoOffset;
        AddQualSet(pQual);
    }

    prop.dwLength = m_OutBuff.GetOffset() - dwStartingOffset;
    m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&prop, 
                                    sizeof(WBEM_Property));
    return 1;

}


//***************************************************************************
//
//  DWORD CBMOFOut::AddQualifier
//
//  DESCRIPTION:
//
//  Adds a qualifier to the BMOF buffer.
//
//  PARAMETERS:
//
//  bstr                qualifer name
//  pvar                qualifier value
//
//  RETURN VALUE:
//
//  Number of bytes written.
//
//***************************************************************************

DWORD CBMOFOut::AddQualifier(
                        IN BSTR bstr, 
                        IN VARIANT * pvar,
                        CMoQualifier * pQual)
{
    WBEM_Qualifier qu;
    DWORD dwStartingOffset = m_OutBuff.GetOffset();
    
    long lFlavor = pQual->GetFlavor();
    if(pQual->IsAmended())
        lFlavor |= WBEM_FLAVOR_AMENDED;
    if(lFlavor)
        m_OutBuff.AddFlavor(lFlavor);
    qu.dwLength = sizeof(WBEM_Qualifier);           // filled in later
    qu.dwType = pvar->vt;
    qu.dwOffsetName = 0xffffffff;
    qu.dwOffsetValue = 0xffffffff;
    m_OutBuff.AppendBytes((BYTE *)&qu, sizeof(WBEM_Qualifier));
    DWORD dwStartInfoOffset = m_OutBuff.GetOffset();

    // Write the qualifier name and data

    if(bstr)
    {
        qu.dwOffsetName = m_OutBuff.GetOffset() - dwStartInfoOffset;
        m_OutBuff.WriteBSTR(bstr);
    }

    if(pvar->vt != VT_EMPTY && pvar->vt != VT_NULL)
    {
        CMoValue& Value = pQual->AccessValue();

        qu.dwOffsetValue = m_OutBuff.GetOffset() - dwStartInfoOffset;
        

        AddVariant(pvar, &Value);
        qu.dwType = pvar->vt;
    }
    qu.dwLength = m_OutBuff.GetOffset() - dwStartingOffset;
    m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&qu, 
                                    sizeof(WBEM_Qualifier));

    return 0;
}

//***************************************************************************
//
//  DWORD CBMOFOut::AddVariant
//
//  DESCRIPTION:
//
//  Adds a value to the BMOF buffer.
//
//  PARAMETERS:
//
//  pvar                value to add.
//
//  RETURN VALUE:
//
//  Total bytes written
//
//***************************************************************************

DWORD CBMOFOut::AddVariant(VARIANT * pvar, CMoValue * pValue)
{

    if(pValue && pValue->GetNumAliases() > 0)
        pvar->vt |= VT_BYREF;

    VARTYPE vtSimple = pvar->vt & ~VT_ARRAY  & ~VT_BYREF;

    if(pvar->vt & VT_ARRAY)
    {
        DWORD dwStartingOffset = m_OutBuff.GetOffset();
        DWORD dwSize = 0;
        m_OutBuff.AppendBytes((BYTE *)&dwSize, sizeof(DWORD));

        DWORD dwTotal = 0;
        SCODE sc;
        SAFEARRAY * psa;
        long ix[2] = {0,0};
        long uLower, uUpper;
        psa = pvar->parray;
        sc = SafeArrayGetLBound(psa,1,&uLower);
        sc |= SafeArrayGetUBound(psa,1,&uUpper);
        if(sc != S_OK)
            return 0;
        
        // write the number of dimensions and the size of each
        
        DWORD dwNumDim = 1;                                     // for now!!!
        m_OutBuff.AppendBytes((BYTE *)&dwNumDim, sizeof(long)); // Number of dimensions
        DWORD dwNumElem = uUpper - uLower + 1;
        m_OutBuff.AppendBytes((BYTE *)&dwNumElem, sizeof(long));

        // Write out the row size

        DWORD dwStartingRowOffset = m_OutBuff.GetOffset();
        DWORD dwRowSize = 0;
        m_OutBuff.AppendBytes((BYTE *)&dwRowSize, sizeof(DWORD));

        // Get each element and write it

        for(ix[0] = uLower; ix[0] <= uUpper && sc == S_OK; ix[0]++) 
        {
            VARIANT var;
            VariantInit(&var);
            var.vt = vtSimple;
            sc = SafeArrayGetElement(psa,ix,&var.bstrVal);
            if(sc != S_OK)
            {
                Trace(true, m_pDbg, SAFE_ARRAY_ERROR);
            }
            if(ix[0] < uUpper)
                m_OutBuff.SetPadMode(FALSE);
            else
                m_OutBuff.SetPadMode(TRUE);
            dwTotal += AddSimpleVariant(&var, ix[0], pValue);
            if(var.vt != VT_EMBEDDED_OBJECT)    // Our dispatch is actual a CMObject *
                VariantClear(&var);
        }

        // Update the size of the property and the row.  Note that having a separate size
        // is for possible future support of multi dimensional arrays.

        dwRowSize = m_OutBuff.GetOffset() - dwStartingRowOffset;
        m_OutBuff.WriteBytes(dwStartingRowOffset, (BYTE *)&dwRowSize, 
                                    sizeof(DWORD));

        dwSize = m_OutBuff.GetOffset() - dwStartingOffset;
        m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&dwSize, 
                                    sizeof(DWORD));

        return dwTotal;
 
    }
    else
        return AddSimpleVariant(pvar, -1, pValue);
}

//***************************************************************************
//
//  DWORD CBMOFOut::AddSimpleVariant
//
//  DESCRIPTION:
//
//  Adds a non array variant to the BMOF buffer.
//
//  PARAMETERS:
//
//  pvar                value to add.
//  iIndex              set to -1 if property in scalar, or if array, has
//                      the index of this element.  Note that arrays are
//                      broken up into simple variants.
//  
//
//  RETURN VALUE:
//
//  Bytes written
//***************************************************************************

DWORD CBMOFOut::AddSimpleVariant(VARIANT * pvar, int iIndex, CMoValue * pValue)
{
    DWORD dwSize = iTypeSize(pvar->vt & ~VT_BYREF);
    VARTYPE vtSimple = pvar->vt & ~VT_BYREF;
    if(pValue && pValue->GetNumAliases() && (vtSimple == VT_BSTR))
    {
        WCHAR * wszAlias = NULL;
        int iTry, iAlIndex = -1;
                
        if(iIndex == -1)
            pValue->GetAlias(0, wszAlias, iAlIndex);
        else
        {
            for(iTry = 0; iTry < pValue->GetNumAliases(); iTry++)
            {
                pValue->GetAlias(iTry, wszAlias, iAlIndex);
                if(iIndex == iAlIndex)
                    break;
            }
            if(iTry == pValue->GetNumAliases())
                wszAlias = NULL;
        }
        if(wszAlias && iIndex == -1)
                pvar->bstrVal = SysAllocString(wszAlias);
        
        else if(wszAlias && iIndex != -1)
        {
            WCHAR * pTemp = new WCHAR[wcslen(wszAlias)+2];
            if(pTemp == NULL)
                return 0;
            pTemp[0]= L'$';
            wcscpy(pTemp+1, wszAlias);
            pvar->bstrVal = SysAllocString(pTemp);
            delete pTemp;
        }
        else if(wszAlias == NULL && iIndex != -1)
        {
            WCHAR * pTemp = new WCHAR[wcslen(pvar->bstrVal)+2];
            if(pTemp == NULL)
                return 0;
            pTemp[0]= L' ';
            wcscpy(pTemp+1, pvar->bstrVal);
            pvar->bstrVal = SysAllocString(pTemp);
            delete pTemp;
        }


    }
    if(vtSimple == VT_BSTR)
        return m_OutBuff.WriteBSTR(pvar->bstrVal);
    else if(vtSimple == VT_EMBEDDED_OBJECT)
    {
        CMObject * pObj = (CMObject *)pvar->punkVal;
        return AddClass(pObj, TRUE);
    }
    else
        return m_OutBuff.AppendBytes((BYTE *)&pvar->bstrVal, dwSize);
}

//***************************************************************************
//
//  BOOL CBMOFOut::WriteFile
//
//  DESCRIPTION:
//
//  Writes the buffer out to the file.
//
//***************************************************************************

BOOL CBMOFOut::WriteFile()
{
    BOOL bRet = FALSE;
    if(m_pFile)
    {
        m_BinMof.dwLength = m_OutBuff.GetOffset();
        m_OutBuff.WriteBytes(0, (BYTE *)&m_BinMof, sizeof(WBEM_Binary_MOF));
#ifdef  UNICODE
        char cFile[MAX_PATH];
        wcstombs(cFile, m_pFile, MAX_PATH);
        bRet = m_OutBuff.WriteToFile(cFile);
#else
        bRet = m_OutBuff.WriteToFile(m_pFile);
#endif
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\cbmofout.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CBMOFOUT.H

Abstract:

	Declares the CBMOFOut class.

History:

	a-davj  06-April-97   Created.

--*/

#ifndef __CBMOFOUT__H_
#define __CBMOFOUT__H_

#include "cout.h"
#include <WBEMIDL.H>

//***************************************************************************
//
//  CLASS NAME:
//
//  CBMOFOut
//
//  DESCRIPTION:
//
//  Provides an easy way for outputting class information into a binary mof
//  file.  Users will create an instance, passing the eventual file name, and
//  then just add classes.
//
//***************************************************************************

class CBMOFOut {
  public:
    CBMOFOut(LPTSTR BMOFFileName, PDBG pDbg);
    ~CBMOFOut();
    DWORD AddClass(CMObject * pObject, BOOL bEmbedded);
    BOOL WriteFile();

  private:
    DWORD AddQualSet(CMoQualifierArray * pQualifierSet);
    DWORD AddPropSet(CMObject * pWbemObject);
    DWORD AddMethSet(CMObject * pWbemObject);
    DWORD AddQualifier(BSTR bstr, VARIANT * pvar, CMoQualifier * pQual);
    DWORD AddProp(BSTR bstr, VARIANT * pvar, CMoQualifierArray * pQual,DWORD dwType, CMoProperty * pProp);
    DWORD AddVariant(VARIANT * pvar, CMoValue * pVal);
    DWORD AddSimpleVariant(VARIANT * pvar, int iIndex, CMoValue * pValue);
    COut m_OutBuff;
    TCHAR * m_pFile;
    WBEM_Binary_MOF m_BinMof;
	PDBG m_pDbg;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\bmofhelp.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    BMOFHELP.CPP

Abstract:

    Creates the object list from the binary mof file

History:

	a-davj  14-April-97   Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include <float.h>
#include <mofout.h>
#include <mofparse.h>
#include <moflex.h>
#include <mofdata.h>

#include <typehelp.h>

#include <io.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
//#include <corepol.h>
#include <wbemutil.h>
#include <genutils.h>

#include "bmof.h"
#include "cbmofout.h"
#include "bmofhelp.h"
#include "trace.h"
#include "strings.h"
#include "mrcicode.h"
#include <autoptr.h>
long lObjectNumber = 0;
class CFreeMe
{
private:
    VARIANT * m_pVar;
public:
    CFreeMe(VARIANT * pVar){m_pVar = pVar;};
    ~CFreeMe();

};

CFreeMe::~CFreeMe()
{
    if(m_pVar)
    {
        VARTYPE vt = m_pVar->vt & ~VT_ARRAY;
        try
        {
            if(vt == VT_BSTR)
                VariantClear(m_pVar);
            else if(m_pVar->vt & VT_ARRAY)
                SafeArrayDestroyDescriptor(m_pVar->parray);
            m_pVar->vt = VT_EMPTY;


        }
        catch(...)
        {}
    }
    
}

//***************************************************************************
//
//  CMoQualifierArray *  CreateQual
//
//  DESCRIPTION:
//
//  Creates a CMoQualifierArray by using a CBMOFQualList object.
//
//  RETURN VALUE:
//
//  Pointer to new object, NULL if error.
//
//***************************************************************************

CMoQualifierArray *  CreateQual(CMofData * pOutput, CBMOFQualList * pql, CMObject * pObj,LPCWSTR wszPropName, PDBG pDbg)
{
    ResetQualList(pql);

    WCHAR * pName = NULL;
    DWORD dwFlavor= 0;
    CBMOFDataItem Data;
    VARIANT var;
    VariantInit(&var);
	CMoQualifierArray * pRet = new CMoQualifierArray(pDbg);
    if(pRet == NULL)
        return NULL;
    while(NextQualEx(pql, &pName, &Data, &dwFlavor, pOutput->GetBmofBuff(), pOutput->GetBmofToFar()))
    {
        BOOL bAliasRef;
        VariantInit(&var);
        BMOFToVariant(pOutput, &Data, &var, bAliasRef,FALSE, pDbg);
        CFreeMe fm(&var);
        wmilib::auto_ptr<CMoQualifier> pQual(new CMoQualifier(pDbg));
        if(pQual.get() == NULL)
            return NULL;
        if(pName == NULL || FAILED(pQual->SetQualName(pName)))
            return NULL;
        if(dwFlavor)
        {
            if(dwFlavor & WBEM_FLAVOR_AMENDED)
            {
                pQual->SetAmended(true);
            }
            else
                pQual->SetAmended(false);
            pQual->SetFlavor(dwFlavor);
        }
		BOOL bArray = var.vt & VT_ARRAY;
        if(bAliasRef && !bArray)
        {
            CMoValue & Value = pQual->AccessValue();
            if(FAILED(AddAliasReplaceValue(Value, var.bstrVal)))
                return NULL;
        }
		else if(bAliasRef && bArray)
		{
			SAFEARRAY* psaSrc = var.parray;
			long lLBound, lUBound;
			SafeArrayGetLBound(psaSrc, 1, &lLBound);
			SafeArrayGetUBound(psaSrc, 1, &lUBound);
			CMoValue & Value = pQual->AccessValue();

	        for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
		    {
			    // Load the initial data element into a VARIANT
				// ============================================

				BSTR bstr;
				SafeArrayGetElement(psaSrc, &lIndex, &bstr);

				if(bstr[0] == L'$')
				{
        			        SCODE sc = Value.AddAlias(&bstr[1], lIndex);	// skip the leading $
					if(FAILED(sc))
						return NULL;
	                GUID guid;
					CoCreateGuid(&guid);

					WCHAR wszGuidBuffer[100];
					StringFromGUID2(guid, wszGuidBuffer, 100);

					BSTR bstrNew = SysAllocString(wszGuidBuffer);
					if(bstrNew == NULL)
						return NULL;
					sc = SafeArrayPutElement(psaSrc, &lIndex, bstrNew);
					SysFreeString(bstrNew);
					if(FAILED(sc))
						return NULL;
				}
			}
			SCODE sc = WbemVariantChangeType(pQual->GetpVar(), &var, var.vt);
		}
        else
        {
            SCODE sc = WbemVariantChangeType(pQual->GetpVar(), &var, var.vt);
        }
//        VariantClear(&var);
        free(pName);
        if (pRet->Add(pQual.get()))
        {
            pQual.release();
        }
    }
    pRet->RegisterAliases(pObj,wszPropName);
    return pRet;
}

//***************************************************************************
//
//  SCODE ConvertValue
//
//  DESCRIPTION:
//
//  Creates a CMoQualifierArray by using a CBMOFQualList object.
//
//  RETURN VALUE:
//
//  Pointer to new object, NULL if error.
//
//***************************************************************************

SCODE ConvertValue(CMoProperty * pProp, VARIANT * pSrc, BOOL bAliasRef)
{
    VARIANT * pDest;
    pDest = pProp->GetpVar();
	if((pSrc->vt & ~VT_ARRAY) == VT_EMBEDDED_OBJECT)
	{
		pDest->vt = pSrc->vt;
		pDest->punkVal = pSrc->punkVal;		// also works if this is parrayVal!
        pSrc->vt = VT_EMPTY;                // DONT CLEAR THIS since destination is taking ownership
		return S_OK;
	}
    if(!bAliasRef)
        return WbemVariantChangeType(pProp->GetpVar(), pSrc, pSrc->vt);
    if(pSrc->vt == VT_BSTR)
    {
        CMoValue & Value = pProp->AccessValue();
        return AddAliasReplaceValue(Value, pSrc->bstrVal);
    }
    if(pSrc->vt == (VT_BSTR | VT_ARRAY))
    {
        SAFEARRAY* psaSrc = V_ARRAY(pSrc);

        long lLBound, lUBound;
        SafeArrayGetLBound(psaSrc, 1, &lLBound);
        SafeArrayGetUBound(psaSrc, 1, &lUBound);

        // Stuff the individual data pieces
        // ================================

        for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
        {
            // Load the initial data element into a VARIANT
            // ============================================

            BSTR bstr;
            SafeArrayGetElement(psaSrc, &lIndex, &bstr);

            if(bstr[0] == L' ')
            {
                BSTR bstrNew = SysAllocString(&bstr[1]);
                if(bstrNew == NULL)
                	return WBEM_E_OUT_OF_MEMORY;
                SCODE sc2 = SafeArrayPutElement(psaSrc, &lIndex, bstrNew);
                SysFreeString(bstrNew);
                if(FAILED(sc2))
                	return sc2;
            }
            else
            {
        
                CMoValue & Value = pProp->AccessValue();
                HRESULT hr2 = Value.AddAlias(&bstr[1],lIndex);  // skip over the $ used it indcate alias
                if(FAILED(hr2))
                    return hr2;

                // Create a unique value and put it in there
                // =========================================

                GUID guid;
                CoCreateGuid(&guid);

                WCHAR wszGuidBuffer[100];
                StringFromGUID2(guid, wszGuidBuffer, 100);

                BSTR bstrNew = SysAllocString(wszGuidBuffer);
                if(bstrNew == NULL)
                	return WBEM_E_OUT_OF_MEMORY;
                SCODE sc2 = SafeArrayPutElement(psaSrc, &lIndex, bstrNew);
                SysFreeString(bstrNew);
                if(FAILED(sc2))
                	return sc2;
            }
        }

        return WbemVariantChangeType(pProp->GetpVar(), pSrc, pSrc->vt);

    }
    else
        return WBEM_E_FAILED;
}

//***************************************************************************
//
//  BOOL ConvertBufferIntoIntermediateForm()
//
//  DESCRIPTION:
//
//  Creates a CMObject (the parse object format) from a CBMOFObj (binary mof format)
//  object.
//
//  PARAMETERS:
//
//  pOutput				Pointer to object that will hold the intermediate data.
//  pBuff				Binary mof data.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL ConvertBufferIntoIntermediateForm(CMofData * pOutput, BYTE * pBuff, PDBG pDbg, BYTE * pBmofToFar)
{

	CBMOFObj * po;
	BOOL bRet;
    // Create a ObjList object

    pOutput->SetBmofBuff(pBuff);
    pOutput->SetBmofToFar(pBmofToFar);
    CBMOFObjList * pol = CreateObjList(pBuff);
    ResetObjList(pol);

    lObjectNumber = 0;
    while(po = NextObj(pol))
    {
        if(!BMOFParseObj(pOutput, po, NULL, FALSE, pDbg))
        {
            free(po);
            return FALSE;
        }
        free(po);
        lObjectNumber++;
    }
    bRet = TRUE;            // Got all the way through with no errors.
    free(pol);

    return bRet;
}


//***************************************************************************
//
//  BOOL BMOFParseObj
//
//  DESCRIPTION:
//
//  Creates a CMObject (the parse object format) from a CBMOFObj (binary mof format)
//  object.
//
//  PARAMETERS:
//
//  pObj				pointer to binary mof object.
//	pVar				poninter to a variant which will point to the resulting 
//						object.  If this is NULL, then the object is a top level
//						(not embedded) object and it will be added to the main
//						object list.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL BMOFParseObj(CMofData * pOutput, CBMOFObj * po, VARIANT * pVar, BOOL bMethArg, PDBG pDbg)
{
	VARIANT var;
    CBMOFDataItem Data;
    WCHAR * pClassName;
    BOOL bAliasRef;
    CMoQualifierArray * paQualifiers;
    wmilib::auto_ptr<CMObject> pObject;


    // Check the type.  This is a sanity check for weeding out old format files!

    DWORD dwType = GetType(po);
    if(dwType != 0 && dwType != 1)
    {
        Trace(true,pDbg,INVALID_BMOF_OBJECT_TYPE);
        return FALSE;
    }

    // Create either the new class of instance object

    if(!GetName(po, &pClassName))
    {
        Trace(true,pDbg, CANT_FIND_CLASS_NAME);
        return FALSE;
    }
    
    if(GetType(po) == 0)
    {
        if(FindProp(po, L"__SuperClass", &Data))
        {
            BMOFToVariant(pOutput, &Data, &var, bAliasRef, FALSE, pDbg);

            pObject.reset(new CMoClass( var.bstrVal, pClassName, pDbg));
            VariantClear(&var);
        }
        else
            pObject.reset(new CMoClass( NULL, pClassName, pDbg));
    }
    else
    {
        pObject.reset(new CMoInstance(pClassName, pDbg));
    }
    free(pClassName);
    if(pObject.get() == NULL)
        return FALSE;
    if(pObject->IsOK() == false)
        return FALSE;

    // Get the namespace and add it

    if(FindProp(po, L"__Namespace", &Data))
    {
        BMOFToVariant(pOutput, &Data, &var, bAliasRef, FALSE, pDbg);
        HRESULT hr = pObject->SetNamespace(var.bstrVal);
        VariantClear(&var);
        if(FAILED(hr))
            return FALSE;
    }

    // Add other pragma values

    long lClass = 0;
    long lInstance = 0;
    if(FindProp(po, L"__ClassFlags", &Data))
	{
        BMOFToVariant(pOutput, &Data, &var, bAliasRef, FALSE, pDbg);
		lClass = var.lVal;
		VariantClear(&var);
	}
    if(FindProp(po, L"__InstanceFlags", &Data))
	{
        BMOFToVariant(pOutput, &Data, &var, bAliasRef, FALSE, pDbg);
		lInstance = var.lVal;
		VariantClear(&var);
	}
    pObject->SetOtherDefaults(lClass, lInstance);


    if(FindProp(po, L"__ALIAS", &Data))
    {
        BMOFToVariant(pOutput, &Data, &var, bAliasRef, FALSE, pDbg);
        HRESULT hr2 = pObject->SetAlias(var.bstrVal);
        VariantClear(&var);
        if(FAILED(hr2))
        {
            return FALSE;
        }
    }

    CBMOFQualList * pql = GetQualList(po);
	if(pql)
	{
		paQualifiers = CreateQual(pOutput, pql, pObject.get(), NULL, pDbg);
		if(paQualifiers)
			pObject->SetQualifiers(paQualifiers);
			
        free(pql);
	}

    ResetObj(po);

    WCHAR * pPropName = NULL;

    while(NextProp(po, &pPropName, &Data))
    {
        VariantInit(&var);
        BOOL bGotValue = BMOFToVariant(pOutput, &Data, &var, bAliasRef, FALSE, pDbg);
        CFreeMe fm(&var);
            
        // ignore these special properties

        if(!wbem_wcsicmp(pPropName,L"__Class") || 
           !wbem_wcsicmp(pPropName,L"__SuperClass") ||
           !wbem_wcsicmp(pPropName,L"__ALIAS") ||
           !wbem_wcsicmp(pPropName,L"__CLASSFLAGS") ||
           !wbem_wcsicmp(pPropName,L"__INSTANCEFLAGS") ||
           !wbem_wcsicmp(pPropName,L"__NameSpace"))
        {
            free(pPropName);
            continue;
        }


        wmilib::auto_ptr<CValueProperty> pProp( new CValueProperty(NULL, pDbg));
        if(pProp.get() == NULL)
            return FALSE;
        if(FAILED(pProp->SetPropName(pPropName)))
            return FALSE;

	    pql = GetPropQualList(po, pPropName);
        paQualifiers = NULL;
		if(pql)
		{
			if(paQualifiers = CreateQual(pOutput, pql, pObject.get(), pPropName, pDbg))
				pProp->SetQualifiers(paQualifiers);
                    free(pql);
                    if(paQualifiers == NULL)
                        return FALSE;
		}
		if(bGotValue)
        {
			SCODE sc = ConvertValue(pProp.get(), &var, bAliasRef);
        }
		else
		{
			VARIANT * t_pVar = pProp->GetpVar();
			t_pVar->vt = VT_NULL;
			t_pVar->lVal = 0;
		}

        // Set the type.  Note that numeric types are stored as strings and so it is necessary to
        // get the type from the cimtype qualifier

        CMoValue* pValue = NULL;
        if(paQualifiers)
            pValue = paQualifiers->Find(L"CIMTYPE");
        if(pValue)
        {
            CMoType Type(pDbg);
            VARIANT& varRef = pValue->AccessVariant();
            if(varRef.vt == VT_BSTR && varRef.bstrVal)
            {
                HRESULT hr2 = Type.SetTitle(varRef.bstrVal);
                if(FAILED(hr2))
                {
                    return FALSE;
                }
                VARTYPE vt = Type.GetCIMType();
                if(Data.m_dwType & VT_ARRAY)
                    vt |= VT_ARRAY;
                pProp->SetType(vt);
            }
        }
        else
            pProp->SetType((VARTYPE)Data.m_dwType);

        if (pObject->AddProperty(pProp.get()))
        {
            pProp->RegisterAliases(pObject.get());           
            if(bMethArg)
                pProp->SetAsArg(); 
            pProp.release();             
        }

        free(pPropName);
        pPropName = NULL;
    }

    // Get the methods
    
    WCHAR * pMethName = NULL;

    while(NextMeth(po, &pMethName, &Data))
    {
        VariantClear(&var);
		BOOL bGotValue = BMOFToVariant(pOutput, &Data, &var, bAliasRef, TRUE, pDbg);
        CFreeMe fm(&var);
        wmilib::auto_ptr<CMethodProperty> pMeth( new CMethodProperty(NULL, pDbg, TRUE));
        if(pMeth.get() == NULL)
            return FALSE;
        if(FAILED(pMeth->SetPropName(pMethName)))
            return FALSE;

	    pql = GetMethQualList(po, pMethName);
        paQualifiers = NULL;
		if(pql)
		{
			if(paQualifiers = CreateQual(pOutput, pql, pObject.get(), pMethName, pDbg))
				pMeth->SetQualifiers(paQualifiers);
            free(pql);
		}
		if(bGotValue)
        {
			SCODE sc = ConvertValue(pMeth.get(), &var, bAliasRef);

            long lLower, lUpper, lCnt;
            sc = SafeArrayGetLBound(var.parray, 1, &lLower);
            sc = SafeArrayGetUBound(var.parray, 1, &lUpper);
			CMoInstance * pTemp;

            for(lCnt = lLower; lCnt <= lUpper; lCnt++)
            {
                pTemp = NULL;
			    sc = SafeArrayGetElement(var.parray, &lCnt, &pTemp);
                if(sc == S_OK && pTemp)
                {
                    // If there are two objects, then the first is inputs and the second outputs.  If there
                    // is just one, examine the object 

                    if(lLower != lUpper && lCnt == lLower)
                        pMeth->SetIn(pTemp);
                    else if(lLower != lUpper && lCnt == lUpper)
                        pMeth->SetOut(pTemp);
                    else if(pTemp->IsInput())
                        pMeth->SetIn(pTemp);
                    else 
                        pMeth->SetOut(pTemp);
                }
            }
        }
		else
		{
			VARIANT * t_pVar = pMeth->GetpVar();
			t_pVar->vt = VT_NULL;
			t_pVar->lVal = 0;
		}
        pMeth->SetType((VARTYPE)Data.m_dwType);

        if (pObject->AddProperty(pMeth.get()))
        {
            pMeth->RegisterAliases(pObject.get());
            pMeth.release();
        }
        free(pMethName);
    }


	if(pVar)
	{
            pVar->punkVal = (IUnknown *)pObject.get();
	}
	else
		pOutput->AddObject(pObject.get());
       pObject.release();
	return TRUE;
}

//***************************************************************************
//
//  BOOL BMOFToVariant
//
//  DESCRIPTION:
//
//  Converts a bmof data object into a variant
//
//***************************************************************************

BOOL BMOFToVariant(CMofData * pOutput, CBMOFDataItem * pData, VARIANT * pVar, BOOL & bAliasRef, BOOL bMethodArg, PDBG pDbg)
{
    SCODE sc;
    VariantInit(pVar);
	DWORD dwSimpleType = pData->m_dwType & ~VT_ARRAY & ~VT_BYREF;
    bAliasRef = pData->m_dwType & VT_BYREF;

    long lFirstDim;
    VARIANT vTemp;  

	long lNumDim = GetNumDimensions(pData);
	if(lNumDim == -1)
		return FALSE;

    pVar->vt = (WORD)pData->m_dwType & ~VT_BYREF;

    if(lNumDim == 0)
    {
        memset((BYTE *)&(vTemp.lVal),0,8);
		if(!GetData(pData, (BYTE *)&(vTemp.lVal), NULL))
        {
            pVar->vt = VT_EMPTY;
			return FALSE;
        }
        if(dwSimpleType == VT_BSTR)
        {
            pVar->bstrVal = SysAllocString(vTemp.bstrVal);
            BMOFFree(vTemp.bstrVal);
            if(pVar->bstrVal == NULL)
                return FALSE;
        }
		else if(dwSimpleType == VT_EMBEDDED_OBJECT)
		{
			CBMOFObj * pObj;
			pObj = (CBMOFObj *)vTemp.bstrVal;
			BMOFParseObj(pOutput, pObj, pVar, bMethodArg, pDbg);
            BMOFFree(pObj);
			return TRUE;
		}
        else
            memcpy((void *)&(pVar->bstrVal), (void *)&(vTemp.bstrVal),8); 

        return TRUE;
    }
	    
    
	lFirstDim = GetNumElements(pData, 0);

    
    DWORD ulLower, ulUpper;
    
    SAFEARRAY * psa;
    SAFEARRAYBOUND rgsabound[1];
    long ix[2] = {0,0};
    ulLower = 0;
    ulUpper = lFirstDim-1;
    rgsabound[0].lLbound = ulLower;
    rgsabound[0].cElements = ulUpper - ulLower +1;

#ifdef _WIN64
	VARTYPE vtTemp = (dwSimpleType == VT_EMBEDDED_OBJECT) ? VT_R8 : (VARTYPE)dwSimpleType;
#else
	VARTYPE vtTemp = (dwSimpleType == VT_EMBEDDED_OBJECT) ? VT_I4 : (VARTYPE)dwSimpleType;
#endif
    psa = SafeArrayCreate(vtTemp,1,rgsabound);
    for(ix[0] = ulLower; ix[0] <= (long)ulUpper; ix[0]++) 
    {

        memset((BYTE *)&(vTemp.lVal),0,8);

		GetData(pData, (BYTE *)&(vTemp.lVal), ix);	
        if(dwSimpleType == VT_BSTR)
        {
            BSTR bstr = SysAllocString(vTemp.bstrVal);
            free(vTemp.bstrVal);
            vTemp.vt = VT_EMPTY;
            if(bstr == NULL)
            {
                pVar->vt = VT_EMPTY;
                return FALSE;
            }
            sc = SafeArrayPutElement(psa,ix,(void *)bstr);
            SysFreeString(bstr);
            if(FAILED(sc))
            	return FALSE;
        }
		else if(dwSimpleType == VT_EMBEDDED_OBJECT)
		{
			CBMOFObj * pObj;
			VARIANT vConv;
			VariantInit(&vConv);
			pObj = (CBMOFObj *)vTemp.punkVal;
			BMOFParseObj(pOutput, pObj, &vConv, bMethodArg, pDbg);
            free(pObj);
            sc = SafeArrayPutElement(psa,ix,(void *)&vConv.lVal);
            if(FAILED(sc))
            	return FALSE;
		}
        else
        {
            memcpy((void *)&(pVar->bstrVal), (void *)&(vTemp.bstrVal),8); 
            sc = SafeArrayPutElement(psa,ix,(void *)&(vTemp.lVal));
            if(FAILED(sc))
            	return FALSE;
        }
    
 //       VariantClear(&vTemp);
    }
    pVar->parray = psa;
    return TRUE;

}

//***************************************************************************
//
//  void AddAliasReplaceValue
//
//  DESCRIPTION:
//
//  Used when a Value has an alias.
//
//  RETURN VALUE:
//
//  TRUE if the file is a binary mof
//
//***************************************************************************

HRESULT AddAliasReplaceValue(CMoValue & Value, const WCHAR * pAlias)
{
    
    HRESULT hr = Value.AddAlias(pAlias);
    if(FAILED(hr))
        return hr;
    V_VT(&Value.AccessVariant()) = VT_BSTR;

        // Create a unique value and put it in there
        // =========================================

    GUID guid;
    CoCreateGuid(&guid);

    WCHAR wszGuidBuffer[100];
    StringFromGUID2(guid, wszGuidBuffer, 100);

    BSTR bstr = SysAllocString(wszGuidBuffer);
    if(bstr == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    V_BSTR(&Value.AccessVariant()) = bstr;
    return S_OK;
}

extern "C" void * BMOFAlloc(size_t Size)
{
    return malloc(Size);
}
extern "C" void BMOFFree(void * pFree)
{
    free(pFree);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\cout.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    COUT.H

Abstract:

	Declares the COut class.

History:

	a-davj  06-April-97   Created.

--*/

#ifndef __COUT__H_
#define __COUT__H_


#define INIT_SIZE 4096
#define ADDITIONAL_SIZE 4096
#include "trace.h"

//***************************************************************************
//
//  CLASS NAME:
//
//  COut
//
//  DESCRIPTION:
//
//  Provides an automatically resizing buffer for ouput.  Writting is done
//  to offsets and the buffer also writes itself to a file.
//
//***************************************************************************

#include <flexarry.h>

class COut {
  public:
    COut(PDBG pDbg);
    ~COut();
    BOOL WriteToFile(LPSTR pFile);
    DWORD WriteBytes(DWORD dwOffset, BYTE * pSrc, DWORD dwSize);
    DWORD AppendBytes(BYTE * pSrc, DWORD dwSize);
    DWORD WriteBSTR(BSTR bstr);
    DWORD GetOffset(void){return m_dwCurr;};
    BOOL AddFlavor(long lFlavor);
    void SetPadMode(BOOL bPad){m_bPadString = bPad;};
  private:
	PDBG m_pDbg;
    BYTE * m_pMem;
    DWORD  m_dwSize;
    DWORD m_dwCurr;
    CFlexArray m_Offsets;
    CFlexArray m_Flavors;
    BOOL m_bPadString;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\comobj.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    COMOBJ.H

Abstract:

	This file defines the classes related to class representation
	of mofcomp objects.

History:

	9/16/98     a-davj      Created

--*/

#ifndef __COMOBJ__H_
#define __COMOBJ__H_

//***************************************************************************
//
//  CLASS NAME:
//
//  CGenFactory
//
//  DESCRIPTION:
//
//  Class factory template.
//
//***************************************************************************


typedef LPVOID * PPVOID;
void ObjectCreated();
void ObjectDestroyed();

template<class TObj>
class CGenFactory : public IClassFactory
    {
    protected:
        long           m_cRef;
    public:
        CGenFactory(void)
        {
            m_cRef=0L;
            ObjectCreated();
            return;
        };

        ~CGenFactory(void)
        {
            ObjectDestroyed();
            return;
        }

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID riid, PPVOID ppv)
        {
            *ppv=NULL;

            if (IID_IUnknown==riid || IID_IClassFactory==riid)
                *ppv=this;

            if (NULL!=*ppv)
            {
                AddRef();
                return NOERROR;
            }

            return ResultFromScode(E_NOINTERFACE);
        };

        STDMETHODIMP_(ULONG) AddRef(void)
        {    
            return ++m_cRef;
        };
        STDMETHODIMP_(ULONG) Release(void)
        {
            long lRet = InterlockedDecrement(&m_cRef);
            if (0 ==lRet)
                delete this;
            return lRet;
        };

        //IClassFactory members
        STDMETHODIMP CreateInstance(IN LPUNKNOWN pUnkOuter, IN REFIID riid, OUT PPVOID ppvObj)
        {
            HRESULT hr;

            *ppvObj=NULL;
            hr=E_OUTOFMEMORY;

            // This object doesnt support aggregation.

            if (NULL!=pUnkOuter)
                return CLASS_E_NOAGGREGATION;

            //Create the object passing function to notify on destruction.
    
            TObj * pObj = new TObj();

            if (NULL==pObj)
                return hr;

            // Setup the class all empty, etc.

            hr=pObj->QueryInterface(riid, ppvObj);
            pObj->Release();
            return hr;
            
        };
        STDMETHODIMP         LockServer(BOOL fLock)
        {
            if (fLock)
                InterlockedIncrement((long *)&g_cLock);
            else
                InterlockedDecrement((long *)&g_cLock);
            return NOERROR;
        };
    };


//***************************************************************************
//
//  CLASS NAME:
//
//  CMofComp
//
//  DESCRIPTION:
//
//  Supports mofcomp functions for clients.
//
//***************************************************************************

class CMofComp : IMofCompiler
{
    protected:
        long           m_cRef;
    public:
        CMofComp(void)
        {
            m_cRef=1L;
            ObjectCreated();
            return;
        };

        ~CMofComp(void)
        {
            ObjectDestroyed();
            return;
        }

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID riid, PPVOID ppv)
        {
            *ppv=NULL;

            if (IID_IUnknown==riid || IID_IMofCompiler==riid)
                *ppv=this;

            if (NULL!=*ppv)
            {
                AddRef();
                return NOERROR;
            }

            return E_NOINTERFACE;
        };

        STDMETHODIMP_(ULONG) AddRef(void)
        {    
            return ++m_cRef;
        };
        STDMETHODIMP_(ULONG) Release(void)
        {
            long lRef = InterlockedDecrement(&m_cRef);
            if (0L == lRef)
                delete this;
            return lRef;
        };

        // IMofCompiler functions

        HRESULT STDMETHODCALLTYPE CompileFile( 
            /* [in] */ LPWSTR FileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LPWSTR User,
            /* [in] */ LPWSTR Authority,
            /* [in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);
        
        HRESULT STDMETHODCALLTYPE CompileBuffer( 
            /* [in] */ long BuffSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LPWSTR User,
            /* [in] */ LPWSTR Authority,
            /* [in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);
        
        HRESULT STDMETHODCALLTYPE CreateBMOF( 
            /* [in] */ LPWSTR TextFileName,
            /* [in] */ LPWSTR BMOFFileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);
};

//***************************************************************************
//
//  CLASS NAME:
//
//  CWinmgmtMofComp
//
//  DESCRIPTION:
//
//  Provides mofcomp functions for internal use.
//
//***************************************************************************

class CWinmgmtMofComp : IWinmgmtMofCompiler
{
    protected:
        long           m_cRef;
    public:
        CWinmgmtMofComp(void)
        {
            m_cRef=1L;
            ObjectCreated();
            return;
        };

        ~CWinmgmtMofComp(void)
        {
            ObjectDestroyed();
            return;
        }

        //IUnknown members
        STDMETHODIMP         QueryInterface(REFIID riid, PPVOID ppv)
        {
            *ppv=NULL;

            if (IID_IUnknown==riid || IID_IWinmgmtMofCompiler==riid)
                *ppv=this;

            if (NULL!=*ppv)
            {
                AddRef();
                return NOERROR;
            }

            return E_NOINTERFACE;
        };

        STDMETHODIMP_(ULONG) AddRef(void)
        {    
            return ++m_cRef;
        };
        STDMETHODIMP_(ULONG) Release(void)
        {
            long lRef = InterlockedDecrement(&m_cRef);
            if (0L == lRef)
                delete this;
            return lRef;
        };

        // IWinmgmtMofCompiler functions

        HRESULT STDMETHODCALLTYPE WinmgmtCompileFile( 
            /* [in] */ LPWSTR FileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [in] */ IWbemServices __RPC_FAR *pOverride,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);
        
        HRESULT STDMETHODCALLTYPE WinmgmtCompileBuffer( 
            /* [in] */ long BuffSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [in] */ IWbemServices __RPC_FAR *pOverride,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\comobj.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    COMOBJ.CPP

Abstract:

    Implements mofcomp com objects.

History:

    a-davj  17-Sept-98       Created.

--*/

#include "precomp.h"
#include "commain.h"
#include "wbemcli.h"
#include "wbemprov.h"
#include "wbemint.h"
#include "comobj.h"
#include "mofout.h"
#include "mofparse.h"
#include "dllcalls.h"

SCODE Compile(CMofParser & Parser, IWbemServices *pOverride, IWbemContext * pCtx, long lOptionFlags, long lClassFlags, long lInstanceFlags,
                WCHAR * wszDefault, WCHAR *UserName, WCHAR *pPassword , WCHAR *Authority, 
                WCHAR * wszBmof, bool bInProc, WBEM_COMPILE_STATUS_INFO *pInfo);

void ClearStatus(WBEM_COMPILE_STATUS_INFO  *pInfo)
{
    if(pInfo)
    {
    pInfo->lPhaseError = 0;        // 0, 1, 2, or 3 matching current return value
    pInfo->hRes = 0;            // Actual error
    pInfo->ObjectNum = 0;
    pInfo->FirstLine = 0;
    pInfo->LastLine = 0;
    pInfo->dwOutFlags = 0;
    }
}

HRESULT APIENTRY  CompileFileViaDLL( 
            /* [in] */ LPWSTR FileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LPWSTR User,
            /* [in] */ LPWSTR Authority,
            /* [in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo)
{
    if(FileName == NULL)
        return WBEM_E_INVALID_PARAMETER;

    TCHAR cFile[MAX_PATH];
    ClearStatus(pInfo);
    TCHAR * pFile = NULL;
    if(FileName)
    {
        CopyOrConvert(cFile, FileName, MAX_PATH);
        pFile = cFile;
    }

    DebugInfo dbg((lOptionFlags & WBEM_FLAG_CONSOLE_PRINT) != 0);
    CMofParser Parser(pFile, &dbg);

    SCODE sc = Compile(Parser, NULL, NULL, lOptionFlags, lClassFlags, lInstanceFlags,
                ServerAndNamespace, User, Password, Authority, 
                NULL, false, pInfo);
    return sc;

}

HRESULT APIENTRY  CreateBMOFViaDLL( 
            /* [in] */ LPWSTR TextFileName,
            /* [in] */ LPWSTR BMOFFileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo)
{
    TCHAR cFile[MAX_PATH];

    if(TextFileName == NULL || BMOFFileName == NULL)
        return WBEM_E_INVALID_PARAMETER;

    ClearStatus(pInfo);
    TCHAR * pFile = NULL;
    if(TextFileName)
    {
        CopyOrConvert(cFile, TextFileName, MAX_PATH);
        pFile = cFile;
    }

    DebugInfo dbg((lOptionFlags & WBEM_FLAG_CONSOLE_PRINT) != 0);
    CMofParser Parser(pFile, &dbg);

    SCODE sc = Compile(Parser, NULL, NULL, lOptionFlags, lClassFlags, lInstanceFlags,
                ServerAndNamespace, NULL, NULL, NULL, 
                BMOFFileName, false, pInfo);
    return sc;

}


HRESULT CMofComp::CompileFile( 
            /* [in] */ LPWSTR FileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LPWSTR User,
            /* [in] */ LPWSTR Authority,
            /* [in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo)
{

    if(FileName == NULL)
        return WBEM_E_INVALID_PARAMETER;

    TCHAR cFile[MAX_PATH];
    ClearStatus(pInfo);
    TCHAR * pFile = NULL;
    if(FileName)
    {
        CopyOrConvert(cFile, FileName, MAX_PATH);
        pFile = cFile;
    }

    DebugInfo dbg((lOptionFlags & WBEM_FLAG_CONSOLE_PRINT) != 0);
    CMofParser Parser(pFile, &dbg);
    if((lOptionFlags & WBEM_FLAG_CHECK_ONLY) && (lOptionFlags & WBEM_FLAG_CONSOLE_PRINT))
        Parser.SetToDoScopeCheck();

    SCODE sc = Compile(Parser, NULL, NULL, lOptionFlags, lClassFlags, lInstanceFlags,
                ServerAndNamespace, User, Password, Authority, 
                NULL, false, pInfo);
    return sc;

}
        
HRESULT CMofComp::CompileBuffer( 
            /* [in] */ long BuffSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LPWSTR User,
            /* [in] */ LPWSTR Authority,
            /* [in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo)
{

    SCODE sc;
    if(pBuffer == NULL || BuffSize == 0)
        return WBEM_E_INVALID_PARAMETER;
    DebugInfo dbg((lOptionFlags & WBEM_FLAG_CONSOLE_PRINT) != 0);
    CMofParser Parser(&dbg);
    try
    {

        Parser.SetBuffer((char *)pBuffer, BuffSize);
        sc = Compile(Parser, NULL, NULL, lOptionFlags, lClassFlags, lInstanceFlags,
                ServerAndNamespace, User, Password, Authority, 
                NULL, false, pInfo);
    }
    catch(...)
    {
        sc = WBEM_E_FAILED;
    }
    return sc;
}
        
HRESULT CMofComp::CreateBMOF( 
            /* [in] */ LPWSTR TextFileName,
            /* [in] */ LPWSTR BMOFFileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo)
{
    TCHAR cFile[MAX_PATH];

    if(TextFileName == NULL || BMOFFileName == NULL)
        return WBEM_E_INVALID_PARAMETER;

    ClearStatus(pInfo);
    TCHAR * pFile = NULL;
    if(TextFileName)
    {
        CopyOrConvert(cFile, TextFileName, MAX_PATH);
        pFile = cFile;
    }

    DebugInfo dbg((lOptionFlags & WBEM_FLAG_CONSOLE_PRINT) != 0);
    CMofParser Parser(pFile, &dbg);

    SCODE sc = Compile(Parser, NULL, NULL, lOptionFlags, lClassFlags, lInstanceFlags,
                ServerAndNamespace, NULL, NULL, NULL, 
                BMOFFileName, false, pInfo);
    return sc;
}

HRESULT CWinmgmtMofComp::WinmgmtCompileFile( 
            /* [in] */ LPWSTR FileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [in] */ IWbemServices __RPC_FAR *pOverride,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo)
{
    TCHAR cFile[MAX_PATH];
    if(FileName == NULL)
        return WBEM_E_INVALID_PARAMETER;
    ClearStatus(pInfo);
    TCHAR * pFile = NULL;
    if(FileName)
    {
        CopyOrConvert(cFile, FileName, MAX_PATH);
        pFile = cFile;
    }

    DebugInfo dbg((lOptionFlags & WBEM_FLAG_CONSOLE_PRINT) != 0);
    CMofParser Parser(pFile, &dbg);

    SCODE sc = Compile(Parser, pOverride, pCtx, lOptionFlags, lClassFlags, lInstanceFlags,
                ServerAndNamespace, NULL, NULL, NULL, 
                NULL, true, pInfo);
    return sc;
}
        
HRESULT CWinmgmtMofComp::WinmgmtCompileBuffer( 
            /* [in] */ long BuffSize,
            /* [size_is][in] */ BYTE __RPC_FAR *pBuffer,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [in] */ IWbemServices __RPC_FAR *pOverride,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo)
{

    if(pBuffer == NULL || BuffSize == 0)
        return WBEM_E_INVALID_PARAMETER;

    DebugInfo dbg((lOptionFlags & WBEM_FLAG_CONSOLE_PRINT) != 0);
    CMofParser Parser(&dbg);
    try
    {

        Parser.SetBuffer((char *)pBuffer, BuffSize);
        SCODE sc = Compile(Parser, pOverride, pCtx, lOptionFlags, lClassFlags, lInstanceFlags, 
                    NULL, NULL, NULL, NULL, NULL, true, pInfo); 
        return sc;
    }
    catch(...)
    {
        return S_FALSE;
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\cout.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    COUT.CPP

Abstract:

    Declares the COut class.

History:

    a-davj  06-April-97   Created.

--*/

#include "precomp.h"
#include <io.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
#include <arrtempl.h>

#include "cout.h"
#include "trace.h"
#include "strings.h"
#include "mrciclass.h"
#include "bmof.h"

//***************************************************************************
//
//  COut::COut
//
//  DESCRIPTION:
//
//  Constructor.  Allocates initial buffer.
//
//***************************************************************************

COut::COut(PDBG pDbg)
{
    m_pDbg = pDbg;
    m_dwSize = INIT_SIZE;
    m_pMem = (BYTE *)malloc(m_dwSize);
    m_dwCurr = 0;
    m_bPadString = TRUE;
}

//***************************************************************************
//
//  COut::~COut
//
//  DESCRIPTION:
//
//  Destructor.  Frees the buffer.
//
//***************************************************************************

COut::~COut()
{
    if(m_pMem)
        free(m_pMem);
}

//***************************************************************************
//
//  void COut::WriteToFile
//
//  DESCRIPTION:
//
//  Creates a file and writes the buffer to it.  Like other compilers, it
//  overwrites any existing files.
//
//  PARAMETERS:
//
//  pFile               File name to write to.
//
//***************************************************************************

BOOL COut::WriteToFile(
                        IN LPSTR pFile)
{
    BOOL bRet = FALSE;
    BYTE * pCompressed = NULL;
    DWORD one = 1;
    DWORD dwSize;
    int iRet;
    DWORD dwCompressedSize;
    DWORD dwSignature = BMOF_SIG;
    CMRCICompression * pCompress = new CMRCICompression;
    if(pCompress == NULL)
        return FALSE;
    CDeleteMe<CMRCICompression> dm(pCompress);

    // Test if there are flavors

    if(m_Flavors.Size() > 0)
    {
        // write out the flavor information

        void * lOffSet;
        void * lFlavor; 
        AppendBytes((BYTE *)"BMOFQUALFLAVOR11", 16);
        long lNum = m_Flavors.Size();
        AppendBytes( (BYTE *)&lNum, 4);

        for(long lCnt = 0; lCnt < lNum; lCnt++)
        {
            lOffSet = m_Offsets.GetAt(lCnt);
            lFlavor = m_Flavors.GetAt(lCnt);
            AppendBytes( (BYTE *)&lOffSet, 4);
            AppendBytes( (BYTE *)&lFlavor, 4);
        }


    }


    int fh = NULL;
    if(pFile == NULL)
        return FALSE;

    fh = _open(pFile, _O_BINARY | O_RDWR | _O_TRUNC | _O_CREAT, _S_IREAD |_S_IWRITE);
    if(fh == -1)
    {
        Trace(true, m_pDbg, FILE_CREATE_FAILED, pFile, errno);
        goto Cleanup;
    }


    // Create a compressed version of the blob

    dwSize = (m_dwCurr > 0x7000) ? m_dwCurr : 0x7000;

    pCompressed = new BYTE[dwSize];
    if(pCompressed == NULL)
        return FALSE;

    dwCompressedSize = pCompress->Mrci1MaxCompress( m_pMem, m_dwCurr, pCompressed, dwSize);

    if(dwCompressedSize == 0xffffffff || dwCompressedSize == 0)
    {
        Trace(true, m_pDbg, COMPRESSION_FAILED);
        goto Cleanup;
    }

    // write the decomression signature, the decompressed size, and the compressed size

    iRet = _write(fh, (BYTE *)&dwSignature, sizeof(DWORD));
    if(iRet != sizeof(DWORD))
    {
        Trace(true, m_pDbg, FILE_WRITE_FAILED, pFile, errno);
        goto Cleanup;
    }

    iRet = _write(fh, (BYTE *)&one, sizeof(DWORD));
    iRet = _write(fh, (BYTE *)&dwCompressedSize, sizeof(DWORD));
    iRet = _write(fh, (BYTE *)&m_dwCurr, sizeof(DWORD));

    // write the compressed data and then free the buffer

    iRet = _write(fh, pCompressed, dwCompressedSize);
    
    if((DWORD)iRet != dwCompressedSize)
        Trace(true, m_pDbg, FILE_WRITE_FAILED, pFile, errno);
    else
        bRet = TRUE;

Cleanup:

    if(fh != NULL)
        _close(fh);
    if(pCompressed)
        delete pCompressed;
    return bRet;
    
}

//***************************************************************************
//
//  DWORD COut::AppendBytes
//
//  DESCRIPTION:
//
//  Adds bytes to the end of the buffer.
//
//  PARAMETERS:
//
//  pSrc                Pointer to data source.
//  dwSize              Number of bytes to add.
//
//  RETURN VALUE:
//
//  Number of bytes added.
//
//***************************************************************************

DWORD COut::AppendBytes(
                        IN BYTE * pSrc, 
                        IN DWORD dwSize)
{
    char * pZero = "\0\0\0\0\0\0\0";
    DWORD dwRet = WriteBytes(m_dwCurr, pSrc, dwSize);
    m_dwCurr += dwRet;
    DWORD dwLeftOver = dwSize & 3;
    if(dwLeftOver && m_bPadString)
    {
        dwRet = WriteBytes(m_dwCurr, (BYTE *)pZero, dwLeftOver);
        m_dwCurr += dwLeftOver;
    }
    return dwRet;
}

//***************************************************************************
//
//  DWORD COut::WriteBSTR
//
//  DESCRIPTION:
//
//  Adds a bstr to the buffer.  Quite simple for now, by might be enhanced
//  later on to compress.
//
//  PARAMETERS:
//
//  bstr                bstr to add.
//
//  RETURN VALUE:
//
//  Number of bytes added.
//
//***************************************************************************

DWORD COut::WriteBSTR(
                        IN BSTR bstr)
{
    return AppendBytes((BYTE *)bstr, 2*(wcslen(bstr) + 1));
}


//***************************************************************************
//
//  DWORD COut::WriteBytes
//
//  DESCRIPTION:
//
//  writes some bytes to the buffer, or possibly adds to the end.
//
//  PARAMETERS:
//
//  dwOffset            Offset in buffer where bytes should go
//  pSrc                points to source data
//  dwSize              number of bytes to copy
//
//  RETURN VALUE:
//
//  Number of bytes copied
//
//***************************************************************************

DWORD COut::WriteBytes(
                        IN DWORD dwOffset, 
                        IN BYTE * pSrc, 
                        IN DWORD dwSize)
{
    if(m_pMem == NULL)
        return 0;

    // check if reallocation is needed!

    if(dwOffset + dwSize > m_dwSize)
    {
        DWORD dwAddSize = ADDITIONAL_SIZE;
        if(dwSize > dwAddSize)
            dwAddSize = dwSize;
        BYTE * pNew = (BYTE *)realloc(m_pMem, m_dwSize + dwAddSize);
        if(pNew == NULL)
        {
            free(m_pMem);
            m_pMem = NULL;
            return 0;
        }
        else
        {
            m_pMem = pNew;
            m_dwSize += dwAddSize;
        }
    }

    memcpy(m_pMem+dwOffset, pSrc, dwSize);
    return dwSize;
}

//***************************************************************************
//
//  DWORD COut::AddFlavor
//
//  DESCRIPTION:
//
//  Save the flavor value for the current offset.
//
//  PARAMETERS:
//
//  long                flavor to be saved
//
//  RETURN VALUE:
//
//  TRUE if OK;
//
//***************************************************************************

BOOL COut::AddFlavor(IN long lFlavor)
{
#ifdef _WIN64
    m_Offsets.Add((void *)IntToPtr(m_dwCurr));
    m_Flavors.Add((void *)IntToPtr(lFlavor));
#else
    m_Offsets.Add((void *)m_dwCurr);
    m_Flavors.Add((void *)lFlavor);
#endif	
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\datasrc.cpp ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    DataSrc.CPP

Abstract:

	Implements DataSrc objects.

History:

	a-davj  21-Dec-99       Created.

--*/

#include "precomp.h"
#include "DataSrc.h"
#include <wbemcli.h>

#include <malloc.h>

FileDataSrc::FileDataSrc(TCHAR * pFileName)
{
	m_fp = NULL;
	m_pFileName = NULL;
	m_iFilePos = -1;		// forces a read
	m_iToFar = 0;
	if(pFileName == NULL)
	{
		m_iStatus = WBEM_E_INVALID_PARAMETER;
		return;
	}
	m_pFileName = new TCHAR[lstrlen(pFileName) + 1];
	if(m_pFileName == NULL)
	{
		m_iStatus = WBEM_E_OUT_OF_MEMORY;
		return;
	}
	lstrcpy(m_pFileName, pFileName);

	m_fp = _wfopen( pFileName, L"rb");
	if(m_fp == NULL)
	{
		m_iStatus = WBEM_E_OUT_OF_MEMORY;
		return;
	}

	// calculate the file size.  Note that the number is the size in unicode words, not bytes.

    fseek(m_fp, 0, SEEK_END);
    m_iSize = ftell(m_fp)/2; // add a bit extra for ending space and null NULL
	MoveToStart();
}
FileDataSrc::~FileDataSrc()
{

	if(m_fp)
		fclose(m_fp);
    DeleteFile(m_pFileName);
	delete m_pFileName;
}

wchar_t FileDataSrc::GetAt(int nOffset)
{
	wchar_t tRet;
	int iPos = m_iPos + nOffset;
	if(iPos >= m_iFilePos && iPos < m_iToFar)
		return m_Buff[iPos - m_iFilePos];
	Move(nOffset);
	tRet = m_Buff[m_iPos - m_iFilePos];
	Move(-nOffset);
    return tRet;
}

void FileDataSrc::Move(int n)
{
	m_iPos += n;
	
	// if m_iPos is in range, then all is well

	if(m_iPos >= m_iFilePos && m_iPos < m_iToFar && m_iFilePos >= 0)
		return;

	// if m_iPos is not even in the file, bail out

	if(m_iPos >= 0 && m_iPos < m_iSize)
		UpdateBuffer();
	return;
}

int FileDataSrc::MoveToPos(int n)
{
	m_iPos = n;
	
	// if m_iPos is in range, then all is well

	if(m_iPos >= m_iFilePos && m_iPos < m_iToFar && m_iFilePos >= 0)
		return -1;

	// if m_iPos is not even in the file, bail out

	if(m_iPos >= 0 && m_iPos < m_iSize)
		UpdateBuffer();
	return n;
}

void FileDataSrc::UpdateBuffer()
{

	// buffer needs to be read.  Determine the starting and ending points

	m_iFilePos = m_iPos - 1000;
	if(m_iFilePos < 0)
		m_iFilePos = 0;
	
	int iReadLen = 10000;
	if(iReadLen + m_iFilePos > m_iSize)
		iReadLen =  m_iSize - m_iFilePos;

    fseek(m_fp, 2*m_iFilePos, SEEK_SET);
	fread(m_Buff, 2, iReadLen, m_fp);
	m_iToFar = m_iFilePos + iReadLen;
	return;
}

int FileDataSrc::MoveToStart()
{
	fseek(m_fp, 0, SEEK_SET);
	m_iPos = -1;
    return 0;
}


BufferDataSrc::BufferDataSrc(long lSize, char *  pMemSrc)
{
	m_Data = new WCHAR[lSize+1];
	if(m_Data)
	{

		memset(m_Data, 0, (lSize+1) * sizeof(WCHAR));
	    m_iSize = mbstowcs(m_Data, pMemSrc, lSize);
	}
	MoveToStart();
}

BufferDataSrc::~BufferDataSrc()
{
	delete [] m_Data;
}

wchar_t BufferDataSrc::GetAt(int nOffset)
{
	int iPos = m_iPos + nOffset;
	if(iPos < 0 || iPos > m_iSize)
		return -1;
	return m_Data[m_iPos + nOffset];
}

void BufferDataSrc::Move(int n)
{
	m_iPos += n;
}

int BufferDataSrc::MoveToStart()
{
	m_iPos = -1;
	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\dllcalls.h ===
/*++

Copyright (C) 1998-2001 Microsoft Corporation

Module Name:

    DLLCALLS.H

Abstract:

	This file defines the entry points for calling this as a dll rather than a com object.

History:

	3/20/00     a-davj      Created

--*/

#ifndef __DLLCALLS__H_
#define __DLLCALLS__H_

HRESULT APIENTRY  CompileFileViaDLL( 
            /* [in] */ LPWSTR FileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LPWSTR User,
            /* [in] */ LPWSTR Authority,
            /* [in] */ LPWSTR Password,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);

HRESULT APIENTRY  CreateBMOFViaDLL( 
            /* [in] */ LPWSTR TextFileName,
            /* [in] */ LPWSTR BMOFFileName,
            /* [in] */ LPWSTR ServerAndNamespace,
            /* [in] */ LONG lOptionFlags,
            /* [in] */ LONG lClassFlags,
            /* [in] */ LONG lInstanceFlags,
            /* [out][in] */ WBEM_COMPILE_STATUS_INFO __RPC_FAR *pInfo);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\datasrc.h ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    DataSrc.H

Abstract:

	Declares DataSrc objects.

History:

	a-davj  21-Dec-99       Created.

--*/

#include "stdio.h"
#ifndef _DataSrc_H_
#define _DataSrc_H_


class DataSrc
{
public:
	DataSrc(): m_iPos(0), m_iSize(0), m_iStatus(0){};
	virtual ~DataSrc(){return;};
	virtual wchar_t GetAt(int nOffset) = 0;
	virtual void Move(int n) = 0;
	int GetPos(){return m_iPos;};
	int GetStatus(){return m_iStatus;};
	bool PastEnd(){return m_iPos >= m_iSize;};
	bool WouldBePastEnd(int iOffset){return (m_iPos+iOffset) >= m_iSize;};
	virtual int MoveToStart() = 0;
	virtual int MoveToPos(int iPos)=0;
protected:
	int m_iPos;
	int m_iSize;
	int m_iStatus;
};

class FileDataSrc : public DataSrc
{
public:
	FileDataSrc(TCHAR * pFileName);
	~FileDataSrc();
	wchar_t GetAt(int nOffset);
	void Move(int n);
	int MoveToStart();
	int MoveToPos(int iPos);

private:
	void UpdateBuffer();
	FILE * m_fp;
	TCHAR * m_pFileName;
	int m_iFilePos;
	int m_iToFar;
	wchar_t m_Buff[10000];
};


class BufferDataSrc : public DataSrc
{
public:
	BufferDataSrc(long lSize, char *  pMemSrc);
	~BufferDataSrc();
	wchar_t GetAt(int nOffset);
	void Move(int n);
	int MoveToStart();
	int MoveToPos(int iPos){m_iPos = iPos; return iPos;};

private:
	wchar_t * m_Data;	    // only used if type is BUFFER

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\localloc.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <arena.h>

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\mofcomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MOFCOMP.H

Abstract:

	Declarations exports for the mof compiler dll.

History:

--*/

#ifndef _mofcomp_H_
#define _mofcomp_H_

#define DONT_ADD_TO_AUTORECOVER 1

#define AUTORECOVERY_REQUIRED 1

// Usage notes;  Both functions invoke the inprocess mofcompiler, with the only difference being that the
// first function takes a file name while the second takes a buffer and a size.  
// The bDoPrintf argument should be set to true if you want printfs to happen.  That isnt generally needed
// as the output goes into the log no matter what.
// The LocatorGUID should be set to CLSID_WbemAdministrativeLocator for providers and core.
// The argc and argv arguements are probably not needed, but if need be, are standard mofcomp arguments.


extern "C" SCODE APIENTRY CompileFile(LPSTR pFileName, BOOL bDoPrintf, GUID LocatorGUID, IWbemContext * pCtx, 
		int argc, char ** argv);

extern "C" SCODE APIENTRY CompileFileEx(LPSTR pFileName, BOOL bDoPrintf, GUID LocatorGUID, IWbemContext * pCtx, 
		DWORD dwFlagsIn, DWORD *pdwFlagsOut, int argc, char ** argv);

extern "C" SCODE APIENTRY CompileBuffer(BYTE * pBuffer, DWORD dwBuffSize, BOOL bDoPrintf, GUID LocatorGUID, IWbemServices * pOverride, IWbemContext * pCtx, 
		int argc, char ** argv);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\maindll.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MAINDLL.CPP

Abstract:

	Contains DLL entry points.  Also has code that controls
	when the DLL can be unloaded by tracking the number of
	objects and locks.

History:

	a-davj  15-Aug-96   Created.

--*/

#include "precomp.h"
#include <initguid.h>
#include <wbemidl.h>
#include <winver.h>
#include <cominit.h>
#include <wbemutil.h>
#include <wbemprov.h>
#include <wbemint.h>
#include <stdio.h>
#include <reg.h>
#include <genutils.h>
#include "comobj.h"
#include "mofout.h"
#include "mofcomp.h"
#include "mofparse.h"
#include "mofdata.h"
#include "bmof.h"
#include "cbmofout.h"
#include "trace.h"
#include "strings.h"
#include <arrtempl.h>
#include <tchar.h>
HINSTANCE ghModule;

//***************************************************************************
//
//  BOOL WINAPI DllMain
//
//  DESCRIPTION:
//
//  Entry point for DLL.  Good place for initialization.
//
//  PARAMETERS:
//
//  hInstance           instance handle
//  ulReason            why we are being called
//  pvReserved          reserved
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL WINAPI DllMain(
                        IN HINSTANCE hInstance,
                        IN ULONG ulReason,
                        LPVOID pvReserved)
{
    if (DLL_PROCESS_DETACH == ulReason)
    {

    }
    else if (DLL_PROCESS_ATTACH == ulReason)
    {
        ghModule = hInstance;
    }

    return TRUE;
}

static ULONG g_cObj = 0;
ULONG g_cLock = 0;

void ObjectCreated()
{
    InterlockedIncrement((LONG *) &g_cObj);
}

void ObjectDestroyed()
{
    InterlockedDecrement((LONG *) &g_cObj);
}


//***************************************************************************
//
//  STDAPI DllGetClassObject
//
//  DESCRIPTION:
//
//  Called when Ole wants a class factory.  Return one only if it is the sort
//  of class this DLL supports.
//
//  PARAMETERS:
//
//  rclsid              CLSID of the object that is desired.
//  riid                ID of the desired interface.
//  ppv                 Set to the class factory.
//
//  RETURN VALUE:
//
//  S_OK                all is well
//  E_FAILED            not something we support
//  
//***************************************************************************

STDAPI DllGetClassObject(
                        IN REFCLSID rclsid,
                        IN REFIID riid,
                        OUT LPVOID * ppv)
{
    HRESULT hr = WBEM_E_FAILED;

    IClassFactory * pFactory = NULL;
    if (CLSID_WinmgmtMofCompiler == rclsid)
        pFactory = new CGenFactory<CWinmgmtMofComp>();
    else if (CLSID_MofCompiler == rclsid)
        pFactory = new CGenFactory<CMofComp>();

    if(pFactory == NULL)
        return E_FAIL;
    hr=pFactory->QueryInterface(riid, ppv);

    if (FAILED(hr))
        delete pFactory; 

    return hr;
}


//***************************************************************************
//
//  STDAPI DllCanUnloadNow
//
//  DESCRIPTION:
//
//  Answers if the DLL can be freed, that is, if there are no
//  references to anything this DLL provides.
//
//  RETURN VALUE:
//
//  S_OK                if it is OK to unload
//  S_FALSE             if still in use
//  
//***************************************************************************

STDAPI DllCanUnloadNow(void)
{
    SCODE   sc;

    //It is OK to unload if there are no objects or locks on the
    // class factory.

    sc=(0L==g_cObj && 0L==g_cLock) ? S_OK : S_FALSE;
    return sc;
}

//***************************************************************************
//
// DllRegisterServer
//
// Purpose: Called during setup or by regsvr32.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllRegisterServer(void)
{ 
    RegisterDLL(ghModule, CLSID_MofCompiler, __TEXT("MOF Compiler"), __TEXT("Both"), NULL);
    RegisterDLL(ghModule, CLSID_WinmgmtMofCompiler, __TEXT("Winmgmt MOF Compiler"), __TEXT("Both"), NULL);
    return NOERROR;
}

//***************************************************************************
//
// DllUnregisterServer
//
// Purpose: Called when it is time to remove the registry entries.
//
// Return:  NOERROR if registration successful, error otherwise.
//***************************************************************************

STDAPI DllUnregisterServer(void)
{
    UnRegisterDLL(CLSID_MofCompiler,NULL);
    UnRegisterDLL(CLSID_WinmgmtMofCompiler,NULL);
    return NOERROR;
}

//***************************************************************************
//
//  bool IsValidMulti
//
//  DESCRIPTION:
//
//  Does a sanity check on a multstring.
//
//  PARAMETERS:
//
//  pMultStr        Multistring to test.
//  dwSize          size of multistring
//
//  RETURN:
//
//  true if OK
//
//***************************************************************************

bool IsValidMulti(TCHAR * pMultStr, DWORD dwSize)
{
    if(pMultStr && dwSize >= 2 && pMultStr[dwSize-2]==0 && pMultStr[dwSize-1]==0)
        return true;
    return false;
}

//***************************************************************************
//
//  bool IsStringPresent
//
//  DESCRIPTION:
//
//  Searches a multstring for the presense of a string.
//
//  PARAMETERS:
//
//  pTest           String to look for.
//  pMultStr        Multistring to test.
//
//  RETURN:
//
//  true if string is found
//
//***************************************************************************

bool IsStringPresent(TCHAR * pTest, TCHAR * pMultStr)
{
    TCHAR * pTemp;
    for(pTemp = pMultStr; *pTemp; pTemp += lstrlen(pTemp) + 1)
        if(!lstrcmpi(pTest, pTemp))
            return true;
    return false;
}

//***************************************************************************
//
//  void AddToAutoRecoverList
//
//  DESCRIPTION:
//
//  Adds the file to the autocompile list, if it isnt already on it.
//
//  PARAMETERS:
//
//  pFileName           File to add
//
//***************************************************************************

void AddToAutoRecoverList(TCHAR * pFileName)
{
    TCHAR cFullFileName[MAX_PATH+1];
    TCHAR * lpFile;
    DWORD dwSize;
    TCHAR * pNew = NULL;
    TCHAR * pTest;
    DWORD dwNewSize = 0;
    DWORD dwNumChar = 0;

    // Get the full file name

    long lRet = GetFullPathName(pFileName, MAX_PATH, cFullFileName, &lpFile);
    if(lRet == 0)
        return;

    bool bFound = false;
    Registry r(WBEM_REG_WINMGMT);
    TCHAR *pMulti = r.GetMultiStr(TEXT("Autorecover MOFs"), dwSize);
    dwNumChar = dwSize / sizeof(TCHAR);
    
    // Ignore the empty string case

    if(dwSize == 1)
    {
        delete pMulti;
        pMulti = NULL;
    }
    if(pMulti)
    {
		CDeleteMe<TCHAR> dm(pMulti);
        if(!IsValidMulti(pMulti, dwNumChar))
        {
            return;             // bail out, messed up multistring
        }
        bFound = IsStringPresent(cFullFileName, pMulti);
        if(!bFound)
            {

            // The registry entry does exist, but doesnt have this name
            // Make a new multistring with the file name at the end

            dwNewSize = dwNumChar + lstrlen(cFullFileName) + 1;
            pNew = new TCHAR[dwNewSize];
            if(!pNew)
                return;
            memcpy(pNew, pMulti, dwSize);

            // Find the double null

            for(pTest = pNew; pTest[0] || pTest[1]; pTest++);     // intentional semi

            // Tack on the path and ensure a double null;

            pTest++;
            lstrcpy(pTest, cFullFileName);
            pTest+= lstrlen(cFullFileName)+1;
            *pTest = 0;         // add second numm
        }
    }
    else
    {
        // The registry entry just doesnt exist.  Create it with a value equal to our name 

        dwNewSize = lstrlen(cFullFileName) + 2;	// note extra char for double null
        pNew = new TCHAR[dwNewSize];
        if(!pNew)
            return;
        lstrcpy(pNew, cFullFileName);
        pTest = pNew + lstrlen(pNew) + 1;
        *pTest = 0;         // add second null
    }

    if(pNew)
    {
        r.SetMultiStr(TEXT("Autorecover MOFs"), pNew, dwNewSize*sizeof(TCHAR));
        delete pNew;
    }

    FILETIME ftCurTime;
    LARGE_INTEGER liCurTime;
    TCHAR szBuff[50];
    GetSystemTimeAsFileTime(&ftCurTime);
    liCurTime.LowPart = ftCurTime.dwLowDateTime;
    liCurTime.HighPart = ftCurTime.dwHighDateTime;
    _ui64tot(liCurTime.QuadPart, szBuff, 10);
    r.SetStr(TEXT("Autorecover MOFs timestamp"), szBuff);

}


//***************************************************************************
//
//  int Trace
//
//  DESCRIPTION:
//
//  Allows for the output function (printf in this case) to be overridden.
//
//  PARAMETERS:
//
//  *fmt                format string.  Ex "%s hello %d"
//  ...                 argument list.  Ex cpTest, 23
//
//  RETURN VALUE:
//
//  size of output in characters.
//***************************************************************************

int Trace(bool bError, PDBG pDbg,DWORD dwID, ...)
{

    IntString is(dwID);
    TCHAR * fmt = is;

    TCHAR *buffer = new TCHAR[2048];
    if(buffer == NULL)
        return 0;
    char *buffer2 = new char[4096];
    if(buffer2 == NULL)
    {
        delete buffer;
        return 0;
    }

    va_list argptr;
    int cnt;
    va_start(argptr, dwID);
#ifdef UNICODE
    cnt = _vsnwprintf(buffer, 2048, fmt, argptr);
#else
    cnt = _vsnprintf(buffer, 2048, fmt, argptr);
#endif
    va_end(argptr);
    CharToOem(buffer, buffer2);

    if(pDbg && pDbg->m_bPrint)
        printf("%s", buffer2);
    if(bError)
        ERRORTRACE((LOG_MOFCOMP,"%s", buffer2));
    else
        DEBUGTRACE((LOG_MOFCOMP,"%s", buffer2));

    delete buffer;
    delete buffer2;
    return cnt;

}


//***************************************************************************
//
//  HRESULT StoreBMOF
//
//  DESCRIPTION:
//
//  This stores the intermediate data as a BINARY MOF instead of storing it to
//  the WBEM database.
//
//  PARAMETERS:
//
//  pObjects            The intermediate data
//  bWMICheck           If true, the the wmi checker program is automatically started
//  BMOFFileName        file name to store the data to.
//
//  RETURN VALUE:
//
//  0 if OK, otherwise an error code
//
//***************************************************************************

HRESULT StoreBMOF(CMofParser & Parser, CPtrArray * pObjects, BOOL bWMICheck, LPTSTR BMOFFileName, PDBG pDbg)
{
    int i;
    {
        CBMOFOut BMof(BMOFFileName, pDbg);

        // Go through all the objects and add them to the database
        // =======================================================

        for(i = 0; i < pObjects->GetSize(); i++)
        {
            CMObject* pObject = (CMObject*)(*pObjects)[i];
			pObject->Reflate(Parser);
            BMof.AddClass(pObject, FALSE);  // possibly add to the BMOF output buffer
			pObject->Deflate(false);
        }
        if(!BMof.WriteFile())
        {
            return WBEM_E_FAILED;
        }
    }


    if(bWMICheck)
    {
        PROCESS_INFORMATION pi;
        STARTUPINFO si;
        si.cb = sizeof(si);
        si.lpReserved = 0;
        si.lpDesktop = NULL;
        si.lpTitle = NULL;
        si.dwFlags = 0;
        si.cbReserved2 = 0;
        si.lpReserved2 = 0;
        TCHAR App[MAX_PATH];
        lstrcpy(App, TEXT("wmimofck "));
        lstrcat(App, BMOFFileName);

        BOOL bRes = CreateProcess(NULL,
                                 App,
                            NULL,
                            NULL,
                            FALSE,
                            0,
                            NULL,
                            NULL,
                            &si,
                            &pi);
        if(bRes == 0)
        {
            DWORD dwError = GetLastError();
            Trace(true, pDbg, WMI_LAUNCH_ERROR, dwError);
            return dwError;
        }
    }
    return WBEM_NO_ERROR;

}


void SetInfo(WBEM_COMPILE_STATUS_INFO *pInfo, long lPhase, HRESULT hRes)
{
    if(pInfo)
    {
        pInfo->lPhaseError = lPhase;
        pInfo->hRes = hRes;
    }
}


HRESULT ExtractAmendment(CMofParser & Parser, WCHAR * wszBmof)
{
    // if this is being used for splitting, then possibly get the amendment value
    // It would be passed in the wszBmof string and would be found after
    // the characters ",a".  For example, the string might be ",aMS_409,fFileName.mof"

    if(wszBmof == NULL || wszBmof[0] != L',')
        return S_OK;                                 // not a problem, is usual case

    // make a copy of the string

    WCHAR *pTemp = new WCHAR[wcslen(wszBmof)+1];
    if(pTemp == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CDeleteMe<WCHAR> dm1(pTemp);
    wcscpy(pTemp, wszBmof);

    // use wcstok to do a seach

    WCHAR * token = wcstok( pTemp, L"," );
    while( token != NULL )   
    {
        if(token[0] == L'a')
        {
            return Parser.SetAmendment(token+1);
        }
        token = wcstok( NULL, L"," );   
    }
    return S_OK;
}

SCODE Compile(CMofParser & Parser, IWbemServices *pOverride, IWbemContext * pCtx, 
              long lOptionFlags, long lClassFlags, long lInstanceFlags,
                WCHAR * wszDefault, WCHAR *UserName, WCHAR *pPassword , WCHAR *Authority, 
                WCHAR * wszBmof, bool bInProc, WBEM_COMPILE_STATUS_INFO *pInfo)
{

    // do flag validity check

    if((lOptionFlags & WBEM_FLAG_DONT_ADD_TO_LIST) && (lOptionFlags & WBEM_FLAG_AUTORECOVER))
    {
        SetInfo(pInfo, 1, WBEM_E_INVALID_PARAMETER);
        return S_FALSE;
    }
    long lValid = WBEM_FLAG_DONT_ADD_TO_LIST | WBEM_FLAG_AUTORECOVER | WBEM_FLAG_CHECK_ONLY |
                  WBEM_FLAG_WMI_CHECK | WBEM_FLAG_SPLIT_FILES | WBEM_FLAG_CONSOLE_PRINT
                  | WBEM_FLAG_CONNECT_REPOSITORY_ONLY;
    if(lOptionFlags & ~lValid)
    {
        SetInfo(pInfo, 1, WBEM_E_INVALID_PARAMETER);
        return S_FALSE;
    }

    // Init buffers for command line args.
    // ===================================

    HRESULT hres;

    // This scope is defined so that the local variables, such as the PARSE 
    // object are destroyed before CoUninitialize is called.

    TCHAR cBMOFOutputName[MAX_PATH] = TEXT("");
    if(wszBmof)
        CopyOrConvert(cBMOFOutputName, wszBmof, MAX_PATH);

    // Parse command line arguments
    // ============================

    BOOL bCheckOnly = lOptionFlags & WBEM_FLAG_CHECK_ONLY;
    BOOL bWMICheck = lOptionFlags & WBEM_FLAG_WMI_CHECK;
    bool bAutoRecover = (lOptionFlags & WBEM_FLAG_AUTORECOVER) != 0;

    if(wszDefault && wcslen(wszDefault) > 0)
    {
        hres = Parser.SetDefaultNamespace(wszDefault);
        if(FAILED(hres))
            return hres;
    }

    hres = ExtractAmendment(Parser, wszBmof);
    if(FAILED(hres))
        return hres;

    Parser.SetOtherDefaults(lClassFlags, lInstanceFlags, bAutoRecover);
    if(!Parser.Parse())
    {
        int nLine = 0, nCol = 0, nError;
        TCHAR Msg[1000];
        WCHAR * pErrorFile = NULL;

        if(Parser.GetErrorInfo(Msg, 1000, &nLine, &nCol, &nError, &pErrorFile))
            Trace(true, Parser.GetDbg(), ERROR_SYNTAX, pErrorFile, nLine, nError, //nLine+1,
                Msg);
        SetInfo(pInfo, 2, nError);
        return S_FALSE;
    }
    Parser.SetToNotScopeCheck();
    // Autorecover is not compatible with certain flags

    if(((lOptionFlags & WBEM_FLAG_DONT_ADD_TO_LIST) == 0 ) &&
       (Parser.GetAutoRecover() || bAutoRecover) && 
       ((lInstanceFlags & ~WBEM_FLAG_OWNER_UPDATE) || (lClassFlags & ~WBEM_FLAG_OWNER_UPDATE) || 
       (wszDefault && wszDefault[0] != 0) || Parser.GetRemotePragmaPaths()))
    {
        Trace(true, Parser.GetDbg(), INVALID_AUTORECOVER);
        SetInfo(pInfo, 1, 0);
        return S_FALSE;
    }

    Trace(false, Parser.GetDbg(), SUCCESS);

    if(bCheckOnly)
    {
        Trace(false, Parser.GetDbg(), SYNTAX_CHECK_COMPLETE);
        SetInfo(pInfo, 0, 0);
        return S_OK;
    }
    

    CMofData* pData = Parser.AccessOutput();

    if((lstrlen(cBMOFOutputName) > 0 && (lOptionFlags & WBEM_FLAG_SPLIT_FILES)) || 
        Parser.GetAmendment())
	{
		hres = pData->Split(Parser, wszBmof, pInfo, Parser.IsUnicode(), Parser.GetAutoRecover(),
            Parser.GetAmendment());
		if(hres != S_OK)
		{
			SetInfo(pInfo, 3, hres);
			return S_FALSE;
		}
        else
        {
            SetInfo(pInfo, 0, 0);
            return S_OK;
        }

	}
    else if(lstrlen(cBMOFOutputName))
    {
        if(Parser.IsntBMOFCompatible())
        {
            Trace(true, Parser.GetDbg(), BMOF_INCOMPATIBLE);
            SetInfo(pInfo, 3, WBEM_E_INVALID_PARAMETER);
            return S_FALSE;
        }
        
        Trace(false, Parser.GetDbg(), STORING_BMOF, cBMOFOutputName);
        
        CPtrArray * pObjArray = pData->GetObjArrayPtr(); 
        
        SCODE sc = StoreBMOF(Parser, pObjArray, bWMICheck, cBMOFOutputName, Parser.GetDbg());
        
        if(sc != S_OK)
        {
            SetInfo(pInfo, 3, sc);
            return S_FALSE;
        }
        else
        {
            SetInfo(pInfo, 0, 0);
            return S_OK;
        }
    }

    IWbemLocator* pLocator = NULL;
    hres = CoCreateInstance(
            (bInProc) ? CLSID_WbemAdministrativeLocator : CLSID_WbemLocator,
            NULL, CLSCTX_ALL, IID_IWbemLocator,
            (void**)&pLocator);

    if(FAILED(hres))
    {
        SetInfo(pInfo, 3, hres);
        return S_FALSE;
    }


    Trace(false, Parser.GetDbg(), STORING_DATA);

    BOOL bConnectRepOnly = lOptionFlags & WBEM_FLAG_CONNECT_REPOSITORY_ONLY;
    if(bInProc && (lClassFlags & WBEM_FLAG_OWNER_UPDATE))
        bConnectRepOnly = TRUE;

    hres = pData->Store(Parser, pLocator, pOverride, TRUE,UserName, pPassword , Authority, pCtx,
                                (bInProc) ? CLSID_WbemAdministrativeLocator : CLSID_WbemLocator,
                                pInfo, lClassFlags & WBEM_FLAG_OWNER_UPDATE,
                                bConnectRepOnly );
    if(pLocator != NULL)
        pLocator->Release();
    if(hres != S_OK)
    {
        SetInfo(pInfo, 3, hres);
        return S_FALSE;
    }
    else
    {
        if(Parser.GetFileName())
            ERRORTRACE((LOG_MOFCOMP,"Finished compiling file:%ls\n", Parser.GetFileName()));
        if(Parser.GetAutoRecover())
        {
            if(lOptionFlags & WBEM_FLAG_DONT_ADD_TO_LIST)
            {
                if(pInfo)
                    pInfo->dwOutFlags |= AUTORECOVERY_REQUIRED;
            }
            else
                AddToAutoRecoverList(Parser.GetFileName());
        }

        SetInfo(pInfo, 0, 0);
        return S_OK;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\mofdata.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MOFDATA.CPP

Abstract:

	Entry points for the WBEM MOF compiler.

History:

	a-davj  12-April-97   Added WMI support.

--*/

#include "precomp.h"
#include <cominit.h>
#include "mofout.h"
#include "mofdata.h"
#include "typehelp.h"
#include "bmof.h"
#include "cbmofout.h"
#include "trace.h"
#include "strings.h"
#include "arrtempl.h"
#include <genutils.h>
#include <tchar.h>

#define TEMP_BUF 128

WCHAR * Macro_CloneStr(LPCWSTR pFr)
{
    if(pFr == NULL)
        return NULL;
    WCHAR * pTo = new WCHAR[wcslen(pFr) + 1];
    if(pTo)
    {
        wcscpy(pTo, pFr);
        return pTo;
    }
    return NULL;
}

CNamespaceCache::CNamespaceRecord::CNamespaceRecord(
                                             COPY LPCWSTR wszName,
                                             ADDREF IWbemServices* pNamespace)
{
    m_wszName = Macro_CloneStr(wszName);
    m_pNamespace = pNamespace;
    m_pNamespace->AddRef();
}

CNamespaceCache::CNamespaceRecord::~CNamespaceRecord()
{
    delete [] m_wszName;
    if(m_pNamespace) m_pNamespace->Release();
}

//*****************************************************************************

CNamespaceCache::CNamespaceCache(ADDREF IWbemLocator* pLocator)
{
    if(pLocator)
        pLocator->AddRef();
    m_pLocator = pLocator;
}

CNamespaceCache::~CNamespaceCache()
{
    if(m_pLocator) m_pLocator->Release();
    for(int i = 0; i < m_aRecords.GetSize(); i++)
    {
        delete (CNamespaceRecord*)m_aRecords[i];
    }
}

RELEASE_ME IWbemServices* CNamespaceCache::GetNamespace(COPY LPCWSTR wszName, SCODE & scRet, 
                                                       WCHAR * pUserName, WCHAR * pPassword , WCHAR * pAuthority,
                                                       IWbemContext * pCtx, GUID LocatorGUID, BOOL bRepositOnly)
{
    // Check if it is the cache
    // ========================

	scRet = S_OK;

    for(int i = 0; i < m_aRecords.GetSize(); i++)
    {
        CNamespaceRecord* pRecord = (CNamespaceRecord*)m_aRecords[i];
        if(!wbem_wcsicmp(pRecord->m_wszName, wszName))
        {
            // Found it
            // ========

            pRecord->m_pNamespace->AddRef();
            return pRecord->m_pNamespace;
        }
    }

    // Not found --- open it
    // =====================

    IWbemServices* pNamespace;

    if(wszName == NULL)
        return NULL;

    LPOLESTR pwszName;
    pwszName = SysAllocString(wszName);
    if(pwszName == NULL)
        return NULL;
    CSysFreeMe fm0(pwszName);
    
    LPOLESTR bstrPassword = NULL;
    LPOLESTR bstrUserName = NULL;
    LPOLESTR bstrAuthority = NULL;
    if(pUserName && wcslen(pUserName) > 0)
    {
            bstrUserName = SysAllocString(pUserName);
            if(bstrUserName == NULL)
                return NULL;
    }
    CSysFreeMe fm1(bstrUserName);
        
    if(pPassword)
    {
        bstrPassword = SysAllocString(pPassword);
        if(bstrPassword == NULL)
            return NULL;
    }
    CSysFreeMe fm2(bstrPassword);
    if(pAuthority && wcslen(pAuthority) > 0)
    {
        bstrAuthority = SysAllocString(pAuthority);
        if(bstrAuthority == NULL)
            return NULL;
     }
    CSysFreeMe fm3(bstrAuthority);

    // Determine if the connection is to the regular locator, or to one of the special inproc ones 
    // used for autocompile.  If it is inproc, then remote connections are not valid.

    bool bInProc = false;
    if(LocatorGUID != CLSID_WbemLocator)
        bInProc = true;

    if(bInProc)
    {
        WCHAR * pMachine = ExtractMachineName(pwszName);
        if(pMachine)
        {
            BOOL bLocal = bAreWeLocal(pMachine);
            delete pMachine;
            if(!bLocal)
            {
                scRet = WBEM_E_INVALID_NAMESPACE;
                ERRORTRACE((LOG_MOFCOMP,"Error, tried to do a remote connect during autocomp\n"));
            }
        }
    }

    // Connect up to namespace.  //TODO, PASS AUTHORITY IN THE CONTEXT

    if(scRet == S_OK)
        scRet = m_pLocator->ConnectServer((LPWSTR)pwszName,
            bstrUserName, bstrPassword, 
            NULL, (bRepositOnly) ? WBEM_FLAG_CONNECT_REPOSITORY_ONLY : 0, 
            pAuthority, pCtx, &pNamespace);
    
    if(scRet == S_OK && !bInProc)
    {

        // Set the impersonation level up so that puts to providers can be done

        DWORD dwAuthLevel, dwImpLevel;
        SCODE sc  = GetAuthImp( pNamespace, &dwAuthLevel, &dwImpLevel);
        if(sc != S_OK || dwAuthLevel > RPC_C_AUTHN_LEVEL_NONE)
            sc = SetInterfaceSecurity(pNamespace, bstrAuthority, bstrUserName, bstrPassword, 
                       RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE);

    }

    if(FAILED(scRet)) return NULL;

    // Add it to the cache
    // ===================

    CNamespaceRecord * pNew = new CNamespaceRecord(wszName, pNamespace);
    if(pNew)
        m_aRecords.Add(pNew); // AddRef'ed

    return pNamespace;
}






//*****************************************************************************
//*****************************************************************************

void CMofData::SetQualifierDefault(ACQUIRE CMoQualifier* pDefault)
{
    // Search for this qualifier in the defaults list
    // ==============================================

    for(int i = 0; i < m_aQualDefaults.GetSize(); i++)
    {
        CMoQualifier* pOrig = (CMoQualifier*)m_aQualDefaults[i];

        if(wbem_wcsicmp(pOrig->GetName(), pDefault->GetName()) == 0)
        {
            // Found it. Replace
            // =================

            delete pOrig;
            m_aQualDefaults[i] = (void*)pDefault;
            return;
        }
    }
    
    // Not found. Add
    // ==============

    m_aQualDefaults.Add((void*)pDefault);
}

HRESULT CMofData::SetDefaultFlavor(MODIFY CMoQualifier& Qual, bool bTopLevel, QUALSCOPE qs, PARSESTATE ps)
{
    
    HRESULT hr;

    // Search for this qualifier in the defaults list
    // ==============================================

    for(int i = 0; i < m_aQualDefaults.GetSize(); i++)
    {
        CMoQualifier* pOrig = (CMoQualifier*)m_aQualDefaults[i];

        if(wbem_wcsicmp(pOrig->GetName(), Qual.GetName()) == 0)
        {
            // Found it. SetFlavor
            // ===================
            
            if(pOrig->IsCimDefault())
            {
                // dont bother if the parse state is the initial scan

                if(ps == INITIAL)
                    continue;
                if(Qual.IsUsingDefaultValue())
                {

                    // see if the scope matches what we have here

                    DWORD dwScope = pOrig->GetScope();
                    bool bInScope = false;
                    if((dwScope & SCOPE_CLASS) || (dwScope & SCOPE_INSTANCE))
                        if(qs == CLASSINST_SCOPE)
                            bInScope = true;
                    if(dwScope & SCOPE_PROPERTY)
                        if(qs == PROPMETH_SCOPE)
                            bInScope = true;

                    if(bInScope)
                    {
                        CMoValue& Src = pOrig->AccessValue();
                        CMoValue& Dest = Qual.AccessValue();
                        Dest.SetType(Src.GetType());
                        VARIANT & varSrc = Src.AccessVariant();
                        VARIANT & varDest = Dest.AccessVariant();
                        hr = VariantCopy(&varDest, &varSrc);
                        if(FAILED(hr))
                            return hr;
                        Qual.SetFlavor(pOrig->GetFlavor());
                        Qual.SetAmended(pOrig->IsAmended());
                    }
                }
            }
            else
            {
                Qual.SetFlavor(pOrig->GetFlavor());
                Qual.SetAmended(pOrig->IsAmended());
            }
            return S_OK;
        }
    }
    return S_OK;
}

BOOL CMofData::IsAliasInUse(READ_ONLY LPWSTR wszAlias)
{
    for(int i = 0; i < m_aObjects.GetSize(); i++)
    {
        CMObject* pObject = (CMObject*)m_aObjects[i];
        if(pObject->GetAlias() && !wbem_wcsicmp(pObject->GetAlias(), wszAlias))
        {
            return TRUE;
        }
    }

    return FALSE;
}

BOOL IsGuid(LPWSTR pTest)
{
    int i;
    int iSoFar = 0;

#define HEXCHECK(n)                 \
    for (i = 0; i < n; i++)         \
        if (!iswxdigit(*pTest++))   \
            return FALSE;

#define HYPHENCHECK()     \
    if (*pTest++ != L'-') \
        return FALSE;

    if(*pTest++ != L'{')
        return FALSE;

    HEXCHECK(8);
    HYPHENCHECK();
    HEXCHECK(4);
    HYPHENCHECK();
    HEXCHECK(4);
    HYPHENCHECK();
    HEXCHECK(4);
    HYPHENCHECK();
    HEXCHECK(12);

    if(*pTest++ != L'}')
        return FALSE;

    return TRUE;

}

INTERNAL LPCWSTR CMofData::FindAliasee(READ_ONLY LPWSTR wszAlias)
{
    for(int i = 0; i < m_aObjects.GetSize(); i++)
    {
        CMObject* pObject = (CMObject*)m_aObjects[i];
        if(pObject->GetAlias() && !wbem_wcsicmp(pObject->GetAlias(), wszAlias))
        {
            IWbemClassObject * pTemp;
            pTemp = pObject->GetWbemObject();

            // check for unresolved aliases in keys
            
            if(pTemp && pObject->IsDone() == FALSE)
            {

                SCODE sc = pTemp->BeginEnumeration(WBEM_FLAG_KEYS_ONLY | WBEM_FLAG_REFS_ONLY);
                if(sc != S_OK)
                    return NULL;
        
                VARIANT var;
                VariantInit(&var);
                while ((sc = pTemp->Next(0, NULL, &var, NULL, NULL)) == S_OK)
                {
                    if(var.vt == VT_BSTR && IsGuid(var.bstrVal))
                    {
                        VariantClear(&var);
                        return NULL;
                    }
                    VariantClear(&var);
                }
            }
            return pObject->GetFullPath();
        }
    }

    return NULL;
}


HRESULT CMofData::Store(CMofParser & Parser, OLE_MODIFY IWbemLocator* pLocator,IWbemServices *pOverride,BOOL bRollbackable,
                        WCHAR * pUserName, WCHAR * pPassword, WCHAR * pAuthority, 
                        IWbemContext * pCtx, GUID LocatorGUID, WBEM_COMPILE_STATUS_INFO *pInfo,
                        BOOL bOwnerUpdate, BOOL bRepositOnly)
{
    HRESULT hres;
    int i;
    CNamespaceCache Cache(pLocator);
	BOOL bMakingProgress = TRUE;
    long lClassFlags = 0;
    long lInstanceFlags = 0; 

    
    while(bMakingProgress)
    {
		bMakingProgress = FALSE;
		for(i = 0; i< m_aObjects.GetSize(); i++)
		{
	        CMObject* pObject = (CMObject*)m_aObjects[i];
       
            if(pObject->IsDone())
                continue;
            lClassFlags = pObject->GetClassFlags();
            lInstanceFlags = pObject->GetInstanceFlags(); 
            if(bOwnerUpdate)
			{
                lClassFlags |= WBEM_FLAG_OWNER_UPDATE;
                lInstanceFlags |= WBEM_FLAG_OWNER_UPDATE;
			}
            // Get a namespace pointer for this object.

            SCODE scRet;
            IWbemServices* pNamespace = NULL;
            if(pOverride && !wbem_wcsicmp(L"root\\default", pObject->GetNamespace()))
			{
				// AddRef() the namespace pointer, since we will be Releasing
				// it below
				pOverride->AddRef();
                pNamespace = pOverride;
			}
            else
			{
				// This will return an AddRef'd pointer
                pNamespace = Cache.GetNamespace(pObject->GetNamespace(), scRet,
                                                pUserName, pPassword ,pAuthority, pCtx, 
                                                LocatorGUID, bRepositOnly);
			}

            if(pNamespace == NULL)
            {
                int iMsg = (GotLineNumber(i)) ? ERROR_OPENING : ERROR_OPENING_NO_LINES;
                PrintError(i, iMsg, scRet, pInfo);
                return scRet;
            }

			// Ensures we release the namespace pointer when we go out of scope
			CReleaseMe	rmns( pNamespace );

            // If there isnt a wbem object, try to get one.  This will fail if this is a 
            // instance for which the class hasn't been saved just yet.

            if(pObject->GetWbemObject() == NULL)
            {

                IWbemClassObject* pWbemObject = NULL;
                hres = pObject->CreateWbemObject(pNamespace, &pWbemObject,pCtx);
                if(hres != S_OK)
                    if(pObject->IsInstance())
                        continue;
                    else
                    {
                        PrintError(i,
                            (GotLineNumber(i)) ? ERROR_CREATING : ERROR_CREATING_NO_LINES,
                            hres, pInfo);
                        return WBEM_E_FAILED;
                    }
                bMakingProgress = TRUE;
                pObject->Reflate(Parser);
                pObject->SetWbemObject(pWbemObject);

                if(!pObject->ApplyToWbemObject(pWbemObject, pNamespace,pCtx))
                {
                    hres = m_pDbg->hresError;
                    PrintError(i,
                        (GotLineNumber(i)) ? ERROR_CREATING : ERROR_CREATING_NO_LINES,
                        hres, pInfo);
            		return WBEM_E_FAILED;
                }

            }
        
		    // If there are no unresolved aliases, save it!

            if(pObject->GetNumAliasedValues() == 0 ||
                S_OK == pObject->ResolveAliasesInWbemObject(pObject->GetWbemObject(),
                    (CMofAliasCollection*)this))
            {

                // Save this into MOM
                // ==================

                hres = pObject->StoreWbemObject(pObject->GetWbemObject(), lClassFlags, lInstanceFlags,
                                            pNamespace, pCtx, pUserName, pPassword ,pAuthority);
                if(hres != S_OK)
                {
                    PrintError(i,
                        (GotLineNumber(i)) ? ERROR_STORING : ERROR_STORING_NO_LINES,
                        hres, pInfo);
		            return WBEM_E_FAILED;
                }
                pObject->FreeWbemObjectIfPossible();
                pObject->Deflate(false);
                pObject->SetDone();
                bMakingProgress = TRUE;
            }

        }
	}

	// If there is one or more objects that cant be resolved, print and bail

	for(i = 0; i < m_aObjects.GetSize(); i++)
    {
        CMObject* pObject = (CMObject*)m_aObjects[i];
		if(pObject && !pObject->IsDone()) 
        {
            PrintError(i,
                (GotLineNumber(i)) ? ERROR_RESOLVING : ERROR_RESOLVING_NO_LINES,
                hres, pInfo);
		    return WBEM_E_FAILED;
        }
    } 
    return S_OK;
}



HRESULT CMofData::RollBack(int nObjects)
{
    return WBEM_E_FAILED;
}

BOOL CMofData::GotLineNumber(int nIndex)
{
    CMObject* pObject = (CMObject*)m_aObjects[nIndex];
    if(pObject == NULL || (pObject->GetFirstLine() == 0 && pObject->GetLastLine() == 0))
        return FALSE;
    else
        return TRUE;
}
void CMofData::PrintError(int nIndex, long lMsgNum, HRESULT hres, WBEM_COMPILE_STATUS_INFO  *pInfo)
{
    CMObject* pObject = (CMObject*)m_aObjects[nIndex];
    TCHAR szMsg[500];
	bool bErrorFound = false;

	if(pInfo)
		pInfo->ObjectNum = nIndex+1;
    if(!GotLineNumber(nIndex))
        Trace(true, m_pDbg, lMsgNum, nIndex+1);
    else
	{
        Trace(true, m_pDbg, lMsgNum, nIndex+1, pObject->GetFirstLine(), 
                                        pObject->GetLastLine(), pObject->GetFileName());
		if(pInfo)
		{
			pInfo->FirstLine = pObject->GetFirstLine();
			pInfo->LastLine = pObject->GetLastLine();
		}
	}
	if(hres)
	{

		// A few error messages are retrived from the local resources.  This is so that the name can be
		// injected into the name.

        if(hres == WBEM_E_NOT_FOUND || hres == WBEM_E_TYPE_MISMATCH || hres == WBEM_E_OVERRIDE_NOT_ALLOWED ||
			hres == WBEM_E_PROPAGATED_QUALIFIER || hres == WBEM_E_VALUE_OUT_OF_RANGE)
        {
		    Trace(true, m_pDbg, ERROR_FORMAT, hres);
            Trace(true, m_pDbg, hres, m_pDbg->GetString());
			bErrorFound = true;
        }
        else
        {
            // Get the error from the standard error facility

			IWbemStatusCodeText * pStatus = NULL;
			SCODE sc = CoCreateInstance(CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
												IID_IWbemStatusCodeText, (LPVOID *) &pStatus);
	
			if(sc == S_OK)
			{
				BSTR bstrError = 0;
				BSTR bstrFacility = 0;
				sc = pStatus->GetErrorCodeText(hres, 0, 0, &bstrError);
				if(sc == S_OK)
				{
					sc = pStatus->GetFacilityCodeText(hres, 0, 0, &bstrFacility);
					if(sc == S_OK)
					{
						IntString is(ERROR_FORMAT_LONG);
						wsprintf(szMsg, is, hres, bstrFacility, bstrError);
						bErrorFound = true;
						SysFreeString(bstrFacility);
					}
					SysFreeString(bstrError);
				}
				pStatus->Release();
			}

			// if all else fails, just use the generic error message

			if(!bErrorFound)
			{
				IntString is(ERROR_FORMATEX);
				wsprintf(szMsg, is, hres);
			}

			// Print the error message

			if(m_pDbg->m_bPrint)
	            printf("%S", szMsg);
			ERRORTRACE((LOG_MOFCOMP,"%S", szMsg));

		}	// ELSE get error from standard facility

	}	// IF hres

}


//***************************************************************************
//
//  GetFileNames
//
//  DESCRIPTION:
//
//  The amendment local, the localized and neutral file names are passed
//  in using the BMOF string.  These values are separated by commas and 
//  a single letter which indicates what follows.  An example string
//  would be ",aMS_409,nNEUTRAL.MOF,lLocalMof"  Notice that the amendment
//  substring starts with an 'a', the neutral starts with 'n', and the 
//  locale starts with 'l'.
//
//  While the neutral name is required, the locale version isnt.  If not
//  supplied, it will be created.  The two character inputs are ASSUMED to
//  point to preallocated buffers of MAX_PATH size!
//
//***************************************************************************

HRESULT GetFileNames(TCHAR * pcNeutral, TCHAR * pcLocale, LPWSTR pwszBMOF)
{
    WCHAR * pNeutral=NULL;
    WCHAR * pLocale=NULL;
    
    if(pwszBMOF == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // make a copy of the string

    WCHAR *pTemp = new WCHAR[wcslen(pwszBMOF)+1];
    if(pTemp == NULL)
        return WBEM_E_OUT_OF_MEMORY;

    CDeleteMe<WCHAR> dm1(pTemp);
    wcscpy(pTemp, pwszBMOF);

    // use wcstok to do a seach

    WCHAR * token = wcstok( pTemp, L"," );
    while( token != NULL )   
    {
        if(token[0] == L'n')
        {
            pNeutral = token+1;
            CopyOrConvert(pcNeutral, pNeutral, MAX_PATH);
        }
        else if(token[0] == L'l')
        {
            pLocale = token+1;
            CopyOrConvert(pcLocale, pLocale, MAX_PATH);
        }
        token = wcstok( NULL, L"," );
    }

    // If the neutral name was not specified, that is an error

    if(pNeutral == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // If the local name was not specified, create it and make it the
    // same as the neutral name except for changing the mfl extension
    
    if(pLocale == NULL)
    {
        TCHAR * pFr = pcNeutral,* pTo = pcLocale;
        for(; *pFr && *pFr != '.'; pTo++, pFr++)
            *pTo = *pFr;
        *pTo=0;
        lstrcat(pcLocale, TEXT(".mfl"));
    }

    // make sure that the locale and neutral names are not the same

    if(!lstrcmpi(pcLocale, pcNeutral))
        return WBEM_E_INVALID_PARAMETER;

    return S_OK;
}

//***************************************************************************
//
//  GetLocale
//
//  DESCRIPTION:
//
//  Converts the amendment string to a local number.  An example string
//  would be "MS_409"
//
//***************************************************************************

HRESULT GetLocale(long * plLocale, WCHAR * pwszAmendment)
{
    if(pwszAmendment == NULL || wcslen(pwszAmendment) != 6)
        return WBEM_E_INVALID_PARAMETER;
    *plLocale = 0;
    swscanf(pwszAmendment+3,L"%x", plLocale);
    return (*plLocale != 0) ? S_OK : WBEM_E_INVALID_PARAMETER;
}

//***************************************************************************
//
//  RecursiveSetAmended
//
//  DESCRIPTION:
//
//  Sets the boolean indicating that an object is to be amended and all of
//  its parents
//
//***************************************************************************

void CMofData::RecursiveSetAmended(CMObject * pObj)
{

    // If the object is already amended, then its parents are already set.
    // In that case, our job is done here!

    if(pObj->IsAmended())
        return;

    // If the object hasnt been set yet, set it and also set its parents

    pObj->SetAmended(true);
 
    // Look for the parent and do the same

    if(pObj->IsInstance() || pObj->IsDelete())
        return;                 // run away now if this is a instance!

    CMoClass * pClass = (CMoClass *)pObj;
    const WCHAR *pClassName = pClass->GetParentName();
    if(pClassName == NULL)
        return;

    // Find the parent and recursively set it!

	for(int i = 0; i< m_aObjects.GetSize(); i++)
	{
	    CMObject* pObject = (CMObject*)m_aObjects[i];
		if(pObject && pObject->GetClassName() && 
            !wbem_wcsicmp(pClassName, pObject->GetClassName()))
        {
            RecursiveSetAmended(pObject);
        }
	}

}

//***************************************************************************
//
//  CMofData::Split
//
//  DESCRIPTION:
//
//  Creates a neutral and locale specific mof.
//
//  Parameters:
//  pwszBMOF        See the GetFileNames() comments
//  pInfo           usual error info
//  bUnicode        if true, then the orignal file was unicode and so the
//                  new files will also be unicode
//  bAutoRecovery   Need to add this pragma if true
//  pwszAmendment   See the GetLocale() comments
//
//***************************************************************************

HRESULT CMofData::Split(CMofParser & Parser, LPWSTR pwszBMOF, WBEM_COMPILE_STATUS_INFO *pInfo, BOOL bUnicode, 
                          BOOL bAutoRecovery, LPWSTR pwszAmendment)
{
    int i;
    TCHAR cNeutral[MAX_PATH];
    TCHAR cLocale[MAX_PATH];
    
    // Determine the file names and locale

    HRESULT hRes = GetFileNames(cNeutral, cLocale, pwszBMOF);
    if(hRes != S_OK)
        return S_OK;

    long lLocale;
    hRes = GetLocale(&lLocale, pwszAmendment);
    if(hRes != S_OK)
        return S_OK;

    // Create the output objects

	COutput Neutral(cNeutral, NEUTRAL, bUnicode, bAutoRecovery, lLocale);
	COutput Local(cLocale, LOCALIZED, bUnicode, bAutoRecovery, lLocale);
	if(!Neutral.IsOK() || !Local.IsOK())
		return WBEM_E_INVALID_PARAMETER;

    // Start by determining what is amended

	for(i = 0; i< m_aObjects.GetSize(); i++)
	{
	    CMObject* pObject = (CMObject*)m_aObjects[i];
        pObject->Reflate(Parser);
		if(pObject->CheckIfAmended())
        {
            RecursiveSetAmended(pObject);
        }
	}


    // Create the neutral output and the localized output.
    // These two loops could have been combined, but are
    // separate for debugging purposes

	for(i = 0; i< m_aObjects.GetSize(); i++)
	{
	    CMObject* pObject = (CMObject*)m_aObjects[i];
		pObject->Split(Neutral);
	}
	for(i = 0; i< m_aObjects.GetSize(); i++)
	{
	    CMObject* pObject = (CMObject*)m_aObjects[i];
		pObject->Split(Local);
	}

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\mofdata.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MOFDATA.H

Abstract:

	Defines MOF compiler classes related to complete MOF file representation
	and transfer of data into WinMgmt. Division of labor between these and
	the classes defined in MOFPROP.H/CPP is not clear-cut.

History:

	11/27/96    a-levn      Compiles.

--*/

#ifndef _MCAUX_H_
#define _MCAUX_H_

#include <windows.h>
#include <wbemidl.h>
#include <miniafx.h>

#include <mofprop.h>

//******************************************************************************
//******************************************************************************
//
//  class CNamespaceCache
//
//  Represents the cache of pointers to the various namespaces MOF compiler
//  has connection to.
//
//******************************************************************************
//
//  Constructor.
//
//  Constructs the cache given the IWbemLocator pointer to WinMgmt. This class will
//  use this pointer to connect to whatever namespace is required.
//
//  PARAMETERS:
//
//      ADDREF IWbemLocator* pLocator    Locator pointer. This function AddRefs
//                                      it. It is Released in destructor.
//
//******************************************************************************
//
//  Destructor
//
//  Releases the locator pointer we were given in the constructor.
//  Releases all cached namespace pointers.
//
//******************************************************************************
//
//  GetNamespace
//
//  Retrieves a pointer to a given namespace. If in cache, the cached copy is
//  returned. If not, a new connection is established and cached.
//
//  PARAMETERS:
//
//      COPY LPCWSTR wszName    Full name of the namespace to connect to.
//
//  RETURN VALUES:
//
//      IWbemServices*:  NULL if an error occurs. If not NULL, the caller must
//                      release this pointer when no longer necessary.
//
//******************************************************************************

class CNamespaceCache
{
private:
    IWbemLocator* m_pLocator;

    struct CNamespaceRecord
    {
        LPWSTR m_wszName;
        IWbemServices* m_pNamespace;

        CNamespaceRecord(COPY LPCWSTR wszName, ADDREF IWbemServices* pNamespace);
        ~CNamespaceRecord();
    };

    CPtrArray m_aRecords; // CNamespaceRecord*

public:
    CNamespaceCache(ADDREF IWbemLocator* pLocator);
    ~CNamespaceCache();
    RELEASE_ME IWbemServices* GetNamespace(COPY LPCWSTR wszName, SCODE & scRet, 
                                           WCHAR * pUserName, WCHAR * pPassword, 
                                           WCHAR * pAuthority,IWbemContext * pCtx,
                                           GUID LocatorGUID, BOOL bConnectRepOnly);
};

//*****************************************************************************
//*****************************************************************************
//
//  class CMofData
//
//  Represents an entire MOF file, basically --- a collection of objects. See
//  CMObject in mofprop.h for details of object representation.
//
//  Capable of storing its data into WinMgmt.
//
//******************************************************************************
//
//  AddObject
//
//  Adds another object to the store.
//
//  PARAMETERS:
//
//      ACQUIRE CMObject* pObject   The object to add. The class acquires this
//                                  object and will delete it on destruction.
//
//******************************************************************************
//
//  GetNumObjects
//
//  RETURN VALUES:
//
//      int:    the number of objects in the store.
//
//******************************************************************************
//
//  GetObject
//
//  Returns the object stored at a given index
//
//  PARAMETERS:
//
//      int nIndex  The index to retrieve the object at. 
//
//  RETURN VALUES:
//
//      CMObject*:  NULL if nIndex is out of range. Otherwise, an INTERNAL 
//                  pointer which is NOT to be deleted by the caller.
//
//******************************************************************************
//
//  Store
//
//  Transfers all the data to WinMgmt.
//
//  PARAMETERS:
//
//      OLE_MODIFY IWbemLocator* pLocator   WinMgmt locator pointer to store into.
//      long lClassFlags                    WBEM_FLAG_CREATE_OR_UPATE, 
//                                          WBEM_FLAG_CREAYE_ONLY, or
//                                          WBEM_FLAG_UPDATE_ONLY to apply to 
//                                          class operations.
//      long lInstanceFlags                 Same as lClassFlags, but for 
//                                          instance operations.
//      BOOL bRollBackable                  Not implemented. Must be TRUE.
//

class CMofParser;

class CMofData : private CMofAliasCollection
{
private:
    CPtrArray m_aObjects; // CMObject*
    CPtrArray m_aQualDefaults; // CMoQualifier*
    BYTE * m_pBmofData;
    BYTE * m_pBmofToFar;
    HRESULT RollBack(int nObjects);

    INTERNAL LPCWSTR FindAliasee(READ_ONLY LPWSTR wszAlias);
    friend CMObject;
	PDBG m_pDbg;

    BOOL GotLineNumber(int nIndex);

    void PrintError(int nIndex, long lMsgNum, HRESULT hres, WBEM_COMPILE_STATUS_INFO  *pInfo);
public:
    void SetBmofBuff(BYTE * pData){m_pBmofData = pData;};
    BYTE * GetBmofBuff(){return m_pBmofData;};
    void SetBmofToFar(BYTE * pData){m_pBmofToFar = pData;};
    BYTE * GetBmofToFar(){return m_pBmofToFar;};
    BOOL CMofData::IsAliasInUse(READ_ONLY LPWSTR wszAlias);
    void AddObject(ACQUIRE CMObject* pObject) {m_aObjects.Add(pObject);}
    int GetNumObjects() {return m_aObjects.GetSize();}
    CPtrArray * GetObjArrayPtr(){return &m_aObjects;}; 

    INTERNAL CMObject* GetObject(int nIndex) 
        {return (CMObject*)m_aObjects[nIndex];}

    void SetQualifierDefault(ACQUIRE CMoQualifier* pDefault);
    HRESULT SetDefaultFlavor(MODIFY CMoQualifier& Qual, bool bTopLevel, QUALSCOPE qs, PARSESTATE ps);
    int GetNumDefaultQuals(){return m_aQualDefaults.GetSize();};
    CMoQualifier* GetDefaultQual(int nIndex){return (CMoQualifier*)m_aQualDefaults.GetAt(nIndex);}; 

	CMofData(PDBG pDbg){m_pDbg = pDbg;};
    ~CMofData()
    {
        int i;
        for(i = 0; i < m_aObjects.GetSize(); i++) 
            delete (CMObject*)m_aObjects[i];
        for(i = 0; i < m_aQualDefaults.GetSize(); i++) 
            delete (CMoQualifier*)m_aQualDefaults[i];
    }

    HRESULT Store(CMofParser & Parser, OLE_MODIFY IWbemLocator* pLocator, IWbemServices *pOverride, BOOL bRollBackable,
        WCHAR * pUserName, WCHAR * pPassword, WCHAR *pAuthority,IWbemContext * pCtx,
        GUID LocatorGUID, WBEM_COMPILE_STATUS_INFO *pInfo, BOOL bOwnerUpdate,BOOL bConnectRepOnly);

    HRESULT Split(CMofParser & Parser, LPWSTR BMOFFileName, WBEM_COMPILE_STATUS_INFO *pInfo, BOOL bUnicode, 
                    BOOL bAutoRecovery,LPWSTR pwszAmendment);
    
    void RecursiveSetAmended(CMObject * pObj);


};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\moflex.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    MOFLEX.CPP

Abstract:

	Implementation for class CMofLexer, which tokenizes MOF files.
	ANSI, DBCS and UNICODE are supported.

History:

	a-raymcc    11-Oct-95   Created.
	a-raymcc    27-Jan-96   Update for aliasing.
	a-davj       6-June-96  Added support for octal, hex and binary constants
						  and line stitching, comment concatenation, escape
						  characters and old style comments.

--*/

#include "precomp.h"
#include <bmof.h>
#include <stdio.h>
#include <errno.h>
#include <arrtempl.h>
#include "mrciclass.h"

#include "datasrc.h"
#include "moflex.h"
#include "preproc.h"
#include "trace.h"
#include "strings.h"
#include "wbemcli.h"

#define INIT_ALLOC          512
#define ADDITIONAL_ALLOC    10000
#define MAX_ALLOC           1000000
#define UUIDLEN             36

// The following is the table of tokens consisting of a 
// single character.
// =====================================================

typedef struct
{
    wchar_t cToken;
    int nSymbol;
}   SingleTok;

SingleTok SingleTokenMap[] =
{
    L'{',   TOK_OPEN_BRACE,
    L'}',   TOK_CLOSE_BRACE,
    L'[',   TOK_OPEN_BRACKET,
    L']',   TOK_CLOSE_BRACKET,
    L'(',   TOK_OPEN_PAREN,
    L')',   TOK_CLOSE_PAREN,
    L',',   TOK_COMMA,
    L'=',   TOK_EQUALS,
    L';',   TOK_SEMI,
    L'&',   TOK_AMPERSAND,
    L':',   TOK_COLON,
    L'#',   TOK_POUND,
    L'$',   TOK_DOLLAR_SIGN,
    L'+',   TOK_PLUS
};

#define NUM_SINGLE_TOKENS   (sizeof(SingleTokenMap)/sizeof(SingleTok))

// The following is the table of keywords which look like normal
// identifiers.
// =============================================================

typedef struct
{
    OLECHAR *pKeyword;
    int nToken;
}   Keyword;

static Keyword MofKeywords[] =
{
    L"class",        TOK_CLASS,
    L"instance",     TOK_INSTANCE,
    L"null",         TOK_KEYWORD_NULL,
    L"external",     TOK_EXTERNAL,
    L"as",           TOK_AS,
    L"ref",          TOK_REF,
    L"of",           TOK_OF,
//    L"object",       TOK_OBJECT,
    L"typedef",      TOK_TYPEDEF,
    L"subrange",     TOK_SUBRANGE,
    L"pragma",      TOK_PRAGMA,
    L"define",      TOK_DEFINE,
    L"ifdef",       TOK_IFDEF,
    L"include",     TOK_INCLUDE,
    L"endif",       TOK_ENDIF,
    L"ifndef",      TOK_IFNDEF,
    L"enum",         TOK_ENUM,
    L"AUTORECOVER",  TOK_AUTORECOVER,
    L"true",         TOK_TRUE,
    L"false",        TOK_FALSE,
    L"interface",    TOK_INTERFACE,
	L"ToInstance",	 TOK_TOINSTANCE,
	L"ToSubClass", TOK_TOSUBCLASS,
	L"EnableOverride",  TOK_ENABLEOVERRIDE,
	L"DisableOverride", TOK_DISABLEOVERRIDE,
	L"NotToInstance",	 TOK_NOTTOINSTANCE,
	L"Amended", TOK_AMENDED,
	L"NotToSubClass", TOK_NOTTOSUBCLASS,
	L"Restricted", TOK_RESTRICTED,
	L"qualifier", TOK_QUALIFIER,
    L"ClassFlags", TOK_CLASSFLAGS,
    L"InstanceFlags", TOK_INSTANCEFLAGS,
    L"Amendment", TOK_AMENDMENT,
    L"void", TOK_VOID,
    L"deleteclass", TOK_DELETECLASS,
    L"FAIL", TOK_FAIL,
    L"NOFAIL", TOK_NOFAIL
};

#define NUM_KEYWORDS  (sizeof(MofKeywords)/sizeof(Keyword))
BOOL iswodigit(wchar_t wcTest);

//***************************************************************************
//
//  SingleCharToken()
//
//  This examines a single character of input and scans the table to
//  determine if it is one of the single-character tokens.
//
//  Parameters:
//      c = The character being tested.
//  Return value:
//      Zero if no match, otherwise the TOK_ constant which identifies      
//      the token.
// 
//***************************************************************************

static int SingleCharToken(wchar_t c)
{
    for (int i = 0; i < NUM_SINGLE_TOKENS; i++)
        if (SingleTokenMap[i].cToken == c)
            return SingleTokenMap[i].nSymbol;

    return 0;
}

//***************************************************************************
//
//  BOOL iswwbemalpha
//
//  Used to test if a wide character is suitable for identifiers.
//
//  Parameters:
//      c = The character being tested.
//  Return value:
//      TRUE if OK.
// 
//***************************************************************************
BOOL iswwbemalpha(wchar_t c)
{
    if(c == 0x5f || (0x41 <= c && c <= 0x5a) ||
       (0x61  <= c && c <= 0x7a) || (0x80  <= c && c <= 0xfffd))
        return TRUE;
    else
        return FALSE;
}

//***************************************************************************
//
//  KeywordFilter()
//
//  This function examines an identifier string to determine if it is
//  in fact a keyword.
//
//  Parameters:
//      pTokStr = a pointer to the string to be examined.
//
//  Return value:
//      TOK_SIMPLE_IDENT if no match and no '_', or else the correct TOK_ value
//      for the keyword.
//
//***************************************************************************

static int KeywordFilter(wchar_t *pTokStr)
{
    for (int i = 0; i < NUM_KEYWORDS; i++)
        if (wbem_wcsicmp(MofKeywords[i].pKeyword, pTokStr) == 0)
            return MofKeywords[i].nToken;

    wchar_t * pEnd;
    pEnd = pTokStr + wcslen(pTokStr) -1;

    if(*pTokStr != L'_' && *pEnd != L'_')
        return TOK_SIMPLE_IDENT;
    else
        return TOK_SYSTEM_IDENT;
}

//***************************************************************************
//
//  ValidGuid()
//
//  Examines a character string to determine if it constitutes a valid
//  GUID.
//
//  Return value:
//      TRUE if the string is a GUID, FALSE if not.
//
//***************************************************************************

BOOL CMofLexer::ValidGuid()
{
    int i;
    int iSoFar = 0;

#define HEXCHECK(n)                 \
    for (i = 0; i < n; i++)         \
        if (!iswxdigit(GetChar(iSoFar++)))   \
            return FALSE;

#define HYPHENCHECK()     \
    if (GetChar(iSoFar++) != L'-') \
        return FALSE;

    HEXCHECK(8);
    HYPHENCHECK();
    HEXCHECK(4);
    HYPHENCHECK();
    HEXCHECK(4);
    HYPHENCHECK();
    HEXCHECK(4);
    HYPHENCHECK();
    HEXCHECK(12);

    return TRUE;
}

//***************************************************************************
//
//  CMofLexer::Init()
//
//  Helper for first state of construction; inializing variables.
//
//***************************************************************************

void CMofLexer::Init()
{
    m_nLine = 1; 
	m_nStartOfLinePos = 0;
    m_bBMOF = false;
    m_wFile[0] = 0;
    m_nWorkBufSize = INIT_ALLOC;
    m_pWorkBuf = new wchar_t[m_nWorkBufSize];
	m_pDataSrc = NULL;
    m_pBuff = NULL;                             // set in the constructors
	m_pToFar = NULL;
    m_nErrorCode = (m_pWorkBuf) ? no_error : memory_failure ;
}

//***************************************************************************
//
//  CMofLexer::BuildBuffer()
//
//  Helper for last stage of construction; build the unicode buffer.  Note 
//  that this can be used by either the file or memory based constructor.
//
//***************************************************************************

void CMofLexer::BuildBuffer(long lSize, TCHAR * pFileName, char *  pMemSrc, char * pMemToFar)
{
    if(m_nErrorCode != no_error)
        return;                     // already failed!

	if(pFileName)
		m_pDataSrc = new FileDataSrc(pFileName);
	else
		m_pDataSrc = new BufferDataSrc(lSize, pMemSrc);

	if(m_pDataSrc == NULL)
        m_nErrorCode = memory_failure;
	else if(m_pDataSrc->GetStatus() != 0)
        m_nErrorCode = file_io_error;
        return;
}


//***************************************************************************
//
//  Constructor for in-memory parsing.
//
//***************************************************************************

CMofLexer::CMofLexer(PDBG pDbg)
{
	m_bUnicode = false;
	m_pDbg = pDbg;
    Init();
}

HRESULT CMofLexer::SetBuffer(char *pMemory, DWORD dwMemSize)
{

    DWORD dwCompressedSize, dwExpandedSize;

    if(IsBMOFBuffer((BYTE *)pMemory, dwCompressedSize, dwExpandedSize))
    {
        bool bRet = CreateBufferFromBMOF((BYTE *)pMemory + 16, dwCompressedSize, dwExpandedSize);
        if(bRet == false)
            m_nErrorCode = invalid_source_buffer;
    }
    else
    {

    	m_bUnicode = false;
        BuildBuffer(dwMemSize+4, NULL, pMemory, pMemory+dwMemSize);
    }

    if(m_nErrorCode == no_error)
        return S_OK;
    else
        return WBEM_E_FAILED;
}

//***************************************************************************
//
//  Checks if the file contains a binarary mof and if it does, decompresses 
//  the binary data.
//
//***************************************************************************

bool CMofLexer::ProcessBMOFFile(FILE *fp)
{

    // read the first 20 bytes

    BYTE Test[TEST_SIZE];
    int iRet = fread(Test, 1, TEST_SIZE, fp);
    if(iRet != TEST_SIZE)
    {
        // if we cant read even the header, it must not be a BMOF
        return false;
    }

    DWORD dwCompressedSize, dwExpandedSize;

    // Test if the mof is binary

    if(!IsBMOFBuffer(Test, dwCompressedSize, dwExpandedSize))
    {
        // not a binary mof.  This is the typical case
        return false;
    }

    // get the compression type, and the sizes

    fseek(fp, 0, SEEK_SET);

    DWORD dwSig, dwCompType;
    iRet = fread(&dwSig, sizeof(DWORD), 1, fp);
    iRet = fread(&dwCompType, sizeof(DWORD), 1, fp);
    iRet = fread(&dwCompressedSize, sizeof(DWORD), 1, fp);
    iRet = fread(&dwExpandedSize, sizeof(DWORD), 1, fp);

    // Make sure the compression type is one we understand!

    if(dwCompType != 0 && dwCompType != 1)
    {
        return FALSE;
    }

    // If there was no compression, just read the data

    if(dwCompType == 0)
    {
        m_pBuff = (WCHAR *)new BYTE[dwExpandedSize];
        if(m_pBuff == NULL)
        {
            return false;
        }
        iRet = fread(m_pBuff, dwExpandedSize, 1, fp);
        m_bBMOF = true;
		m_pToFar = (BYTE *)m_pBuff + dwExpandedSize;
        return true;
    }

    // Allocate storage for the compressed data

    BYTE * pCompressed = new BYTE[dwCompressedSize];
    if(pCompressed == NULL)
    {
        return false;
    }

    // Read the compressed data.

    iRet = fread(pCompressed, 1, dwCompressedSize,fp);
    if((DWORD)iRet != dwCompressedSize)
    {
        delete pCompressed;
        return false;
    }

    // Convert from compress into something we can use later

    bool bRet = CreateBufferFromBMOF(pCompressed, dwCompressedSize, dwExpandedSize);
    delete pCompressed;
    return bRet;
}



//***************************************************************************
//
//  Creates the working buffer from a compressed binary mof buffer.
//
//***************************************************************************

bool CMofLexer::CreateBufferFromBMOF(byte * pCompressed, DWORD dwCompressedSize, DWORD dwExpandedSize)
{
    if(m_pBuff)
        delete m_pBuff;

    m_pBuff = (WCHAR *)new BYTE[dwExpandedSize];
    if(m_pBuff == NULL)
    {
        return false;
    }
	m_pToFar = (BYTE *)m_pBuff + dwExpandedSize;

	// Decompress the data

    CMRCICompression * pCompress = new CMRCICompression;
    if(pCompress == NULL)
        return FALSE;
    CDeleteMe<CMRCICompression> dm(pCompress);
    DWORD dwResSize = pCompress->Mrci1Decompress(pCompressed, dwCompressedSize,
        (BYTE *)m_pBuff, dwExpandedSize);
     
    bool bRet = dwResSize == dwExpandedSize;
    if(bRet)
        m_bBMOF = true;

    return bRet;

}


//***************************************************************************
//
//  Constructor for file-based parsing.
//
//***************************************************************************

CMofLexer::CMofLexer(const TCHAR *pFilePath, PDBG pDbg)
{
	m_bUnicode = FALSE;
	m_pDbg = pDbg;
    Init();
    FILE *fp;
    BOOL bBigEndian = FALSE;

    if(pFilePath == NULL)
    {
        m_nErrorCode = file_not_found;
        return;
    }
    TCHAR szExpandedFilename[MAX_PATH+1];
	DWORD nRes = ExpandEnvironmentStrings(pFilePath,
										  szExpandedFilename,
										  FILENAME_MAX);
    if(nRes == 0)
        lstrcpy(szExpandedFilename, pFilePath);

    // Make sure the file exists and can be opened

    if(pFilePath && lstrlen(szExpandedFilename))
    {
        Trace(true, pDbg, PARSING_MSG, szExpandedFilename);
    }

#ifdef UNICODE
    fp = _wfopen(szExpandedFilename, L"rb");
#else
    fp = fopen(szExpandedFilename, "rb");
#endif

    if (!fp)
    {
        if (errno == ENOENT)
            m_nErrorCode = file_not_found;
        if (errno == EACCES)
            m_nErrorCode = access_denied;
        else
            m_nErrorCode = file_io_error;
        return;
    }
    else
    {   

        CfcloseMe cm(fp);

        // If the file contains a binary mof, handle it here

        if(ProcessBMOFFile(fp))
        {
            return;
        }
    }

    // Create a temp file name

    TCHAR cTempFileName[MAX_PATH+1];
    TCHAR cTempPath[MAX_PATH+1];
    if( 0 == GetTempPath(MAX_PATH+1, cTempPath))
    {
        m_nErrorCode = problem_creating_temp_file;
        return ;
    }
    if( 0 == GetTempFileName(cTempPath, TEXT("tmp"), 0, cTempFileName))
    {
        m_nErrorCode = problem_creating_temp_file;
        return ;
    }

    // Create the temp file

    FILE *fpTemp;
#ifdef UNICODE
    fpTemp = _wfopen(cTempFileName, L"wb+");
#else
    fpTemp = fopen(cTempFileName, "wb+");
#endif
    if(fpTemp == 0)
    {
        m_nErrorCode = problem_creating_temp_file;
        return;
    }
    else
    {

        CFlexArray sofar;   // used to make sure we dont get into an infinite loop

        SCODE sc = WriteFileToTemp(szExpandedFilename, fpTemp, sofar, pDbg, this);
		fclose(fpTemp);
        for(int iCnt = 0; iCnt < sofar.Size(); iCnt++)
        {
            char * pTemp = (char * )sofar.GetAt(iCnt);
            delete pTemp;
        }

        if(sc != S_OK)
        {
			if(m_nErrorCode == no_error)
				m_nErrorCode = preprocessor_error;
		    DeleteFile(cTempFileName);
            return;
        }
    
            // Determine the size of the file
        // ==============================
    
        fseek(fpTemp, 0, SEEK_END);
        long lSize = ftell(fpTemp) + 6; // add a bit extra for ending space and null NULL
        fseek(fpTemp, 0, SEEK_SET);

        // The temp file will be little endian unicode

        lSize /= 2;
        m_bUnicode = TRUE;
        bBigEndian = FALSE;

		// This will create a DataSrc object which will clean up the temp file
        BuildBuffer(lSize,cTempFileName ,NULL,NULL);
    }   
    


}

//***************************************************************************
//
//  Destructor.
//
//***************************************************************************

CMofLexer::~CMofLexer()
{
    if (m_pBuff)
        delete m_pBuff;
    if (m_pWorkBuf)
        delete m_pWorkBuf;
	delete m_pDataSrc;
}


//***************************************************************************
//
//  iswodigit
//
//  Returns TRUE if it is a valid octal character.  '0' to '7'.
//
//***************************************************************************

BOOL iswodigit(wchar_t wcTest)
{
    if(iswdigit(wcTest) && wcTest != L'8' && wcTest != L'9')
        return TRUE;
    else
        return FALSE;
}

//***************************************************************************
//
//  CMofLexer::OctalConvert
//
//  Converts an octal escape sequence into a character and returns the number
//  of digits converted.  Only a max of 3 digits is converted and if it isnt
//  a wchar, the digits cant add up to more that 0377
//
//***************************************************************************

int CMofLexer::OctalConvert(wchar_t *pResult, LexState lsCurr)
{
    int iNum = 0; 
    wchar_t wcTest;
    *pResult = 0;
    for(wcTest = GetChar(iNum+1); iswodigit(wcTest) && iNum < 3;
                    iNum++, wcTest = GetChar(iNum+1)) 
    {
        *pResult *= 8;
        *pResult += wcTest - L'0';
    }
    if((lsCurr == wstring || lsCurr == wcharacter) && *pResult >0xff)
        m_bBadString = TRUE;
    return iNum;
}

//***************************************************************************
//
//  CMofLexer::HexConvert
//
//  Converts a hex escape sequence into a character and returns the number
//  of digits converted.
//
//***************************************************************************

int CMofLexer::HexConvert(wchar_t *pResult, LexState lsCurr)
{
    int iNum = 0; 
    wchar_t wcTest;
    *pResult = 0;
    int iMax = (lsCurr == wstring||lsCurr == wcharacter) ? 4 : 2;
    for(wcTest = GetChar(iNum+2); iswxdigit(wcTest) && iNum < iMax;
                    iNum++, wcTest = GetChar(iNum+2)) 
    {
        *pResult *= 16;     
        if(iswdigit(wcTest))          // sscanf(xx,"%1x",int) also works!
            *pResult += wcTest - L'0';
        else
            *pResult += towupper(wcTest) - L'A' + 10;
    }
    if(iNum == 0)
        return -1;      // error, nothing was converted!
    return iNum+1;      // num converted plus the 'x' char!
}

//***************************************************************************
//
//  CMofLexer::ConvertEsc
//
//  Processes escape characters.  Returns size of sequence, a -1 indicates an 
//  error.  Also, the *pResult is set upon success.
//
//***************************************************************************

int CMofLexer::ConvertEsc(wchar_t * pResult, LexState lsCurr)
{
    // like C, case sensitive

    switch(GetChar(1)) {
        case L'n':
            *pResult = 0xa;
            break;
        case L't':
            *pResult = 0x9;
            break;
        case L'v':
            *pResult = 0xb;
            break;
        case L'b':
            *pResult = 0x8;
            break;
        case L'r':
            *pResult = 0xd;
            break;
        case L'f':
            *pResult = 0xc;
            break;
        case L'a':
            *pResult = 0x7;
            break;
        case L'\\':
            *pResult = L'\\';
            break;
        case L'?':
            *pResult = L'?';
            break;
        case L'\'':
            *pResult = L'\'';
            break;
        case L'\"':
            *pResult = L'\"';
            break;
        case L'x': 
            return HexConvert(pResult,lsCurr);
            break;
        default:
            if(iswodigit(GetChar(1)))
                return OctalConvert(pResult,lsCurr);
            return -1;  // error!
            break;
        }
    return 1;    
}

//***************************************************************************
//
//  ProcessStr
//
//  Processes new characters once we are in the string state.
// 
//  Return "stop" if end of string.
//
//***************************************************************************

LexState CMofLexer::ProcessStr(wchar_t * pNewChar, LexState lsCurr, int * piRet)
{


    // Check for end of string if we are a wstring state

    if (GetChar() == L'"' && lsCurr == wstring)
    {
        // search for the next non white space character.  If it is another
        // string then these strings need to be combined.

        int iCnt = 1;
        int iMinMove = 0;
        wchar_t wcTest;
        for(wcTest = GetChar(iCnt); wcTest != NULL; iCnt++, wcTest=GetChar(iCnt))
        {   
            if(m_pDataSrc->WouldBePastEnd(iCnt))
            {
				// dont go past eof!!

                *piRet = (m_bBadString) ? TOK_ERROR : TOK_LPWSTR;
                return stop;        // last string in the file
				
            }
            if(wcTest == L'"' && GetChar(iCnt+1) == L'"')
            {
                iCnt++;
                iMinMove = iCnt;
                continue;
            }
            if(!iswspace(wcTest))
                break;
        }
        // a-levn: no ascii strings are supported. "abc" means unicode.

        if(lsCurr == wstring)
        {            
            if(wcTest == L'/')
            {
                // might be an intervening comment
                // ===============================
                if (GetChar(iCnt+1) == L'/') 
                {
                    m_bInString = TRUE;
                    MovePtr(iCnt+1);
                    return new_style_comment;
                }
                else if (GetChar(iCnt+1) == L'*') 
                {
                    m_bInString = TRUE;
                    MovePtr(iCnt+1);             // skip an extra so not to be fooled by 
                    return old_style_comment;
                }
            }
            if(wcTest != L'"')
			{
                *piRet = (m_bBadString) ? TOK_ERROR : TOK_LPWSTR;
                MovePtr(iMinMove); // skip over '"'
                return stop;        // normal way for string to end
            }
            else
                MovePtr(iCnt + 1); // skip over '"'
        }
    }

    // If we are in character state, check for end

    if (GetChar(0) == L'\'' && lsCurr == wcharacter)
    {

        if(m_bBadString || m_pDataSrc->PastEnd() || 
            (m_pDataSrc->GetAt(-1) == L'\'') && m_pDataSrc->GetAt(-2) != L'\\')
            *piRet = TOK_ERROR;
        else
            *piRet = TOK_WCHAR;
        return stop;
    }

    // Not at end, get the character, possibly converting escape sequences

    if(GetChar(0) == L'\\')
    {
        int iSize = ConvertEsc(pNewChar,lsCurr);
		m_i8 = *pNewChar;
        if(iSize < 1)
            m_bBadString = TRUE;
        else
        {
            MovePtr(iSize);
            if(lsCurr == wcharacter && GetChar(1) != L'\'')
            {
                *piRet = TOK_ERROR;
                return stop;
            }

        }
    }
    else if(GetChar(0) == '\n')
    {
        m_bBadString = TRUE;
        MovePtr(-1);
        return stop;
    }
    else
    {
        *pNewChar = GetChar(0);
		m_i8 = *pNewChar;
        if(*pNewChar == 0 || *pNewChar > 0xfffeu || (GetChar(1) != L'\'' && lsCurr == wcharacter))
        {
            *piRet = TOK_ERROR;
            return stop;
        }
    }
    return lsCurr;
}

//***************************************************************************
//
//  BinaryToInt
//
//  Converts a character representation of a binary, such as "101b" into
//  an integer.  
//
//***************************************************************************

BOOL BinaryToInt(wchar_t * pConvert, __int64& i64Res)
{
    BOOL bNeg = FALSE;
    __int64 iRet = 0;
    WCHAR * pStart;
    if(*pConvert == L'-' || *pConvert == L'+')
    {
        if(*pConvert == L'-')
            bNeg = TRUE;
        pConvert++;
    }
    for(pStart = pConvert;*pConvert && (*pConvert == L'0' || *pConvert == L'1'); pConvert++)
    {
        if(pConvert - pStart > 63)
            return FALSE;               // Its too long
        iRet *= 2;
        if(*pConvert == L'1')
            iRet += 1;
    }

	if(towupper(*pConvert) != L'B')
		return FALSE;

    if(bNeg)
        iRet = -iRet;

    i64Res = iRet;
	return TRUE;
}

BOOL GetInt(WCHAR *pData, WCHAR * pFormat, __int64 * p64)
{
    static WCHAR wTemp[100];
    if(swscanf(pData, pFormat, p64) != 1)
        return FALSE;

    // Make sure the data is ok.  When comparing, make sure that leading 0's are skipped

    swprintf(wTemp, pFormat, *p64);
    WCHAR * pTemp;
    for(pTemp = pData; *pTemp == L'0' && pTemp[1]; pTemp++);
    if(wbem_wcsicmp(wTemp, pTemp))
        return FALSE;
    return TRUE;
}

//***************************************************************************
//
//  CMofLexer::iGetNumericType()
//
//  Return value:
//      What type of numeric constant the current pointer is pointing to.
//
//***************************************************************************

int CMofLexer::iGetNumericType(void)
{

#define isuorl(x) (towupper(x) == L'U' || towupper(x) == L'L')

    wchar_t * pTemp;
    BOOL bBinary = FALSE;
    wchar_t * pStart;   // first charcter not including leading - or +
    int iNumBinaryDigit = 0;
    int iNumDigit = 0;
    int iNumOctalDigit = 0;
    int iNumDot = 0;
    int iNumE = 0;

    wchar_t * pEnd = m_pWorkBuf + wcslen(m_pWorkBuf) - 1;

    if(*m_pWorkBuf == L'-' || *m_pWorkBuf == L'+')
        pStart = m_pWorkBuf+1;
    else 
        pStart = m_pWorkBuf;
    int iLen = wcslen(pStart);      // length not including leading '-' or '+'


    BOOL bHex = (pStart[0] == L'0' && towupper(pStart[1]) == L'X');

    // loop through and count the number of various digit types, decimal points, etc.
    // ==============================================================================

    for(pTemp = pStart; *pTemp; pTemp++)
    {
        // Check for 'U' or 'l' characters at the end.  They are an error
        // if the number is a float, or not in the last two characters, or
        // if a 'u' is present along with a '-' in the first character
        // ===============================================================

        if (isuorl(*pTemp))
        { 
            if(pTemp < pEnd -1 || !isuorl(*pEnd) || iNumDot || iNumE)
                return TOK_ERROR;
            if(towupper(*pTemp) == L'U' && *m_pWorkBuf == L'-')
                return TOK_ERROR;
            iLen--;
            continue;
        } 
           
        // If we previously hit the binary indicator, the only thing that 
        // should be after the b is U or L characters.
        // ==============================================================

        if(bBinary)
            return TOK_ERROR;

        // If in hex mode, only allow for x in second digit and hex numbers.
        // anything else is an error.
        // =================================================================

        if(bHex)
        {
            if(pTemp < pStart+2)        // ignore the 0X
                continue;
            if(!iswxdigit(*pTemp))
                return TOK_ERROR;
            iNumDigit++;
            continue;
        }        

        // Number is either a non hex integer or a float.
        // Do a count of various special digit types, decimal points, etc.
        // ===============================================================

        if(*pTemp == L'0' || *pTemp == L'1')
            iNumBinaryDigit++;
        if(iswodigit(*pTemp))
            iNumOctalDigit++;

        // each character should fall into one of the following catagories

        if(iswdigit(*pTemp))
            iNumDigit++;
        else if(*pTemp == L'.')
        {
            iNumDot++;
            if(iNumDot > 1 || iNumE > 0)
                return TOK_ERROR;
        }
        else if(towupper(*pTemp) == L'E') 
        {
            if(iNumDigit == 0 || iNumE > 0)
                return TOK_ERROR;
            iNumDigit=0;            // to ensure at least one digit after the 'e'
            iNumE++;
        }
        else if(*pTemp == L'-' || *pTemp == L'+')  // ok if after 'E'
        {
            if(pTemp > pStart && towupper(pTemp[-1]) == L'E')
                continue;
            else
                return TOK_ERROR; 
        }
        else if (towupper(*pTemp) == L'B')
            bBinary = TRUE;
        else 
            return TOK_ERROR;
    }

    // Make sure there are enough digits
    // =================================

    if(iNumDigit < 1)
        return TOK_ERROR;

    // take care of integer case.
    // ==========================

    if(bHex || bBinary || iNumDigit == iLen)
    {
        __int64 i8 = 0;
        if(bHex)
        {
            if(!GetInt(m_pWorkBuf+2, L"%I64x", &i8))
                return TOK_ERROR;
        }
        else if(bBinary)
		{
            if(!BinaryToInt(m_pWorkBuf, i8))
				return TOK_ERROR;
		}
    
        
        else if(pStart[0] != L'0' || wcslen(pStart) == 1)
        {
            if(*m_pWorkBuf == '-')
            {
                if(!GetInt(m_pWorkBuf, L"%I64i", &i8))
                    return TOK_ERROR;
            }
            else
            {
                if(!GetInt(m_pWorkBuf, L"%I64u", &i8))
                    return TOK_ERROR;
            }
        }
        else if(iNumDigit == iNumOctalDigit)
        {
            if(!GetInt(m_pWorkBuf+1, L"%I64o", &i8))
                return TOK_ERROR;
        }
        else return TOK_ERROR;

        // Make sure the number isnt too large
        // ===================================

        m_i8 = i8;
        if(*m_pWorkBuf == L'-')
            return TOK_SIGNED64_NUMERIC_CONST; 
		else
            return TOK_UNSIGNED64_NUMERIC_CONST;
    }

    // must be a floating point, no conversion needed.

    return TOK_FLOAT_VALUE;
}

//***************************************************************************
//
//  CMofLexer::MovePtr
//
//  Moves pointer farther into the buffer.  Note that the farthest it will go 
//  is one past the last valid WCHAR which is the location of an extra NULL
//
//***************************************************************************

void CMofLexer::MovePtr(int iNum)
{
    int iSoFar = 0;
    int iChange = (iNum > 0) ? 1 : -1;
    int iNumToDo = (iNum > 0) ? iNum : -iNum;

    while(iSoFar < iNumToDo) 
    {

		if(iChange == 1)
		{

			// going forward, update the pointer and make sure it 
			// is still in an acceptable range.
			// ==================================================
			m_pDataSrc->Move(iChange);
			if(m_pDataSrc->PastEnd())     // points to the NULL
				return;


			// If going forward and a slash cr is hit, do an extra skip.

            WCHAR wCurr = m_pDataSrc->GetAt(0);
			if(wCurr == L'\\' && m_pDataSrc->GetAt(1) == L'\n')
			{
				m_nLine++;
				m_pDataSrc->Move(1);     // extra increment
				m_nStartOfLinePos = m_pDataSrc->GetPos();
				continue;
			}
			else if(wCurr == L'\\' && m_pDataSrc->GetAt(1) == L'\r' 
                                   && m_pDataSrc->GetAt(2) == L'\n')
			{
				m_nLine++;
				m_pDataSrc->Move(2);     // extra increment
				m_nStartOfLinePos = m_pDataSrc->GetPos();
				continue;
			}
			else if (wCurr == L'\n')
			{
				m_nLine++;
				m_nStartOfLinePos = m_pDataSrc->GetPos();
			}
		}
		else
		{

			// If going backward and a cr is left, then decrement the line

			if (m_pDataSrc->GetAt(0) == L'\n' && 
				m_pDataSrc->GetPos() > 0 )
			{
					m_nLine--;
					m_nStartOfLinePos = m_pDataSrc->GetPos();
			}
		
			// Update the pointer and make sure it is still in an 
			// acceptable range.
			// ==================================================
			m_pDataSrc->Move(iChange);
			if(m_pDataSrc->GetPos() < 0)
			{
				m_pDataSrc->MoveToStart();
				return;
			}

			// If going backward and a slash cr is hit, do an extra skip.

            WCHAR wCurr = m_pDataSrc->GetAt(0);
			if( wCurr == L'\n' && m_pDataSrc->GetAt(-1) == L'\\')
			{
				m_nLine--;
				m_nStartOfLinePos = m_pDataSrc->GetPos();
				m_pDataSrc->Move(-1);     // extra decrement
				continue;
			}
            else if( wCurr == L'\n' && m_pDataSrc->GetAt(-1) == L'\r' &&
                                       m_pDataSrc->GetAt(-2) == L'\\')
			{
				m_nLine--;
				m_nStartOfLinePos = m_pDataSrc->GetPos();
				m_pDataSrc->Move(-2);     // extra decrement
				continue;
			}

		}

        iSoFar++;
    }
}

//***************************************************************************
//
//  CMofLexer::GetChar()
//
//  Returns a character at an offset from the current character pointer.
//
//***************************************************************************

wchar_t CMofLexer::GetChar(int iNum)
{
    if(iNum == 0)
        return m_pDataSrc->GetAt(0);
	else if(iNum == 1)
	{
		wchar_t tRet = m_pDataSrc->GetAt(1);
		if(tRet != L'\\' && tRet != '\n')
			return tRet;
	}  
    MovePtr(iNum);
    wchar_t wcRet = m_pDataSrc->GetAt(0);
    MovePtr(-iNum);
    return wcRet;
}

//***************************************************************************
//
//  CMofLexer::iGetColumn()
//
//  Gets the current column value.  Counts back to the previous Cr or the 
//  start of buffer.
//
//***************************************************************************

int CMofLexer::iGetColumn()
{
	return  m_pDataSrc->GetPos() - m_nStartOfLinePos;
}

//***************************************************************************
//
//  CMofLexer::bOKNumericAddition()
//
//  Returns true if the test character could be added to numeric buffer.
//  Note that it returns true if an alphanumeric, or a + or - and the last
//  character in the working buffer is an 'E'
//
//***************************************************************************

BOOL CMofLexer::bOKNumericAddition(wchar_t cTest)
{
    if(iswalnum(cTest) || cTest == L'.')
        return TRUE;
    int iLen = wcslen(m_pWorkBuf);
    if(iLen > 0)
        if(towupper(m_pWorkBuf[iLen-1]) == L'E' &&
            (cTest == L'+' || cTest == L'-') &&
            towupper(m_pWorkBuf[1]) != L'X')
                return TRUE;
    return FALSE;
}

//***************************************************************************
//
//  CMofLexer::SpaceAvailable()
//
//  Returns TRUE if there is enuough space in the working buffer to add.
//  another character.  It will expand the buffer if need be.
//
//***************************************************************************

BOOL CMofLexer::SpaceAvailable()
{
    // most common case is that there is already space available

    int iNumWChar = m_pEndOfText-m_pWorkBuf+1;
    if(iNumWChar < m_nWorkBufSize)
        return TRUE;

    if(m_nWorkBufSize > MAX_ALLOC)     // programs need limits!
        return FALSE;

    // Allocate a bigger buffer and copy the old stuff into it
    // =======================================================

    long nNewSize = m_nWorkBufSize + ADDITIONAL_ALLOC;
    wchar_t * pNew = new wchar_t[nNewSize];
    if(pNew == FALSE)
        return FALSE;
    memcpy(pNew, m_pWorkBuf, m_nWorkBufSize*2);
    delete m_pWorkBuf;
    m_nWorkBufSize = nNewSize;
    m_pWorkBuf = pNew;
    m_pEndOfText  = m_pWorkBuf + iNumWChar - 1;
    return TRUE;
}

//***************************************************************************
//
//  NextToken()
//
//  This function contains the DFA recognizer for MOF tokens.  It works
//  entirely in UNICODE characters, so the NextChar() function is expected
//  to pretranslate ANSI or DBCS source streams into wide characters.
//
//  Return value:
//      One of the TOK_ constants, or TOK_EOF when the end of the input
//      stream has been reached.  If the user calls PushBack(), then
//      this will return the symbol which was pushed back onto the input
//      stream.  Only one level of push back is supported.
//
//***************************************************************************
int CMofLexer::NextToken(bool bDontAllowWhitespace) 
{
    int nToken = TOK_ERROR;
    LexState eState = start;
    m_bBadString = FALSE;
    
    *m_pWorkBuf = 0;
    m_pEndOfText = m_pWorkBuf;
    m_bInString = FALSE;

#define CONSUME(c)  \
    if (!SpaceAvailable()) return TOK_ERROR;\
    *m_pEndOfText++ = (c), *m_pEndOfText = 0;

    wchar_t c;
    
    for (MovePtr(1); m_nErrorCode == no_error && !m_pDataSrc->PastEnd(); MovePtr(1))
    {
        c = GetChar();

        // *************************************************************************
        // General 'start' state entry.
        // ============================

        if (eState == start)
        {
            m_nTokCol = iGetColumn();
            m_nTokLine = m_nLine;
            // If a non-newline whitespace and we are in 'start', then just strip it.
            // =======================================================================

            if (iswspace(c) || c == L'\n')
                if(bDontAllowWhitespace)
                    return TOK_ERROR;
                else
                    continue;


            // Check for string continuation
            // =============================

            if(m_bInString)
            {
                if(c == '"')
                {
                    eState = wstring;
                    continue;
                }
                else
                {
                    // string ended after all

                    MovePtr(-1);
                    return TOK_LPWSTR;
                }
            }

            // Handle all single character tokens.
            // ===================================

            if (nToken = SingleCharToken(c))
                return nToken;

            // Start of comment, we have to get either another / or a *.  
            // The style of comment depends on what you get.  To get 
            // neither is an error
            // ======================================================

            if (c == L'/')
            {
                if (GetChar(1) == L'/') 
                {
                    eState = new_style_comment;
                    continue;
                }
                else if (GetChar(1) == L'*') 
                {
                    eState = old_style_comment;
                    MovePtr(1);             // skip an extra so not to be fooled by /*/
                    continue;
                }
                else
                    return TOK_ERROR;
            }

            // Check for strings or characters. Like C, 'L' is case sensitive
            // ================================

            if (c == L'"' || c == L'\'')
            {
                eState = (c == L'"') ? wstring : wcharacter;
                continue;
            }

            // Tokens beginning with these letters might be a uuid.   
            // ====================================================

            if (iswxdigit(c) && ValidGuid())
            {
                eState = uuid;
                CONSUME(c);
                continue;
            }

                
            // Check for identifiers which start with either a letter or _
            // ===========================================================

            if (iswwbemalpha(c) || c == L'_')
            {
                eState = ident;
                CONSUME(c);
                continue;
            }

            // Check for a leading minus sign or digits.  Either indicates
            // a numeric constant
            // ===========================================================

            if (iswdigit(c) || c == L'-') 
            {
                eState = numeric;
                CONSUME(c);
                continue;
            }

            // If the first character was a '.', then it might be a
            // float or a single byte token.
            // ====================================================

            if (c == L'.')
            {
                if (iswdigit(GetChar(1)))
                {
                    eState = numeric;
                    CONSUME(c);
                    continue;
                }
            return TOK_DOT;
            }

            // If here, an unknown token.
            // ==========================

            break;
        } // end of if (eState == start)

        // ************************************************************
        // Some state other than start


        // If we are in a quoted string or character.
        // ==========================================

        if (eState == wstring || eState == wcharacter)
        {
            wchar_t wTemp;      // might be converted esc sequence
            int iRet;
            LexState lsNew = ProcessStr(&wTemp,eState,&iRet);
            if(stop == lsNew)
            {
                return iRet;
            }
            else 
            {
                eState = lsNew;
            }

            if(eState == wstring || eState == wcharacter)
            {
                CONSUME(wTemp);
            }
            // else we stepped out of the string and into a comment.
            continue;
        }


        // numeric state, undetermined numeric constant.
        // =============================================

        if (eState == numeric)
        {
            if(bOKNumericAddition(c)) 
            {
                CONSUME(c);
                continue;
            }

            MovePtr(-1);
            return iGetNumericType();
        }


        // If we are getting an identifer, we continue
        // until a nonident char is hit.
        // ============================================

        if (eState == ident)
        {
            if (iswdigit(c) || iswwbemalpha(c) || c == L'_')
            {
                CONSUME(c);
                continue;
            }

            MovePtr(-1);
            return KeywordFilter(m_pWorkBuf);
        }

        // GUIDs are already verified, just load up the proper length
        // ==========================================================

        if (eState == uuid)
        {
            CONSUME(c);
            if(wcslen(m_pWorkBuf) >= UUIDLEN)
                return TOK_UUID;
            else
                continue;
        }

        // Take care of comment states.  New style comments "//" are 
        // terminated by a new line while old style end with "*/"
        // =========================================================

        if (eState == new_style_comment)
        {
            if (c == L'\n')
            {
                eState = start;
            }
            continue;
        }

        if (eState == old_style_comment) 
        {
            if (c == L'*')
                if(GetChar(1) == L'/') 
                {
                    MovePtr(1);
                    eState = start;
                }
            continue;
        }
        break;      // this is bad, got into strange state
    }

    // If we ended and the last thing was a string, the we are ok.  This takes care
    // of the case where the last token in a file is a string.

    if ((eState == start || eState == new_style_comment) && m_bInString)
    {
          return TOK_LPWSTR;
    }

    // return eof if we never got started, ex, bad file name

    if(m_nErrorCode != no_error)
        return 0;
    if(m_pDataSrc->PastEnd() && 
			(eState == start || eState == new_style_comment))
        return 0; 
    else
    {
        if(eState == old_style_comment)
            Trace(true, m_pDbg, UNEXPECTED_EOF, m_nTokLine);
		if(c == L'*' && GetChar(1) == L'/')
            Trace(true, m_pDbg, COMMENT_ERROR, m_nTokLine);

        return TOK_ERROR;
    }
}

//***************************************************************************
//
//  GetText
//
//***************************************************************************

const OLECHAR *CMofLexer::GetText(int *pLineDeclared)
{
    if (pLineDeclared)
        *pLineDeclared = m_nTokLine;

    return m_pWorkBuf;
}

void CMofLexer::SetLexPosition(ParseState * pPos)
{
	m_pDataSrc->MoveToPos(pPos->m_iPos); 
}

void CMofLexer::GetLexPosition(ParseState * pPos)
{
	pPos->m_iPos = m_pDataSrc->GetPos(); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\mofout.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    MOFOUT.H

Abstract:

Class and code used to output split files.

History:

	2/4/99    a-davj      Compiles.

--*/

#ifndef _MOFOUT_H_
#define _MOFOUT_H_

#include <windows.h>
#include <wbemidl.h>
#include <miniafx.h>

typedef enum {NEUTRAL, LOCALIZED} OutputType;
class COutput
{
    HANDLE m_hFile;     // file being output to
    OutputType m_Type;  // indicates neutral/localized
    BOOL m_bUnicode;    // true if unicode
    int m_Level;        // 0 indicates normal object, higher numbers
                        // indicate that current object is embedded
    long m_lClassFlags; // last class flags 
    long m_lInstanceFlags; // last instance flags
    WCHAR m_wszNamespace[MAX_PATH+1]; // last namespace
    bool m_bSplitting;      // indicates if current instance has a "locale" qual.
    long m_lLocale;
public:
    COutput(TCHAR * pName, OutputType ot, BOOL bUnicode, BOOL bAutoRecovery, long lLocale);
    ~COutput();
    void WritePragmasForAnyChanges(long lClassFlags, long lInstanceFlags, 
        LPWSTR pwsNamespace, long lLocale);
    void IncLevel(){m_Level++;};
    void DecLevel(){m_Level--;};
    int GetLevel(){return m_Level;};
    long GetLocale(){return m_lLocale;};
    bool IsSplitting(){return m_bSplitting;};
    void SetSplitting(bool bVal){m_bSplitting = bVal;};
    BOOL IsOK(){return (m_hFile != INVALID_HANDLE_VALUE);};
    OutputType GetType(){return m_Type;};
    bool WriteLPWSTR(WCHAR const * pOutput);
    bool WriteVARIANT(VARIANT & var);
    bool NewLine(int iIndent);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\moflex.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MOFLEX.H

Abstract:

	Declarations for class CMofLexer, which tokenizes MOF files.  
	ANSI, DBCS and UNICODE are supported.

History:

	a-raymcc    11-Oct-95   Created.
	a-raymcc    27-Jan-96   Update for aliasing.
	a-davj       6-June-96  Added support for octal, hex and binary constants
						  and line stitching, comment concatenation, escape
						  characters and old style comments.

--*/

#ifndef _MOFLEX_H_
#define _MOFLEX_H_

#include <windows.h>
#include <stdio.h>
#include "trace.h"

// Terminal tokens required by the parser.
// =======================================

#define TOK_NULL                     0
#define TOK_ERROR                   -1

#define TOK_CLASS                           256
#define TOK_SIMPLE_IDENT                    257
#define TOK_OPEN_BRACE                      258
#define TOK_CLOSE_BRACE                     259
#define TOK_SEMI                            260
#define TOK_COLON                           261
#define TOK_INTERFACE                       262
#define TOK_REF                             263
#define TOK_OPEN_BRACKET                    264
#define TOK_CLOSE_BRACKET                   265
#define TOK_EQUALS                          266
#define TOK_INSTANCE                        267
#define TOK_AS                              268
#define TOK_COMMA                           269
#define TOK_EXTERNAL                        270
#define TOK_OPEN_PAREN                      271
#define TOK_CLOSE_PAREN                     272
#define TOK_LPWSTR                          274
#define TOK_UUID                            277
#define TOK_KEYWORD_NULL                    278
#define TOK_FLOAT_VALUE                     279
#define TOK_AMPERSAND                       280
#define TOK_DOT                             281
#define TOK_DOLLAR_SIGN                     282
#define TOK_HEX_CONST                       283
#define TOK_OCTAL_CONST                     284
#define TOK_LINE                            285
#define TOK_OF                              286
#define TOK_OBJECT                          287
#define TOK_TYPEDEF                         288
#define TOK_SUBRANGE                        289
#define TOK_PRAGMA                          290
#define TOK_DEFINE                          291
#define TOK_IFDEF                           292
#define TOK_INCLUDE                         293
#define TOK_ENDIF                           294
#define TOK_IFNDEF                          295
#define TOK_WCHAR                           296
#define TOK_ENUM                            300
#define TOK_AUTORECOVER                     301
#define TOK_NAMESPACE                       302
#define TOK_POUND                           303
#define TOK_TRUE                            304
#define TOK_FALSE                           305
#define TOK_TOINSTANCE                      306
#define TOK_TOSUBCLASS                      307
#define TOK_ENABLEOVERRIDE                  308
#define TOK_DISABLEOVERRIDE                 309
#define TOK_NOTTOINSTANCE                   310
#define TOK_NOTTOSUBCLASS                   311
#define TOK_QUALIFIER                       312
#define TOK_INSTANCEFLAGS                   313
#define TOK_CLASSFLAGS                      314
#define TOK_SIGNED64_NUMERIC_CONST          315
#define TOK_UNSIGNED64_NUMERIC_CONST        316
#define TOK_VOID                            317
#define TOK_AMENDMENT                       318
#define TOK_RESTRICTED                      319
#define TOK_SYSTEM_IDENT                    320
#define TOK_AMENDED							321
#define TOK_DELETECLASS						322
#define TOK_FAIL                            323
#define TOK_NOFAIL                          324
#define TOK_DELETEINSTANCE                  326
#define TOK_LOCALE                          327
#define TOK_PLUS	             		    328
#define TOK_INSTANCELOCALE                  329
#define TOK_NONLOCAL                        330
#define TOK_NONLOCALTYPE                    331
#define TOK_SOURCE                          332
#define TOK_SOURCETYPE                      333
class DataSrc;

// This type is used to describe the state of the lexer state machine.
// ====================================================================

typedef enum {  start,
                new_style_comment,          // ie, "//" comments
                old_style_comment,          // ie, "/* ... */" comments
                wstring,
                wcharacter,
                uuid,
                ident,
                numeric,
                lexerror,
                stop
            }   LexState;

class CMofLexer
{
	PDBG m_pDbg;
    int   m_nLine;
    int   m_nTokCol;
	int   m_nStartOfLinePos;
    int   m_nTokLine;
    int   m_nErrorCode;
	BOOL  m_bUnicode;
    wchar_t  *m_pBuff;            // holds the data to be parsed
	BYTE *m_pToFar;
//todo    wchar_t *m_pCurrWChar;       // points to the current character
//todo    wchar_t *m_pLastWChar;       // points to the last valid character
	DataSrc * m_pDataSrc;
    wchar_t *m_pWorkBuf;         // Holds the current token string
    int   m_nWorkBufSize;        // number of WCHARs working buff holds
    wchar_t *m_pEndOfText;       // points to null terminator of working buff
    BOOL m_bInString;
    BOOL m_bBadString;
    bool m_bBMOF;
    WCHAR m_wFile[MAX_PATH];
    __int64 m_i8;

    void Init();
    BOOL SpaceAvailable();
    void BuildBuffer(long lSize, TCHAR * pFileName,char *  pMemSrc, char * pMemToFar);
    void MovePtr(int iNum);
    wchar_t GetChar(int iNum = 0);
    int iGetColumn();
    int iGetNumericType(void);
    LexState ProcessStr(wchar_t * pNewChar, LexState lsCurr, int *piRet);
    int ConvertEsc(wchar_t * pResult, LexState lsCurr);
    int OctalConvert(wchar_t *pResult, LexState lsCurr);
    int HexConvert(wchar_t *pResult, LexState lsCurr);
    BOOL bOKNumericAddition(wchar_t cTest);
    BOOL ValidGuid();
    bool ProcessBMOFFile(FILE *fp);
    bool CreateBufferFromBMOF(byte * pIn, DWORD dwCompressedSize, DWORD dwExpandedSize);    

public:
    enum {
            no_error,
            file_not_found,
            memory_failure,
            access_denied,
            file_io_error,
            unrecognized_token,
            token_too_long,
            invalid_source_file,
            invalid_source_buffer,
            problem_creating_temp_file,
            preprocessor_error,
			invalid_include_file
         };
    
    CMofLexer(PDBG pDbg);
    CMofLexer(const TCHAR *pFilePath, PDBG pDbg);    
    ~CMofLexer();
    HRESULT SetBuffer(char *pSrcMemory, DWORD dwMemSize);
	BOOL IsUnicode(){return m_bUnicode;};

    int NextToken(bool bDontAllowWhitespace = false);    // Returns 0 on end of file

    __int64 GetLastInt(){return m_i8;};
    const OLECHAR *GetText(int *pLineDeclared = 0);

    int GetLineNumber() { return m_nLine; }
    void SetLineNumber(int iNew) {m_nLine = iNew-1;};   // the -1 accounts for the cr/lf at eol
    WCHAR * GetErrorFile(){return m_wFile;};
    void SetErrorFile(const WCHAR * pNew){wcsncpy(m_wFile, pNew, MAX_PATH-1);};
    int GetColumn() { return m_nTokCol; }
    int GetError() { return m_nErrorCode; }
    void SetError(int iError) { m_nErrorCode = iError; }
    bool IsBMOF(){return m_bBMOF;};
    BYTE * GetBuff(){return (BYTE *)m_pBuff;};
    BYTE * GetToFar(){return (BYTE *)m_pToFar;};


    void SetLexPosition(ParseState * pPos);
    void GetLexPosition(ParseState * pPos);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\mofparse.cpp ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    MOFPARSE.CPP

Abstract:

	This is a recursive descent parser for the MOF syntax.
	It is based on the MOF.BNF file which defines the LL(1) MOF grammar.
	In each production, nonterminals are represented by functions
	with the same name.

	NOTES:
	(a) The lexer is implemented by class CMofLexer.
	(b) Right-recursion in the grammar is consistently implemented
	  directly as a loop for that nonterminal.

	OUTPUT:
	Output is an unchecked list of classes and instances.
	This is contained in the CMofData object.

	Verification of output is done elsewhere, depending on the
	compile context.

History:

	a-raymcc    18-Oct-95   created.
	a-raymcc    25-Oct-95   semantic stack operational
	a-raymcc    27-Jan-96   reference & alias support
	a-levn      18-Oct-96   Rewrote not to use semantic stack.
						  Converted to new mof syntax and new 
						  WINMGMT interfaces.

--*/

#include "precomp.h"
#include <stdio.h>
#include <float.h>
#include "mofout.h"
#include <mofparse.h>
#include <moflex.h>
#include <mofdata.h>
#include <tchar.h>
#include <typehelp.h>

#include <io.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>

#include "bmofhelp.h"
#include "trace.h"
#include "strings.h"
#include "moflex.h"
#include <wbemutil.h>
#include <genutils.h>
#include <arrtempl.h>
#include <autoptr.h>

//***************************************************************************
//
//  Global defs
//
//***************************************************************************

static BOOL KnownBoolQualifier(wchar_t *pIdent, DWORD *pdwQualifierVal);


//***************************************************************************
//
//  Useful macros.
//
//***************************************************************************

#define CHECK(tok)  \
    if (m_nToken != tok) return FALSE;  \
    NextToken();

//***************************************************************************
//
//  ValidFlags.
//
//***************************************************************************

bool ValidFlags(bool bClass, long lFlags)
{
	if(bClass)
		return  ((lFlags == WBEM_FLAG_CREATE_OR_UPDATE) ||
			 (lFlags == WBEM_FLAG_UPDATE_ONLY) ||
			 (lFlags == WBEM_FLAG_CREATE_ONLY) ||
			 (lFlags == WBEM_FLAG_UPDATE_SAFE_MODE) ||
			 (lFlags == WBEM_FLAG_UPDATE_FORCE_MODE) ||
			 (lFlags == (WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_UPDATE_SAFE_MODE)) ||
			 (lFlags == (WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_UPDATE_FORCE_MODE)));
	else
		return 
		((lFlags == WBEM_FLAG_CREATE_OR_UPDATE) ||
			 (lFlags == WBEM_FLAG_UPDATE_ONLY) ||
			 (lFlags == WBEM_FLAG_CREATE_ONLY));
}

//***************************************************************************
//
//***************************************************************************

CMofParser::CMofParser(const TCHAR *pFileName, PDBG pDbg)
    : m_Lexer(pFileName, pDbg), m_Output(pDbg)
{
    m_nToken = 0;
    m_bOK = true;
	m_pDbg = pDbg;
    m_nErrorContext = 0;
    m_nErrorLineNumber = 0;
    _tcsncpy(m_cFileName, pFileName, MAX_PATH-1);
    m_wszNamespace = Macro_CloneStr(L"root\\default");
    if(m_wszNamespace == NULL)
        m_bOK = false;
    m_bAutoRecover = false;
    m_wszAmendment = NULL;
	m_bRemotePragmaPaths = false;
    m_bNotBMOFCompatible = false;
    m_State = INITIAL;
    m_bDoScopeCheck = true;
}

//***************************************************************************
//
//***************************************************************************

CMofParser::CMofParser(PDBG pDbg
    )
    : m_Lexer(pDbg), m_Output(pDbg)
{
    m_bOK = true;
    m_nToken = 0;
    m_nErrorContext = 0;
	m_pDbg = pDbg;
    m_nErrorLineNumber = 0;
    m_bAutoRecover = false;
	m_bRemotePragmaPaths = false;
    m_wszAmendment = NULL;
    m_cFileName[0] = 0;
    m_bNotBMOFCompatible = false;
    m_wszNamespace = Macro_CloneStr(L"root\\default");
    if(m_wszNamespace == NULL)
        m_bOK = false;
    m_State = INITIAL;
    m_bDoScopeCheck = true;
}

//***************************************************************************
//
//***************************************************************************

CMofParser::~CMofParser()
{
    delete [] m_wszNamespace;
    delete [] m_wszAmendment;
}

//***************************************************************************
//
//***************************************************************************

HRESULT CMofParser::SetDefaultNamespace(LPCWSTR wszDefault)
{
    delete [] m_wszNamespace;
    m_wszNamespace = Macro_CloneStr(wszDefault);
    if(m_wszNamespace == NULL && wszDefault != NULL)
        return WBEM_E_OUT_OF_MEMORY;
    else
         return S_OK;
}

HRESULT CMofParser::SetAmendment(LPCWSTR wszDefault)
{
    delete [] m_wszAmendment;
    m_wszAmendment = Macro_CloneStr(wszDefault);
    if(m_wszAmendment == NULL && wszDefault != NULL)
        return WBEM_E_OUT_OF_MEMORY;
    else
         return S_OK;
}


//***************************************************************************
//
//***************************************************************************

bool CMofParser::GetErrorInfo(
    TCHAR *pBuffer,
    DWORD dwBufSize,
    int *pLineNumber,
    int *pColumn,
	int *pError,
    LPWSTR * pErrorFile
    )
{
    if(m_Lexer.IsBMOF())
        return false;
    if (pLineNumber)
        *pLineNumber = m_Lexer.GetLineNumber();
    if (pColumn)
        *pColumn = m_Lexer.GetColumn();
	if (pError)
		*pError = m_nErrorContext;

    TCHAR *pErrText = TEXT("Undefined error");

	IntString Err(m_nErrorContext);
	if(lstrlen(Err) > 0)
		pErrText = Err;
    if ((DWORD)lstrlen(pErrText) < dwBufSize)
        lstrcpy(pBuffer, pErrText);
    *pErrorFile = m_Lexer.GetErrorFile();
    return true;
}


//***************************************************************************
//
//  <Parse> ::= <top_level_decl><Parse>
//  <Parse> ::= <preprocessor_command><Parse>
//  <Parse> ::= <>
//
//***************************************************************************
// v1.10

BOOL CMofParser::Parse()
{

    if(m_bOK == false)
    {
        m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
        return FALSE;
    }
    
    // Check for the special case of the binary mof file.  If it is so, 
    // dont parse, instead get the classes, attributes and props
    // from the file

    if(m_Lexer.IsBMOF())
    {
		return ConvertBufferIntoIntermediateForm(&m_Output,m_Lexer.GetBuff(), m_pDbg,
			m_Lexer.GetToFar());
    }


    if(m_Lexer.GetError() != 0)
    {
        if(CMofLexer::problem_creating_temp_file == m_Lexer.GetError())
            m_nErrorContext = WBEMMOF_E_ERROR_CREATING_TEMP_FILE;
        else if(CMofLexer::invalid_include_file == m_Lexer.GetError())
            m_nErrorContext = WBEMMOF_E_ERROR_INVALID_INCLUDE_FILE;
        else
            m_nErrorContext = WBEMMOF_E_INVALID_FILE;
        return FALSE;
    }

    NextToken();

    BOOL bEnd = FALSE;
    while(!bEnd)
    {
        switch(m_nToken)
        {
            case TOK_POUND:
                if(!preprocessor_command()) 
                    return FALSE;
                break;
            
            case TOK_QUALIFIER:
                if(!qualifier_default())
                    return FALSE;
                break;

            case 0: // nothing left to parse
                bEnd = TRUE;
                break;
            default:
                if (!top_level_decl())
                    return FALSE;
                break;
        }
    }

    return TRUE;
}

//***************************************************************************
//
//  <preprocessor_command> ::= <pound_define>  // not impl
//  <preprocessor_command> ::= TOK_PRAGMA <pound_pragma>
//  <preprocessor_command> ::= TOK_LINE TOK_UNSIGNED_NUMERIC_CONST TOK_LPWSTR
//
//***************************************************************************

BOOL CMofParser::preprocessor_command()
{
    NextToken();
    DWORD dwType = m_nToken;
    if(dwType == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"line", m_Lexer.GetText()))
        dwType = TOK_LINE;
   
    switch(dwType)
    {
        case TOK_PRAGMA:
            if(!pound_pragma())
                return FALSE;
            break;
        case TOK_LINE:
            NextToken();
            if(m_nToken != TOK_UNSIGNED64_NUMERIC_CONST)
                return false;
            m_Lexer.SetLineNumber((int)m_Lexer.GetLastInt());
            NextToken();
            if(m_nToken != TOK_LPWSTR)
                return false;
            m_Lexer.SetErrorFile(m_Lexer.GetText());
            NextToken();
            return TRUE;
        case TOK_INCLUDE:
        case TOK_DEFINE:
            Trace(true, m_pDbg, PREPROCESSOR);
            return FALSE;
    }
    return TRUE;
}

//***************************************************************************
//
//  <FailOrNoFail> ::= FAIL;
//  <FailOrNoFail> ::= NOFAIL;
//
//***************************************************************************

BOOL CMofParser::FailOrNoFail(bool * pbFail)
{
    NextToken();
    if(m_nToken == TOK_FAIL)
        *pbFail = true;
    else if(m_nToken == TOK_NOFAIL)
        *pbFail = false;
    else return FALSE;
    return TRUE;
}

//***************************************************************************
//
//<pound_pragma> ::= TOK_LPWSTR             // Where string is "namespace"
//                    TOK_OPEN_PAREN TOK_LPWSTR TOK_CLOSE_PAREN;
//
//<pound_pragma> ::= TOK_AMENDMENT 
//                    TOK_OPEN_PAREN TOK_LPWSTR TOK_CLOSE_PAREN;
//
//<pound_pragma> ::= TOK_CLASSFLAGS  
//                    TOK_OPEN_PAREN <flag_list> TOK_CLOSE_PAREN;
//
//<pound_pragma> ::= TOK_INSTANCEFLAGS 
//                    TOK_OPEN_PAREN <flag_list> TOK_CLOSE_PAREN;
//
//<pound_pragma> ::= TOK_AUTORECOVER 
//
//<pound_pragma> ::= TOK_DELETECLASS 
//                    TOK_OPEN_PAREN TOK_LPWSTR TOK_COMMA <FailOrNoFail>  TOK_CLOSE_PAREN;
//
//***************************************************************************

BOOL CMofParser::pound_pragma()
{
    NextToken();

    DWORD dwType = m_nToken;

    if(dwType == TOK_AUTORECOVER)
    {
        m_bAutoRecover = true;
        NextToken();
        return TRUE;
    }

    if(dwType == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"locale", m_Lexer.GetText()))
    {
        dwType = TOK_LOCALE;
        ERRORTRACE((LOG_MOFCOMP,"Warning, unsupported LOCALE pragma\n"));
    }

    if(dwType == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"INSTANCELOCALE", m_Lexer.GetText()))
    {
        dwType = TOK_INSTANCELOCALE;
        ERRORTRACE((LOG_MOFCOMP,"Warning, unsupported INSTANCELOCALE pragma\n"));
    }

    if(dwType == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"NONLOCAL", m_Lexer.GetText()))
    {
        dwType = TOK_NONLOCAL;
        ERRORTRACE((LOG_MOFCOMP,"Warning, unsupported NONLOCAL pragma\n"));
    }

    if(dwType == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"NONLOCALTYPE", m_Lexer.GetText()))
    {
        dwType = TOK_NONLOCALTYPE;
        ERRORTRACE((LOG_MOFCOMP,"Warning, unsupported NONLOCALTYPE pragma\n"));
    }

    if(dwType == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"SOURCE", m_Lexer.GetText()))
    {
        dwType = TOK_SOURCE;
        ERRORTRACE((LOG_MOFCOMP,"Warning, unsupported SOURCE pragma\n"));
    }

    if(dwType == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"SOURCETYPE", m_Lexer.GetText()))
    {
        dwType = TOK_SOURCETYPE;
        ERRORTRACE((LOG_MOFCOMP,"Warning, unsupported SOURCETYPE pragma\n"));
    }


    if(dwType == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"namespace", m_Lexer.GetText()))
        dwType = TOK_NAMESPACE;
    if(dwType == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"deleteinstance", m_Lexer.GetText()))
        dwType = TOK_DELETEINSTANCE;
    if(dwType != TOK_NAMESPACE && dwType != TOK_INSTANCEFLAGS && dwType != TOK_CLASSFLAGS && 
        dwType != TOK_AMENDMENT && dwType != TOK_DELETECLASS && dwType != TOK_DELETEINSTANCE &&
        dwType != TOK_LOCALE && dwType != TOK_INSTANCELOCALE && dwType != TOK_NONLOCAL &&
        dwType != TOK_NONLOCALTYPE && dwType != TOK_SOURCE && dwType !=  TOK_SOURCETYPE)
    {
        m_nErrorContext = WBEMMOF_E_INVALID_PRAGMA;
        return FALSE;
    }

    m_nErrorContext = WBEMMOF_E_EXPECTED_OPEN_PAREN;
    NextToken();
    CHECK(TOK_OPEN_PAREN);


    LPWSTR wszNewNamespace;
    BOOL bRet = FALSE;
    WCHAR * pClassName;
	WCHAR *pMachine;
    BOOL bClass;
    switch(dwType)
    {
    case TOK_CLASSFLAGS:
    case TOK_INSTANCEFLAGS:
		if(!flag_list(dwType ==TOK_CLASSFLAGS))
			return FALSE;
		break;

    case TOK_AMENDMENT:
        m_nErrorContext = WBEMMOF_E_INVALID_AMENDMENT_SYNTAX;
        if(m_nToken != TOK_LPWSTR) return FALSE;

        if(m_wszAmendment)
        {
            m_nErrorContext = WBEMMOF_E_INVALID_DUPLICATE_AMENDMENT;
            return FALSE;
        }
        m_wszAmendment = Macro_CloneStr((LPWSTR)m_Lexer.GetText());
        if(m_wszAmendment == NULL && (LPWSTR)m_Lexer.GetText() != NULL)
        {
            m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
            return FALSE;
        }
        break;

    case TOK_DELETEINSTANCE:
    case TOK_DELETECLASS:
        if(TOK_DELETECLASS == dwType)
        {
            bClass = TRUE;
            m_nErrorContext = WBEMMOF_E_INVALID_DELETECLASS_SYNTAX;
        }
        else
        {
            bClass = FALSE;
            m_nErrorContext = WBEMMOF_E_INVALID_DELETEINSTANCE_SYNTAX;
        }

        m_bNotBMOFCompatible = true;
        if(m_nToken != TOK_LPWSTR) 
            return FALSE;
        pClassName = Macro_CloneStr((LPWSTR)m_Lexer.GetText());
        if(pClassName == NULL)
            return FALSE;
        if(wcslen(pClassName) >= 1)
        {
            bool bFail;
            NextToken();
            if(m_nToken == TOK_COMMA)
                if(FailOrNoFail(&bFail))
                {
                    wmilib::auto_ptr<CMoActionPragma> pObject(new CMoActionPragma(pClassName, m_pDbg, bFail, bClass));
                    if(pObject.get() == NULL)
                    {
                        m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
                        return FALSE;
                    }
                    if(pObject->IsOK() == false)
                    {
                        m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
                        return FALSE;
                    }
                    
                    HRESULT hr2 = pObject->SetNamespace(m_wszNamespace);
                    if(FAILED(hr2))
                    {
                        m_nErrorContext = hr2;
                        return FALSE;
                    }
                    pObject->SetOtherDefaults(GetClassFlags(), GetInstanceFlags());
                    m_Output.AddObject(pObject.get());
                    pObject.release();
                    bRet = TRUE;
                }
        }
      
        delete pClassName;
        if(bRet == FALSE)
            return FALSE;
        break;

    case TOK_NAMESPACE:
        m_nErrorContext = WBEMMOF_E_INVALID_NAMESPACE_SYNTAX;
        if(m_nToken != TOK_LPWSTR) return FALSE;
        wszNewNamespace = (LPWSTR)m_Lexer.GetText();
		
		pMachine = ExtractMachineName(wszNewNamespace);
		if(pMachine)
		{
			if(!bAreWeLocal(pMachine))
				m_bRemotePragmaPaths = true;
			delete [] pMachine;
		}
        if(wszNewNamespace[0] == L'\\' || wszNewNamespace[0] == L'/')
        {
            if(wszNewNamespace[1] == L'\\' || wszNewNamespace[1] == L'/')
            {
        /*
            // Cut off the server part
            // =======================

            if(memcmp(wszNewNamespace, L"\\\\.\\", 8)) 
            {
			    m_nErrorContext = WBEMMOF_E_INVALID_NAMESPACE_SPECIFICATION;
                return FALSE;
            }
            wszNewNamespace += 4;
        */
            }
            else
            {
            // Cut off the slash
            // =================

                wszNewNamespace += 1;
            }

            delete [] m_wszNamespace;
            m_wszNamespace = Macro_CloneStr(wszNewNamespace);
            if(m_wszNamespace == NULL && wszNewNamespace != NULL)
            {
                m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
                return FALSE;
            }

        }
        else
        {
            // Append to the old value
            // =======================

            LPWSTR wszFullNamespace = new WCHAR[
                wcslen(m_wszNamespace) + 2 + wcslen(wszNewNamespace)];
            if(wszFullNamespace == NULL)
                return FALSE;
            swprintf(wszFullNamespace, L"%s\\%s", m_wszNamespace, wszNewNamespace);

            delete [] m_wszNamespace;
            m_wszNamespace = wszFullNamespace;
        }
        break;

    }

    if(dwType != TOK_CLASSFLAGS && dwType != TOK_INSTANCEFLAGS)
		NextToken();

    m_nErrorContext = WBEMMOF_E_EXPECTED_CLOSE_PAREN;
    CHECK(TOK_CLOSE_PAREN);

    return TRUE;
}

//***************************************************************************
//
//  <flag_list> ::= TOK_LPWSTR <string_list_rest>;
//  <flag_list> ::= TOK_UNSIGNED_NUMERIC_CONST;
//  <flag_list> ::= <>;
//
//***************************************************************************

bool CMofParser::GetFlagValue(long & lNewValue)
{
	if(!wbem_wcsicmp(L"createonly", (LPWSTR)m_Lexer.GetText()))
		lNewValue |= WBEM_FLAG_CREATE_ONLY;
	else if(!wbem_wcsicmp(L"updateonly", (LPWSTR)m_Lexer.GetText()))
		lNewValue |= WBEM_FLAG_UPDATE_ONLY;
	else if(!wbem_wcsicmp(L"safeupdate", (LPWSTR)m_Lexer.GetText()))
		lNewValue |= WBEM_FLAG_UPDATE_SAFE_MODE;
	else if(!wbem_wcsicmp(L"forceupdate", (LPWSTR)m_Lexer.GetText()))
		lNewValue |= WBEM_FLAG_UPDATE_FORCE_MODE;
	else
		return false;
	return true;
}

bool CMofParser::flag_list(bool bClass)
{
	long lNewValue = 0;
    m_nErrorContext = WBEMMOF_E_INVALID_FLAGS_SYNTAX;

	if(m_nToken == TOK_UNSIGNED64_NUMERIC_CONST)
	{
		lNewValue = _wtol(m_Lexer.GetText());
		NextToken();
	}
	else if (m_nToken == TOK_CLOSE_PAREN)
		lNewValue = 0;
	else if (m_nToken == TOK_LPWSTR)
	{
		if(!GetFlagValue(lNewValue))
			return false;
		NextToken();
		if(!string_list(bClass, lNewValue))
			return false;
		if(!ValidFlags(bClass, lNewValue))
			return false;
	}
	else
		return false;


	if(bClass)
		m_lDefClassFlags = lNewValue;
	else
		m_lDefInstanceFlags = lNewValue;
	return true;
}

//***************************************************************************
//
//  <string_list> ::= <>;
//  <string_list> ::= TOK_COMMA TOK_LPWSTR <string_list>;
//
//***************************************************************************

bool CMofParser::string_list(bool bClass, long & lNewValue)
{
	if (m_nToken == TOK_COMMA)
	{
		NextToken();
		if (m_nToken != TOK_LPWSTR)
			return false;
		if(!GetFlagValue(lNewValue))
			return false;

		NextToken();
		return string_list(bClass, lNewValue);
	}

	return true;
}

//***************************************************************************
//
//  <top_level_decl> ::= <qualifier_decl> <decl_type>
//
//  Note: <decl_type> is implicit in the switch() statement.
//
//***************************************************************************
// 1.10

BOOL CMofParser::top_level_decl()
{
    CMoQualifierArray* paQualifiers = new CMoQualifierArray(m_pDbg);
	ParseState QualPosition;
	GetParserPosition(&QualPosition);
    if (paQualifiers == NULL || !qualifier_decl(*paQualifiers, true, CLASSINST_SCOPE))
    {
        if(paQualifiers)
            delete paQualifiers;
        return FALSE;
    }
    // Branch to the correct top-level declaration.
    // =============================================

    switch (m_nToken) {
        case TOK_CLASS:
        {
            if(m_bDoScopeCheck && (FALSE == CheckScopes(IN_CLASS, paQualifiers, NULL)))
                return FALSE;

            if(!class_decl(paQualifiers, NULL, &QualPosition))
                return FALSE;

            m_nErrorContext = WBEMMOF_E_EXPECTED_SEMI;
			if(m_nToken != TOK_SEMI)
				return FALSE;
			NextToken();

            return TRUE;
        }

        case TOK_INSTANCE:
        {
            if(m_bDoScopeCheck && (FALSE == CheckScopes(IN_INSTANCE, paQualifiers, NULL)))
                return FALSE;

            if(!instance_decl(paQualifiers, NULL, &QualPosition))
                return FALSE;

            m_nErrorContext = WBEMMOF_E_EXPECTED_SEMI;
			if(m_nToken != TOK_SEMI)
				return FALSE;
			NextToken();
            return TRUE;
        }
        case TOK_TYPEDEF:
            return typedef_(paQualifiers);
        default:
            m_nErrorContext = WBEMMOF_E_UNRECOGNIZED_TOKEN;
        // Syntax error
    }

    return FALSE;
}

//***************************************************************************
//
//  <typedef> ::=  see BNF. Not supported.
//
//***************************************************************************

BOOL CMofParser::typedef_(ACQUIRE CMoQualifierArray* paQualifiers)
{
    m_nErrorContext = WBEMMOF_E_TYPEDEF_NOT_SUPPORTED;

    Trace(true, m_pDbg, NO_TYPEDEFS);
    return FALSE;
}

//***************************************************************************
//
//  <class_decl> ::=
//      TOK_CLASS
//      TOK_SIMPLE_IDENT
//      <class_def>
//
//  Adds the resulting class to the member CMofData
//
//***************************************************************************
// v1.10

BOOL CMofParser::class_decl(ACQUIRE CMoQualifierArray* paQualifiers, VARIANT * pValue, ParseState * pQualPosition)
{
    BSTR strClassName;

    // Begin syntax check.
    // ===================

    m_nErrorContext = WBEMMOF_E_INVALID_CLASS_DECLARATION;
    int nFirstLine = m_Lexer.GetLineNumber();

    if (m_nToken != TOK_CLASS)
    {
        delete paQualifiers;
        return FALSE;
    }
    NextToken();

    // Get the class name.
    // ====================

    if (m_nToken != TOK_SIMPLE_IDENT)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_CLASS_NAME;
        delete paQualifiers;
        return FALSE;
    }

    strClassName = SysAllocString((LPWSTR)m_Lexer.GetText());
    if(strClassName == NULL)
    {
        m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
        return FALSE;
    }

    // This finishes up and does the necessary freeing

    return class_def(paQualifiers, strClassName, nFirstLine, pQualPosition, pValue);
    
}


//***************************************************************************
//
//  <class_def> ::=;
//  <class_def> ::=
//      <as_alias>
//      <opt_parent_class>
//      TOK_OPEN_BRACE
//      <property_decl_list>
//      TOK_CLOSE_BRACE;
//
//  Adds the resulting class to the member CMofData
//
//***************************************************************************
// v1.10

BOOL CMofParser::class_def(ACQUIRE CMoQualifierArray* paQualifiers, 
                           BSTR strClassName, int nFirstLine, ParseState * pQualPosition,
						   VARIANT * pVar)
{
    BOOL bRetVal = FALSE;       // Default
    BSTR strParentName = NULL;
    LPWSTR wszAlias = NULL;

    // Begin syntax check.
    // ===================

    NextToken();

    // Check for the case where its just a semi.  That would be the case
    // where the entire line was [qual] class myclass;

    if(m_nToken == TOK_SEMI)
    {
        CMoClass* pObject = new CMoClass(strParentName, strClassName, m_pDbg, TRUE);
        if(pObject == NULL)
            return FALSE;
        if(pObject->IsOK() == false)
        {
            m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
            delete pObject;
            return FALSE;
        }
        HRESULT hr2 = pObject->SetNamespace(m_wszNamespace);
        if(FAILED(hr2))
        {
            m_nErrorContext = hr2;
            delete pObject;
            return FALSE;
        }
        
        pObject->SetOtherDefaults(GetClassFlags(), GetInstanceFlags());

        SysFreeString(strClassName);

        // Apply qualifiers (already parsed)
        // =================================

        pObject->SetQualifiers(paQualifiers);

        m_Output.AddObject(pObject);
        return TRUE;
    }
    
    // Get the alias (if any)
    // ======================

    if(!as_alias(wszAlias))
    {
        delete paQualifiers;
        SysFreeString(strClassName);
        return FALSE;
    }


    // Get the parent type name, if there is one.
    // ===========================================
                                    
    if (!opt_parent_class(&strParentName))
    {
        SysFreeString(strClassName);
        delete paQualifiers;
        return FALSE;
    }

    // Check for the open brace.
    // =========================

    if (m_nToken != TOK_OPEN_BRACE)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_OPEN_BRACE;

        SysFreeString(strClassName);
        SysFreeString(strParentName);
        delete paQualifiers;
        return FALSE;
    }


    // Create new object
    // =================

    CMoClass* pObject = new CMoClass(strParentName, strClassName, m_pDbg);
    if(pObject == NULL)
        return FALSE;
    if(pObject->IsOK() == false)
    {
        delete pObject;
        return FALSE;
    }

    GetParserPosition(pObject->GetDataState());
	if(pQualPosition)
		pObject->SetQualState(pQualPosition);
    NextToken();
    HRESULT hr2 = pObject->SetNamespace(m_wszNamespace);
    if(FAILED(hr2))
    {
        m_nErrorContext = hr2;
        return FALSE;
    }
    
    pObject->SetOtherDefaults(GetClassFlags(), GetInstanceFlags());

    SysFreeString(strClassName);
    SysFreeString(strParentName);

    // Apply qualifiers (already parsed)
    // =================================

    pObject->SetQualifiers(paQualifiers);

    // Set alias
    // =========

    if(wszAlias != NULL)
    {
        HRESULT hr2 = pObject->SetAlias(wszAlias);
        delete [] wszAlias;
        if(FAILED(hr2))
        {
            m_nErrorContext = hr2;
            goto Exit;
        }
    }

    // Now get the list properties.
    // ============================


    if (!property_decl_list(pObject))
        goto Exit;

    // Final close brace and semicolon.
    // ================================
    m_nErrorContext = WBEMMOF_E_EXPECTED_BRACE_OR_BAD_TYPE;

    if (m_nToken != TOK_CLOSE_BRACE)
        goto Exit;

    hr2 = pObject->SetLineRange(nFirstLine, m_Lexer.GetLineNumber(), m_Lexer.GetErrorFile());
    if(FAILED(hr2))
    {
        m_nErrorContext = hr2;
        goto Exit;
    }
    NextToken();

    // We have now syntactially recognized a class
    // but done no context-sensitive verification.  This is
    // deferred to whatever module is using the parser output.
    // =======================================================

    if(pVar)
	{
		pVar->vt = VT_EMBEDDED_OBJECT;
        pVar->punkVal = (IUnknown *)pObject;
	}
    else
    {
        pObject->Deflate(false);
        m_Output.AddObject(pObject);
    }
    return TRUE;

Exit:
    delete pObject;
    return FALSE;
}

//***************************************************************************
//
//  <sys_or_regular> ::= TOK_SIMPLE_IDENT;
//  <sys_or_regular> ::= TOK_SYSTEM_IDENT;
//
//***************************************************************************

bool CMofParser::sys_or_regular()
{
    if(m_nToken == TOK_SIMPLE_IDENT || m_nToken == TOK_SYSTEM_IDENT)
        return true;
    else
        return false;
}

//***************************************************************************
//
//  <opt_parent_class> ::= TOK_COLON <SYS_OR_REGULAR>;
//  <opt_parent_class> ::= <>;
//
//***************************************************************************
// v1.10

BOOL CMofParser::opt_parent_class(OUT BSTR* pstrParentName)
{
    // If a colon is present, there is a parent type.
    // ==============================================

    if (m_nToken == TOK_COLON)
    {
        NextToken();

        // Get the parent type identifier.
        // ===============================
        
        if (!sys_or_regular())
        {
            m_nErrorContext = WBEMMOF_E_EXPECTED_CLASS_NAME;
            return FALSE;
        }

        *pstrParentName = SysAllocString((LPWSTR)m_Lexer.GetText());
        if(*pstrParentName == NULL)
        {
            m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
            return FALSE;
        }
        NextToken();
    }
    else *pstrParentName = NULL;

    return TRUE;
}

//***************************************************************************
//
//  <property_decl_list> ::= <PropOrMeth_decl> <property_decl_list>;
//  <property_decl_list> ::= <>;
//
//  Adds the properties to the CMObject passed.
//
//***************************************************************************
// v1.10

BOOL CMofParser::property_decl_list(MODIFY CMObject* pObject)
{
    // Begin parsing.
    // ==============

    while (m_nToken == TOK_SIMPLE_IDENT || m_nToken == TOK_OPEN_BRACKET || 
        m_nToken == TOK_VOID || m_nToken == TOK_SYSTEM_IDENT)
    {
        CMoProperty* pProp = NULL;

        if (!PropOrMeth_decl(&pProp))
        {
            delete pProp;
            return FALSE;
        }

        if(!pObject->AddProperty(pProp))
        {
            // Duplicate property
            // ==================

            m_nErrorContext = WBEMMOF_E_DUPLICATE_PROPERTY;
            return FALSE;
        }
    }
                       
    return TRUE;
}

//***************************************************************************
//
//  <PropOrMeth_decl> ::=                           
//      <qualifier_decl>
//      <PropOrMeth_decl2>;
//
//  Stores itself in the passed CMoProperty object (unintialized)
//
//***************************************************************************
// v1.10

BOOL CMofParser::PropOrMeth_decl(OUT CMoProperty ** ppProp)
{
    

    // Get the qualifiers
    // ==================

    CMoQualifierArray* paQualifiers = new CMoQualifierArray(m_pDbg);
    if (paQualifiers == NULL || !qualifier_decl(*paQualifiers, false, PROPMETH_SCOPE))
        return FALSE;

    

    // Read the rest of the property information
    // =========================================

    if (!PropOrMeth_decl2(ppProp, paQualifiers))
        return FALSE;

    SCOPE_CHECK scheck = IN_METHOD;
    if((*ppProp)->IsValueProperty())
        scheck = IN_PROPERTY;
    if(m_bDoScopeCheck && (FALSE == CheckScopes(scheck, paQualifiers, *ppProp)))
        return FALSE;
    
    return TRUE;
}

//***************************************************************************
//
//  <PropOrMeth_decl2> ::= <TypeAndName> <finish_PropOrMeth>;
//  <PropOrMeth_decl2> ::= TOK_VOID TOK_SIMPLE_IDENT <finish_meth>;
//
//  Modifies the CMoProperty object passed in (the qualifiers are already
//  set by this time).
//
//***************************************************************************
//  v1.10

BOOL CMofParser::PropOrMeth_decl2(MODIFY CMoProperty ** ppProp, CMoQualifierArray* paQualifiers)
{
    if(m_nToken != TOK_VOID)
    {
        CMoType Type(m_pDbg);
        WString sName;
        BOOL bRet = TypeAndName(Type, sName);
        if(bRet)
            bRet = finish_PropOrMeth(Type, sName, ppProp, paQualifiers);
        return bRet;
    }
    else
    {
        CMoType Type(m_pDbg);
        WString sName;
        
        HRESULT hr2 = Type.SetTitle(L"NULL");
        if(FAILED(hr2))
        {
            m_nErrorContext = hr2;
            return FALSE;
        }
        

        // Now get the property name.
        // ==========================

        NextToken();
        if (m_nToken != TOK_SIMPLE_IDENT)
        {
            m_nErrorContext = WBEMMOF_E_EXPECTED_PROPERTY_NAME;
            return FALSE;
        }

        sName = m_Lexer.GetText();
        NextToken();
        return finish_meth(Type, sName, ppProp, paQualifiers);
    }
}

//***************************************************************************
//
//  <finish_PropOrMeth> ::= <finish_prop>;
//  <finish_PropOrMeth> ::= <finish_meth>;
// 
//  examines the string, gets the name and determines if it is a property or
//  method and then calls the appropriate routine to finish.
//
//***************************************************************************

BOOL CMofParser::finish_PropOrMeth(CMoType & Type, WString & sName,MODIFY CMoProperty ** ppProp, 
                                   CMoQualifierArray* paQualifiers)
{
    if(m_nToken == TOK_OPEN_PAREN)
        return finish_meth(Type, sName, ppProp, paQualifiers);
    else
        return finish_prop(Type, sName, ppProp, paQualifiers);
}

//***************************************************************************
//
//  <finish_prop> ::=     <opt_array> <default_value> TOK_SEMI
//
//***************************************************************************

BOOL CMofParser::finish_prop(CMoType & Type, WString & sName, CMoProperty ** ppProp,
                             CMoQualifierArray * paQualifiers)
{

    unsigned uSuggestedSize = 0xffffffff;

    *ppProp = new CValueProperty(paQualifiers, m_pDbg);
    if(*ppProp == NULL)
        return FALSE;

    if(FAILED((*ppProp)->SetPropName((wchar_t *) sName)))
        return FALSE;
    if(FAILED((*ppProp)->SetTypeTitle(Type.GetTitle())))
        return FALSE;

    // Check to see if this is an array type.
    // ======================================

    if (!opt_array(Type, paQualifiers))
        return FALSE;

    // Type parsing complete. Check it
    // ===============================

    VARTYPE vtType = Type.GetCIMType();
    if(vtType == VT_ERROR)
    {
        m_nErrorContext = WBEMMOF_E_UNRECOGNIZED_TYPE;
        return FALSE;
    }

    
    // Get the default value and assign it to the property.
    // ====================================================

    if (!default_value(Type, (*ppProp)->AccessValue()))
        return FALSE;

    // If Type resulted in extra qualifiers (CIMTYPE), add them to the prop
    // ===================================================================

    CMoValue & Val = (*ppProp)->AccessValue();
    Val.SetType(vtType);
    Type.StoreIntoQualifiers(paQualifiers);

    // Check closing semicolon.
    // ========================

    if (m_nToken != TOK_SEMI)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_SEMI;
        return FALSE;
    }

    NextToken();

    return TRUE;
}

//***************************************************************************
//
//  <finish_meth> ::=  TOK_OPEN_PAREN <arg_list> TOK_CLOSE_PAREN TOK_SEMI
//
//***************************************************************************

BOOL CMofParser::finish_meth(CMoType & Type, WString & sName, CMoProperty ** ppProp,
                             CMoQualifierArray * paQualifiers)
{

    CMethodProperty * pMeth = new CMethodProperty(paQualifiers, m_pDbg, FALSE); 
    if(pMeth == NULL)
        return FALSE;
    *ppProp = pMeth;

    if(FAILED(pMeth->SetPropName((wchar_t *) sName)))
        return FALSE;
    if(FAILED(pMeth->SetTypeTitle(Type.GetTitle())))
        return FALSE;

    // Check to see if this is an array type.
    // ======================================

    if (!arg_list(pMeth))
        return FALSE;

    // If Type resulted in extra qualifiers (CIMTYPE), add them to the prop
    // ===================================================================

//    Type.StoreIntoQualifiers((*ppProp)->GetQualifiers());

    if (m_nToken != TOK_CLOSE_PAREN)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_CLOSE_PAREN;
        return FALSE;
    }

    if(Type.IsArray())
    {
        m_nErrorContext = WBEMMOF_E_NO_ARRAYS_RETURNED;
        return FALSE;
    }
    WString sTemp = L"ReturnValue";
    CMoValue Value(m_pDbg);
    if(wbem_wcsicmp(L"NULL",Type.GetTitle()))
        if(!pMeth->AddToArgObjects(NULL, sTemp, Type, TRUE, m_nErrorContext, NULL, Value))
            return FALSE;

    NextToken();

    // Check closing semicolon.
    // ========================

    if (m_nToken != TOK_SEMI)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_SEMI;
        return FALSE;
    }

    NextToken();

    return TRUE;
}

//***************************************************************************
//
//  <arg_list> ::= <arg_decl> <rest_of_args>;
//  <arg_list> ::= <>;
//
//***************************************************************************

BOOL CMofParser::arg_list(CMethodProperty * pMethProp)
{
    NextToken();
    if (m_nToken == TOK_CLOSE_PAREN)
    {
        return TRUE;
    }

    BOOL bRet = arg_decl(pMethProp);
    if(!bRet)
        return FALSE;
    else
        return rest_of_args(pMethProp);
}

//***************************************************************************
//
// <arg_decl> ::= <qualifier_decl><TypeAndName><opt_array>;
//
//***************************************************************************
BOOL CMofParser::arg_decl(CMethodProperty * pMethProp)
{

    CMoQualifierArray * paQualifiers = new CMoQualifierArray(m_pDbg);
    if(paQualifiers == NULL || !qualifier_decl(*paQualifiers,false, PROPMETH_SCOPE))
        return FALSE;
    CValueProperty * pArg =  new CValueProperty(paQualifiers, m_pDbg);
    if(pArg == NULL)
        return FALSE;
    CMoType Type(m_pDbg);
    WString sName;
    if(!TypeAndName(Type, sName))
        return FALSE;

    if(FAILED(pArg->SetPropName(sName)))
        return FALSE;

    if(FAILED(pArg->SetTypeTitle(Type.GetTitle())))
        return FALSE;

    if(!opt_array(Type, paQualifiers))
        return FALSE;

    VARIANT * pVar = pArg->GetpVar();
    if(!default_value(Type, pArg->AccessValue()))
        return FALSE;

    if(m_bDoScopeCheck && (FALSE == CheckScopes(IN_PARAM, paQualifiers, pArg)))
        return FALSE;
    
    m_nErrorContext = WBEM_E_INVALID_PARAMETER;
    if(!pMethProp->AddToArgObjects(paQualifiers, sName, Type, FALSE,  m_nErrorContext, pVar,
        pArg->AccessValue()))
        return FALSE;
    
    // Type parsing complete. Check it
    // ===============================

    if(Type.GetCIMType() == VT_ERROR)
    {
        m_nErrorContext = WBEMMOF_E_UNRECOGNIZED_TYPE;
        return FALSE;
    }


    // If Type resulted in extra qualifiers (CIMTYPE), add them to the prop
    // ===================================================================

    Type.StoreIntoQualifiers(paQualifiers);

    pMethProp->AddArg(pArg);
    return TRUE;

}

//***************************************************************************
//
//  <rest_of_args> ::= TOK_COMMA <arg_decl> <rest_of_args>;
//  <rest_of_args> ::= <>;
//
//***************************************************************************

BOOL CMofParser::rest_of_args(CMethodProperty * pMethProp)
{
    if(m_nToken == TOK_COMMA)
    {
        NextToken();
        BOOL bRet = arg_decl(pMethProp);
        if(!bRet)
            return FALSE;
        return rest_of_args(pMethProp);
    }
    return TRUE;
}

//***************************************************************************
//
//  <TypeAndName> ::= <type> <opt_ref> TOK_SIMPLE_IDENT;
//
//***************************************************************************

BOOL CMofParser::TypeAndName(MODIFY CMoType& Type, WString &sName)
{
    if (!type(Type))
    {
        return FALSE;
    }

    // Check if it is actually a reference to a type
    // =============================================

    if (!opt_ref(Type))
        return FALSE;

    // Now get the property name.
    // ==========================

    if (m_nToken != TOK_SIMPLE_IDENT)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_PROPERTY_NAME;
        return FALSE;
    }

    sName = m_Lexer.GetText(); 
    NextToken();
    return TRUE;
}

//***************************************************************************
//
//  <opt_ref> ::= TOK_REF;
//  <opt_ref> ::= <>;
//
//  Modifies the type object to reflect that this is a ref.
//
//***************************************************************************
// v1.10

BOOL CMofParser::opt_ref(MODIFY CMoType& Type)
{
    if (m_nToken == TOK_REF)
    {
        Type.SetIsRef(TRUE);
        Type.SetIsEmbedding(FALSE);
        NextToken();
    }
    else if(Type.GetCIMType() == VT_ERROR)		// Probably a class name
    {
        if(Type.IsUnsupportedType())
        {
    	    m_nErrorContext = WBEMMOF_E_UNSUPPORTED_CIMV22_DATA_TYPE;
            return false;
        }
        Type.SetIsEmbedding(TRUE);
        Type.SetIsRef(FALSE);
    }
    else
    {
        Type.SetIsRef(FALSE);
        Type.SetIsEmbedding(FALSE);
    }
        
    return TRUE;
}

//***************************************************************************
//
//  <opt_array> ::= TOK_OPEN_BRACKET <opt_array_detail>;
//  <opt_array> ::= <>;
//
//
//***************************************************************************
// v1.10

BOOL CMofParser::opt_array(MODIFY CMoType& Type, CMoQualifierArray * paQualifiers)
{

    if (m_nToken == TOK_OPEN_BRACKET)
    {
        return opt_array_detail(Type, paQualifiers);
    }
    else Type.SetIsArray(FALSE);

    return TRUE;
}

//***************************************************************************
//
//  <opt_array_detail> ::= TOK_UNSIGNED64_NUMERIC_CONST TOK_CLOSE_BRACKET;
//  <opt_array_detail> ::= TOK_CLOSE_BRACKET;
//
//***************************************************************************

BOOL CMofParser::opt_array_detail(MODIFY CMoType& Type, CMoQualifierArray * paQualifiers)
{

    Type.SetIsArray(TRUE);

    // check if next token is a unsigned constant

    NextToken();
    if(m_nToken == TOK_UNSIGNED64_NUMERIC_CONST)
    {
        unsigned uSuggestedSize = _wtoi(m_Lexer.GetText());

        // If a max suggested size is set, then add a qualifier named max()
        // ================================================================
    
        CMoQualifier* pNewQualifier = new CMoQualifier(m_pDbg);
        if(pNewQualifier == NULL)
            return FALSE;
        if(FAILED(pNewQualifier->SetQualName(L"MAX")))
            return FALSE;
        VARIANT * pvar = pNewQualifier->GetpVar();
        pvar->vt = VT_I4;
        pvar->lVal = (int)uSuggestedSize;
        if(!paQualifiers->Add(pNewQualifier))
        {
            // Duplicate qualifier
            // ===================

            m_nErrorContext = WBEMMOF_E_DUPLICATE_QUALIFIER;
            return FALSE;
        }

        NextToken();
    }
        
    m_nErrorContext = WBEMMOF_E_EXPECTED_CLOSE_BRACKET;
    CHECK(TOK_CLOSE_BRACKET);
	return TRUE;
}


//***************************************************************************
//
//  <default_value> ::= <>;
//  <default_value> ::= TOK_EQUALS <initializer>;
//
//  This function only applies to class declarations.
//
//***************************************************************************
// v1.10

BOOL CMofParser::default_value(READ_ONLY CMoType& Type,
                               OUT CMoValue& Value)
{
    if (m_nToken == TOK_EQUALS) {
        NextToken();

        // Get the value
        // =============

        return initializer(Type, Value);
    }
    else {

        Value.SetType(Type.GetCIMType());
        VariantClear(&Value.AccessVariant());
        V_VT(&Value.AccessVariant()) = VT_NULL;

        /*
        // HACK!!!! Clear the VARIANT's data field
        // =======================================

        memset(&Value.AccessVariant(), 0, sizeof(VARIANT));

        // No initializer. Set type to whatever we can discern from Type
        // =============================================================

        V_VT(&Value.AccessVariant()) = Type.GetVarType();
        if(V_VT(&Value.AccessVariant()) == VT_BSTR)
        {
            // NULL strings are not well-supported
            // ===================================

            V_BSTR(&Value.AccessVariant()) = SysAllocString(L"");
        }
        */
    }

    return TRUE;
}


//***************************************************************************
//
//  Qualifier parsing
//
//***************************************************************************

//***************************************************************************
//
//  <qualifier_decl>   ::= TOK_OPEN_BRACKET <qualifier_list> TOK_CLOSE_BRACKET;
//  <qualifier_decl>   ::= <>;
//
//
//***************************************************************************
// v1.10
BOOL CMofParser::qualifier_decl(OUT CMoQualifierArray& aQualifiers, bool bTopLevel, QUALSCOPE qs)
{
    if (m_nToken == TOK_OPEN_BRACKET) {
        NextToken();

        if (!qualifier_list(aQualifiers, bTopLevel, qs)) {
            return FALSE;
        }

        // Check closing bracket.
        // ======================

        if (m_nToken != TOK_CLOSE_BRACKET) {
            m_nErrorContext = WBEMMOF_E_EXPECTED_CLOSE_BRACKET;
            return FALSE;
        }
        NextToken();
    }

    return TRUE;
}

//***************************************************************************
//
//  <qualifier_list>   ::= <qualifier><qualifier_list_rest>;
//
//***************************************************************************
// v1.10
BOOL CMofParser::qualifier_list(OUT CMoQualifierArray& aQualifiers, bool bTopLevel, QUALSCOPE qs)
{
    CMoQualifier* pNewQualifier = new CMoQualifier(m_pDbg);
    if(pNewQualifier == NULL)
        return FALSE;

    if (!qualifier(*pNewQualifier, bTopLevel, qs))
    {
        delete pNewQualifier;
        return FALSE;
    }

    // if the qualifier is null, then just ignore it

    VARIANT * pVar = pNewQualifier->GetpVar();
    if(pVar->vt == VT_NULL)
    {
        delete pNewQualifier;
        return qualifier_list_rest(aQualifiers, bTopLevel, qs);
    }

    // Stuff the qualifier into the array
    // ==================================

    if(!aQualifiers.Add(pNewQualifier))
    {
        // Duplicate qualifier
        // ===================

        m_nErrorContext = WBEMMOF_E_DUPLICATE_QUALIFIER;
        return FALSE;
    }

    return qualifier_list_rest(aQualifiers, bTopLevel, qs);
}

//***************************************************************************
//
//  <qualifier_list_rest> ::= TOK_COMMA <qualifier><qualifier_list_rest>;
//  <qualifier_list_rest> ::= <>;
//
//***************************************************************************
// v1.10
BOOL CMofParser::qualifier_list_rest(MODIFY CMoQualifierArray& aQualifiers, bool bTopLevel, QUALSCOPE qs)
{
    while (m_nToken == TOK_COMMA)
    {
        NextToken();

        CMoQualifier* pQualifier = new CMoQualifier(m_pDbg);
        if(pQualifier == NULL)
            return FALSE;

        if (!qualifier(*pQualifier, bTopLevel, qs))
        {
            delete pQualifier;
            return FALSE;
        }

        // if the qualifier is null, then just ignore it

        VARIANT * pVar = pQualifier->GetpVar();
        if(pVar->vt == VT_NULL)
        {
            delete pQualifier;
        }
        else if(!aQualifiers.Add(pQualifier))
        {
            // Duplicate qualifier
            // ===================

            m_nErrorContext = WBEMMOF_E_DUPLICATE_QUALIFIER;
            return FALSE;
        }
    }

    return TRUE;
}

//***************************************************************************
//
//  <qualifier>        ::= TOK_SIMPLE_IDENT <qualifier_parms>;
//
//***************************************************************************
// v1.10

BOOL CMofParser::qualifier(OUT CMoQualifier& Qualifier, bool bTopLevel, QUALSCOPE qs)
{
    m_nErrorContext = WBEMMOF_E_EXPECTED_QUALIFIER_NAME;

    if (m_nToken != TOK_SIMPLE_IDENT && m_nToken != TOK_AMENDMENT)
        return FALSE;

    // Check that this qualifier is not illegal in a MOF
    // =================================================

    if(!wbem_wcsicmp(m_Lexer.GetText(), L"CIMTYPE"))
    {
        m_nErrorContext = WBEMMOF_E_CIMTYPE_QUALIFIER;
        return FALSE;
    }

    if(FAILED(Qualifier.SetQualName(m_Lexer.GetText())))
    {
        m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
        return FALSE;
    }

    NextToken();

    if (!qualifier_parm(Qualifier, bTopLevel, qs))
    {
        return FALSE;
    }

    return TRUE;
}

//***************************************************************************
//
//  <qualifier_parm>  ::= <flavor_param>;
//  <qualifier_parm>  ::= TOK_OPEN_PAREN <qualifier_initializer_list> TOK_CLOSE_PAREN <flavor_param>;
//
//***************************************************************************
// v1.10

BOOL CMofParser::qualifier_parm(OUT CMoQualifier& Qualifier, bool bTopLevel, QUALSCOPE qs)
{

    HRESULT hr;
	CMoValue & Value = Qualifier.AccessValue();

    if (m_nToken == TOK_OPEN_PAREN)
    {
        NextToken();

        // Read the parameter. 
        // ====================
        
        CMoType Type(m_pDbg);
        if (!simple_initializer(Type, Value, true))
            return FALSE;

       m_nErrorContext = WBEMMOF_E_EXPECTED_CLOSE_PAREN;
        CHECK(TOK_CLOSE_PAREN);
    }
    else if (m_nToken == TOK_OPEN_BRACE)
    {
        NextToken();

        // Read the parameters. 
        // ====================

        if (!qualifier_initializer_list(Value))
            return FALSE;

        m_nErrorContext = WBEMMOF_E_EXPECTED_CLOSE_BRACE;
        CHECK(TOK_CLOSE_BRACE);
    }
    else
    {
        // Boolean qualifier: set to TRUE
        // ==============================

        V_VT(&Value.AccessVariant()) = VT_BOOL;
        V_BOOL(&Value.AccessVariant()) = VARIANT_TRUE;
        Qualifier.SetUsingDefaultValue(true);
    }

    // Get the default flavor for this qualifier
    // =========================================

    hr = m_Output.SetDefaultFlavor(Qualifier, bTopLevel, qs, m_State);
    if(FAILED(hr))
        return FALSE;
    return flavor_param(Qualifier, false);
}

//****************************************************************************
//
//  qualifier_initializer_list ::= initializer_list
//
//  Their syntax is the same, but the storage model is different.
//
//***************************************************************************

BOOL CMofParser::qualifier_initializer_list(OUT CMoValue& Value)
{

    // We don't know the type, so create an initialized one
    // ====================================================

    CMoType Type(m_pDbg);
    if(!initializer_list(Type, Value, true))
        return FALSE;

    return TRUE;
}


//***************************************************************************
//
// Basic low-level productions for types, idents, etc.

//***************************************************************************
//
//  <type> ::= TOK_SIMPLE_IDENT;
//
//***************************************************************************
// v1.10

BOOL CMofParser::type(OUT CMoType& Type)
{
    m_nErrorContext = WBEMMOF_E_EXPECTED_TYPE_IDENTIFIER;

    if (!sys_or_regular())
        return FALSE;

    HRESULT hr = Type.SetTitle(m_Lexer.GetText());
    if(FAILED(hr))
    {
        m_nErrorContext = hr;
        return FALSE;
    }

    NextToken();
    return TRUE;
}


//***************************************************************************
//
//  <const_value> ::= TOK_LPSTR;
//  <const_value> ::= TOK_LPWSTR;
//  <const_value> ::= TOK_SIGNED64_NUMERIC_CONST;
//  <const_value> ::= TOK_UNSIGNED64_NUMERIC_CONST;
//  <const_value> ::= TOK_UUID;
//  <const_value> ::= TOK_KEYWORD_NULL;
//
//***************************************************************************
// 1.10



BOOL CMofParser::const_value(MODIFY CMoType& Type, OUT VARIANT& varValue, bool bQualifier)
{
    varValue.lVal = 0;
    VARIANT var;
    SCODE sc;
    m_nErrorContext = WBEMMOF_E_TYPE_MISMATCH;
    __int64 iTemp;
    switch (m_nToken)
    {
	case TOK_PLUS:
	  // Just ignore '+'
	  NextToken();
	  if (m_nToken != TOK_SIGNED64_NUMERIC_CONST &&
	      m_nToken != TOK_UNSIGNED64_NUMERIC_CONST)
	      return FALSE;

        case TOK_SIGNED64_NUMERIC_CONST:
        case TOK_UNSIGNED64_NUMERIC_CONST:
           WCHAR wcTemp[30];
		    iTemp = m_Lexer.GetLastInt();
            if(m_nToken == TOK_SIGNED64_NUMERIC_CONST)
                swprintf(wcTemp,L"%I64d", m_Lexer.GetLastInt());
            else
                swprintf(wcTemp,L"%I64u", m_Lexer.GetLastInt());
            var.vt = VT_BSTR;
            var.bstrVal =  SysAllocString(wcTemp);
            if(var.bstrVal == NULL)
            {
                m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
                return FALSE;
            }
            sc = WbemVariantChangeType(&varValue, &var, VT_I4);
            VariantClear(&var);
            if(sc != S_OK)
            {
                varValue.vt = VT_BSTR; 
                varValue.bstrVal = SysAllocString(wcTemp);
                if(varValue.bstrVal == NULL)
                {
                    m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
                    return FALSE;
                }
                sc = S_OK;
            }
            break;

        case TOK_KEYWORD_NULL:
            V_VT(&varValue) = VT_NULL;
//            if(bQualifier)
//            {
//                m_nErrorContext = WBEMMOF_E_UNSUPPORTED_CIMV22_QUAL_VALUE;
//                return FALSE;
//            }
            break;

        case TOK_FLOAT_VALUE:
//            if(bQualifier)
//            {
                var.vt = VT_BSTR;
                var.bstrVal =  SysAllocString(m_Lexer.GetText());
                if(var.bstrVal == NULL)
                {
                    m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
                    return FALSE;
                }
                sc = VariantChangeTypeEx(&varValue, &var, 0x409, 0, VT_R8);
                VariantClear(&var);
                if(sc != S_OK)
                    return FALSE;
                break;
 //           }           //intentional lack of a break!!!!
        case TOK_LPWSTR:
        case TOK_UUID:
            V_VT(&varValue) = VT_BSTR; 
            V_BSTR(&varValue) = SysAllocString(m_Lexer.GetText());
            if(varValue.bstrVal == NULL)
            {
                m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
                return FALSE;
            }
            break;

        case TOK_WCHAR:
            varValue.vt = VT_I2;
            varValue.iVal = (short)m_Lexer.GetLastInt();
            if(bQualifier)
            {
                m_nErrorContext = WBEMMOF_E_UNSUPPORTED_CIMV22_QUAL_VALUE;
                return FALSE;
            }
            break;

        case TOK_TRUE:
            V_VT(&varValue) = VT_BOOL;
            V_BOOL(&varValue) = VARIANT_TRUE;
            break;
        case TOK_FALSE:
            V_VT(&varValue) = VT_BOOL;
            V_BOOL(&varValue) = VARIANT_FALSE;
            break;

        default:
            m_nErrorContext = WBEMMOF_E_ILLEGAL_CONSTANT_VALUE;
            return FALSE;
    }

    NextToken();
    return TRUE;
}


//***************************************************************************
//
//  <initializer> ::= <simple_initializer>;
//  <initializer> ::= TOK_EXTERNAL;
//  <initializer> ::= TOK_OPEN_BRACE <initializer_list> TOK_CLOSE_BRACE;
//
//***************************************************************************
//  v1.10

BOOL CMofParser::initializer(MODIFY CMoType& Type, OUT CMoValue& Value)
{
    // A complex initializer list.
    // ===========================

    if (m_nToken == TOK_OPEN_BRACE)
    {
        NextToken();
        if(!initializer_list(Type, Value, false))
        {
            return FALSE;
        }

        m_nErrorContext = WBEMMOF_E_EXPECTED_CLOSE_BRACE;
        CHECK(TOK_CLOSE_BRACE);
    }

    // If the syntax says "prop = external" for MO Provided types...
    // =============================================================

    else if (m_nToken == TOK_EXTERNAL || m_nToken == TOK_KEYWORD_NULL)
    {
        Value.SetType(Type.GetCIMType());
        V_VT(&Value.AccessVariant()) = VT_NULL;
        NextToken();
        return TRUE;
    }

    else if (!simple_initializer(Type, Value, false))
    {
        return FALSE;
    }

    return TRUE;
}

//***************************************************************************
//
//  <simple_initializer> ::= <const_value>;
//  <simple_initializer> ::= <alias>;
//  <simple_initializer> ::= <instance_decl>;
//
//  Semantic stack actions:
//      On TRUE returns an MCST_CONST_VALUE token, an MCST_ALIAS, or
//      an MCST_KEYREF token, depending on which branch is taken.
//
//***************************************************************************
// v1.10

BOOL CMofParser::simple_initializer(MODIFY CMoType& Type, 
                                    OUT CMoValue& Value, bool bQualifier)
{
    if (m_nToken == TOK_DOLLAR_SIGN)
    {
        // It's an alias. Check the type
        // =============================

        if(Type.IsDefined())
        {
            if(!Type.IsRef()) 
            {
                m_nErrorContext = WBEMMOF_E_UNEXPECTED_ALIAS;
                return FALSE;
            }
        }
        else
        {
            // Type unknown at start-up. Set to object ref now
            // ===============================================

            HRESULT hr = Type.SetTitle(L"object");
            if(FAILED(hr))
            {
                m_nErrorContext = hr;
                return FALSE;
            }
            Type.SetIsRef(TRUE);
        }

        NextToken(true);
        m_nErrorContext = WBEMMOF_E_EXPECTED_ALIAS_NAME;
        if (m_nToken != TOK_SIMPLE_IDENT)
            return FALSE;

		AddAliasReplaceValue(Value, m_Lexer.GetText());

    	NextToken();
        return TRUE;
    }
    if (m_nToken == TOK_INSTANCE || m_nToken == TOK_OPEN_BRACKET || m_nToken == TOK_CLASS )
    {    
        VARIANT & var = Value.AccessVariant();
        CMoQualifierArray* paQualifiers = new CMoQualifierArray(m_pDbg);
        if (paQualifiers == NULL || !qualifier_decl(*paQualifiers, false, CLASSINST_SCOPE))
            return FALSE;
		BOOL bClass = (m_nToken == TOK_CLASS);
		if(bClass)
			return class_decl(paQualifiers, &var, NULL);
		else			
			return instance_decl(paQualifiers, &var, NULL);
    }
    else
      return const_value(Type, Value.AccessVariant(),bQualifier);
}

//***************************************************************************
//
//  <initializer_list> ::= <simple_initializer><init_list_2>;
//
//***************************************************************************
// v1.10

BOOL CMofParser::initializer_list(MODIFY CMoType& Type,
                                  OUT CMoValue& Value, bool bQualifier)
{
    HRESULT hres;

    // Check if the type is compatible with array
    // ==========================================

    if(Type.IsDefined())
    {
        if(!Type.IsArray())
        {
            m_nErrorContext = WBEMMOF_E_UNEXPECTED_ARRAY_INIT;
            return FALSE;
        }

    }

    // Get the initializers.
    // =====================

    CPtrArray aValues; // CMoValue*
    BOOL bFirst = TRUE;
    do
    {
        // Allow for the empty array case

        if(m_nToken == TOK_CLOSE_BRACE && bFirst)
            break;

        // Skip the comma, unless it is the first element
        // ==============================================
        if(!bFirst) NextToken();

        // Get single initializer 
        // ======================
        CMoValue* pSimpleValue = new CMoValue(m_pDbg);
        if(pSimpleValue == NULL || !simple_initializer(Type, *pSimpleValue, bQualifier))
            return FALSE;

        // Add it to the list
        // ==================
        aValues.Add(pSimpleValue);
        bFirst = FALSE;
    }
    while(m_nToken == TOK_COMMA);

    // Now, stuff them into a SAFEARRAY and register their aliases
    // ===========================================================

    // Create the SAFEARRAY of appropriate type
    // ========================================


	// start by figuring the type.  If all the entries are of the same
	// type, then use it.  If there is a mix, use BSTR.

    VARTYPE vt = VT_BSTR;
    if(aValues.GetSize() > 0)
    {
        VARIANT& varFirst = ((CMoValue*)aValues[0])->AccessVariant();
        vt = V_VT(&varFirst);		// normally this is what is set!
		for(int ii = 1; ii < aValues.GetSize(); ii++)
		{
			VARIANT& varCur = ((CMoValue*)aValues[ii])->AccessVariant();
			if(vt != V_VT(&varCur))
			{
                // If we just have a mix of i2 and i4, go for i4

                if((vt == VT_I4 || vt == VT_I2) && 
                   (V_VT(&varCur) == VT_I4 || V_VT(&varCur) == VT_I2) )
                     vt = VT_I4;
                else
                {
    			    vt = VT_BSTR;
				    break;
                }
			}
		}
    }


    SAFEARRAYBOUND aBounds[1];
    aBounds[0].lLbound = 0;
    aBounds[0].cElements = aValues.GetSize();

    //SAFEARRAY* pArray = SafeArrayCreateVector(vt, 0, aValues.GetSize());

#ifdef _WIN64
	VARTYPE vtTemp = (vt == VT_EMBEDDED_OBJECT) ? VT_I8 : vt;
#else
	VARTYPE vtTemp = (vt == VT_EMBEDDED_OBJECT) ? VT_I4 : vt;
#endif
	SAFEARRAY* pArray = SafeArrayCreate(vtTemp, 1, aBounds);

    // Stuff the individual data pieces
    // ================================

    for(int nIndex = 0; nIndex < aValues.GetSize(); nIndex++)
    {
        CMoValue* pSimpleValue = (CMoValue*)aValues[nIndex];
        VARIANT& varItem = pSimpleValue->AccessVariant();

        // Cast it to the array type, just in case
        // =======================================

        if((vt & ~VT_ARRAY) != VT_EMBEDDED_OBJECT)
		{
			hres = WbemVariantChangeType(&varItem, &varItem, vt);
			if(FAILED(hres)) return FALSE;
            if(varItem.vt == VT_NULL)
                varItem.llVal = 0;
		}

        if(vt == VT_BSTR)
        {
            hres = SafeArrayPutElement(pArray, (long*)&nIndex, varItem.bstrVal);
        }
		else if (vt == VT_EMBEDDED_OBJECT)
		{
			if(varItem.vt == VT_NULL)
			{
				m_nErrorContext = WBEMMOF_E_NULL_ARRAY_ELEM;
				return FALSE;
			}
			hres = SafeArrayPutElement(pArray, (long*)&nIndex, &varItem.punkVal);
            if(FAILED(hres))
                return FALSE;
		}
        else
        {
            hres = SafeArrayPutElement(pArray, (long*)&nIndex, &V_I1(&varItem));
            if(FAILED(hres))
                return FALSE;
        }

        // Transfer any aliases to the containing value
        // ============================================

        for(int i = 0; i < pSimpleValue->GetNumAliases(); i++)
        {
            LPWSTR wszAlias;
            wszAlias=NULL;
            int nDummy; // SimpleValue cannot contain an array!

            if(pSimpleValue->GetAlias(i, wszAlias, nDummy))
            {
                hres = Value.AddAlias(wszAlias, nIndex);
                if(FAILED(hres))
                {
                    m_nErrorContext = hres;
                    return FALSE;
                 }
             }
        }

		// Since VT_EMBEDDED_OBJECT is actually a pointer to a CMObject, dont
		// delete that since it will be needed later on.

		if((vt & ~VT_ARRAY) == VT_EMBEDDED_OBJECT)
        {
            VARIANT & Var = pSimpleValue->AccessVariant();
            Var.vt = VT_I4;
        }
		delete pSimpleValue;
    }

    // Store that array in the VARIANT
    // ===============================

    V_VT(&Value.AccessVariant()) = VT_ARRAY | vt;
    V_ARRAY(&Value.AccessVariant()) = pArray;

    return TRUE;
}

//***************************************************************************
//
//  Instances.
//
//***************************************************************************

//***************************************************************************
//
//  <instance_decl> ::=
//      TOK_INSTANCE TOK_OF
//      <type>
//      <as_alias>
//      TOK_OPEN_BRACE
//      <prop_init_list>
//      TOK_CLOSE_BRACE;
//
//  This can be called for both top level instances and embedded instances.
//  In the top level case, the pVar will be set to null and the object will
//  be added to the ouput.  In the embedded case, the pVar will be used to 
//  point to the object.
//***************************************************************************

BOOL CMofParser::instance_decl(ACQUIRE CMoQualifierArray* paQualifiers, VARIANT * pVar, ParseState * pQualPosition)
{
    BOOL bRetVal = FALSE;       // Default
    BSTR strClassName;

    // Begin syntax check.
    // ===================

    m_nErrorContext = WBEMMOF_E_INVALID_INSTANCE_DECLARATION;
    int nFirstLine = m_Lexer.GetLineNumber();

    if (m_nToken != TOK_INSTANCE)
    {
        delete paQualifiers;
        return FALSE;
    }
    NextToken();

    if(m_nToken != TOK_OF)
    {
        delete paQualifiers;
        return FALSE;
    }
    NextToken();

    // Get the class name.
    // ====================

    if (!sys_or_regular())
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_CLASS_NAME;
        delete paQualifiers;
        return FALSE;
    }

    strClassName = SysAllocString((LPWSTR)m_Lexer.GetText());
    if(strClassName == NULL)
    {
        m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
        return FALSE;
    }
    
    NextToken();

    // Create an instance of this class
    // ================================

    CMoInstance* pObject = new CMoInstance(strClassName, m_pDbg);    
    if(pObject == NULL)
    {
        m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
        return FALSE;
    }
    if(pObject->IsOK() == false)
        goto Exit;
        
    HRESULT hr2 = pObject->SetNamespace(m_wszNamespace);
    if(FAILED(hr2))
    {
        m_nErrorContext = hr2;
        goto Exit;
    }
    pObject->SetOtherDefaults(GetClassFlags(), GetInstanceFlags());
    SysFreeString(strClassName);

    // Apply qualifiers (already parsed)
    // =================================

    pObject->SetQualifiers(paQualifiers);
    
    // Check for an alias.  Aliases are only allowed for top level instances.
    // ======================================================================


    if(m_nToken == TOK_AS && pVar)
    {
        m_nErrorContext = WBEMMOF_E_ALIASES_IN_EMBEDDED;
        delete paQualifiers;
        return FALSE;
    }
    LPWSTR wszAlias = NULL;
    if (!as_alias(wszAlias))
        goto Exit;

    if(wszAlias)
    {
        HRESULT hr2 = pObject->SetAlias(wszAlias);
        delete [] wszAlias;
        if(FAILED(hr2))
        {
            m_nErrorContext = hr2;
            goto Exit;
        }
        
    }

    // Check for the open brace.
    // =========================

    m_nErrorContext = WBEMMOF_E_EXPECTED_OPEN_BRACE;

    if (m_nToken != TOK_OPEN_BRACE)
        goto Exit;

    // Now get the list properties.
    // ============================
    GetParserPosition(pObject->GetDataState());
	if(pQualPosition)
	{
		pObject->SetQualState(pQualPosition);
	}
    NextToken();
    if (!prop_init_list(pObject))
        goto Exit;

    // Final close brace.
    // ==================

    m_nErrorContext = WBEMMOF_E_EXPECTED_CLOSE_BRACE;

    if (m_nToken != TOK_CLOSE_BRACE)
        goto Exit;
    hr2 = pObject->SetLineRange(nFirstLine, m_Lexer.GetLineNumber(), m_Lexer.GetErrorFile());
    if(FAILED(hr2))
    {
        m_nErrorContext = hr2;
        goto Exit;
    }
    
    NextToken();

    // We have now syntactially recognized an instance
    // but done no context-sensitive verification.  This is
    // deferred to whatever module is using the parser output.
    // =======================================================

    if(pVar)
	{
		pVar->vt = VT_EMBEDDED_OBJECT;
        pVar->punkVal = (IUnknown *)pObject;
	}
    else
    {
        pObject->Deflate(false);
        m_Output.AddObject(pObject);
    }
    return TRUE;

Exit:
    delete pObject;
    return FALSE;
}

//***************************************************************************
//
//  <as_alias> ::= TOK_AS <alias>;
//  <as_alias> ::= <>;
//
//***************************************************************************
BOOL CMofParser::as_alias(OUT LPWSTR& wszAlias)
{
    if (m_nToken == TOK_AS)
    {
        NextToken();
        return alias(wszAlias);
    }
    
    wszAlias = NULL;
    return TRUE;
}

//***************************************************************************
//
//  <alias> ::= TOK_DOLLAR_SIGN TOK_SIMPLE_IDENT;
//
//
//***************************************************************************

BOOL CMofParser::alias(OUT LPWSTR& wszAlias)
{
    if (m_nToken != TOK_DOLLAR_SIGN)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_DOLLAR;
        return FALSE;
    }
    NextToken(true);

    if (m_nToken != TOK_SIMPLE_IDENT)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_ALIAS_NAME;
        return FALSE;
    }

    // Set the alias in the object
    // ===========================

    wszAlias = Macro_CloneStr(m_Lexer.GetText());
    if(wszAlias == NULL)
    {
        m_nErrorContext = WBEM_E_OUT_OF_MEMORY;
        return FALSE;
    }
    if(m_Output.IsAliasInUse(wszAlias))
    {
        m_nErrorContext = WBEMMOF_E_MULTIPLE_ALIASES;
        return FALSE;
    }

    NextToken();
    return TRUE;
}

//***************************************************************************
//
//  <prop_init_list> ::= <prop_init><prop_init_list>;
//  <prop_init_list> ::= <>;
//
//***************************************************************************
// v1.10

BOOL CMofParser::prop_init_list(MODIFY CMObject* pObject)
{
    while (m_nToken == TOK_OPEN_BRACKET ||
           m_nToken == TOK_SIMPLE_IDENT )
    {
        CValueProperty* pProp = new CValueProperty(NULL, m_pDbg);
        if (pProp == NULL || !prop_init(*pProp))
            return FALSE;

        if(!pObject->AddProperty(pProp))
        {
            // Duplicate property
            // ==================

            m_nErrorContext = WBEMMOF_E_DUPLICATE_PROPERTY;
            return FALSE;
        }
    }

    return TRUE;
}

//***************************************************************************
//
//  <prop_init> ::= <qualifier_decl> <ident> TOK_EQUALS <initializer> TOK_SEMI;
//
//***************************************************************************
BOOL CMofParser::prop_init(OUT CMoProperty& Prop)
{
    // Get the qualifiers
    // ==================

    CMoQualifierArray* paQualifiers = new CMoQualifierArray(m_pDbg);

    if (paQualifiers == NULL || !qualifier_decl(*paQualifiers,false, PROPMETH_SCOPE))
        return FALSE;
    Prop.SetQualifiers(paQualifiers); // acquired

    // Now get the property name.
    // ==========================

    if (m_nToken != TOK_SIMPLE_IDENT)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_PROPERTY_NAME;
        return FALSE;
    }

    if(FAILED(Prop.SetPropName((wchar_t *) m_Lexer.GetText())))
        return FALSE;
    NextToken();

    // Get the default value and assign it to the property.
    // ====================================================

    CMoType Type(m_pDbg);
    if (!default_value(Type, Prop.AccessValue()))
        return FALSE;

    // Check closing semicolon.
    // ========================

    m_nErrorContext = WBEMMOF_E_EXPECTED_SEMI;

    if (m_nToken != TOK_SEMI)
        return FALSE;

    NextToken();

    if(m_bDoScopeCheck && (FALSE == CheckScopes(IN_PROPERTY, paQualifiers, &Prop)))
        return FALSE;

    return TRUE;
}

//***************************************************************************
//
//	<flavor_param>    ::= TOK_COLON TOK_OPEN_PAREN <flavor_list> TOK_CLOSE_PAREN;
//	<flavor_param>    ::= <>;
//
//***************************************************************************

BOOL CMofParser::flavor_param(OUT CMoQualifier& Qual, bool bDefaultQual)
{
	if(m_nToken == TOK_COLON)
	{
		NextToken();

		if(!flavor_list(Qual))
			return FALSE;
	}
	return TRUE;
}

//***************************************************************************
//
//	<flavor_list> ::= <flavor_value> <flavor_list_rest>;
//
//***************************************************************************

BOOL CMofParser::flavor_list(OUT CMoQualifier& Qual)
{
	if(!flavor_value(Qual))
		return FALSE;
	else 
		return flavor_list_rest(Qual);
}

//***************************************************************************
//
//	<flavor_list_rest> ::= <FLAVOR_VALUE> <flavor_list_rest>;
//	<flavor_list_rest> ::= <>;
//
//***************************************************************************

BOOL CMofParser::flavor_list_rest(CMoQualifier& Qual)
{

	if(m_nToken == TOK_COMMA || m_nToken == TOK_CLOSE_BRACKET || m_nToken == TOK_SEMI)
        return TRUE;
    else

	{
		if(!flavor_value(Qual))
			return FALSE;
		return flavor_list_rest(Qual);
	}
	return TRUE;
}

//***************************************************************************
//
//	<def_flavor_list> ::= <flavor_value> <flavor_list_rest>;
//
//***************************************************************************

BOOL CMofParser::def_flavor_list(OUT CMoQualifier& Qual)
{
	if(!flavor_value(Qual))
		return FALSE;
	else 
		return def_flavor_list_rest(Qual);
}

//***************************************************************************
//
//	<def_flavor_list_rest> ::= <FLAVOR_VALUE> <def_flavor_list_rest>;
//	<def_flavor_list_rest> ::= <>;
//
//***************************************************************************

BOOL CMofParser::def_flavor_list_rest(CMoQualifier& Qual)
{
	if(m_nToken == TOK_CLOSE_PAREN)
        return TRUE;
    else

	{
        if(m_nToken != TOK_COMMA)
            return FALSE;
        NextToken();

		if(!flavor_value(Qual))
			return FALSE;
		return def_flavor_list_rest(Qual);
	}
	return TRUE;
    
}

//***************************************************************************
//
//	<flavor_value> ::= TOK_TOINSTANCE;
//	<flavor_value> ::= TOK_TOSUBCLASS;
//	<flavor_value> ::= TOK_ENABLEOVERRIDE;
//	<flavor_value> ::= TOK_DISABLEOVERRIDE;
//	<flavor_value> ::= TOK_NOTTOINSTANCE;
//	<flavor_value> ::= TOK_AMENDED;
//	<flavor_value> ::= TOK_NOTTOSUBCLASS;
//	<flavor_value> ::= TOK_RESTRICTED;
//
//***************************************************************************

BOOL CMofParser::flavor_value(CMoQualifier& Qual)
{
	SCODE sc = Qual.SetFlag(m_nToken, m_Lexer.GetText());
    if(sc != S_OK)
    {
	    m_nErrorContext = sc;
		return FALSE;
    }
	NextToken();
	return TRUE;
}

//***************************************************************************
//
// <qualifier_default> ::= TOK_QUALIFIER TOK_SIMPLE_IDENT TOK_COLON  <finish_qualifier_default>;
//
//***************************************************************************

BOOL CMofParser::qualifier_default()
{
    // Verify header
    // =============

    CHECK(TOK_QUALIFIER);

    m_nErrorContext = WBEMMOF_E_EXPECTED_QUALIFIER_NAME;
    if(m_nToken != TOK_SIMPLE_IDENT)
        return FALSE;

    // Store qualifier name
    // ====================

    CMoQualifier* pDefault = new CMoQualifier(m_pDbg);
    if(pDefault == NULL)
        return FALSE;
    if(FAILED(pDefault->SetQualName(m_Lexer.GetText())))
    {
        delete pDefault;
        return FALSE;
    }
    NextToken();

	// check for chase where its just Qualifier Name ;

    if(m_nToken == TOK_SEMI)
    {
        m_Output.SetQualifierDefault(pDefault);
	    NextToken();
        return TRUE;
    }

    // Make sure there is a colon

    if(m_nToken != TOK_COLON)
    {
        m_nErrorContext = WBEMMOF_E_EXPECTED_SEMI;
        delete pDefault;
        return FALSE;
    }

    // Get the flavor
    // ==============

    if(!finish_qualifier_default(*pDefault))
    {
        delete pDefault;
        return FALSE;
    }

    m_nErrorContext = WBEMMOF_E_EXPECTED_SEMI;
    if(m_nToken != TOK_SEMI)
    {
        delete pDefault;
        return FALSE;
    }
    NextToken();
    return TRUE;
}


//***************************************************************************
//
// <finish_qualifier_default> ::= <flavor_list>;
// <finish_qualifier_default> ::= <type> TOK_EQUALS <default_value> TOK_COMMA TOK_SCOPE TOK_OPEN_PAREN <scope_list> TOK_CLOSE_PAREN <finish_qualifier_end>
//
//***************************************************************************

BOOL CMofParser::finish_qualifier_default(CMoQualifier& Qual)
{
    // Determine if it is of the simple (flavor only type) or the more complex

    NextToken();
	SCODE sc = Qual.SetFlag(m_nToken, m_Lexer.GetText());
    if(sc == S_OK)
    {
        BOOL bRet = flavor_list(Qual);
        if(bRet)
            m_Output.SetQualifierDefault(&Qual);
        return bRet;
    }

    m_nErrorContext = WBEMMOF_E_INVALID_QUALIFIER_SYNTAX;
    Qual.SetCimDefault(true);

    // assume that we have the long (cim version)

    // Get the type

    CMoType Type(m_pDbg);

    if (!type(Type))
    {
        return FALSE;
    }

    // optional array indication
    if(m_nToken == TOK_OPEN_BRACKET)
    {
        NextToken();
        if(m_nToken != TOK_CLOSE_BRACKET)
            return FALSE;
        Type.SetIsArray(TRUE);
        NextToken();
    }
    else
        Type.SetIsArray(FALSE);


    VARTYPE vt = Type.GetCIMType();
    if(vt == VT_ERROR)
        return FALSE;
    Qual.SetType(vt);

    // optional TOK_EQUALS

    if(m_nToken == TOK_EQUALS)
    {
 
        // TOK_SIMPLE_VALUE

        NextToken();
	    CMoValue & Value = Qual.AccessValue();

        if (!simple_initializer(Type, Value, true))
                return FALSE;
    }

    // look for comma

    if(m_nToken != TOK_COMMA)
        return FALSE;

    // TOK_SCOPE 

    NextToken();
    if(m_nToken != TOK_SIMPLE_IDENT || wbem_wcsicmp(L"SCOPE", m_Lexer.GetText()))
        return FALSE;
    
    // TOK_OPEN_PAREN 

    NextToken();
    if(m_nToken != TOK_OPEN_PAREN)
        return FALSE;
    
    // <scope_list> and close paren

    if(!scope_list(Qual))
        return FALSE;

    return finish_qualifier_end(Qual);
}

//***************************************************************************
//
//  <finish_qualifier_end> ::= TOK_COMMA TOK_FLAVOR OK_OPEN_PAREN <flavor_list> TOK_CLOSE_PAREN;
//  <finish_qualifier_end> ::= <>;
//
//***************************************************************************

BOOL CMofParser::finish_qualifier_end(CMoQualifier& Qual)
{
    
    // TOK_COMMA 

    NextToken();
    if(m_nToken == TOK_SEMI)
        return TRUE;

    if(m_nToken != TOK_COMMA)
        return FALSE;

    // TOK_FLAVOR 
    
    NextToken();
    if(m_nToken != TOK_SIMPLE_IDENT || wbem_wcsicmp(L"FLAVOR", m_Lexer.GetText()))
        return FALSE;

    // TOK_OPEN_PAREN 

    NextToken();
    if(m_nToken != TOK_OPEN_PAREN)
        return FALSE;
    
    // <flavor_list> 

    NextToken();
    if(!def_flavor_list(Qual))
        return FALSE;
    
    // TOK_CLOSE_PAREN

    if(m_nToken != TOK_CLOSE_PAREN)
        return FALSE;
    
    m_Output.SetQualifierDefault(&Qual);
    NextToken();

    return TRUE;
}

//***************************************************************************
//
//	<scope_list> ::= <scope_value> <scope_list_rest>;
//
//***************************************************************************

BOOL CMofParser::scope_list(OUT CMoQualifier& Qual)
{
    NextToken();
	if(!scope_value(Qual))
		return FALSE;
	else 
		return scope_list_rest(Qual);
}

//***************************************************************************
//
//	<scope_list_rest> ::= <SCOPE_VALUE> <scope_list_rest>;
//	<scope_list_rest> ::= <>;
//
//***************************************************************************

BOOL CMofParser::scope_list_rest(CMoQualifier& Qual)
{
	if(m_nToken == TOK_CLOSE_PAREN)
        return TRUE;
    else

	{
        if(m_nToken != TOK_COMMA)
            return FALSE;
        NextToken();
		if(!scope_value(Qual))
			return FALSE;
		return scope_list_rest(Qual);
	}
	return TRUE;
}

//***************************************************************************
//
//	<scope_value> ::= TOK_CLASS;
//	<scope_value> ::= TOK_INSTANCE;
//
//***************************************************************************

BOOL CMofParser::scope_value(CMoQualifier& Qual)
{
	BOOL bRet = Qual.SetScope(m_nToken, m_Lexer.GetText());   
    if(!bRet)
		return FALSE;
	NextToken();
	return TRUE;
}

BOOL CMofParser::CheckScopes(SCOPE_CHECK scope_check, CMoQualifierArray* paQualifiers, 
                             CMoProperty * pProperty)
{
    m_nErrorContext = WBEMMOF_E_QUALIFIER_USED_OUTSIDE_SCOPE;
    bool bAssociation = false;
    bool bReference = false;
    int iDef;

    // if this is a class, check determine if it is an association 

    if(scope_check == IN_CLASS)
    {
		CMoValue * pValue = paQualifiers->Find(L"ASSOCIATION");
		if(pValue)
		{
            VARIANT& var = pValue->AccessVariant();
			if(var.vt == VT_BOOL && var.boolVal == VARIANT_TRUE)
                bAssociation=true;
        }
    }

    // if it is a property, determine if it is a reference

    if((scope_check == IN_PROPERTY || scope_check == IN_PARAM) && 
        pProperty && (pProperty->GetType() == CIM_REFERENCE))
        bReference = true;

    // For each qualifier in my list, look at the globals look for a match

    int iNumTest =  paQualifiers->GetSize();
    int iNumDef = m_Output.GetNumDefaultQuals();
    for(int iTest = 0; iTest < iNumTest; iTest++)
    {
        // Get the qualifier to test

        CMoQualifier* pTest = paQualifiers->GetAt(iTest);
        
        // look for the qualifier in the default list
        
        CMoQualifier* pDefault = NULL;
        for(iDef = 0; iDef < iNumDef; iDef++)
        {
            CMoQualifier* pDefault = m_Output.GetDefaultQual(iDef);
            if(wbem_wcsicmp(pDefault->GetName(), pTest->GetName()) == 0)
            {
                bool bInScope = false;
                DWORD dwScope = pDefault->GetScope();
                if(dwScope == 0)
                    bInScope = true;
                if((dwScope & SCOPE_ASSOCIATION) && bAssociation)
                    bInScope = true;
                if((dwScope & SCOPE_REFERENCE) && bReference)
                    bInScope = true;

                // got a match
                switch (scope_check)
                {
                case IN_CLASS:
                    if(dwScope & SCOPE_CLASS)
                        bInScope = true;
                    break;
                case IN_INSTANCE:
                    if(dwScope & SCOPE_INSTANCE)
                        bInScope = true;
                    break;
                case IN_PROPERTY:
                    if(dwScope & SCOPE_PROPERTY)
                        bInScope = true;
                    break;
                case IN_PARAM:
                    if(dwScope & SCOPE_PARAMETER)
                        bInScope = true;
                    break;
                case IN_METHOD:
                    if(dwScope & SCOPE_METHOD)
                        bInScope = true;
                    break;
                }
                if(!bInScope)
                    return false;
                break;
            }
        }

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\mofout.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    MOFOUT.CPP

Abstract:

	Class and code used to output split files.  This is used so that a 
	single mof file can be split into a localized and non localized versions.

History:

	2/4/99    a-davj      Compiles.

--*/

#include "precomp.h"
#include <cominit.h>
#include <wbemcli.h>
#include "mofout.h"
#include <genutils.h>
#include <var.h>
#include "mofprop.h"


//***************************************************************************
//
//  COutput::COutput
//
//  DESCRIPTION:
//
//  Constructor.  This object is used to serialize output to a file
//
//***************************************************************************

COutput::COutput(TCHAR * pName, OutputType ot, BOOL bUnicode, BOOL bAutoRecovery, long lLocale) : m_lLocale(lLocale)
{
    m_bUnicode = true;
    m_Level = 0;
    m_lClassFlags = 0;
    m_lInstanceFlags = 0;
    m_bSplitting = false;
    if(ot == NEUTRAL)
        wcscpy(m_wszNamespace, L"root\\default");
    else
        wcscpy(m_wszNamespace, L"_?");
    m_hFile = CreateFile(pName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ, NULL,
        CREATE_ALWAYS, 0, NULL);
	if(bUnicode && m_hFile != INVALID_HANDLE_VALUE)
	{
		unsigned char cUnicodeHeader[2] = {0xff, 0xfe};
		DWORD dwWrite;
        WriteFile(m_hFile, cUnicodeHeader, 2, &dwWrite, NULL);
	}

    m_Type = ot;
    if(bAutoRecovery)
        WriteLPWSTR(L"#pragma autorecover\r\n");

}

//***************************************************************************
//
//  COutput::~COutput()
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

COutput::~COutput()
{
    if(m_hFile != INVALID_HANDLE_VALUE)
        CloseHandle(m_hFile);
}

//***************************************************************************
//
//  COutput::WriteLPWSTR(WCHAR const * pOutput)
//
//  DESCRIPTION:
//
//  Writes a string to the file.  If the original file was not unicode, then
//  this converts the text back into mbs.
//
//***************************************************************************

bool COutput::WriteLPWSTR(WCHAR const * pOutput)
{

    DWORD dwLen, dwWrite;
    if(pOutput == NULL || m_hFile == INVALID_HANDLE_VALUE)
        return false;
    if(m_bUnicode)
    {
        dwLen = 2 * (wcslen(pOutput));
        WriteFile(m_hFile, pOutput, dwLen, &dwWrite, NULL);
    }
    else
    {
        int iLen = 2 * (wcslen(pOutput) + 1);
        char * pTemp = new char[iLen];
        if(pTemp == NULL)
            return false;
        wcstombs(pTemp, pOutput, iLen);
        dwLen = strlen(pTemp);
        WriteFile(m_hFile, pTemp, dwLen, &dwWrite, NULL);
        delete [] pTemp;
    }
    if(dwWrite == dwLen)
        return true;
    else
        return false;
}

//***************************************************************************
//
//  COutput::WriteVARIANT(VARIANT & varIn)
//
//  DESCRIPTION:
//
//  Serialized a variant out to the file.  This relies on the CVar class so
//  as to be compatible with GetObjectText().
//
//***************************************************************************

bool COutput::WriteVARIANT(VARIANT & varIn)
{
    CVar X(&varIn);    
    BSTR b = X.GetText(0,0);
    if(b)
    {
        WriteLPWSTR(b);
        SysFreeString(b);
        return true;
    }
    else
        return false;
}

//***************************************************************************
//
//  bool COutput::NewLine(int iIndent)
//
//  DESCRIPTION:
//
//  Starts a new line.  In addition to the cr\lf, this also indents based on
//  the argument and the level of subobject.  I.e.  if we are inside a 
//  subobject to a subobject, we would indent 10 characters.  
//
//***************************************************************************

bool COutput::NewLine(int iIndent)
{
    WriteLPWSTR(L"\r\n");
    int iExtra = iIndent + m_Level * 4;
    for (int i = 0; i < iExtra; i++)
    {
        WriteLPWSTR(L" ");
    }
    return true;
}

//***************************************************************************
//
//  COutput::WritePragmasForAnyChanges()
//
//  DESCRIPTION:
//
//  This is called at the start of each class or instance object.  If the
//  class flags, instance flags, or namespace have changed, then this outputs
//  the appropriate pragmas.  The lLocale argument is used if we are 
//  outputting to the localized file.  In that case the lLocale is added to
//  the namespace path. 
//
//***************************************************************************

void COutput::WritePragmasForAnyChanges(long lClassFlags, long lInstanceFlags, 
                                        LPWSTR pwsNamespace, long lLocale)
{
    if(m_Level > 0)
        return;         // ignore for embedded objects;

    if(lClassFlags != m_lClassFlags)
    {
        WCHAR wTemp[40];
        m_lClassFlags = lClassFlags;
        swprintf(wTemp, L"#pragma classflags(%d)\r\n", m_lClassFlags);
        WriteLPWSTR(wTemp);
    }
    if(lInstanceFlags != m_lInstanceFlags)
    {
        WCHAR wTemp[40];
        m_lInstanceFlags = lInstanceFlags;
        swprintf(wTemp, L"#pragma instanceflags(%d)\r\n", m_lInstanceFlags);
        WriteLPWSTR(wTemp);
    }
    if(wbem_wcsicmp(m_wszNamespace, pwsNamespace))
    {
        // copy the namespace into the buffer.

        wcsncpy(m_wszNamespace, pwsNamespace, MAX_PATH);
        m_wszNamespace[MAX_PATH] = 0;

        // before writting this out, each slash needs to be doubled up.  Also,
        // the path may need the machine part.

        WCHAR wTemp[MAX_PATH*2];
        WCHAR * pTo = wTemp, * pFrom = pwsNamespace;
        if(pwsNamespace[0] != L'\\')
        {
            wcscpy(pTo, L"\\\\\\\\.\\\\");
            pTo+= 7;
        }
        while(*pFrom)
        {
            if(*pFrom == L'\\')
            {
                *pTo = L'\\';
                pTo++;
            }
            *pTo = *pFrom;
            pTo++;
            pFrom++;
        }
        *pTo = 0;
        
        WriteLPWSTR(L"#pragma namespace(\"");
        WriteLPWSTR(wTemp);
        WriteLPWSTR(L"\")\r\n");
        
        // For localized, we need to create the namespace and then to modify the pragma
        // Example, if the namespace is root, we need to write
        // #pragma ("root")
        // instance of __namespace{name="ms_409";};
        // #pragma ("root\ms_409")

        if(m_Type == LOCALIZED)
        {
            WCHAR wMSLocale[10];
            swprintf(wMSLocale, L"ms_%x", lLocale);
        
            WriteLPWSTR(L"instance of __namespace{ name=\"");
            WriteLPWSTR(wMSLocale);
            WriteLPWSTR(L"\";};\r\n");

            WriteLPWSTR(L"#pragma namespace(\"");
            WriteLPWSTR(wTemp);
            WriteLPWSTR(L"\\\\");
            WriteLPWSTR(wMSLocale);
            WriteLPWSTR(L"\")\r\n");
        }

    }
}

//***************************************************************************
//
//  CMoValue::Split(COutput &out)
//
//  DESCRIPTION:
//
//  Serialize a CMoValue.  In general, the standard converted is used, but
//  we must special case alias values.
//
//***************************************************************************

BOOL CMoValue::Split(COutput &out)
{

    int iNumAlias = GetNumAliases();
    LPWSTR wszAlias = NULL; int nArrayIndex;

    // This is the normal case of all but references!!!!

    if(iNumAlias == 0)
        return out.WriteVARIANT(m_varValue);
    
    if(m_varValue.vt == VT_BSTR)
    {
        // simple case, single alias

        out.WriteLPWSTR(L"$");
        GetAlias(0, wszAlias, nArrayIndex);
        out.WriteLPWSTR(wszAlias);
        return TRUE;
    }
    else
    {

        out.WriteLPWSTR(L"{");

        // For each string from the safe array

        SAFEARRAY* psaSrc = V_ARRAY(&m_varValue);
        if(psaSrc == NULL)
            return FALSE;
        SAFEARRAYBOUND aBounds[1];
        long lLBound;
        SCODE sc = SafeArrayGetLBound(psaSrc, 1, &lLBound);
        long lUBound;
        sc |= SafeArrayGetUBound(psaSrc, 1, &lUBound);
        if(sc != S_OK)
            return FALSE;

        aBounds[0].cElements = lUBound - lLBound + 1;
        aBounds[0].lLbound = lLBound;

        for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
        {

            // Determine if this is an alias
            
            int iTest;
            for(iTest = 0; iTest < iNumAlias; iTest++)
            {
                if(GetAlias(iTest, wszAlias, nArrayIndex))
                    if(nArrayIndex == lIndex)
                        break;
            }

            // If so, the output the alias value

            if(iTest < iNumAlias)
            {
                out.WriteLPWSTR(L"$");
                out.WriteLPWSTR(wszAlias);
            }
            else
            {
                // else output the string

                BSTR bstr;
                if(S_OK == SafeArrayGetElement(psaSrc, &lIndex, &bstr))
                {
                    out.WriteLPWSTR(L"\"");
                    out.WriteLPWSTR(bstr);
                    SysFreeString(bstr);
                    out.WriteLPWSTR(L"\"");
                }
                SysFreeString (bstr);
            }
            
            // possibly output a comma

            if(lUBound != lLBound && lIndex < lUBound)
                out.WriteLPWSTR(L",");
        }
        
        out.WriteLPWSTR(L"}");
        return TRUE;
    }
}

BOOL CMoActionPragma::Split(COutput & out)
{
    // Write flags and namespace pragmas

    long lLocale = out.GetLocale();
    WCHAR * pwszNamespace = m_wszNamespace;
    out.WritePragmasForAnyChanges(m_lDefClassFlags, m_lDefInstanceFlags, pwszNamespace, lLocale);

    out.NewLine(0);
	if(m_bClass)
		out.WriteLPWSTR(L"#pragma deleteclass(");
	else
		out.WriteLPWSTR(L"#pragma deleteinstance(");

    // The class name may have embedded quotes etc.  So convert to variant and
    // output that since that logic automatically puts in the needed escapes

    VARIANT var;    
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(m_wszClassName);
    if(var.bstrVal == NULL)
        return FALSE;
    out.WriteVARIANT(var);
    VariantClear(&var);
    
    out.WriteLPWSTR(L",");
    if(m_bFail)
        out.WriteLPWSTR(L"FAIL)");
    else
        out.WriteLPWSTR(L"NOFAIL)");
    out.NewLine(0);
    return TRUE;
}
//***************************************************************************
//
//  CMObject::Split(COutput & out)
//
//  DESCRIPTION:
//
//  Serialize a Class of instance object.
//
//***************************************************************************

BOOL CMObject::Split(COutput & out)
{

    // If this is a top level object, figure out if it has a [locale] qualifier

    long lLocale = out.GetLocale();

    if(out.GetLevel() == 0)
    {
        bool bAmended = m_bAmended;

        if(out.GetType() == LOCALIZED)
        {
            // if this is the localized output and this object doesnt
            // have the locale.

            if(!bAmended)
                return TRUE;
        }
        else
        {
            // if this is the non localized version, then the object
            // may, or may not be split apart.

            out.SetSplitting(bAmended);
        }
    }

	WCHAR * pwszNamespace = m_wszNamespace;

    // Write flags and namespace pragmas

    out.WritePragmasForAnyChanges(m_lDefClassFlags, m_lDefInstanceFlags, pwszNamespace, lLocale);

    // Write the qualifiers

    if(GetQualifiers())
    {
        CMoQualifierArray * pqual = GetQualifiers();
        pqual->Split(out, OBJECT);
    }

    // Write the instance or class declaration

    out.NewLine(0);
    if(IsInstance())
    {
        out.WriteLPWSTR(L"Instance of ");
        out.WriteLPWSTR(GetClassName());
        CMoInstance * pInst = (CMoInstance *)this;
        if(pInst->GetAlias())
        {
            out.WriteLPWSTR(L" as $");
            out.WriteLPWSTR(GetAlias());
        }
    }
    else
    {
        out.WriteLPWSTR(L"class ");
        out.WriteLPWSTR(GetClassName());
        CMoClass * pClass = (CMoClass *)this;
        if(pClass->GetAlias())
        {
            out.WriteLPWSTR(L" as $");
            out.WriteLPWSTR(GetAlias());
        }
        if(pClass->GetParentName())
        {
            out.WriteLPWSTR(L" : ");
            out.WriteLPWSTR(pClass->GetParentName());
        }
    }
    out.NewLine(0);
    out.WriteLPWSTR(L"{");

    // Output the properties and methods
    
    for(int i = 0; i < GetNumProperties(); i++)
    {
        if(!GetProperty(i)->Split(out)) return FALSE;
    }

    out.NewLine(0);

    // if this is a top level object, add the semicolon and an extra 
    if(out.GetLevel() == 0)
    {
        out.WriteLPWSTR(L"};");
        out.NewLine(0);
    }
    else
        out.WriteLPWSTR(L"}");

    return TRUE;
}

//***************************************************************************
//
//  CValueProperty::Split(COutput & out)
//
//  DESCRIPTION:
//
//  Serializes value properties
//
//***************************************************************************

BOOL CValueProperty::Split(COutput & out)
{
    // Write the qualifiers

    if(GetQualifiers())
    {
        CMoQualifierArray * pqual = GetQualifiers();
        if(out.GetType() == LOCALIZED && !pqual->HasAmended() && !m_bIsArg)
            return TRUE;
        pqual->Split(out, (m_bIsArg) ? ARG : PROP);
    }
    else
        if(out.GetType() == LOCALIZED && !m_bIsArg)
            return TRUE;

    // determine if this is an array value

    VARTYPE vt = m_Value.GetType();
    BOOL bArray = vt & VT_ARRAY;
    if(m_bIsArg && bArray == FALSE && vt == 0)
    {
        VARTYPE vtInner = m_Value.GetVarType();
        bArray = vtInner & VT_ARRAY;
    }

    // Possibly output the type, such as "sint32"

    if(m_wszTypeTitle)
    {
        out.WriteLPWSTR(m_wszTypeTitle);
        VARTYPE vt = m_Value.GetType();
        vt = vt & (~CIM_FLAG_ARRAY);
        if(vt == CIM_REFERENCE)
            out.WriteLPWSTR(L" Ref");
        out.WriteLPWSTR(L" ");
    }

    // Output the property name

    out.WriteLPWSTR(m_wszName);
    if(bArray)
        out.WriteLPWSTR(L"[]");

    // In general, the value is output via CMoValue, but the
    // glaring exception is embedded objects and arrays of 
    // embedded objects

    vt = m_Value.GetVarType();
    if(vt != VT_NULL && out.GetType() == NEUTRAL )
    {
        out.WriteLPWSTR(L" = ");
        if(vt == VT_UNKNOWN)
        {
            // got an embedded object

            VARIANT & var = m_Value.AccessVariant(); 
            CMObject * pObj = (CMObject *)var.punkVal;
            out.IncLevel();     // indicate embedding
            pObj->Split(out);
            out.DecLevel();
        }
        else if (vt == (VT_ARRAY | VT_UNKNOWN))
        {
            // got an embedded object array

            SCODE sc ;
            out.WriteLPWSTR(L"{");
            VARIANT & var = m_Value.AccessVariant(); 
            SAFEARRAY * psaSrc = var.parray;
            if(psaSrc == NULL)
                return FALSE;
            long lLBound, lUBound;
            sc = SafeArrayGetLBound(psaSrc, 1, &lLBound);
            sc |= SafeArrayGetUBound(psaSrc, 1, &lUBound);
            if(sc != S_OK)
                return FALSE; 

            for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
            {
                CMObject * pObj = NULL;

                SCODE sc = SafeArrayGetElement(psaSrc, &lIndex, &pObj);
                if(sc == S_OK && pObj)
                {
                    out.IncLevel();     // indicate embedding
                    pObj->Split(out);
                    out.DecLevel();
                }
                if(lLBound != lUBound && lIndex < lUBound)
                    out.WriteLPWSTR(L",");
            }
            out.WriteLPWSTR(L"}");
        }
        else
            m_Value.Split(out);         // !!! Typical case
    }

    // Note that property objects are used as argmuments in methods.  If this
    // is one of these, then dont output a ';'

    if(!m_bIsArg)
        out.WriteLPWSTR(L";");

    return TRUE;
}

//***************************************************************************
//
//  CMethodProperty::IsDisplayable(COutput & out)
//
//  DESCRIPTION:
//
//  Serializes methods
//
//***************************************************************************

BOOL CMethodProperty::IsDisplayable(COutput & out)
{
    // if we are neutral, then always.

    if(out.GetType() == NEUTRAL)
        return TRUE;

    // Write the qualifiers

    if(GetQualifiers())
    {
        CMoQualifierArray * pqual = GetQualifiers();
        if(pqual->HasAmended())
            return TRUE;
    }

    int iSize = m_Args.GetSize();
    for(int i = 0; i < iSize; i++)
    {
        CValueProperty * pProp = (CValueProperty *)m_Args.GetAt(i);
        if(pProp)
        {
            CMoQualifierArray * pqual = pProp->GetQualifiers();
            if(pqual->HasAmended())
                return TRUE;
        }
    }

    return FALSE;
}

//***************************************************************************
//
//  CMethodProperty::Split(COutput & out)
//
//  DESCRIPTION:
//
//  Serializes methods
//
//***************************************************************************

BOOL CMethodProperty::Split(COutput & out)
{
    if(!IsDisplayable(out))
        return TRUE;

    // Write the qualifiers

    if(GetQualifiers())
    {
        CMoQualifierArray * pqual = GetQualifiers();
        pqual->Split(out, PROP);
    }

    // Output the method's return value type and name

    if(m_wszTypeTitle)
    {
        if(wbem_wcsicmp(L"NULL", m_wszTypeTitle))
            out.WriteLPWSTR(m_wszTypeTitle);
        else
            out.WriteLPWSTR(L"void");
        out.WriteLPWSTR(L" ");
    }
    out.WriteLPWSTR(m_wszName);

    // output the arguements between the parenthesis

    out.WriteLPWSTR(L"(");
    int iSize = m_Args.GetSize();
    for(int i = 0; i < iSize; i++)
    {
        CValueProperty * pProp = (CValueProperty *)m_Args.GetAt(i);
        if(pProp)
        {
            pProp->SetAsArg();
            pProp->Split(out);
        }
        if(iSize > 0 && i < (iSize-1))
            out.WriteLPWSTR(L",");
    }

    out.WriteLPWSTR(L");");

    return TRUE;
}

//***************************************************************************
//
//  CMoQualifier::IsDisplayable(COutput & out, QualType qt)
//
//  DESCRIPTION:
//
//  Determines if a qualifier is to be written.
//
//***************************************************************************

BOOL CMoQualifier::IsDisplayable(COutput & out, QualType qt)
{

    if(!wbem_wcsicmp(L"cimtype", m_wszName))   // never!
        return FALSE;
    if(!wbem_wcsicmp(L"KEY", m_wszName))       // always!
        return TRUE;
    if(!wbem_wcsicmp(L"LOCALE", m_wszName) && qt == OBJECT)
        if(out.GetType() == LOCALIZED)
            return FALSE;
        else
            return TRUE;
    if(!wbem_wcsicmp(L"ID", m_wszName) && qt == ARG)
        return FALSE;
    if(!wbem_wcsicmp(L"IN", m_wszName) && qt == ARG)
        return TRUE;
    if(!wbem_wcsicmp(L"OUT", m_wszName) && qt == ARG)
        return TRUE;

    if(out.GetType() == LOCALIZED)
    {
        return (m_bAmended) ? TRUE : FALSE;
    }
    else
    {
        if(out.IsSplitting() == FALSE)
            return TRUE;
        if(m_bAmended == FALSE)
            return TRUE;
        return FALSE;
    }
}

//***************************************************************************
//
//  PrintSeparator(COutput & out, bool bFirst)
//
//  DESCRIPTION:
//
//  Outputs space or colon when dumping flavors.
//
//***************************************************************************

void PrintSeparator(COutput & out, bool bFirst)
{
    if(bFirst)
        out.WriteLPWSTR(L" : ");
    else
        out.WriteLPWSTR(L" ");
}

//***************************************************************************
//
//  CMoQualifier::Split(COutput & out)
//
//  DESCRIPTION:
//
//  Serializes CMoQualifiers.
//
//***************************************************************************

BOOL CMoQualifier::Split(COutput & out)
{
    
    // Always write the name

    out.WriteLPWSTR(m_wszName);
    VARIANT & var = m_Value.AccessVariant();

    // If the type is other than a true bool, dump it out

    if(var.vt != VT_BOOL || var.boolVal != VARIANT_TRUE)
    {
        VARTYPE vt = m_Value.GetVarType();
    
        // If this is an array, then the lower level dumping
        // code will enclose the values in {}
        
        if((vt & VT_ARRAY) == 0)
            out.WriteLPWSTR(L"(");
        
        m_Value.Split(out);
        
        if((vt & VT_ARRAY) == 0)
            out.WriteLPWSTR(L")");
    }

    // Dump out the flavors

    bool bFirst = true;
    if(m_bAmended)
    {
        PrintSeparator(out, bFirst);
        out.WriteLPWSTR(L"Amended");
        bFirst = false;
    }
    if(m_lFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE)
    {
        PrintSeparator(out, bFirst);
        out.WriteLPWSTR(L"ToInstance");
        bFirst = false;
    }
    if(m_lFlavor & WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS)
    {
        PrintSeparator(out, bFirst);
        out.WriteLPWSTR(L"ToSubclass");
        bFirst = false;
    }
    if(m_lFlavor & WBEM_FLAVOR_NOT_OVERRIDABLE)
    {
        PrintSeparator(out, bFirst);
        out.WriteLPWSTR(L"DisableOverride");
        bFirst = false;
    }

    return TRUE;
}

//***************************************************************************
//
//  CMoQualifierArray::Split(COutput & out, QualType qt)
//
//  DESCRIPTION:
//
//  Serializes the qualifier array.
//
//***************************************************************************

BOOL CMoQualifierArray::Split(COutput & out, QualType qt)
{

    bool bTopLevelLocalizedObj = ( qt == OBJECT && out.GetType() == LOCALIZED && 
                                    out.GetLevel() == 0);

    // count the number that need to be serialized.

    int iNumOutput = 0, i;
    for(i = 0; i < GetSize(); i++)
    {

        CMoQualifier * pQual = GetAt(i);
        if(pQual && pQual->IsDisplayable(out, qt))      
            iNumOutput++;
    }

    // If this is a top level object in a localized object, then the local is foced out
    // along with the amended qualifier

    if(bTopLevelLocalizedObj)
        iNumOutput += 2;

    // If this is for anything other than an argument, then
    // dump a new line.  Note that properties get an extra
    // two characters of indent

    if(qt == PROP)
        out.NewLine(2);
    else if (qt == OBJECT && iNumOutput > 0)
        out.NewLine(0);
    if(iNumOutput == 0)     // perfectly normal
        return TRUE;

    // Serialize the individual qualifiers

    out.WriteLPWSTR(L"[");
    int iNumSoFar = 0;
    for(i = 0; i < GetSize(); i++)
    {

        CMoQualifier * pQual = GetAt(i);
        if(pQual == NULL || !pQual->IsDisplayable(out, qt))     
            continue;
        iNumSoFar++;
        pQual->Split(out);

        if(iNumSoFar < iNumOutput)
            out.WriteLPWSTR(L",");
    }

    // If this is a top level object in a localized object, then the local is foced out
    // along with the amended qualifier

    if(bTopLevelLocalizedObj)
    {
        WCHAR Buff[50];
        swprintf(Buff, L"AMENDMENT, LOCALE(0x%03x)", out.GetLocale());
        out.WriteLPWSTR(Buff);

    }

    out.WriteLPWSTR(L"] ");

    return TRUE;
}

//***************************************************************************
//
//  CMObject::CheckIfAmended()
//
//  DESCRIPTION:
//
//  returns true if the object has one or more Amended qualifiers.
//
//***************************************************************************

bool CMObject::CheckIfAmended()
{
    if(m_bAmended)
        return true;

    // true if this is a __namespace object

    if(IsInstance())
    {
        if(!wbem_wcsicmp(GetClassName(), L"__namespace"))
            return false;
    }

    // Deletes always get displayed

    if(IsDelete())
        return TRUE;

    // Check if the main qualifier list has an amended qualifier
    
    if(m_paQualifiers->HasAmended())
        return true;

    // check if any of the properties has an amended qualifier

	for(int i = 0; i < GetNumProperties(); i++)
	{
		CMoProperty * pProp = GetProperty(i);
		if(pProp)
		{
            CMoQualifierArray* pPropQualList = pProp->GetQualifiers();
            if(pPropQualList->HasAmended())
                return true;
		}
	}
    return false;
}

//***************************************************************************
//
//  CMoQualifierArray::HasAmended()
//
//  DESCRIPTION:
//
//  Returns true if one of more of the qualifiers is amended.
//
//***************************************************************************

bool CMoQualifierArray::HasAmended()
{
    int iCnt, iSize = m_aQualifiers.GetSize();
    for(iCnt = 0; iCnt < iSize; iCnt++)
    {
        CMoQualifier * pQual = (CMoQualifier *)m_aQualifiers.GetAt(iCnt);
        if(pQual)
            if(pQual->IsAmended())
                return true;
    }
    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\mofprop.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MOFPROP.CPP

Abstract:

History:

--*/

#include "precomp.h"
#include <wbemidl.h>
//#include "corepol.h"
#include "wstring.h"
#include "mofout.h"
#include "mofprop.h"
#include "typehelp.h"
#include "trace.h"
#include "strings.h"
#include "cwbemtime.h"
#include <genutils.h>
#include <wbemutil.h>
#include <cominit.h>
#include <arrtempl.h>
#include "moflex.h"
#include "mofparse.h"
#include <memory>

BOOL BinaryToInt(wchar_t * pConvert, __int64& i64Res);

void assign(WCHAR * &pTo, LPCWSTR pFrom)
{
    if(pTo)
    {
        delete pTo;
        pTo = NULL;
    }
    if(pFrom)
    {
        pTo = new WCHAR[wcslen(pFrom)+1];
        if(pTo)
            wcscpy(pTo, pFrom);
    }
}

BOOL ConvertAndTry(WCHAR * pFormat, WCHAR *pData, WCHAR *pCheck, unsigned __int64 & ui8)
{
    static WCHAR wTemp[100];
    if(swscanf(pData, pFormat, &ui8) != 1)
        return FALSE;
    swprintf(wTemp,pFormat, ui8);
    return !wbem_wcsicmp(wTemp, pCheck);
}


CMoValue::CAlias::CAlias(COPY LPCWSTR wszAlias, int nArrayIndex)
{
    m_nArrayIndex = nArrayIndex;
    m_wszAlias = Macro_CloneStr(wszAlias);
}

CMoValue::CAlias::~CAlias()

{
    delete [] m_wszAlias;
}


CMoValue::CMoValue(PDBG pDbg)
{
	m_pDbg = pDbg;
    m_vType = 0;
    VariantInit(&m_varValue);
}

CMoValue::~CMoValue()
{
	if(m_varValue.vt == VT_EMBEDDED_OBJECT)
	{
#ifdef _WIN64
		CMObject * pObj = (CMObject *)m_varValue.llVal;
#else
		CMObject * pObj = (CMObject *)m_varValue.lVal;
#endif
		if(pObj)
			delete pObj;
		m_varValue.vt = VT_NULL;
	}
	else if(m_varValue.vt == (VT_EMBEDDED_OBJECT | VT_ARRAY))
	{
		SCODE sc ;
		SAFEARRAY * psaSrc = m_varValue.parray;
		if(psaSrc == NULL)
			return;
        long lLBound, lUBound;
        sc = SafeArrayGetLBound(psaSrc, 1, &lLBound);
        sc |= SafeArrayGetUBound(psaSrc, 1, &lUBound);
		if(sc != S_OK)
			return; 

        for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
        {
            // Load the initial data element into a VARIANT
            // ============================================
			CMObject * pObj;

             sc = SafeArrayGetElement(psaSrc, &lIndex, &pObj);
			if(sc == S_OK && pObj)
				delete pObj;
		}
		SafeArrayDestroy(psaSrc);
		m_varValue.vt = VT_NULL;

	}
    if((m_varValue.vt & ~	VT_ARRAY) != VT_EMBEDDED_OBJECT)
        VariantClear(&m_varValue);

    for(int i = 0; i < m_aAliases.GetSize(); i++)
    {
        delete (CAlias*)m_aAliases[i];
    }
}

BOOL CMoValue::GetAlias(IN int nAliasIndex,
                        OUT INTERNAL LPWSTR& wszAlias,
                        OUT int& nArrayIndex)
{
    if(nAliasIndex >= m_aAliases.GetSize()) return FALSE;

    CAlias* pAlias = (CAlias*)m_aAliases[nAliasIndex];
    wszAlias = pAlias->m_wszAlias;
    nArrayIndex = pAlias->m_nArrayIndex;

    return TRUE;
}

HRESULT CMoValue::AddAlias(COPY LPCWSTR wszAlias, int nArrayIndex)
{
    CAlias* pAlias = new CAlias(wszAlias, nArrayIndex);
    if(pAlias == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    if(pAlias->m_wszAlias == NULL && wszAlias != NULL)
    {
        delete pAlias;
        return WBEM_E_OUT_OF_MEMORY;
    }
    m_aAliases.Add(pAlias);
    return S_OK;
}

//*****************************************************************************

CMoProperty::CMoProperty(CMoQualifierArray * paQualifiers, PDBG pDbg) : m_Value(pDbg)
{
	m_pDbg = pDbg;
    m_wszName = NULL;
	m_wszTypeTitle = NULL;
    m_paQualifiers = paQualifiers;
}

HRESULT CMoProperty::SetPropName(COPY LPCWSTR wszName)
{
    delete [] m_wszName;
    m_wszName = Macro_CloneStr(wszName);
    if(m_wszName == NULL && wszName != NULL )
        return WBEM_E_OUT_OF_MEMORY;
    else
        return S_OK;
}
HRESULT CMoProperty::SetTypeTitle(COPY LPCWSTR wszName)
{
	delete [] m_wszTypeTitle;
    m_wszTypeTitle = Macro_CloneStr(wszName);
    if(m_wszTypeTitle == NULL && wszName != NULL)
        return WBEM_E_OUT_OF_MEMORY;
    else
        return S_OK;
}

void CMoProperty::SetQualifiers(ACQUIRE CMoQualifierArray* pQualifiers)
{
    delete m_paQualifiers;
    m_paQualifiers = pQualifiers;
}

IWbemClassObject * CMoProperty::GetInstPtr(const WCHAR * pClassName,  IWbemServices* pNamespace, CMObject * pMo, 
                                           IWbemContext * pCtx)
{
	IWbemClassObject *pInst = NULL;
    SCODE sc;

  	BSTR bstr = SysAllocString(pClassName);
    if(bstr == NULL)
	    return NULL;
	CSysFreeMe fm(bstr);
    if(!wbem_wcsicmp(L"__PARAMETERS", pClassName))
    {
        sc = pNamespace->GetObject(bstr, 0, pCtx, &pInst, NULL);
    }
    else if(pMo->IsInstance())
    {
    	IWbemClassObject *pClass = NULL;
	    sc = pNamespace->GetObject(bstr, 0, pCtx, &pClass, NULL);
	    if(sc != S_OK)
		    return NULL;
	    sc = pClass->SpawnInstance(0, &pInst);
        pClass->Release();
    }
	else
	{
		// got a class, not an instance!

        CMoClass * pClass = (CMoClass * )pMo;
        if(pClass->GetParentName() && wcslen(pClass->GetParentName()) > 0)
        {
            IWbemClassObject * pParent = NULL;
            BSTR bstrParent = SysAllocString(pClass->GetParentName());
            if(bstrParent == NULL)
                return NULL;
            CSysFreeMe fm2(bstrParent);
	        sc = pNamespace->GetObject(bstrParent, 0, pCtx, &pParent, NULL);
            if(FAILED(sc))
                return NULL;
            CReleaseMe rm(pParent);
            sc = pParent->SpawnDerivedClass(0, &pInst);
            if(FAILED(sc))
                return NULL;
        }
        else
	        sc = pNamespace->GetObject(NULL, 0, pCtx, &pInst, NULL);
	    if(sc != S_OK)
		    return NULL;
		VARIANT var;
		var.vt = VT_BSTR;
		var.bstrVal = bstr;
		pInst->Put(L"__CLASS", 0, &var, 0);
	}
    if(sc != S_OK)
		    return NULL;

	BOOL bOK = pMo->ApplyToWbemObject(pInst,pNamespace,pCtx);

    if(bOK)
        return pInst;
    else
    {
        pInst->Release();
        return NULL;
    }

}

BOOL CValueProperty::AddEmbeddedObject(OLE_MODIFY IWbemClassObject* pObject, IWbemServices* pNamespace, IWbemContext * pCtx)
{
    VARIANT & var = m_Value.AccessVariant();
	VARIANT vSet;
	IWbemClassObject * pInst = NULL;

	if(var.vt & VT_ARRAY)
	{
		vSet.vt = VT_EMBEDDED_OBJECT | VT_ARRAY;
        SAFEARRAYBOUND aBounds[1];

        long lLBound, lUBound;
        SafeArrayGetLBound(var.parray, 1, &lLBound);
        SafeArrayGetUBound(var.parray, 1, &lUBound);

        aBounds[0].cElements = lUBound - lLBound + 1;
        aBounds[0].lLbound = lLBound;

        vSet.parray = SafeArrayCreate(VT_EMBEDDED_OBJECT & ~VT_ARRAY, 1, aBounds);
		if(vSet.parray == NULL)
			return FALSE;

        // Stuff the individual data pieces
        // ================================

        for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
        {
            // Load the initial data element into a VARIANT
            // ============================================
			
			CMObject * pTemp;
            SCODE hres = SafeArrayGetElement(var.parray, &lIndex, &pTemp);
          	if(FAILED(hres) || pTemp == FALSE) 
            {
                SafeArrayDestroy(vSet.parray);
                return FALSE;
            }
            // Cast it to the new type
            // =======================

			pInst = GetInstPtr(pTemp->GetClassName(), pNamespace, pTemp, pCtx);
       		if(pInst == NULL) 
			{
				Trace(true, m_pDbg, ALIAS_PROP_ERROR, m_wszName);
                SafeArrayDestroy(vSet.parray);
				return FALSE;
			}

			// Put it into the new array
			// =========================

			hres = SafeArrayPutElement(vSet.parray, &lIndex, pInst);


			pInst->Release();
          	if(FAILED(hres)) 
            {
                SafeArrayDestroy(vSet.parray);
                return FALSE;
            }
        }
	}
	else
	{
		CMObject * pTemp = (CMObject *)var.punkVal;
		pInst = GetInstPtr(pTemp->GetClassName(), pNamespace, pTemp, pCtx);
		if(pInst == NULL)
		{
			Trace(true, m_pDbg, ALIAS_PROP_ERROR, m_wszName);
			return FALSE;
		}
        vSet.punkVal = pInst;
		vSet.vt = VT_EMBEDDED_OBJECT;
	}
	HRESULT hres = pObject->Put(m_wszName, 0, &vSet, 0);

    // Release all the WbemObjects we have created
    // ==========================================

	if(var.vt & VT_ARRAY)
		SafeArrayDestroy(vSet.parray);
    else if(pInst)
		pInst->Release();
	return hres == S_OK;
}

BOOL CValueProperty::AddToObject(OLE_MODIFY IWbemClassObject* pObject, IWbemServices* pNamespace, 
                                 BOOL bClass, IWbemContext * pCtx)
{
    if(m_wszName == NULL) return FALSE;

    m_pDbg->SetString(m_wszName);

    // Get the property value
    // ======================

	VARIANT & var = m_Value.AccessVariant();

	// Determine if this is an embedded object.

	VARTYPE vtSimple = var.vt & ~VT_ARRAY;
	if(vtSimple == VT_NULL)
		vtSimple = m_Value.GetType() & ~VT_ARRAY;

    // If the type is embedded object, make sure the class name is OK.

	if(vtSimple == VT_EMBEDDED_OBJECT)
	{
		// Determine the class name of the embedded object.

		CMoValue * pValue = m_paQualifiers->Find(L"CIMTYPE");
		if(pValue)
		{
			if(var.vt == VT_BSTR && wcslen(var.bstrVal) > wcslen(L"Object:"))
			{

				// Test if this class if valid by doing a GetObject call

				WCHAR * pClassName = var.bstrVal + wcslen(L"Object:");
				IWbemClassObject *pClass = NULL;
				BSTR bstr = SysAllocString(pClassName);
				if(bstr == NULL)
					return FALSE;
				SCODE sc = pNamespace->GetObject(bstr, 0, pCtx,&pClass, NULL);
				SysFreeString(bstr);
				if(sc != S_OK)
				{
					m_pDbg->hresError = WBEM_E_INVALID_PROPERTY_TYPE;
					Trace(true, m_pDbg, BAD_PROP_TYPE, GetName());
					return FALSE;
				}
				pClass->Release();
			}
		}
    }

	// If there is an actual embedded object, store it.

   	if((var.vt & ~VT_ARRAY) == VT_EMBEDDED_OBJECT)
    {
        if(!AddEmbeddedObject(pObject, pNamespace, pCtx))
			return FALSE;
		return GetQualifiers()->AddToPropOrMeth(pObject, m_wszName, bClass, TRUE);
	}

    VARTYPE vNewType = m_Value.GetType();

    // arguments cannot be VT_EMPTY

    if(m_bIsArg && var.vt == VT_EMPTY)
        var.vt = VT_NULL;

    // Set the property value.  Not that reference types are a special case used by binary mofs
    // and so the flag should be eliminated.
    // ======================

    vNewType &= ~VT_BYREF;
    HRESULT hres = pObject->Put(m_wszName, 0, &var, (bClass || m_bIsArg) ? vNewType : 0);
    if(FAILED(hres))
    {
        m_pDbg->hresError = hres;
        return FALSE;
    }

    // Configure the qualifier set
    // ===========================

    if(!GetQualifiers()->AddToPropOrMeth(pObject, m_wszName, bClass, TRUE))
    {
        return FALSE;
    }

    // Get the syntax value
    // ====================


//    VariantClear(&vNew);
//    VariantClear(&v);    
    return TRUE;
}

BOOL CValueProperty::RegisterAliases(MODIFY CMObject* pObject)
{
    // Copy all alias registrations into the object
    // ============================================

	int iNumAlias = m_Value.GetNumAliases();
    for(int i = 0; i < iNumAlias; i++)
    {
        LPWSTR wszAlias;
        int nArrayIndex;
        m_Value.GetAlias(i, wszAlias, nArrayIndex);
        CPropertyLocation * pNew = new CPropertyLocation(m_wszName, nArrayIndex);
        if(pNew == NULL)
            return FALSE;
        if(pNew->IsOK() == false)
        {
            delete pNew;
            return FALSE;
        }
        HRESULT hr = pObject->AddAliasedValue(pNew,  wszAlias);
        if(FAILED(hr))
            return FALSE;
    }

    // Ask the qualifier set to do the same
    // ====================================

    if(m_paQualifiers)
        GetQualifiers()->RegisterAliases(pObject, m_wszName);

    return TRUE;
}

CMoProperty::~CMoProperty()
{
    if(m_paQualifiers)
        delete m_paQualifiers;
    if(m_wszName)
        delete [] m_wszName;
    if(m_wszTypeTitle)
        delete [] m_wszTypeTitle;
}

//*****************************************************************************

CMoQualifier::CMoQualifier(PDBG pDbg) : m_Value(pDbg)
{
    m_pDbg = pDbg;
    m_wszName = NULL;
    m_lFlavor = 0;
    m_bOverrideSet = false;
    m_bNotOverrideSet = false;
    m_bIsRestricted = false;
    m_bNotToInstance = false;
    m_bToInstance = false;
    m_bNotToSubclass = false;
    m_bToSubclass = false;
    m_bAmended = false;
    m_dwScope = 0;
    m_bCimDefaultQual = false;
    m_bUsingDefaultValue = false;

}

CMoQualifier::~CMoQualifier()
{
    if(m_wszName)
        delete [] m_wszName;
}

HRESULT CMoQualifier::SetFlag(int iToken, LPCWSTR pwsText)
{

    if(iToken == TOK_TOINSTANCE)
    {
        if(m_bIsRestricted || m_bNotToInstance)
            return WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2;
        m_lFlavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
        m_bToInstance = true;
    }
    else if(iToken == TOK_TOSUBCLASS)
    {
        if(m_bIsRestricted || m_bNotToSubclass)
            return WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2;
        m_lFlavor |= WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
        m_bToSubclass = true;
    }
    else if(iToken == TOK_NOTTOINSTANCE)
    {
        if(m_bToInstance)
            return WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2;
        m_lFlavor &= ~WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE;
        m_bNotToInstance = true;
    }
    else if(iToken == TOK_NOTTOSUBCLASS)
    {
        if(m_bToSubclass)
            return WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2;
        m_lFlavor &= ~WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS;
        m_bNotToSubclass = true;
    }
    else if(iToken == TOK_ENABLEOVERRIDE)
    {
        if(m_bNotOverrideSet)
            return WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2;
        m_lFlavor &= ~WBEM_FLAVOR_NOT_OVERRIDABLE;
        m_bOverrideSet = true;
    }
    else if(iToken == TOK_DISABLEOVERRIDE)
    {
        if(m_bOverrideSet)
            return WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2;
        m_bNotOverrideSet = true;
        m_lFlavor |= WBEM_FLAVOR_NOT_OVERRIDABLE;
    }
    else if(iToken == TOK_RESTRICTED)
    {      
        if(m_bToInstance || m_bToSubclass)
            return WBEMMOF_E_INCOMPATIBLE_FLAVOR_TYPES2;
        m_bIsRestricted = true;
        m_lFlavor &= ~WBEM_FLAVOR_MASK_PROPAGATION;
    }
    else if(iToken == TOK_AMENDED)
    {      
        m_bAmended = true;
    }
    else if(iToken == TOK_SIMPLE_IDENT && !wbem_wcsicmp(L"translatable", pwsText))
    {
	    return S_OK;    // WBEMMOF_E_UNSUPPORTED_CIMV22_FLAVOR_TYPE;
    }

    else
        return WBEMMOF_E_EXPECTED_FLAVOR_TYPE;
    return S_OK;
}

BOOL CMoQualifier::SetScope(int iToken, LPCWSTR pwsText)
{
    if(iToken == TOK_SIMPLE_IDENT && !wbem_wcsicmp(pwsText, L"ANY"))
    {
        m_dwScope |= 0XFFFFFFFF; 
        return TRUE;
    }
    if(iToken == TOK_SIMPLE_IDENT && !wbem_wcsicmp(pwsText, L"ASSOCIATION"))
    {
        m_dwScope |= SCOPE_ASSOCIATION; 
        return TRUE;
    }
    if(iToken == TOK_CLASS)
    {
        m_dwScope |= SCOPE_CLASS;
        return TRUE;
    }
    if(iToken == TOK_SIMPLE_IDENT && !wbem_wcsicmp(pwsText, L"indication"))
    {
        ERRORTRACE((LOG_MOFCOMP,"Warning, unsupported INDICATION keyword used in scope\n"));
        return TRUE;            // IGNORE THESE
    }
    if(iToken == TOK_SIMPLE_IDENT && !wbem_wcsicmp(pwsText, L"schema"))
    {
        ERRORTRACE((LOG_MOFCOMP,"Warning, unsupported SCHEMA keyword used in scope\n"));
        return TRUE;            // IGNORE THESE
    }
    if(iToken == TOK_INSTANCE)
    {
        m_dwScope |= SCOPE_INSTANCE;
        return TRUE;
    }
    if(iToken == TOK_SIMPLE_IDENT && !wbem_wcsicmp(pwsText, L"METHOD"))
    {
        m_dwScope |= SCOPE_METHOD; 
        return TRUE;
    }
    if(iToken == TOK_SIMPLE_IDENT && !wbem_wcsicmp(pwsText, L"PARAMETER"))
    {
        m_dwScope |= SCOPE_PARAMETER; 
        return TRUE;
    }
    if(iToken == TOK_SIMPLE_IDENT && !wbem_wcsicmp(pwsText, L"PROPERTY"))
    {
        m_dwScope |= SCOPE_PROPERTY;
        return TRUE;
    }
    if(iToken == TOK_SIMPLE_IDENT && !wbem_wcsicmp(pwsText, L"REFERENCE"))
    {
        m_dwScope |= SCOPE_REFERENCE; 
        return TRUE;
    }
    return FALSE;
}

HRESULT CMoQualifier::SetQualName(COPY LPCWSTR wszName)
{
    delete [] m_wszName;
    m_wszName = Macro_CloneStr(wszName);
    if(m_wszName == NULL && wszName != NULL)
        return WBEM_E_OUT_OF_MEMORY;
    else
        return S_OK;
}


BOOL CMoQualifier::AddToSet(OLE_MODIFY IWbemQualifierSet* pQualifierSet,
                            BOOL bClass)
{
    BSTR strName = SysAllocString(m_wszName);
    if(strName == NULL)
    {
        return FALSE;
    }    

    m_pDbg->SetString(strName);

    HRESULT hres = pQualifierSet->Put(
        strName,
        &m_Value.AccessVariant(),GetFlavor());
    if(FAILED(hres))
    {
        m_pDbg->hresError = hres;
        return FALSE;
    }

    SysFreeString(strName);

    return SUCCEEDED(hres);
}


INTERNAL CMoValue* CMoQualifierArray::Find(READ_ONLY LPCWSTR wszName)
{
    for(int i = 0; i < GetSize(); i++)
    {
        CMoQualifier* pQual = GetAt(i);
        if(!wbem_wcsicmp(pQual->GetName(), wszName))
        {
            return &pQual->AccessValue();
        }
    }

    return NULL;
}

BOOL CMoQualifierArray::Add(ACQUIRE CMoQualifier* pQualifier)
{
    // before adding a qualifier, check for a duplicate name.

    if(pQualifier == NULL || pQualifier->GetName() == NULL)
        return FALSE;
    CMoValue * pValue = Find(pQualifier->GetName());
    if(pValue != NULL)
        return FALSE; 

    m_aQualifiers.Add(pQualifier);
    return TRUE;
}
    
//*****************************************************************************

CMoQualifierArray::~CMoQualifierArray()
{
    for(int i = 0; i < GetSize(); i++)
    {
        delete GetAt(i);
    }
}
BOOL CMoQualifierArray::AddToSet(OLE_MODIFY IWbemQualifierSet* pQualifierSet,
                                 BOOL bClass)
{
    // Add all the qualifiers to it
    // ============================
    for(int i = 0; i < GetSize(); i++)
    {
        if(!GetAt(i)->AddToSet(pQualifierSet, bClass)) return FALSE;
    }

    return TRUE;
}

BOOL CMoQualifierArray::RegisterAliases(MODIFY CMObject* pObject,
                                        READ_ONLY LPCWSTR wszPropName)
{
    for(int i = 0; i < GetSize(); i++)
    {
        CMoValue& QualifierValue = GetAt(i)->AccessValue();
        LPCWSTR wszName = GetAt(i)->GetName();

        for(int j = 0; j < QualifierValue.GetNumAliases(); j++)
        {
            LPWSTR wszAlias;
            int nArrayIndex;
            QualifierValue.GetAlias(j, wszAlias, nArrayIndex);
            VARIANT  & Var = QualifierValue.AccessVariant();
            if((Var.vt & VT_ARRAY) == 0)
                nArrayIndex = -1;
            CQualifierLocation * pNew = new CQualifierLocation(wszName, m_pDbg, wszPropName, nArrayIndex);
            if(pNew == NULL)
                return FALSE;
            if(pNew->IsOK() == false)
            {
                delete pNew;
                return FALSE;
            }
            HRESULT hr = pObject->AddAliasedValue(pNew , wszAlias);
            if(FAILED(hr))
                return FALSE;
        }
    }

    return TRUE;
}

BOOL CMoQualifierArray::AddToObject(OLE_MODIFY IWbemClassObject* pObject,
                                    BOOL bClass)
{
    // Get the qualifier set from the object
    // =====================================

    IWbemQualifierSet* pQualifierSet;
    if(FAILED(pObject->GetQualifierSet(&pQualifierSet)))
    {
        return FALSE;
    }

    // Add all qualifiers to it
    // ========================

    BOOL bRes = AddToSet(pQualifierSet, bClass);
    pQualifierSet->Release();

    return bRes;
}

BOOL CMoQualifierArray::AddToPropOrMeth(OLE_MODIFY IWbemClassObject* pObject,
                                      READ_ONLY LPCWSTR wszName,
                                      BOOL bClass, BOOL bProp)
{
    // Get the qualifier set
    // =====================

    BSTR strName = SysAllocString(wszName);
    if(strName == NULL)
    {
        return FALSE;
    }
            
    IWbemQualifierSet* pQualifierSet;
    SCODE sc;
    if(bProp)
        sc = pObject->GetPropertyQualifierSet(strName, &pQualifierSet);
    else
        sc = pObject->GetMethodQualifierSet(strName, &pQualifierSet);
    SysFreeString(strName);

    if(FAILED(sc))
        return FALSE;

    // Add qualifiers to it
    // ====================

    BOOL bRes = AddToSet(pQualifierSet, bClass);
    pQualifierSet->Release();

    return bRes;
}


//*****************************************************************************

CMoType::~CMoType()
{
    delete m_wszTitle;
}

HRESULT CMoType::SetTitle(COPY LPCWSTR wszTitle)
{
    delete [] m_wszTitle;
    m_wszTitle = Macro_CloneStr(wszTitle);
    if(m_wszTitle == NULL && wszTitle != NULL)
        return WBEM_E_OUT_OF_MEMORY;
    else
        return S_OK;
}

VARTYPE CMoType::GetCIMType()
{
    if(IsRef() && IsArray()) return CIM_REFERENCE | VT_ARRAY;
    if(IsRef()) return CIM_REFERENCE;
    if(IsEmbedding() && IsArray()) return VT_EMBEDDED_OBJECT | VT_ARRAY;
    if(IsEmbedding()) return VT_EMBEDDED_OBJECT;

    VARTYPE vt_array = (IsArray())?VT_ARRAY:0;

    // Check if it is even initialized
    // ===============================

    if(m_wszTitle == NULL)
    {
        return VT_BSTR; // HACK! string converts nicely into just about anything
    }

    // VT_UI1

    if(!wbem_wcsicmp(m_wszTitle, L"sint8"))
         return CIM_SINT8 | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"uint8"))
         return CIM_UINT8 | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"sint16"))
         return CIM_SINT16 | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"uint16"))
         return CIM_UINT16 | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"sint32"))
         return CIM_SINT32 | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"uint32"))
         return CIM_UINT32 | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"sint64"))
         return CIM_SINT64 | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"uint64"))
         return CIM_UINT64 | vt_array;


    // VT_R4

    if (!wbem_wcsicmp(m_wszTitle, L"real32"))
        return CIM_REAL32 | vt_array;
    if (!wbem_wcsicmp(m_wszTitle, L"real64"))
        return CIM_REAL64 | vt_array;

    // Do other types

    if(!wbem_wcsicmp(m_wszTitle, L"BOOLEAN"))
        return CIM_BOOLEAN | vt_array;


    if(!wbem_wcsicmp(m_wszTitle, L"string"))
        return CIM_STRING | vt_array;

    if(!wbem_wcsicmp(m_wszTitle, L"datetime"))
        return CIM_DATETIME | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"REF"))
        return CIM_REFERENCE | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"CHAR16"))
        return CIM_CHAR16 | vt_array;
    if(!wbem_wcsicmp(m_wszTitle, L"OBJECT"))
        return CIM_OBJECT | vt_array;

    
    if(!wbem_wcsicmp(m_wszTitle, L"void") || 
        !wbem_wcsicmp(m_wszTitle, L"null"))
        return VT_NULL;

    if(!_wcsnicmp(m_wszTitle, L"REF:", 4))
        return CIM_REFERENCE | vt_array;
    if(!_wcsnicmp(m_wszTitle, L"OBJECT:", 7))
        return CIM_OBJECT | vt_array;

    return VT_ERROR;
}

bool CMoType::IsUnsupportedType()
{
    if(m_wszTitle == NULL)
    {
        return false;
    }

    if(!wbem_wcsicmp(m_wszTitle, L"dt_sint8"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_uint8"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_sint16"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_uint16"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_sint32"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_uint32"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_sint64"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_uint64"))
         return true;
    if (!wbem_wcsicmp(m_wszTitle, L"dt_real32"))
         return true;
    if (!wbem_wcsicmp(m_wszTitle, L"dt_real64"))
         return true;
    if (!wbem_wcsicmp(m_wszTitle, L"dt_char16"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_BOOL"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_str"))
         return true;
    if(!wbem_wcsicmp(m_wszTitle, L"dt_datetime"))
         return true;
    return false;
}

BOOL CMoType::StoreIntoQualifiers(CMoQualifierArray * pQualifiers)
{
    if(pQualifiers == NULL)
        return FALSE;
    if(IsRef() ||IsEmbedding())
    {
        WCHAR * pFormat = (IsRef()) ? L"ref" : L"object";

        if(wbem_wcsicmp(m_wszTitle, L"object") == 0)
        {
            pQualifiers->Add(CreateSyntax(pFormat));
        }
        else
        {
            LPWSTR wszSyntax = new WCHAR[wcslen(m_wszTitle) + 20];
            if(wszSyntax == NULL)
                return FALSE;
            swprintf(wszSyntax, L"%s:%s",pFormat, m_wszTitle);

            pQualifiers->Add(CreateSyntax(wszSyntax));
            delete [] wszSyntax;
        }

        return TRUE;
    }

    pQualifiers->Add(CreateSyntax(m_wszTitle));
    return TRUE;
}

DELETE_ME CMoQualifier* CMoType::CreateSyntax(READ_ONLY LPCWSTR wszSyntax)
{
    CMoQualifier* pQualifier = new CMoQualifier(m_pDbg);
    if(pQualifier == NULL)
        return NULL;
    if(FAILED(pQualifier->SetQualName(L"CIMTYPE")))
    {
        delete pQualifier;
        return NULL;
    }
    pQualifier->SetFlavor(WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE |
        WBEM_FLAVOR_FLAG_PROPAGATE_TO_DERIVED_CLASS);

    BSTR bstrVal = SysAllocString(wszSyntax);
    if(bstrVal == NULL)
    {
        delete pQualifier;
        return NULL;
    }
    V_VT(&pQualifier->AccessValue().AccessVariant()) = VT_BSTR;
    V_BSTR(&pQualifier->AccessValue().AccessVariant()) = bstrVal;

    return pQualifier;
}

//*****************************************************************************

HRESULT CValueLocation::SetArrayElement(
                                        MODIFY VARIANT& vArray,
                                        int nIndex,
                                        READ_ONLY VARIANT& vValue)
{
    if(V_VT(&vArray) != (VT_ARRAY | VT_BSTR)) return WBEM_E_FAILED;
  //  if(V_VT(&vArray) != (VT_ARRAY | VT_VARIANT)) return WBEM_E_FAILED;

    SAFEARRAY* pSafeArray = V_ARRAY(&vArray);
    long lLowerBound;
    if(FAILED(SafeArrayGetLBound(pSafeArray, 1, &lLowerBound)))
        return WBEM_E_FAILED;

    long lActualIndex = lLowerBound + nIndex;

    // Set the value in the array
    // ==========================

    if(FAILED(SafeArrayPutElement(pSafeArray,
                                    (long*)&lActualIndex,
                                    (void*)vValue.bstrVal)))
    {
        return WBEM_E_FAILED;
    }

    return WBEM_NO_ERROR;
}

//*****************************************************************************

CPropertyLocation::CPropertyLocation(COPY LPCWSTR wszName, int nArrayIndex)
{
    m_bOK = true;
    m_wszName = Macro_CloneStr(wszName);
    if(m_wszName == NULL && wszName != NULL)
        m_bOK = false;
    m_nArrayIndex = nArrayIndex;
}

CPropertyLocation::~CPropertyLocation()
{
    if(m_wszName)
        delete m_wszName;
}

HRESULT CPropertyLocation::Set(READ_ONLY VARIANT& varValue,
                OLE_MODIFY IWbemClassObject* pObject)
{
    if(m_nArrayIndex == -1)
    {
        // Not an array index. Simply set the property
        // ===========================================

        return pObject->Put(m_wszName, 0, &varValue, 0);
    }
    else
    {
        // Array index. Get the value
        // ==========================

        VARIANT vArray;
        VariantInit(&vArray);
        HRESULT hres = pObject->Get(m_wszName, 0, &vArray, NULL, NULL);
        if(FAILED(hres)) return hres;

        // Set the value
        // =============

        if(FAILED(SetArrayElement(vArray, m_nArrayIndex, varValue)))
            return WBEM_E_FAILED;

        // Store the whole array back into the property
        // ============================================

        hres = pObject->Put(m_wszName, 0, &vArray, 0);
        VariantClear(&vArray);

        return hres;
    }
}

//*****************************************************************************

CQualifierLocation::CQualifierLocation(COPY LPCWSTR wszName,PDBG pDbg,
                                       COPY LPCWSTR wszPropName,
                                       int nArrayIndex)
{
    m_bOK = true;
    m_pDbg = pDbg;
    if(wszName)
        m_wszName = Macro_CloneStr(wszName);
    else
        m_wszName = NULL;
    if(m_wszName == NULL && wszName != NULL)
        m_bOK = false;

    if(wszPropName != NULL) 
        m_wszPropName = Macro_CloneStr(wszPropName);
    else 
        m_wszPropName = NULL;
    if(m_wszPropName == NULL && wszPropName != NULL)
        m_bOK = false;

    m_nArrayIndex = nArrayIndex;
}

CQualifierLocation::~CQualifierLocation()
{
    if(m_wszName)
        delete m_wszName;
    if(m_wszPropName)
        delete m_wszPropName;
}

HRESULT CQualifierLocation::Set(READ_ONLY VARIANT& varValue,
                                OLE_MODIFY IWbemClassObject* pObject)
{
    HRESULT hres;
    long lOrigFlavor= 0;

    if(pObject == NULL)
        return WBEM_E_INVALID_PARAMETER;

    // Get the qualifier set for either the property or the object
    // ===========================================================

    IWbemQualifierSet* pQualifierSet;
    if(m_wszPropName == NULL)
    {
        hres = pObject->GetQualifierSet(&pQualifierSet);
    }
    else
    {
        hres = pObject->GetPropertyQualifierSet(m_wszPropName, &pQualifierSet);
    }

    if(FAILED(hres)) 
        return hres;

    // Get the qualifier value (need it for the type in either case)
    // =============================================================

    VARIANT vQualifierVal;
    VariantInit(&vQualifierVal);

    hres = pQualifierSet->Get(m_wszName, 0, &vQualifierVal, &lOrigFlavor);
    if(FAILED(hres)) return hres;

    // Check if array is involved
    // ==========================

    if(m_nArrayIndex == -1)
    {
        // Just set the qualifier value
        // ============================

        hres = pQualifierSet->Put(m_wszName, &varValue, lOrigFlavor);
    }
    else
    {
        // Set the appropriate array element
        // =================================

        if(FAILED(SetArrayElement(vQualifierVal, m_nArrayIndex, varValue)))
            return WBEM_E_FAILED;

        // Store the value back
        // ====================

        hres = pQualifierSet->Put(m_wszName, &vQualifierVal, lOrigFlavor);
        if(FAILED(hres))
        {
            m_pDbg->hresError = FALSE;
            return hres;
        }
    }

    pQualifierSet->Release();
    VariantClear(&vQualifierVal);
    return hres;
}


//*****************************************************************************

CMObject::CAliasedValue::CAliasedValue(
                                       ACQUIRE CValueLocation* _pLocation,
                                       COPY LPCWSTR _wszAlias)
{
    pLocation = _pLocation;
    wszAlias = Macro_CloneStr(_wszAlias);
}

CMObject::CAliasedValue::~CAliasedValue()
{
    delete pLocation;
    delete [] wszAlias;
}

CMObject::CMObject()
{
    m_wszAlias = NULL;
    m_wszNamespace = NULL;
    m_paQualifiers = NULL;
    m_wszFullPath = NULL;
    m_nFirstLine = 0;
    m_nLastLine = 0;
    m_lDefClassFlags = 0;
    m_lDefInstanceFlags = 0;
    m_bDone = FALSE;
    m_pWbemObj = NULL;
    m_bParameter = false;
    m_bAmended = false;
    m_wFileName = NULL;
    m_bDeflated = false;
    m_bOK =  true;
}

HRESULT CMObject::Deflate(bool bDestruct)
{
    if(!bDestruct && (m_wszAlias || GetNumAliasedValues() > 0))
    {
        return S_OK;
    }
    m_bDeflated = true;
	if(m_paQualifiers)
	{
		for(int i = 0; i < m_paQualifiers->GetSize(); i++)
		{
			CMoQualifier * pQual = (CMoQualifier *) m_paQualifiers->GetAt(i);
			delete pQual;
		}
		m_paQualifiers->RemoveAll();
	}
    for(int i = 0; i < m_aProperties.GetSize(); i++)
    {
        CMoProperty * pProp = (CMoProperty *) m_aProperties[i];

        // If this is an parameter object (in argument or out arguement), dont delete any embedded
        // objects since they will be delete as the CMethodParameter is cleaned out

        if(m_bParameter)
        {
            VARIANT * pVar = pProp->GetpVar();
            if(pVar->vt & VT_UNKNOWN)
                pVar->vt = VT_I4;
        }
        delete pProp;
    }
    m_aProperties.RemoveAll();
    return S_OK;
}

HRESULT CMObject::Reflate(CMofParser & Parser)
{
    if(!m_bDeflated)
        return S_OK;

    if(IsInstance())
        Parser.SetState(REFLATE_INST);
    else
        Parser.SetState(REFLATE_CLASS);

    Parser.SetParserPosition(&m_QualState);
    if (!Parser.qualifier_decl(*m_paQualifiers, true, CLASSINST_SCOPE))
		return WBEM_E_FAILED;

    Parser.SetParserPosition(&m_DataState);
    if(IsInstance())
    {
        Parser.NextToken();
        Parser.prop_init_list(this);
    }
    else
    {
        Parser.NextToken();
        Parser.property_decl_list(this);
    }
    m_bDeflated = false;
    return S_OK;

}


CMObject::~CMObject()
{
    if(m_wszAlias)
        delete [] m_wszAlias;
    if(m_wszNamespace)
        delete [] m_wszNamespace;
    if(m_wszFullPath)
        delete [] m_wszFullPath;
    if(m_pWbemObj)
        m_pWbemObj->Release();
    Deflate(true);
    if(m_paQualifiers)
        delete m_paQualifiers;

    int i;
    for(i = 0; i < m_aAliased.GetSize(); i++)
    {
        delete (CAliasedValue*)m_aAliased[i];
    }

    delete [] m_wFileName;
}

void CMObject::FreeWbemObjectIfPossible()
{
    if(m_wszAlias == NULL && m_pWbemObj)
    {
        m_pWbemObj->Release();
        m_pWbemObj = NULL;
    }
}

HRESULT CMObject::SetAlias(COPY LPCWSTR wszAlias)
{
    delete [] m_wszAlias;
    m_wszAlias = Macro_CloneStr(wszAlias);
    if(m_wszAlias == NULL && wszAlias != NULL)
        return WBEM_E_OUT_OF_MEMORY;
    else
        return S_OK;
}

HRESULT CMObject::SetNamespace(COPY LPCWSTR wszNamespace)
{
    delete [] m_wszNamespace;
    m_wszNamespace = Macro_CloneStr(wszNamespace);
    if(m_wszNamespace == NULL && wszNamespace != NULL)
        return WBEM_E_OUT_OF_MEMORY;
    else
        return S_OK;
}

HRESULT CMObject::SetLineRange(int nFirstLine, int nLastLine, WCHAR * pFileName)
{
    m_nFirstLine = nFirstLine;
    m_nLastLine = nLastLine;
    m_wFileName = Macro_CloneStr(pFileName);
    if(m_wFileName == NULL && pFileName != NULL)
        return WBEM_E_OUT_OF_MEMORY;
    else
        return S_OK;
}

void CMObject::SetQualifiers(ACQUIRE CMoQualifierArray* pQualifiers)
{
    delete m_paQualifiers;
    m_paQualifiers = pQualifiers;
    pQualifiers->RegisterAliases(this, NULL);
}

BOOL CMObject::AddProperty(ACQUIRE CMoProperty* pProperty)
{
    // Check if the property has already been specified
    // ================================================

    for(int i = 0; i < m_aProperties.GetSize(); i++)
    {
        CMoProperty* pCurrentProp = (CMoProperty*)m_aProperties[i];
        if(!wbem_wcsicmp(pCurrentProp->GetName(), pProperty->GetName()))
        {
            return FALSE;
        }
    }
    
    m_aProperties.Add(pProperty);
    pProperty->RegisterAliases(this);
    return TRUE;
}


BOOL CMObject::GetAliasedValue(IN int nIndex,
                              OUT INTERNAL LPWSTR& wszAlias)
{
    if(nIndex >= m_aAliased.GetSize())
    {
        return FALSE;
    }

    CAliasedValue* pValue = (CAliasedValue*)m_aAliased[nIndex];
    wszAlias = pValue->wszAlias;

    return TRUE;
}

BOOL CMObject::ResolveAliasedValue(IN int nIndex,
                                   READ_ONLY LPCWSTR wszPath,
                                   OLE_MODIFY IWbemClassObject* pObject)
{
    CAliasedValue* pValue = (CAliasedValue*)m_aAliased[nIndex];

    // Construct the variant with the value
    // ====================================

    VARIANT v;
    VariantInit(&v);
    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(wszPath);
    if(v.bstrVal == NULL)
    {
        return FALSE;
    }
    // Tell the value locator to set it
    // ================================

    BOOL bRes = SUCCEEDED(pValue->pLocation->Set(v, pObject));

    VariantClear(&v);

    return bRes;
}

HRESULT CMObject::AddAliasedValue(ACQUIRE CValueLocation* pLocation,
                                COPY LPCWSTR wszAlias)
{
    if(pLocation)
    {
        CAliasedValue* pValue = new CAliasedValue(pLocation, wszAlias);
        if(pValue == NULL)
            return WBEM_E_OUT_OF_MEMORY;
        if(pValue->wszAlias == NULL && wszAlias != NULL)
        {
            delete pValue;
            return WBEM_E_OUT_OF_MEMORY;
        }
        m_aAliased.Add(pValue);
    }
    return S_OK;
}

CMoProperty* CMObject::GetPropertyByName(WCHAR * pwcName)
{
    for(int iCnt = 0; iCnt < m_aProperties.GetSize(); iCnt++)
    {
        CMoProperty* pProp = (CMoProperty*)m_aProperties[iCnt];
        if(pProp && pProp->GetName())
            if(!wbem_wcsicmp(pwcName, pProp->GetName()))
                return pProp;
    }
    return NULL;
}
BOOL CMObject::ApplyToWbemObject(OLE_MODIFY IWbemClassObject* pObject, IWbemServices* pNamespace,
                                BOOL bClass, IWbemContext * pCtx)
{

    if(GetQualifiers() && !GetQualifiers()->AddToObject(pObject, bClass)) return FALSE;

    for(int i = 0; i < GetNumProperties(); i++)
    {
        if(!GetProperty(i)->AddToObject(pObject, pNamespace, bClass, pCtx)) return FALSE;
    }

    // Construct the path for future reference
    // =======================================

    VARIANT v;
    VariantInit(&v);
    SCODE sc = pObject->Get(L"__RELPATH", 0, &v, NULL, NULL);
    if(sc != S_OK || V_VT(&v) != VT_BSTR)
    {
        // This is probably an embedded object. If not, we will fail shortly
        // anyway. For now, just set the path to NULL and continue. // a-levn
        delete [] m_wszFullPath;
        m_wszFullPath = NULL;
        return TRUE;
    }

    SetFullPath(v.bstrVal);
    VariantClear(&v);

    return TRUE;
}

void CMObject::SetFullPath(BSTR bstr)
{
    if(bstr == NULL)
        return;

    if(m_wszFullPath)
        delete [] m_wszFullPath;
    
    int iLen = 20 + wcslen(bstr);
    if(m_wszNamespace)
        iLen += wcslen(m_wszNamespace);

    m_wszFullPath = new WCHAR[iLen];

    if(m_wszFullPath == NULL)
        return;

    // note that if m_wszNamespace is fully qualified, there is no need to 
    // prepend the slashes

    if(m_wszNamespace && m_wszNamespace[0] == L'\\' && m_wszNamespace[1] == L'\\')
        swprintf(m_wszFullPath, L"%s:%s", m_wszNamespace, bstr);
    else
        swprintf(m_wszFullPath, L"\\\\.\\%s:%s", m_wszNamespace, bstr);
}

int CMObject::GetNumAliasedValues()
{
    int iRet = m_aAliased.GetSize();

    // Also check the number of aliases in any embedded objects.

    int iCnt;
    for(iCnt = 0; iCnt < GetNumProperties(); iCnt++)
    {
        CMoProperty* pProp = GetProperty(iCnt);
        if(pProp == NULL)
            break;
        if(!pProp->IsValueProperty())
        {
            // Method properties actually contain one or two embedded instances for holding the
            // arguments.  Use those for the method case.

            CMethodProperty * pMeth = (CMethodProperty *)pProp;
            CMoInstance * pArgListObj = pMeth->GetInObj();
            if(pArgListObj)
                iRet += pArgListObj->GetNumAliasedValues();
            pArgListObj = pMeth->GetOutObj();
            if(pArgListObj)
                iRet += pArgListObj->GetNumAliasedValues();
            continue;
        }
        CMoValue& value = pProp->AccessValue();
        VARIANT & var = value.AccessVariant();

        if(var.vt == VT_EMBEDDED_OBJECT)
        {
            CMObject * pTemp = (CMObject *)var.punkVal;
            if(pTemp)
                iRet += pTemp->GetNumAliasedValues();
        }
        else if(var.vt == (VT_EMBEDDED_OBJECT | VT_ARRAY))
        {
        
            long lLBound, lUBound;
            SafeArrayGetLBound(var.parray, 1, &lLBound);
            SafeArrayGetUBound(var.parray, 1, &lUBound);

            // Check the individual embedded objects.
            // ======================================

            for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
            {
            
                CMObject * pTemp;
                SCODE hres = SafeArrayGetElement(var.parray, &lIndex, &pTemp);
                  if(FAILED(hres) || pTemp == FALSE) 
                    return iRet;
                iRet += pTemp->GetNumAliasedValues();                
            }
        }
    }
    return iRet;
}

HRESULT CMObject::ResolveAliasesInWbemObject(
        OLE_MODIFY IWbemClassObject* pObject,
        READ_ONLY CMofAliasCollection* pCollection)
{
    int i;
    SCODE sc;

    // Resolve them all using the collection
    // =====================================

    for(i = 0; i < m_aAliased.GetSize(); i++)
    {
        LPWSTR wszAlias;
        GetAliasedValue(i, wszAlias);

        LPCWSTR wszPathToAliasee = pCollection->FindAliasee(wszAlias);
        if(wszPathToAliasee == NULL) return WBEM_E_FAILED;

        if(!ResolveAliasedValue(i, wszPathToAliasee, pObject))
        {
            return WBEM_E_FAILED;
        }
    }

    // Also resolve any embedded objects

    int iCnt;
    for(iCnt = 0; iCnt < GetNumProperties(); iCnt++)
    {
        CMoProperty* pProp = GetProperty(iCnt);
        if(pProp == NULL)
            break;
        CMoValue& value = pProp->AccessValue();
        VARIANT & var = value.AccessVariant();

        if(!pProp->IsValueProperty())
        {
            // Methods contain possibly and input and an output object for storing the arguments.
            // These objects could contain aliases.

            BOOL bChanged = FALSE;
            CMethodProperty * pMeth = (CMethodProperty *)pProp;
            CMoInstance * pArgListObj = pMeth->GetInObj();
            BSTR bstr = SysAllocString(pProp->GetName());
            if(!bstr)
                return WBEM_E_FAILED;
            IWbemClassObject *pIn = NULL;
            IWbemClassObject *pOut = NULL;

            sc = pObject->GetMethod(bstr, 0, &pIn, &pOut);
            if(pArgListObj && pArgListObj->GetNumAliasedValues() && pIn)
            {
                sc = pArgListObj->ResolveAliasesInWbemObject((IWbemClassObject *)pIn,pCollection);
                if(sc == S_OK)
                    bChanged = TRUE;
            }
            pArgListObj = pMeth->GetOutObj();
            if(pArgListObj && pArgListObj->GetNumAliasedValues() && pOut)
            {
                sc = pArgListObj->ResolveAliasesInWbemObject((IWbemClassObject *)pOut,pCollection);
                if(sc == S_OK)
                    bChanged = TRUE;
            }
            if(bChanged)
                sc = pObject->PutMethod(bstr, 0, pIn, pOut);
            if(bstr)
                SysFreeString(bstr);
            if(pIn)
                pIn->Release();
            if(pOut)
                pOut->Release();
            continue;
        }
        
        else if(var.vt == VT_EMBEDDED_OBJECT)
        {
            CMObject * pTemp = (CMObject *)var.punkVal;
            if(pTemp)
            {
                VARIANT varDB;
                VariantInit(&varDB);
                BSTR bstr = SysAllocString(pProp->GetName());
                if(bstr)
                {
                    sc = pObject->Get(bstr, 0, &varDB, NULL, NULL);
                    
                    if(sc == S_OK)
                    {
                        IWbemClassObject * pClass = (IWbemClassObject *)varDB.punkVal;
                        sc = pTemp->ResolveAliasesInWbemObject((IWbemClassObject *)varDB.punkVal,pCollection);
                        if(S_OK == sc)
                            pObject->Put(bstr, 0, &varDB, 0);
                        else
                            return WBEM_E_FAILED;
                        pClass->Release();
                    }
                    SysFreeString(bstr);
                }
                else
                    return WBEM_E_OUT_OF_MEMORY;
            }
        }
        else if(var.vt == (VT_EMBEDDED_OBJECT | VT_ARRAY))
        {
        
            BSTR bstr = SysAllocString(pProp->GetName());
            if(bstr)
            {
                VARIANT varDB;
                VariantInit(&varDB);
                sc = pObject->Get(bstr, 0, &varDB, NULL, NULL);
                if(sc == S_OK)
                {
                    long lLBound, lUBound;
                    SafeArrayGetLBound(var.parray, 1, &lLBound);
                    SafeArrayGetUBound(var.parray, 1, &lUBound);

                    // Check the individual embedded objects.
                    // ======================================

                    for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
                    {
            
                        CMObject * pTemp;
                        sc = SafeArrayGetElement(var.parray, &lIndex, &pTemp);
                        IWbemClassObject * pWBEMInst = NULL;
                        sc |= SafeArrayGetElement(varDB.parray, &lIndex, &pWBEMInst);
                        
                        if(sc == S_OK && pTemp && pWBEMInst)
                        {
                            if(pTemp->m_aAliased.GetSize() > 0)
                            {
                                sc = pTemp->ResolveAliasesInWbemObject(pWBEMInst,pCollection);
                                if(sc != S_OK)
                                    return WBEM_E_FAILED;
                            }
                        }
                        if(pWBEMInst)
                            pWBEMInst->Release();
                    }
                    sc = pObject->Put(bstr, 0, &varDB, 0);
                    SafeArrayDestroyData(varDB.parray);
                    SafeArrayDestroyDescriptor(varDB.parray);
             
                }
                SysFreeString(bstr);
            }
            else
                return WBEM_E_OUT_OF_MEMORY;
        }
    }
    return WBEM_NO_ERROR;
}


//*****************************************************************************

CMoClass::CMoClass(COPY LPCWSTR wszParentName, COPY LPCWSTR wszClassName, PDBG pDbg,
                    BOOL bUpdateOnly)
{
    m_pDbg = pDbg;
    m_wszParentName = Macro_CloneStr(wszParentName);
    if(m_wszParentName == NULL && wszParentName != NULL)
        m_bOK = false;
    m_wszClassName = Macro_CloneStr(wszClassName);
    if(m_wszClassName == NULL && wszClassName != NULL)
        m_bOK = false;
    m_bUpdateOnly = bUpdateOnly;
}

CMoClass::~CMoClass()
{
    delete [] m_wszParentName;
    delete [] m_wszClassName;
}

HRESULT CMoClass::CreateWbemObject(READ_ONLY IWbemServices* pNamespace,
         RELEASE_ME IWbemClassObject** ppObject, IWbemContext * pCtx)
{
    // Take care of update only case.  In this case, the object is
    // not created, on retrieved for the later put!

    if(m_bUpdateOnly)
    {
        return pNamespace->GetObject(m_wszClassName, 0, pCtx, ppObject, NULL);
    }

    // Get the parent class from WINMGMT
    // ==============================


    BSTR strParentName = NULL;
    if(m_wszParentName)
    {
        strParentName = SysAllocString(m_wszParentName);
        if(strParentName == NULL)
        {
            return WBEM_E_OUT_OF_MEMORY;
        }        
        m_pDbg->SetString(strParentName);
    }

    IWbemClassObject* pParentClass = NULL;
    HRESULT hres = pNamespace->GetObject(strParentName, 0, pCtx, &pParentClass, NULL);
    if(strParentName)
        SysFreeString(strParentName);
    if(FAILED(hres)) return hres;

    if(m_wszParentName && wcslen(m_wszParentName))
    {
        // Create a child
        // ==============

        hres = pParentClass->SpawnDerivedClass(0, ppObject);
        pParentClass->Release();
        if(FAILED(hres)) return hres;
    }
    else
    {
        // Copy the dummy over
        // ===================

        *ppObject = pParentClass;
    }
    
    VARIANT v;
    VariantInit(&v);

    // Set the class name
    // ==================

    V_VT(&v) = VT_BSTR;
    V_BSTR(&v) = SysAllocString(m_wszClassName);
    if(v.bstrVal == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }    
    (*ppObject)->Put(L"__CLASS", 0, &v, 0);
    VariantClear(&v);

    return hres;
}

HRESULT CMoClass::StoreWbemObject(READ_ONLY IWbemClassObject* pObject,
        long lClassFlags, long lInstanceFlags,
        OLE_MODIFY IWbemServices* pNamespace, IWbemContext * pCtx,
        WCHAR * pUserName, WCHAR * pPassword, WCHAR * pAuthority)
{
    return pNamespace->PutClass(pObject, lClassFlags, pCtx, NULL);
}


//*****************************************************************************

CMoInstance::CMoInstance(COPY LPCWSTR wszClassName, PDBG pDbg, bool bParameter)
{
    m_pDbg = pDbg;
    m_wszClassName = Macro_CloneStr(wszClassName);
    if(m_wszClassName == NULL && wszClassName != NULL)
        m_bOK = false;
   m_bParameter = bParameter;
}

CMoInstance::~CMoInstance()
{
    delete [] m_wszClassName;
}


// *****************************************************************************
// Used to determine if this object is the input arguement list of a method.  
// That can be determined by checking if any of the properties have a "IN" qualifier
// *****************************************************************************

BOOL CMoInstance::IsInput()
{
    for(int iCnt = 0; iCnt < GetNumProperties(); iCnt++)
    {
        CMoProperty* pProp = GetProperty(iCnt);
        CMoQualifierArray* pQual = pProp->GetQualifiers();
        if(pQual->Find(L"IN"))
            return TRUE;
    }
    return FALSE;
        
}


HRESULT CMoInstance::CreateWbemObject(READ_ONLY IWbemServices* pNamespace,
         RELEASE_ME IWbemClassObject** ppObject, IWbemContext * pCtx)
{
    // Get the class from WINMGMT
    // =======================

    IWbemClassObject* pClass = NULL;
    BSTR strClassName = SysAllocString(m_wszClassName);
    if(strClassName == NULL)
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    m_pDbg->SetString(strClassName);

    HRESULT hres = pNamespace->GetObject(strClassName, 0, pCtx, &pClass, NULL);
    SysFreeString(strClassName);
    if(FAILED(hres)) return hres;

    // Spawn a new instance
    // ====================

    hres = pClass->SpawnInstance(0, ppObject);
    pClass->Release();

    return hres;
}

HRESULT CMoInstance::StoreWbemObject(READ_ONLY IWbemClassObject* pObject,
        long lClassFlags, long lInstanceFlags,
        OLE_MODIFY IWbemServices* pNamespace, IWbemContext * pCtx,
        WCHAR * pUserName, WCHAR * pPassword, WCHAR * pAuthority)
{
    IWbemCallResult *pCallResult = NULL;
    SCODE scRet = pNamespace->PutInstance(pObject, lInstanceFlags, pCtx, 
        (m_wszAlias) ? &pCallResult : NULL);

    if(scRet == S_OK && pCallResult)
    {
        BSTR bstr = NULL;
        DWORD dwAuthLevel, dwImpLevel;
        SCODE sc  = GetAuthImp( pNamespace, &dwAuthLevel, &dwImpLevel);
        if(sc == S_OK && dwAuthLevel > RPC_C_AUTHN_LEVEL_NONE)
            sc = SetInterfaceSecurity(pCallResult, pAuthority, pUserName, pPassword, 
                       dwAuthLevel, RPC_C_IMP_LEVEL_IMPERSONATE);

        scRet = pCallResult->GetResultString(9999, &bstr);
        if(sc == S_OK && scRet == S_OK && bstr)
        {
            SetFullPath(bstr);
            SysFreeString(bstr);
        }

        pCallResult->Release();
    }
    return scRet;
}

CMethodProperty::CMethodProperty(CMoQualifierArray * paQualifiers, PDBG pDbg, BOOL bBinary)
                   :CMoProperty(paQualifiers, pDbg)
{
    m_pDbg = pDbg;
    m_pInObj = NULL;
    m_pOutObj = NULL;
    m_IDType = UNSPECIFIED;     // Gets set on first argument
    m_NextAutoID = 0;
	m_bBinaryMof = bBinary;
	
}

CValueProperty::CValueProperty(CMoQualifierArray * paQualifiers, PDBG pDbg)
                   :CMoProperty(paQualifiers, pDbg)
{
    m_pDbg = pDbg;
    m_bIsArg = FALSE;
}


CMethodProperty::~CMethodProperty()
{
    VARIANT & var = m_Value.AccessVariant();
    var.vt = VT_EMPTY;

    if(m_pInObj != NULL)
            delete m_pInObj; 
    if(m_pOutObj != NULL)
            delete m_pOutObj;

    for(int i = 0; i < m_Args.GetSize(); i++)
    {
        CValueProperty * pProp = (CValueProperty *)m_Args[i];
        CMoProperty * pProp2 = (CMoProperty *)m_Args[i];
        delete (CValueProperty *)m_Args[i];
    }
    m_Args.RemoveAll();

}

BOOL CMethodProperty::AddToObject(OLE_MODIFY IWbemClassObject* pObject, IWbemServices* pNamespace, BOOL bClass, IWbemContext * pCtx)
{
    IWbemClassObject * pIn = NULL;
    IWbemClassObject * pOut = NULL;
    if(m_pInObj)
    {
        pIn = GetInstPtr(L"__PARAMETERS", pNamespace, m_pInObj, pCtx);
        if(pIn == NULL)
            return FALSE;
    }
    if(m_pOutObj)
    {
        pOut = GetInstPtr(L"__PARAMETERS", pNamespace, m_pOutObj, pCtx);
        if(pOut == NULL)
            return FALSE;
    }

    SCODE sc = pObject->PutMethod(GetName(), 0, pIn, pOut);
    if(pIn)
        pIn->Release();
    if(pOut)
        pOut->Release();

    if(FAILED(sc))
    {
        m_pDbg->hresError = sc;
        return FALSE;
    }
    if(!GetQualifiers()->AddToPropOrMeth(pObject, m_wszName, bClass, FALSE))
    {
        return FALSE;
    }

    return sc == S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//  Creates a new qualifier set which is a copy of the source. 
//
/////////////////////////////////////////////////////////////////////////////////////////////

CMoQualifierArray * CreateArgQualifierList(BOOL bInput, CMoQualifierArray *pSrcQualifiers, PDBG pDbg)
{
    if(pSrcQualifiers == NULL)
        return NULL;

    std::auto_ptr<CMoQualifierArray> pRet (new CMoQualifierArray (pDbg));
    
    if (pRet.get() == NULL)
        return NULL;

    for(int iCnt = 0; iCnt < pSrcQualifiers->GetSize(); iCnt++)
    {
        CMoQualifier* pSrc = pSrcQualifiers->GetAt(iCnt);
        if(pSrc == NULL)
            continue;

        // If this is for input, dont copy out qualifiers, and vice versa!

        if(bInput && !wbem_wcsicmp(pSrc->GetName(), L"OUT"))
            continue;
        if(!bInput && !wbem_wcsicmp(pSrc->GetName(), L"IN"))
            continue;

        // Create the new qualifier, copy the values from the existing one

	std::auto_ptr<CMoQualifier> pQual (new CMoQualifier(pDbg));
        if(pQual.get() == NULL)
            return NULL;
//        if(pSrc->IsRestricted())
//            pQual->SetRestricted();
        pQual->SetFlavor(pSrc->GetFlavor());
//        if(pSrc->IsOverrideSet())
//            pQual->OverrideSet();
        if(FAILED(pQual->SetQualName(pSrc->GetName())))
            return NULL;
        pQual->SetType(pSrc->GetType());
        VARIANT * pSrcVar = pSrc->GetpVar();
        
	HRESULT hr = WbemVariantChangeType(pQual->GetpVar(), pSrcVar, pSrcVar->vt);

	if (SUCCEEDED (hr))
	{
        // Add the new qualifier to the new set
        pRet->Add (pQual.release());
	}
	else
	{ 
	  return NULL;
	}
    }
    return pRet.release();
}

bool CMethodProperty::IsIDSpecified(CMoQualifierArray * paQualifiers)
{
    int iSize = paQualifiers->GetSize();
    for(int iCnt = 0; iCnt < iSize; iCnt++)
    {
        CMoQualifier* pTest = paQualifiers->GetAt(iCnt);
        if(pTest == NULL || wbem_wcsicmp(pTest->GetName(), L"ID"))
            continue;
        VARIANT * pVar = pTest->GetpVar();
        if(pVar->vt != VT_I4)
            m_IDType = INVALID;
        return true;
    }
    return false;
}

/////////////////////////////////////////////////////////////////////////////////////////////
//
//  This takes a method argument and adds it to either the input or output arguement object
//
/////////////////////////////////////////////////////////////////////////////////////////////

BOOL CMethodProperty::AddIt(WString & sName, CMoType & Type, BOOL bInput, 
                            CMoQualifierArray * paQualifiers, VARIANT * pVar, 
                            CMoValue & Value, BOOL bRetValue, BOOL bSecondPass)
{

    HRESULT hr;

    // Except for the return value, all parameters must have an ID.  We support both the automatic
    // generation of IDs, as well as allowing the explicit settings of IDs.  However, doing both
    // in a method is not allowed

    if(!bRetValue && !bSecondPass)
    {

        // Better have a qual set!

        if(paQualifiers == NULL)
            return FALSE;

        if(IsIDSpecified(paQualifiers))     // find it was explicitly set
        {

            // Explicity set.  Just pass it along to fastprox as is.  Note that if we
        
            if(m_IDType == AUTOMATIC || m_IDType == INVALID)
                return FALSE;
            m_IDType = MANUAL;
        }
        else
        {
            // The IDs must be set automatically

            if(m_IDType == MANUAL || m_IDType == INVALID)
                return FALSE;
            m_IDType = AUTOMATIC;

            // Add a new qualifier to this

            CMoQualifier * pNew = new CMoQualifier(m_pDbg);
            if(pNew == NULL)
                return FALSE;
            if(FAILED(pNew->SetQualName(L"ID")))
            {
                delete pNew;
                return FALSE;
            }
            pNew->SetFlavor(WBEM_FLAVOR_FLAG_PROPAGATE_TO_INSTANCE |
                            WBEM_FLAVOR_NOT_OVERRIDABLE);
        
            VARIANT * pVar2 = pNew->GetpVar();
            pVar2->vt = VT_I4;
            pVar2->lVal = m_NextAutoID++;
            paQualifiers->Add(pNew);

        }
    }

    // Get a pointer to either the input or output object.  In either case, the object
    // will need to be created if this is the first property being added to it.

    CMoInstance * pObj = NULL;
    if(bInput)
    {
        if(m_pInObj == NULL)
        {
            m_pInObj = new CMoInstance(L"__PARAMETERS", m_pDbg, true); 
            if(m_pInObj == NULL)
                return FALSE;
            if(m_pInObj->IsOK() == false)
            {
                delete m_pInObj;
                return FALSE;
            }
                
        }
        pObj = m_pInObj;
    }
    else
    {
        if(m_pOutObj == NULL)
        {
            m_pOutObj = new CMoInstance(L"__PARAMETERS", m_pDbg ,true); 
            if(m_pOutObj == NULL)
                return FALSE;
            if(m_pOutObj->IsOK() == false)
            {
                delete m_pOutObj;
                return FALSE;
            }
         }
        pObj = m_pOutObj;
    }
    
    if(pObj == NULL)
        return FALSE;
    // If the property doesnt have a qualifier set, as would be the case for the retvalue,
    // create one

    CMoQualifierArray * pQualifiers = NULL;

    if(paQualifiers == NULL)
        pQualifiers = new CMoQualifierArray(m_pDbg);
    else
        pQualifiers = CreateArgQualifierList(bInput, paQualifiers, m_pDbg);
    if(pQualifiers == NULL)
        return FALSE;

    // Create a new value property

    CValueProperty * pNewProp = new CValueProperty(pQualifiers, m_pDbg);
    if(pNewProp == NULL)
        return FALSE;
    VARTYPE vt = Type.GetCIMType();
    if(FAILED(pNewProp->SetPropName(sName)))
    {
        delete pNewProp;
        return FALSE;
    }
    pNewProp->SetAsArg();
    Type.StoreIntoQualifiers(pQualifiers);
    VARIANT * pDest;
    pDest = pNewProp->GetpVar();
    if(pVar && pVar->vt != VT_EMPTY && pVar->vt != VT_NULL)
    {
        VARTYPE vtSimple = pVar->vt & ~VT_ARRAY;
        if(vtSimple != VT_EMBEDDED_OBJECT || pVar->vt == (VT_EMBEDDED_OBJECT | VT_ARRAY))
        {
            hr = VariantCopy(pDest, pVar);
            if(FAILED(hr))
                return FALSE;
        }
        else
        {
            pDest->vt = VT_EMBEDDED_OBJECT;
            pDest->punkVal = pVar->punkVal;
        }
    }

    pNewProp->SetType(vt);

    // If the original value contains some aliases, make sure they get added

    CMoValue & Dest = pNewProp->AccessValue();
    for(int i = 0; i < Value.GetNumAliases(); i++)
    {
        LPWSTR wszAlias;
        int nArrayIndex;
        if(Value.GetAlias(i, wszAlias, nArrayIndex))
        {
            hr = Dest.AddAlias(wszAlias, nArrayIndex);
            if(FAILED(hr))
                return FALSE;
        }
    }


    pObj->AddProperty(pNewProp);

    return TRUE;
}

BOOL CMethodProperty::AddToArgObjects(CMoQualifierArray * paQualifiers, WString & sName, 
                                      CMoType & Type, BOOL bRetValue, int & ErrCtx, VARIANT * pVar,
                                      CMoValue & Value)
{
    
    // if return value and it is null or void, just bail out

    if(Type.IsDefined() == FALSE  && bRetValue)
        return TRUE;


    // Determine which arg list this goes into

    BOOL bGoesIntoInputs = FALSE;
    BOOL bGoesIntoOutputs = FALSE;
    
    if( bRetValue)
        bGoesIntoOutputs = TRUE;
    else
    {
        // Loop through the arg list.

        if(paQualifiers == NULL)
            return FALSE;
        if(paQualifiers->Find(L"IN"))
            bGoesIntoInputs = TRUE;
        if(paQualifiers->Find(L"OUT"))
            bGoesIntoOutputs = TRUE;
    }

    // make sure it isnt already on the list

    if(bGoesIntoInputs && m_pInObj && m_pInObj->GetPropertyByName(sName))
        return FALSE;

    if(bGoesIntoOutputs && m_pOutObj && m_pOutObj->GetPropertyByName(sName))
        return FALSE;

    if(bGoesIntoInputs == FALSE && bGoesIntoOutputs == FALSE)
    {
        ErrCtx = WBEMMOF_E_MUST_BE_IN_OR_OUT;
        return FALSE;
    }
    
    // Create the object(s) if necessary

    if(bGoesIntoInputs)
        if(!AddIt(sName, Type, TRUE, paQualifiers, pVar, Value, bRetValue, FALSE))
            return FALSE;

    if(bGoesIntoOutputs)
        return AddIt(sName, Type, FALSE, paQualifiers, pVar, Value, bRetValue, bGoesIntoInputs);
    else
        return TRUE;
}

CMoActionPragma::CMoActionPragma(COPY LPCWSTR wszClassName, PDBG pDbg, bool bFail, BOOL bClass)
{
    m_pDbg = pDbg;
    m_wszClassName = Macro_CloneStr(wszClassName);
    if(m_wszClassName == NULL && wszClassName != NULL)
        m_bOK = false;
    m_bFail = bFail;
    m_bClass = bClass;
}

CMoActionPragma::~CMoActionPragma()
{
    delete [] m_wszClassName;
}

HRESULT CMoActionPragma::StoreWbemObject(READ_ONLY IWbemClassObject* pObject,
        long lClassFlags, long lInstanceFlags,
        OLE_MODIFY IWbemServices* pNamespace, IWbemContext * pCtx,
        WCHAR * pUserName, WCHAR * pPassword, WCHAR * pAuthority)
{
    if(m_wszClassName == NULL || wcslen(m_wszClassName) < 1)
        return WBEM_E_FAILED;
    BSTR bstr = SysAllocString(m_wszClassName);
    if(bstr)
    {

        SCODE sc;
		if(m_bClass)
			sc = pNamespace->DeleteClass(bstr, 0, NULL, NULL);
		else
			sc = pNamespace->DeleteInstance(bstr, 0, NULL, NULL);

        SysFreeString(bstr);
        if(!m_bFail)
            return S_OK;
        else
        {
            if(FAILED(sc))
                wcsncpy(m_pDbg->m_wcError, m_wszClassName, 99);
            return sc;
        }
    }
    else
        return WBEM_E_OUT_OF_MEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
//#include "arena.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\mofparse.h ===
/*++

Copyright (C) 1995-2001 Microsoft Corporation

Module Name:

    MOFPARSE.H

Abstract:

	Declarations for MOF Parser class.

History:

	a-raymcc    18-Oct-95   Created.
	a-raymcc    27-Jan-96   Reference & alias support.

--*/

#ifndef _MOFPARSE_H_
#define _MOFPARSE_H_

#include "wstring.h"
#include "parmdefs.h"
#include "moflex.h"
#include "mofprop.h"
#include "mofdata.h"
#include "bmof.h"
#include "bmofhelp.h"
#include "trace.h"

enum SCOPE_CHECK{IN_CLASS, IN_INSTANCE, IN_PROPERTY, IN_PARAM, IN_METHOD};

bool ValidFlags(bool bClass, long lFlags);

class CMofParser
{
    CMofLexer   m_Lexer;
    CMofData    m_Output;

	PDBG m_pDbg;
    LPWSTR m_wszNamespace;
    long m_lDefClassFlags;
    long m_lDefInstanceFlags;
    bool m_bAutoRecover;
    bool m_bNotBMOFCompatible;
    WCHAR * m_wszAmendment;
	bool m_bRemotePragmaPaths;
    bool m_bOK;
    int m_nToken;

    int m_nErrorContext;
    int m_nErrorLineNumber;
    TCHAR m_cFileName[MAX_PATH];
    PARSESTATE m_State;
    bool m_bDoScopeCheck;

    // Internal functions.
    // ===================


    // Nonterminal symbols from productions.
    // =====================================

public:
    void SetToDoScopeCheck(){m_bDoScopeCheck = true;};
    void SetToNotScopeCheck(){m_bDoScopeCheck = false;};

    void SetState(PARSESTATE state){m_State = state;};

    void NextToken(bool bDontAllowWhitespace = false) { m_nToken = m_Lexer.NextToken(bDontAllowWhitespace); }
    BOOL top_level_decl();        // stores in CMofData
    BOOL decl_type();             // stores in CMofData
    BOOL class_decl(ACQUIRE CMoQualifierArray* paAttrs, VARIANT * pValue, ParseState *pQualPosition);  // stores in CMofData
    BOOL class_def(ACQUIRE CMoQualifierArray* paAttrs, BSTR strClassName,
                    int nFirstLine, ParseState * pQualPosition, VARIANT * pValue); 
    BOOL instance_decl(ACQUIRE CMoQualifierArray* paAttrs, VARIANT * pValue, ParseState * QualPosition = NULL);// stores in CMofData

    BOOL qualifier_decl(OUT CMoQualifierArray& aAttrs, bool bTopLevel, QUALSCOPE qs);

    BOOL type(OUT CMoType& Type);                           
    BOOL opt_parent_class(OUT BSTR* pstrParentName);            
    BOOL property_decl_list(MODIFY CMObject* pObject);

    BOOL as_alias(OUT LPWSTR& wszAlias);
    BOOL prop_init_list(MODIFY CMObject* pObject);
    BOOL prop_init(OUT CMoProperty& Prop);

    BOOL alias(OUT LPWSTR& wszAlias);
    BOOL PropOrMeth_decl(OUT CMoProperty **ppProp);              
    BOOL PropOrMeth_decl2(OUT CMoProperty **ppProp, CMoQualifierArray * paQualifiers);
    BOOL finish_PropOrMeth(CMoType & Type, WString & sName, CMoProperty ** ppProp, CMoQualifierArray * paQualifiers);
    BOOL finish_prop(CMoType & Type, WString & sName, CMoProperty ** ppProp, CMoQualifierArray * paQualifiers);
    BOOL finish_meth(CMoType & Type, WString & sName, CMoProperty ** ppProp, CMoQualifierArray * paQualifiers);
    BOOL TypeAndName(MODIFY CMoType& Type, WString & sName);

    BOOL arg_list(CMethodProperty * pMethProp);
    BOOL arg_decl(CMethodProperty * pMethProp);
    BOOL rest_of_args(CMethodProperty * pMethProp);

    BOOL opt_ref(MODIFY CMoType& Type);                  
    BOOL opt_array(MODIFY CMoType& Type, CMoQualifierArray * paQualifiers);
    BOOL opt_array_detail(MODIFY CMoType& Type, CMoQualifierArray * paQualifiers); 
    BOOL default_value(READ_ONLY CMoType& Type, OUT CMoValue& Value);              
    BOOL initializer(MODIFY CMoType& Type, OUT CMoValue& Value);

    BOOL qualifier_list(OUT CMoQualifierArray& aAttrs, bool bTopLevel, QUALSCOPE qs);
    BOOL qualifier(OUT CMoQualifier& Attr, bool bTopLevel, QUALSCOPE qs);                     
    BOOL qualifier_list_rest(MODIFY CMoQualifierArray& aAttrs, bool bTopLevel, QUALSCOPE qs);
    BOOL qualifier_parm(OUT CMoQualifier& Attr, bool bTopLevel, QUALSCOPE qs);
    BOOL qualifier_initializer_list(OUT CMoValue& Value);

    BOOL const_value(MODIFY CMoType& Type, OUT VARIANT& varValue, bool bQualifier);

    BOOL simple_initializer(MODIFY CMoType& Type, OUT CMoValue& Value, bool bQualifier);         
    BOOL initializer_list(MODIFY CMoType& Type, OUT CMoValue& Value, bool bQualifier);

    BOOL preprocessor_command();    // executes
    BOOL pound_include();           // executes
    BOOL pound_define();            // executes
    BOOL pound_pragma();            // executes
	bool flag_list(bool bClass);
	bool string_list(bool bClass, long & lNewValue);
	bool GetFlagValue(long & lNewValue);

    BOOL typedef_(ACQUIRE CMoQualifierArray* paAttrs);
    BOOL complete_type();
    BOOL enum_();
    BOOL enum_data();
    BOOL enum_data_rest();
    BOOL int_enum_data_rest();
    BOOL int_enum_datum();
    BOOL string_enum_data_rest();
    BOOL string_enum_datum();
    BOOL opt_name();
    BOOL opt_subrange();
    BOOL const_int();
    BOOL const_string();
    BOOL const_char();
	BOOL flavor_param(OUT CMoQualifier& Qual, bool bDefaultQual);
	BOOL flavor_list(OUT CMoQualifier& Qual);
	BOOL flavor_list_rest(CMoQualifier& Qual);
	BOOL def_flavor_list(OUT CMoQualifier& Qual);
	BOOL def_flavor_list_rest(CMoQualifier& Qual);
	BOOL flavor_value(CMoQualifier& Qual);
    bool sys_or_regular();

    BOOL qualifier_default();
    BOOL finish_qualifier_default(CMoQualifier& Qual);
    BOOL finish_qualifier_end(CMoQualifier& Qual);
	BOOL scope_list(OUT CMoQualifier& Qual);
	BOOL scope_list_rest(CMoQualifier& Qual);
	BOOL scope_value(CMoQualifier& Qual);

    BOOL FailOrNoFail(bool * pbFail);
    CMofParser(const TCHAR *pFilename, PDBG pdbg);
    CMofParser(PDBG pdbg);

   ~CMofParser();  
   HRESULT SetBuffer(char *pMemory, DWORD dwMemSize){return m_Lexer.SetBuffer(pMemory, dwMemSize);};
    PDBG GetDbg(){return m_pDbg;};

   HRESULT SetDefaultNamespace(LPCWSTR wszDefault);
    void SetOtherDefaults(long lClass, long lInst, bool bAutoRecover){m_lDefClassFlags = lClass;m_lDefInstanceFlags=lInst;
                m_bAutoRecover = bAutoRecover; return;};
    long GetClassFlags(void){return m_lDefClassFlags;};
    long GetInstanceFlags(void){return m_lDefInstanceFlags;};
    bool GetAutoRecover(void){return m_bAutoRecover;};
    HRESULT SetAmendment(LPCWSTR wszDefault);
    WCHAR * GetAmendment(void){return m_wszAmendment;};
    bool GetRemotePragmaPaths(void){return m_bRemotePragmaPaths;};
    BOOL Parse(); 
    bool GetErrorInfo(TCHAR *pBuffer, DWORD dwBufSize, 
        int *pLineNumber, int *pColumn,	int *pError, LPWSTR * pErrorFile);   
	TCHAR * GetFileName(){return m_cFileName;};
    INTERNAL CMofData *AccessOutput() { return &m_Output; }
	BOOL IsUnicode(){return m_Lexer.IsUnicode();};
    bool IsntBMOFCompatible(){return m_bNotBMOFCompatible;};
    void SetParserPosition(ParseState * pPos){m_Lexer.SetLexPosition(pPos); m_nToken = pPos->m_nToken;};
    void GetParserPosition(ParseState * pPos){m_Lexer.GetLexPosition(pPos); pPos->m_nToken = m_nToken;};
    BOOL CheckScopes(SCOPE_CHECK scope_check, CMoQualifierArray* paQualifiers, CMoProperty * pProperty);

};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\mofprop.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    MOFPROP.H

Abstract:

History:

--*/

#ifndef __MOFPROP__H_
#define __MOFPROP__H_

#include <miniafx.h>
#include <wbemidl.h>
#include "wstring.h"
#include "parmdefs.h"
#include <wbemutil.h>
//#include "mofparse.h"
#include "trace.h"
#define VT_EX_EMBEDDED (VT_RESERVED | VT_EMBEDDED_OBJECT)

#define SCOPE_CLASS         1
#define SCOPE_INSTANCE      2
#define SCOPE_PROPERTY      4
#define SCOPE_METHOD        8
#define SCOPE_PARAMETER     0X10
#define SCOPE_ASSOCIATION   0X20
#define SCOPE_REFERENCE     0x40

enum QUALSCOPE{CLASSINST_SCOPE,  PROPMETH_SCOPE};
enum PARSESTATE {INITIAL, REFLATE_INST, REFLATE_CLASS};

class CMObject;
class CMoClass;
class CMofParse;
class ParseState;


class CMoValue
{
protected:
    VARTYPE m_vType;
    VARIANT m_varValue;
    struct CAlias
    {
        LPWSTR m_wszAlias;
        int m_nArrayIndex;

        CAlias() : m_wszAlias(NULL), m_nArrayIndex(-1){}
        CAlias(COPY LPCWSTR wszAlias, int nArrayIndex = -1);
        ~CAlias();
    };
    CPtrArray m_aAliases; // CAlias*
    PDBG m_pDbg;

public:
    CMoValue(PDBG pDbg);
    ~CMoValue();

    INTERNAL VARIANT& AccessVariant() {return m_varValue;}
    VARTYPE GetType() {return m_vType;}
    VARTYPE GetVarType() {return m_varValue.vt;}
    void SetType(VARTYPE vType) {m_vType = vType;}

    int GetNumAliases() {return m_aAliases.GetSize();}
    BOOL GetAlias(IN int nAliasIndeex, 
        OUT INTERNAL LPWSTR& wszAlias, OUT int& nArrayIndex);
    HRESULT AddAlias(COPY LPCWSTR wszAlias, int nArrayIndex = -1);
    BOOL Split(COutput & out);
};

//*****************************************************************************
typedef enum {OBJECT, PROP, ARG} QualType;

class CMoQualifier
{
protected:
    LPWSTR m_wszName;
    CMoValue m_Value;
    PDBG m_pDbg;
    DWORD m_dwScope;
    long m_lFlavor;
    bool m_bNotOverrideSet;
    bool m_bOverrideSet;
    bool m_bIsRestricted;
    bool m_bNotToInstance;
    bool m_bToInstance;
    bool m_bNotToSubclass;
    bool m_bToSubclass;
    bool m_bAmended;
    bool m_bCimDefaultQual;
    bool m_bUsingDefaultValue;
public:
    CMoQualifier(PDBG pDbg);
    ~CMoQualifier();
    BOOL IsRestricted(){return m_bIsRestricted;};
    void SetRestricted(){m_bIsRestricted = TRUE;};
    void SetCimDefault(bool bSet){m_bCimDefaultQual = bSet;};
    bool IsCimDefault(){return m_bCimDefaultQual;};
    void SetUsingDefaultValue(bool bSet){m_bUsingDefaultValue = bSet;};
    bool IsUsingDefaultValue(){return m_bUsingDefaultValue;};

    HRESULT SetQualName(COPY LPCWSTR wszName);
    INTERNAL LPWSTR GetName() {return m_wszName;}
    VARIANT * GetpVar(){return & m_Value.AccessVariant();};
    VARTYPE GetType(){return m_Value.GetType();};
    void SetType(VARTYPE vt){m_Value.SetType(vt);};
    bool IsAmended(){return m_bAmended;};
    void SetAmended(bool bAmended){m_bAmended = bAmended;};

    CMoValue& AccessValue() {return m_Value;}
    void SetFlavor(long lFlavor) { m_lFlavor = lFlavor;};
    long GetFlavor(void) { return m_lFlavor;};
    void OverrideSet(){m_bOverrideSet = TRUE;};
    BOOL IsOverrideSet(){return m_bOverrideSet;};
    HRESULT SetFlag(int iToken, LPCWSTR pwsText);
    BOOL SetScope(int iToken, LPCWSTR pwsText);
    DWORD GetScope(){return m_dwScope;};
    BOOL Split(COutput & out);
    BOOL IsDisplayable(COutput & out, QualType qt);

private:
    BOOL AddToSet(OLE_MODIFY IWbemQualifierSet* pQualifierSet, BOOL bClass);
    friend class CMoQualifierArray;
    friend class CBMOFOut;
};

//*****************************************************************************

class CMoQualifierArray
{
protected:
    CPtrArray m_aQualifiers;
    PDBG m_pDbg;

public:
    CMoQualifierArray(PDBG pDbg){m_pDbg = pDbg;}
    ~CMoQualifierArray();
	void RemoveAll(){m_aQualifiers.RemoveAll();};
    int GetSize() {return m_aQualifiers.GetSize();}

    INTERNAL CMoQualifier* GetAt(int nIndex) 
        {return (CMoQualifier*) m_aQualifiers[nIndex];}

    INTERNAL CMoQualifier* operator[](int nIndex) {return GetAt(nIndex);}
    INTERNAL CMoValue* Find(READ_ONLY LPCWSTR wszName);

    BOOL Add(ACQUIRE CMoQualifier* pQualifier);

    BOOL RegisterAliases(MODIFY CMObject* pObject,
                         READ_ONLY LPCWSTR wszPropName);

    BOOL AddToSet(OLE_MODIFY IWbemQualifierSet* pQualifierSet, BOOL bClass);
    BOOL AddToObject(OLE_MODIFY IWbemClassObject* pObject, BOOL bClass);
    BOOL AddToPropOrMeth(OLE_MODIFY IWbemClassObject* pObject, 
                    READ_ONLY LPCWSTR wszProperty, BOOL bClass, BOOL bProp);
    BOOL Split(COutput & out, QualType qt);

    bool HasAmended();
};
    
//*****************************************************************************

class CMoProperty
{
protected:
    LPWSTR m_wszName;
    CMoValue m_Value;
    LPWSTR m_wszTypeTitle;
    PDBG m_pDbg;
    CMoQualifierArray* m_paQualifiers;
    IWbemClassObject * GetInstPtr(const WCHAR * pClassName,  IWbemServices* pNamespace, CMObject * pMo, IWbemContext * pCtx);

public:
    CMoProperty(CMoQualifierArray * paQualifiers, PDBG pDbg);
    virtual ~CMoProperty();
    virtual BOOL IsValueProperty(){return TRUE;};

    INTERNAL LPWSTR GetName() {return m_wszName;}
    HRESULT SetPropName(COPY LPCWSTR wszName);
    HRESULT SetTypeTitle(COPY LPCWSTR wszName);

    VARTYPE GetType(){return m_Value.GetType();};
    void SetType(VARTYPE vType){m_Value.SetType(vType);};
    CMoValue& AccessValue() {return m_Value;}
    VARIANT * GetpVar(){return & m_Value.AccessVariant();};
    void SetQualifiers(ACQUIRE CMoQualifierArray* pQualifiers);
    INTERNAL CMoQualifierArray* GetQualifiers() {return m_paQualifiers;}

    virtual BOOL RegisterAliases(MODIFY CMObject* pObject){return TRUE;};
    virtual BOOL AddToObject(OLE_MODIFY IWbemClassObject* pObject, IWbemServices* pNamespace, BOOL bClass, IWbemContext * pCtx) = 0;
    virtual BOOL Split(COutput & out) = 0;

private:
    friend CMObject;
    friend CMoClass;
};

class CValueProperty : public CMoProperty
{
protected:
private:
    BOOL AddEmbeddedObject(OLE_MODIFY IWbemClassObject* pObject, IWbemServices* pNamespace, IWbemContext * pCtx);
    friend CMObject;
    friend CMoClass;
    BOOL m_bIsArg;
    PDBG m_pDbg;
public:

    CValueProperty(CMoQualifierArray * paQualifiers, PDBG pDbg);
    BOOL RegisterAliases(MODIFY CMObject* pObject);
    BOOL AddToObject(OLE_MODIFY IWbemClassObject* pObject, IWbemServices* pNamespace, BOOL bClass, IWbemContext * pCtx);
    void SetAsArg(){m_bIsArg = TRUE;};
    BOOL Split(COutput & out);
};

class CMoType;
class CMoInstance;


class  CMethodProperty : public CMoProperty
{
protected:
    enum ParamIDType {UNSPECIFIED, AUTOMATIC, MANUAL, INVALID};

public:
    BOOL IsValueProperty(){return FALSE;};
    CMethodProperty(CMoQualifierArray * paQualifiers, PDBG pDbg, BOOL bBinary);
    ~CMethodProperty();
    BOOL AddToObject(OLE_MODIFY IWbemClassObject* pObject, IWbemServices* pNamespace, BOOL bClass, IWbemContext * pCtx);
    BOOL AddArg(CValueProperty * pAdd){return m_Args.Add(pAdd);};
    CMoInstance * GetInObj(){return m_pInObj;};
    CMoInstance * GetOutObj(){return m_pOutObj;};
    BOOL AddToArgObjects(CMoQualifierArray * paQualifiers, WString & sName, CMoType & Type, BOOL bRetValue, 
                            int & ErrCtx, VARIANT * pVar, CMoValue & Value);
    void SetIn(CMoInstance * pIn){m_pInObj = pIn;};
    void SetOut(CMoInstance * pOut){m_pOutObj = pOut;};
    bool IsIDSpecified(CMoQualifierArray * paQualifiers);
    BOOL Split(COutput & out);
    BOOL IsDisplayable(COutput & out);


private:
    ParamIDType m_IDType;
    DWORD m_NextAutoID;
    BOOL AddIt(WString & sName, CMoType & Type, BOOL bInput, CMoQualifierArray * paQualifiers, 
        VARIANT * pVar, CMoValue & Value, BOOL bRetValue, BOOL bSecondPass);
    BOOL AddEmbeddedObject(OLE_MODIFY IWbemClassObject* pObject, IWbemServices* pNamespace, IWbemContext * pCtx);
    friend CMObject;
    friend CMoClass;
    CMoInstance * m_pInObj;
    CMoInstance * m_pOutObj;
    CPtrArray m_Args;
    PDBG m_pDbg;
	BOOL m_bBinaryMof;
};

//*****************************************************************************

class CMoType
{
protected:
    BOOL m_bIsRef;
    BOOL m_bIsEmbedding;
    BOOL m_bIsArray;
    LPWSTR m_wszTitle;
    PDBG m_pDbg;
    DELETE_ME CMoQualifier* CreateSyntax(READ_ONLY LPCWSTR wszSyntax);
public:
    CMoType(PDBG pDbg) : m_bIsRef(FALSE), m_bIsEmbedding(FALSE), m_bIsArray(FALSE), 
                m_wszTitle(NULL), m_pDbg(pDbg){}
    ~CMoType();

    HRESULT SetTitle(COPY LPCWSTR wszTitle);
    INTERNAL LPCWSTR GetTitle() {return m_wszTitle;}
    BOOL IsDefined() {return (m_wszTitle != NULL);}
    BOOL IsString() {return !wbem_wcsicmp(m_wszTitle, L"string");};

    void SetIsRef(BOOL bIsRef) {m_bIsRef = bIsRef;}
    BOOL IsRef() {return m_bIsRef;}

    void SetIsEmbedding(BOOL bIsEmbedding) {m_bIsEmbedding = bIsEmbedding;}
    BOOL IsEmbedding() {return m_bIsEmbedding;}

    void SetIsArray(BOOL bIsArray) {m_bIsArray = bIsArray;}
    BOOL IsArray() {return m_bIsArray;}

    VARTYPE GetCIMType();
    bool IsUnsupportedType();
    BOOL StoreIntoQualifiers(CMoQualifierArray * pQualifiers);
};

//*****************************************************************************

class CValueLocation
{
public:
    virtual ~CValueLocation(){}
    virtual HRESULT Set(READ_ONLY VARIANT& varValue,
                OLE_MODIFY IWbemClassObject* pObject) = 0;
protected:
    HRESULT SetArrayElement(
                MODIFY VARIANT& vArray,
                int nIndex,
                READ_ONLY VARIANT& vValue);
};

class CPropertyLocation : public CValueLocation
{
protected:
    LPWSTR m_wszName;
    int m_nArrayIndex;
    bool m_bOK;
public:
    CPropertyLocation(COPY LPCWSTR wszName, int nArrayIndex = -1);
    ~CPropertyLocation();
    virtual HRESULT Set(READ_ONLY VARIANT& varValue,
                OLE_MODIFY IWbemClassObject* pObject);
    bool IsOK(){return m_bOK;};
};

class CQualifierLocation : public CValueLocation
{
protected:
    LPWSTR m_wszName;
    LPWSTR m_wszPropName;
    int m_nArrayIndex;
    PDBG m_pDbg;
    bool m_bOK;
public:
    CQualifierLocation(COPY LPCWSTR wszName, PDBG pDbg, COPY LPCWSTR wszPropName = NULL,
                        int nArrayIndex = -1);
    ~CQualifierLocation();
    virtual HRESULT Set(READ_ONLY VARIANT& varValue,
                OLE_MODIFY IWbemClassObject* pObject);
    bool IsOK(){return m_bOK;};
};

//*****************************************************************************

class CMofAliasCollection
{
public:
    virtual INTERNAL LPCWSTR FindAliasee(READ_ONLY LPWSTR wszAlias) = 0;
};

//*****************************************************************************

class CMofParser;

class CMObject
{
protected:
    CMoQualifierArray* m_paQualifiers;
    CPtrArray m_aProperties; // CMoProperty*

    LPWSTR m_wszAlias;
    LPWSTR m_wszNamespace;
    long m_lDefClassFlags;
    long m_lDefInstanceFlags;
    BOOL m_bDone;
    IWbemClassObject * m_pWbemObj;

    LPWSTR m_wszFullPath;

    struct CAliasedValue
    {
        CValueLocation* pLocation;
        LPWSTR wszAlias;

        CAliasedValue(ACQUIRE CValueLocation* _pLocation,
            COPY LPCWSTR _wszAlias);

        ~CAliasedValue();
    };
    CPtrArray m_aAliased; // CAliasedValue*

    int m_nFirstLine;
    LPWSTR m_wFileName;
    int m_nLastLine;
    bool m_bParameter;
    bool m_bAmended;
    ParseState m_DataState;
    ParseState m_QualState;
    bool m_bDeflated;
    bool m_bOK;
public:
    CMObject();
    virtual ~CMObject();
    bool IsOK(){return m_bOK;};
    ParseState * GetDataState(){return &m_DataState;};
    ParseState * GetQualState(){return &m_QualState;};
	void SetQualState(ParseState * pNew){if(pNew)m_QualState = *pNew;};

    void SetWbemObject(IWbemClassObject *pObj){m_pWbemObj = pObj;};
    IWbemClassObject * GetWbemObject(){return m_pWbemObj;};

    BOOL IsDone(){return m_bDone;};
    void SetDone(){m_bDone = TRUE;};

    virtual INTERNAL LPCWSTR GetClassName() = 0;

    HRESULT SetNamespace(COPY LPCWSTR wszNamespace);
    void SetOtherDefaults(long lClass, long lInst)
        {m_lDefClassFlags = lClass;m_lDefInstanceFlags=lInst;return;};

    void SetFullPath(BSTR bstr);
    INTERNAL LPCWSTR GetNamespace() {return m_wszNamespace;}
    long GetClassFlags(void){return m_lDefClassFlags;};
    long GetInstanceFlags(void){return m_lDefInstanceFlags;};


    HRESULT SetAlias(COPY LPCWSTR wszAlias);
    INTERNAL LPCWSTR GetAlias() {return m_wszAlias;}

    INTERNAL LPCWSTR GetFullPath() {return m_wszFullPath;}

    int GetFirstLine() {return m_nFirstLine;}
    int GetLastLine() {return m_nLastLine;}
    WCHAR * GetFileName() {return m_wFileName;};
    HRESULT SetLineRange(int nFirstLine, int nLastLine, WCHAR * pFileName);

    BOOL AddProperty(ACQUIRE CMoProperty* pProperty);
    int GetNumProperties() {return m_aProperties.GetSize();}
    INTERNAL CMoProperty* GetProperty(int nIndex)
        {return (CMoProperty*)m_aProperties[nIndex];}
    CMoProperty* GetPropertyByName(WCHAR * pwcName);

    int GetNumAliasedValues();
    BOOL GetAliasedValue(
        IN int nIndex, 
        OUT INTERNAL LPWSTR& wszAlias);
    HRESULT AddAliasedValue(ACQUIRE CValueLocation* pLocation,
        COPY LPCWSTR wszAlias);

    void SetQualifiers(ACQUIRE CMoQualifierArray* pQualifiers);
    INTERNAL CMoQualifierArray* GetQualifiers() {return m_paQualifiers;}
    virtual BOOL IsInstance(){return FALSE;};
    virtual BOOL IsDelete(){return FALSE;};

public:
    virtual HRESULT CreateWbemObject(READ_ONLY IWbemServices* pNamespace,
         RELEASE_ME IWbemClassObject** ppObject, IWbemContext * pCtx) = 0;
    virtual BOOL ApplyToWbemObject(OLE_MODIFY IWbemClassObject* pObject,IWbemServices* pNamespace, IWbemContext * pCtx) = 0;
    virtual HRESULT StoreWbemObject(READ_ONLY IWbemClassObject* pObject,
        long lClassFlags, long lInstanceFlags,
        OLE_MODIFY IWbemServices* pNamespace, IWbemContext * pCtx,
        WCHAR * pUserName, WCHAR * pPassword, WCHAR * pAuthority) = 0;

    BOOL ResolveAliasedValue(
        IN int nIndex, READ_ONLY LPCWSTR wszPath,
        OLE_MODIFY IWbemClassObject* pObject);
    HRESULT ResolveAliasesInWbemObject(
        OLE_MODIFY IWbemClassObject* pObject,
        READ_ONLY CMofAliasCollection* pCollection);

    bool CheckIfAmended();
    void SetAmended(bool bVal){m_bAmended = bVal;};
    bool IsAmended(){return m_bAmended;};

    virtual BOOL Split(COutput & out);
    virtual void FreeWbemObjectIfPossible();
    virtual HRESULT Deflate(bool bDestruct);
    virtual HRESULT Reflate(CMofParser & Parser);

protected:
    BOOL ApplyToWbemObject(OLE_MODIFY IWbemClassObject* pObject,IWbemServices* pNamespace, BOOL bClass, IWbemContext * pCtx);
};


class CMoClass : public CMObject
{
protected:
    LPWSTR m_wszParentName;
    LPWSTR m_wszClassName;
    BOOL m_bUpdateOnly;
    PDBG m_pDbg;

public:
    CMoClass(COPY LPCWSTR wszParentName, COPY LPCWSTR wszClassName, PDBG pDbg,
               BOOL bUpdateOnly = FALSE);
    ~CMoClass();

    INTERNAL LPCWSTR GetParentName() {return m_wszParentName;}
    INTERNAL LPCWSTR GetClassName() {return m_wszClassName;}

    HRESULT CreateWbemObject(READ_ONLY IWbemServices* pNamespace, 
         RELEASE_ME IWbemClassObject** ppObject, IWbemContext * pCtx);

    BOOL ApplyToWbemObject(OLE_MODIFY IWbemClassObject* pObject,IWbemServices* pNamespace, IWbemContext * pCtx)
        {return CMObject::ApplyToWbemObject(pObject,pNamespace, TRUE, pCtx); /* class */ }

    HRESULT StoreWbemObject(READ_ONLY IWbemClassObject* pObject,
        long lClassFlags, long lInstanceFlags,
        OLE_MODIFY IWbemServices* pNamespace, IWbemContext * pCtx,
        WCHAR * pUserName, WCHAR * pPassword, WCHAR * pAuthority);
};

class CMoInstance : public CMObject
{
protected:
    LPWSTR m_wszClassName;
    PDBG m_pDbg;
public:
    CMoInstance(COPY LPCWSTR wszClassName, PDBG m_pDbg, bool bParameter = false);
    ~CMoInstance();
    BOOL IsInput();

    INTERNAL LPCWSTR GetClassName() {return m_wszClassName;}

    HRESULT CreateWbemObject(READ_ONLY IWbemServices* pNamespace, 
         RELEASE_ME IWbemClassObject** ppObject, IWbemContext * pCtx);

    BOOL ApplyToWbemObject(OLE_MODIFY IWbemClassObject* pObject,IWbemServices* pNamespace, IWbemContext * pCtx)
        {return CMObject::ApplyToWbemObject(pObject, pNamespace, FALSE, pCtx); /* instance */ }

    HRESULT StoreWbemObject(READ_ONLY IWbemClassObject* pObject,
        long lClassFlags, long lInstanceFlags,
        OLE_MODIFY IWbemServices* pNamespace, IWbemContext * pCtx,
        WCHAR * pUserName, WCHAR * pPassword, WCHAR * pAuthority);

    BOOL IsInstance(){return TRUE;};
};

class CMoActionPragma : public CMObject
{
protected:
    LPWSTR m_wszClassName;
    PDBG m_pDbg;
    BOOL m_bFail;       // if true, the failure of the delete will stop the compile
	BOOL m_bClass;
public:
    CMoActionPragma(COPY LPCWSTR wszClassName, PDBG m_pDbg, bool bFail, BOOL bClass);
    ~CMoActionPragma();

    INTERNAL LPCWSTR GetClassName() {return m_wszClassName;}

    HRESULT CreateWbemObject(READ_ONLY IWbemServices* pNamespace, 
        RELEASE_ME IWbemClassObject** ppObject, IWbemContext * pCtx){return S_OK;};

    BOOL ApplyToWbemObject(OLE_MODIFY IWbemClassObject* pObject,IWbemServices* pNamespace, IWbemContext * pCtx)
        {return TRUE;}

    HRESULT StoreWbemObject(READ_ONLY IWbemClassObject* pObject,
        long lClassFlags, long lInstanceFlags,
        OLE_MODIFY IWbemServices* pNamespace, IWbemContext * pCtx,
        WCHAR * pUserName, WCHAR * pPassword, WCHAR * pAuthority);

    BOOL IsInstance(){return FALSE;};
    BOOL IsDelete(){return TRUE;};
    BOOL Split(COutput & out);

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\preproc.cpp ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PREPROC.CPP

Abstract:

    Implementation for the preprocessor.

History:

    a-davj      6-april-99   Created.

--*/

#include "precomp.h"
#include <arrtempl.h>
#include "trace.h"
#include "moflex.h"
#include "preproc.h"
#include <wbemcli.h>
#include <io.h>
#include <tchar.h>
#include "bmof.h"
#include "strings.h"

//***************************************************************************
//
//  WriteLineAndFilePragma
//
//  DESCRIPTION:
//
//  Write the line into the temp file which indicates what file and line number
//  is to follow.
//
//***************************************************************************

void WriteLineAndFilePragma(FILE * pFile, const TCHAR * pFileName, int iLine)
{
    WCHAR wTemp[50+MAX_PATH];
    WCHAR wFileName[MAX_PATH];
#ifdef UNICODE
    wcsncpy(wFileName, pFileName, MAX_PATH);
#else
    mbstowcs(wFileName, pFileName, MAX_PATH);
#endif
    WCHAR wFileName2[MAX_PATH+20];
    WCHAR * pFr, *pTo;
    for(pFr = wFileName, pTo = wFileName2; *pFr; pFr++, pTo++)
    {
        *pTo = *pFr;
        if(*pFr == L'\\')
        {
            pTo++;
            *pTo = L'\\';
        }
    }
    *pTo = 0;
    swprintf(wTemp, L"#line %d \"%s\"\r\n", iLine, wFileName2);
    WriteLine(pFile, wTemp);
}

//***************************************************************************
//
//  WriteLine(FILE * pFile, WCHAR * pLine)
//
//  DESCRIPTION:
//
//  Writes a single line out to the temporary file.
//
//***************************************************************************

void WriteLine(FILE * pFile, WCHAR * pLine)
{
    fwrite(pLine, 2, wcslen(pLine), pFile);
}

//***************************************************************************
//
//  IsBMOFBuffer
//
//  DESCRIPTION:
//
//  Used to check if a buffer is the start of a binary mof.
//
//***************************************************************************

bool IsBMOFBuffer(byte * pTest, DWORD & dwCompressedSize, DWORD & dwExpandedSize)
{

    DWORD * pdwRead = (DWORD *)pTest;

    if(*pdwRead == BMOF_SIG)
    {
        // ignore the compression type, and the Compressed Size
        
        pdwRead += 2;       // skip the compression type;
        
        dwCompressedSize = *pdwRead;
        pdwRead++;
        dwExpandedSize = *pdwRead;
        return true;        
    }
    return false;
}

//***************************************************************************
//
//  IsBinaryFile
//
//  DESCRIPTION:
//
//  returns true if the file contains a binary mof.
//
//***************************************************************************

bool IsBinaryFile(FILE * fp)
{

    // read the first 20 bytes

    BYTE Test[TEST_SIZE];
    int iRet = fread(Test, 1, TEST_SIZE, fp);
    fseek(fp, 0, SEEK_SET);

    if(iRet != TEST_SIZE)
    {
        // if we cant read even the header, it must not be a BMOF
        return false;
    }

    DWORD dwCompressedSize, dwExpandedSize;

    // Test if the mof is binary

    if(!IsBMOFBuffer(Test, dwCompressedSize, dwExpandedSize))
    {
        // not a binary mof.  This is the typical case
        return false;
    }
    return true;
}

//***************************************************************************
//
//  CheckForUnicodeEndian
//
//  DESCRIPTION:
//
//  Examines the first couple of bytes in a file and determines if the file
//  is in unicode and if so, if it is big endian.  It is assumed that the
//  file is pointing to the start and if the file is unicode, the pointer 
//  is left at the first actual data byte.
//
//***************************************************************************

void CheckForUnicodeEndian(FILE * fp, bool * punicode, bool * pbigendian)
{

    // Check for UNICODE source file.
    // ==============================

    BYTE UnicodeSignature[2];
    if (fread(UnicodeSignature, sizeof(BYTE), 2, fp) != 2)
    {
        *punicode = false;
        fseek(fp, 0, SEEK_SET);
        return ;
    }

    if (UnicodeSignature[0] == 0xFF && UnicodeSignature[1] == 0xFE)
    {
        *punicode = TRUE;
        *pbigendian = FALSE;
    }
    else if (UnicodeSignature[0] == 0xFE && UnicodeSignature[1] == 0xFF)
    {
        *punicode = TRUE;
        *pbigendian = TRUE;
    }
    else    // ANSI/DBCS.  Move back to start of file.
    {
        *punicode = false;
        fseek(fp, 0, SEEK_SET);
    }

}

//***************************************************************************
//
//  GetNextChar
//
//  DESCRIPTION:
//
//  Gets the next WCHAR from the file.
//
//***************************************************************************

WCHAR GetNextChar(FILE * fp, bool unicode, bool bigendian)
{
    WCHAR wRet[2];
    if(unicode)      // unicode file
    {
        if (fread(wRet, sizeof(wchar_t), 1, fp) == 0)
            return 0;
        if(bigendian)
        {
            wRet[0] = ((wRet[0] & 0xff) << 8) | ((wRet[0] & 0xff00) >> 8);
        }
    }
    else                    // single character file
    {
        char temp;
        if (fread(&temp, sizeof(char), 1, fp) == 0)
            return 0;
        if(temp == 0x1a)
            return 0;       // EOF for ascii files!
        swprintf(wRet, L"%C", temp);
    }
    return wRet[0];
}

//***************************************************************************
//
//  IsInclude
//
//  DESCRIPTION:
//
//  Looks at a line and determines if it is a #include line.  This is 
//  probably temporary since later we might have a preprocessor parser should
//  we start to add a lot of preprocessor features.
//
//***************************************************************************

HRESULT IsInclude(WCHAR * pLine, TCHAR * cFileNameBuff, bool & bReturn)
{

    bReturn = false;
    
    // Do a quick check to see if this could be a #include or #pragma include

    int iNumNonBlank = 0;
    WCHAR * pTemp;
    
    for(pTemp = pLine; *pTemp; pTemp++)
    {
        if(*pTemp != L' ')
        {
            iNumNonBlank++;
            if(iNumNonBlank == 1 && *pTemp != L'#')
                return false;
            if(iNumNonBlank == 2 && towupper(*pTemp) != L'I' && 
                                    towupper(*pTemp) != L'P')
                return S_OK;
            
            // we have established that the first two non blank characters are #I
            // or #p, therefore we continue on...

            if(iNumNonBlank > 1)
                break;
        }
    }

    // Create a version of the line with no blanks in front of the first quote

    WCHAR *wTemp = new WCHAR[wcslen(pLine) + 1];
    if(wTemp == NULL)
        return WBEM_E_OUT_OF_MEMORY;
    CDeleteMe<WCHAR> dm(wTemp);
    WCHAR *pTo;
    BOOL bFoundQuote = FALSE;
    for(pTo = wTemp, pTemp = pLine; *pTemp; pTemp++)
    {
        if(*pTemp == L'"')
            bFoundQuote = TRUE;
        if(*pTemp != L' ' || bFoundQuote)
        {
            *pTo = *pTemp;
            pTo++;
        }
    }
    *pTo = 0;

    // Verify that the line starts with #include(" or #pragma include

    WCHAR * pTest;
    if(_wcsnicmp(wTemp, L"#pragma", 7) == 0)
        pTest = wTemp+7;
    else
        pTest = wTemp+1;

    if(_wcsnicmp(pTest, L"include(\"", 9) || wcslen(pTest) < 12)
        return S_OK;

    // Count back from the end to find the previous "

    WCHAR *Last;
    for(Last = pTo-1; *Last && Last > wTemp+9 && *Last != L'"'; Last--);

    if(*Last != L'"')
        return S_OK;

    *Last = 0;

    CopyOrConvert(cFileNameBuff, pTest+9, MAX_PATH);
    bReturn =  true;
    return S_OK;
   
}

//***************************************************************************
//
//  ReadLine
//
//  DESCRIPTION:
//
//  Reads a single line from a file.
//
//  RETURN:
//
//  NULL if end of file, or error, other wise this is a pointer to a WCHAR
//  string which MUST BE FREED BY THE CALLER.
//
//***************************************************************************

WCHAR * ReadLine(FILE * pFile, bool unicode, bool bigendian)
{

    // Get the current position

    int iCurrPos = ftell(pFile);

    // count the number of characters in the line

    WCHAR wCurr;
    int iNumChar = 0;
    for(iNumChar = 0; wCurr = GetNextChar(pFile, unicode, bigendian); iNumChar++)
        if(wCurr == L'\n')
            break;
    if(iNumChar == 0 && wCurr == 0)
        return NULL;
    iNumChar+= 2;

    // move the file pointer back

    fseek(pFile, iCurrPos, SEEK_SET);

    // allocate the buffer

    WCHAR * pRet = new WCHAR[iNumChar+1];
    if(pRet == NULL)
        return NULL;

    // move the characters into the buffer

    WCHAR * pNext = pRet;
    for(iNumChar = 0; wCurr = GetNextChar(pFile, unicode, bigendian); pNext++)
    {
        *pNext = wCurr;
        if(wCurr == L'\n')
        {
           pNext++;
           break;
        }
    }
    *pNext = 0;
    return pRet;
}

//***************************************************************************
//
//  WriteFileToTemp
//
//  DESCRIPTION:
//
//  Writes the contests of a file to the temporay file.  The temporary file
//  will always be little endian unicode.  This will be called recursively
//  should an include be encountered.
//
//***************************************************************************

HRESULT WriteFileToTemp(const TCHAR * pFileName, FILE * pTempFile, CFlexArray & sofar, PDBG pDbg,CMofLexer* pLex)
{

    SCODE sc = S_OK;
    int iSoFarPos = -1;

    // Make sure the file isnt on the list already.  If it is, then fail since we would
    // be in a loop.  If it isnt, add it to the list.

    for(int iCnt = 0; iCnt < sofar.Size(); iCnt++)
    {
        TCHAR * pTemp = (TCHAR * )sofar.GetAt(iCnt);
        if(lstrcmpi(pTemp, pFileName) == 0)
        {
            Trace(true, pDbg, ERROR_RECURSIVE_INCLUDE, pFileName);
            return WBEM_E_FAILED;
        }
    }

    TCHAR * pNew = new TCHAR[lstrlen(pFileName) + 1];
    if(pNew)
    {
        lstrcpy(pNew, pFileName);
        sofar.Add((void *)pNew);
        iSoFarPos = sofar.Size()-1;
    }
    else
        return WBEM_E_OUT_OF_MEMORY;
        
    // Write the file and line number out

    WriteLineAndFilePragma(pTempFile, pFileName, 1);

    // Open the file

    FILE *fp;
#ifdef UNICODE
    fp = _wfopen(pFileName, L"rb");
#else
    fp = fopen(pFileName, "rb");
#endif
    if(fp == NULL)
    {
        Trace(true, pDbg, ERROR_INCLUDING_ABSENT, pFileName);
        pLex->SetError(CMofLexer::invalid_include_file);
        return WBEM_E_FAILED;
    }

    CfcloseMe cm(fp);

    // Make sure the file isnt binary

    if(IsBinaryFile(fp))
    {
        Trace(true, pDbg, ERROR_INCLUDING_ABSENT, pFileName);
        return WBEM_E_FAILED;
    }

    // Determine if the file is unicode and bigendian

    bool unicode, bigendian;
    CheckForUnicodeEndian(fp, &unicode, &bigendian);

    // Go through each line of the file, if it is another include, then recursively call this guy.
   
    WCHAR * pLine = NULL;
    for(int iLine = 1; pLine = ReadLine(fp, unicode, bigendian);)
    {
        CDeleteMe<WCHAR> dm(pLine);
        TCHAR cFileName[MAX_PATH+1];
        bool bInclude;
        HRESULT hr = IsInclude(pLine, cFileName, bInclude);
        if(FAILED(hr))
            return hr;
        if(bInclude)
        {
            TCHAR szExpandedFilename[MAX_PATH+1];
            DWORD nRes = ExpandEnvironmentStrings(cFileName,
                                                szExpandedFilename,
                                                FILENAME_MAX);
            if (nRes == 0)
            {
                //That failed!
                lstrcpy(szExpandedFilename, cFileName);
            }

            if (_taccess(szExpandedFilename,0))
            {
               // Included file not found, look in same directory as parent MOF file
 
               TCHAR cSrcPath[_MAX_PATH] = L"";
               TCHAR cSrcDrive[_MAX_DRIVE] = L"";
               TCHAR cSrcDir[_MAX_DIR] = L"";
 
               // Get drive and directory information of parent MOF file
 
               if (_tfullpath( cSrcPath, pFileName, _MAX_PATH ) != NULL)
               {
                  _tsplitpath(cSrcPath, cSrcDrive, cSrcDir, NULL, NULL);
               }
 
               // Copy original included MOF file information to cSrcPath
 
               _tcscpy(cSrcPath, szExpandedFilename);
 
               // Build up new full path of included MOF using the 
               // path of the parent MOF. 
               // Note: Intentionally did not use _makepath here. 
 
               _tcscpy(szExpandedFilename, L"");         // flush string
               _tcscat(szExpandedFilename, cSrcDrive);  // add drive info
               _tcscat(szExpandedFilename, cSrcDir);    // add directory info
               _tcscat(szExpandedFilename, cSrcPath);   // add original specified path and filename
            }

            sc = WriteFileToTemp(szExpandedFilename, pTempFile, sofar, pDbg, pLex);
            WriteLineAndFilePragma(pTempFile, pFileName, 1);
            if(sc != S_OK)
                break;
        }
        else
        {
            iLine++;
            WriteLine(pTempFile, pLine);
        }
    }

    // remove the entry so that the file can be included more than once at the same level

    if(iSoFarPos != -1)
    {
        TCHAR * pTemp = (TCHAR * )sofar.GetAt(iSoFarPos);
        if(pTemp)
        {
            delete pTemp;
            sofar.RemoveAt(iSoFarPos);
        }
    }
    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_tool\makefile.inc ===
!INCLUDE $(_NTDRIVE)$(_NTROOT)\WMI\COMMON\makefile.cmn
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\typehelp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    TYPEHELP.H

Abstract:

History:

--*/

#include "parmdefs.h"

WCHAR * Macro_CloneStr(LPCWSTR pFr);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\trace.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    TRACE.H

Abstract:

	Declares the Trace functions.

History:

	a-davj  13-July-97   Created.

--*/

#ifndef __TRACE__H_
#define __TRACE__H_

class DebugInfo
{
public:
	bool m_bPrint;
	WCHAR m_wcError[100];
	HRESULT hresError;
	void SetString(WCHAR * pIn){ wcsncpy(m_wcError, pIn, 99);};
	DebugInfo(bool bPrint) {m_bPrint = bPrint; m_wcError[0] = 0;m_wcError[99] = 0;hresError=0;};
	WCHAR * GetString(){return m_wcError;};
};

typedef DebugInfo * PDBG;

int Trace(bool bError, PDBG pDbg, DWORD dwID, ...);

class IntString
{
    TCHAR *m_pString;
public:
	 IntString(DWORD dwID);
	~IntString();
    operator TCHAR *() { return m_pString; } 
};

void CopyOrConvert(TCHAR * pTo, WCHAR * pFrom, int iLen);

class ParseState
{
public:
    int m_iPos;
    int m_nToken;
    ParseState(){ m_iPos=0; m_nToken= 0;};
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\strings.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

    STRINGS.H

Abstract:

	Resource definitions

History:

--*/


#define PARSING_MSG     0
#define ERROR_SYNTAX    PARSING_MSG+1
#define SUCCESS         ERROR_SYNTAX+1
#define SYNTAX_CHECK_COMPLETE  SUCCESS+1
#define STORING_BMOF          SYNTAX_CHECK_COMPLETE+1
#define STORING_DATA          STORING_BMOF+1
#define CANT_FIND_CLASS_NAME  STORING_DATA+1
#define INVALID_AUTORECOVER   CANT_FIND_CLASS_NAME + 1

#define SAFE_ARRAY_ERROR      50
#define UNEXPECTED_EOF        SAFE_ARRAY_ERROR+1
#define COMMENT_ERROR         UNEXPECTED_EOF+1
#define PREPROCESSOR          COMMENT_ERROR+1
#define NO_TYPEDEFS           PREPROCESSOR+1
#define ALIAS_PROP_ERROR      NO_TYPEDEFS+1
#define BAD_PROP_TYPE         ALIAS_PROP_ERROR+1
#define FILE_CREATE_FAILED    BAD_PROP_TYPE+1
#define FILE_WRITE_FAILED     FILE_CREATE_FAILED+1
#define ERROR_FORMAT          FILE_WRITE_FAILED+1
#define CR					  ERROR_FORMAT+1
#define WMI_LAUNCH_ERROR      CR+1
#define COMPRESSION_FAILED     WMI_LAUNCH_ERROR+1
#define ERROR_FORMATEX        COMPRESSION_FAILED+1
#define ERROR_FORMAT_LONG     ERROR_FORMATEX+1
#define INVALID_BMOF_OBJECT_TYPE ERROR_FORMAT_LONG+1


#define ERROR_INCLUDING_BINARY          158
#define ERROR_INCLUDING_ABSENT          159
#define ERROR_RECURSIVE_INCLUDE         160

#define ERROR_OPENING                   150
#define ERROR_OPENING_NO_LINES          151
#define ERROR_CREATING                  152
#define ERROR_CREATING_NO_LINES         153
#define ERROR_STORING                   154
#define ERROR_STORING_NO_LINES          155
#define ERROR_RESOLVING                 156
#define ERROR_RESOLVING_NO_LINES        157
#define ERRCTX_INVALID_DELETECLASS_SYNTAX         170
#define BMOF_INCOMPATIBLE                         171
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\preproc.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

    PREPROC.H

Abstract:

	Implementation for the preprocessor.

History:

	a-davj      6-april-99   Created.

--*/

#ifndef _PREPROC_H_
#define _PREPROC_H_

#define TEST_SIZE 20

bool IsBMOFBuffer(byte * pTest, DWORD & dwCompressedSize, DWORD & dwExpandedSize);
bool IsBinaryFile(FILE * fp);
void WriteLineAndFilePragma(FILE * pFile, const char * pFileName, int iLine);
void WriteLine(FILE * pFile, WCHAR * pLine);
HRESULT WriteFileToTemp(const TCHAR * pFileName, FILE * pTempFile, CFlexArray & sofar, PDBG pDbg, CMofLexer*);
void CheckForUnicodeEndian(FILE * fp, bool * punicode, bool * pbigendian);
WCHAR * ReadLine(FILE * pFilebool,bool unicode, bool bigendian);
WCHAR GetNextChar(FILE * pFile, bool unicode, bool bigendian);

HRESULT IsInclude(WCHAR * pLine, TCHAR * cFileNameBuff, bool & bReturn);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\trace.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    TRACE.CPP

Abstract:

    Support of trace output and internationalized strings.

History:

    a-davj  13-July-97   Created.

--*/

#include "precomp.h"
#include <wbemcli.h>
#include "trace.h"

extern HINSTANCE ghModule; 


TCHAR JustInCase = 0;

BSTR GetFromStdErrorFacility(HRESULT hres)
{

	HRESULT hTemp = hres;
	
	// Certain strings are obtained from the standard facility rather
	// than the local string table.

	if(hres == WBEM_E_NOT_FOUND || hres == WBEM_E_TYPE_MISMATCH || hres == WBEM_E_OVERRIDE_NOT_ALLOWED ||
		hres == WBEM_E_PROPAGATED_QUALIFIER || hres == WBEM_E_VALUE_OUT_OF_RANGE)
		return NULL;

	// we are only interested in 0x8004xxxx values.

	hTemp &= 0xffff0000;
	if(hTemp != 0x80040000)
		return NULL;

	// attempt to read the string from the usual place
	IWbemStatusCodeText * pStatus = NULL;
	SCODE sc = CoCreateInstance(CLSID_WbemStatusCodeText, 0, CLSCTX_INPROC_SERVER,
										IID_IWbemStatusCodeText, (LPVOID *) &pStatus);

	if(FAILED(sc))
		return NULL;
	BSTR bstrError = 0;
	sc = pStatus->GetErrorCodeText(hres, 0, 0, &bstrError);
	pStatus->Release();
	if(sc == S_OK)
		return bstrError;
	else
		return NULL;
}

IntString::IntString(DWORD dwID)
{
    DWORD dwSize, dwRet;

    // see if the message can be obtained for the standard place
    
	BSTR bstrErrMsg = GetFromStdErrorFacility((HRESULT)dwID);
	if(bstrErrMsg)
	{
		m_pString = new TCHAR[lstrlen(bstrErrMsg)+1];
		if(m_pString == NULL)
		{
			SysFreeString(bstrErrMsg);
            m_pString = &JustInCase;     // should never happen!
            return; 
		}
		lstrcpy(m_pString, bstrErrMsg);
    	SysFreeString(bstrErrMsg);
        return; 
	}

	// Get the message from the string table.
	
    for(dwSize = 128; dwSize < 4096; dwSize *= 2)
    {
        m_pString = new TCHAR[dwSize];
        if(m_pString == NULL)
        {
            m_pString = &JustInCase;     // should never happen!
            return; 
        }
        dwRet = LoadString( ghModule, dwID, m_pString, dwSize);

        // Check for failure to load

        if(dwRet == 0)
        {
            m_pString = &JustInCase;     // should never happen!
            return; 
        }
        // Check for the case where the buffer was too small

        if((dwRet + 1) >= dwSize)
            delete m_pString;
        else
            return;             // all is well!
    }
}

IntString::~IntString()
{
    if(m_pString != &JustInCase)
        delete(m_pString);
}
 
void CopyOrConvert(TCHAR * pTo, WCHAR * pFrom, int iLen)
{ 
#ifdef UNICODE
    wcsncpy(pTo, pFrom,iLen);
#else
    wcstombs(pTo, pFrom, iLen);
#endif
    pTo[iLen-1] = 0;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_tool\precomp.h ===
/*++

Copyright (C) 1999-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/
#pragma warning (disable : 4786)
#include <ole2.h>
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_tool\strings.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    STRINGS.H

Abstract:

	Resource definitions

History:

--*/


#define USAGE1 0
#define USAGE1A USAGE1+1
#define USAGE1B USAGE1A+1
#define USAGE1C USAGE1B+1
#define USAGE1D USAGE1C+1
#define USAGE1E USAGE1D+1
#define USAGE1F  USAGE1E+1
#define USAGE2  USAGE1F+1
#define USAGE3  USAGE2+1
#define USAGE4  USAGE3+1
#define USAGE4a  USAGE4+1
#define USAGE4b  USAGE4a+1
#define USAGE5  USAGE4b+1
#define USAGE6  USAGE5+1
#define USAGE7  USAGE6+1
#define USAGE8  USAGE7+1
#define USAGE9  USAGE8+1
#define USAGE10 USAGE9+1
#define USAGE11 USAGE10+1
#define USAGE12  USAGE11+1
#define USAGE12A  USAGE12+1
#define USAGE12B  USAGE12A+1
#define USAGE12C  USAGE12B+1
#define USAGE12D  USAGE12C+1
#define USAGE12E  USAGE12D+1

#define USAGE13  USAGE12E+1
#define USAGE14  USAGE13+1
#define WMI_ARG_ERROR  USAGE14+1
#define PARSING_MSG     WMI_ARG_ERROR+1
#define FILE_NOT_FOUND  PARSING_MSG+1
#define WMI_NOT_SETUP FILE_NOT_FOUND+1

#define  SUCCESS WMI_NOT_SETUP+1
#define  DONE SUCCESS+1
#define  WMI_LAUNCH_ERROR DONE+1
#define LONGVERSION WMI_LAUNCH_ERROR+1
#define SHORTVERSION LONGVERSION+1
#define COPYRIGHT SHORTVERSION+1
#define CCI_ERROR   COPYRIGHT+1
#define COMINIT_ERROR CCI_ERROR+1
#define COMPILER_ERROR COMINIT_ERROR+1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\64\bmofhelp.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    BMOFHELP.CPP

Abstract:

    Creates the object list from the binary mof file

History:

    a-davj  14-April-97   Created.

--*/

#include "precomp.h"
#include <stdio.h>
#include <float.h>
#include <mofout.h>
#include <mofparse.h>
#include <moflex.h>
#include <mofdata.h>

#include <typehelp.h>

#include <io.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/stat.h>
//#include "corepol.h"
#include <wbemutil.h>
#include <genutils.h>

#include "bmof.h"
#include "cbmofout.h"
#include "bmofhelp.h"
#include "trace.h"
#include "strings.h"
#include "mrcicode.h"

class CFreeMe
{
private:
    VARIANT * m_pVar;
public:
    CFreeMe(VARIANT * pVar){m_pVar = pVar;};
    ~CFreeMe();

};

CFreeMe::~CFreeMe()
{
    if(m_pVar)
    {
        VARTYPE vt = m_pVar->vt & ~VT_ARRAY;
        try
        {
            if(vt == VT_BSTR)
                VariantClear(m_pVar);
            else if(m_pVar->vt & VT_ARRAY)
                SafeArrayDestroyDescriptor(m_pVar->parray);
            m_pVar->vt = VT_EMPTY;


        }
        catch(...)
        {}
    }
}

//***************************************************************************
//
//  CMoQualifierArray *  CreateQual
//
//  DESCRIPTION:
//
//  Creates a CMoQualifierArray by using a CBMOFQualList object.
//
//  RETURN VALUE:
//
//  Pointer to new object, NULL if error.
//
//***************************************************************************

CMoQualifierArray *  CreateQual(CMofData * pOutput, CBMOFQualList * pql, CMObject * pObj,LPCWSTR wszPropName, PDBG pDbg)
{
    ResetQualList(pql);

    WCHAR * pName = NULL;
    CBMOFDataItem Data;
    VARIANT var;
    VariantInit(&var);
    CMoQualifierArray * pRet = new CMoQualifierArray(pDbg);
    if(pRet == NULL)
        return NULL;
    while(NextQual(pql, &pName, &Data))
    {
        BOOL bAliasRef;
        VariantInit(&var);
        BMOFToVariant(pOutput, &Data, &var, bAliasRef,FALSE, pDbg);
        CFreeMe fm(&var);
        CMoQualifier * pQual = new CMoQualifier(pDbg);
        if(pQual == NULL)
            return NULL;
        pQual->SetName(pName);
        BOOL bArray = var.vt & VT_ARRAY;
        if(bAliasRef && !bArray)
        {
            CMoValue & Value = pQual->AccessValue();
            AddAliasReplaceValue(Value, var.bstrVal);
        }
        else if(bAliasRef && bArray)
        {
            SAFEARRAY* psaSrc = var.parray;
            long lLBound, lUBound;
            SafeArrayGetLBound(psaSrc, 1, &lLBound);
            SafeArrayGetUBound(psaSrc, 1, &lUBound);
            CMoValue & Value = pQual->AccessValue();

            for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
            {
                // Load the initial data element into a VARIANT
                // ============================================

                BSTR bstr;
                SafeArrayGetElement(psaSrc, &lIndex, &bstr);

                if(bstr[0] == L'$')
                {
                    Value.AddAlias(&bstr[1], lIndex);   // skip the leading $
                    GUID guid;
                    CoCreateGuid(&guid);

                    WCHAR wszGuidBuffer[100];
                    StringFromGUID2(guid, wszGuidBuffer, 100);

                    BSTR bstrNew = SysAllocString(wszGuidBuffer);
                    SafeArrayPutElement(psaSrc, &lIndex, bstrNew);
                }
            }
            SCODE sc = WbemVariantChangeType(pQual->GetpVar(), &var, var.vt);
        }
        else
        {
            SCODE sc = WbemVariantChangeType(pQual->GetpVar(), &var, var.vt);
        }
//        VariantClear(&var);
        free(pName);
        pRet->Add(pQual);
    }
    pRet->RegisterAliases(pObj,wszPropName);
    return pRet;
}

//***************************************************************************
//
//  SCODE ConvertValue
//
//  DESCRIPTION:
//
//  Creates a CMoQualifierArray by using a CBMOFQualList object.
//
//  RETURN VALUE:
//
//  Pointer to new object, NULL if error.
//
//***************************************************************************

SCODE ConvertValue(CMoProperty * pProp, VARIANT * pSrc, BOOL bAliasRef)
{
    VARIANT * pDest;
    pDest = pProp->GetpVar();
    if((pSrc->vt & ~VT_ARRAY) == VT_EMBEDDED_OBJECT)
    {
        pDest->vt = pSrc->vt;
        pDest->punkVal = pSrc->punkVal;     // also works if this is parrayVal!
        return S_OK;
    }
    if(!bAliasRef)
        return WbemVariantChangeType(pProp->GetpVar(), pSrc, pSrc->vt);
    if(pSrc->vt == VT_BSTR)
    {
        CMoValue & Value = pProp->AccessValue();
        AddAliasReplaceValue(Value, pSrc->bstrVal);
        return S_OK;
    }
    if(pSrc->vt == (VT_BSTR | VT_ARRAY))
    {
        SAFEARRAY* psaSrc = V_ARRAY(pSrc);

        long lLBound, lUBound;
        SafeArrayGetLBound(psaSrc, 1, &lLBound);
        SafeArrayGetUBound(psaSrc, 1, &lUBound);

        // Stuff the individual data pieces
        // ================================

        for(long lIndex = lLBound; lIndex <= lUBound; lIndex++)
        {
            // Load the initial data element into a VARIANT
            // ============================================

            BSTR bstr;
            SafeArrayGetElement(psaSrc, &lIndex, &bstr);

            if(bstr[0] == L' ')
            {
                BSTR bstrNew = SysAllocString(&bstr[1]);
                SafeArrayPutElement(psaSrc, &lIndex, bstrNew);
            }
            else
            {
        
                CMoValue & Value = pProp->AccessValue();
                Value.AddAlias(&bstr[1],lIndex);  // skip over the $ used it indcate alias

                // Create a unique value and put it in there
                // =========================================

                GUID guid;
                CoCreateGuid(&guid);

                WCHAR wszGuidBuffer[100];
                StringFromGUID2(guid, wszGuidBuffer, 100);

                BSTR bstrNew = SysAllocString(wszGuidBuffer);
                SafeArrayPutElement(psaSrc, &lIndex, bstrNew);
            }
        }

        return WbemVariantChangeType(pProp->GetpVar(), pSrc, pSrc->vt);

    }
    else
        return WBEM_E_FAILED;
}

//***************************************************************************
//
//  BOOL ConvertBufferIntoIntermediateForm()
//
//  DESCRIPTION:
//
//  Creates a CMObject (the parse object format) from a CBMOFObj (binary mof format)
//  object.
//
//  PARAMETERS:
//
//  pOutput             Pointer to object that will hold the intermediate data.
//  pBuff               Binary mof data.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL ConvertBufferIntoIntermediateForm(CMofData * pOutput, BYTE * pBuff, PDBG pDbg)
{

    CBMOFObj * po;
    BOOL bRet;

    // Create a ObjList object

    CBMOFObjList * pol = CreateObjList(pBuff);
    ResetObjList(pol);

    while(po = NextObj(pol))
    {
        if(!BMOFParseObj(pOutput, po, NULL, FALSE, pDbg))
            return FALSE;
        free(po);
    }
    bRet = TRUE;            // Got all the way through with no errors.
    free(pol);

    return bRet;
}


//***************************************************************************
//
//  BOOL BMOFParseObj
//
//  DESCRIPTION:
//
//  Creates a CMObject (the parse object format) from a CBMOFObj (binary mof format)
//  object.
//
//  PARAMETERS:
//
//  pObj                pointer to binary mof object.
//  pVar                poninter to a variant which will point to the resulting 
//                      object.  If this is NULL, then the object is a top level
//                      (not embedded) object and it will be added to the main
//                      object list.
//
//  RETURN VALUE:
//
//  TRUE if OK.
//
//***************************************************************************

BOOL BMOFParseObj(CMofData * pOutput, CBMOFObj * po, VARIANT * pVar, BOOL bMethArg, PDBG pDbg)
{
    VARIANT var;
    CBMOFDataItem Data;
    WCHAR * pClassName;
    BOOL bAliasRef;
    CMoQualifierArray * paQualifiers;
    CMObject * pObject = NULL;

    // Check the type.  This is a sanity check for weeding out old format files!

    DWORD dwType = GetType(po);
    if(dwType != 0 && dwType != 1)
    {
        Trace(true,pDbg,INVALID_BMOF_OBJECT_TYPE);
        return FALSE;
    }

    // Create either the new class of instance object

    if(!GetName(po, &pClassName))
    {
        Trace(true,pDbg, CANT_FIND_CLASS_NAME);
        return FALSE;
    }
    
    if(GetType(po) == 0)
    {
        if(FindProp(po, L"__SuperClass", &Data))
        {
            BMOFToVariant(pOutput, &Data, &var, bAliasRef, FALSE, pDbg);

            pObject = new CMoClass( var.bstrVal, pClassName, pDbg);
            VariantClear(&var);
        }
        else
            pObject = new CMoClass( NULL, pClassName, pDbg);
    }
    else
    {
        pObject = new CMoInstance(pClassName, pDbg);
    }
    free(pClassName);
    if(pObject == NULL)
        return FALSE;

    // Get the namespace and add it

    if(FindProp(po, L"__Namespace", &Data))
    {
        BMOFToVariant(pOutput, &Data, &var, bAliasRef, FALSE, pDbg);
        pObject->SetNamespace(var.bstrVal);
        VariantClear(&var);
    }

    // Add other pragma values

    long lClass = 0;
    long lInstance = 0;
    if(FindProp(po, L"__ClassFlags", &Data))
    {
        BMOFToVariant(pOutput, &Data, &var, bAliasRef, FALSE, pDbg);
        lClass = var.lVal;
        VariantClear(&var);
    }
    if(FindProp(po, L"__InstanceFlags", &Data))
    {
        BMOFToVariant(pOutput, &Data, &var, bAliasRef, FALSE, pDbg);
        lInstance = var.lVal;
        VariantClear(&var);
    }
    pObject->SetOtherDefaults(lClass, lInstance);


    if(FindProp(po, L"__ALIAS", &Data))
    {
        BMOFToVariant(pOutput, &Data, &var, bAliasRef, FALSE, pDbg);
        pObject->SetAlias(var.bstrVal);
        VariantClear(&var);
    }

    CBMOFQualList * pql = GetQualList(po);
    if(pql)
    {
        paQualifiers = CreateQual(pOutput, pql, pObject, NULL, pDbg);
        if(paQualifiers)
            pObject->SetQualifiers(paQualifiers);
        free(pql);
    }

    ResetObj(po);

    WCHAR * pPropName = NULL;

    while(NextProp(po, &pPropName, &Data))
    {
        VariantInit(&var);
        BOOL bGotValue = BMOFToVariant(pOutput, &Data, &var, bAliasRef, FALSE, pDbg);
        CFreeMe fm(&var);
            
        // ignore these special properties

        if(!_wcsicmp(pPropName,L"__Class") || 
           !_wcsicmp(pPropName,L"__SuperClass") ||
           !_wcsicmp(pPropName,L"__ALIAS") ||
           !_wcsicmp(pPropName,L"__CLASSFLAGS") ||
           !_wcsicmp(pPropName,L"__INSTANCEFLAGS") ||
           !_wcsicmp(pPropName,L"__NameSpace"))
        {
            free(pPropName);
            continue;
        }


        CValueProperty * pProp = new CValueProperty(NULL, pDbg);
        if(pProp == NULL)
            return FALSE;
        pProp->SetName(pPropName);

        pql = GetPropQualList(po, pPropName);
        if(pql)
        {
            if(paQualifiers = CreateQual(pOutput, pql, pObject, pPropName, pDbg))
                pProp->SetQualifiers(paQualifiers);
            free(pql);
        }
        if(bGotValue)
        {
            SCODE sc = ConvertValue(pProp, &var, bAliasRef);
        }
        else
        {
            VARIANT * pVar = pProp->GetpVar();
            pVar->vt = VT_NULL;
            pVar->lVal = 0;
        }

        // Set the type.  Note that numeric types are stored as strings and so it is necessary to
        // get the type from the cimtype qualifier

        CMoValue* pValue = paQualifiers->Find(L"CIMTYPE");
        if(pValue)
        {
            CMoType Type(pDbg);
            VARIANT& var = pValue->AccessVariant();
            if(var.vt == VT_BSTR && var.bstrVal)
            {
                Type.SetTitle(var.bstrVal);
                VARTYPE vt = Type.GetCIMType();
                if(Data.m_dwType & VT_ARRAY)
                    vt |= VT_ARRAY;
                pProp->SetType(vt);
            }
        }
        else
            pProp->SetType((VARTYPE)Data.m_dwType);

        pObject->AddProperty(pProp);
        pProp->RegisterAliases(pObject);
        if(bMethArg)
            pProp->SetAsArg();

        free(pPropName);
    }

    // Get the methods
    
    WCHAR * pMethName = NULL;

    while(NextMeth(po, &pMethName, &Data))
    {
        VariantClear(&var);
        BOOL bGotValue = BMOFToVariant(pOutput, &Data, &var, bAliasRef, TRUE, pDbg);
        CFreeMe fm(&var);
        CMethodProperty * pMeth = new CMethodProperty(NULL, pDbg);
        if(pMeth == NULL)
            return FALSE;
        pMeth->SetName(pMethName);

        pql = GetMethQualList(po, pMethName);
        if(pql)
        {
            if(paQualifiers = CreateQual(pOutput, pql, pObject, pMethName, pDbg))
                pMeth->SetQualifiers(paQualifiers);
            free(pql);
        }
        if(bGotValue)
        {
            SCODE sc = ConvertValue(pMeth, &var, bAliasRef);

            long lLower, lUpper, lCnt;
            sc = SafeArrayGetLBound(var.parray, 1, &lLower);
            sc = SafeArrayGetUBound(var.parray, 1, &lUpper);
            CMoInstance * pTemp;

            for(lCnt = lLower; lCnt <= lUpper; lCnt++)
            {
                pTemp = NULL;
                sc = SafeArrayGetElement(var.parray, &lCnt, &pTemp);
                if(sc == S_OK && pTemp)
                {
                    // If there are two objects, then the first is inputs and the second outputs.  If there
                    // is just one, examine the object 

                    if(lLower != lUpper && lCnt == lLower)
                        pMeth->SetIn(pTemp);
                    else if(lLower != lUpper && lCnt == lUpper)
                        pMeth->SetOut(pTemp);
                    else if(pTemp->IsInput())
                        pMeth->SetIn(pTemp);
                    else 
                        pMeth->SetOut(pTemp);
                }
            }
        }
        else
        {
            VARIANT * pVar = pMeth->GetpVar();
            pVar->vt = VT_NULL;
            pVar->lVal = 0;
        }
        pMeth->SetType((VARTYPE)Data.m_dwType);

        pObject->AddProperty(pMeth);
        pMeth->RegisterAliases(pObject);

        free(pMethName);
    }


    if(pVar)
    {
        pVar->punkVal = (IUnknown *)pObject;
    }
    else
        pOutput->AddObject(pObject);
    return TRUE;
}

//***************************************************************************
//
//  BOOL BMOFToVariant
//
//  DESCRIPTION:
//
//  Converts a bmof data object into a variant
//
//***************************************************************************

BOOL BMOFToVariant(CMofData * pOutput, CBMOFDataItem * pData, VARIANT * pVar, BOOL & bAliasRef, BOOL bMethodArg, PDBG pDbg)
{
    VariantInit(pVar);
    DWORD dwSimpleType = pData->m_dwType & ~VT_ARRAY & ~VT_BYREF;
    bAliasRef = pData->m_dwType & VT_BYREF;

    long lFirstDim;
    VARIANT vTemp;  

    long lNumDim = GetNumDimensions(pData);
    if(lNumDim == -1)
        return FALSE;

    pVar->vt = (WORD)pData->m_dwType & ~VT_BYREF;

    if(lNumDim == 0)
    {
        memset((BYTE *)&(vTemp.lVal),0,8);
        if(!GetData(pData, (BYTE *)&(vTemp.lVal), NULL))
        {
            pVar->vt = VT_EMPTY;
            return FALSE;
        }
        if(dwSimpleType == VT_BSTR)
        {
            pVar->bstrVal = SysAllocString(vTemp.bstrVal);
            BMOFFree(vTemp.bstrVal);
        }
        else if(dwSimpleType == VT_EMBEDDED_OBJECT)
        {
            CBMOFObj * pObj;
            pObj = (CBMOFObj *)vTemp.bstrVal;
            BMOFParseObj(pOutput, pObj, pVar, bMethodArg, pDbg);
            BMOFFree(pObj);
            return TRUE;
        }
        else
            memcpy((void *)&(pVar->bstrVal), (void *)&(vTemp.bstrVal),8); 

        return TRUE;
    }
        
    
    lFirstDim = GetNumElements(pData, 0);

    
    DWORD ulLower, ulUpper;
    
    SAFEARRAY * psa;
    SAFEARRAYBOUND rgsabound[1];
    long ix[2] = {0,0};
    ulLower = 0;
    ulUpper = lFirstDim-1;
    rgsabound[0].lLbound = ulLower;
    rgsabound[0].cElements = ulUpper - ulLower +1;
    
    VARTYPE vtSubstitute;
    if(sizeof(DWORD *) == 8)
        vtSubstitute = VT_R8;
    else
        vtSubstitute = VT_I4;
    VARTYPE vtTemp = (dwSimpleType == VT_EMBEDDED_OBJECT) ? vtSubstitute : (VARTYPE)dwSimpleType;
    psa = SafeArrayCreate(vtTemp,1,rgsabound);
    for(ix[0] = ulLower; ix[0] <= (long)ulUpper; ix[0]++) 
    {

        memset((BYTE *)&(vTemp.lVal),0,8);

        GetData(pData, (BYTE *)&(vTemp.lVal), ix);  
        if(dwSimpleType == VT_BSTR)
        {
            BSTR bstr = SysAllocString(vTemp.bstrVal);
            free(vTemp.bstrVal);
            vTemp.vt = VT_EMPTY;
            if(bstr == NULL)
            {
                pVar->vt = VT_EMPTY;
                return FALSE;
            }
            SafeArrayPutElement(psa,ix,(void *)bstr);
            SysFreeString(bstr);
        }
        else if(dwSimpleType == VT_EMBEDDED_OBJECT)
        {
            CBMOFObj * pObj;
            VARIANT vConv;
            VariantInit(&vConv);
            pObj = (CBMOFObj *)vTemp.punkVal;
            BMOFParseObj(pOutput, pObj, &vConv, bMethodArg, pDbg);
            free(pObj);
            SafeArrayPutElement(psa,ix,(void *)&vConv.lVal);
        }
        else
        {
            memcpy((void *)&(pVar->bstrVal), (void *)&(vTemp.bstrVal),8); 
            SafeArrayPutElement(psa,ix,(void *)&(vTemp.lVal));
        }
    
 //       VariantClear(&vTemp);
    }
    pVar->parray = psa;
    return TRUE;

}

//***************************************************************************
//
//  void AddAliasReplaceValue
//
//  DESCRIPTION:
//
//  Used when a Value has an alias.
//
//  RETURN VALUE:
//
//  TRUE if the file is a binary mof
//
//***************************************************************************

void AddAliasReplaceValue(CMoValue & Value, const WCHAR * pAlias)
{

    Value.AddAlias(pAlias);
    V_VT(&Value.AccessVariant()) = VT_BSTR;

        // Create a unique value and put it in there
        // =========================================

    GUID guid;
    CoCreateGuid(&guid);

    WCHAR wszGuidBuffer[100];
    StringFromGUID2(guid, wszGuidBuffer, 100);

    V_BSTR(&Value.AccessVariant()) = SysAllocString(wszGuidBuffer);

}

extern "C" void * BMOFAlloc(size_t Size)
{
    return malloc(Size);
}
extern "C" void BMOFFree(void * pFree)
{
    free(pFree);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_dll\64\cbmofout.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    CBMOFOUT.CPP

Abstract:

    Declares the CBMOFOut class.

History:

    a-davj  06-April-97   Created.

--*/

#include "precomp.h"
#include "wstring.h"
#include "mofout.h"
#include "mofdata.h"
#include "bmof.h"
#include "cbmofout.h"
#include "trace.h"
#include "strings.h"
#include <wbemutil.h>

//***************************************************************************
//
//  CBMOFOut::CBMOFOut
//
//  DESCRIPTION:
//
//  Constructor.  Save the eventual destination name and writes the initial
//  structure out to the buffer.  NOTE THAT TYPICALLY THE BMOFFileName will
//  be NULL and this object will not do anything.  That deals with the 99%
//  of mofs that are not WMI!
//
//  PARAMETERS:
//
//  BMOFFileName        Name of file to eventually write to.
//
//***************************************************************************

CBMOFOut::CBMOFOut(
                   IN LPTSTR BMOFFileName, PDBG pDbg) : m_OutBuff(pDbg)
{
    m_pDbg = pDbg;
    m_BinMof.dwSignature = BMOF_SIG;              // spells BMOF
    m_BinMof.dwLength = sizeof(WBEM_Binary_MOF);     // updated at end
    m_BinMof.dwVersion = 1;            // 0x1
    m_BinMof.dwEncoding = 1;           // 0x1 = little endian, DWORD-aligned, no compression
    m_BinMof.dwNumberOfObjects = 0;    // Total classes and instances in MOF


    if(BMOFFileName && lstrlen(BMOFFileName) > 0)
    {
        m_pFile = new TCHAR[lstrlen(BMOFFileName) + 1];
        if(m_pFile)
        {
            lstrcpy(m_pFile, BMOFFileName);
            m_OutBuff.AppendBytes((BYTE *)&m_BinMof, sizeof(WBEM_Binary_MOF));
        }
    }
    else 
        m_pFile = NULL;


}
//***************************************************************************
//
//  CBMOFOut::~CBMOFOut
//
//  DESCRIPTION:
//
//  Destructor.
//
//***************************************************************************

CBMOFOut::~CBMOFOut()
{
    if(m_pFile)
        delete m_pFile;
}


//***************************************************************************
//
//  DWORD CBMOFOut::AddClass
//
//  DESCRIPTION:
//
//  Adds a class to the BMOF buffer.
//
//  PARAMETERS:
//
//  pObject             pointer to class object.  
//  bEmbedded           TRUE if object is embedded.
//
//  RETURN VALUE:
//
//  Number of bytes written.
//
//***************************************************************************

DWORD CBMOFOut::AddClass(
                        IN CMObject * pObject,
                        IN BOOL bEmbedded)
{
    DWORD dwStartingOffset = m_OutBuff.GetOffset();
    CMoQualifierArray * pQualifierSet = NULL;
    if(!m_pFile)
        return 0;
    WBEM_Object wo;

    wo.dwLength = sizeof(WBEM_Object);       // updated later
    wo.dwOffsetQualifierList = 0xffffffff;
    wo.dwOffsetPropertyList = 0xffffffff;
    wo.dwOffsetMethodList = 0xffffffff;
    wo.dwType = (pObject->IsInstance()) ? 1 : 0;   // 0 = class, 1 = instance

    m_OutBuff.AppendBytes((BYTE *)&wo, sizeof(WBEM_Object));
    DWORD dwStartInfoOffset = m_OutBuff.GetOffset();


    // Write class qualifier

    pQualifierSet = pObject->GetQualifiers();
    if(pQualifierSet)
    {
        wo.dwOffsetQualifierList = m_OutBuff.GetOffset() - dwStartInfoOffset;
        AddQualSet(pQualifierSet);
    }

    wo.dwOffsetPropertyList = m_OutBuff.GetOffset() - dwStartInfoOffset;
    AddPropSet(pObject);

    wo.dwOffsetMethodList = m_OutBuff.GetOffset() - dwStartInfoOffset;
    AddMethSet(pObject);

    wo.dwLength = m_OutBuff.GetOffset() - dwStartingOffset;
    m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&wo, sizeof(WBEM_Object));

    // If the object is not embedded, update the structure that keeps track 
    // of top level objects.

    if(!bEmbedded)
    {
        m_BinMof.dwNumberOfObjects++;
        m_BinMof.dwLength = m_OutBuff.GetOffset();
        m_OutBuff.WriteBytes(0, (BYTE *)&m_BinMof, 
                            sizeof(WBEM_Binary_MOF));
    }

    return wo.dwLength;
}

//***************************************************************************
//
//  DWORD CBMOFOut::AddQualSet
//
//  DESCRIPTION:
//
//  Adds a qualifier set to the BMOF buffer.
//
//  PARAMETERS:
//
//  pQualifierSet       pointer to qualifier object. 
//
//  RETURN VALUE:
//
//  Number of bytes written.
//
//***************************************************************************

DWORD CBMOFOut::AddQualSet(
                        IN CMoQualifierArray * pQualifierSet)
{
    DWORD dwStartingOffset = m_OutBuff.GetOffset();
    WBEM_QualifierList ql;
    ql.dwLength = sizeof(WBEM_QualifierList);
    ql.dwNumQualifiers = 0;

    m_OutBuff.AppendBytes((BYTE *)&ql, sizeof(WBEM_QualifierList));
    BSTR bstr = NULL;
    VARIANT var;
    VariantInit(&var);

    int i;
    for(i = 0; i < pQualifierSet->GetSize(); i++)
    {
        CMoQualifier * pQual = pQualifierSet->GetAt(i);
        if(pQual)
        {
            ql.dwNumQualifiers++;
            AddQualifier(pQual->GetName(), pQual->GetpVar(), pQual);
        }
    }
    
    ql.dwLength = m_OutBuff.GetOffset() - dwStartingOffset;
    m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&ql, 
                                    sizeof(WBEM_QualifierList));
    return ql.dwLength;
}

//***************************************************************************
//
//  DWORD CBMOFOut::AddPropSet
//
//  DESCRIPTION:
//
//  Adds the property set to the BMOF buffer.
//
//  PARAMETERS:
//
//  pObject          pointer to class object.
//
//  RETURN VALUE:
//
//  Number of bytess written
//
//***************************************************************************

DWORD CBMOFOut::AddPropSet(
                        IN CMObject * pObject)
{
    DWORD dwStartingOffset = m_OutBuff.GetOffset();
    WBEM_PropertyList pl;

    BSTR bstr = NULL;
    VARIANT var;
    VariantInit(&var);
    IWbemQualifierSet* pQual = NULL;

    pl.dwLength = sizeof(WBEM_PropertyList);       // updated later
    pl.dwNumberOfProperties = 0;
    m_OutBuff.AppendBytes((BYTE *)&pl, sizeof(WBEM_PropertyList));

    // Loop through the properties

    int i;
    for(i = 0; i < pObject->GetNumProperties(); i++)
    {
        CMoProperty * pProp = pObject->GetProperty(i);
        if(pProp && pProp->IsValueProperty())
        {
            pl.dwNumberOfProperties++;
            CMoQualifierArray * pQual = pProp->GetQualifiers();
            AddProp(pProp->GetName(), pProp->GetpVar(), pQual,pProp->GetType(),pProp);
        }
    }
    
    // Store the class name and possibly the parent name as properties.

    VariantInit(&var);
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(pObject->GetClassName()); 
    AddProp(L"__CLASS", &var, NULL,VT_BSTR,NULL);
    pl.dwNumberOfProperties++;
    VariantClear(&var);

    if(pObject->GetNamespace() && wcslen(pObject->GetNamespace()) > 0)
    {
        VariantInit(&var);
        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString(pObject->GetNamespace()); 
        AddProp(L"__NAMESPACE", &var, NULL,VT_BSTR,NULL);
        pl.dwNumberOfProperties++;
        VariantClear(&var);
    }

    if(pObject->GetClassFlags() != 0)
    {
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = pObject->GetClassFlags(); 
        AddProp(L"__CLASSFLAGS", &var, NULL,VT_I4,NULL);
        pl.dwNumberOfProperties++;
        VariantClear(&var);
    }
    if(pObject->GetInstanceFlags() != 0)
    {
        VariantInit(&var);
        var.vt = VT_I4;
        var.lVal = pObject->GetInstanceFlags(); 
        AddProp(L"__INSTANCEFLAGS", &var, NULL,VT_I4,NULL);
        pl.dwNumberOfProperties++;
        VariantClear(&var);
    }

    if(pObject->GetAlias() && wcslen(pObject->GetAlias()) > 0)
    {
        VariantInit(&var);
        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString(pObject->GetAlias()); 
        AddProp(L"__ALIAS", &var, NULL,VT_BSTR,NULL);
        pl.dwNumberOfProperties++;
        VariantClear(&var);
    }

    if(!pObject->IsInstance())
    {
        CMoClass * pClass = (CMoClass * )pObject;
        var.vt = VT_BSTR;
        if(pClass->GetParentName() && wcslen(pClass->GetParentName()) > 0)
        {
            var.bstrVal = SysAllocString(pClass->GetParentName()); 
            AddProp(L"__SUPERCLASS", &var, NULL,VT_BSTR,NULL);
            pl.dwNumberOfProperties++;
            VariantClear(&var);
        }
    };

    
    pl.dwLength = m_OutBuff.GetOffset() - dwStartingOffset;
    m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&pl, 
                                    sizeof(WBEM_PropertyList));
    return pl.dwLength;
}

//***************************************************************************
//
//  DWORD CBMOFOut::AddMethSet
//
//  DESCRIPTION:
//
//  Adds the method set to the BMOF buffer.
//
//  PARAMETERS:
//
//  pObject          pointer to class object.
//
//  RETURN VALUE:
//
//  Number of bytess written
//
//***************************************************************************

DWORD CBMOFOut::AddMethSet(
                        IN CMObject * pObject)
{
    DWORD dwStartingOffset = m_OutBuff.GetOffset();
    WBEM_PropertyList ml;
    SCODE sc;

    IWbemQualifierSet* pQual = NULL;

    ml.dwLength = sizeof(WBEM_PropertyList);       // updated later
    ml.dwNumberOfProperties = 0;
    m_OutBuff.AppendBytes((BYTE *)&ml, sizeof(WBEM_PropertyList));

    // Loop through the properties

    int i;
    for(i = 0; i < pObject->GetNumProperties(); i++)
    {
        CMoProperty * pProp = pObject->GetProperty(i);
        if(pProp && !pProp->IsValueProperty())
        {
            ml.dwNumberOfProperties++;
            CMoQualifierArray * pQual = pProp->GetQualifiers();

            // Create a variant that has an array of embedded object for each of out
            // input and output arg sets

            CMethodProperty * pMeth = (CMethodProperty *)pProp;
            VARIANT vSet;
            if(pMeth->GetInObj() || pMeth->GetOutObj())
            {
                vSet.vt = VT_ARRAY | VT_EMBEDDED_OBJECT;

                SAFEARRAYBOUND aBounds[1];
                
                // Note the you might have either inputs, or ouputs, or both

                if(pMeth->GetInObj() && pMeth->GetOutObj())
                    aBounds[0].cElements = 2;
                else
                    aBounds[0].cElements = 1;
                aBounds[0].lLbound = 0;
                VARTYPE vtSubstitute;
                if(sizeof(DWORD *) == 8)
                    vtSubstitute = VT_R8;
                else
                    vtSubstitute = VT_I4;

                vSet.parray = SafeArrayCreate(vtSubstitute, 1, aBounds);
                if(vSet.parray == NULL)
                    return FALSE;
                long lIndex = 0;
                VARIANT var;

                if(pMeth->GetInObj())
                {
                    var.punkVal = (IUnknown *)pMeth->GetInObj();
                    sc = SafeArrayPutElement(vSet.parray, &lIndex, &var.punkVal);
                    lIndex = 1;
                }
                if(pMeth->GetOutObj())
                {
                    var.punkVal = (IUnknown *)pMeth->GetOutObj();
                    sc = SafeArrayPutElement(vSet.parray, &lIndex, &var.punkVal);
                }
            }
            else
                vSet.vt = VT_NULL;
            AddProp(pProp->GetName(), &vSet, pQual,pProp->GetType(),pProp);
        }
    }
    
    ml.dwLength = m_OutBuff.GetOffset() - dwStartingOffset;
    m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&ml, 
                                    sizeof(WBEM_PropertyList));
    return ml.dwLength;
}

//***************************************************************************
//
//  DWORD CBMOFOut::AddProp
//
//  DESCRIPTION:
//
//  Adds a single property to the BMOF buffer.
//
//  PARAMETERS:
//
//  bstr                property name
//  pvar                variant containing value
//  pQual               pointer to qualifier set if any.  Caller will release.
//  dwType              data type.  Note that the variant might have type
//                      VT_NULL if the property doesnt have a value.
//  RETURN VALUE:
//
//  Number of bytes written
//
//***************************************************************************

DWORD CBMOFOut::AddProp(
                        IN BSTR bstr, 
                        IN VARIANT * pvar, 
                        IN CMoQualifierArray * pQual,
                        IN DWORD dwType,
                        IN CMoProperty * pProp)
{
    DWORD dwStartingOffset = m_OutBuff.GetOffset();
    WBEM_Property prop;
    prop.dwLength = sizeof(WBEM_Property);
    if(pvar->vt == VT_NULL || pvar->vt == VT_EMPTY)
        prop.dwType = dwType;
    else
        prop.dwType = pvar->vt;

    prop.dwOffsetName = 0xffffffff;
    prop.dwOffsetValue = 0xffffffff;
    prop.dwOffsetQualifierSet = 0xffffffff;
    m_OutBuff.AppendBytes((BYTE *)&prop, sizeof(WBEM_Property));

    DWORD dwStartInfoOffset =  m_OutBuff.GetOffset();

    if(bstr)
    {
        prop.dwOffsetName = m_OutBuff.GetOffset() - dwStartInfoOffset;
        m_OutBuff.WriteBSTR(bstr);
    }
    
    if(pvar->vt != VT_EMPTY && pvar->vt != VT_NULL)
    {
        prop.dwOffsetValue = m_OutBuff.GetOffset() - dwStartInfoOffset;
        if(pProp)
        {
            CMoValue& Value = pProp->AccessValue();
            AddVariant(pvar, &Value);
            prop.dwType = pvar->vt;
        }
        else 
            AddVariant(pvar, NULL);
    }

    if(pQual)
    {
        prop.dwOffsetQualifierSet = m_OutBuff.GetOffset() - dwStartInfoOffset;
        AddQualSet(pQual);
    }

    prop.dwLength = m_OutBuff.GetOffset() - dwStartingOffset;
    m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&prop, 
                                    sizeof(WBEM_Property));
    return 1;

}


//***************************************************************************
//
//  DWORD CBMOFOut::AddQualifier
//
//  DESCRIPTION:
//
//  Adds a qualifier to the BMOF buffer.
//
//  PARAMETERS:
//
//  bstr                qualifer name
//  pvar                qualifier value
//
//  RETURN VALUE:
//
//  Number of bytes written.
//
//***************************************************************************

DWORD CBMOFOut::AddQualifier(
                        IN BSTR bstr, 
                        IN VARIANT * pvar,
                        CMoQualifier * pQual)
{
    WBEM_Qualifier qu;
    DWORD dwStartingOffset = m_OutBuff.GetOffset();
    
    qu.dwLength = sizeof(WBEM_Qualifier);           // filled in later
    qu.dwType = pvar->vt;
    qu.dwOffsetName = 0xffffffff;
    qu.dwOffsetValue = 0xffffffff;
    m_OutBuff.AppendBytes((BYTE *)&qu, sizeof(WBEM_Qualifier));
    DWORD dwStartInfoOffset = m_OutBuff.GetOffset();

    // Write the qualifier name and data

    if(bstr)
    {
        qu.dwOffsetName = m_OutBuff.GetOffset() - dwStartInfoOffset;
        m_OutBuff.WriteBSTR(bstr);
    }

    if(pvar->vt != VT_EMPTY && pvar->vt != VT_NULL)
    {
        CMoValue& Value = pQual->AccessValue();

        qu.dwOffsetValue = m_OutBuff.GetOffset() - dwStartInfoOffset;
        

        AddVariant(pvar, &Value);
        qu.dwType = pvar->vt;
    }
    qu.dwLength = m_OutBuff.GetOffset() - dwStartingOffset;
    m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&qu, 
                                    sizeof(WBEM_Qualifier));

    return 0;
}

//***************************************************************************
//
//  DWORD CBMOFOut::AddVariant
//
//  DESCRIPTION:
//
//  Adds a value to the BMOF buffer.
//
//  PARAMETERS:
//
//  pvar                value to add.
//
//  RETURN VALUE:
//
//  Total bytes written
//
//***************************************************************************

DWORD CBMOFOut::AddVariant(VARIANT * pvar, CMoValue * pValue)
{

    if(pValue && pValue->GetNumAliases() > 0)
        pvar->vt |= VT_BYREF;

    VARTYPE vtSimple = pvar->vt & ~VT_ARRAY  & ~VT_BYREF;

    if(pvar->vt & VT_ARRAY)
    {
        DWORD dwStartingOffset = m_OutBuff.GetOffset();
        DWORD dwSize = 0;
        m_OutBuff.AppendBytes((BYTE *)&dwSize, sizeof(DWORD));

        DWORD dwTotal = 0;
        SCODE sc;
        SAFEARRAY * psa;
        long ix[2] = {0,0};
        long uLower, uUpper;
        psa = pvar->parray;
        sc = SafeArrayGetLBound(psa,1,&uLower);
        sc |= SafeArrayGetUBound(psa,1,&uUpper);
        if(sc != S_OK)
            return 0;
        
        // write the number of dimensions and the size of each
        
        DWORD dwNumDim = 1;                                     // for now!!!
        m_OutBuff.AppendBytes((BYTE *)&dwNumDim, sizeof(long)); // Number of dimensions
        DWORD dwNumElem = uUpper - uLower + 1;
        m_OutBuff.AppendBytes((BYTE *)&dwNumElem, sizeof(long));

        // Write out the row size

        DWORD dwStartingRowOffset = m_OutBuff.GetOffset();
        DWORD dwRowSize = 0;
        m_OutBuff.AppendBytes((BYTE *)&dwRowSize, sizeof(DWORD));

        // Get each element and write it

        for(ix[0] = uLower; ix[0] <= uUpper && sc == S_OK; ix[0]++) 
        {
            VARIANT var;
            VariantInit(&var);
            var.vt = vtSimple;
            sc = SafeArrayGetElement(psa,ix,&var.bstrVal);
            if(sc != S_OK)
            {
                Trace(true, m_pDbg, SAFE_ARRAY_ERROR);
            }
            dwTotal += AddSimpleVariant(&var, ix[0], pValue);
            if(var.vt != VT_EMBEDDED_OBJECT)    // Our dispatch is actual a CMObject *
                VariantClear(&var);
        }

        // Update the size of the property and the row.  Note that having a separate size
        // is for possible future support of multi dimensional arrays.

        dwRowSize = m_OutBuff.GetOffset() - dwStartingRowOffset;
        m_OutBuff.WriteBytes(dwStartingRowOffset, (BYTE *)&dwRowSize, 
                                    sizeof(DWORD));

        dwSize = m_OutBuff.GetOffset() - dwStartingOffset;
        m_OutBuff.WriteBytes(dwStartingOffset, (BYTE *)&dwSize, 
                                    sizeof(DWORD));

        return dwTotal;
 
    }
    else
        return AddSimpleVariant(pvar, -1, pValue);
}

//***************************************************************************
//
//  DWORD CBMOFOut::AddSimpleVariant
//
//  DESCRIPTION:
//
//  Adds a non array variant to the BMOF buffer.
//
//  PARAMETERS:
//
//  pvar                value to add.
//  iIndex              set to -1 if property in scalar, or if array, has
//                      the index of this element.  Note that arrays are
//                      broken up into simple variants.
//  
//
//  RETURN VALUE:
//
//  Bytes written
//***************************************************************************

DWORD CBMOFOut::AddSimpleVariant(VARIANT * pvar, int iIndex, CMoValue * pValue)
{
    DWORD dwSize = iTypeSize(pvar->vt & ~VT_BYREF);
    VARTYPE vtSimple = pvar->vt & ~VT_BYREF;
    if(pValue && pValue->GetNumAliases() && (vtSimple == VT_BSTR))
    {
        WCHAR * wszAlias = NULL;
        int iTry, iAlIndex;
                
        if(iIndex == -1)
            pValue->GetAlias(0, wszAlias, iAlIndex);
        else
        {
            for(iTry = 0; iTry < pValue->GetNumAliases(); iTry++)
            {
                pValue->GetAlias(iTry, wszAlias, iAlIndex);
                if(iIndex == iAlIndex)
                    break;
            }
            if(iTry == pValue->GetNumAliases())
                wszAlias = NULL;
        }
        if(wszAlias && iIndex == -1)
                pvar->bstrVal = SysAllocString(wszAlias);
        
        else if(wszAlias && iIndex != -1)
        {
            WCHAR * pTemp = new WCHAR[wcslen(wszAlias)+2];
            if(pTemp == NULL)
                return 0;
            pTemp[0]= L'$';
            wcscpy(pTemp+1, wszAlias);
            pvar->bstrVal = SysAllocString(pTemp);
            delete pTemp;
        }
        else if(wszAlias == NULL && iIndex != -1)
        {
            WCHAR * pTemp = new WCHAR[wcslen(pvar->bstrVal)+2];
            if(pTemp == NULL)
                return 0;
            pTemp[0]= L' ';
            wcscpy(pTemp+1, pvar->bstrVal);
            pvar->bstrVal = SysAllocString(pTemp);
            delete pTemp;
        }


    }
    if(vtSimple == VT_BSTR)
        return m_OutBuff.WriteBSTR(pvar->bstrVal);
    else if(vtSimple == VT_EMBEDDED_OBJECT)
    {
        CMObject * pObj = (CMObject *)pvar->punkVal;
        return AddClass(pObj, TRUE);
    }
    else
        return m_OutBuff.AppendBytes((BYTE *)&pvar->bstrVal, dwSize);
}

//***************************************************************************
//
//  BOOL CBMOFOut::WriteFile
//
//  DESCRIPTION:
//
//  Writes the buffer out to the file.
//
//***************************************************************************

BOOL CBMOFOut::WriteFile()
{
    BOOL bRet = FALSE;
    if(m_pFile)
    {
        m_BinMof.dwLength = m_OutBuff.GetOffset();
        m_OutBuff.WriteBytes(0, (BYTE *)&m_BinMof, sizeof(WBEM_Binary_MOF));
#ifdef  UNICODE
        char cFile[MAX_PATH];
        wcstombs(cFile, m_pFile, MAX_PATH);
        bRet = m_OutBuff.WriteToFile(cFile);
#else
        bRet = m_OutBuff.WriteToFile(m_pFile);
#endif
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\localloc.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <arena.h>

static class WbemComnInitializer
{
public:

    WbemComnInitializer()
    {
        CWin32DefaultArena::WbemHeapInitialize( GetProcessHeap() );
    }

} g_WbemComnInitializer;

void* __cdecl operator new ( size_t size )
{
    return CWin32DefaultArena::WbemMemAlloc( size );
}
    
void __cdecl operator delete ( void* pv )
{
    CWin32DefaultArena::WbemMemFree( pv );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_tool\mofutils.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MOFUTILSD.CPP

Abstract:

    Support of trace output and internationalized strings.

History:

    a-davj  13-July-97   Created.

--*/

#include "precomp.h"
#include <reg.h>
#include "strings.h"
#include <stdio.h>
#include <stdarg.h>
#include <wbemutil.h>
#include <wbemcli.h>
#include "mofutils.h"

TCHAR JustInCase = 0;
 
//***************************************************************************
//
//  int Trace
//
//  DESCRIPTION:
//
//  Allows for the output function (printf in this case) to be overridden.
//
//  PARAMETERS:
//
//  *fmt                format string.  Ex "%s hello %d"
//  ...                 argument list.  Ex cpTest, 23
//
//  RETURN VALUE:
//
//  size of output in characters.
//***************************************************************************

int Trace(bool bError, DWORD dwID, ...)
{

    IntString is(dwID);
    TCHAR * fmt = is;

    TCHAR *buffer = new TCHAR[2048];
    if(buffer == NULL)
        return 0;
    char *buffer2 = new char[4096];
    if(buffer2 == NULL)
    {
        delete buffer;
        return 0;
    }

    va_list argptr;
    int cnt;
    va_start(argptr, dwID);

#ifdef UNICODE
    cnt = _vsnwprintf(buffer, 2048, fmt, argptr);
#else
    cnt = _vsnprintf(buffer, 2048, fmt, argptr);
#endif
    va_end(argptr);
    CharToOem(buffer, buffer2);

    printf("%s", buffer2);
    if(bError)
        ERRORTRACE((LOG_MOFCOMP,"%s", buffer2));
    else
        DEBUGTRACE((LOG_MOFCOMP,"%s", buffer2));

    delete buffer;
    delete buffer2;
    return cnt;
}

void PrintUsage()
{
    Trace(false, USAGE1);
    Trace(false, USAGE1A);
    Trace(false, USAGE1B);
    Trace(false, USAGE1C);
    Trace(false, USAGE1D);
    Trace(false, USAGE1E);
    Trace(false, USAGE1F);
    Trace(false, USAGE2);
    Trace(false, USAGE3);
    Trace(false, USAGE4);
    Trace(false, USAGE4a);
    Trace(false, USAGE4b);
    Trace(false, USAGE5);
    Trace(false, USAGE6);
    Trace(false, USAGE7);
    Trace(false, USAGE8);
    Trace(false, USAGE9);
    Trace(false, USAGE10);
    Trace(false, USAGE11);
    Trace(false, USAGE12);
    Trace(false, USAGE12A);
    Trace(false, USAGE12B);
    Trace(false, USAGE12C);
    Trace(false, USAGE12D);
    Trace(false, USAGE12E);
    Trace(false, USAGE13);
    Trace(false, USAGE14);
}
//******************************************************************************
//
//  See GETVER.H for documentation
//
//******************************************************************************
BOOL GetVerInfo(TCHAR * pResStringName, 
                        TCHAR * pRes, DWORD dwResSize)
{
    // Extract Version informatio

    DWORD dwTemp, dwSize = MAX_PATH;
    TCHAR cName[MAX_PATH];
    BOOL bRet = FALSE;
    HINSTANCE hInst = GetModuleHandle(NULL);
    long lSize = GetModuleFileName(hInst, cName, MAX_PATH); 
    if(lSize == 0)
        return FALSE;
    lSize = GetFileVersionInfoSize(cName, &dwTemp);
    if(lSize < 1)
        return FALSE;
    
    TCHAR * pBlock = new TCHAR[lSize];
    if(pBlock != NULL)
    {
        bRet = GetFileVersionInfo(cName, NULL, lSize, pBlock);

        if(bRet)
        {
            TCHAR lpSubBlock[MAX_PATH];
            TCHAR * lpBuffer = NULL;
            UINT wBuffSize = MAX_PATH;

            short * piStuff; 
            bRet = VerQueryValue(pBlock, TEXT("\\VarFileInfo\\Translation") , (void**)&piStuff, &wBuffSize);
            if(bRet)
            {
                wsprintf(lpSubBlock,TEXT("\\StringFileInfo\\%04x%04x\\%s"),piStuff[0], piStuff[1],"ProductVersion");
                bRet = VerQueryValue(pBlock, lpSubBlock, (void**)&lpBuffer, &wBuffSize);
            }
            if(bRet == FALSE)
            {
                // Try again in english
                wsprintf(lpSubBlock,TEXT("\\StringFileInfo\\040904E4\\%s"),pResStringName);                        
                bRet = VerQueryValue(pBlock, lpSubBlock,(void**)&lpBuffer, &wBuffSize);
            }
            if(bRet)
                lstrcpyn(pRes, lpBuffer, dwResSize);
        }

        delete pBlock;
    }
    return bRet;
}


IntString::IntString(DWORD dwID)
{
    DWORD dwSize, dwRet;

    for(dwSize = 128; dwSize < 4096; dwSize *= 2)
    {
        m_pString = new TCHAR[dwSize];
        if(m_pString == NULL)
        {
            m_pString = &JustInCase;     // should never happen!
            return; 
        }
        dwRet = LoadString( GetModuleHandle(NULL), dwID, m_pString, dwSize);

        // Check for failure to load

        if(dwRet == 0)
        {
            m_pString = &JustInCase;     // should never happen!
            return; 
        }
        // Check for the case where the buffer was too small

        if((dwRet + 1) >= dwSize)
            delete m_pString;
        else
            return;             // all is well!
    }
}

IntString::~IntString()
{
    if(m_pString != &JustInCase)
        delete(m_pString);
}
 
//***************************************************************************
//
//  BOOL bGetString
//
//  DESCRIPTION:
//
//  Converts a command line argument into a WCHAR string.  Note that the arugment is 
//  of the form /X:stuff.  This is passed a pointer to the colon.
//
//  PARAMETERS:
//
//  pArg                Input, pointer to the colon
//  pOut                Points the the output buffer where the data is to be copied.
//                      IT IS ASSUMED THAT pOut points to a buffer of MAX_PATH length
//
//
//  RETURN VALUE:
//
//  TRUE if OK
//
//***************************************************************************

BOOL bGetString(char * pIn, WCHAR * pOut)
{
    if(pIn == NULL)
        return FALSE;
    if(*pIn != ':')
    {
        PrintUsage();
        return FALSE;
    }
    pIn++;          // skip passed the colon
    int iLen = mbstowcs(NULL, pIn, strlen(pIn)+1);
    if(iLen > MAX_PATH-1)
    {
        PrintUsage();
        return FALSE;
    }
    
    int iRet = mbstowcs(pOut, pIn, MAX_PATH-1);
    if(iRet < 1)
    {
        PrintUsage();
        return FALSE;
    }
    return TRUE;
}
//***************************************************************************
//
//  ValidFlags.
//
//***************************************************************************

bool ValidFlags(bool bClass, long lFlags)
{
    if(bClass)
        return  ((lFlags == WBEM_FLAG_CREATE_OR_UPDATE) ||
             (lFlags == WBEM_FLAG_UPDATE_ONLY) ||
             (lFlags == WBEM_FLAG_CREATE_ONLY) ||
             (lFlags == WBEM_FLAG_UPDATE_SAFE_MODE) ||
             (lFlags == WBEM_FLAG_UPDATE_FORCE_MODE) ||
             (lFlags == (WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_UPDATE_SAFE_MODE)) ||
             (lFlags == (WBEM_FLAG_UPDATE_ONLY | WBEM_FLAG_UPDATE_FORCE_MODE)));
    else
        return 
        ((lFlags == WBEM_FLAG_CREATE_OR_UPDATE) ||
             (lFlags == WBEM_FLAG_UPDATE_ONLY) ||
             (lFlags == WBEM_FLAG_CREATE_ONLY));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\msgmain.cpp ===
*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <commain.h>
#include <clsfac.h>
#include "msgsvc.h"
#include "multsend.h"
#include "smrtmrsh.h"
#include "rpcsend.h"
#include "rpcrecv.h"
#include "msmqsend.h"
#include "msmqrecv.h"
#include "msmqqmgr.h"
#include "msmqq.h"
#include "objacces.h"
#include <tchar.h>

class CMsgServer : public CComServer
{
    HRESULT Initialize()
    {
        ENTER_API_CALL

        BOOL bRes;
        HRESULT hr;
        CWbemPtr<CUnkInternal> pFactory;

        pFactory = new CSingletonClassFactory<CMsgServiceNT>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_WmiMessageService, 
                           pFactory,
                           _T("Message Service"), 
                           TRUE );

        if ( FAILED(hr) )
        {
            return hr;
        }
        
        pFactory = new CSimpleClassFactory<CMsgRpcSender>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_WmiMessageRpcSender, 
                           pFactory,
                           _T("Rpc Message Sender"), 
                           TRUE );

        if ( FAILED(hr) )
        {
            return hr;
        }

        pFactory = new CSimpleClassFactory<CMsgRpcReceiver>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_WmiMessageRpcReceiver, 
                           pFactory,
                           _T("Rpc Message Receiver"), 
                           TRUE );
        
        if ( FAILED(hr) )
        {
            return hr;
        }

        pFactory = new CSimpleClassFactory<CMsgMultiSendReceive>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_WmiMessageMultiSendReceive, 
                           pFactory,
                           _T("Message Multi SendReceive"), 
                           TRUE );
        
        if ( FAILED(hr) )
        {
            return hr;
        }

        pFactory= new CSimpleClassFactory<CSmartObjectMarshaler>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_WmiSmartObjectMarshal,
                           pFactory,
                           _T("Smart Object Marshaler"), 
                           TRUE );

        if ( FAILED(hr) )
        {
            return hr;
        }

        pFactory= new CSimpleClassFactory<CSmartObjectUnmarshaler>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_WmiSmartObjectUnmarshal,
                           pFactory,
                           _T("Smart Object Marshaler"), 
                           TRUE );

        if ( FAILED(hr) )
        {
            return hr;
        }

        pFactory=new CSimpleClassFactory<CObjectAccessFactory>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_WmiSmartObjectAccessFactory,
                           pFactory,
                           _T("Smart Object Access Factory"), 
                           TRUE );

        if ( FAILED(hr) )
        {
            return hr;
        }

#ifdef __WHISTLER_UNCUT

        pFactory = new CSimpleClassFactory<CMsgMsmqSender>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_WmiMessageMsmqSender, 
                           pFactory,
                           _T("MSMQ Message Sender"), 
                           TRUE );

        if ( FAILED(hr) )
        {
            return hr;
        }

        pFactory = new CSimpleClassFactory<CMsgMsmqReceiver>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_WmiMessageMsmqReceiver, 
                           pFactory,
                           _T("MSMQ Message Receiver"), 
                           TRUE );

        if ( FAILED(hr) )
        {
            return hr;
        }

        pFactory = new CClassFactory<CMsgMsmqQueue>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_WmiMessageQueue, 
                           pFactory,
                           _T("MSMQ Message Queue"), 
                           TRUE );

        if ( FAILED(hr) )
        {
            return hr;
        }

        pFactory = new CSimpleClassFactory<CMsgMsmqQueueMgr>(GetLifeControl());

        if ( pFactory == NULL )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        hr = AddClassInfo( CLSID_WmiMessageQueueManager, 
                           pFactory,
                           _T("MSMQ Message Queue Mager"), 
                           TRUE );

#endif
        return hr;

        EXIT_API_CALL
    }

    void UnInitialize()
    {
    }

    void Register( )
    {
    }

    void Unregister( )
    {
    }

} g_Server;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_tool\mofutils.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MOFUTILS.H

Abstract:

	Declares the MOFUTILS functions.

History:

	a-davj  13-July-97   Created.

--*/

#ifndef __MOFUTILS__H_
#define __MOFUTILS__H_


int Trace(bool bError, DWORD dwID, ...);
void PrintUsage();
BOOL GetVerInfo(TCHAR * pResStringName, TCHAR * pRes, DWORD dwResSize);
BOOL bGetString(char * pIn, WCHAR * pOut);
bool ValidFlags(bool bClass, long lFlags);

class IntString
{
    TCHAR *m_pString;
public:
	 IntString(DWORD dwID);
	~IntString();
    operator TCHAR *() { return m_pString; } 
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\mqmgmt.h ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    mqmgmt.h

Abstract:


--*/

#ifndef __MQMGMT_H__
#define __MQMGMT_H__

#ifdef __cplusplus
extern "C"
{
#endif

//********************************************************************
//  LOCAL MSMQ MACHINE PROPERTIES
//********************************************************************
enum MQMGMT_MACHINE_PROPERTIES
{
    PROPID_MGMT_MSMQ_BASE = 0,    
    PROPID_MGMT_MSMQ_OPENQUEUES,    /* VT_LPWSTR | VT_VECTOR  */
    PROPID_MGMT_MSMQ_PRIVATEQ,      /* VT_LPWSTR | VT_VECTOR  */
    PROPID_MGMT_MSMQ_DSSERVER,      /* VT_LPWSTR        */
    PROPID_MGMT_MSMQ_CONNECTED,     /* VT_LPWSTR        */
    PROPID_MGMT_MSMQ_TYPE,          /* VT_LPWSTR        */
};


//********************************************************************
//  LOCAL MSMQ QUEUE PROPERTIES
//********************************************************************
enum MQMGMT_QUEUE_PROPERTIES
{
    PROPID_MGMT_QUEUE_BASE = 0,
    PROPID_MGMT_QUEUE_PATHNAME,             /* VT_LPWSTR            */
    PROPID_MGMT_QUEUE_FORMATNAME,           /* VT_LPWSTR            */
    PROPID_MGMT_QUEUE_TYPE,                 /* VT_LPWSTR            */
    PROPID_MGMT_QUEUE_LOCATION,             /* VT_LPWSTR            */
    PROPID_MGMT_QUEUE_XACT,                 /* VT_LPWSTR            */
    PROPID_MGMT_QUEUE_FOREIGN,              /* VT_LPWSTR            */
    PROPID_MGMT_QUEUE_MESSAGE_COUNT,        /* VT_UI4               */
    PROPID_MGMT_QUEUE_USED_QUOTA,           /* VT_UI4               */
    PROPID_MGMT_QUEUE_JOURNAL_MESSAGE_COUNT,/* VT_UI4               */
    PROPID_MGMT_QUEUE_JOURNAL_USED_QUOTA,   /* VT_UI4               */
    PROPID_MGMT_QUEUE_STATE,                /* VT_LPWSTR            */
    PROPID_MGMT_QUEUE_NEXTHOPS,             /* VT_LPWSTR | VT_VECTOR*/
    PROPID_MGMT_QUEUE_EOD_LAST_ACK,         /* VT_BLOB              */
    PROPID_MGMT_QUEUE_EOD_LAST_ACK_TIME,    /* VT_I4                */
    PROPID_MGMT_QUEUE_EDO_LAST_ACK_COUNT,   /* VT_UI4               */
    PROPID_MGMT_QUEUE_EOD_FIRST_NON_ACK,    /* VT_BLOB              */
    PROPID_MGMT_QUEUE_EOD_LAST_NON_ACK,     /* VT_BLOB              */
    PROPID_MGMT_QUEUE_EOD_NEXT_SEQ,         /* VT_BLOB              */
    PROPID_MGMT_QUEUE_EOD_NO_READ_COUNT,    /* VT_UI4               */
    PROPID_MGMT_QUEUE_EOD_NO_ACK_COUNT,     /* VT_UI4               */
    PROPID_MGMT_QUEUE_EOD_RESEND_TIME,      /* VT_I4                */
    PROPID_MGMT_QUEUE_EOD_RESEND_INTERVAL,  /* VT_UI4               */
    PROPID_MGMT_QUEUE_EDO_RESEND_COUNT,     /* VT_UI4               */
    PROPID_MGMT_QUEUE_EOD_SOURCE_INFO,      /* VT_VARIANT | VT_VECTOR */
};


//
// Returned Value for PROPID_MGMT_MSMQ_CONNECTED property
//
#define MSMQ_CONNECTED      L"CONNECTED"
#define MSMQ_DISCONNECTED   L"DISCONNECTED"

//
// Returned value for PROPID_MGMT_QUEUE_TYPE
//
#define MGMT_QUEUE_TYPE_PUBLIC      L"PUBLIC"
#define MGMT_QUEUE_TYPE_PRIVATE     L"PRIVATE"
#define MGMT_QUEUE_TYPE_MACHINE     L"MACHINE"
#define MGMT_QUEUE_TYPE_CONNECTOR   L"CONNECTOR"

//
// Returned value for PROPID_MGMT_QUEUE_STATE
//
#define MGMT_QUEUE_STATE_LOCAL          L"LOCAL CONNECTION"
#define MGMT_QUEUE_STATE_NONACTIVE      L"INACTIVE"
#define MGMT_QUEUE_STATE_WAITING        L"WAITING"
#define MGMT_QUEUE_STATE_NEED_VALIDATE  L"NEED VALIDATION"
#define MGMT_QUEUE_STATE_ONHOLD         L"ONHOLD"
#define MGMT_QUEUE_STATE_CONNECTED      L"CONNECTED"
#define MGMT_QUEUE_STATE_DISCONNECTING  L"DISCONNECTING"
#define MGMT_QUEUE_STATE_DISCONNECTED   L"DISCONNECTED"

//
// Returned value for PROPID_MGMT_QUEUE_LOCATION
//
#define MGMT_QUEUE_LOCAL_LOCATION   L"LOCAL"
#define MGMT_QUEUE_REMOTE_LOCATION  L"REMOTE"

//
//Returned Value for PROPID_MGMT_QUEUE_XACT and PROPID_MGMT_QUEUE_FOREIGN
//
#define MGMT_QUEUE_UNKNOWN_TYPE     L"UNKNOWN"
#define MGMT_QUEUE_CORRECT_TYPE     L"YES"
#define MGMT_QUEUE_INCORRECT_TYPE   L"NO"


#define MO_MACHINE_TOKEN    L"MACHINE"
#define MO_QUEUE_TOKEN      L"QUEUE"

#define MACHINE_ACTION_CONNECT      L"CONNECT"
#define MACHINE_ACTION_DISCONNECT   L"DISCONNECT"
#define MACHINE_ACTION_TIDY         L"TIDY"

#define QUEUE_ACTION_PAUSE      L"PAUSE"
#define QUEUE_ACTION_RESUME     L"RESUME"
#define QUEUE_ACTION_EOD_RESEND L"EOD_RESEND"


typedef PROPID MGMTPROPID;
typedef struct tagMQMGMTPROPS
{
    DWORD cProp;
    MGMTPROPID* aPropID;
    MQPROPVARIANT* aPropVar;
    HRESULT* aStatus;
} MQMGMTPROPS;

    
struct SEQUENCE_INFO
{
    LONGLONG SeqID;
    ULONG SeqNo; 
    ULONG PrevNo;
};


    
HRESULT
APIENTRY
MQMgmtGetInfo(
    IN LPCWSTR pMachineName,
    IN LPCWSTR pObjectName,
    IN OUT MQMGMTPROPS* pMgmtProps
    );

HRESULT
APIENTRY
MQMgmtAction(
    IN LPCWSTR pMachineName,
    IN LPCWSTR pObjectName,
    IN LPCWSTR pAction
    );

#ifdef __cplusplus
}
#endif

#endif // __MQMGMT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\mofcomp_tool\mofcomp.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

    MOFCOMP.CPP

Abstract:

    Entry points for the WBEM MOF compiler.

History:

    a-davj  12-April-97   Added WMI support.

--*/

#include "precomp.h"
#include <stdio.h>
#include <locale.h>
#include <initguid.h>
#include <wbemidl.h>
#include <winver.h>
#include <cominit.h>
#include <wbemutil.h>
#include <wbemcli.h>
#include <mofcomp.h>
#include <cominit.h>
#include <objidl.h>
#include <dllcalls.h>
#include "mofutils.h"
#include "strings.h"
char cFileName[MAX_PATH];
WCHAR wFileName[MAX_PATH];
WCHAR wBMOFFileName[MAX_PATH];

int __cdecl main(int argc, char** argv)
{ 
    cFileName[0] = 0;
    wFileName[0] = 0;
    wBMOFFileName[0]= 0;
    bool bBmofSet = false;

    // Set locale so that strings are correctly processed.
    // ===================================================
    setlocale(LC_ALL, "");    

    HRESULT hres;
    SCODE sc;

    // Parse command line arguments
    // ============================
    WCHAR UserName[MAX_PATH];
    WCHAR Password[MAX_PATH];
    WCHAR * pPassword = NULL;
    WCHAR Authority[MAX_PATH];
    WCHAR wszDefault[MAX_PATH];

    TCHAR pVersion[100];
    BOOL bRet = GetVerInfo(TEXT("ProductVersion"), pVersion, 100); 
    if(bRet)
    Trace(false, LONGVERSION, pVersion);
    else
    Trace(false, SHORTVERSION);
    Trace(false, COPYRIGHT);
    if(argc < 2)
    {
        PrintUsage();
        return 1;
    }

    // Set locale so that strings are correctly processed.
    // ===================================================
    setlocale(LC_ALL, "");    

    // Init buffers for command line args.
    // ===================================
    UserName[0] = 0;
    Password[0] = 0;
    Authority[0] = 0;
    wszDefault[0] = 0;
    long lLoginFlags = 0;

    // This scope is defined so that the local variables, such as the PARSE 
    // object are destroyed before CoUninitialize is called.

    char cBMOFOutputName[MAX_PATH] = "";

    // Parse command line arguments
    // ============================

    bool bClassFlagsHardcoded = false;
    bool bInstanceFlagsHardcoded = false;
    long lClassFlags = 0;
    long lInstanceFlags = 0;
    long lOptionFlags = WBEM_FLAG_CONSOLE_PRINT;

    for(int i = 1; i < argc-1; i++)
    {
        char *pcCurrArg = argv[i] + 1; 
        if(argv[i][0] != '-' && argv[i][0] != '/')
        {
            PrintUsage();
            return 1;
        }
        if(!_stricmp(pcCurrArg, "check"))
        {
            lOptionFlags |= WBEM_FLAG_CHECK_ONLY;
        }
        else if(!_stricmp(pcCurrArg, "AUTORECOVER"))
        {
            lOptionFlags |= WBEM_FLAG_AUTORECOVER;
        }
        else if(!_stricmp(pcCurrArg, "WMI"))
        {
            HINSTANCE hLib  = LoadLibraryEx(TEXT("wmimofck.exe"), NULL, LOAD_LIBRARY_AS_DATAFILE);
            if(hLib == NULL)
            {
                Trace(true, WMI_NOT_SETUP);
                return 1;
            }
            else FreeLibrary(hLib);
            lOptionFlags |= WBEM_FLAG_WMI_CHECK;
        }
        else if(!_stricmp(pcCurrArg, "class:updateonly"))
        {
            lClassFlags |= WBEM_FLAG_UPDATE_ONLY;
        }
        else if(!_stricmp(pcCurrArg, "class:createonly"))
        {
            lClassFlags |= WBEM_FLAG_CREATE_ONLY;
        }
        else if(!_stricmp(pcCurrArg, "class:safeupdate"))
        {
            lClassFlags |= WBEM_FLAG_UPDATE_SAFE_MODE;
        }
        else if(!_stricmp(pcCurrArg, "class:forceupdate"))
        {
            lClassFlags |= WBEM_FLAG_UPDATE_FORCE_MODE;
        }
        else if(!_stricmp(pcCurrArg, "instance:updateonly"))
        {
            if(lInstanceFlags != 0)
            {
            PrintUsage();
            return 1;
            }
            lInstanceFlags = WBEM_FLAG_UPDATE_ONLY;
        }
        else if(!_stricmp(pcCurrArg, "instance:createonly"))
        {
            if(lInstanceFlags != 0)
            {
            PrintUsage();
            return 1;
            }
            lInstanceFlags = WBEM_FLAG_CREATE_ONLY;
        }
        else if(!_strnicmp(pcCurrArg, "Amendment:", 10))
        {
            if(strlen(pcCurrArg) <=10)
            {
                PrintUsage();
                return 1;
            }
            strcat(cBMOFOutputName, ",a");
            strcat(cBMOFOutputName, pcCurrArg+10);
            mbstowcs(wBMOFFileName, cBMOFOutputName, MAX_PATH);
            lOptionFlags |= WBEM_FLAG_SPLIT_FILES;
        }
        else if(!_strnicmp(pcCurrArg, "mof:", 4))
        {
            if(strlen(pcCurrArg) <=4)
            {
                PrintUsage();
                return 1;
            }
            strcat(cBMOFOutputName, ",n");
            strcat(cBMOFOutputName, pcCurrArg+4);
            mbstowcs(wBMOFFileName, cBMOFOutputName, MAX_PATH);
            lOptionFlags |= WBEM_FLAG_SPLIT_FILES;
        }
        else if(!_strnicmp(pcCurrArg, "mfl:", 4))
        {
            if(strlen(pcCurrArg) <=4)
            {
                PrintUsage();
                return 1;
            }
            strcat(cBMOFOutputName, ",l");
            strcat(cBMOFOutputName, pcCurrArg+4);
            mbstowcs(wBMOFFileName, cBMOFOutputName, MAX_PATH);
            lOptionFlags |= WBEM_FLAG_SPLIT_FILES;
        }
        else if(toupper(pcCurrArg[0]) == 'C' && pcCurrArg[1] == ':')
        {
            if(lClassFlags != 0)
            {
            PrintUsage();
            return 1;
            }
                bClassFlagsHardcoded = true;
            lClassFlags = atol(&pcCurrArg[2]);
        }
        else if(toupper(pcCurrArg[0]) == 'I' && pcCurrArg[1] == ':')
        {
            if(lInstanceFlags != 0)
            {
            PrintUsage();
            return 1;
            }
                bInstanceFlagsHardcoded = true;
            lInstanceFlags = atol(&pcCurrArg[2]);
        }
        else if(toupper(*pcCurrArg) == 'N')
        {
            if(!bGetString(argv[i]+2, wszDefault))
            return 1;
        }
        else if(toupper(*pcCurrArg) == 'B')
        {
            if(strlen(argv[i]) <=3 || argv[i][2] != ':' || wcslen(wBMOFFileName))
            {
                PrintUsage();
                return 1;
            }
            strcpy(cBMOFOutputName, argv[i]+3);
            mbstowcs(wBMOFFileName, cBMOFOutputName, MAX_PATH);
            bBmofSet = true;
        }
        else if(toupper(*pcCurrArg) == 'U')
        {
            if(!bGetString(argv[i]+2, UserName))
            return 1;
        }
        else if(toupper(*pcCurrArg) == 'P')
        {
            // Allow for blank password
    
            char * pArg = argv[i];
            if(pArg[2] != ':' || pArg[3] != 0)         // Dont use bGetString for empty password case
            if(!bGetString(argv[i]+2, Password))
                return 1;
            pPassword = Password;
        }
        else if(toupper(*pcCurrArg) == 'A')
        {
            if(!bGetString(argv[i]+2, Authority))
            return 1;
        }

        else
        {
            PrintUsage();
            return 1;
        }
    }


    // Do a sanity check of the flags chosen

    if((bClassFlagsHardcoded == false && !ValidFlags(true, lClassFlags)) || 
       (bInstanceFlagsHardcoded == false && !ValidFlags(false, lInstanceFlags)))
    {
        PrintUsage();
        return 1;
    }

    if((lOptionFlags & WBEM_FLAG_WMI_CHECK) && strlen(cBMOFOutputName) < 1)
    {
        Trace(true, WMI_ARG_ERROR);
        return 1;
    }

    if(strcmp(argv[argc-1], "-?") == 0 || strcmp(argv[argc-1], "/?") == 0)
    {
        PrintUsage();
        return 1;
    }
    if((lOptionFlags & WBEM_FLAG_SPLIT_FILES) && bBmofSet)
    {
        PrintUsage();
        return 1;
    }
    

    // display the file name and make sure it is a valid file

    strcpy(cFileName, argv[argc-1]);
    mbstowcs(wFileName, argv[argc-1], MAX_PATH);
#ifdef UNICODE
    if(GetFileAttributes(wFileName) == 0xFFFFFFFF)
#else
    if(GetFileAttributes(cFileName) == 0xFFFFFFFF)
#endif
    {
        Trace(true, FILE_NOT_FOUND, cFileName);
        return 1;
    }


    hres = InitializeCom();
    if(hres)
    {
        Trace(true, COMINIT_ERROR, hres);
        return 3;
    }

    WBEM_COMPILE_STATUS_INFO info;
    hres = InitializeSecurity(NULL, -1, NULL, NULL, 
                                RPC_C_AUTHN_LEVEL_CONNECT, 
                                RPC_C_IMP_LEVEL_IDENTIFY, 
                                NULL, EOAC_NONE, 0);

    if(strlen(cBMOFOutputName) > 0)
        sc = CreateBMOFViaDLL( wFileName, wBMOFFileName, wszDefault,
                    lOptionFlags, lClassFlags,
                        lInstanceFlags, &info);
    else
        sc = CompileFileViaDLL(wFileName, wszDefault, UserName, 
                        Authority, pPassword, lOptionFlags, lClassFlags,
                        lInstanceFlags, &info);
    if(sc != S_OK)
        Trace(true, COMPILER_ERROR, info.hRes);


    CoUninitialize();

    if(sc == S_OK)
    {
        Trace(true, DONE);
        return 0;
    }
    else
        return info.lPhaseError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\msgsvc.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <assert.h>
#include <comutl.h>
#include <wbemcli.h>
#include "msgsvc.h"

/**************************************************************************
  CMsgServiceRecord - hold sink given to the msg service on Add().
***************************************************************************/

class CMsgServiceRecord : public OVERLAPPED
{
    CCritSec m_cs;
    long m_cRefs;
    CWbemPtr<IWmiMessageReceiverSink> m_pSink;

public:

    CMsgServiceRecord() : m_cRefs(0) { }

    void SetSink( IWmiMessageReceiverSink* pSink )
    {
        CInCritSec ics(&m_cs);
        m_pSink = pSink;
    }

    void AddRef()
    {
        InterlockedIncrement( &m_cRefs );
    }

    void Release()
    {
        if ( InterlockedDecrement( &m_cRefs ) == 0 )
        {
            delete this;
        }
    }
        
    HRESULT Receive()
    {
        CInCritSec ics(&m_cs);
        
        if ( m_pSink == NULL )
        {
            return WBEM_E_SHUTTING_DOWN;
        }

        return m_pSink->Receive( this );
    }

    HRESULT Notify()
    {
        CInCritSec ics(&m_cs);
        
        if ( m_pSink == NULL )
        {
            return WBEM_E_SHUTTING_DOWN;
        }
        
        return m_pSink->Notify( this );
    }
};

/*****************************************************************************
  CMsgService
******************************************************************************/

ULONG CMsgService::SyncServiceFunc( void* pCtx )
{
    HRESULT hr;

    CMsgServiceRecord* pRecord = (CMsgServiceRecord*)pCtx;

    do 
    {
        hr = pRecord->Receive();

    } while( SUCCEEDED(hr) );

    //
    // Since the record will no longer be serviced, give up our ref
    // count on it.
    //
    pRecord->Release();

    return hr;
}

ULONG CMsgService::AsyncServiceFunc( void* pCtx )
{
    HRESULT hr;

    CMsgServiceRecord* pRecord;
    CMsgService* pSvc = (CMsgService*)pCtx;

    do 
    {
        hr = pSvc->AsyncWaitForCompletion( INFINITE, &pRecord );

        if ( FAILED(hr) )
        {
            //
            // exit loop. hr will describe whether it was normal or not. 
            //
            break;
        }

        if ( hr == S_OK ) 
        {
            //
            // hr can be S_FALSE as well.  this occurrs when the 
            // first submit is performed.  In this case, we don't do 
            // the notify.
            //
            hr = pRecord->Notify();
        }

        if ( SUCCEEDED(hr) ) 
        {
            hr = pSvc->AsyncReceive( pRecord );
        }

        if ( FAILED(hr) ) 
        {
            //
            // Since the record will no longer be serviced, give up our ref
            // count on it.
            //
            pRecord->Release();
        }

    } while ( 1 );
        
    return hr;
}

/*********************************************************************
  CMsgService 
**********************************************************************/

CMsgService::CMsgService( CLifeControl* pControl )
 : m_XService( this ), CUnkInternal( pControl ),
   m_hThread( INVALID_HANDLE_VALUE ), m_cSvcRefs( 0 ), m_bAsyncInit( FALSE )
{
    
}

void* CMsgService::GetInterface( REFIID riid )
{
    if ( riid == IID_IWmiMessageService )
    {
        return &m_XService;
    }
    return NULL;
}

CMsgService::~CMsgService()
{
    if ( m_bAsyncInit )
    {
        //
        // wait for async thread to complete. TODO: print error here if 
        // WaitForSingleObject times out.  
        //
        WaitForSingleObject( m_hThread, 5000 );
        CloseHandle( m_hThread );
    }
} 

HRESULT CMsgService::EnsureService( BOOL bAsync )
{
    HRESULT hr;

    if ( !bAsync )
    {
        return S_OK;
    }

    CInCritSec ics( &m_cs );

    if ( m_bAsyncInit )
    {
        return S_OK;
    }

    assert( m_hThread == INVALID_HANDLE_VALUE );

    //
    // must make sure that all async initialization is performed  
    // before starting the async thread(s).
    //

    hr = AsyncInitialize();

    if ( FAILED(hr) )
    {
        return hr;
    }

    m_hThread = CreateThread( NULL, 
                              0, 
                              AsyncServiceFunc, 
                              this,  
                              0, 
                              NULL ); 

    if ( m_hThread == INVALID_HANDLE_VALUE )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    m_bAsyncInit = TRUE;

    return S_OK;
}

HRESULT CMsgService::Remove( void* pHdl )
{
    CMsgServiceRecord* pRecord = (CMsgServiceRecord*)pHdl;
    
    //
    // setting the sink to null will ensure that no callbacks 
    // will occur.
    //    
    pRecord->SetSink( NULL );

    //
    // the client will not be using the record anymore so release its ref.
    //
    pRecord->Release();

    return S_OK;
}

HRESULT CMsgService::Add( CMsgServiceRecord* pRecord,
                          HANDLE hFileOverlapped,
                          DWORD dwFlags )
{
    HRESULT hr;

    hr = EnsureService( TRUE );
        
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = AsyncAddOverlappedFile( hFileOverlapped, pRecord );

    if ( FAILED(hr) )
    {
        return hr;
    }

    return WBEM_S_NO_ERROR;
}

HRESULT CMsgService::Add( CMsgServiceRecord* pRec, DWORD dwFlags )
{
    HRESULT hr;

    hr = EnsureService( FALSE );

    HANDLE hThread = CreateThread( NULL, 0, SyncServiceFunc, pRec, 0, NULL );
 
    if ( hThread == INVALID_HANDLE_VALUE )
    {
         return HRESULT_FROM_WIN32( GetLastError() );
    }

    return WBEM_S_NO_ERROR;
}  

HRESULT CMsgService::XService::Add( IWmiMessageReceiverSink* pSink, 
                                    HANDLE* phFileOverlapped,
                                    DWORD dwFlags,
                                    void** ppHdl )
{
    ENTER_API_CALL
   
    HRESULT hr;

    *ppHdl = NULL;

    //
    // create the msg service record for this sink.
    //

    CWbemPtr<CMsgServiceRecord> pRecord = new CMsgServiceRecord;
    
    if ( pRecord == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pRecord->SetSink( pSink );

    //
    // initialize for async or sync operation
    //

    if ( phFileOverlapped )
    {
        hr = m_pObject->Add( pRecord, *phFileOverlapped, dwFlags );
    }
    else
    {
        hr = m_pObject->Add( pRecord, dwFlags );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // the msg service keeps a ref count now on the record until its sure 
    // that it is no longer being serviced.  
    //
    pRecord->AddRef();

    //
    // caller now owns a ref as well.  This will be released in Remove().
    //
    pRecord->AddRef();
    *ppHdl = pRecord;

    return WBEM_S_NO_ERROR;

    EXIT_API_CALL
}
 
HRESULT CMsgService::XService::Remove( void* pHdl )
{
    ENTER_API_CALL
    return m_pObject->Remove( pHdl );
    EXIT_API_CALL
}

/*************************************************************************
  CMessageServiceNT
**************************************************************************/

#define SHUTDOWN_COMPLETION_KEY 0xfffffffe
#define INITRECV_COMPLETION_KEY 0xfffffffd

CMsgServiceNT::CMsgServiceNT( CLifeControl* pControl ) 
 : CMsgService( pControl ), m_hPort( INVALID_HANDLE_VALUE )
{
    
}

CMsgServiceNT::~CMsgServiceNT()
{
    if ( m_hPort != INVALID_HANDLE_VALUE )
    {
        CloseHandle( m_hPort );
    }
}

HRESULT CMsgServiceNT::AsyncAddOverlappedFile( HANDLE hOverlappedFile,
                                               CMsgServiceRecord* pRec )
{
    //
    // add the file handle that was given to us to the completion port.
    // when the receiver closes this file handle, it will be removed from 
    // the completion port automatically.
    //

    HANDLE hPort = CreateIoCompletionPort( hOverlappedFile, m_hPort, 0, 0 );

    if ( hPort == INVALID_HANDLE_VALUE )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    assert( hPort == m_hPort );

    //
    // now perform the first receive on the record.  We cannot do it on this
    // thread because overlapped i/o cancels requests if the thread that 
    // issued them is brought down before the i/o completes.  To work around 
    // this, we post a request to the completion port and wait for it
    // to be received.
    // 

    if ( !PostQueuedCompletionStatus( m_hPort, 
                                      0, 
                                      INITRECV_COMPLETION_KEY, 
                                      pRec ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return S_OK;
}

//
// assumes already locked.
//

HRESULT CMsgServiceNT::AsyncInitialize()
{
    if ( m_hPort != INVALID_HANDLE_VALUE )
    {
        return S_OK;
    }

    m_hPort = CreateIoCompletionPort( INVALID_HANDLE_VALUE, 
                                      NULL, 
                                      NULL, 
                                      0 );
    
    if ( m_hPort == INVALID_HANDLE_VALUE )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
    
    return S_OK;
}

HRESULT CMsgServiceNT::AsyncShutdown( DWORD cThreads )
{
    //
    // this method has the responsibility breaking the async thread(s) out
    // of their svc loop.
    //

    assert( m_hPort != INVALID_HANDLE_VALUE );

    for( DWORD i=0; i < cThreads; i++ )
    {
        PostQueuedCompletionStatus( m_hPort, 0, SHUTDOWN_COMPLETION_KEY, NULL);
    }

    return S_OK;
}

HRESULT CMsgServiceNT::AsyncReceive( CMsgServiceRecord* pRecord )
{
    ZeroMemory( pRecord, sizeof(OVERLAPPED) );
    return pRecord->Receive();        
}

HRESULT CMsgServiceNT::AsyncWaitForCompletion( DWORD dwTimeout,
                                               CMsgServiceRecord** ppRecord)
{
    BOOL bRes;
    ULONG dwBytesTransferred;
    ULONG_PTR dwCompletionKey;   
    LPOVERLAPPED lpOverlapped;
    *ppRecord = NULL;

    bRes = GetQueuedCompletionStatus( m_hPort,
                                      &dwBytesTransferred,
                                      &dwCompletionKey,
                                      &lpOverlapped,
                                      dwTimeout );

    if ( bRes )
    {
        if ( dwCompletionKey == SHUTDOWN_COMPLETION_KEY )
        {
            return WBEM_E_SHUTTING_DOWN;
        }
    }
    else if ( lpOverlapped == NULL )
    {
        //
        // usually happens when the operation times out. HR will tell caller
        // if this is the case.
        //
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // if we're here, then this means that we've sucessfully dequeued a 
    // completion packet.  However, the i/o operation may have failed 
    // ( bRes is FALSE ).  In this case the overlapped structure will 
    // contain the needed error information.  
    //

    *ppRecord = (CMsgServiceRecord*)lpOverlapped;

    //
    // we must also handle the case where this is an initial receive 
    // completion.  This happens when a receiver is first added.  Since
    // we can't issue a receive on the adding thread, we must do it on our 
    // worker threads.  In this case, we return S_FALSE to signal to the 
    // Async handling routine that there was no prior submit and a notify
    // should NOT be formed.  
    //
    return dwCompletionKey != INITRECV_COMPLETION_KEY ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\msmqcomn.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __MSMQCOMN_H__
#define __MSMQCOMN_H__

/**************************************************************************
  MSMQ Function Typedefs 
***************************************************************************/

typedef HRESULT (APIENTRY *PMQCreateQueue)( PSECURITY_DESCRIPTOR, 
                                            MQQUEUEPROPS*, 
                                            LPWSTR, 
                                            DWORD* );

typedef HRESULT (APIENTRY *PMQOpenQueue)( LPWSTR, 
                                          DWORD, 
                                          DWORD, 
                                          QUEUEHANDLE* );

typedef HRESULT (APIENTRY *PMQDeleteQueue)( LPWSTR );

typedef HRESULT (APIENTRY *PMQFreeMemory)( PVOID );

typedef HRESULT (APIENTRY *PMQSendMessage)( QUEUEHANDLE, 
                                            MQMSGPROPS*, 
                                            ITransaction* );

typedef HRESULT (APIENTRY *PMQReceiveMessage)( QUEUEHANDLE, 
                                               DWORD, 
                                               DWORD, 
                                               MQMSGPROPS*,
                                               LPOVERLAPPED, 
                                               PMQRECEIVECALLBACK, 
                                               HANDLE, 
                                               ITransaction* );

typedef HRESULT (APIENTRY *PMQCloseQueue)( QUEUEHANDLE );

typedef HRESULT (APIENTRY *PMQPathNameToFormatName)( LPCWSTR, LPWSTR, DWORD* );

typedef HRESULT (APIENTRY *PMQCreateCursor)( QUEUEHANDLE hQueue,
                                             PHANDLE phCursor );

typedef HRESULT (APIENTRY *PMQCloseCursor)( HANDLE hCursor );

typedef HRESULT (APIENTRY *PMQGetSecurityContext)( PVOID lpCertBuffer,
                                                   DWORD dwCertBufferLength,
                                                   HANDLE* hSecurityContext );

typedef void (APIENTRY *PMQFreeSecurityContext)( HANDLE hSecurityContext );

typedef HRESULT (APIENTRY *PMQRegisterCertificate)( DWORD dwFlags,  
                                                    PVOID lpCertBuffer,  
                                                    DWORD dwCertBufferLen );

typedef HRESULT (APIENTRY *PMQMgmtGetInfo)( LPCWSTR pMachineName,
                                            LPCWSTR pObjectName,
                                            MQMGMTPROPS* pMgmtProps );

typedef HRESULT (APIENTRY *PMQGetQueueProperties)( LPCWSTR lpwcsFormatName,
                                                   MQQUEUEPROPS* pQueueProps );

typedef HRESULT (APIENTRY *PMQGetPrivateComputerInformation)( LPCWSTR,
                                                              MQPRIVATEPROPS*);

/************************************************************************
  CMsmqApi
*************************************************************************/

#define FUNCPTR(FUNC) P ## FUNC m_fp ## FUNC;

class CMsmqApi
{
    HMODULE m_hModule;
    
public:

    CMsmqApi() { ZeroMemory( this, sizeof(CMsmqApi) ); }
    ~CMsmqApi();

    HRESULT Initialize();

    FUNCPTR(MQGetQueueProperties)
    FUNCPTR(MQCreateQueue)
    FUNCPTR(MQOpenQueue)
    FUNCPTR(MQDeleteQueue)
    FUNCPTR(MQFreeMemory)
    FUNCPTR(MQSendMessage)
    FUNCPTR(MQReceiveMessage)
    FUNCPTR(MQCloseQueue)
    FUNCPTR(MQPathNameToFormatName)
    FUNCPTR(MQCreateCursor)
    FUNCPTR(MQCloseCursor)
    FUNCPTR(MQGetSecurityContext)
    FUNCPTR(MQFreeSecurityContext)
    FUNCPTR(MQRegisterCertificate)
    FUNCPTR(MQGetPrivateComputerInformation)
    FUNCPTR(MQMgmtGetInfo)
};


/**************************************************************************
  Common MSMQ Util Functions
***************************************************************************/

#include <wstring.h>

HRESULT MqClassToWmiRes( DWORD dwClass );
HRESULT MqResToWmiRes( HRESULT hr, HRESULT hrDefault = S_OK );
HRESULT IsMsmqOnline( CMsmqApi& rApi );
HRESULT IsMsmqWorkgroup( CMsmqApi& rApi );
HRESULT EnsureMsmqService( CMsmqApi& rApi );
HRESULT NormalizeQueueName( CMsmqApi&,LPCWSTR wszEndpoint,WString& rwsFormat);


#endif // __MSMQQCOMN_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\msmqhdlr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <wbemcli.h>
#include <assert.h>
#include "msmqcomn.h"
#include "msmqhdlr.h"
#include "msmqctx.h"
#include "msmqhdr.h"

#define CALLFUNC(FUNC) m_rApi.m_fp ## FUNC 

static MSGPROPID g_aPropID[] = { 
    PROPID_M_EXTENSION,      // header info - our hdr followed by user's hdr
    PROPID_M_EXTENSION_LEN,  // len of entire hdr
    PROPID_M_CLASS,          // contains msmq msg type - normal or nack
    PROPID_M_APPSPECIFIC,    // contains ack status code
    PROPID_M_ADMIN_QUEUE,    // contains format name to use for sending acks
    PROPID_M_ADMIN_QUEUE_LEN,// len of format name, if 0 then no sending acks
    PROPID_M_SENDERID,       // SID of sender, only trustworthy if auth
    PROPID_M_SENDERID_LEN,   // length of SID, may be zero
    PROPID_M_AUTHENTICATED,  // tells us if message was authenticated.
    PROPID_M_PRIV_LEVEL,     // tells us if message was encrypted when sending
    PROPID_M_BODY,           // user's data
    PROPID_M_BODY_SIZE       // user's data len 
};

// eTotalProps must last.
enum { eExt=0, eExtLen, eClass, eAppSpec, eAck, eAckLen, 
       eSid, eSidLen, eAuth, ePriv, eBody, eBodyLen, eTotalProps }; 


/*************************************************************************
  CMsgMsmqHandler
**************************************************************************/

void* CMsgMsmqHandler::GetInterface( REFIID riid )
{
    if ( riid == IID_IWmiMessageQueueReceiver )
    {
        return &m_XQueueReceiver;
    }
    return NULL;
}

HRESULT CMsgMsmqHandler::ReceiveMessage( DWORD dwTimeout,
                                         DWORD dwAction,
                                         PVOID pvCursor,
                                         LPOVERLAPPED pOverlapped,
                                         ITransaction* pTxn )
{
    ENTER_API_CALL

    HRESULT hr;

    MQMSGPROPS* pMsgProps = &m_MsgProps;

    switch( dwAction )
    {

    case WMIMSG_ACTION_QRCV_PEEK_CURRENT:
        dwAction = MQ_ACTION_PEEK_CURRENT;
        break;

    case WMIMSG_ACTION_QRCV_PEEK_NEXT:
        dwAction = MQ_ACTION_PEEK_NEXT;
        break;
        
    case WMIMSG_ACTION_QRCV_RECEIVE:
        dwAction = MQ_ACTION_RECEIVE;
        break;

    case WMIMSG_ACTION_QRCV_REMOVE:
        dwAction = MQ_ACTION_RECEIVE;
        pMsgProps = NULL;
        break;

    default:

        return WBEM_E_INVALID_OPERATION; 
    };

    //
    // if receive fails due to some buffer being too small, then we resize
    // it and try again.  We could only do this two times, however, if for 
    // some reason there are multiple receivers for the same queue, there 
    // could be a case where there are multiple threads trying to receive 
    // the same message.  In this case, we might need to grow more than once
    //
    do
    {
        hr = CALLFUNC(MQReceiveMessage)( m_hQueue,
                                         dwTimeout,
                                         dwAction,
                                         pMsgProps,
                                         pOverlapped,
                                         NULL,
                                         pvCursor,
                                         pTxn );

    } while( FAILED(hr) && (hr = CheckBufferResize(hr)) == S_OK );

    if ( SUCCEEDED(hr) && pMsgProps != NULL && pOverlapped == NULL )
    {
        //
        // handle the message here.
        //

        hr = HandleMessage( pTxn );
    }

    if ( FAILED(hr) )
    {
        return MqResToWmiRes( hr, S_OK );
    }
    
    return hr;

    EXIT_API_CALL
}

HRESULT CMsgMsmqHandler::CreateCursor( PVOID* ppvCursor )
{
    return CALLFUNC(MQCreateCursor)( m_hQueue, ppvCursor );
}
    
HRESULT CMsgMsmqHandler::DestroyCursor( PVOID pvCursor )
{
    return CALLFUNC(MQCloseCursor)( pvCursor );
}


HRESULT CMsgMsmqHandler::Create( CMsmqApi& rApi,
                                 IWmiMessageSendReceive* pRecv,
                                 QUEUEHANDLE hQueue,
                                 DWORD dwFlags,
                                 CMsgMsmqHandler** ppHndlr )
{
    HRESULT hr;

    *ppHndlr = NULL;

    CWbemPtr<CMsgMsmqHandler> pHndlr;

    pHndlr = new CMsgMsmqHandler( rApi, pRecv, hQueue, dwFlags );

    if ( pHndlr == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    MQPROPVARIANT* aPropVar = new MQPROPVARIANT[eTotalProps];

    if ( aPropVar == NULL )
    {
        delete pHndlr;
        return WBEM_E_OUT_OF_MEMORY;
    }

    ZeroMemory( aPropVar, sizeof(MQPROPVARIANT)*eTotalProps );

    //
    // Initialize msg props 
    //

    pHndlr->m_MsgProps.cProp = eTotalProps;
    pHndlr->m_MsgProps.aPropID = g_aPropID;
    pHndlr->m_MsgProps.aPropVar = aPropVar;
    pHndlr->m_MsgProps.aStatus = NULL;

    aPropVar[eExt].vt = VT_VECTOR | VT_UI1;
    aPropVar[eExt].caub.pElems = new BYTE[256];
    aPropVar[eExt].caub.cElems = aPropVar[eExt].caub.pElems != NULL ? 256:0;
    aPropVar[eExtLen].vt = VT_UI4;

    aPropVar[eBody].vt = VT_VECTOR | VT_UI1;
    aPropVar[eBody].caub.pElems = new BYTE[1024];
    aPropVar[eBody].caub.cElems = aPropVar[eBody].caub.pElems!=NULL ? 1024:0;
    aPropVar[eBodyLen].vt = VT_UI4;

    aPropVar[eSid].vt = VT_VECTOR | VT_UI1;
    aPropVar[eSid].caub.pElems = new BYTE[256];
    aPropVar[eSid].caub.cElems = aPropVar[eSid].caub.pElems != NULL ? 256:0;
    aPropVar[eSidLen].vt = VT_UI4;

    aPropVar[eAck].vt = VT_LPWSTR;
    aPropVar[eAck].pwszVal = new WCHAR[256];
    aPropVar[eAckLen].vt = VT_UI4;
    aPropVar[eAckLen].ulVal = aPropVar[eAck].pwszVal != NULL ? 256 : 0;

    aPropVar[eClass].vt = VT_UI2;
    aPropVar[eAuth].vt = VT_UI1;
    aPropVar[eAppSpec].vt = VT_UI4;
    aPropVar[ePriv].vt = VT_UI4;

    //
    // this object is used to verify the private hashes on our header.  Private
    // hashes are used to verify that receiving and sending machines are the
    // same.
    //

    hr = CSignMessage::Create( L"WMIMSG", &pHndlr->m_pSign );

    if ( FAILED(hr) )
    {
        return hr;
    }

    pHndlr->AddRef();
    *ppHndlr = pHndlr;

    return WBEM_S_NO_ERROR;
}

CMsgMsmqHandler::~CMsgMsmqHandler()
{
    MQPROPVARIANT* aPropVar = m_MsgProps.aPropVar;

    //
    // clean up any allocated buffers.
    // delete (and vector delete) is guaranteed to handle NULL.
    //

    delete [] aPropVar[eExt].caub.pElems;
    delete [] aPropVar[eBody].caub.pElems;
    delete [] aPropVar[eSid].caub.pElems;
    delete [] aPropVar[eAck].caub.pElems;
    delete [] aPropVar;
}

//
// returns S_OK if the error code specifies a buffer resize and 
// appropriate buffer was successfully resized.  If hr does not
// specify a buffer resize, then it just returns hr.
// 

HRESULT CMsgMsmqHandler::CheckBufferResize( HRESULT hr )
{
    DWORD dwSize;
    MQPROPVARIANT* aPropVar = m_MsgProps.aPropVar;

    int i = 0;

    if ( hr == MQ_ERROR_BUFFER_OVERFLOW )
    {
        //
        // do we need to resize the body or extension buffer ? 
        //

        if ( aPropVar[eBodyLen].ulVal > aPropVar[eBody].caub.cElems )
        {
            i = eBody;
            dwSize = aPropVar[eBodyLen].ulVal;
        }
        else if ( aPropVar[eExtLen].ulVal > aPropVar[eExt].caub.cElems )
        {
            i = eExt;
            dwSize = aPropVar[eExtLen].ulVal;
        }
        else
        {
            assert(0);
        }
    }
    else if ( hr == MQ_ERROR_SENDERID_BUFFER_TOO_SMALL )
    {
        i = eSid;
        dwSize = aPropVar[eSidLen].ulVal;
        
    }
    else if ( hr == MQ_ERROR_FORMATNAME_BUFFER_TOO_SMALL )
    {
        i = eAck;
        dwSize = aPropVar[eAckLen].ulVal;
    }
    else
    {
        return hr; // not a buffer resize error code
    }
    
    delete [] aPropVar[i].caub.pElems;
    
    aPropVar[i].caub.pElems = new BYTE[dwSize];

    if ( aPropVar[i].caub.pElems != NULL )
    {
        aPropVar[i].caub.cElems = dwSize;
    }
    else
    {
        aPropVar[i].caub.cElems = 0;
        return WBEM_E_OUT_OF_MEMORY;
    }

    return S_OK;
}

HRESULT CMsgMsmqHandler::HandleMessageAck( HRESULT hrStatus )
{
    HRESULT hr;

    MQPROPVARIANT* aPropVar = m_MsgProps.aPropVar;

    if ( aPropVar[eAckLen].ulVal == 0 )
    {
        //
        // no Ack queue specified.
        //
        return WBEM_S_NO_ERROR;
    }

    LPCWSTR wszAck = aPropVar[eAck].pwszVal;

    //
    // open a sender to the Ack queue.  For right now, all nacks
    // use Guaranteed QoS.
    //

    CWbemPtr<IWmiMessageSender> pSender;

    hr = CoCreateInstance( CLSID_WmiMessageMsmqSender,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiMessageSender,
                           (void**)&pSender );
    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemPtr<IWmiMessageSendReceive> pSend;

    hr = pSender->Open( wszAck,
                        WMIMSG_FLAG_QOS_GUARANTEED | WMIMSG_FLAG_SNDR_ACK,
                        NULL,
                        NULL,
                        NULL,
                        &pSend );

    if ( FAILED(hr) )
    {
        //
        // TODO: should notify error here.
        //
        return hr;
    }

    PBYTE pData = aPropVar[eBody].caub.pElems;
    ULONG cData = aPropVar[eBodyLen].ulVal;

    //
    // if encryption was specified to signal the data, then we cannot
    // specify it on the Ack (remains consistent with msmq nacks)
    // 

    if ( aPropVar[ePriv].ulVal != MQMSG_PRIV_LEVEL_NONE )
    {
        pData = NULL;
        cData = 0;
    }

    PBYTE pAuxData = m_MsgProps.aPropVar[eExt].caub.pElems;
    ULONG cAuxData = m_MsgProps.aPropVar[eExtLen].ulVal;
    
    return pSend->SendReceive( pData, 
                               cData, 
                               pAuxData, 
                               cAuxData, 
                               hrStatus,
                               NULL );
}

HRESULT CMsgMsmqHandler::HandleMessage( ITransaction* pTxn )
{
    HRESULT hr;

    hr = HandleMessage2( pTxn );

    if ( FAILED(hr) )
    {
        if ( m_dwFlags & WMIMSG_FLAG_RCVR_ACK )
        {
            //
            // don't send acks, since we ourselves are an ack handler
            //
            
            return WBEM_S_NO_ERROR;
        }

        HandleMessageAck( hr );
        
        return hr;
    }

    //
    // TODO : handle positive ack if flags specify
    //

    return WBEM_S_NO_ERROR;
}

HRESULT CMsgMsmqHandler::HandleMessage2( ITransaction* pTxn )
{
    HRESULT hr;

    if ( m_pRecv == NULL )
    {
        return WBEM_S_NO_ERROR;
    }

    MQPROPVARIANT* aPropVar = m_MsgProps.aPropVar;

    PBYTE pData = aPropVar[eBody].caub.pElems;
    ULONG cData = aPropVar[eBodyLen].ulVal;
    PBYTE pAuxData = aPropVar[eExt].caub.pElems;
    ULONG cAuxData = aPropVar[eExtLen].ulVal;
    
    //
    // handle the msmq hdr attached to the front of the aux data.
    //

    CMsgMsmqHdr MsmqHdr;
 
    CBuffer HdrStrm( pAuxData, cAuxData, FALSE );

    hr = MsmqHdr.Unpersist( HdrStrm );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // get user header information
    //

    PBYTE pUserAuxData = HdrStrm.GetRawData() + HdrStrm.GetIndex();
    ULONG cUserAuxData = MsmqHdr.GetAuxDataLength();
    
    hr = HdrStrm.Advance( cUserAuxData );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // we may need to verify that the msg originated from this machine.
    //

    if ( m_dwFlags & WMIMSG_FLAG_RCVR_PRIV_VERIFY )
    {
        //
        // first check the integrity of the user data
        // 

        hr = m_pSign->Verify( pData, 
                              cData, 
                              MsmqHdr.GetDataHash(), 
                              MsmqHdr.GetDataHashLength() );

        if ( hr != S_OK )
        {
            return WMIMSG_E_INVALIDMESSAGE;
        }
        
        //
        // now check the integrity of the hdr.
        // 

        ULONG cHdr = HdrStrm.GetIndex();

        ULONG cHdrHash;
        BYTE achHdrHash[MAXHASHSIZE];

        hr = HdrStrm.Read( &cHdrHash, sizeof(DWORD), NULL );

        if ( hr != S_OK || cHdrHash > MAXHASHSIZE )
        {
            return WMIMSG_E_INVALIDMESSAGE;
        }

        hr = HdrStrm.Read( achHdrHash, cHdrHash, NULL );

        if ( hr != S_OK )
        {
            return WMIMSG_E_INVALIDMESSAGE;
        }

        hr = m_pSign->Verify( HdrStrm.GetRawData(), 
                              cHdr, 
                              achHdrHash, 
                              cHdrHash );

        if ( hr != S_OK )
        {
            return WMIMSG_E_INVALIDMESSAGE;
        }
    }   

    //
    // check to see if this is an msmq generated nack.  If so, then 
    // need to map nack type to error code. If not, then our status is 
    // specified in the App specific field.
    //

    DWORD dwStatus;

    if ( aPropVar[eClass].uiVal == MQMSG_CLASS_NORMAL )
    {
        dwStatus = aPropVar[eAppSpec].ulVal;
    }
    else
    {
        dwStatus = MqClassToWmiRes( aPropVar[eClass].uiVal );
    }

    //
    // construct the receiver context for this message.
    //

    PSID pSenderSid = aPropVar[eSid].caub.cElems > 0 ?
                      aPropVar[eSid].caub.pElems : NULL;

    BOOL bAuth = aPropVar[eAuth].bVal == MQMSG_AUTHENTICATION_REQUESTED ?
                                              TRUE : FALSE;

    CMsgMsmqRcvrCtx RcvrCtx( &MsmqHdr, pSenderSid, bAuth );

    //
    // hand the message off to the users code.
    //

    hr = m_pRecv->SendReceive( pData, 
                               cData, 
                               pUserAuxData, 
                               cUserAuxData,
                               dwStatus,
                               &RcvrCtx );
    
    if ( FAILED(hr) )
    {
        return hr; 
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\msmqcomn.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <wbemcli.h>
#include <wmimsg.h>
#include <tchar.h>
#include "msmqcomn.h"

#define MAX_FORMAT_NAME 1024
#define CALLFUNC(FUNC) rApi.m_fp ## FUNC 

HRESULT MqClassToWmiRes( DWORD dwClass )
{
    switch( dwClass )
    {
    case MQMSG_CLASS_NACK_ACCESS_DENIED :
        return WBEM_E_ACCESS_DENIED;

    case MQMSG_CLASS_NACK_BAD_DST_Q :
        return WMIMSG_E_INVALIDADDRESS;

    case MQMSG_CLASS_NACK_BAD_ENCRYPTION :
    case MQMSG_CLASS_NACK_COULD_NOT_ENCRYPT :
        return WMIMSG_E_ENCRYPTFAILURE;

    case MQMSG_CLASS_NACK_BAD_SIGNATURE :
    case MQMSG_CLASS_NACK_UNSUPPORTED_CRYPTO_PROVIDER :
        return WMIMSG_E_AUTHFAILURE;

    case MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_Q :
    case MQMSG_CLASS_NACK_NOT_TRANSACTIONAL_MSG :
        return WMIMSG_E_XACTFAILURE;

    case MQMSG_CLASS_NACK_PURGED : 
    case MQMSG_CLASS_NACK_Q_DELETED :
    case MQMSG_CLASS_NACK_Q_PURGED :
        return WMIMSG_E_QUEUEPURGED;

    case MQMSG_CLASS_NACK_RECEIVE_TIMEOUT :
    case MQMSG_CLASS_NACK_RECEIVE_TIMEOUT_AT_SENDER :
        return WMIMSG_E_TIMEDOUT;
    };

    return dwClass;
}

HRESULT MqResToWmiRes( HRESULT hr, HRESULT hrDefault )
{
    switch( hr )
    {
    case MQ_ERROR_SHARING_VIOLATION :
    case MQ_ERROR_ACCESS_DENIED :

        return WBEM_E_ACCESS_DENIED;

    case MQ_ERROR_ILLEGAL_SECURITY_DESCRIPTOR :
      
        return WBEM_E_INVALID_PROPERTY;
 
    case MQ_ERROR_SERVICE_NOT_AVAILABLE :
    case MQ_ERROR_NO_DS :
    case MQ_ERROR_DTC_CONNECT :

        return WMIMSG_E_REQSVCNOTAVAIL;

    case MQ_ERROR_QUEUE_NOT_FOUND :
        
        return WMIMSG_E_TARGETNOTFOUND;
   
    case MQ_ERROR_ILLEGAL_FORMATNAME :
    case MQ_ERROR_ILLEGAL_QUEUE_PATHNAME :
    case MQ_ERROR_UNSUPPORTED_FORMATNAME_OPERATION :
                 
        return WMIMSG_E_INVALIDADDRESS;

    case MQ_ERROR_NO_INTERNAL_USER_CERT :

        return WMIMSG_E_AUTHFAILURE;

    case MQ_ERROR_TRANSACTION_USAGE :
 
        return WMIMSG_E_XACTFAILURE;

    case MQ_ERROR_INSUFFICIENT_RESOURCES :
  
        return WMIMSG_E_MSGTOOLARGE; 

    case MQ_ERROR_QUEUE_EXISTS :
 
        return WBEM_E_ALREADY_EXISTS;    

    case MQ_ERROR_IO_TIMEOUT :
 
        return WMIMSG_E_TIMEDOUT;    
    };

    return hrDefault == S_OK ? hr : hrDefault;
}

HRESULT StartMsmqServiceNT()
{
    SC_HANDLE hSvcMgr;

    hSvcMgr = OpenSCManagerW( NULL, NULL, SC_MANAGER_CONNECT );

    if ( hSvcMgr == NULL )
    {
        return WBEM_E_ACCESS_DENIED;
    }

    SC_HANDLE hSvc;

    hSvc = OpenServiceW( hSvcMgr, L"msmq", SERVICE_START );

    if ( hSvc == NULL )
    {
        CloseServiceHandle( hSvcMgr );
        return WBEM_E_ACCESS_DENIED;
    }

    BOOL bRes = StartService( hSvc, 0, NULL );

    CloseServiceHandle( hSvc );
    CloseServiceHandle( hSvcMgr );

    return bRes ? S_OK : HRESULT_FROM_WIN32( GetLastError() );
}

HRESULT StartMsmqService9x()
{
    //
    // TODO: will probably have to exec process here.
    //
    return S_OK;
}

HRESULT EnsureMsmqService( CMsmqApi& rApi )
{
    HRESULT hr;

    //
    // issue a call to find out if the msmq service is down.
    //

    hr = IsMsmqOnline( rApi );

    if ( hr == WMIMSG_E_REQSVCNOTAVAIL )
    {
        //
        // try to restart the service.
        //
        
        OSVERSIONINFO osi;
        ZeroMemory( &osi, sizeof(OSVERSIONINFO) );
        osi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        GetVersionEx( &osi );
        
        if ( osi.dwPlatformId != VER_PLATFORM_WIN32_WINDOWS )
        {
            hr = StartMsmqServiceNT();
        }
        else
        {
            hr = StartMsmqService9x();
        }
    }
          
    if ( rApi.m_fpMQRegisterCertificate != NULL )
    {
        //
        // try to ensure that the calling user has an internal certificate 
        // registered.
        //

        CALLFUNC(MQRegisterCertificate)( MQCERT_REGISTER_IF_NOT_EXIST,
                                         NULL,
                                         0 );
    }
  
    return WBEM_S_NO_ERROR;
}

HRESULT IsMsmqWorkgroup( CMsmqApi& rApi )
{
    HRESULT hr;

    //
    // if the MQGetPrivateComputerInformation is avaliable use it. if not, 
    // then we have to go to the registry. 
    // 

    if ( rApi.m_fpMQGetPrivateComputerInformation != NULL )
    {
        MQPROPVARIANT PropVar;
        PropVar.vt = VT_BOOL;
        QMPROPID PropID = PROPID_PC_DS_ENABLED;

        MQPRIVATEPROPS PrivProps;
        PrivProps.cProp = 1;
        PrivProps.aPropID = &PropID;
        PrivProps.aPropVar = &PropVar;
        PrivProps.aStatus = NULL;

        hr = CALLFUNC(MQGetPrivateComputerInformation)( NULL, &PrivProps );

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = PropVar.boolVal == VARIANT_TRUE ? S_OK : S_FALSE;
    }
    else
    {
        //
        // TODO: Add non win2k version here ..
        //

        hr = S_FALSE;
    }

    return hr;
}

HRESULT IsMsmqOnline( CMsmqApi& rApi )
{
    //
    // There is a public w2k func to do this, but we can't rely on it because 
    // this module needs to run on older platforms.  Going to use internal
    // method for now.
    //

    HRESULT hr;
    
    MQPROPVARIANT MgmtPropVar;
    QMPROPID MgmtPropID = PROPID_MGMT_MSMQ_CONNECTED;
    
    MQMGMTPROPS MgmtProps;
    MgmtProps.cProp = 1;
    MgmtProps.aPropID = &MgmtPropID;
    MgmtProps.aPropVar = &MgmtPropVar;
    MgmtProps.aStatus = NULL;

    hr = CALLFUNC(MQMgmtGetInfo)( NULL, L"MACHINE", &MgmtProps );

    if ( FAILED(hr) )
    {
        return MqResToWmiRes( hr );
    }

    if ( _wcsicmp( MgmtPropVar.pwszVal, MSMQ_CONNECTED ) != 0 )
    {
        return S_FALSE;
    }

    return S_OK;
}

HRESULT NormalizeQueueName( CMsmqApi& rApi,
                            LPCWSTR wszEndpoint, 
                            WString& rwsFormat )
{
    HRESULT hr;

    //
    // if there is an '=' before any '\', then it is a format name.
    // else it is a pathname.
    //

    WCHAR* pwchEquals = wcschr( wszEndpoint, '=' );
    WCHAR* pwchSlash = wcschr( wszEndpoint, '\\' );

    if ( pwchEquals != NULL )
    {
        if ( pwchSlash == NULL || pwchSlash > pwchEquals )
        {
            rwsFormat = wszEndpoint;
            return S_OK;
        }
    }

    WCHAR achFormat[MAX_FORMAT_NAME];
    ULONG cFormat = MAX_FORMAT_NAME;

    hr = CALLFUNC(MQPathNameToFormatName)( wszEndpoint, achFormat, &cFormat );

    if ( FAILED(hr) )
    {
        return hr;
    }

    rwsFormat = achFormat;

    return S_OK;
}

/**************************************************************************
  CMsmqApi
***************************************************************************/

CMsmqApi::~CMsmqApi()
{
    if ( m_hModule != NULL )
    {
        FreeLibrary( m_hModule );
    }
}

#define GETFUNC(FUNC) \
    m_fp ##FUNC = (P ##FUNC) GetProcAddress( m_hModule, #FUNC ); \
    if ( m_fp ##FUNC == NULL ) { return HRESULT_FROM_WIN32(GetLastError()); }

#define GETFUNC_OPT(FUNC) \
    m_fp ##FUNC = (P ##FUNC) GetProcAddress( m_hModule, #FUNC );


HRESULT CMsmqApi::Initialize()
{
    if ( m_hModule != NULL )
    {
        return S_OK;
    }

    m_hModule = LoadLibrary( _T("mqrt") );

    if ( m_hModule == NULL )
    {
        //
        // msmq is not installed.
        //
        return WMIMSG_E_REQSVCNOTAVAIL;
    }

    GETFUNC( MQCreateQueue )
    GETFUNC( MQOpenQueue )
    GETFUNC( MQDeleteQueue )
    GETFUNC( MQFreeMemory )
    GETFUNC( MQSendMessage )
    GETFUNC( MQReceiveMessage )
    GETFUNC( MQCloseQueue )
    GETFUNC( MQCreateCursor )
    GETFUNC( MQCloseCursor )
    GETFUNC( MQMgmtGetInfo )
    GETFUNC( MQPathNameToFormatName )
    GETFUNC( MQGetSecurityContext )
    GETFUNC( MQGetQueueProperties)
    GETFUNC( MQFreeSecurityContext )
    GETFUNC_OPT( MQRegisterCertificate )
    GETFUNC_OPT( MQGetPrivateComputerInformation )

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\msgsvc.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef __MSGSVC_H__
#define __MSGSVC_H__

#include <wmimsg.h>
#include <unk.h>
#include <sync.h>

class CMsgServiceRecord;

/*********************************************************************
  CMsgService 
**********************************************************************/

class CMsgService : public CUnkInternal // will be singleton
{
    class XService : CImpl<IWmiMessageService, CMsgService>
    {
    public:

        STDMETHOD(Add)( IWmiMessageReceiverSink* pSink, 
                        HANDLE* phFileOverlapped,
                        DWORD dwFlags,
                        void** ppHdl );

        STDMETHOD(Remove)( void* pHdl );

        XService( CMsgService* pObj ) 
         : CImpl<IWmiMessageService, CMsgService> ( pObj ) { }

    } m_XService;

    CCritSec m_cs;
    long m_cSvcRefs;
    HANDLE m_hThread;
    BOOL m_bAsyncInit;

    static ULONG WINAPI AsyncServiceFunc( void* pCtx );
    static ULONG WINAPI SyncServiceFunc( void* pCtx );
    
    HRESULT EnsureService( BOOL bAsync );
    HRESULT CheckShutdown();
    
protected:

    virtual HRESULT AsyncInitialize() = 0;

    //
    // This call notifies the overlapped impl that it is must take care
    // of the first receive on the message service record.  It also 
    // gives the overlapped impl a chance to do something with the 
    // the file handle associated with overlapped i/o.  For example, 
    // completion port impl will add the file handle to the port.
    //  
    virtual HRESULT AsyncAddOverlappedFile( HANDLE hOverlapped,
                                            CMsgServiceRecord* pRecord ) = 0;
        
    //
    // responsible for causing all threads to break out of their svc loop. 
    // returns S_OK if it was successful.
    //
    virtual HRESULT AsyncShutdown( DWORD cThreads ) = 0;
   
    //
    // initializes overlapped struct and calls sink's receive(). 
    // passes result from sink's receive back.
    //
    virtual HRESULT AsyncReceive( CMsgServiceRecord* pRecord ) = 0;
    
    //
    // returns S_FALSE if a notify should not be performed by worker thread
    // returns S_OK if a notify should be performed by worker thread
    //
    virtual HRESULT AsyncWaitForCompletion( DWORD dwTimeout, 
                                            CMsgServiceRecord** ppRec) = 0;

public:
    
    CMsgService( CLifeControl* pControl );
    virtual ~CMsgService();

    void* GetInterface( REFIID riid );

    HRESULT Add( CMsgServiceRecord* pRec, HANDLE hFileOvrlapd, DWORD dwFlags );

    HRESULT Add( CMsgServiceRecord* pRec, DWORD dwFlags );

    HRESULT Remove( void* pHdl );
};

/***************************************************************************
  CMsgServiceNT - implements async part of MsgService using Completion ports.
****************************************************************************/

class CMsgServiceNT : public CMsgService
{
    HANDLE m_hPort;
    
public:

    CMsgServiceNT( CLifeControl* pControl );
    ~CMsgServiceNT();

    HRESULT AsyncAddOverlappedFile( HANDLE hOverlappedFile, 
                                    CMsgServiceRecord* pRecord );
    HRESULT AsyncInitialize();
    HRESULT AsyncShutdown( DWORD cThreads );
    HRESULT AsyncReceive( CMsgServiceRecord* pRecord );
    HRESULT AsyncWaitForCompletion(DWORD dwTimeout, CMsgServiceRecord** ppRec);
};

#endif __MSGSVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\msmqctx.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __MSMQCTX_H__
#define __MSMQCTX_H__

#include <wmimsg.h>
#include "msmqhdr.h"

/*************************************************************************
  CMsgMsmqRcvrCtx
**************************************************************************/

class CMsgMsmqRcvrCtx : public IWmiMessageReceiverContext
{
    CMsgMsmqHdr* m_pHdr;
    PSID m_pSenderSid;
    BOOL m_bAuth;

public:

    CMsgMsmqRcvrCtx( CMsgMsmqHdr* pHdr, 
                     PSID pSenderSid, 
                     BOOL bAuth ) 
    : m_pHdr(pHdr), m_pSenderSid(pSenderSid), m_bAuth(bAuth) {}

    STDMETHOD_(ULONG,AddRef)() { return 1; }
    STDMETHOD_(ULONG,Release)() { return 1; }
    STDMETHOD(QueryInterface)( REFIID riid, void** ppv )
    {
        if ( riid == IID_IUnknown || riid == IID_IWmiMessageReceiverContext )
        {
            *ppv = (IWmiMessageReceiverContext*)this;
            return S_OK;
        }
        return E_NOINTERFACE;
    }

    STDMETHOD(GetTimeSent)( SYSTEMTIME* pTime );

    STDMETHOD(GetSendingMachine)( WCHAR* awchMachine, 
                                  ULONG cMachine,
                                  ULONG* pcMachine );

    STDMETHOD(GetTarget)( WCHAR* awchTarget, 
                          ULONG cTarget,
                          ULONG* pcTarget );

    STDMETHOD(GetSenderId)( PBYTE achSenderId, 
                            ULONG cSenderId,
                            ULONG* pcSenderId );

    STDMETHOD(IsSenderAuthenticated)();

    STDMETHOD(ImpersonateSender)() { return WBEM_E_NOT_SUPPORTED; }
    STDMETHOD(RevertToSelf)() { return WBEM_E_NOT_SUPPORTED; }
};

#endif // __MSMQCTX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\msmqhdlr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __MSMQHDLR_H__
#define __MSMQHDLR_H__

#include <unk.h>
#include <wmimsg.h>
#include <comutl.h>
#include <msgsig.h>
#include "msmqcomn.h"

/**************************************************************************
  CMsgMsmqHandler - The message handler encapsulates the actual MSMQ 
  message structure, all of the memory associated with it, performing the 
  actual receive to MSMQ and delivering the message to the user's SendReceive
  message sink.  
***************************************************************************/

class CMsgMsmqHandler : public CUnk
{
    class XQueueReceiver : CImpl< IWmiMessageQueueReceiver, CMsgMsmqHandler >
    {
    public:

        STDMETHOD(ReceiveMessage)( DWORD dwTimeout, 
                                   PVOID pvCursor, 
                                   DWORD dwAction,
                                   ITransaction* pTxn )
        {
            return m_pObject->ReceiveMessage( dwTimeout, 
                                              dwAction,
                                              pvCursor,
                                              NULL,
                                              pTxn );
        }

        STDMETHOD(CreateCursor)( PVOID* ppvCursor )
        {
            return m_pObject->CreateCursor( ppvCursor );
        }

        STDMETHOD(DestroyCursor)( PVOID pvCursor )
        {
            return m_pObject->DestroyCursor( pvCursor );
        }

        XQueueReceiver( CMsgMsmqHandler* pObject )
         : CImpl< IWmiMessageQueueReceiver, CMsgMsmqHandler > (pObject) {} 
   
    } m_XQueueReceiver;

protected:

    CMsmqApi& m_rApi;
    DWORD m_dwFlags;
    MQMSGPROPS m_MsgProps;
    QUEUEHANDLE m_hQueue;
    CWbemPtr<CSignMessage> m_pSign;
    CWbemPtr<IWmiMessageSendReceive> m_pRecv;
    CWbemPtr<IUnknown> m_pContainer; // used to keep a container object alive.

    CMsgMsmqHandler( CMsmqApi& rApi,
                     IWmiMessageSendReceive* pRecv, 
                     QUEUEHANDLE hQueue, 
                     DWORD dwFlags )
     : m_hQueue(hQueue), m_XQueueReceiver(this), 
       m_pRecv(pRecv), m_dwFlags( dwFlags ), m_rApi( rApi )
    { 
        ZeroMemory( &m_MsgProps, sizeof(MQMSGPROPS) ); 
    }

    void* GetInterface( REFIID );

    HRESULT HandleMessage2( ITransaction* pTxn );
    HRESULT HandleMessageAck( HRESULT hr );

public:

    ~CMsgMsmqHandler(); 

    //
    // Use this if you want the handler to keep its parent container object 
    // alive until its demise.
    //
    void SetContainer( IUnknown* pContainer ) { m_pContainer = pContainer; }

    //
    // Receives the current message based on action. After a sucessful 
    // return from this call, the message is saved in this object.  
    // Subsequent calls to handle message can then be made.  
    // Any saved message from a previous call will be overwritten with the 
    // new msg. See idl for action values.
    //
    HRESULT ReceiveMessage( DWORD dwTimeout, 
                            DWORD dwAction,
                            PVOID pvCursor,
                            LPOVERLAPPED pOverlapped,
                            ITransaction* pTxn );
    //
    // Calls the SendReceive() method on the recv callback based on the 
    // contents of the message obtained from the last call to Receive.
    //
    HRESULT HandleMessage( ITransaction* pTxn );

    HRESULT CreateCursor( PVOID* ppvCursor );
    HRESULT DestroyCursor( PVOID pvCursor );

    HRESULT CheckBufferResize( HRESULT hr );

    static HRESULT Create( CMsmqApi& rApi,
                           IWmiMessageSendReceive* pRecv, 
                           QUEUEHANDLE hQueue,
                           DWORD dwFlags,
                           CMsgMsmqHandler** ppHndlr );
};

#endif // __MSMQHDLR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\msmqctx.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <wmimsg.h>
#include <comutl.h>
#include "msmqctx.h"

/***************************************************************************
  CMsgMsmqRcvrCtx
****************************************************************************/

STDMETHODIMP CMsgMsmqRcvrCtx::GetTimeSent( SYSTEMTIME* pTime )
{
    *pTime = *m_pHdr->GetTimeSent();
    return S_OK;
}

STDMETHODIMP CMsgMsmqRcvrCtx::GetSendingMachine( WCHAR* awchMachine, 
                                                 ULONG cMachine,
                                                 ULONG* pcMachine )
{ 
    LPCWSTR wszSource = m_pHdr->GetSendingMachine();

    *pcMachine = wcslen( wszSource ) + 1;

    if ( *pcMachine > cMachine )
    {
        return S_FALSE;
    }

    wcscpy( awchMachine, wszSource );

    return S_OK;
}

STDMETHODIMP CMsgMsmqRcvrCtx::GetTarget( WCHAR* awchTarget, 
                                         ULONG cTarget,
                                         ULONG* pcTarget )
{
    LPCWSTR wszTarget = m_pHdr->GetTarget();

    *pcTarget = wcslen( wszTarget ) + 1;

    if ( *pcTarget > cTarget )
    {
        return S_FALSE;
    }

    wcscpy( awchTarget, wszTarget );

    return S_OK;
}

STDMETHODIMP CMsgMsmqRcvrCtx::GetSenderId( PBYTE pchSenderId, 
                                           ULONG cSenderId,
                                           ULONG* pcSenderId )
{
    HRESULT hr;

    if ( m_pSenderSid != NULL )
    {
        *pcSenderId = GetLengthSid( m_pSenderSid );

        if ( *pcSenderId <= cSenderId )
        {
            memcpy( pchSenderId, m_pSenderSid, *pcSenderId );
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            hr = WBEM_S_FALSE;
        }
    }
    else
    {
        *pcSenderId = 0;
        hr = WBEM_S_NO_ERROR;
    }
    
    return hr;
}

STDMETHODIMP CMsgMsmqRcvrCtx::IsSenderAuthenticated()
{
    return m_bAuth ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\msmqhdr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <wmimsg.h>
#include "msmqhdr.h"

const DWORD g_dwSig = 0x6d696d77;
const BYTE g_chVersionMajor = 1;
const BYTE g_chVersionMinor = 0;

/****************************************************************************
  CMsgMsmqHdr
*****************************************************************************/

CMsgMsmqHdr::CMsgMsmqHdr( LPCWSTR wszTarget, 
                          LPCWSTR wszSource, 
                          PBYTE pDataHash,                          
                          ULONG cDataHash,
                          ULONG cAuxData )
: m_wszTarget(wszTarget), m_wszSource( wszSource ), 
  m_cAuxData(cAuxData), m_cDataHash(cDataHash)
{
    GetSystemTime( &m_Time );
    memcpy( m_achDataHash, pDataHash, cDataHash ); 
}

HRESULT CMsgMsmqHdr::Unpersist( CBuffer& rStrm )
{
    HRESULT hr;

    DWORD dwSig;
    BYTE chVersionMajor, chVersionMinor;

    //
    // read and verify signature.
    //

    hr = rStrm.Read( &dwSig, sizeof(DWORD), NULL );

    if ( hr != S_OK || dwSig != g_dwSig )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read and check version major (currently no check).
    //

    hr = rStrm.Read( &chVersionMajor, 1, NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    // 
    // read and check version minor (currently no check).
    //

    hr = rStrm.Read( &chVersionMinor, 1, NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read reserved
    //

    DWORD dwReserved;

    hr = rStrm.Read( &dwReserved, sizeof(DWORD), NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }
    
    //
    // read source machine.
    //

    hr = rStrm.ReadLPWSTR( m_wszSource );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read target queue name.
    //

    hr = rStrm.ReadLPWSTR( m_wszTarget );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read sent time.
    //

    hr = rStrm.Read( &m_Time, sizeof(SYSTEMTIME), NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read size of user data hash
    //

    hr = rStrm.Read( &m_cDataHash, sizeof(DWORD), NULL );

    if ( hr != S_OK || m_cDataHash > MAXHASHSIZE )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read hash of user data.
    //

    hr = rStrm.Read( m_achDataHash, m_cDataHash, NULL );
    
    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read length of user header.
    // 

    hr = rStrm.Read( &m_cAuxData, sizeof(DWORD), NULL );
    
    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }
    
    return WBEM_S_NO_ERROR;
}

HRESULT CMsgMsmqHdr::Persist( CBuffer& rStrm )
{
    HRESULT hr;

    hr = rStrm.Write( &g_dwSig, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write version major.
    //

    hr = rStrm.Write( &g_chVersionMajor, 1, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    // 
    // write version minor.
    //

    hr = rStrm.Write( &g_chVersionMinor, 1, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write reserved flags ( currently not used ).
    //

    DWORD dwReserved = 0;
    
    hr = rStrm.Write( &dwReserved, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write source machine
    //

    hr = rStrm.WriteLPWSTR( m_wszSource );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write target queue.
    //

    hr = rStrm.WriteLPWSTR( m_wszTarget );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write time sent.
    //

    hr =  rStrm.Write( &m_Time, sizeof(SYSTEMTIME), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write length of data hash
    //

    hr = rStrm.Write( &m_cDataHash, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write hash of data section
    //

    hr = rStrm.Write( m_achDataHash, m_cDataHash, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write the size of the user header.
    //

    return rStrm.Write( &m_cAuxData, sizeof(DWORD), NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\msmqq.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <wbemcli.h>
#include <wstring.h>
#include "msmqq.h"
#include "msmqcomn.h"

#define CALLFUNC(FUNC) m_Api.m_fp ## FUNC

/*************************************************************************
  CMsgMsmqQueue
**************************************************************************/

void* CMsgMsmqQueue::GetInterface( REFIID riid )
{
    if ( riid == IID_IWmiMessageQueue )
    {
        return &m_XQueue;
    }
    return NULL;
}

HRESULT CMsgMsmqQueue::EnsureQueue( LPCWSTR wszEndpoint, DWORD dwFlags )
{
    HRESULT hr;

    CInCritSec ics( &m_cs );

    if ( m_hQueue != NULL )
    {
        return WBEM_S_NO_ERROR;
    }

    WString wsFormat;

    hr = NormalizeQueueName( m_Api, wszEndpoint, wsFormat );
   
    if ( FAILED(hr) )
    {
        return hr;
    }
                                     
    return CALLFUNC(MQOpenQueue)( wsFormat, 
                                  MQ_RECEIVE_ACCESS, 
                                  MQ_DENY_NONE, 
                                  &m_hQueue );
}

HRESULT CMsgMsmqQueue::Open( LPCWSTR wszEndpoint,
                             DWORD dwFlags,
                             IWmiMessageSendReceive* pRcv,
                             IWmiMessageQueueReceiver** ppRcvr )
{
    ENTER_API_CALL

    HRESULT hr;

    *ppRcvr = NULL;

    hr = m_Api.Initialize();

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = EnsureMsmqService( m_Api );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = EnsureQueue( wszEndpoint, dwFlags );

    if ( FAILED(hr) )
    {
        return MqResToWmiRes(hr, WMIMSG_E_TARGETNOTFOUND );
    }

    CWbemPtr<CMsgMsmqHandler> pHndlr;

    hr = CMsgMsmqHandler::Create( m_Api,
                                  pRcv, 
                                  m_hQueue, 
                                  dwFlags, 
                                  &pHndlr );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // we will pass this object in to the handler.  This will keep this object
    // alive until the handler is released.  The benefit of this is that the
    // client doesn't have to hold a reference to both a queue object and a 
    // queue receiver object if they don't need to.
    //

    pHndlr->SetContainer( this );

    return pHndlr->QueryInterface( IID_IWmiMessageQueueReceiver, 
                                   (void**)ppRcvr );
    EXIT_API_CALL
}

HRESULT CMsgMsmqQueue::Clear()
{
    if ( m_hQueue != NULL )
    {
        CALLFUNC(MQCloseQueue)( m_hQueue );
    }
    m_hQueue = NULL;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\msmqhdr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __MSMQHDR_H__
#define __MSMQHDR_H__

#include <buffer.h>

#define MAXHASHSIZE 64

/**********************************************************************
  CMsgMsmqHdr - this header information is prepended with users header info
  found in AuxData. This is primarily used by ack receivers so they can 
  can obtain the target queue and sent time of the message.  There are a 
  couple of reasons why we store this information and not rely on msmq msg 
  props :  1 ) msmq cannot ensure that a returned message has not been 
  tampered with and 2 ) the target queue should be a logical name that a 
  user will understand, and not some format name that msmq will substitute
  such as with public queues pathnames.
***********************************************************************/

class CMsgMsmqHdr
{
    SYSTEMTIME m_Time;
    LPCWSTR m_wszTarget;
    LPCWSTR m_wszSource;
    BYTE m_achDataHash[MAXHASHSIZE];
    ULONG m_cDataHash;
    ULONG m_cAuxData;

public:

    CMsgMsmqHdr() { ZeroMemory( this, sizeof(CMsgMsmqHdr) ); }
    
    CMsgMsmqHdr( LPCWSTR wszTarget, 
                 LPCWSTR wszSource, 
                 BYTE* pDataHash,
                 ULONG cDataHash,
                 ULONG cAuxData );

    SYSTEMTIME* GetTimeSent() { return &m_Time; }
    LPCWSTR GetSendingMachine() { return m_wszSource; }
    LPCWSTR GetTarget() { return m_wszTarget; }
    PBYTE GetDataHash() { return m_achDataHash; }
    ULONG GetDataHashLength() { return m_cDataHash; }
    ULONG GetAuxDataLength() { return m_cAuxData; }

    HRESULT Unpersist( CBuffer& rStrm );
    HRESULT Persist( CBuffer& rStrm );
};

#endif // __MSMQHDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\msmqqmgr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#ifndef __MSMQQMGR_H__
#define __MSMQQMGR_H__

#include <unk.h>
#include <sync.h>
#include <wmimsg.h>
#include "msmqcomn.h"

/**************************************************************************
  CMsgMsmqQueueMgr
***************************************************************************/

class CMsgMsmqQueueMgr 
: public CUnkBase<IWmiMessageQueueManager,&IID_IWmiMessageQueueManager>
{
    CCritSec m_cs;
    CMsmqApi m_Api;

    HRESULT EnsureMsmq();

public:

    STDMETHOD(Create)( LPCWSTR wszPathName, 
                       GUID guidType, 
                       BOOL bAuth,
                       DWORD dwQos,
                       DWORD dwQuota,
                       PVOID pSecurityDescriptor );

    STDMETHOD(Destroy)( LPCWSTR wszName );

    STDMETHOD(GetAllNames)( GUID guidType,     
                            BOOL bPrivateOnly, 
                            LPWSTR** ppwszNames,
                            ULONG* pcNames );

    CMsgMsmqQueueMgr( CLifeControl* pCtl ) 
     : CUnkBase<IWmiMessageQueueManager,&IID_IWmiMessageQueueManager>(pCtl) { }
};

#endif // __MSMQQMGR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\msmqrecv.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __MSMQRECV_H__
#define __MSMQRECV_H__

#include <unk.h>
#include <wstring.h>
#include <sync.h>
#include <wmimsg.h>
#include <comutl.h>
#include "msmqhdlr.h"
#include "msmqrecv.h"
#include "msmqcomn.h"

/**************************************************************************
  CMsgMsmqReceiver
***************************************************************************/

class CMsgMsmqReceiver 
: public CUnkBase<IWmiMessageReceiver,&IID_IWmiMessageReceiver>
{
    CCritSec m_cs;
    CMsmqApi m_Api;
    DWORD m_dwFlags;
    WString m_wsEndpoint;
    QUEUEHANDLE m_hQueue;
    PVOID m_pSvcId;
    CWbemPtr<IWmiMessageService> m_pSvc;
    CWbemPtr<IWmiMessageSendReceive> m_pRecv;
    CWbemPtr<CMsgMsmqHandler> m_pHndlr;

    HRESULT EnsureReceiver();
    void* GetInterface( REFIID riid );
        
public:

    CMsgMsmqReceiver( CLifeControl* pCtl );
    ~CMsgMsmqReceiver();

    //
    // called by Rcv Sinks on error. 
    //
    HRESULT HandleError( HRESULT hr );
    HRESULT HandleReceiveError( HRESULT hr );

    STDMETHOD(Close)(); 

    STDMETHOD(Open)( LPCWSTR wszEndpoint,
                     DWORD dwFlags,
                     WMIMSG_RCVR_AUTH_INFOP pAuthInfo,
                     IWmiMessageSendReceive* pRcv );
};

/*************************************************************************
  CMsgSimpleRcvSink - Receive operation is not safe.  If something bad 
  happens after receiving the message but before delivering to the handler, 
  the message will be lost.  Supports Overlapped I/O.
**************************************************************************/

class CMsgSimpleRcvSink
: public CUnkBase<IWmiMessageReceiverSink, &IID_IWmiMessageReceiverSink>
{
    //
    // does not hold ref counts on these because of circular ref.
    //
    CMsgMsmqHandler* m_pHndlr;
    CMsgMsmqReceiver* m_pRcvr;

    CMsgSimpleRcvSink( CLifeControl* pCtl,
                       CMsgMsmqHandler* pHndlr,
                       CMsgMsmqReceiver* pRcvr )
    : CUnkBase<IWmiMessageReceiverSink, &IID_IWmiMessageReceiverSink>( pCtl ),
      m_pHndlr( pHndlr ), m_pRcvr( pRcvr ) {}

public: 

    STDMETHOD(Receive)( PVOID pOverlapped );
    STDMETHOD(Notify)( PVOID pOverlapped );

    static HRESULT Create( CLifeControl* pControl,
                           CMsgMsmqHandler* pHndlr,
                           CMsgMsmqReceiver* pRcvr,
                           IWmiMessageReceiverSink** ppRvcrSink );
};

/*************************************************************************
  CMsgSafeRcvSink - safely reads messages off a queue.  It first peeks at
  messages, delivers to the handler on completion, and then removes the 
  message.  Supports Overlapped I/O.  This implementation does NOT support 
  multiple instances per queue.  
**************************************************************************/

class CMsgSafeRcvSink
: public CUnkBase<IWmiMessageReceiverSink, &IID_IWmiMessageReceiverSink>
{
    //
    // does not hold ref counts on these because of circular ref.
    //
    CMsgMsmqHandler* m_pHndlr;
    CMsgMsmqReceiver* m_pRcvr;

    CMsgSafeRcvSink( CLifeControl* pCtl,
                     CMsgMsmqHandler* pHndlr,
                     CMsgMsmqReceiver* pRcvr )

    : CUnkBase<IWmiMessageReceiverSink, &IID_IWmiMessageReceiverSink>( pCtl ),
      m_pHndlr( pHndlr ), m_pRcvr( pRcvr ) {}

public: 

    STDMETHOD(Receive)( PVOID pOverlapped );
    STDMETHOD(Notify)( PVOID pOverlapped );  

    static HRESULT Create( CLifeControl* pControl,
                           CMsgMsmqHandler* pHndlr,
                           CMsgMsmqReceiver* pRcvr,
                           IWmiMessageReceiverSink** ppRvcrSink );
};

#endif // __MSMQRECV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\msmqrecv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <assert.h>
#include <wbemcli.h>
#include "msmqrecv.h"
#include "msmqcomn.h"

#define CALLFUNC(FUNC) (*m_Api.m_fp ## FUNC )

/**************************************************************************
   CMsgMsmqReceiver
***************************************************************************/

CMsgMsmqReceiver::CMsgMsmqReceiver( CLifeControl* pCtl )
: CUnkBase<IWmiMessageReceiver,&IID_IWmiMessageReceiver>( pCtl ), 
  m_pSvcId(NULL), m_hQueue(INVALID_HANDLE_VALUE), m_dwFlags(0) 
{ 
} 

CMsgMsmqReceiver::~CMsgMsmqReceiver()
{
    Close();
}

HRESULT CMsgMsmqReceiver::Close()
{
    ENTER_API_CALL

    //
    // before removing the sink from the service, the receiver is 
    // responsible for knocking the sink out its blocking calls on the
    // queue.  This is done by closing the queue handle.
    //

    if ( m_hQueue != INVALID_HANDLE_VALUE )
    {
        CALLFUNC(MQCloseQueue)( m_hQueue );
        m_hQueue = INVALID_HANDLE_VALUE;
    }

    if ( m_pSvcId != NULL )
    {
        assert( m_pSvc != NULL );
        m_pSvc->Remove( m_pSvcId );
        m_pSvcId = NULL;
    }

    m_pSvc.Release();
    m_pHndlr.Release();

    return S_OK;

    EXIT_API_CALL
}

HRESULT CMsgMsmqReceiver::EnsureReceiver()
{
    HRESULT hr;

    assert( m_pHndlr == NULL );
    assert( m_pSvc == NULL );
    assert( m_pSvcId == NULL );
    assert( m_hQueue == INVALID_QUEUE_HANDLE );
    
    //
    // obtain a pointer to the message service.  The message service is a 
    // singleton.  This way, all receivers can locate and share the same 
    // service.  The receiver is going to hand its receiver sink to the 
    // service.
    //
    hr = CoCreateInstance( CLSID_WmiMessageService, 
                           NULL, 
                           CLSCTX_INPROC,
                           IID_IWmiMessageService,
                           (void**)&m_pSvc );
    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = EnsureMsmqService( m_Api );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // try to normalize the queue name.
    //

    WString wsFormat;

    hr = NormalizeQueueName( m_Api, m_wsEndpoint, wsFormat );
   
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // try to open the queue
    //
                                     
    hr = CALLFUNC(MQOpenQueue)( wsFormat, 
                                MQ_RECEIVE_ACCESS, 
                                MQ_DENY_NONE, 
                                &m_hQueue );    
    if ( FAILED(hr) )
    {
        return MqResToWmiRes( hr, WMIMSG_E_TARGETNOTFOUND );
    }

    hr = CMsgMsmqHandler::Create( m_Api, 
                                  m_pRecv, 
                                  m_hQueue, 
                                  m_dwFlags, 
                                  &m_pHndlr );
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Create the appropriate sink according to the Qos and add it to 
    // the message service.  Currently, all Qos types support overlapped i/o.
    //

    CWbemPtr<IWmiMessageReceiverSink> pSink;

    switch( m_dwFlags & WMIMSG_MASK_QOS )
    {
    case WMIMSG_FLAG_QOS_EXPRESS:

        hr = CMsgSimpleRcvSink::Create( m_pControl, m_pHndlr, this, &pSink );
        break;

    case WMIMSG_FLAG_QOS_GUARANTEED:

        hr = CMsgSafeRcvSink::Create( m_pControl, m_pHndlr, this, &pSink );
        break;

    default:

        return WBEM_E_NOT_SUPPORTED;
    };

    //
    // The SvcId will be used on release of the receiver to remove 
    // the sink from the messsage service.  
    //
    
    return m_pSvc->Add( pSink, &m_hQueue, 0, &m_pSvcId );    
}

HRESULT CMsgMsmqReceiver::Open( LPCWSTR wszEndpoint,
                                DWORD dwFlags,
                                WMIMSG_RCVR_AUTH_INFOP pAuthInfo,
                                IWmiMessageSendReceive* pRecv )
{
    ENTER_API_CALL

    HRESULT hr;

    CInCritSec ics( &m_cs );

    hr = m_Api.Initialize();

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // handle cleanup of open queues and open msg svc connections.
    //

    Close();

    //
    // need to save the endpoint and flags because we may need to reinitialize
    // at a later time.
    //

    m_wsEndpoint = wszEndpoint;
    m_dwFlags = dwFlags;
    m_pRecv = pRecv;

    //
    // rest of init takes place in EnsureReceiver().  This part of init will 
    // also occur later when trying to recover from queue errors.
    //

    return EnsureReceiver();

    EXIT_API_CALL
}

HRESULT CMsgMsmqReceiver::HandleError( HRESULT hr )
{
    CWbemPtr<IWmiMessageTraceSink> pTraceSink;
    
    if ( m_pRecv->QueryInterface( IID_IWmiMessageTraceSink, 
                                  (void**)&pTraceSink ) == S_OK )
    {
        pTraceSink->Notify( MqResToWmiRes(hr), 
                            CLSID_WmiMessageMsmqReceiver, 
                            m_wsEndpoint, 
                            NULL );
    }

    return hr;
}

HRESULT CMsgMsmqReceiver::HandleReceiveError( HRESULT hr )
{
    //
    // if this method returns Success, then it means that we should keep
    // keep receiving.
    //

    if ( hr == MQ_ERROR_INVALID_HANDLE || hr == MQ_ERROR_OPERATION_CANCELLED )
    {
        //
        // indicates shutdown. we want to stop receiving on the sink, 
        // but since this is a benign error, don't notify the error sink.
        //
        return WBEM_E_SHUTTING_DOWN;
    }

    //
    // ask the handler if it needs to resize any of its buffers. If so, 
    // then return success and we'll try again.
    //
    
    HRESULT hr2 = m_pHndlr->CheckBufferResize(hr);

    if ( hr2 != S_FALSE )
    {
        return hr2;        
    }
        
    //
    // some errors we can attempt to recover from.  Unfortunately, we 
    // cannot tell here if this is one of those errors.  So always try to 
    // revive the receiver.  
    //
    
    Close(); 
    
    hr2 = EnsureReceiver();

    //
    // always tell the trace sink about this error.  If EnsureReceiver()
    // was successful, then the error will downgraded to a warning.  TODO.
    //

    HandleError( hr );

    //
    // we always want to return the original error because we want the svc
    // to stop receiving on the original sink.  If EnsureReceiver() is 
    // successful, then a new sink will be created to take its place.
    //

    return hr;
}

/**************************************************************************
   CMsgSimpleRcvSink
***************************************************************************/

STDMETHODIMP CMsgSimpleRcvSink::Receive( PVOID pOverlapped )
{
    ENTER_API_CALL

    HRESULT hr;

    hr = m_pHndlr->ReceiveMessage( INFINITE, 
                                   WMIMSG_ACTION_QRCV_RECEIVE, 
                                   NULL,
                                   LPOVERLAPPED(pOverlapped), 
                                   NULL );
    if ( FAILED(hr) )
    {
        return m_pRcvr->HandleReceiveError( hr );
    }

    return WBEM_S_NO_ERROR;

    EXIT_API_CALL
}

STDMETHODIMP CMsgSimpleRcvSink::Notify( PVOID pvOverlapped )
{
    ENTER_API_CALL

    HRESULT hr;

    LPOVERLAPPED pOverlapped = LPOVERLAPPED(pvOverlapped);

    hr = ULONG(pOverlapped->Internal);

    if ( FAILED(hr) )
    {
        return m_pRcvr->HandleReceiveError( hr );
    }

    hr = m_pHndlr->HandleMessage( NULL );

    if ( FAILED(hr) )
    {
        //
        // we don't want to return this hr because we'll stop listening 
        // on the sink. HandleError notifies the user, but we keep on 
        // truckin.  Its only when there is an error with receiving from 
        // the queue handle that we stop receiving on the sink.
        //
        m_pRcvr->HandleError( hr );
    }

    return WBEM_S_NO_ERROR;

    EXIT_API_CALL
}   

HRESULT CMsgSimpleRcvSink::Create( CLifeControl* pControl,
                                   CMsgMsmqHandler* pHndlr,
                                   CMsgMsmqReceiver* pRcvr,
                                   IWmiMessageReceiverSink** ppSink )
{
    HRESULT hr;

    *ppSink = NULL;

    CWbemPtr<CMsgSimpleRcvSink> pSink;

    pSink = new CMsgSimpleRcvSink( pControl, pHndlr, pRcvr );

    if ( pSink == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return pSink->QueryInterface( IID_IWmiMessageReceiverSink, (void**)ppSink);
}

/**************************************************************************
   CMsgSafeRcvSink
***************************************************************************/

STDMETHODIMP CMsgSafeRcvSink::Receive( PVOID pOverlapped )
{
    ENTER_API_CALL

    HRESULT hr;

    hr = m_pHndlr->ReceiveMessage( INFINITE, 
                                   WMIMSG_ACTION_QRCV_PEEK_CURRENT, 
                                   NULL,
                                   LPOVERLAPPED(pOverlapped),
                                   NULL );
    if ( FAILED(hr) )
    {
        return m_pRcvr->HandleReceiveError(hr);
    }

    return WBEM_S_NO_ERROR;

    EXIT_API_CALL
}

STDMETHODIMP CMsgSafeRcvSink::Notify( PVOID pvOverlapped )
{
    ENTER_API_CALL
    
    HRESULT hr;

    LPOVERLAPPED pOverlapped = LPOVERLAPPED(pvOverlapped);

    hr = ULONG(pOverlapped->Internal);

    if ( FAILED(hr) )
    {
        return m_pRcvr->HandleReceiveError( hr );
    }

    hr = m_pHndlr->HandleMessage( NULL );

    //
    // we don't want to return this hr because we'll stop listening 
    // on the sink. HandleError notifies the user, but we keep on 
    // truckin.  Its only when there is an error with receiving from 
    // the queue handle that we stop receiving on the sink.
    //
    if ( FAILED(hr) )
    {
        m_pRcvr->HandleError( hr );
    }

    hr = m_pHndlr->ReceiveMessage( INFINITE, 
                                   WMIMSG_ACTION_QRCV_REMOVE, 
                                   NULL,
                                   NULL,
                                   NULL );

    if ( FAILED(hr) )
    {
        return m_pRcvr->HandleReceiveError( hr );
    }

    return WBEM_S_NO_ERROR; 

    EXIT_API_CALL
}

HRESULT CMsgSafeRcvSink::Create( CLifeControl* pControl,
                                 CMsgMsmqHandler* pHndlr,
                                 CMsgMsmqReceiver* pRcvr,
                                 IWmiMessageReceiverSink** ppSink )
{
    HRESULT hr;

    *ppSink = NULL;

    CWbemPtr<CMsgSafeRcvSink> pSink;

    pSink = new CMsgSafeRcvSink( pControl, pHndlr, pRcvr );

    if ( pSink == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    return pSink->QueryInterface(IID_IWmiMessageReceiverSink, (void**)ppSink);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\msmqq.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __MSMQQ_H__
#define __MSMQQ_H__

#include <unk.h>
#include <wmimsg.h>
#include <sync.h>
#include "msmqhdlr.h"
#include "msmqcomn.h"

/**************************************************************************
  CMsgMsmqQueue
***************************************************************************/

class CMsgMsmqQueue : public CUnk
{
    class XQueue : public CImpl<IWmiMessageQueue, CMsgMsmqQueue> 
    {
    public:

        STDMETHOD(Open)( LPCWSTR wszEndpoint,
                         DWORD dwFlags,
                         IWmiMessageSendReceive* pRcv,
                         IWmiMessageQueueReceiver** ppRcv )
        { 
            return m_pObject->Open( wszEndpoint, dwFlags, pRcv, ppRcv ); 
        }

        XQueue( CMsgMsmqQueue* pObj ) 
         : CImpl<IWmiMessageQueue, CMsgMsmqQueue > ( pObj ) { } 
    
    } m_XQueue;

    HRESULT EnsureQueue( LPCWSTR wszEndpoint, DWORD dwFlags );
    void* GetInterface( REFIID riid );

    CCritSec m_cs;
    CMsmqApi m_Api;
    QUEUEHANDLE m_hQueue;
    
public: 

    CMsgMsmqQueue( CLifeControl* pCtl, IUnknown* pUnk = NULL ) 
      : CUnk( pCtl, pUnk ), m_XQueue( this ), m_hQueue( NULL ) { }

    ~CMsgMsmqQueue() { Clear(); }

    HRESULT Clear(); 

    HRESULT Open( LPCWSTR wszEndpoint,
                  DWORD dwFlags,
                  IWmiMessageSendReceive* pRcv,
                  IWmiMessageQueueReceiver** ppRecv );
};

#endif // __MSMQQ_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\msmqsend.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <assert.h>
#include <arrtempl.h>
#include <comutl.h>
#include <wbemcli.h>
#include <buffer.h>
#include "msmqhdr.h"
#include "msmqsend.h"
#include "msmqcomn.h"

#define MAXPROPS 10
#define MAXHASHSIZE 64

struct MsmqOutgoingMessage : MQMSGPROPS
{
    MSGPROPID     m_aPropID[MAXPROPS];
    MQPROPVARIANT m_aPropVar[MAXPROPS]; 
    
    MsmqOutgoingMessage( DWORD dwFlags, DWORD dwStatus,
                         LPBYTE pData, ULONG cData, 
                         LPBYTE pHdr, ULONG cHdr, 
                         HANDLE hSecCtx, LPCWSTR wszAckFormatName );
};

/*****************************************************************
  CMsgMsmqSender
******************************************************************/

HRESULT CMsgMsmqSender::Open( LPCWSTR wszTarget, 
                              DWORD dwFlags,
                              WMIMSG_SNDR_AUTH_INFOP pAuthInfo,
                              LPCWSTR wszResponse,
                              IWmiMessageTraceSink* pTraceSink,
                              IWmiMessageSendReceive** ppSend )
{
    HRESULT hr;
    *ppSend = NULL;

    ENTER_API_CALL

    if ( (dwFlags & WMIMSG_MASK_QOS) != WMIMSG_FLAG_QOS_EXPRESS &&
         (dwFlags & WMIMSG_MASK_QOS) != WMIMSG_FLAG_QOS_GUARANTEED )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    CWbemPtr<CMsgMsmqSend> pSend;

    pSend = new CMsgMsmqSend( m_pControl,
                              wszTarget, 
                              dwFlags, 
                              wszResponse,
                              pTraceSink );

    if ( pSend == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    if ( (dwFlags & WMIMSG_FLAG_SNDR_LAZY_INIT) == 0 )
    {
        hr = pSend->EnsureSender();

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    return pSend->QueryInterface(IID_IWmiMessageSendReceive, (void**)ppSend);

    EXIT_API_CALL
}

/*****************************************************************
  CMsgMsmqSend
******************************************************************/

#define CALLFUNC(FUNC) (*m_Api.m_fp ## FUNC )

CMsgMsmqSend::CMsgMsmqSend( CLifeControl* pCtl, 
                            LPCWSTR wszTarget,
                            DWORD dwFlags,
                            LPCWSTR wszResponse,
                            IWmiMessageTraceSink* pTraceSink )
 : CUnkBase<IWmiMessageSendReceive,&IID_IWmiMessageSendReceive>(pCtl),
   m_bInit(FALSE), m_hQueue(NULL), m_dwFlags(dwFlags), 
   m_wsResponse( wszResponse ), m_hSecCtx( NULL ), m_pTraceSink( pTraceSink )
{ 
    //
    // save our computer name.
    //

    TCHAR achComputer[MAX_COMPUTERNAME_LENGTH+1];
    ULONG ulSize = MAX_COMPUTERNAME_LENGTH+1;
    GetComputerName( achComputer, &ulSize );
    m_wsComputer = achComputer;

    //
    // if the target is NULL, then we use our computer name as the target.
    //

    if ( wszTarget != NULL && *wszTarget != '\0' )
    { 
        m_wsTarget = wszTarget;
    }
    else
    {
        m_wsTarget = m_wsComputer;
    }
} 

CMsgMsmqSend::~CMsgMsmqSend() 
{ 
    Clear(); 
}

HRESULT CMsgMsmqSend::HandleTrace( HRESULT hr, IUnknown* pCtx )
{
    if ( m_pTraceSink != NULL )
    {
        return m_pTraceSink->Notify( hr, 
                                     CLSID_WmiMessageMsmqSender, 
                                     m_wsTarget, 
                                     pCtx );
    }
    return WBEM_S_NO_ERROR;
}

void CMsgMsmqSend::Clear()
{
    m_bInit = FALSE;

    if ( m_hSecCtx != NULL )
    {
        CALLFUNC(MQFreeSecurityContext)( m_hSecCtx );
        m_hSecCtx = NULL;
    }

    if ( m_hQueue != NULL )
    {
        CALLFUNC(MQCloseQueue)( m_hQueue );
        m_hQueue = NULL;
    }    
}

HRESULT CMsgMsmqSend::EnsureSender()
{
    HRESULT hr;

    CInCritSec ics(&m_cs);

    if ( m_bInit )
    {
        return WBEM_S_NO_ERROR;
    }

    hr = m_Api.Initialize();

    if ( FAILED(hr) )
    {
        return hr; // MSMQ probably isn't installed.
    }

    hr = EnsureMsmqService( m_Api );

    if ( FAILED(hr) )
    {
        return hr;
    }

    Clear();

    WString wsFormatName;

    hr = NormalizeQueueName( m_Api, m_wsTarget, wsFormatName );

    if ( FAILED(hr) )
    {     
        return MqResToWmiRes( hr, WMIMSG_E_INVALIDADDRESS );
    }

    hr = CALLFUNC(MQOpenQueue)( wsFormatName, 
                                MQ_SEND_ACCESS, 
                                MQ_DENY_NONE, 
                                &m_hQueue );

    if ( FAILED(hr) )
    {
        return MqResToWmiRes( hr, WMIMSG_E_TARGETNOTFOUND );
    }

    if ( m_dwFlags & WMIMSG_FLAG_SNDR_AUTHENTICATE )
    {
        //
        // get security context for process account. 
        // 

        hr = CALLFUNC(MQGetSecurityContext)( NULL, 0, &m_hSecCtx );

        if ( FAILED(hr) )
        {
            return MqResToWmiRes( hr, WMIMSG_E_AUTHFAILURE );
        }
    }

    //
    // this will be used to sign our hdr so that a local receiver ( such as 
    // an ack receiver can verify this machine sent it ).
    //

    hr = CSignMessage::Create( L"WMIMSG", &m_pSign );

    if ( FAILED(hr) )
    {
        return hr;
    }

    m_bInit = TRUE;

    return hr;
}
    
MsmqOutgoingMessage::MsmqOutgoingMessage( DWORD dwFlags, DWORD dwStatus,
                                          LPBYTE pData, ULONG cData, 
                                          LPBYTE pHdr, ULONG cHdr, 
                                          HANDLE hSecCtx, 
                                          LPCWSTR wszAckFormatName )
{
    cProp = 0;
    aPropID = m_aPropID;
    aPropVar = m_aPropVar;
    aStatus= NULL;

    m_aPropID[cProp] = PROPID_M_BODY;
    m_aPropVar[cProp].vt = VT_VECTOR | VT_UI1;
    m_aPropVar[cProp].caub.cElems = cData;
    m_aPropVar[cProp].caub.pElems = pData;
    cProp++;

    m_aPropID[cProp] = PROPID_M_EXTENSION;
    m_aPropVar[cProp].vt = VT_VECTOR | VT_UI1;
    m_aPropVar[cProp].caub.cElems = cHdr;
    m_aPropVar[cProp].caub.pElems = pHdr;
    cProp++;

    m_aPropID[cProp] = PROPID_M_APPSPECIFIC;
    m_aPropVar[cProp].vt = VT_UI4;
    m_aPropVar[cProp].ulVal = dwStatus;
    cProp++;

    if ( wszAckFormatName != NULL && *wszAckFormatName != '\0')
    {
        m_aPropID[cProp] = PROPID_M_ACKNOWLEDGE;
        m_aPropVar[cProp].vt = VT_UI1;
        m_aPropVar[cProp].bVal = MQMSG_ACKNOWLEDGMENT_NACK_RECEIVE;
        cProp++;

        m_aPropID[cProp] = PROPID_M_ADMIN_QUEUE;
        m_aPropVar[cProp].vt = VT_LPWSTR;
        m_aPropVar[cProp].pwszVal = LPWSTR(wszAckFormatName);
        cProp++;
    }

    if ( (dwFlags & WMIMSG_MASK_QOS) != WMIMSG_FLAG_QOS_EXPRESS )
    {
        m_aPropID[cProp] = PROPID_M_DELIVERY;
        m_aPropVar[cProp].vt = VT_UI1;
        m_aPropVar[cProp].bVal = MQMSG_DELIVERY_RECOVERABLE;
        cProp++;
    } 
    
    if ( dwFlags & WMIMSG_FLAG_SNDR_AUTHENTICATE )
    {
        m_aPropID[cProp] = PROPID_M_AUTH_LEVEL;
        m_aPropVar[cProp].vt = VT_UI4;
        m_aPropVar[cProp].ulVal = MQMSG_AUTH_LEVEL_ALWAYS;
        cProp++;
    
#ifndef _WIN64
        m_aPropID[cProp] = PROPID_M_SECURITY_CONTEXT;
        m_aPropVar[cProp].vt = VT_UI4;
        m_aPropVar[cProp].ulVal = ULONG(hSecCtx);      
        cProp++;
#endif

    }

    if ( dwFlags & WMIMSG_FLAG_SNDR_ENCRYPT )
    {
        m_aPropID[cProp] = PROPID_M_PRIV_LEVEL;
        m_aPropVar[cProp].vt = VT_UI4;
        m_aPropVar[cProp].ulVal = MQMSG_PRIV_LEVEL_BODY;
        cProp++;
    }
}

HRESULT CMsgMsmqSend::SendReceive( PBYTE pData, 
                                   ULONG cData,
                                   PBYTE pAuxData,
                                   ULONG cAuxData,
                                   DWORD dwFlagStatus,
                                   IUnknown* pCtx ) 
{
    ENTER_API_CALL

    HRESULT hr;

    hr = Send( pData, cData, pAuxData, cAuxData, dwFlagStatus, pCtx );

    if ( FAILED(hr) )
    {
        HandleTrace( hr, pCtx );
        return hr;
    }

    return HandleTrace( hr, pCtx );

    EXIT_API_CALL
}

HRESULT CMsgMsmqSend::Send( PBYTE pData, 
                            ULONG cData,
                            PBYTE pAuxData,
                            ULONG cAuxData,
                            DWORD dwFlagStatus,
                            IUnknown* pCtx ) 
{
    HRESULT hr;

    hr = EnsureSender();

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    DWORD dwStatus = 0;

    ULONG cHash = MAXHASHSIZE;
    BYTE achHash[MAXHASHSIZE];

    if ( m_dwFlags & WMIMSG_FLAG_SNDR_PRIV_SIGN )
    {
        //
        // create a 'private' hash on the data. this will be used by local 
        // receivers to verify that it sent the message and that it has not 
        // been tampered with.
        //

        hr = m_pSign->Sign( pData, cData, achHash, cHash );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }
    else
    {
        cHash = 0;
    }

    //
    // now we can create our msmq msg header. this header will be prepended
    // to the users header in auxdata.  We do not create our own header if 
    // this is an ack sender because AuxData already contains an msmq msg hdr.
    // For nacks, msmq will return data as sent, so we want to remain 
    // consistent with this for our 'application' level acks.
    // 

    BYTE achHdr[512];

    CBuffer HdrStrm( achHdr, 512, FALSE );

    CMsgMsmqHdr MsmqHdr( m_wsTarget, m_wsComputer, achHash, cHash, cAuxData );

    if ( (m_dwFlags & WMIMSG_FLAG_SNDR_ACK) == 0 )
    {
        hr = MsmqHdr.Persist( HdrStrm );
        
        if ( FAILED(hr) )
        {
            return hr;
        }
    }
    else
    {
        //
        // the flagstatus param contains the status.
        //
        dwStatus = dwFlagStatus;
    }

    hr = HdrStrm.Write( pAuxData, cAuxData, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( m_dwFlags & WMIMSG_FLAG_SNDR_PRIV_SIGN )
    {
        //
        // hash the entire header and store it at the end of the header.
        //

        hr = m_pSign->Sign( HdrStrm.GetRawData(), 
                            HdrStrm.GetIndex(), 
                            achHash, 
                            cHash );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }
    else
    {
        cHash = 0;
    }

    hr = HdrStrm.Write( &cHash, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = HdrStrm.Write( achHash, cHash, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }
 
    //
    // Obtain the correct ITransaction ptr. If the user did not specify
    // a txn and we are sending using xact qos, then we need to use the 
    // single message txn.
    //

    CWbemPtr<ITransaction> pTxn;

    if ( pCtx != NULL )
    {
        pCtx->QueryInterface( IID_ITransaction, (void**)&pTxn );
    }

    DWORD dwQos = m_dwFlags & WMIMSG_MASK_QOS;

    if ( pTxn == NULL && dwQos == WMIMSG_FLAG_QOS_XACT )
    {
        pTxn = MQ_SINGLE_MESSAGE;
    }

    HANDLE hSecCtx = m_hSecCtx;

    if ( m_dwFlags & WMIMSG_FLAG_SNDR_AUTHENTICATE )
    {
        //
        // Check to see if we're impersonating.  If so, then we need to 
        // obtain the MSMQ security context and use it when sending the 
        // message.
        //

        HANDLE hToken;
              
        if ( OpenThreadToken( GetCurrentThread(), 
                              TOKEN_QUERY, 
                              TRUE, 
                              &hToken ) )
        {
            CloseHandle( &hToken );
           
            //
            // we are forgiving when encountering errors with authentication 
            // on the send side.  This is because the receiving end might not
            // even care about authentication ( and msmq doesn't have mutual 
            // auth ).  If the target cares about auth, then we'll be sure to
            // find out via a nack msg.
            // 

            hr = CALLFUNC(MQGetSecurityContext)( NULL, 0, &hSecCtx );

            if ( FAILED(hr) )
            {
                return MqResToWmiRes( hr, WMIMSG_E_AUTHFAILURE );
            }
        }        
    }
    
    MsmqOutgoingMessage Msg( m_dwFlags,
                             dwStatus,
                             pData, 
                             cData, 
                             HdrStrm.GetRawData(),
                             HdrStrm.GetIndex(),
                             hSecCtx,
                             m_wsResponse );
    
    hr = CALLFUNC(MQSendMessage)( m_hQueue, &Msg, pTxn );  

    if( hSecCtx != m_hSecCtx && hSecCtx != NULL )
    {
        CALLFUNC(MQFreeSecurityContext)( hSecCtx );
    }

    if ( FAILED(hr) )
    {
        //
        // this is so the next call will reset us.
        //
        Clear();

        return MqResToWmiRes( hr );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\msmqqmgr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <wbemcli.h>
#include <comutl.h>
#include "msmqcomn.h"
#include "msmqqmgr.h"


static QUEUEPROPID g_aQueuePropID[] = { PROPID_Q_TRANSACTION, 
                                        PROPID_Q_PATHNAME,
                                        PROPID_Q_AUTHENTICATE,
                                        PROPID_Q_QUOTA,
                                        PROPID_Q_TYPE };

const DWORD g_cQueueProp = sizeof(g_aQueuePropID) / sizeof(QUEUEPROPID);

#define CALLFUNC(FUNC) m_Api.m_fp ## FUNC

/*************************************************************************
  CMsgMsmqQueueMgr
**************************************************************************/

HRESULT CMsgMsmqQueueMgr::EnsureMsmq()
{
    HRESULT hr;

    CInCritSec ics( &m_cs );

    hr = m_Api.Initialize();

    if ( FAILED(hr) )
    {
        return hr;
    }

    return EnsureMsmqService( m_Api );
}   

HRESULT CMsgMsmqQueueMgr::Create( LPCWSTR wszPathName,
                                  GUID guidType,
                                  BOOL bAuth,
                                  DWORD dwQos,
                                  DWORD dwQuota,
                                  PVOID pSecDesc )
{
    HRESULT hr;

    hr = EnsureMsmq();

    if ( FAILED(hr) )
    {
        return hr;
    }

    MQPROPVARIANT aPropVar[g_cQueueProp];

    BOOL bXact = dwQos == WMIMSG_FLAG_QOS_XACT ? TRUE : FALSE;

    //
    // transaction
    //

    aPropVar[0].vt = VT_UI1;
    aPropVar[0].bVal = bXact ? MQ_TRANSACTIONAL : MQ_TRANSACTIONAL_NONE;

    //
    // pathname
    //   
    aPropVar[1].vt = VT_LPWSTR;
    aPropVar[1].pwszVal = LPWSTR(wszPathName);

    //
    // auth
    //
    aPropVar[2].vt = VT_UI1;
    aPropVar[2].bVal = bAuth ? MQ_AUTHENTICATE : MQ_AUTHENTICATE_NONE;

    //
    // quota
    //
    aPropVar[3].vt = VT_UI4;
    aPropVar[3].ulVal = dwQuota;

    //
    // type
    //
    aPropVar[4].vt = VT_CLSID;
    aPropVar[4].puuid = &guidType;
    
    MQQUEUEPROPS QueueProps;
    QueueProps.cProp = g_cQueueProp;
    QueueProps.aPropID = g_aQueuePropID;
    QueueProps.aPropVar = aPropVar;
    QueueProps.aStatus = NULL;

    DWORD dwDummy = 0;

    hr = CALLFUNC(MQCreateQueue)( pSecDesc, &QueueProps, NULL, &dwDummy );  

    if ( FAILED(hr) )
    {
        return MqResToWmiRes(hr);
    }
    
    return hr;  
} 

HRESULT CMsgMsmqQueueMgr::Destroy( LPCWSTR wszName )
{
    ENTER_API_CALL

    HRESULT hr;

    hr = EnsureMsmq();

    if ( FAILED(hr) )
    {
        return hr;
    }

    WString wsFormat;

    hr = NormalizeQueueName( m_Api, wszName, wsFormat ); 

    if ( FAILED(hr) )
    {
        return MqResToWmiRes( hr);
    }
    
    return CALLFUNC(MQDeleteQueue)( wsFormat );

    EXIT_API_CALL
}

HRESULT CMsgMsmqQueueMgr::GetAllNames( GUID guidTypeFilter,     
                                       BOOL bPrivateOnly, 
                                       LPWSTR** ppwszNames,
                                       ULONG* pcNames )
{ 
    ENTER_API_CALL

    HRESULT hr;

    *ppwszNames = NULL;
    *pcNames = 0;

    hr = EnsureMsmq();

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( bPrivateOnly != TRUE )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    //
    // First get all private queue names.
    //

    MGMTPROPID MgmtPropID = PROPID_MGMT_MSMQ_PRIVATEQ;
    MQPROPVARIANT MgmtPropVar;
    MgmtPropVar.vt = VT_LPWSTR | VT_VECTOR;

    MQMGMTPROPS MgmtProps;
    MgmtProps.cProp = 1;
    MgmtProps.aPropID = &MgmtPropID;
    MgmtProps.aPropVar = &MgmtPropVar;
    MgmtProps.aStatus = NULL;

    hr = CALLFUNC(MQMgmtGetInfo)( NULL, L"MACHINE", &MgmtProps );

    if ( FAILED(hr) )
    {
        return MqResToWmiRes( hr );
    }

    // 
    // Allocate return array to total number of private queues.  
    // Because of the filter guid, the actual returned number 
    // will most likely be smaller.  
    //  

    DWORD dwSize = sizeof(LPWSTR) * MgmtPropVar.calpwstr.cElems;
    LPWSTR* awszNames = (LPWSTR*)CoTaskMemAlloc( dwSize );

    if ( awszNames == NULL )
    {
        CALLFUNC(MQFreeMemory)( MgmtPropVar.calpwstr.pElems );
        return WBEM_E_OUT_OF_MEMORY;
    }

    //
    // for each name, get the queue type guid for it and compare 
    // with the filter type guid.
    //

    CLSID guidType;

    QUEUEPROPID QueuePropID = PROPID_Q_TYPE;

    MQPROPVARIANT QueuePropVar;
    QueuePropVar.vt = VT_CLSID;
    QueuePropVar.puuid = &guidType;

    MQQUEUEPROPS QueueProps;
    QueueProps.cProp = 1;
    QueueProps.aPropID = &QueuePropID;
    QueueProps.aPropVar = &QueuePropVar;
    QueueProps.aStatus = NULL;

    ULONG cNames = 0;

    for( ULONG i=0; i < MgmtPropVar.calpwstr.cElems; i++ )
    {
        WString wsQueueName;

        LPWSTR wszPathname = MgmtPropVar.calpwstr.pElems[i];

        hr = NormalizeQueueName( m_Api, wszPathname, wsQueueName );

        if ( FAILED(hr) )
        {
            return MqResToWmiRes( hr );
        }

        hr = CALLFUNC(MQGetQueueProperties)( wsQueueName, &QueueProps );

        if ( FAILED(hr) )
        {
            continue;
        }

        if ( guidType == guidTypeFilter )
        {       
            DWORD dwSize = (wcslen(wszPathname)+1)*sizeof(WCHAR);
            
            awszNames[cNames] = (LPWSTR)CoTaskMemAlloc( dwSize );

            if ( awszNames[cNames] == NULL )
            {
                hr = WBEM_E_OUT_OF_MEMORY;
                break;
            }

            wcscpy( awszNames[cNames], wszPathname );
            cNames++;
        }
    }

    if ( FAILED(hr) )
    {
        for( i=0; i < cNames; i++ )
        {
            CoTaskMemFree( awszNames[i] );
        }
        CoTaskMemFree( awszNames );
    }

    CALLFUNC(MQFreeMemory)( MgmtPropVar.calpwstr.pElems );

    *ppwszNames = awszNames;
    *pcNames = cNames;

    return hr;

    EXIT_API_CALL
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\multsend.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __MULTSEND_H__
#define __MULTSEND_H__

#include <sync.h>
#include <unk.h>
#include <comutl.h>
#include <wmimsg.h>

class CMsgMultiSendReceive 
: public CUnkBase<IWmiMessageMultiSendReceive,&IID_IWmiMessageMultiSendReceive>
{
    struct SenderNode
    {
        SenderNode* m_pNext;
        CWbemPtr<IWmiMessageSendReceive> m_pVal;
        BOOL m_bTermSender;

    }* m_pTail; // tail can move as we send.

    SenderNode* m_pPrimary; // always points to the first one added.

    CCritSec m_cs;

public:

    CMsgMultiSendReceive( CLifeControl* pCtl )
      : CUnkBase< IWmiMessageMultiSendReceive,
                  &IID_IWmiMessageMultiSendReceive >(pCtl), 
       m_pTail( NULL ), m_pPrimary( NULL )
    { 
    }

    ~CMsgMultiSendReceive();

    STDMETHOD(Add)( DWORD dwFlags, 
                    IWmiMessageSendReceive* pSndRcv );
    
    STDMETHOD(SendReceive)( PBYTE pData, 
                            ULONG cData, 
                            PBYTE pAuxData,
                            ULONG cAuxData,
                            DWORD dwFlagsStatus,
                            IUnknown* pCtx );
};

#endif // __MULTSEND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\msmqsend.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __MSMQSEND_H__
#define __MSMQSEND_H__

#include <unk.h>
#include <comutl.h>
#include <wstring.h>
#include <sync.h>
#include <wmimsg.h>
#include <msgsig.h>
#include "msmqcomn.h"

/**************************************************************************
  CMsgMsmqSender
***************************************************************************/

class CMsgMsmqSender 
: public CUnkBase<IWmiMessageSender,&IID_IWmiMessageSender>
{
public:

    STDMETHOD(Open)( LPCWSTR wszTarget, 
                     DWORD dwFlags,
                     WMIMSG_SNDR_AUTH_INFOP pAuthInfo,
                     LPCWSTR wszResponse,
                     IWmiMessageTraceSink* pTraceSink,
                     IWmiMessageSendReceive** ppSend );

    CMsgMsmqSender( CLifeControl* pCtl )
    : CUnkBase<IWmiMessageSender,&IID_IWmiMessageSender>( pCtl ) { }
};

/**************************************************************************
  CMsgMsmqSend
***************************************************************************/

class CMsgMsmqSend 
: public CUnkBase<IWmiMessageSendReceive, &IID_IWmiMessageSendReceive>
{
    CCritSec m_cs;
    CMsmqApi m_Api;
    QUEUEHANDLE m_hQueue;
    WString m_wsTarget;
    WString m_wsResponse;
    WString m_wsComputer;
    DWORD m_dwFlags;
    BOOL m_bInit;
    HANDLE m_hSecCtx;
    CWbemPtr<CSignMessage> m_pSign; 
    CWbemPtr<IWmiMessageTraceSink> m_pTraceSink;

    void Clear();

    HRESULT HandleTrace( HRESULT hRes, IUnknown* pContext );

    HRESULT Send( PBYTE pData, 
                  ULONG cData, 
                  PBYTE pAuxData,
                  ULONG cAuxData,
                  DWORD dwFlagStatus,
                  IUnknown* pContext );
    
public: 

    CMsgMsmqSend( CLifeControl* pCtl, 
                  LPCWSTR wszTarget,
                  DWORD dwFlags,
                  LPCWSTR wszResponse,
                  IWmiMessageTraceSink* pTraceSink );

    virtual ~CMsgMsmqSend();

    HRESULT EnsureSender();

    STDMETHOD(SendReceive)( PBYTE pData, 
                            ULONG cData, 
                            PBYTE pAuxData,
                            ULONG cAuxData,
                            DWORD dwFlagStatus,
                            IUnknown* pContext );
};

#endif // __MSMQSEND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\rpcctx.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __RPCCTX_H__
#define __RPCCTX_H__

#include <wmimsg.h>
#include <comutl.h>
#include "rpchdr.h"

/*************************************************************************
  CMsgRpcRcvrCtx
**************************************************************************/

class CMsgRpcRcvrCtx : public IWmiMessageReceiverContext
{
    CMsgRpcHdr* m_pHdr;
    RPC_BINDING_HANDLE m_hClient;

public:

    CMsgRpcRcvrCtx( CMsgRpcHdr* pHdr, RPC_BINDING_HANDLE hClient )
    : m_pHdr(pHdr), m_hClient(hClient) {}

    STDMETHOD_(ULONG,AddRef)() { return 1; }
    STDMETHOD_(ULONG,Release)() { return 1; }
    STDMETHOD(QueryInterface)( REFIID riid, void** ppv )
    {
        if ( riid == IID_IUnknown || riid == IID_IWmiMessageReceiverContext )
        {
            *ppv = (IWmiMessageReceiverContext*)this;
            return S_OK;
        }
        return E_NOINTERFACE;
    }

    STDMETHOD(GetTimeSent)( SYSTEMTIME* pTime );

    STDMETHOD(GetSendingMachine)( WCHAR* awchMachine, 
                                  ULONG cMachine,
                                  ULONG* pcMachine );

    STDMETHOD(GetTarget)( WCHAR* awchTarget, 
                          ULONG cTarget,
                          ULONG* pcTarget );

    STDMETHOD(GetSenderId)( PBYTE achSenderId, 
                            ULONG cSenderId,
                            ULONG* pcSenderId );

    STDMETHOD(IsSenderAuthenticated)();
    STDMETHOD(ImpersonateSender)();
    STDMETHOD(RevertToSelf)();
};

#endif // __RPCCTX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\precomp.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#undef _CRTIMP
#define _CRTIMP
#include <yvals.h>
#undef _CRTIMP
#define _CRTIMP __declspec(dllimport)

#include <ole2.h>
#include <windows.h>
#include <wincrypt.h>
#include <transact.h>
#include <mq.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\multsend.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <assert.h>
#include "multsend.h"

/*****************************************************************
  CMsgMultiSendReceive - Implements the list of senders using a circular
  list.  This allows us to easily advance the current sender when 
  encountering failures.  MultiSendReceive remembers the last good sender.
  It will keep using this until it has a problem with it. 
******************************************************************/

CMsgMultiSendReceive::~CMsgMultiSendReceive()
{
    if ( m_pTail == NULL )
    {
        return;
    }

    SenderNode* pCurr = m_pTail->m_pNext;

    while( pCurr != m_pTail )
    {
        SenderNode* pTmp = pCurr->m_pNext;
        delete pCurr;
        pCurr = pTmp;
    }

    delete m_pTail;
}

//
// Later, we could support flags that tell us where to add the sender.
// for now, we always add to the end of the list.
//
HRESULT CMsgMultiSendReceive::Add( DWORD dwFlags, 
                                   IWmiMessageSendReceive* pSndRcv) 
{
    ENTER_API_CALL

    HRESULT hr;

    SenderNode* pNew = new SenderNode;

    if ( pNew == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    pNew->m_pVal = pSndRcv;
    
    CInCritSec ics(&m_cs);
    
    if ( m_pTail != NULL )
    {
        pNew->m_pNext = m_pTail->m_pNext;
        m_pTail->m_pNext = pNew;
    }
    else
    { 
        m_pPrimary = pNew;
        pNew->m_pNext = pNew;      
    }

    //
    // if the sender is also a multi sender, we handle things differently 
    // in the send logic.
    //
    if ( dwFlags & WMIMSG_FLAG_MULTISEND_TERMINATING_SENDER )
    {
        pNew->m_bTermSender = TRUE;
    }
    else
    {
        pNew->m_bTermSender = FALSE;
    }

    m_pTail = pNew;

    return S_OK;

    EXIT_API_CALL
}


//
// returns S_FALSE when succeeded but primary is not used.
//
HRESULT CMsgMultiSendReceive::SendReceive( PBYTE pData, 
                                           ULONG cData, 
                                           PBYTE pAuxData,
                                           ULONG cAuxData,
                                           DWORD dwFlags,
                                           IUnknown* pCtx )
{
    ENTER_API_CALL

    HRESULT hr;

    CInCritSec ics( &m_cs );

    if ( m_pTail == NULL )
    {
        return S_OK;
    }

    HRESULT hrReturn = S_OK;

    SenderNode* pCurr = m_pTail;
    SenderNode* pTerm = m_pTail;

    do 
    {
        pCurr = pCurr->m_pNext;

        hr = pCurr->m_pVal->SendReceive( pData, 
                                         cData, 
                                         pAuxData, 
                                         cAuxData, 
                                         dwFlags, 
                                         pCtx );

        //
        // on error we only observe the 'return immediately' flag if we are not
        // calling another multi sender.  This allows all the terminal primary
        // senders to be tried first, before resorting to alternates.  
        //

        if( SUCCEEDED(hr) || 
            pCurr->m_bTermSender && 
            dwFlags & WMIMSG_FLAG_MULTISEND_RETURN_IMMEDIATELY ) 
        {
            hrReturn = hr;
            break;
        }
        else
        {
            m_pTail = m_pTail->m_pNext;
            hrReturn = hr;
        }

    } while( pCurr != pTerm );

    if ( hrReturn != S_OK )
    {
        return hrReturn;
    }

    return m_pTail->m_pNext == m_pPrimary ? S_OK : S_FALSE;

    EXIT_API_CALL
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\objacces.cpp ===
#include "precomp.h"
#include <wbemutil.h>
#include "objacces.h"

/****************************************************************************
  CPropAccessor
*****************************************************************************/

HRESULT CPropAccessor::GetParentObject( ObjectArray& raObjects,
                                        _IWmiObject** ppParent )
{
    HRESULT hr = WBEM_S_NO_ERROR;
 
    *ppParent = NULL;

    if ( m_pParent == NULL )
    {
        _DBG_ASSERT( raObjects.size() > 0 );
        *ppParent = raObjects[0];
        (*ppParent)->AddRef();
    }
    else
    {
        CPropVar vParent;
        
        hr = m_pParent->GetProp( raObjects, 0, &vParent, NULL );

        if ( SUCCEEDED(hr) )
        {
            _DBG_ASSERT( V_VT(&vParent) == VT_UNKNOWN );

            hr = V_UNKNOWN(&vParent)->QueryInterface( IID__IWmiObject,                                                               (void**)ppParent );
        }
    }

    return hr;
}

/****************************************************************************
  CFastPropAccessor
*****************************************************************************/

HRESULT CFastPropAccessor::GetProp( ObjectArray& raObjects,
                                    DWORD dwFlags, 
                                    VARIANT* pvar, 
                                    CIMTYPE* pct )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( pvar != NULL )
    {
        CWbemPtr<_IWmiObject> pParent;

        hr = GetParentObject( raObjects, &pParent );
        
        if ( SUCCEEDED(hr) )
        {
            hr = ReadValue( pParent, pvar );
        }
    }
    
    if ( pct != NULL )
    {
        *pct = m_ct;
    }

    return hr;
}

HRESULT CFastPropAccessor::PutProp( ObjectArray& raObjects,
                                    DWORD dwFlags, 
                                    VARIANT* pvar, 
                                    CIMTYPE ct )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( pvar != NULL )
    {
        CWbemPtr<_IWmiObject> pParent;

        hr = GetParentObject( raObjects, &pParent );
        
        if ( SUCCEEDED(hr) )
        {
            hr = WriteValue( pParent, pvar );
        }
    }

    return hr;
}

/****************************************************************************
  CStringPropAccessor
*****************************************************************************/

HRESULT CStringPropAccessor::ReadValue( _IWmiObject* pObj, VARIANT* pvar )
{
    HRESULT hr;
    
    long cBuff;

    hr = pObj->ReadPropertyValue( m_lHandle, 0, &cBuff, NULL );

    if ( hr == WBEM_E_BUFFER_TOO_SMALL )
    {
        BSTR bstr = SysAllocStringByteLen( NULL, cBuff );

        if ( bstr != NULL )
        {
            hr = pObj->ReadPropertyValue( m_lHandle, 
                                          cBuff, 
                                          &cBuff, 
                                          PBYTE(bstr) );
            if ( SUCCEEDED(hr) )
            {
                V_VT(pvar) = VT_BSTR;
                V_BSTR(pvar) = bstr;
            }
            else
            {
                SysFreeString( bstr );
            }
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }
    else if ( SUCCEEDED(hr) )
    {
        V_VT(pvar) = VT_NULL;
    }

    return hr;
}

HRESULT CStringPropAccessor::WriteValue( _IWmiObject* pObj, VARIANT* pvar )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    if ( V_VT(pvar) == VT_BSTR )
    {
        ULONG cLen = wcslen( V_BSTR(pvar) );
        hr = pObj->WritePropertyValue( m_lHandle, 
                                       cLen*2+2, 
                                       PBYTE(V_BSTR(pvar)) );  
    }
    else if ( V_VT(pvar) == VT_NULL )
    {
        //
        // how do we handle NULL ?? 
        //
    }
    else
    {
        hr = WBEM_E_TYPE_MISMATCH;
    }

    return hr;
}

/****************************************************************************
  CSimplePropAccessor
*****************************************************************************/

HRESULT CSimplePropAccessor::GetProp( ObjectArray& raObjects,
                                      DWORD dwFlags, 
                                      VARIANT* pvar, 
                                      CIMTYPE* pct )
{
    HRESULT hr;

    if ( m_pDelegateTo == NULL )
    {        
        CWbemPtr<_IWmiObject> pParent;

        hr = GetParentObject( raObjects, &pParent );

        if ( SUCCEEDED(hr) )
        {
            hr = pParent->Get( m_wsName, 0, pvar, pct, NULL );
        }
    }
    else
    {
        hr = m_pDelegateTo->GetProp( raObjects, dwFlags, pvar, pct );
    }

    return hr;
}
                                     
HRESULT CSimplePropAccessor::PutProp( ObjectArray& raObjects,
                                      DWORD dwFlags, 
                                      VARIANT* pvar, 
                                      CIMTYPE ct )
{
    HRESULT hr;

    if ( m_pDelegateTo == NULL )
    {
        CWbemPtr<_IWmiObject> pParent;

        hr = GetParentObject( raObjects, &pParent );

        if ( SUCCEEDED(hr) )
        {
            hr = pParent->Put( m_wsName, 0, pvar, ct );
        }
    }
    else
    {
        hr = m_pDelegateTo->PutProp( raObjects, dwFlags, pvar, ct );
    }

    return hr;
}

/****************************************************************************
  CEmbeddedPropAccessor
*****************************************************************************/

HRESULT CEmbeddedPropAccessor::GetProp( ObjectArray& raObjects,
                                        DWORD dwFlags, 
                                        VARIANT* pvar, 
                                        CIMTYPE* pct )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    VariantInit( pvar );

    if ( raObjects.size() <= m_lObjIndex )
    {
        raObjects.resize( m_lObjIndex*2 );
    }

    _IWmiObjectP pObj = raObjects[m_lObjIndex];
 
    if ( pObj != NULL )
    {
        V_VT(pvar) = VT_UNKNOWN;
        V_UNKNOWN(pvar) = pObj;
        pObj->AddRef();
    }
    else
    {
        _IWmiObjectP pParent;

        hr = GetParentObject( raObjects, &pParent );

        if ( SUCCEEDED(hr) )
        {
            CPropVar vProp;

            hr = pParent->Get( m_wsName, 0, &vProp, pct, NULL );

            if ( SUCCEEDED(hr) )
            {
                if ( V_VT(&vProp) == VT_UNKNOWN )
                {
                    hr = V_UNKNOWN(&vProp)->QueryInterface( IID__IWmiObject,
                                                            (void**)&pObj );
                    if ( SUCCEEDED(hr) )
                    {
                        raObjects[m_lObjIndex] = pObj;
                        V_VT(pvar) = VT_UNKNOWN;
                        V_UNKNOWN(pvar) = pObj;
                        pObj->AddRef();
                    }
                }
                else if ( V_VT(&vProp) == VT_NULL )
                {
                    hr = WBEM_E_NOT_FOUND;
                }
                else
                {
                    hr = WBEM_E_TYPE_MISMATCH;
                }
            }
        }
    }

    return hr;
}
                                     
HRESULT CEmbeddedPropAccessor::PutProp( ObjectArray& raObjects,
                                        DWORD dwFlags, 
                                        VARIANT* pvar, 
                                        CIMTYPE ct )
{
    HRESULT hr;

    if ( raObjects.size() <= m_lObjIndex )
    {
        raObjects.resize( m_lObjIndex*2 );
    }

    _IWmiObjectP pParent;

    hr = GetParentObject( raObjects, &pParent );

    if ( SUCCEEDED(hr) )
    {
        hr = pParent->Put( m_wsName, 0, pvar, ct );
        
        if ( SUCCEEDED(hr) )
        {
            _IWmiObjectP pObj;

            if ( V_VT(pvar) == VT_UNKNOWN )
            {
                hr = V_UNKNOWN(pvar)->QueryInterface( IID__IWmiObject, 
                                                      (void**)&pObj );
            }

            if ( SUCCEEDED(hr) )
            {
                raObjects[m_lObjIndex] = pObj;
            }
        } 
    }

    return hr;
}

/****************************************************************************
  CObjectAccessFactory - impl for IWmiObjectAccessFactory
*****************************************************************************/

STDMETHODIMP CObjectAccessFactory::SetObjectTemplate( IWbemClassObject* pTmpl )
{
    HRESULT hr;

    if ( m_pTemplate == NULL )
    {
        hr = pTmpl->QueryInterface( IID__IWmiObject, (void**)&m_pTemplate );
    }
    else
    {
        hr = WBEM_E_INVALID_OPERATION;
    }

    return hr;
}

STDMETHODIMP CObjectAccessFactory::GetObjectAccess(IWmiObjectAccess** ppAccess)
{
    HRESULT hr = WBEM_S_NO_ERROR;
    
    *ppAccess = new CObjectAccess( m_pControl );

    if ( *ppAccess != NULL )
    {
        (*ppAccess)->AddRef();
    }
    else
    {
        hr = WBEM_E_OUT_OF_MEMORY;
    }

    return hr;
}

HRESULT CObjectAccessFactory::FindOrCreateAccessor( LPCWSTR wszPropElem,
                                                    BOOL bEmbedded,
                                                    CPropAccessor* pParent, 
                                                    CPropAccessor** ppAccessor)
{
    HRESULT hr = WBEM_S_NO_ERROR;

    *ppAccessor = NULL;

    //
    // determine the map the use for the prop accessors.  
    // 

    PropAccessMap* pmapPropAccess;

    if ( pParent != NULL )
    {
        _DBG_ASSERT( pParent->GetType() == CPropAccessor::e_Embedded ); 
        pmapPropAccess = &((CEmbeddedPropAccessor*)pParent)->m_mapPropAccess;
    }
    else
    {
        pmapPropAccess = &m_mapPropAccess;
    }

    //
    // see if an accessor already exists.  If not create one.
    //

    PropAccessMap::iterator it = pmapPropAccess->find( wszPropElem );

    //
    // if we're untyped and the accessor is also a Simple 
    // accessor, but now we know it to be embedded, convert the
    // accessor to an embedded one.
    // 

    if ( it != pmapPropAccess->end() && 
         !( bEmbedded && it->second->GetType() == CPropAccessor::e_Simple ) )
    {
        *ppAccessor = it->second;
        (*ppAccessor)->AddRef();
    }
    else
    {
        long lHandle = -1;
        CIMTYPE cimtype = 0;

        if ( m_pTemplate != NULL )
        {
            //
            // get type information from the template. Also get handle
            // if possible. For now, we don't do anything special for 
            // properties that are embedded.
            //
            
            if ( !bEmbedded )
            {
                hr = m_pTemplate->GetPropertyHandle( wszPropElem,
                                                     &cimtype,
                                                     &lHandle );
                if ( SUCCEEDED(hr) )
                {
                    ;
                }
                else
                {
                    cimtype = -1;
                    hr = WBEM_S_NO_ERROR;
                }
            }
        }

        CWbemPtr<CPropAccessor> pAccessor;
        
        if ( SUCCEEDED(hr) )
        {
            if ( bEmbedded )
            {
                pAccessor = new CEmbeddedPropAccessor( wszPropElem, 
                                                       m_lIndexGenerator++, 
                                                       pParent );
            }
            else if ( m_pTemplate != NULL && lHandle != -1 && cimtype == CIM_STRING )
            {
                pAccessor = new CStringPropAccessor( lHandle, cimtype, pParent );
            }
            else
            {
                pAccessor = new CSimplePropAccessor( wszPropElem, pParent );
            }
        }

        //
        // add to the map. If an entry does exists already, then have it 
        // delegate to our new one. The new entry becomes responsible for 
        // the original one to keep it alive.
        //
                
        if ( pAccessor != NULL )
        {
            if ( it != pmapPropAccess->end() )
            {
                pAccessor->AssumeOwnership( it->second );
                it->second->DelegateTo( pAccessor );
            }

            (*pmapPropAccess)[wszPropElem] = pAccessor;
            pAccessor->AddRef();
            *ppAccessor = pAccessor;
        }
        else
        {
            hr = WBEM_E_OUT_OF_MEMORY;
        }
    }

    return hr;
}

STDMETHODIMP CObjectAccessFactory::GetPropHandle( LPCWSTR wszProp, 
                                                  DWORD dwFlags, 
                                                  LPVOID* ppHdl )
{
    HRESULT hr;

    ENTER_API_CALL

    WString wsProp( wszProp );

    LPWSTR wszPropElem = wcstok( wsProp, L"." );
    
    CWbemPtr<CPropAccessor> pAccessor;
    CWbemPtr<CPropAccessor> pParentAccessor;

    do
    {
        LPWSTR wszNextPropElem = wcstok( NULL, L"." );
    
        pAccessor.Release();

        hr = FindOrCreateAccessor( wszPropElem, 
                                   wszNextPropElem != NULL, 
                                   pParentAccessor, 
                                   &pAccessor );

        pParentAccessor = pAccessor;
        wszPropElem = wszNextPropElem;

    } while( SUCCEEDED(hr) && wszPropElem != NULL );

    if ( SUCCEEDED(hr) )
    {
        *ppHdl = pAccessor;
    }
    else
    {
        *ppHdl = NULL;
    }

    EXIT_API_CALL

    return hr;
}

/***************************************************************************
  CObjectAccess
****************************************************************************/

STDMETHODIMP CObjectAccess::CommitChanges()
{
    HRESULT hr = WBEM_S_NO_ERROR;

    ENTER_API_CALL

    //
    // commit our embeddeded objects.  Since the set of embedded object 
    // accessors is ordered by level, we will do things in the right order.
    //

    EmbeddedPropAccessSet::iterator it;

    for( it = m_setEmbeddedAccessorsToCommit.begin(); 
         it != m_setEmbeddedAccessorsToCommit.end(); it++ )
    {
        CEmbeddedPropAccessor* pAccessor = *it;

        IWbemClassObject* pProp = m_aObjects[pAccessor->GetObjectIndex()];
        _DBG_ASSERT( pProp != NULL );

        VARIANT vProp;
        V_VT(&vProp) = VT_UNKNOWN;
        V_UNKNOWN(&vProp) = pProp;

        hr = pAccessor->PutProp( m_aObjects, 0, &vProp, CIM_OBJECT );

        if ( SUCCEEDED(hr) )
        {
            ;
        }
        else
        {
            break;
        }
    }

    EXIT_API_CALL

    return hr;
}

STDMETHODIMP CObjectAccess::GetObject( IWbemClassObject** ppObj )
{
    HRESULT hr;

    if ( m_aObjects.size() > 0 && m_aObjects[0] != NULL )
    {
        m_aObjects[0]->AddRef();
        *ppObj = m_aObjects[0];
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        *ppObj = NULL;
        hr = WBEM_S_FALSE;
    }
    
    return hr;
}

STDMETHODIMP CObjectAccess::SetObject( IWbemClassObject* pObj )
{
    HRESULT hr = WBEM_S_NO_ERROR;

    ENTER_API_CALL

    m_aObjects.clear();    
    m_setEmbeddedAccessorsToCommit.clear();

    if ( pObj != NULL )
    {
        CWbemPtr<_IWmiObject> pIntObj;

        hr = pObj->QueryInterface( IID__IWmiObject, (void**)&pIntObj );

        if ( SUCCEEDED(hr) )
        {
            m_aObjects.insert( m_aObjects.end(), pIntObj );
        }
    }

    EXIT_API_CALL

    return hr;
}
    
STDMETHODIMP CObjectAccess::GetProp( LPVOID pHdl, 
                                     DWORD dwFlags,
                                     VARIANT* pvar, 
                                     CIMTYPE* pct )
{
    HRESULT hr;

    ENTER_API_CALL

    if ( m_aObjects.size() > 0 )
    {
        hr = ((CPropAccessor*)pHdl)->GetProp( m_aObjects, dwFlags, pvar, pct );
    }
    else
    {
        hr = WBEM_E_INVALID_OPERATION;
    }

    EXIT_API_CALL

    return hr;
}

STDMETHODIMP CObjectAccess::PutProp( LPVOID pHdl, 
                                     DWORD dwFlags, 
                                     VARIANT* pvar,
                                     CIMTYPE ct )
{
    HRESULT hr;

    ENTER_API_CALL

    if ( m_aObjects.size() > 0 )
    {
        CPropAccessor* pAccessor = (CPropAccessor*)pHdl;

        CEmbeddedPropAccessor* pParent = 
              (CEmbeddedPropAccessor*)pAccessor->GetParent();

        hr = pAccessor->PutProp( m_aObjects, dwFlags, pvar, ct );
                                           
        if ( SUCCEEDED(hr) )
        {
            //
            // if there is an 
            if ( pParent == NULL )
            {
                ;
            }
            else
            {
                m_setEmbeddedAccessorsToCommit.insert( pParent );
            }
        }
    }
    else
    {
        hr = WBEM_E_INVALID_OPERATION;
    }

    EXIT_API_CALL

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\objacces.h ===
#ifndef __OBJACCES_H__
#define __OBJACCES_H__

#include <wbemint.h>
#include <wstring.h>
#include <comutl.h>
#include <arrtempl.h>
#include <unk.h>
#include <map>
#include <vector>
#include <set>
#include <wstlallc.h>
#include "wmimsg.h"

typedef CWbemPtr<_IWmiObject> _IWmiObjectP;
typedef std::vector< _IWmiObjectP, wbem_allocator<_IWmiObjectP> > ObjectArray;

/****************************************************************************
  CPropAccessor - base class for all prop accessors.  Property Accessors are 
  passed back from the GetPropHandle() method of IWmiObjectAccessFactory.
*****************************************************************************/

class CPropAccessor : public CUnk
{

protected:

    //
    // if the object we're accessing is not a top level object, then we'll
    // have a parent accessor to get it.  Cannot hold reference here, 
    // because in some cases the parent may hold a reference on the child and
    // we'd have a circular reference.  It will not be possible though for a 
    // parent to be deleted out from the child.
    // 
    CPropAccessor* m_pParent;

    //
    // Accessor to delegate to.  Sometimes, once a prop accessor is 
    // handed out, we learn more about the property ( e.g. its type )
    // and it would be beneficial to have the original accessor delegate 
    // to a more efficient one.  we don't hold a reference here because 
    // the delegate will assume ownership of this object and will hold 
    // a reference on it.  Holding a reference to the delegate would cause
    // a circular reference.
    //
    CPropAccessor* m_pDelegateTo;

    //
    // whenever a prop accessor is replaced by a more efficient one, it 
    // is removed from the map.  Since the map holds onto the ref that 
    // keeps the accessor alive, we need to the new accessor be responsible
    // for cleaning up the original one.  The original one is potentially
    // still being used by the client ( but now delegates to the new accessor )
    // ane we have to keep it alive for the lifetime of the access factory.
    //
    CWbemPtr<CPropAccessor> m_pResponsibleFor;
 
    //
    // level of the property - 0 means its a property on a top level object.
    //
    int m_nLevel;

    HRESULT GetParentObject( ObjectArray& raObjects, _IWmiObject** ppParent );
   
    void* GetInterface( REFIID ) { return NULL; }

public:

    CPropAccessor( CPropAccessor* pParent ) 
    : m_pParent( pParent ), m_pDelegateTo( NULL )
    { 
        if ( pParent == NULL )
            m_nLevel = 0;
        else
            m_nLevel = pParent->GetLevel() + 1;
    }

    int GetLevel() const { return m_nLevel; }
    CPropAccessor* GetParent() { return m_pParent; } 

    enum AccessorType_e { e_Simple, e_Fast, e_Embedded };

    virtual ~CPropAccessor() {} 

    virtual HRESULT GetProp( ObjectArray& raObjects,
			     DWORD dwFlags, 
			     VARIANT* pvar, 
			     CIMTYPE* pct ) = 0;

    virtual HRESULT PutProp( ObjectArray& raObjects,
			     DWORD dwFlags, 
			     VARIANT* pvar,
                             CIMTYPE ct ) = 0;

    virtual AccessorType_e GetType() = 0;

    void AssumeOwnership( CPropAccessor* pAccessor )
    {
        m_pResponsibleFor = pAccessor;
    }

    void DelegateTo( CPropAccessor* pAccessor ) 
    { 
        m_pDelegateTo = pAccessor; 
    }
};

typedef CWbemPtr<CPropAccessor> CPropAccessorP;

typedef std::map< WString, 
                  CPropAccessorP, 
                  WSiless, 
                  wbem_allocator<CPropAccessorP> > PropAccessMap;

/*****************************************************************************
  CEmbeddedPropAccessor - accessor for an embedded object property.
  This impl caches the embedded object that is accessed to optimize 
  subsequent accesses.
******************************************************************************/

class CEmbeddedPropAccessor : public CPropAccessor
{
    //
    // name of the embedded object property.
    //
    WString m_wsName;
    
    //
    // the index in the object array where the embedded obj will be cached 
    // when accessed for the first time.
    //
    long m_lObjIndex;

    //
    // child accessors for the embedded object.
    //
    PropAccessMap m_mapPropAccess;

    friend class CObjectAccessFactory;

public:

    CEmbeddedPropAccessor( LPCWSTR wszName, 
                           long lObjIndex,
                           CPropAccessor* pParent = NULL )
    : CPropAccessor( pParent ), m_wsName( wszName ), m_lObjIndex( lObjIndex )
    {
    } 

    HRESULT GetProp( ObjectArray& raObjects,
		     DWORD dwFlags, 
		     VARIANT* pvar, 
		     CIMTYPE* pct );

    HRESULT PutProp( ObjectArray& raObjects, 
		     DWORD dwFlags, 
		     VARIANT* pvar,
                     CIMTYPE ct );

    AccessorType_e GetType() { return e_Embedded; }

    int GetObjectIndex() { return m_lObjIndex; }
};

/*****************************************************************************
  CSimplePropAccessor - simple accessor for non-embedded object properties. 
******************************************************************************/

class CSimplePropAccessor : public CPropAccessor
{
    //
    // name of the embedded object property.
    //
    WString m_wsName;

public:

    CSimplePropAccessor( LPCWSTR wszName, CPropAccessor* pParent = NULL )
    : CPropAccessor( pParent ), m_wsName( wszName ) { }

    HRESULT GetProp( ObjectArray& raObjects,
		     DWORD dwFlags, 
		     VARIANT* pvar, 
		     CIMTYPE* pct );

    HRESULT PutProp( ObjectArray& raObjects,
		     DWORD dwFlags, 
                     VARIANT* pvar, 
                     CIMTYPE ct ); 

    AccessorType_e GetType() { return e_Simple; }
};

/*****************************************************************************
  CFastPropAccessor - fast accessor base for non-embedded object properties. 
  Is used when the type of the property is known at property handle creation.
******************************************************************************/

class CFastPropAccessor : public CPropAccessor
{
protected:

    long m_lHandle;
    CIMTYPE m_ct;

public:

    CFastPropAccessor( long lHandle, CIMTYPE ct, CPropAccessor* pParent=NULL )
    : CPropAccessor( pParent ), m_lHandle( lHandle ), m_ct( ct ) { }

    HRESULT GetProp( ObjectArray& raObjects,
		     DWORD dwFlags, 
		     VARIANT* pvar, 
		     CIMTYPE* pct );

    HRESULT PutProp( ObjectArray& raObjects,
		     DWORD dwFlags, 
                     VARIANT* pvar, 
                     CIMTYPE ct ); 

    AccessorType_e GetType() { return e_Fast; }

    virtual HRESULT ReadValue( _IWmiObject* pObj, VARIANT* pvar ) = 0;
    virtual HRESULT WriteValue( _IWmiObject* pObj, VARIANT* pvar ) = 0;
};

/*****************************************************************************
  CStringPropAccessor
******************************************************************************/

class CStringPropAccessor : public CFastPropAccessor
{
public:

    CStringPropAccessor( long lHandle, CIMTYPE ct, CPropAccessor* pParent=NULL)
    : CFastPropAccessor( lHandle, ct, pParent ) { }

    HRESULT ReadValue( _IWmiObject* pObj, VARIANT* pvar );
    HRESULT WriteValue( _IWmiObject* pObj, VARIANT* pvar );
};

/****************************************************************************
  CObjectAccessFactory - impl for IWmiObjectAccessFactory
*****************************************************************************/

class CObjectAccessFactory 
: public CUnkBase<IWmiObjectAccessFactory, &IID_IWmiObjectAccessFactory>
{
    _IWmiObjectP m_pTemplate;
    PropAccessMap m_mapPropAccess;
    long m_lIndexGenerator;

    HRESULT FindOrCreateAccessor( LPCWSTR wszPropElem,
                                  BOOL bEmbedded,
                                  CPropAccessor* pParent, 
                                  CPropAccessor** ppAccessor );
public:

    CObjectAccessFactory( CLifeControl* pControl ) 
    : CUnkBase<IWmiObjectAccessFactory,&IID_IWmiObjectAccessFactory>(pControl),
      m_lIndexGenerator(1)
    {
    } 

    STDMETHOD(SetObjectTemplate)( IWbemClassObject* pTemplate );
    STDMETHOD(GetObjectAccess)( IWmiObjectAccess** ppAccess );
    STDMETHOD(GetPropHandle)( LPCWSTR wszProp, DWORD dwFlags, LPVOID* ppHdl );
};

/****************************************************************************
  CObjectAccess - impl for IWmiObjectAccess.
*****************************************************************************/

class CObjectAccess : public CUnkBase<IWmiObjectAccess,&IID_IWmiObjectAccess>
{
    ObjectArray m_aObjects;

    class CEmbeddedPropAccessorCompare
    {
    public:
        bool operator() ( const CEmbeddedPropAccessor* pA,
                          const CEmbeddedPropAccessor* pB ) const
        {
            bool bRet;    
            if ( !(pA == pB) )
                if ( pA->GetLevel() == pB->GetLevel() )
                    bRet = pA < pB;
                else
                    bRet = pA->GetLevel() > pB->GetLevel();
            else
                bRet = FALSE; 
            return bRet;
        }
    };
 
    typedef std::set< CEmbeddedPropAccessor*, 
            CEmbeddedPropAccessorCompare, 
            wbem_allocator<CEmbeddedPropAccessor*> > EmbeddedPropAccessSet;
    
    EmbeddedPropAccessSet m_setEmbeddedAccessorsToCommit;
 
public:

    CObjectAccess( CLifeControl* pControl ) 
    : CUnkBase<IWmiObjectAccess,&IID_IWmiObjectAccess> ( pControl ) {} 

    STDMETHOD(SetObject)( IWbemClassObject* pObj );
    STDMETHOD(GetObject)( IWbemClassObject** ppObj );

    //
    // should support flags that describe what is going to be done 
    // with the value.  If it's going to be put into another object then
    // we'll give back a value which can only be used for that purpose.  More
    // efficient. e.g. we could use the get/put prop pointer methods 
    //
    STDMETHOD(GetProp)( LPVOID pHdl, 
                        DWORD dwFlags, 
                        VARIANT* pvar, 
                        CIMTYPE* pct );

    STDMETHOD(PutProp)( LPVOID pHdl, 
                        DWORD dwFlags, 
                        VARIANT* pvar,
                        CIMTYPE ct );

    STDMETHOD(CommitChanges)();
};

#endif // __OBJACCES_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\rpcctx.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include <sspi.h>
#include <secext.h>
#include <wmimsg.h>
#include <comutl.h>
#include "rpcctx.h"

HRESULT RpcResToWmiRes(  RPC_STATUS stat, HRESULT hrDefault )
{
    //
    // override the default error code here if a more specific one can be 
    // determined
    //

    switch( stat )
    {
    case EPT_S_NOT_REGISTERED :
        return WMIMSG_E_TARGETNOTLISTENING;

    case ERROR_ACCESS_DENIED :
        return WBEM_E_ACCESS_DENIED;
    };

    return hrDefault == S_OK ? HRESULT_FROM_WIN32(stat) : hrDefault;
}

/******************************************************/
/*         MIDL allocate and free                     */
/******************************************************/
 
void __RPC_FAR * __RPC_USER midl_user_allocate(size_t len)
{
    return( new BYTE[len] );
}
 
void __RPC_USER midl_user_free(void __RPC_FAR * ptr)
{
    delete [] ptr;
}

/***************************************************************************
  CMsgRpcRcvrCtx
****************************************************************************/

STDMETHODIMP CMsgRpcRcvrCtx::GetTimeSent( SYSTEMTIME* pTime )
{
    *pTime = *m_pHdr->GetTimeSent();
    return S_OK;
}

STDMETHODIMP CMsgRpcRcvrCtx::GetSendingMachine( WCHAR* awchMachine, 
                                                ULONG cMachine,
                                                ULONG* pcMachine )
{ 
    LPCWSTR wszSource = m_pHdr->GetSendingMachine();

    *pcMachine = wcslen( wszSource ) + 1;

    if ( *pcMachine > cMachine )
    {
        return S_FALSE;
    }

    wcscpy( awchMachine, wszSource );

    return S_OK;
}

STDMETHODIMP CMsgRpcRcvrCtx::GetTarget( WCHAR* awchTarget, 
                                        ULONG cTarget,
                                        ULONG* pcTarget )
{
    *pcTarget = 0;
    return WBEM_E_NOT_SUPPORTED;
}

STDMETHODIMP CMsgRpcRcvrCtx::IsSenderAuthenticated()
{
    HRESULT hr;
    DWORD dwAuthn;
    DWORD dwLevel;
    RPC_STATUS stat;

    stat = RpcBindingInqAuthClient( m_hClient,
                                    NULL,
                                    NULL,
                                    &dwLevel,
                                    &dwAuthn,
                                    NULL );
    
    if ( stat == RPC_S_OK &&
         dwAuthn != RPC_C_AUTHN_NONE && 
         dwLevel >= RPC_C_AUTHN_LEVEL_PKT_INTEGRITY )
    {
        hr = WBEM_S_NO_ERROR; 
    }
    else
    {
        hr = WBEM_S_FALSE;
    }

    return hr;
}

STDMETHODIMP CMsgRpcRcvrCtx::ImpersonateSender()
{
    HRESULT hr;
    RPC_STATUS stat = RpcImpersonateClient( m_hClient );

    if ( stat == RPC_S_OK )
    {
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        hr = RpcResToWmiRes( stat, S_OK );
    }

    return hr;
}

STDMETHODIMP CMsgRpcRcvrCtx::RevertToSelf()
{
    HRESULT hr;
    RPC_STATUS stat = RpcRevertToSelf();

    if ( stat == RPC_S_OK )
    {
        hr = WBEM_S_NO_ERROR;
    }
    else
    {
        hr = RpcResToWmiRes( stat, S_OK );
    }

    return hr;
}

STDMETHODIMP CMsgRpcRcvrCtx::GetSenderId( PBYTE pchSenderId, 
                                          ULONG cSenderId,
                                          ULONG* pcSenderId )
{
    HRESULT hr;
    RPC_STATUS stat;
  
    *pcSenderId = 0;

    stat = RpcImpersonateClient( m_hClient );

    if ( stat == RPC_S_OK )
    {
        HANDLE hToken;

        if ( OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken) )
        {
            //
            // use the passed in buffer to get the SID_AND_ATTRIBUTES
            //

            DWORD dwLen;

            if ( GetTokenInformation( hToken,
                                      TokenUser,
                                      pchSenderId,
                                      cSenderId,
                                      &dwLen ) )
            {
                //
                // move the sid to the beginning of the buffer.
                //

                PSID pSid = PSID_AND_ATTRIBUTES(pchSenderId)->Sid;
                *pcSenderId = GetLengthSid( pSid );
                memmove( pchSenderId, pSid, *pcSenderId );

                hr = WBEM_S_NO_ERROR;
            }
            else
            {
                DWORD dwRes = GetLastError();

                if ( dwRes == ERROR_MORE_DATA )
                {
                    *pcSenderId = dwLen;
                    hr = WBEM_S_FALSE;
                }
                else
                {
                    hr = WMIMSG_E_AUTHFAILURE;
                }
            }

            CloseHandle( hToken );
        }
        else
        {
            hr = WMIMSG_E_AUTHFAILURE;
        }

        RpcRevertToSelf();
    }
    else
    {
        hr = RpcResToWmiRes( stat, S_OK );
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\rpchdr.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <time.h>
#include <wmimsg.h>
#include "rpchdr.h"

const DWORD g_dwSig = 0x6d696d77;
const BYTE g_chVersionMajor = 1;
const BYTE g_chVersionMinor = 0;

/****************************************************************************
  CMsgRpcHdr
*****************************************************************************/

CMsgRpcHdr::CMsgRpcHdr( LPCWSTR wszSource, ULONG cAuxData )
: m_wszSource( wszSource ), m_cAuxData( cAuxData ) 
{
    GetSystemTime( &m_Time );
}

HRESULT CMsgRpcHdr::Unpersist( CBuffer& rStrm )
{
    HRESULT hr;

    DWORD dwSig;
    BYTE chVersionMajor, chVersionMinor;

    //
    // read and verify signature.
    //

    hr = rStrm.Read( &dwSig, sizeof(DWORD), NULL );

    if ( hr != S_OK || dwSig != g_dwSig )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read and check version major (currently no check).
    //

    hr = rStrm.Read( &chVersionMajor, 1, NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    // 
    // read and check version minor (currently no check).
    //

    hr = rStrm.Read( &chVersionMinor, 1, NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read reserved
    //

    DWORD dwReserved;

    hr = rStrm.Read( &dwReserved, sizeof(DWORD), NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }
    
    //
    // read source machine.
    //

    hr = rStrm.ReadLPWSTR( m_wszSource );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read sent time.
    //

    hr = rStrm.Read( &m_Time, sizeof(SYSTEMTIME), NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // read user header size.
    //

    hr = rStrm.Read( &m_cAuxData, sizeof(DWORD), NULL );

    if ( hr != S_OK )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }
    
    return WBEM_S_NO_ERROR;
}

HRESULT CMsgRpcHdr::Persist( CBuffer& rStrm )
{
    HRESULT hr;

    hr = rStrm.Write( &g_dwSig, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write version major.
    //

    hr = rStrm.Write( &g_chVersionMajor, 1, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    // 
    // write version minor.
    //

    hr = rStrm.Write( &g_chVersionMinor, 1, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write reserved flags ( currently not used ).
    //

    DWORD dwReserved = 0;
    
    hr = rStrm.Write( &dwReserved, sizeof(DWORD), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write source machine
    //

    hr = rStrm.WriteLPWSTR( m_wszSource );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write time sent.
    //

    hr = rStrm.Write( &m_Time, sizeof(SYSTEMTIME), NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // write user hdr size.
    //

    return rStrm.Write( &m_cAuxData, sizeof(DWORD), NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\rpcrecv.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __RPCRECV_H__
#define __RPCRECV_H__

#include <unk.h>
#include <wmimsg.h>
#include <comutl.h>
#include "rpcmsg.h"

/**************************************************************************
  CMsgRpcReceiver
***************************************************************************/

class CMsgRpcReceiver 
: public CUnkBase< IWmiMessageReceiver, &IID_IWmiMessageReceiver >
{          
public:

    CMsgRpcReceiver( CLifeControl* pCtl ) : 
     CUnkBase<IWmiMessageReceiver,&IID_IWmiMessageReceiver>( pCtl ) { }

    ~CMsgRpcReceiver() { Close(); }

    STDMETHOD(Open)( LPCWSTR wszEndpoint,
                     DWORD dwFlags,
                     WMIMSG_RCVR_AUTH_INFOP pAuthInfo,
                     IWmiMessageSendReceive* pRcv );
    
    STDMETHOD(Close)();
};


#endif // __RPCRECV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\rpcrecv.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <assert.h>
#include <wbemcli.h>
#include <wbemutil.h>
#include <arrtempl.h>
#include "rpcrecv.h"
#include "rpcmsg.h"
#include "rpchdr.h"
#include "rpcctx.h"

extern HRESULT RpcResToWmiRes(  RPC_STATUS stat, HRESULT hrDefault );

IWmiMessageSendReceive* g_pRcv = NULL;
PSECURITY_DESCRIPTOR g_pSD = NULL;

RPC_STATUS RPC_ENTRY RpcAuthCallback( RPC_IF_HANDLE Interface, void *Context )
{
    RPC_STATUS stat;

    _DBG_ASSERT( g_pSD != NULL );

    stat = RpcImpersonateClient( Context );

    if ( stat == RPC_S_OK )
    {
        HANDLE hToken;

        if( OpenThreadToken( GetCurrentThread(), TOKEN_QUERY, TRUE, &hToken ) )
        {
            GENERIC_MAPPING map;
            ZeroMemory( &map, sizeof(GENERIC_MAPPING) );
            PRIVILEGE_SET ps;
            DWORD dwPrivLength = sizeof(ps);
            BOOL bStatus;
            DWORD dwGranted;

            if ( ::AccessCheck( g_pSD, 
                                hToken,
                                1,
                                &map, 
                                &ps,
                                &dwPrivLength, 
                                &dwGranted, 
                                &bStatus ) )
            {
                stat = bStatus ? RPC_S_OK : RPC_S_ACCESS_DENIED; 
            }
            else
            {
                stat = RPC_S_ACCESS_DENIED;
            }

            CloseHandle( hToken );
        }
        else
        {
            stat = RPC_S_ACCESS_DENIED;
        }

        RpcRevertToSelf();
    }

    return stat;
}

long RcvrSendReceive( RPC_BINDING_HANDLE hClient,
                      PBYTE pData, 
                      ULONG cData, 
                      PBYTE pAuxData, 
                      ULONG cAuxData )
{
    HRESULT hr;

    ENTER_API_CALL

    CBuffer HdrStrm( pAuxData, cAuxData, FALSE );

    CMsgRpcHdr Hdr;

    hr = Hdr.Unpersist( HdrStrm );

    if ( FAILED(hr) )
    {
        return hr;
    }

    PBYTE pUserAuxData = HdrStrm.GetRawData() + HdrStrm.GetIndex();

    CMsgRpcRcvrCtx Ctx( &Hdr, hClient );

    hr = g_pRcv->SendReceive( pData, 
                              cData, 
                              pUserAuxData, 
                              Hdr.GetAuxDataLength(), 
                              0, 
                              &Ctx );    
    EXIT_API_CALL

    return hr;
}

HRESULT CreateAuthOnlySecurityDescriptor( PSECURITY_DESCRIPTOR* ppSD )
{
    HRESULT hr;

    //
    // obtain the sid from the process token to use for owner and 
    // group fields of SD.
    //

    HANDLE hProcessToken;

    if ( !OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hProcessToken ))
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    CCloseMe cm( hProcessToken );

    DWORD dwSize;
    GetTokenInformation( hProcessToken, TokenOwner, NULL, 0, &dwSize );
    
    if ( GetLastError() != ERROR_MORE_DATA && 
         GetLastError() != ERROR_INSUFFICIENT_BUFFER )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }
        
    TOKEN_OWNER* pOwner = (TOKEN_OWNER*) new BYTE[dwSize];

    if ( pOwner == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CVectorDeleteMe<BYTE> vdm( (BYTE*)pOwner );

    if ( !GetTokenInformation( hProcessToken, 
                               TokenOwner, 
                               (BYTE*)pOwner, 
                               dwSize, 
                               &dwSize ) )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    //
    // create a DACL that allows only authenticated users access.
    //

    SID AuthenticatedUsers;
    SID_IDENTIFIER_AUTHORITY idAuth = SECURITY_NT_AUTHORITY; 
    InitializeSid( &AuthenticatedUsers, &idAuth, 1 );
    PDWORD pdwSubAuth = GetSidSubAuthority( &AuthenticatedUsers, 0 );
    *pdwSubAuth = SECURITY_AUTHENTICATED_USER_RID;
    _DBG_ASSERT( IsValidSid( &AuthenticatedUsers ) );

    dwSize = sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) - 4 +
                 GetLengthSid(&AuthenticatedUsers);
    
    PACL pAuthOnlyAcl = (PACL) new BYTE[dwSize];

    if ( pAuthOnlyAcl == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CVectorDeleteMe<BYTE> vdm2( (BYTE*)pAuthOnlyAcl );

    InitializeAcl( pAuthOnlyAcl, dwSize, ACL_REVISION );
    AddAccessAllowedAce( pAuthOnlyAcl, ACL_REVISION, 1, &AuthenticatedUsers );

    //
    // create and initialize SD
    //

    SECURITY_DESCRIPTOR AuthOnlySD;
    InitializeSecurityDescriptor( &AuthOnlySD, SECURITY_DESCRIPTOR_REVISION );

    SetSecurityDescriptorOwner( &AuthOnlySD, pOwner->Owner, TRUE );
    SetSecurityDescriptorGroup( &AuthOnlySD, pOwner->Owner, TRUE );
    SetSecurityDescriptorDacl( &AuthOnlySD, TRUE, pAuthOnlyAcl, FALSE );

    dwSize = 0;
    MakeSelfRelativeSD( &AuthOnlySD, NULL, &dwSize );

    if ( GetLastError() != ERROR_MORE_DATA &&
         GetLastError() != ERROR_INSUFFICIENT_BUFFER )
    {
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    *ppSD = new BYTE[dwSize];

    if ( *ppSD == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    if ( !MakeSelfRelativeSD( &AuthOnlySD, *ppSD, &dwSize ) )
    {
        delete [] *ppSD;
        *ppSD = NULL;
        return HRESULT_FROM_WIN32( GetLastError() );
    }

    return WBEM_S_NO_ERROR;
}

//
// for now only one rpc receiver can be registered for the process.  later 
// make the global state be the instance state for CMsgRpcReceiver.
//

STDMETHODIMP CMsgRpcReceiver::Open( LPCWSTR wszBinding,
                                    DWORD dwFlags,
                                    WMIMSG_RCVR_AUTH_INFOP pAuthInfo,
                                    IWmiMessageSendReceive* pRcv )
{
    HRESULT hr;
    RPC_STATUS stat;

    hr = Close();

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    //
    // first parse the binding string.
    //

    LPWSTR wszProtSeq, wszEndpoint;

    stat = RpcStringBindingParse( (LPWSTR)wszBinding, 
                                  NULL, 
                                  &wszProtSeq,
                                  NULL,
                                  &wszEndpoint,
                                  NULL );
    if ( stat != RPC_S_OK )
    {
        return RpcResToWmiRes( stat, S_OK );
    }
    
    //
    // init the protocol sequence
    //

    if ( *wszEndpoint == '\0' )
    {
        stat = RpcServerUseProtseq( wszProtSeq,
                                    RPC_C_PROTSEQ_MAX_REQS_DEFAULT, 
                                    NULL );
        if ( stat == RPC_S_OK )
        {
            RPC_BINDING_VECTOR* pBindingVector;

            stat = RpcServerInqBindings( &pBindingVector );

            if ( stat == RPC_S_OK )
            {
                stat = RpcEpRegisterNoReplace( 
                           RcvrIWmiMessageRemoteSendReceive_v1_0_s_ifspec,
                           pBindingVector,
                           NULL,
                           NULL );

                RpcBindingVectorFree( &pBindingVector );
            }
        }
    }
    else
    {
        stat = RpcServerUseProtseqEp( wszProtSeq,
                                      RPC_C_PROTSEQ_MAX_REQS_DEFAULT,
                                      wszEndpoint,
                                      NULL );
    }

    RpcStringFree( &wszProtSeq );
    RpcStringFree( &wszEndpoint );
    
    if ( stat != RPC_S_OK )
    {
        return RpcResToWmiRes( stat, S_OK );
    }

    //
    // enable negotiate authentication service ( negotiates between NTLM 
    // and kerberos )
    // 

    if ( pAuthInfo != NULL )
    {
        for( int i=0; i < pAuthInfo->cwszPrincipal; i++ )
        {
            stat = RpcServerRegisterAuthInfo( 
                                         (LPWSTR)pAuthInfo->awszPrincipal[i],
                                         RPC_C_AUTHN_GSS_NEGOTIATE, 
                                         NULL, 
                                         NULL );
            if ( stat != RPC_S_OK )
            {
                return RpcResToWmiRes( stat, S_OK );
            }
        }
    }
    else
    {       
        LPWSTR wszPrincipal;

        stat = RpcServerInqDefaultPrincName( RPC_C_AUTHN_GSS_NEGOTIATE,
                                             &wszPrincipal );
        if ( stat != RPC_S_OK )
        {
            return RpcResToWmiRes( stat, S_OK );
        }
        
        stat = RpcServerRegisterAuthInfo( wszPrincipal,
                                          RPC_C_AUTHN_GSS_NEGOTIATE, 
                                          NULL, 
                                          NULL );
        RpcStringFree( &wszPrincipal );

        if ( stat != RPC_S_OK )
        {
            return RpcResToWmiRes( stat, S_OK );
        }
    }

    RPC_IF_CALLBACK_FN* pAuthCallback = NULL;

    if ( dwFlags & WMIMSG_FLAG_RCVR_SECURE_ONLY )
    {
        PSECURITY_DESCRIPTOR pAuthOnlySD;

        hr = CreateAuthOnlySecurityDescriptor( &pAuthOnlySD );

        if ( FAILED(hr) )
        {
            return hr;
        }

        _DBG_ASSERT( g_pSD == NULL );           
        g_pSD = pAuthOnlySD;
        
        pAuthCallback = RpcAuthCallback;
    }

    //
    // register the interface 
    // 

    DWORD dwRpcFlags = RPC_IF_AUTOLISTEN;

    stat = RpcServerRegisterIfEx( 
                               RcvrIWmiMessageRemoteSendReceive_v1_0_s_ifspec,
                               NULL,
                               NULL,
                               dwRpcFlags,
                               RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                               pAuthCallback );

    if ( stat != RPC_S_OK )
    {
        return RpcResToWmiRes( stat, S_OK );
    }

    _DBG_ASSERT( g_pRcv == NULL );

    pRcv->AddRef();
    g_pRcv = pRcv;

    return WBEM_S_NO_ERROR;
}
    
STDMETHODIMP CMsgRpcReceiver::Close()
{
    RPC_STATUS stat;

    stat = RpcServerUnregisterIf( 
                           RcvrIWmiMessageRemoteSendReceive_v1_0_s_ifspec,
                           NULL,
                           0 );

    RPC_BINDING_VECTOR* pBindingVector;
    stat = RpcServerInqBindings( &pBindingVector );

    if ( stat == RPC_S_OK )
    {
        stat = RpcEpUnregister(
                           RcvrIWmiMessageRemoteSendReceive_v1_0_s_ifspec,
                           pBindingVector,
                           NULL );

        RpcBindingVectorFree( &pBindingVector );
    }

    if ( g_pRcv != NULL )
    {
        g_pRcv->Release();
        g_pRcv = NULL;
    }

    if ( g_pSD != NULL )
    {
        delete [] g_pSD;
        g_pSD = NULL;
    }

    return WBEM_S_NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\smrtmrsh.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <wbemint.h>
#include <wbemutil.h>
#include <md5wbem.h>
#include <arrtempl.h>
#include "smrtmrsh.h"
#include "buffer.h"


static DWORD g_dwSignature = 0xabcdefab;
static WORD g_dwVersion = 0;

enum { e_ClassIdNone=0,
       e_ClassIdHash,
       e_ClassIdHashAndPath } ClassIdType_e;

enum { e_DataPartial=0,
       e_DataFull } DataType_e;
       
/****
         
  Packed Object Format 
  
  - 4 byte magic number 
  - 2 byte version number 
  - 1 byte class id type
  - 4 byte class id len
  - N byte class id
  - 1 byte data type
  - 4 byte data len
  - N byte data 
  
  *****/
       
#define HDRSIZE  16 // size of msg w/o variable length data.
#define HASHSIZE 16 


/**************************************************************************
  CWbemObjectWrapper - smooths out differences between Nova and Whistler 
***************************************************************************/

class CWbemObjectWrapper
{
    CWbemPtr<_IWmiObject> m_pWmiObj;
    CWbemPtr<IWbemObjectAccess> m_pObjAccess;
//    CWbemPtr<IWbemObjectInternals> m_pObjInt;

public:

    HRESULT SetPointer( IWbemClassObject* pObj )
    {
        HRESULT hr;

        hr = pObj->QueryInterface( IID__IWmiObject, (void**)&m_pWmiObj );

        if ( FAILED(hr) )
        {
            hr = pObj->QueryInterface( IID_IWbemObjectAccess, 
                                       (void**)&m_pObjAccess );

            if ( SUCCEEDED(hr) )
            {
             //   hr = pObj->QueryInterface( IID_IWbemObjectInternals, 
             //                              (void**)&m_pObjInt );
            }
        }

        return hr;
    }

    operator IWbemObjectAccess* ()
    {
        IWbemObjectAccess* pAccess;
        
        if ( m_pWmiObj != NULL )
        {
            pAccess = m_pWmiObj;
        }
        else
        {
            pAccess = m_pObjAccess;
        }
        
        return pAccess;
    }

    BOOL IsValid()
    {
        return m_pWmiObj != NULL || m_pObjAccess != NULL;
    }

    HRESULT SetObjectParts( LPVOID pMem, 
                            DWORD dwDestBufSize, 
                            DWORD dwParts )
    {
        HRESULT hr;

        if ( m_pWmiObj != NULL )
        {
            hr = m_pWmiObj->SetObjectParts( pMem, dwDestBufSize, dwParts );
        }
        else
        {
            hr = WBEM_E_NOT_SUPPORTED;
        }

        return hr;
    }

    HRESULT GetObjectParts( LPVOID pDestination,
                            DWORD dwDestBufSize,
                            DWORD dwParts,
                            DWORD *pdwUsed )
    {
        HRESULT hr;

        if ( m_pWmiObj != NULL )
        {
            hr = m_pWmiObj->GetObjectParts( pDestination, 
                                            dwDestBufSize, 
                                            dwParts,
                                            pdwUsed );
        }
        else
        {
            hr = WBEM_E_NOT_SUPPORTED;
        }

        return hr;
    }

    HRESULT MergeClassPart( IWbemClassObject* pObj )
    {
        HRESULT hr;

        if ( m_pWmiObj != NULL )
        {
            hr = m_pWmiObj->MergeClassPart( pObj );
        }
        else
        {
            hr = WBEM_E_NOT_SUPPORTED;
        }

        return hr;
    }   
};

HRESULT GetClassPath( IWbemClassObject* pObj,
                      LPCWSTR wszNamespace,
                      PBYTE pBuff, 
                      ULONG cBuff,
                      ULONG* pcUsed )
{
    HRESULT hr;
    *pcUsed = 0;

    CPropVar vNamespace, vClass;

    //
    // before trying to optimize the property access, realize that 
    // class objects do not support handle access to the __Namespace prop.
    //  

    hr = pObj->Get( L"__NAMESPACE", 0, &vNamespace, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pObj->Get( L"__CLASS", 0, &vClass, NULL, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( V_VT(&vNamespace) == VT_BSTR )
    {
        wszNamespace = V_BSTR(&vNamespace);
    }

    if ( wszNamespace == NULL )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    if ( V_VT(&vClass) != VT_BSTR )
    {
        return WBEM_E_CRITICAL_ERROR;
    }

    ULONG cNamespace = wcslen(wszNamespace)*2;
    ULONG cClass = wcslen(V_BSTR(&vClass))*2;

    //
    // add 4 for the two null terminators
    //

    *pcUsed = cNamespace + cClass + 4;

    if ( cBuff < *pcUsed )
    {
        return WBEM_E_BUFFER_TOO_SMALL;
    }

    ULONG iBuff = 0;

    memcpy( pBuff+iBuff, wszNamespace, cNamespace );
    iBuff += cNamespace;

    *(WCHAR*)(pBuff+iBuff) = ':';
    iBuff+= 2;

    memcpy( pBuff+iBuff, V_BSTR(&vClass), cClass );
    iBuff += cClass;

    *(WCHAR*)(pBuff+iBuff) = '\0';
    iBuff+= 2;
    
    _DBG_ASSERT( iBuff == *pcUsed );

    return hr;
}

HRESULT GetClassPartHash( CWbemObjectWrapper& rWrap, 
                          PBYTE pClassPartHash,
                          ULONG cClassPartHash )
{
    HRESULT hr;

    //
    // Too bad we have to perform a copy here, but no other way.  This 
    // function requires the passed in buffer be big enough to hold both 
    // the class part and the hash.  This is not really too limiting because 
    // in most cases where this function is used, the caller already has 
    // enough memory allocated to use here as a workarea.
    //

    DWORD dwSize;

    if ( cClassPartHash >= HASHSIZE )
    {
        hr = rWrap.GetObjectParts( pClassPartHash+HASHSIZE,
                                   cClassPartHash-HASHSIZE,
                                   WBEM_OBJ_CLASS_PART,
                                   &dwSize );
        if ( SUCCEEDED(hr) )
        {
            MD5::Transform( pClassPartHash+HASHSIZE, dwSize, pClassPartHash );
        }
    }
    else
    {
        hr = WBEM_E_BUFFER_TOO_SMALL;
    }

    return hr;
}
      
/***************************************************************************
  CSmartObjectMarshaler
****************************************************************************/

HRESULT CSmartObjectMarshaler::GetMaxMarshalSize( IWbemClassObject* pObj,
                                                  LPCWSTR wszNamespace,
                                                  DWORD dwFlags,
                                                  ULONG* pulSize )
{
    HRESULT hr;

    CWbemPtr<IMarshal> pMrsh;
    hr = pObj->QueryInterface( IID_IMarshal, (void**)&pMrsh );
    
    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // user is requesting the required size to pack object. For now,
    // we always use the size of the entire object blob.  However, the
    // actual size of the object may be much smaller. 
    //

    DWORD dwSize;

    hr = pMrsh->GetMarshalSizeMax( IID_IWbemClassObject, 
                                   pObj,
                                   MSHCTX_INPROC,
                                   NULL,
                                   0,
                                   &dwSize );
    if ( FAILED(hr) )
    {
        return hr;
    }

    *pulSize = dwSize + HDRSIZE + HASHSIZE;

    if ( dwFlags == WMIMSG_FLAG_MRSH_PARTIAL )
    {
        hr = GetClassPath( pObj, wszNamespace, NULL, 0, &dwSize );

        if ( hr == WBEM_E_BUFFER_TOO_SMALL )
        {
            *pulSize += dwSize;
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            _DBG_ASSERT( FAILED(hr) );
        }
    }

    return hr;
}


HRESULT CSmartObjectMarshaler::InternalPack( IWbemClassObject* pObj,
                                             LPCWSTR wszNamespace,
                                             DWORD dwFlags,
                                             ULONG cBuff, 
                                             BYTE* pBuff, 
                                             ULONG* pcUsed )
{
    HRESULT hr;
    *pcUsed = 0;

    //
    // make sure we have enough room for at least the header data.
    //

    if ( cBuff < HDRSIZE )
    {
        return WBEM_E_BUFFER_TOO_SMALL;
    }

    ULONG iBuff = 0;

    memcpy( pBuff + iBuff, &g_dwSignature, 4 );
    iBuff += 4;
    
    memcpy( pBuff + iBuff, &g_dwVersion, 2 );
    iBuff += 2;

    //
    // write class information 
    // 

    DWORD dwSize;
    BOOL bPartialData;

    CWbemObjectWrapper ObjWrap;
    PBYTE pClassPartHash = NULL;

    if ( dwFlags == WMIMSG_FLAG_MRSH_FULL_ONCE )
    {
        hr = ObjWrap.SetPointer( pObj );

        if ( FAILED(hr) )
        {
            return hr;
        }

        //
        // send class part hash for class info
        //

        *(pBuff+iBuff) = char(e_ClassIdHash);
        iBuff++;

        dwSize = HASHSIZE;
        memcpy( pBuff+iBuff, &dwSize, 4 );
        iBuff += 4;

        hr = GetClassPartHash( ObjWrap, pBuff+iBuff, cBuff-iBuff );
        
        if ( FAILED(hr) )
        {
            return hr;
        }
        
        pClassPartHash = pBuff+iBuff;
        iBuff += HASHSIZE;

        //
        // see if we've sent the class part before
        // 

        CInCritSec ics( &m_cs );
        bPartialData = m_SentMap[pClassPartHash];
    }
    else if ( dwFlags == WMIMSG_FLAG_MRSH_PARTIAL )
    {
        hr = ObjWrap.SetPointer( pObj );

        if ( FAILED(hr) )
        {
            return hr;
        }

        //
        // send class path and class part hash for class info
        //

        *(pBuff+iBuff) = char(e_ClassIdHashAndPath);
        iBuff++;
        
        PBYTE pLen = pBuff+iBuff;
        iBuff+= 4; // leave room for class info size

        hr = GetClassPartHash( ObjWrap, pBuff+iBuff, cBuff-iBuff );
        
        if ( FAILED(hr) )
        {
            return hr;
        }

        iBuff += HASHSIZE;
        
        hr = GetClassPath( pObj, 
                           wszNamespace, 
                           pBuff+iBuff, 
                           cBuff-iBuff, 
                           &dwSize );

        if ( FAILED(hr) )
        {
            return hr;
        }

        iBuff += dwSize;

        dwSize += HASHSIZE; // size if both hash and path

        memcpy( pLen, &dwSize, 4 );

        bPartialData = TRUE;
    }
    else if ( dwFlags == WMIMSG_FLAG_MRSH_FULL )
    {
        //
        // no class information
        //

        *(pBuff+iBuff) = char(e_ClassIdNone);
        iBuff++;

        memset( pBuff + iBuff, 0, 4 );
        iBuff += 4;

        bPartialData = FALSE;
    }
    else
    {
        return WBEM_E_INVALID_PARAMETER;
    }

    //
    // write data
    //

    if ( bPartialData )
    {
        *(pBuff+iBuff) = char(e_DataPartial);
        iBuff++;

        PBYTE pLen = pBuff+iBuff;

        iBuff += 4; // fill in length afterwords.

        //
        // now get instance part
        //

        _DBG_ASSERT( ObjWrap.IsValid() );

        hr = ObjWrap.GetObjectParts( pBuff+iBuff, 
                                     cBuff-iBuff, 
                                     WBEM_OBJ_DECORATION_PART | 
                                     WBEM_OBJ_INSTANCE_PART,
                                     &dwSize ); 

        if ( FAILED(hr) )
        {
            return hr;
        }

        iBuff += dwSize;

        //
        // go back and set length .. 
        // 

        memcpy( pLen, &dwSize, 4 );
    }
    else
    {
        *(pBuff+iBuff) = char(e_DataFull);

        iBuff++;

        PBYTE pLen = pBuff+iBuff;
        
        iBuff += 4; // fill in length afterwords.

        //
        // for now, use MarshalInterface() to marshal object.  The reason
        // for this is because SetObjectMemory() has a bug where
        // it assumes ownership of the memory ( even though the client 
        // doesn't have access to the allocator used to free it ).  
        //

        CBuffer Strm( pBuff+iBuff, cBuff-iBuff, FALSE );
        
        CWbemPtr<IMarshal> pMrsh;
        hr = pObj->QueryInterface( IID_IMarshal, (void**)&pMrsh );

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = pMrsh->MarshalInterface( &Strm, 
                                      IID_IWbemClassObject, 
                                      pObj, 
                                      MSHCTX_INPROC, 
                                      NULL, 
                                      0 );
        if ( FAILED(hr) )
        {
            return hr;
        }

        //
        // check if we read more data than we can fit into our buffer.  We 
        // can tell this if the buffer is no longer the one we passed in.
        //

        if ( Strm.GetRawData() != pBuff+iBuff )
        {
            return WBEM_E_BUFFER_TOO_SMALL;
        }

        dwSize = Strm.GetIndex();

        iBuff += dwSize;

        //
        // go back and set length of the data.
        //

        memcpy( pLen, &dwSize, 4 );

        if ( dwFlags == WMIMSG_FLAG_MRSH_FULL_ONCE )
        {
            //
            // mark that we've successfully packed the class part once.
            // 
            _DBG_ASSERT( pClassPartHash != NULL );
            CInCritSec ics(&m_cs);
            m_SentMap[pClassPartHash] = TRUE;
        }
    }

    *pcUsed = iBuff;

    return WBEM_S_NO_ERROR;
}


STDMETHODIMP CSmartObjectMarshaler::Pack( IWbemClassObject* pObj,
                                          LPCWSTR wszNamespace,
                                          DWORD dwFlags,
                                          ULONG cBuff,
                                          BYTE* pBuff,
                                          ULONG* pcUsed )
{
    HRESULT hr;
    
    ENTER_API_CALL

    hr = InternalPack( pObj, wszNamespace, dwFlags, cBuff, pBuff, pcUsed );

    if ( hr == WBEM_E_BUFFER_TOO_SMALL )
    {
        HRESULT hr2;

        hr2 = GetMaxMarshalSize( pObj, wszNamespace, dwFlags, pcUsed );

        if ( FAILED(hr2) )
        {
            hr = hr2;
        }
    }

    EXIT_API_CALL

    return hr;
}

STDMETHODIMP CSmartObjectMarshaler::Flush()
{
    CInCritSec ics(&m_cs);
    m_SentMap.clear();
    return S_OK;
}

/***************************************************************************
  CSmartObjectUnmarshaler
****************************************************************************/

HRESULT CSmartObjectUnmarshaler::EnsureInitialized()
{
    HRESULT hr;

    CInCritSec ics( &m_cs );

    if ( m_pEmptyClass != NULL )
    {
        return WBEM_S_NO_ERROR;
    }
    
    //
    // allocate a template class object which we can use for spawning
    // 'empty' instances from.  
    //

    CWbemPtr<IWbemClassObject> pEmptyClass;

    hr = CoCreateInstance( CLSID_WbemClassObject,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWbemClassObject,
                           (void**)&pEmptyClass );
    if ( FAILED(hr) )
    {
        return hr;
    }

    VARIANT vName;
    V_VT(&vName) = VT_BSTR;
    V_BSTR(&vName) = L"__DummyClass";

    hr = pEmptyClass->Put( L"__CLASS", 0, &vName, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // allocate a locator to access namespaces for obtaining class definitions.
    // 

    CWbemPtr<IWbemLocator> pLocator;

    hr = CoCreateInstance( CLSID_WbemLocator,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWbemLocator,
                           (void**)&pLocator );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // Allocate a full object unmarshaler.  This is used to create classes 
    // or instances that were sent in full. 
    //

    hr = CoCreateInstance( CLSID_WbemClassObjectProxy,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IMarshal,
                           (void**)&m_pUnmrsh );
    if ( FAILED(hr) )
    {
        return hr;
    }

    m_pEmptyClass = pEmptyClass;
    m_pLocator = pLocator;

    return WBEM_S_NO_ERROR;
}

void CSmartObjectUnmarshaler::MakeRoomInCache( DWORD dwSize )
{
    while ( !m_Cache.empty() && dwSize + m_ulCacheSize > m_ulMaxCacheSize )
    {
        DWORD dwLeastRecentTime = 0xffffffff;
        ClassPartMap::iterator it, itLeastRecent;

        for( it = m_Cache.begin(); it != m_Cache.end(); it++ )
        {
            CacheRecord& rCurrent = it->second;

            if ( rCurrent.m_dwLastUsedTime <= dwLeastRecentTime )
            {
                itLeastRecent = it;
                dwLeastRecentTime = rCurrent.m_dwLastUsedTime;
            }
        }

        _DBG_ASSERT( m_ulCacheSize >= itLeastRecent->second.m_dwClassSize );
        m_ulCacheSize -= itLeastRecent->second.m_dwClassSize;
        m_Cache.erase( itLeastRecent );
    }
}


HRESULT CSmartObjectUnmarshaler::CacheClassPart( PBYTE pClassHash,
                                                 DWORD dwSize,
                                                 IWbemClassObject* pClassPart )
{
    HRESULT hr;

    CInCritSec ics(&m_cs);

    ClassPartMap::iterator it = m_Cache.find( pClassHash );

    if ( it == m_Cache.end() )
    {
        MakeRoomInCache( dwSize );

        if ( dwSize + m_ulCacheSize < m_ulMaxCacheSize )
        {
            //
            // create the record and add to cache.
            //
            
            CacheRecord Record;
            
            Record.m_dwClassSize = dwSize;
            Record.m_pClassPart = pClassPart;
            Record.m_dwLastUsedTime = GetTickCount();                    
            
            m_Cache[pClassHash] = Record;
            m_ulCacheSize += dwSize;
            
            hr = WBEM_S_NO_ERROR;
        }
        else
        {
            //
            // the class part size is too big to store in the cache.
            //
            hr = WBEM_S_FALSE;
        }
    }
    else
    {
        //
        // already in the cache.
        //
        hr = WBEM_S_NO_ERROR;
    }

    return hr;
}

HRESULT CSmartObjectUnmarshaler::FindClassPart( PBYTE pClassPartHash, 
                                                LPCWSTR wszClassPath, 
                                                IWbemClassObject** ppClassPart)
{
    HRESULT hr;

    //
    // first try the cache ...
    // 

    ClassPartMap::iterator it;

    {
        CInCritSec ics(&m_cs);
        it = m_Cache.find( pClassPartHash );

        if ( it != m_Cache.end() )
        {
            it->second.m_dwLastUsedTime = GetTickCount();
            
            *ppClassPart = it->second.m_pClassPart;
            (*ppClassPart)->AddRef();

//            DEBUGTRACE((LOG_ESS,
//                      "MRSH: Cache Hit !!! %d bytes saved in transmission\n",
//                       it->second.m_dwClassSize ));
            
            return WBEM_S_NO_ERROR;
        }
    }

    //
    // expensive route ... fetch the class object from wmi 
    // 
    
    if ( wszClassPath == NULL )
    {
        //
        // there's nothing we can do. 
        //
        return WBEM_E_NOT_FOUND;
    }

    CWbemPtr<IWbemServices> pSvc;

    CWbemBSTR bsNamespace = wszClassPath;
    WCHAR* pch = wcschr( bsNamespace, ':' );

    if ( pch == NULL )
    {
        return WBEM_E_INVALID_OBJECT_PATH;
    }

    *pch++ = '\0';

    hr = m_pLocator->ConnectServer( bsNamespace, NULL, NULL, 
                                   NULL, 0, NULL, NULL, &pSvc );

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    CWbemBSTR bsRelpath = pch;

    CWbemPtr<IWbemClassObject> pClass;

    hr = pSvc->GetObject( bsRelpath, 0, NULL, &pClass, NULL );

    if ( FAILED(hr) )
    {
        return hr;
    }

    CWbemPtr<IWbemClassObject> pClassPart;

    hr = pClass->SpawnInstance( 0, &pClassPart );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // now we have to verify that hash of the class part and the 
    // hash sent in the message are the same.
    // 
    
    CWbemObjectWrapper ObjWrap;

    hr = ObjWrap.SetPointer( pClassPart );

    if ( FAILED(hr) )
    {
        return hr;
    }

    DWORD dwSize;

    hr = ObjWrap.GetObjectParts( NULL, 0, WBEM_OBJ_CLASS_PART, &dwSize );

    if ( hr != WBEM_E_BUFFER_TOO_SMALL )
    {
        _DBG_ASSERT( FAILED(hr) );
        return hr;
    }

    PBYTE pBuff = new BYTE[dwSize+HASHSIZE];

    if ( pBuff == NULL )
    {
        return WBEM_E_OUT_OF_MEMORY;
    }

    CVectorDeleteMe<BYTE> tdm( pBuff );
    
    hr = GetClassPartHash( ObjWrap, pBuff, dwSize+HASHSIZE );

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( memcmp( pBuff, pClassPartHash, HASHSIZE ) == 0 )
    {
        //
        // things look good so cache the class part.
        // 

        hr = CacheClassPart( pClassPartHash, dwSize, pClassPart );

        if ( FAILED(hr) )
        {
            return hr;
        }

        *ppClassPart = pClassPart;
        (*ppClassPart)->AddRef();
    }
    else
    {
        //
        // class parts don't match up, nothing else we can do.
        //

        hr = WBEM_E_NOT_FOUND;
    }   

    return hr;
}

STDMETHODIMP CSmartObjectUnmarshaler::Unpack( ULONG cBuff,
                                              PBYTE pBuff, 
                                              DWORD dwFlags,
                                              IWbemClassObject** ppObj,
                                              ULONG* pcUsed ) 
{
    HRESULT hr;

    ENTER_API_CALL

    *pcUsed = 0;
    *ppObj = NULL;

    hr = EnsureInitialized();

    if ( FAILED(hr) )
    {
        return hr;
    }

    if ( cBuff < HDRSIZE )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // verify signature and version info 
    //

    DWORD dw;
    ULONG iBuff = 0;

    memcpy( &dw, pBuff + iBuff, 4 );

    iBuff += 6; // version info is not currently used;

    if ( dw != g_dwSignature )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // obtain the class id type 
    // 

    char chClassIdType = *(pBuff + iBuff);
    iBuff++;

    memcpy( &dw, pBuff + iBuff, 4 );
    iBuff += 4;

    if ( cBuff - iBuff - 5 < dw ) // 5 is for what's left in the hdr to read
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    //
    // obtain the class information associated with the data
    //

    PBYTE pClassPartHash = NULL;
    LPCWSTR wszClassPath = NULL;

    if ( chClassIdType == e_ClassIdHash )
    {
        pClassPartHash = pBuff+iBuff; 
    }
    else if ( chClassIdType == e_ClassIdHashAndPath )
    {
        pClassPartHash = pBuff+iBuff;
        wszClassPath = LPWSTR(pBuff+iBuff+HASHSIZE);

        if ( *(WCHAR*)(pBuff+iBuff+dw-2) != '\0' )
        {
            return WMIMSG_E_INVALIDMESSAGE;
        }
    }
    else if ( chClassIdType == e_ClassIdNone ) 
    {
        if ( dw != 0 )
        {
            return WMIMSG_E_INVALIDMESSAGE;
        }
    }
    else 
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    iBuff += dw;

    //
    // get data part info
    //

    char chDataType = *(pBuff+iBuff);
    iBuff++;

    memcpy( &dw, pBuff+iBuff, 4 );
    iBuff += 4;

    if ( dw > cBuff-iBuff )
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    CWbemPtr<IWbemClassObject> pObj;

    if ( chDataType == e_DataFull )
    {
        CBuffer Strm( pBuff+iBuff, cBuff-iBuff, FALSE );

        hr = m_pUnmrsh->UnmarshalInterface( &Strm, 
                                            IID_IWbemClassObject, 
                                            (void**)&pObj );
        if ( FAILED(hr) )
        {
            return WMIMSG_E_INVALIDMESSAGE;
        }

        dw = Strm.GetIndex();

        //
        // if there is an associated hash we need to store the class part 
        // of the unmarshaled object in our cache.
        //

        if ( pClassPartHash != NULL )
        {
            //
            // create an empty version of the instance to store in the 
            // cache. All we're interested in storing is the class part.
            //
            
            CWbemPtr<IWbemClassObject> pClassPart;
            hr = pObj->SpawnInstance( 0, &pClassPart );
            
            if ( FAILED(hr) )
            {
                return hr;
            }

            CWbemObjectWrapper ObjWrap;

            hr = ObjWrap.SetPointer( pClassPart );

            if ( FAILED(hr) )
            {
                return hr;
            }

            DWORD dwSize;

            hr = ObjWrap.GetObjectParts( NULL,
                                         0,
                                         WBEM_OBJ_CLASS_PART,
                                         &dwSize );

            if ( hr != WBEM_E_BUFFER_TOO_SMALL )
            {
                _DBG_ASSERT( FAILED(hr) );
                return hr;
            }

            hr = CacheClassPart( pClassPartHash, dwSize, pClassPart );

            if ( FAILED(hr) )
            {
                return hr;
            }
        }
    }
    else if ( chDataType == e_DataPartial )
    {
        CWbemPtr<IWbemClassObject> pClassPart;

        _DBG_ASSERT( pClassPartHash != NULL );

        hr = FindClassPart( pClassPartHash, wszClassPath, &pClassPart );

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = m_pEmptyClass->SpawnInstance( 0, &pObj );

        if ( FAILED(hr) )
        {
            return hr;
        }

        CWbemObjectWrapper ObjWrap;

        hr = ObjWrap.SetPointer( pObj );

        if ( FAILED(hr) )
        {
            return hr;
        }

        //
        // aquires ownership of the memory -- must be CoTaskMemAlloc-ed
        // kind of unfortunate - but the memory has to be allocated and 
        // copied sometime so guess its not that big of a deal.
        // 
        
        PVOID pInstData = CoTaskMemAlloc( dw );

        if ( NULL == pInstData )
        {
            return WBEM_E_OUT_OF_MEMORY;
        }

        memcpy( pInstData, pBuff+iBuff, dw );

        hr = ObjWrap.SetObjectParts( pInstData,
                                     dw,
                                     WBEM_OBJ_DECORATION_PART |
                                     WBEM_OBJ_INSTANCE_PART );
        if ( FAILED(hr) )
        {
            CoTaskMemFree( pInstData );
            return hr;
        }

        hr = ObjWrap.MergeClassPart( pClassPart );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }
    else
    {
        return WMIMSG_E_INVALIDMESSAGE;
    }

    iBuff += dw; // advance the index to account for the data part

    pObj->AddRef();
    *ppObj = pObj;
    *pcUsed = iBuff;

    EXIT_API_CALL

    return WBEM_S_NO_ERROR;
}
                    
STDMETHODIMP CSmartObjectUnmarshaler::Flush()
{
    CInCritSec ics(&m_cs);
    m_Cache.clear();
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\rpcsend.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __RPCSEND_H__
#define __RPCSEND_H__

#include <unk.h>
#include <comutl.h>
#include <wstring.h>
#include <sync.h>
#include "wmimsg.h"

/**************************************************************************
  CMsgRpcSender
***************************************************************************/

class CMsgRpcSender 
: public CUnkBase<IWmiMessageSender,&IID_IWmiMessageSender>
{

public:

    CMsgRpcSender( CLifeControl* pCtl )
    : CUnkBase<IWmiMessageSender,&IID_IWmiMessageSender>( pCtl ) { }

    STDMETHOD(Open)( LPCWSTR wszTarget, 
                     DWORD dwFlags,
                     WMIMSG_SNDR_AUTH_INFOP pAuthInfo,
                     LPCWSTR wszResponse,
                     IWmiMessageTraceSink* pTraceSink,
                     IWmiMessageSendReceive** ppSend );
};

/**************************************************************************
  CMsgRpcSend
***************************************************************************/

class CMsgRpcSend 
: public CUnkBase<IWmiMessageSendReceive,&IID_IWmiMessageSendReceive>
{
    CCritSec m_cs;
    WString m_wsTarget;
    WString m_wsComputer;
    WString m_wsTargetPrincipal;
    DWORD m_dwFlags;
    BOOL m_bInit;
    RPC_BINDING_HANDLE m_hBinding;
    CWbemPtr<IWmiMessageTraceSink> m_pTraceSink;
   
    void Clear();
    
    HRESULT PerformSend( PBYTE pData,
                         ULONG cData, 
                         PBYTE pAuxData, 
                         ULONG cAuxData );
 
    HRESULT HandleTrace( HRESULT hRes, LPCWSTR wszTrace, IUnknown* pCtx );

public: 

    CMsgRpcSend( CLifeControl* pCtl, 
                 LPCWSTR wszTarget,
                 DWORD dwFlags,
                 WMIMSG_SNDR_AUTH_INFOP pAuthInfo,
                 LPCWSTR wszResponse,
                 IWmiMessageTraceSink* pTraceSink );
     
    STDMETHOD(SendReceive)( PBYTE pData, 
                            ULONG cData, 
                            PBYTE pAuxData,
                            ULONG cAuxData,
                            DWORD dwFlagStatus,
                            IUnknown* pContext );

    virtual ~CMsgRpcSend();

    HRESULT EnsureSender();
};

#endif // __RPCSEND_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\rpchdr.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __RPCHDR_H__
#define __RPCHDR_H__

#include <buffer.h>
#include <wmimsg.h>

/**********************************************************************
  CMsgRpcHdr
***********************************************************************/

class CMsgRpcHdr
{
    SYSTEMTIME m_Time;
    LPCWSTR m_wszSource;
    ULONG m_cAuxData;

public:

    CMsgRpcHdr() { ZeroMemory( this, sizeof(CMsgRpcHdr) ); }
    
    CMsgRpcHdr( LPCWSTR wszSource, ULONG cUserAuxData );

    ULONG GetAuxDataLength() { return m_cAuxData; }
    SYSTEMTIME* GetTimeSent() { return &m_Time; }
    LPCWSTR GetSendingMachine() { return m_wszSource; }

    HRESULT Unpersist( CBuffer& rStrm );
    HRESULT Persist( CBuffer& rStrm );
};


#endif // __RPCHDR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\smrtmrsh.h ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef __SMRTMRSH_H__
#define __SMRTMRSH_H__

#include <wbemcli.h>
#include <wstlallc.h>
#include <wmimsg.h>
#include <comutl.h>
#include <sync.h>
#include <unk.h>
#include <map>

#define HASHSIZE 16
 
class CHash
{ 
    BYTE m_achHash[HASHSIZE];

public:

    CHash( PBYTE pHash ) { memcpy( m_achHash, pHash, HASHSIZE ); } 

    bool operator < ( const CHash& rHash ) const
    {
        return memcmp( m_achHash, rHash.m_achHash, HASHSIZE ) < 0;
    }

};


/***************************************************************************
  CSmartObjectMarshaler
****************************************************************************/

class CSmartObjectMarshaler 
: public CUnkBase< IWmiObjectMarshal, &IID_IWmiObjectMarshal >
{
    CCritSec m_cs;
    std::map<CHash, BOOL, std::less<CHash>, wbem_allocator<BOOL> > m_SentMap;

    HRESULT GetMaxMarshalSize( IWbemClassObject* pObj,
                               LPCWSTR wszNamespace,
                               DWORD dwFlags,
                               ULONG* pulSize );

    HRESULT InternalPack( IWbemClassObject* pObj,
                          LPCWSTR wszNamespace,
                          DWORD dwFlags,
                          ULONG cBuff,   
                          PBYTE pBuff,
                          ULONG* pcUsed );
public:

    CSmartObjectMarshaler( CLifeControl* pCtl, IUnknown* pUnk = NULL )
     : CUnkBase< IWmiObjectMarshal, &IID_IWmiObjectMarshal >( pCtl )
     {
     }

    STDMETHOD(Pack)( IWbemClassObject* pObj,
                     LPCWSTR wszNamespace,
                     DWORD dwFlags,
                     ULONG cBuff,   
                     PBYTE pBuff,
                     ULONG* pcUsed );

    STDMETHOD(Unpack)( ULONG cBuff,       
                       PBYTE pBuff,
                       DWORD dwFlags, 
                       IWbemClassObject** pObj,
                       ULONG* pcUsed )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(Flush)();
};

/***************************************************************************
  CSmartObjectUnmarshaler
****************************************************************************/

class CSmartObjectUnmarshaler 
: public CUnkBase< IWmiObjectMarshal, &IID_IWmiObjectMarshal >
{
    CCritSec m_cs;

    ULONG m_ulMaxCacheSize;
    ULONG m_ulCacheSize;

    CWbemPtr<IMarshal> m_pUnmrsh;
    CWbemPtr<IWbemLocator> m_pLocator;
    CWbemPtr<IWbemClassObject> m_pEmptyClass;

    struct CacheRecord
    {
        DWORD m_dwClassSize;
        DWORD m_dwLastUsedTime;
        CWbemPtr<IWbemClassObject> m_pClassPart;
    };

    typedef std::map< CHash,
                      CacheRecord,
                      std::less<CHash>,
                      wbem_allocator<CacheRecord> > ClassPartMap;

    ClassPartMap m_Cache;

    void MakeRoomInCache( DWORD dwSize );

    HRESULT EnsureInitialized();

    HRESULT CacheClassPart(PBYTE pHash, DWORD dwSize, IWbemClassObject* pInst);

    HRESULT FindClassPart( PBYTE pClassPartHash, 
                           LPCWSTR wszClassPath,
                           IWbemClassObject** ppClassPart );

public:

    CSmartObjectUnmarshaler( CLifeControl* pCtl, IUnknown* pUnk = NULL )
     : CUnkBase< IWmiObjectMarshal, &IID_IWmiObjectMarshal >( pCtl ), 
       m_ulMaxCacheSize(0x500000), m_ulCacheSize(0) { }

    STDMETHOD(Pack)( IWbemClassObject* pObj,
                     LPCWSTR wszNamespace,
                     DWORD dwFlags,
                     ULONG cBuff,   
                     PBYTE pBuff,
                     ULONG* pcUsed )
    {
        return WBEM_E_NOT_SUPPORTED;
    }

    STDMETHOD(Unpack)( ULONG cBuff,       
                       PBYTE pBuff,
                       DWORD dwFlags, 
                       IWbemClassObject** pObj,
                       ULONG* pcUsed );

    STDMETHOD(Flush)();
};

#endif __SMRTMRSH_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\rpcsend.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <assert.h>
#include <comutl.h>
#include "rpchdr.h"
#include "rpcsend.h"
#include "rpcmsg.h"

extern HRESULT RpcResToWmiRes( RPC_STATUS stat, HRESULT hrDefault );

/*****************************************************************
  CMsgRpcSender
******************************************************************/

HRESULT CMsgRpcSender::Open( LPCWSTR wszTarget, 
                             DWORD dwFlags,
                             WMIMSG_SNDR_AUTH_INFOP pAuthInfo,
                             LPCWSTR wszResponse,
                             IWmiMessageTraceSink* pTraceSink,
                             IWmiMessageSendReceive** ppSend )
{
    HRESULT hr;

    ENTER_API_CALL

    CWbemPtr<CMsgRpcSend> pSend;

    pSend = new CMsgRpcSend( m_pControl,
                             wszTarget, 
                             dwFlags, 
                             pAuthInfo,
                             wszResponse,
                             pTraceSink );

    if ( (dwFlags & WMIMSG_FLAG_SNDR_LAZY_INIT) == 0 )
    {
        hr = pSend->EnsureSender();

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    return pSend->QueryInterface(IID_IWmiMessageSendReceive, (void**)ppSend);

    EXIT_API_CALL
}

/*****************************************************************
  CMsgRpcSend
******************************************************************/

CMsgRpcSend::CMsgRpcSend( CLifeControl* pCtl, 
                          LPCWSTR wszTarget,
                          DWORD dwFlags,
                          WMIMSG_SNDR_AUTH_INFOP pAuthInfo,
                          LPCWSTR wszResponse,
                          IWmiMessageTraceSink* pTraceSink )
 : CUnkBase<IWmiMessageSendReceive,&IID_IWmiMessageSendReceive>(pCtl), 
   m_dwFlags(dwFlags), m_pTraceSink( pTraceSink ),
   m_hBinding(NULL), m_bInit(FALSE)
{ 
    //
    // save our computer name.
    //

    TCHAR achComputer[MAX_COMPUTERNAME_LENGTH+1];
    ULONG ulSize = MAX_COMPUTERNAME_LENGTH+1;
    GetComputerName( achComputer, &ulSize );
    m_wsComputer = achComputer;

    //
    // if the target is NULL, then we use our computer name as the target.
    //

    if ( wszTarget != NULL && *wszTarget != '\0' )
    { 
        m_wsTarget = wszTarget;
    }
    else
    {
        m_wsTarget = m_wsComputer;
    }

    if ( pAuthInfo != NULL )
    {
        if ( pAuthInfo->wszTargetPrincipal != NULL )
        {
            m_wsTargetPrincipal = pAuthInfo->wszTargetPrincipal;
        }
    }
} 

CMsgRpcSend::~CMsgRpcSend() 
{ 
    Clear(); 
}

HRESULT CMsgRpcSend::HandleTrace( HRESULT hr, 
                                  LPCWSTR wszTrace, 
                                  IUnknown* pCtx )
{
    //
    // we use the error sink approach instead of just returning an error 
    // because sometimes multiple senders are used in one send operation 
    // ( when using the multi send impl ) and we need to be able to
    // distinguish which one failed.  
    // 

    if ( m_pTraceSink != NULL )
    {
        m_pTraceSink->Notify( hr, CLSID_WmiMessageRpcSender, wszTrace, pCtx );
    }

    return hr;
}

void CMsgRpcSend::Clear()
{
    if ( m_hBinding != NULL )
    {
        RpcBindingFree( &m_hBinding );
        m_hBinding = NULL;
    }
    m_bInit = FALSE;
}

HRESULT CMsgRpcSend::EnsureSender()
{
    HRESULT hr = S_OK;
    RPC_STATUS stat;

    CInCritSec ics(&m_cs);

    if ( m_bInit )
    {
        return WBEM_S_NO_ERROR;
    }

    Clear();

    //
    // connect to the stub at the target.
    //

    stat = RpcBindingFromStringBinding( m_wsTarget, &m_hBinding );

    if ( stat != RPC_S_OK )
    {
        return RpcResToWmiRes( stat, WMIMSG_E_INVALIDADDRESS );
    }

    //
    // binding may be dynamic, so we may have to resolve it.
    //

    stat = RpcEpResolveBinding( m_hBinding,
                                IWmiMessageRemoteSendReceive_v1_0_c_ifspec );
    
    if ( stat != RPC_S_OK )
    {
        return RpcResToWmiRes( stat, WMIMSG_E_TARGETNOTFOUND );
    }
    
    //
    // set binding auth info based on auth and encryption flags.
    //

    RPC_SECURITY_QOS qos;
    DWORD dwAuthnSvc, dwAuthzSvc, dwAuthnLevel;

    LPWSTR wszPrincipal = NULL;

    if ( m_wsTargetPrincipal.Length() > 0 )
    {
        wszPrincipal = m_wsTargetPrincipal;
    }

    qos.Version = RPC_C_SECURITY_QOS_VERSION;
    qos.Capabilities = RPC_C_QOS_CAPABILITIES_DEFAULT;

    if ( m_dwFlags & WMIMSG_FLAG_SNDR_ENCRYPT )
    {
        dwAuthnSvc = RPC_C_AUTHN_GSS_NEGOTIATE;
        dwAuthzSvc = RPC_C_AUTHZ_DEFAULT;    
        dwAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
        qos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
        qos.ImpersonationType = RPC_C_IMP_LEVEL_IDENTIFY;
    }
    else if ( m_dwFlags & WMIMSG_FLAG_SNDR_AUTHENTICATE )
    {
        dwAuthnSvc = RPC_C_AUTHN_GSS_NEGOTIATE;
        dwAuthzSvc = RPC_C_AUTHZ_DEFAULT;    
        qos.IdentityTracking = RPC_C_QOS_IDENTITY_DYNAMIC;
        qos.ImpersonationType = RPC_C_IMP_LEVEL_IDENTIFY;
        dwAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_INTEGRITY;
    }
    else 
    {
        dwAuthnSvc = RPC_C_AUTHN_NONE;
        dwAuthzSvc = RPC_C_AUTHZ_NONE;
        qos.IdentityTracking = RPC_C_QOS_IDENTITY_STATIC;
        qos.ImpersonationType = RPC_C_IMP_LEVEL_ANONYMOUS;
        dwAuthnLevel = RPC_C_AUTHN_LEVEL_NONE;
    }

    stat = RpcBindingSetAuthInfoEx( m_hBinding,
                                    wszPrincipal,
                                    dwAuthnLevel,
                                    dwAuthnSvc,
                                    NULL,
                                    dwAuthzSvc,
                                    &qos );

    if ( stat != RPC_S_OK )
    {         
        return RpcResToWmiRes( stat, WMIMSG_E_AUTHFAILURE );
    }
    
    m_bInit = TRUE;

    return hr;
}

HRESULT CMsgRpcSend::PerformSend( PBYTE pData, 
                                  ULONG cData, 
                                  PBYTE pAuxData,
                                  ULONG cAuxData )
{
    HRESULT hr;

    RpcTryExcept  
    {
        hr = ::SendReceive( m_hBinding,
                            pData, 
                            cData, 
                            pAuxData,
                            cAuxData );
    } 
    RpcExcept(1) 
    {
        hr = RpcResToWmiRes( RpcExceptionCode(), S_OK );
    }
    RpcEndExcept

    return hr;
}    

HRESULT CMsgRpcSend::SendReceive( PBYTE pData, 
                                  ULONG cData,
                                  PBYTE pAuxData,
                                  ULONG cAuxData,
                                  DWORD dwFlagStatus,
                                  IUnknown* pCtx ) 
{
    HRESULT hr;

    BYTE achHdr[512];
    CBuffer HdrStrm( achHdr, 512, FALSE );
    CMsgRpcHdr RpcHdr( m_wsComputer, cAuxData );

    ENTER_API_CALL

    hr = EnsureSender();

    if ( FAILED(hr) )
    {
        return HandleTrace( hr, m_wsTarget, pCtx );
    }

    //
    // create our Rpc hdr and prepend it to the user's hdr data.
    //

    hr = RpcHdr.Persist( HdrStrm );

    if ( FAILED(hr) )
    {
        return HandleTrace( hr, m_wsTarget, pCtx );
    }

    hr = HdrStrm.Write( pAuxData, cAuxData, NULL );

    if ( FAILED(hr) )
    {
        return HandleTrace( hr, m_wsTarget, pCtx );
    }

    hr = PerformSend( pData, 
                      cData,
                      HdrStrm.GetRawData(), 
                      HdrStrm.GetIndex() );  
     
    if ( FAILED(hr) )
    {
        //
        // this is so the next call will reset us.
        //
        Clear();

        hr = RpcResToWmiRes( hr, S_OK );
    }

    HandleTrace( hr, m_wsTarget, pCtx );

    EXIT_API_CALL

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\test\msgsvr\msgsvr.cpp ===
#include <windows.h>
#include <wmimsg.h>
#include <comutl.h>
#include <rcvtest.h>
#include <rcvtest_i.c>
#include <stdio.h>

FILE* g_pfLogFile;
    
class CReceiveTest : public IReceiveTest, public IClassFactory
{
public:

    STDMETHOD_(ULONG,AddRef)() { return 1; }
    STDMETHOD_(ULONG,Release)() { return 1; }
    STDMETHOD(QueryInterface)( REFIID riid , void** ppv )
    {
        if ( riid == IID_IUnknown || riid == IID_IReceiveTest )
        {
            *ppv = (IReceiveTest*)this;
        }
        else if ( riid == IID_IClassFactory )
        {
            *ppv = (IClassFactory*)this;
        }
        else
        {
            return E_NOINTERFACE;
        }
        return S_OK;
    }
    
    STDMETHOD(CreateInstance)( IUnknown* pOuter, REFIID riid, void** ppv )
    {
        return QueryInterface( riid, ppv );
    }

    STDMETHOD(LockServer) (BOOL bLock ) { return S_OK; }

    STDMETHOD(RunTest)( LPCWSTR wszTarget, 
                        DWORD dwFlags, 
                        LPCWSTR wszPrincipal,
                        ULONG cMsgs, 
                        ULONG* pultime );    
    
    STDMETHOD(Kill)() 
    {
        PostThreadMessage( GetCurrentThreadId(), WM_QUIT, 0, 0 );
        return S_OK;
    }
};

struct CTestMsgHandler : public IWmiMessageTraceSink, 
                         public IWmiMessageSendReceive
{
    HRESULT m_hr;
    HANDLE m_hEvent;
    long m_cCurrentMsgs;
    long m_cExpectedMsgs;
    SYSTEMTIME m_Start;

    CTestMsgHandler( long cExpectedMsgs, HANDLE hEvent )
    : m_cExpectedMsgs( cExpectedMsgs ), m_cCurrentMsgs(0), 
      m_hEvent( hEvent ), m_hr( S_OK )
    {
    }

    ~CTestMsgHandler()
    {
        CloseHandle( m_hEvent );
    }

    HRESULT GetResult() { return m_hr; }

    STDMETHOD_(ULONG,AddRef)() { return 1; }
    STDMETHOD_(ULONG,Release)() { return 1; }

    STDMETHOD(QueryInterface)( REFIID riid , void** ppv ) 
    { 
        if ( riid == IID_IWmiMessageTraceSink || 
             riid == IID_IUnknown )
        {
            *ppv = (IWmiMessageTraceSink*)this;
        }
        else if ( riid == IID_IWmiMessageSendReceive )
        {
            *ppv = (IWmiMessageSendReceive*)this;
        }
        if ( *ppv == NULL )
        {
            return E_NOINTERFACE;
        }
        return S_OK;
    }

    void LogMessage( PBYTE pMsg, 
                     ULONG cMsg,
                     PBYTE pAuxData,
                     ULONG cAuxData,
                     DWORD dwFlagStatus,
                     IUnknown* pCtx )
    {
        if ( g_pfLogFile == NULL )
        {
            return;
        }

        IWmiMessageReceiverContext* pRecvCtx;

        pCtx->QueryInterface( IID_IWmiMessageReceiverContext, 
                              (void**)&pRecvCtx );

        SYSTEMTIME st;
        WCHAR awchTime[64];
        pRecvCtx->GetTimeSent( &st );
        swprintf( awchTime, L"%d:%d:%d:%d", st.wHour, 
                 st.wMinute, 
                 st.wSecond, 
                 st.wMilliseconds );
        
        WCHAR awchTarget[256];
        ULONG cTarget;

        pRecvCtx->GetTarget( awchTarget, 256, &cTarget );

        WCHAR awchSource[256];
        ULONG cSource;

        pRecvCtx->GetSendingMachine( awchSource, 256, &cSource );

        WCHAR awchSenderId[256];
        ULONG cSenderId;

        pRecvCtx->GetSenderId( awchSenderId, 256, &cSenderId );

        awchSource[cSource] = '\0';
        awchSenderId[cSenderId] = '\0';
        awchTarget[cTarget] = '\0';

        BOOL bAuth;

        bAuth = pRecvCtx->IsSenderAuthenticated() == S_OK ? TRUE : FALSE;

        fwprintf( g_pfLogFile, L"MSG - #%d, Len:%d, AuxLen:%d, Status:%d, "
                  L"Time:%s, Source:%s, Target:%s, SenderId:%s, Auth:%d\n",   
                  m_cCurrentMsgs, cMsg, cAuxData, dwFlagStatus, 
                  awchTime, awchSource, awchTarget, awchSenderId, bAuth );  
        
        fflush( g_pfLogFile );
    }

    STDMETHOD(Notify)( HRESULT hRes, 
                       GUID guidSource, 
                       LPCWSTR wszError,  
                       IUnknown* pCtx )
    {
        if ( g_pfLogFile != NULL )
        {
            fwprintf( g_pfLogFile, L"Notify : HR=0x%x, ErrorStr : %s\n", 
                      hRes, wszError );
        }

        if ( SUCCEEDED(m_hr) )
        {
            m_hr = hRes;
            SetEvent( m_hEvent );
        }
        return S_OK;
    }

    STDMETHOD(SendReceive)( PBYTE pMsg, 
                            ULONG cMsg,
                            PBYTE pAuxData,
                            ULONG cAuxData,
                            DWORD dwFlagStatus,
                            IUnknown* pCtx )
    {
        LogMessage( pMsg, cMsg, pAuxData, cAuxData, dwFlagStatus, pCtx );

        long cCurrentMsgs = InterlockedIncrement( &m_cCurrentMsgs );

        if ( cCurrentMsgs == 1 )
        {
            GetSystemTime( &m_Start );
        }
        
        if ( cCurrentMsgs >= m_cExpectedMsgs )
        {
            SetEvent( m_hEvent );
        }

        return S_OK;
    }
};

static HANDLE g_hShutdown;

HRESULT CReceiveTest::RunTest( LPCWSTR wszTarget, 
                               DWORD dwFlags, 
                               LPCWSTR wszPrincipal,
                               ULONG cMsgs,
                               ULONG* pulTime )
{
    HRESULT hr;

    CLSID clsidReceiver;

    *pulTime = 0;

    if ( ( dwFlags & WMIMSG_MASK_QOS) != WMIMSG_FLAG_QOS_SYNCHRONOUS )
    {
        clsidReceiver = CLSID_WmiMessageMsmqReceiver;
    }
    else
    {
        clsidReceiver = CLSID_WmiMessageRpcReceiver;
    }        

    CWbemPtr<IWmiMessageReceiver> pReceiver;
    
    hr = CoCreateInstance( clsidReceiver,
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiMessageReceiver,
                           (void**)&pReceiver );
    if ( FAILED(hr) )
    {
        return hr;
    }

    HANDLE hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

    CTestMsgHandler TestHndlr = CTestMsgHandler( cMsgs, hEvent );
     
    WMIMSG_RCVR_AUTH_INFO AuthInfo;

    if ( wszPrincipal != NULL )
    {
        AuthInfo.awszPrincipal = &wszPrincipal;
        AuthInfo.cwszPrincipal = 1;
        hr = pReceiver->Open( wszTarget, dwFlags, &AuthInfo, &TestHndlr );
    }
    else
    {
        hr = pReceiver->Open( wszTarget, dwFlags, NULL, &TestHndlr );
    }

    if ( FAILED(hr) )
    {
        return hr;
    }

    SYSTEMTIME Start, End;

    WaitForSingleObject( hEvent, INFINITE );

    if ( FAILED( TestHndlr.m_hr ) )
    {
        return TestHndlr.m_hr;
    }

    Start = TestHndlr.m_Start;

    GetSystemTime( &End );

    __int64 i64Start, i64End;
    DWORD dwElapsed;
    SystemTimeToFileTime( &Start, PFILETIME(&i64Start) );
    SystemTimeToFileTime( &End, PFILETIME(&i64End) );
    dwElapsed = DWORD(i64End - i64Start) / 10000;

    *pulTime = dwElapsed;

    return S_OK;
};

extern "C" int __cdecl main( int argc, char* argv[] )
{
    if ( argc > 1 )
    {            
        LPCSTR szLogFile = argv[1];

        g_pfLogFile = fopen( szLogFile, "w" );

        if ( g_pfLogFile == NULL )
        {
            printf( "Could not open LogFile %s", szLogFile );
            return 1;
        }
    }

    CoInitializeEx( NULL, COINIT_MULTITHREADED );

    CoInitializeSecurity( NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT,
                          RPC_C_IMP_LEVEL_IDENTIFY, NULL, EOAC_NONE, NULL );

    g_hShutdown = CreateEvent( NULL, TRUE, FALSE, NULL );

    CReceiveTest RcvTest;
    
    HRESULT hr;
    DWORD dwReg;

    hr = CoRegisterClassObject( CLSID_ReceiveTest, 
                                (IClassFactory*)&RcvTest,
                                CLSCTX_LOCAL_SERVER,
                                REGCLS_MULTIPLEUSE,
                                &dwReg );
    if ( FAILED(hr) )
    {
        return 1;
    }

    WaitForSingleObject( g_hShutdown, INFINITE );

    if ( g_pfLogFile != NULL )
    {
        fclose( g_pfLogFile );
    }

    CoRevokeClassObject( dwReg );

    CoUninitialize();
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\test\msgrecv\msgrecv.cpp ===
#include <windows.h>
#include <assert.h>
#include <wmimsg.h>
#include <rcvtest.h>
#include <rcvtest_i.c>
#include <stdio.h>

BOOL g_bVerbose = FALSE;
ULONG g_ulNumMsgs = 1;
LPCWSTR g_wszTarget = NULL;
LPCWSTR g_wszPrincipal = NULL;
DWORD g_dwFlags = 0;
BOOL g_bKill = FALSE;

BOOL ParseArg( LPWSTR wszArg )
{
    WCHAR* pCurr = wszArg;
    
    if ( *pCurr != '/' && *pCurr != '-' )
    {
        g_wszTarget = pCurr;
        return TRUE;
    }

    pCurr++; // remove the / or -

    if ( _wcsicmp( pCurr, L"txn" ) == 0 )
    {
        g_dwFlags &= ~WMIMSG_MASK_QOS;
        g_dwFlags |= WMIMSG_FLAG_QOS_XACT;
    }
    else if ( _wcsicmp( pCurr, L"express" ) == 0 )
    {
        g_dwFlags &= ~WMIMSG_MASK_QOS;
        g_dwFlags |= WMIMSG_FLAG_QOS_EXPRESS;
    }
    else if ( _wcsicmp( pCurr, L"guaranteed" ) == 0 )
    {
        g_dwFlags &= ~WMIMSG_MASK_QOS;
        g_dwFlags |= WMIMSG_FLAG_QOS_GUARANTEED;
    }
    else if ( _wcsicmp( pCurr, L"sync" ) == 0 )
    {
        g_dwFlags &= ~WMIMSG_MASK_QOS;
        g_dwFlags |= WMIMSG_FLAG_QOS_SYNCHRONOUS;
    }
    else if ( _wcsicmp( pCurr, L"ack" ) == 0 )
    {
        g_dwFlags |= WMIMSG_FLAG_RCVR_ACK;
    }
    else if ( _wcsicmp( pCurr, L"verify" ) == 0 )
    {
        g_dwFlags |= WMIMSG_FLAG_RCVR_PRIV_VERIFY;
    }
    else if ( _wcsicmp( pCurr, L"secure" ) == 0 )
    {
        g_dwFlags |= WMIMSG_FLAG_RCVR_SECURE_ONLY;
    }
    else if ( _wcsnicmp( pCurr, L"nummsgs", 7 ) == 0 )
    {
        pCurr += 7;

        if ( *pCurr++ != ':' )
        {
            return FALSE;
        }
        
        g_ulNumMsgs = _wtol( pCurr );
    }
    else if ( _wcsnicmp( pCurr, L"svrprinc", 8 ) == 0 )
    {
        pCurr += 8;

        if ( *pCurr++ != ':' )
        {
            return FALSE;
        }
        
        g_wszPrincipal = pCurr;
    }
    else if ( _wcsicmp( pCurr, L"verbose" ) == 0 )
    {
        g_bVerbose = TRUE;
    }
    else if ( _wcsicmp( pCurr, L"kill" ) == 0 )
    {
        g_bKill = TRUE;
    }
    else
    {
        return FALSE;
    }
    return TRUE;
}

BOOL ParseArgs( int nArgs, LPWSTR* awszArgs )
{
    if ( nArgs < 2 )
    {
        return FALSE;
    }

    for( int i=1; i < nArgs; i++ )
    {
        if ( !ParseArg( awszArgs[i] ) )
        {
            return FALSE;
        }
    }

    return TRUE;
}

extern "C" int __cdecl wmain( int argc, wchar_t* argv[] )
{
    if ( !ParseArgs( argc, argv ) )
    {
        wprintf( L"Usage: msgrcv [-sync|-express|-guaranteed|-txn] \n"
                 L"             [-nummsgs:#] [-ack] [-verify] \n"
                 L"             [-verbose] [-svrprinc:principal] endpoint\n" );
        return 1;
    }

    HRESULT hr;

    CoInitialize( NULL );

    IReceiveTest* pRcvTest;

    hr = CoCreateInstance( CLSID_ReceiveTest,
                           NULL,
                           CLSCTX_LOCAL_SERVER,
                           IID_IReceiveTest,
                           (void**)&pRcvTest );

    if ( FAILED(hr) )
    {
        printf( "Could not CoCI MsgSvr obj. HR = 0x%x\n", hr );
        return 1;
    }

    if ( g_bKill )
    {
        hr = pRcvTest->Kill();

        if ( FAILED(hr) )
        {
            printf("Failed to Kill MsgSvr. HR = 0x%x\n", hr );
            return 1;
        }

        printf("Killed MsgSvr\n");
        return 0;
    }

    ULONG ulElapsed;

    hr = pRcvTest->RunTest( g_wszTarget, 
                            g_dwFlags, 
                            g_wszPrincipal, 
                            g_ulNumMsgs, 
                            &ulElapsed );
    pRcvTest->Release();

    if ( FAILED(hr) )
    {
        printf( "Test Failed. HR = 0x%x\n", hr );
        return 1;
    }

    printf( "Test Succeeded in %d msec.\n", ulElapsed );
    printf( "Rate is %f msg/sec\n", g_ulNumMsgs * 1000.0 / ulElapsed ); 

    CoUninitialize();
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntperf\classmap.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  CLASSMAP.CPP
//  
//  Mapped NT5 Perf Counter Provider
//
//  raymcc      02-Dec-97   Created.        
//  raymcc      20-Feb-98   Updated to use new initializer.
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>

#include <wbemidl.h>

#include <wbemint.h>

#include "flexarry.h"
#include "ntperf.h"
#include "oahelp.inl"



//***************************************************************************
//
//  CClassMapInfo::CClassMapInfo()
//
//  The objective of the map is to have one instance for each CIM class.
//  Internally, a map of perf object ids to CIM property handles is maintained
//  for the class.
//
//  Later, when instances are requested, the blob is retrieved from 
//  HKEY_PERFORMANCE_DATA, and the object IDs in the blob are used to
//  look up the property handles, which are then used to populate instances.
//
//  Property names are never really used except in the mapping phase.
//
//***************************************************************************
// ok

CClassMapInfo::CClassMapInfo()
{
    m_pClassDef = 0;            // The CIM class definition
    m_pszClassName = 0;         // The UNICODE class name

    m_dwObjectId = 0;           // Perf object Id
    m_bSingleton = FALSE;
    m_dwNumProps = 0;           // Number of props in class, size
                                // of the following arrays
                                
    // These are pointers to parallel DWORD arrays, all of the same
    // size (m_dwNumProps)
    // ============================================================
    
    m_pdwIDs = 0;               // IDs of properties
    m_pdwHandles = 0;           // Handles to properties
    m_pdwTypes = 0;             // Types of properties

    m_dwNameHandle = 0;         // The 'Name' property
}


//***************************************************************************
//
//  CClassMapInfo::~CClassMapInfo
//
//***************************************************************************
// ok

CClassMapInfo::~CClassMapInfo()
{
    if (m_pClassDef)
        m_pClassDef->Release();

    delete [] m_pszClassName;
    delete [] m_pdwIDs;
    delete [] m_pdwHandles;
    delete [] m_pdwTypes;
}

//***************************************************************************
//
//  CClassMapInfo::Map()
//
//  Maps the inbound class definition by:
//
//  (1) Retrieving the perf object id from the class definition.
//  (2) Retrieving the property handles, perf ids, and types for each 
//      property.
//
//
//***************************************************************************
// ok

BOOL CClassMapInfo::Map(IWbemClassObject *pObj)
{
    HRESULT hRes;

    // Copy the class definition.
    // ==========================
        
    m_pClassDef = pObj;
    m_pClassDef->AddRef();

    // Get the alternate interface so that we can look up handles.
    // ===========================================================
    
    IWbemObjectAccess *pAlias = 0;
    pObj->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) &pAlias);
    
    // Determine the number of properties and allocate
    // arrays to hold the handles, perf ids, and types.
    // ================================================

    CVARIANT v;
    pObj->Get(CBSTR(L"__PROPERTY_COUNT"), 0, v, 0, 0);
    m_dwNumProps = DWORD(v.GetLONG());

    m_pdwHandles = new DWORD[m_dwNumProps];
    m_pdwIDs = new DWORD[m_dwNumProps];
    m_pdwTypes = new DWORD[m_dwNumProps];
    
    // Clone the class name.
    // =====================

    CVARIANT vClsName;    
    pObj->Get(CBSTR(L"__CLASS"), 0, vClsName, 0, 0);
    m_pszClassName = Macro_CloneLPWSTR(vClsName.GetStr());

    // Get the perf object id for the class.
    // =====================================

    IWbemQualifierSet *pQSet = 0;
    CVARIANT vPerfObjType;

    pObj->GetQualifierSet(&pQSet);
    pQSet->Get(CBSTR(L"PerfIndex"), 0, vPerfObjType, 0);
    m_dwObjectId = DWORD(vPerfObjType.GetLONG());
    
    CVARIANT vSingleton;
    hRes = pQSet->Get(CBSTR(L"Singleton"), 0, vSingleton, 0);
    if (hRes == 0)
        m_bSingleton = TRUE;    

    pQSet->Release();

    
    // Enumerate all the properties and get the object ids
    // and handles for each.
    // ===================================================
    
    pObj->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);

    int nIndex = 0;
    
    while (1)    
    {
        BSTR Name = 0;
                
        hRes = pObj->Next(
            0,
            &Name,
            0,
            0,
            0
            );                

        if (hRes == WBEM_S_NO_MORE_DATA)
            break;

        // Next, get the qualifier set for this property.
        // ==============================================
        
        IWbemQualifierSet *pQSet = 0;
        pObj->GetPropertyQualifierSet(Name, &pQSet);
        
        CVARIANT vCounter;
        hRes = pQSet->Get(CBSTR(L"PerfIndex"), 0, &vCounter, 0);
        pQSet->Release();
        if (hRes)
            vCounter.SetLONG(0);

        // Get the property handle and type.
        // =================================
        
        LONG  lType = 0;
        LONG  lHandle = 0;
        pAlias->GetPropertyHandle(Name, &lType, &lHandle);

        FILE *f = fopen("log", "at");
        fprintf(f, "Prop <%S> Handle = 0x%X  PerfIx=%d\n", Name, lHandle, vCounter.GetLONG());
        fclose(f);

        // We now know the counter id, the property handle and its
        // type.  That is all we really need at runtime to map
        // blobs into CIM object.
        // =======================================================

        m_pdwIDs[nIndex] = (DWORD) vCounter.GetLONG();        
        m_pdwHandles[nIndex] = (DWORD) lHandle;
        m_pdwTypes[nIndex] = (DWORD) lType;
        
        // Free the name.
        // ==============        
        
        SysFreeString(Name);    
        nIndex++;
    }    

    // Get the handle of the 'name' property.
    // ======================================

    pAlias->GetPropertyHandle(L"Name", 0, (LONG *) &m_dwNameHandle);

    // Cleanup.
    // ========

    SortHandles();
        
    pObj->EndEnumeration();
    pAlias->Release();
    return TRUE;
}

//***************************************************************************
//
//  CClassMapInfo::SortHandles
//
//  Sort the perf object ids for quick searching later in the GetPropHandle
//  method.
//
//***************************************************************************
void CClassMapInfo::SortHandles()
{
    // Simple selection sort.  The number of elements is so small
    // and this is only done once, so a quicksort / shellsort would be
    // overkill.
    // ===============================================================

    for (DWORD dwOuter = 0; dwOuter < m_dwNumProps - 1; dwOuter++)
    {
        for (DWORD dwInner = dwOuter + 1; dwInner < m_dwNumProps; dwInner++)
        {
            if (m_pdwIDs[dwInner] < m_pdwIDs[dwOuter])
            {
                DWORD dwTemp = m_pdwIDs[dwInner];
                m_pdwIDs[dwInner] = m_pdwIDs[dwOuter];
                m_pdwIDs[dwOuter] = dwTemp;

                dwTemp = m_pdwHandles[dwInner];
                m_pdwHandles[dwInner] = m_pdwHandles[dwOuter];
                m_pdwHandles[dwOuter] = dwTemp;

                dwTemp = m_pdwTypes[dwInner];
                m_pdwTypes[dwInner] = m_pdwTypes[dwOuter];
                m_pdwTypes[dwOuter] = dwTemp;
            }
        }
    }
}


//***************************************************************************
//
//  CClassMapInfo::GetPropHandle
//
//  Gets the property handle for a corresponding perf counter id.
//  Returns 0 if not found.
//
//***************************************************************************
LONG CClassMapInfo::GetPropHandle(DWORD dwId)
{
    // Binary search.
    // ==============

    DWORD l = 0, u = m_dwNumProps - 1;
    DWORD m;

    while (l <= u)
    {
        m = (l + u) / 2;

        if (dwId < m_pdwIDs[m])
            u = m - 1;
        else if (dwId > m_pdwIDs[m])
            l = m + 1;
        else    // Hit!
            return m_pdwHandles[m];
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\test\acctest\acctest.cpp ===
#include <wbemcli.h>
#include <wmimsg.h>
#include <comutl.h>
#include <stdio.h>
#include <arrtempl.h>
#include <flexarry.h>
#include <wstring.h>

IWbemServices* g_pSvc;
IWmiObjectAccessFactory* g_pAccessFactory;

HRESULT RecurseProps( IWbemClassObject* pInst,
                      LPCWSTR wszPropPrefix,
                      CFlexArray& aPropHandles,
                      CFlexArray& aEmbeddedPropHandles )
{
    HRESULT hr;

    hr = pInst->BeginEnumeration( WBEM_FLAG_NONSYSTEM_ONLY );

    if ( FAILED(hr) )
    {
        return hr;
    }

    BSTR bstrName;
    VARIANT v;
    CIMTYPE ct;

    while( (hr = pInst->Next( 0, &bstrName, &v, &ct, NULL )) == S_OK )
    {
        CSysFreeMe sfm( bstrName ); 
        CClearMe cmv( &v );

        WString wsPropName = wszPropPrefix;
        wsPropName += bstrName;
        
        LPVOID pvHdl;
        hr = g_pAccessFactory->GetPropHandle( wsPropName, 0, &pvHdl ); 

        if ( SUCCEEDED(hr) )
        {
            if ( ct == CIM_OBJECT && V_VT(&v) == VT_UNKNOWN )
            {
                wsPropName += L".";

                CWbemPtr<IWbemClassObject> pEmbedded;

                V_UNKNOWN(&v)->QueryInterface( IID_IWbemClassObject, 
                                               (void**)&pEmbedded );
                
                aEmbeddedPropHandles.Add( pvHdl );

                hr = RecurseProps( pEmbedded, 
                                   wsPropName, 
                                   aPropHandles,
                                   aEmbeddedPropHandles );
            }
            else
            {
                //
                // don't need to add embedded objects to the list since 
                // we have them covered by recursing their properties.
                //
                aPropHandles.Add( pvHdl );
            }
        }

        if ( FAILED(hr) )
        {
            break;
        }
    }

    pInst->EndEnumeration();

    return hr;
}

HRESULT DeepCopyTest( IWbemClassObject* pClass,
                      IWbemClassObject* pInstance,
                      IWbemClassObject* pTemplate )
{
    HRESULT hr;

    //
    // if a template, then set it on the access factory.
    //

    if ( pTemplate != NULL )
    {
        hr = g_pAccessFactory->SetObjectTemplate( pTemplate );
        
        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    //
    // enumerate all the properties of this object and those of all 
    // nested objects.  As we enumerate, get the access handles.
    //

    CFlexArray aPropHandles;
    CFlexArray aEmbeddedPropHandles;

    hr = RecurseProps( pInstance, NULL, aPropHandles, aEmbeddedPropHandles );

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // spawn a new instance to copy into
    // 

    CWbemPtr<IWbemClassObject> pCopy;

    hr = pClass->SpawnInstance( 0, &pCopy );

    //
    // grab accessors for the original and target objects.
    // 

    CWbemPtr<IWmiObjectAccess> pOrigAccess, pCopyAccess;

    hr = g_pAccessFactory->GetObjectAccess( &pOrigAccess );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = g_pAccessFactory->GetObjectAccess( &pCopyAccess );

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pOrigAccess->SetObject( pInstance ); 

    if ( FAILED(hr) )
    {
        return hr;
    }

    hr = pCopyAccess->SetObject( pCopy ); 

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // first need to spawn any contained instances and set them on the new 
    // object before we can copy the props.
    // 

    for( int i=0; i < aEmbeddedPropHandles.Size(); i++ )
    {
        CPropVar v;
        CIMTYPE ct;

        hr = pOrigAccess->GetProp( aEmbeddedPropHandles[i], 0, &v, &ct );

        if ( FAILED(hr) )
        {
            return hr;
        }

        if ( V_VT(&v) != VT_UNKNOWN )
        {
            return WBEM_E_CRITICAL_ERROR;
        }

        //
        // spawn a new instance from the class of the object.
        // 

        CWbemPtr<IWbemClassObject> pEmbedded;

        hr = V_UNKNOWN(&v)->QueryInterface( IID_IWbemClassObject, 
                                            (void**)&pEmbedded );

        if ( FAILED(hr) )
        {
            return hr;
        }

        CPropVar vClass;

        hr = pEmbedded->Get( L"__CLASS", 0, &vClass, NULL, NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }
        
        CWbemPtr<IWbemClassObject> pEmbeddedClass;

        hr = g_pSvc->GetObject( V_BSTR(&vClass),
                                0, 
                                NULL, 
                                &pEmbeddedClass, 
                                NULL );

        if ( FAILED(hr) )
        {
            return hr;
        }

        CWbemPtr<IWbemClassObject> pNewEmbedded;

        hr = pEmbeddedClass->SpawnInstance( 0, &pNewEmbedded );

        if ( FAILED(hr) )
        {
            return hr;
        }

        VARIANT vEmbedded;
        V_VT(&vEmbedded) = VT_UNKNOWN;
        V_UNKNOWN(&vEmbedded) = pNewEmbedded;
        
        hr = pCopyAccess->PutProp( aEmbeddedPropHandles[i], 0, &vEmbedded, ct);

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    hr = pCopyAccess->CommitChanges();

    if ( FAILED(hr) )
    {
        return hr;
    }

    //
    // copy all the properties to the new object.
    //

    for( int i=0; i < aPropHandles.Size(); i++ )
    {
        CPropVar v;
        CIMTYPE ct;

        hr = pOrigAccess->GetProp( aPropHandles[i], 0, &v, &ct );

        if ( FAILED(hr) )
        {
            return hr;
        }

        hr = pCopyAccess->PutProp( aPropHandles[i], 0, &v, ct );

        if ( FAILED(hr) )
        {
            return hr;
        }
    }

    hr = pCopyAccess->CommitChanges();

    if ( FAILED(hr) )
    {
        return hr;
    }
    
    //
    // compare objects. should be same
    //

    CWbemBSTR bsOrigText, bsCopyText;

    pInstance->GetObjectText( 0, &bsOrigText );
    pCopy->GetObjectText( 0, &bsCopyText );

    printf("Original instance looks like ... %S\n", bsOrigText );
    printf("Copied instance looks like ... %S\n", bsCopyText );

    hr = pCopy->CompareTo( 0, pInstance );

    if ( FAILED(hr) )
    {
        return hr;
    }
    else if ( hr == WBEM_S_DIFFERENT )
    {
        return WBEM_E_FAILED;
    }

    return WBEM_S_NO_ERROR;
}
                      

int TestMain( LPCWSTR wszInstancePath, LPCWSTR wszTemplatePath )
{
    HRESULT hr;

    CWbemPtr<IWbemLocator> pLocator;

    hr = CoCreateInstance( CLSID_WbemLocator, 
                           NULL, 
                           CLSCTX_SERVER,
                           IID_IWbemLocator, 
                           (void**)&pLocator );
    if ( FAILED(hr) )
    {
        printf("ERROR CoCIing WbemLocator : hr = 0x%x\n",hr);
        return 1;
    }

    CWbemPtr<IWbemServices> pSvc;

    hr = pLocator->ConnectServer( L"root\\default",
                                  NULL, 
                                  NULL,
                                  NULL, 
                                  0, 
                                  NULL, 
                                  NULL, 
                                  &pSvc );
    if ( FAILED(hr) )
    {
        wprintf( L"ERROR Connecting to root\\default namespace : hr=0x%x\n",hr);
        return 1;
    } 

    g_pSvc = pSvc;

    CWbemPtr<IWbemClassObject> pInst;

    hr = pSvc->GetObject( CWbemBSTR(wszInstancePath), 
                          0, 
                          NULL, 
                          &pInst, 
                          NULL );
    if ( FAILED(hr) )
    {
        printf( "Failed getting test accessor instance : hr=0x%x\n", hr );
        return 1;
    }

    CWbemPtr<IWbemClassObject> pTemplate;

    if ( wszTemplatePath != NULL )
    {
        //
        // test object to use for template.
        // 
        
        hr = pSvc->GetObject( CWbemBSTR(wszTemplatePath), 
                              0, 
                              NULL, 
                              &pTemplate, 
                              NULL );
        if ( FAILED(hr) )
        {
            printf( "Failed getting test accessor template : hr=0x%x\n", hr );
            return 1;
        }
    }

    //
    // get the class object for the instance to use to spawn instances.
    // 

    CPropVar vClass;
    CWbemPtr<IWbemClassObject> pClass;

    hr = pInst->Get( L"__CLASS", 0, &vClass, NULL, NULL );

    if ( SUCCEEDED(hr) )
    {
        hr = pSvc->GetObject( V_BSTR(&vClass), 0, NULL, &pClass, NULL );
    }

    if ( FAILED(hr) )
    {
        printf("Couldn't get class object for test accessor instance "
               ": hr=0x%x\n", hr );
        return hr;
    }

    //
    // create the accessor factory
    //

    CWbemPtr<IWmiObjectAccessFactory> pAccessFactory;

    hr = CoCreateInstance( CLSID_WmiSmartObjectAccessFactory, 
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiObjectAccessFactory,
                           (void**)&pAccessFactory );
    if ( FAILED(hr) )
    {
        printf("Failed CoCIing WmiSmartObjectAccessFactory. HR = 0x%x\n", hr);
        return 1;
    }

    g_pAccessFactory = pAccessFactory;

    hr = DeepCopyTest( pClass, pInst, pTemplate );

    if ( SUCCEEDED(hr) )
    {
        printf( "Successful Deep Copy Test for instance.\n" ); 
    }
    else
    {
        printf( "Failed Deep Copy Test for instance. HR=0x%x\n", hr );
    }

    return 0;
}

extern "C" int __cdecl wmain( int argc, WCHAR** argv )
{ 
    if ( argc < 2 )
    {
        printf( "Usage: acctest <instancepath> [<templatepath>]\n" );
        return 1;
    }

    CoInitialize( NULL );

    TestMain( argv[1], argc < 3 ? NULL : argv[2] );

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntperf\classmap.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  class CClassMapInfo
//
//***************************************************************************

#ifndef _CLASSMAP_H_
#define _CLASSMAP_H_

class CClassMapInfo
{
    IWbemClassObject *m_pClassDef;
    
    LPWSTR m_pszClassName;
    BOOL   m_bSingleton;
    DWORD  m_dwObjectId;

    LONG   m_dwNameHandle;

    DWORD  m_dwNumProps;    
    DWORD *m_pdwIDs;
    DWORD *m_pdwHandles;
    DWORD *m_pdwTypes;

    friend class CNt5PerfProvider;
    friend class PerfHelper;

    void SortHandles();
            
public:
    CClassMapInfo();
   ~CClassMapInfo();
   
    BOOL Map(
        IWbemClassObject *pObj
        ); 

    LONG GetPropHandle(DWORD dwId);
    DWORD GetObjectId() { return m_dwObjectId; }
    BOOL IsSingleton() { return m_bSingleton; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\test\msgqueue\msgqueue.cpp ===
#include <windows.h>
#include <wmimsg.h>
#include <comutl.h>
#include "stdio.h"

LPWSTR g_wszQueue;
DWORD g_dwNumQueues = 1;
DWORD g_dwQuota = 0xffffffff;
DWORD g_dwQos = WMIMSG_FLAG_QOS_EXPRESS;

BOOL g_bAuth = FALSE;
BOOL g_bDestroy = FALSE;
BOOL g_bCreate = FALSE;
BOOL g_bVerbose = FALSE;
GUID g_guidType = { 0x5b6ef4a4, 0x931, 0x46a4, 
                   {0xa5,0xa9,0x8e,0x4,0xfc,0xcd,0xb0,0xd5} };

BOOL ParseArg( LPWSTR wszArg )
{
    WCHAR* pCurr = wszArg;
        
    if ( *pCurr != '/' && *pCurr != '-' )
    {
        g_wszQueue = pCurr;
        return TRUE;
    }

    pCurr++; // remove the / or -
    
    if ( _wcsicmp( pCurr, L"auth" ) == 0 )
    {
        g_bAuth = TRUE;
    }
    else if ( _wcsicmp( pCurr, L"create" ) == 0 )
    {
        g_bCreate = TRUE;
    }
    else if ( _wcsicmp( pCurr, L"destroy" ) == 0 )
    {
        g_bDestroy = TRUE;
    }
    else if ( _wcsicmp( pCurr, L"txn" ) == 0 )
    {
        g_dwQos = WMIMSG_FLAG_QOS_XACT;
    }
    else if ( _wcsicmp( pCurr, L"express" ) == 0 )
    {
        g_dwQos = WMIMSG_FLAG_QOS_EXPRESS;
    }
    else if ( _wcsicmp( pCurr, L"guaranteed" ) == 0 )
    {
        g_dwQos = WMIMSG_FLAG_QOS_GUARANTEED;
    }
    else if ( _wcsicmp( pCurr, L"verbose") == 0 )
    {
        g_bVerbose = TRUE;
    }
    else if ( _wcsnicmp( pCurr, L"quota", 5 ) == 0 )
    {
        pCurr += 5;
        
        if ( *pCurr++ != ':' )
        {
            return FALSE;
        }

        g_dwQuota = _wtol( pCurr );
    }
    else if ( _wcsnicmp( pCurr, L"numqueues", 9 ) == 0 )
    {
        pCurr += 9;
        
        if ( *pCurr++ != ':' )
        {
            return FALSE;
        }

        g_dwNumQueues = _wtol( pCurr );
    }
    else if ( _wcsnicmp( pCurr, L"type", 4 ) == 0 )
    {
        pCurr += 4;
        
        if ( *pCurr++ != ':' )
        {
            return FALSE;
        }

        if ( FAILED( CLSIDFromString( pCurr, &g_guidType ) ) )
        {
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }
    return TRUE;
}

BOOL ParseArgs( int nArgs, LPWSTR* awszArgs )
{
    if ( nArgs < 1 )
    {
        return FALSE;
    }

    for( int i=1; i < nArgs; i++ )
    {
        if ( !ParseArg( awszArgs[i] ) )
        {
            return FALSE;
        }
    }

    if ( (g_bCreate || g_bDestroy) && g_wszQueue == NULL )
    {
        return FALSE;
    }

    return TRUE;
}

int TestMain()
{
    HRESULT hr;
    
    CWbemPtr<IWmiMessageQueueManager> pQueueMgr;

    hr = CoCreateInstance( CLSID_WmiMessageQueueManager, 
                           NULL, 
                           CLSCTX_INPROC, 
                           IID_IWmiMessageQueueManager,
                           (void**)&pQueueMgr );

    if ( FAILED(hr) )
    {
        printf( "Failed Obtaining Queue Object. HR = 0x%x\n", hr );
        return 1;
    }

    WCHAR awchQueue[256];    
    
    SYSTEMTIME Start, End;

    GetSystemTime( &Start );

    if ( g_bCreate )
    {
        wcscpy( awchQueue, g_wszQueue );

        hr = pQueueMgr->Create( awchQueue, 
                                g_guidType,
                                g_bAuth,
                                g_dwQos,
                                g_dwQuota,
                                NULL );
    
        for( DWORD i=1; i < g_dwNumQueues && SUCCEEDED(hr); i ++ )
        {
            swprintf( awchQueue, L"%s%d", g_wszQueue, i );
            
            hr = pQueueMgr->Create( awchQueue,
                                    g_guidType,
                                    g_bAuth,
                                    g_dwQos,
                                    g_dwQuota,
                                    NULL );
        }

        if ( FAILED(hr) )
        {
            wprintf( L"Failed Creating Queue with name %s. HR = 0x%x\n",
                     awchQueue, hr );
            return 1;
        }
    }

    if ( g_bDestroy )
    {
        wcscpy( awchQueue, g_wszQueue );

        hr = pQueueMgr->Destroy( awchQueue );
    
        if ( FAILED(hr) )
        {
            wprintf( L"Failed Destroying Queue with name %s. HR = 0x%x\n",
                     awchQueue, hr );
        }

        for( ULONG i=1; i < g_dwNumQueues; i ++ )
        {
            swprintf( awchQueue, L"%s%d", g_wszQueue, i );            
            
            hr = pQueueMgr->Destroy( awchQueue );
            
            if ( FAILED(hr) )
            {
                wprintf( L"Failed Destroying Queue with name %s. HR = 0x%x\n",
                         awchQueue, hr );
            }
        }
    }

    if ( g_bVerbose )
    {
        WCHAR achType[256];
        StringFromGUID2( g_guidType, achType, 256 ); 

        wprintf( L"Getting all Names for Type : %s\n", achType );

        LPWSTR* pwszNames;
        ULONG cwszNames;

        hr = pQueueMgr->GetAllNames(g_guidType, TRUE, &pwszNames, &cwszNames );

        if ( FAILED(hr) )
        {
            wprintf( L"Failed Getting All Queue Names. HR = 0x%x\n" );
            return 1;
        }

        for( ULONG i=0; i < cwszNames; i++ )
        {
            wprintf( L"    %s\n", pwszNames[i] );
            CoTaskMemFree( pwszNames[i] );
        }
        
        CoTaskMemFree( pwszNames );
    }

    GetSystemTime( &End );

    __int64 i64Start, i64End;
    DWORD dwElapsed;
    SystemTimeToFileTime( &Start, PFILETIME(&i64Start) );
    SystemTimeToFileTime( &End, PFILETIME(&i64End) );
    dwElapsed = DWORD(i64End - i64Start) / 10000;
    
    printf("Test Completed in %d msec!\n", dwElapsed );

    return 0;
}

extern "C" int __cdecl wmain( int argc, wchar_t** argv )
{
    CoInitialize( NULL );

    if ( !ParseArgs( argc, argv ) )
    {
        wprintf( L"Usage : msgqueue [-express|-guaranteed|-txn] \n"
                 L"                 [-auth] [-numqueues:#] [-quota:#]\n"
                 L"                 [-create] [-destroy] [-verbose]\n"
                 L"                 [-type:clsid] <queuename>\n");   
        return 1;
    }

    int ret = TestMain();

    CoUninitialize();

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\test\mrshtest\mrshtest.cpp ===
#include <wbemcli.h>
#include <wmimsg.h>
#include <comutl.h>
#include <stdio.h>

BOOL MarshalTest( IWmiObjectMarshal* pMrsh,
                  IWmiObjectMarshal* pUnmrsh,
                  IWbemClassObject* pObj, 
                  DWORD dwFlags )
{
    HRESULT hr;

    //
    // pack original object into buffer 
    //

    ULONG cLen;

    hr = pMrsh->Pack( pObj, NULL, dwFlags, 0, NULL, &cLen );

    if ( FAILED(hr) && hr != WBEM_E_BUFFER_TOO_SMALL )
    {
        return FALSE;
    }

    PBYTE pBuff = new BYTE[cLen];

    if ( pBuff == NULL )
    {
        return FALSE;
    }

    ULONG cUsed;

    hr = pMrsh->Pack( pObj, NULL, dwFlags, cLen, pBuff, &cUsed );

    if ( FAILED(hr) )
    {
        delete [] pBuff;
        return FALSE;
    }

    ULONG cPacked = cUsed;

    //
    // unpack buffer into new object 
    // 

    CWbemPtr<IWbemClassObject> pNewObj;

    hr = pUnmrsh->Unpack( cLen, pBuff, dwFlags, &pNewObj, &cUsed );

//    delete [] pBuff;

    if ( FAILED(hr) || cUsed != cPacked )
    {
        return FALSE;
    }

    //
    // compare original and new objects
    //

    hr = pNewObj->CompareTo( WBEM_FLAG_IGNORE_OBJECT_SOURCE, pObj );    

    if ( hr != WBEM_S_SAME )
    {
        return FALSE;
    }

    delete [] pBuff;

    return TRUE;
}

int TestMain()
{
    HRESULT hr;

    CWbemPtr<IWbemLocator> pLocator;

    hr = CoCreateInstance( CLSID_WbemLocator, 
                           NULL, 
                           CLSCTX_SERVER,
                           IID_IWbemLocator, 
                           (void**)&pLocator );
    if ( FAILED(hr) )
    {
        printf("ERROR CoCIing WbemLocator : hr = 0x%x\n",hr);
        return 1;
    }

    CWbemPtr<IWbemServices> pSvc;

    hr = pLocator->ConnectServer( L"root\\default",
                                  NULL, 
                                  NULL,
                                  NULL, 
                                  0, 
                                  NULL, 
                                  NULL, 
                                  &pSvc );
    if ( FAILED(hr) )
    {
        wprintf( L"ERROR Connecting to root\\default namespace : hr=0x%x\n",hr);
        return 1;
    } 

    CWbemPtr<IWbemClassObject> pClass;

    hr = pSvc->GetObject( CWbemBSTR(L"TestMarshalClass"), 
                          0, 
                          NULL, 
                          &pClass, 
                          NULL );
    if ( FAILED(hr) )
    {
        printf( "Failed getting test marshal class : hr=0x%x\n", hr );
        return 1;
    }

    CWbemPtr<IWbemClassObject> pObj;

    hr = pSvc->GetObject( CWbemBSTR(L"TestMarshalClass='BasicObject'"), 
                          0, 
                          NULL, 
                          &pObj, 
                          NULL );
    if ( FAILED(hr) )
    {
        printf( "Failed getting test marshal object : hr=0x%x\n", hr );
        return 1;
    }

    CWbemPtr<IWmiObjectMarshal> pMrsh, pUnmrsh;

    hr = CoCreateInstance( CLSID_WmiSmartObjectMarshal, 
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiObjectMarshal,
                           (void**)&pMrsh );

    hr = CoCreateInstance( CLSID_WmiSmartObjectUnmarshal, 
                           NULL,
                           CLSCTX_INPROC,
                           IID_IWmiObjectMarshal,
                           (void**)&pUnmrsh );

    if ( FAILED(hr) )
    {
        printf("Failed CoCIing WmiSmartObjectMarshal. HR = 0x%x\n", hr);
        return 1;
    }
                              
    if ( MarshalTest( pMrsh, pUnmrsh, pClass, WMIMSG_FLAG_MRSH_FULL ) )
    {
        printf( "Successful Marshal Test w/ Class Object and FULL Flag\n" ); 
    }
    else
    {
        printf( "Failed Marshal Test w/ Class Object and FULL Flag\n" );
    }

    if ( MarshalTest( pMrsh, pUnmrsh, pObj, WMIMSG_FLAG_MRSH_FULL ) )
    {
        printf( "Successful Marshal Test w/ Instance and FULL Flag\n" ); 
    }
    else
    {
        printf( "Failed Marshal Test w/ Instance and FULL Flag\n" );
    }

    if ( MarshalTest( pMrsh, pUnmrsh, pObj, WMIMSG_FLAG_MRSH_PARTIAL ) )
    {
        printf( "Successful Marshal Test w/ Instance and PARTIAL Flag\n" ); 
    }
    else
    {
        printf( "Failed Marshal Test w/ Instance and PARTIAL Flag\n" );
    }

    if ( MarshalTest( pMrsh, pUnmrsh, pObj, WMIMSG_FLAG_MRSH_PARTIAL ) )
    {
        printf( "Successful Repeated Marshal Test w/ Instance and PARTIAL Flag\n" ); 
    }
    else
    {
        printf( "Failed Repeated Marshal Test w/ Instance and PARTIAL Flag\n" );
    }

    if ( MarshalTest( pMrsh, pUnmrsh, pObj, WMIMSG_FLAG_MRSH_FULL_ONCE ) )
    {
        printf( "Successful Marshal Test w/ Instance and FULL_ONCE Flag\n" ); 
    }
    else
    {
        printf( "Failed Marshal Test w/ Instance and FULL_ONCE Flag\n" );
    }

    if ( MarshalTest( pMrsh, pUnmrsh, pObj, WMIMSG_FLAG_MRSH_FULL_ONCE ) )
    {
        printf( "Successful Repeated Marshal Test w/ Instance and FULL_ONCE Flag\n" ); 
    }
    else
    {
        printf( "Failed Repeated Marshal Test w/ Instance and FULL_ONCE Flag\n" );
    }

    return 0;
}

extern "C" int __cdecl wmain( int argc, WCHAR** argv )
{ 
    CoInitialize( NULL );

    TestMain();

    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\msg\test\msgsend\msgsend.cpp ===
#include <windows.h>
#include <wmimsg.h>
#include <comutl.h>
#include "stdio.h"

ULONG g_cTargets = 0;
LPWSTR g_awszTargets[256];
LPWSTR g_wszAckTarget = NULL;
LPWSTR g_wszTargetPrincipal = NULL;
DWORD g_dwFlags = 0;
ULONG g_ulNumMsgs = 1;
ULONG g_ulSizeMsg = 256;
BOOL g_bVerbose = FALSE;

class CTestErrorSink : public IWmiMessageTraceSink
{
public:
    STDMETHOD_(ULONG,AddRef)() { return 1; }
    STDMETHOD_(ULONG,Release)() { return 1; }
    STDMETHOD(QueryInterface)( REFIID, void** ) { return E_NOINTERFACE; }
    STDMETHOD(Notify)( HRESULT hRes, 
                       GUID guidSource, 
                       LPCWSTR wszTrace, 
                       IUnknown* pCtx )
    {
        if ( FAILED(hRes) )
        {
            wprintf(L"Error: %s, HR: 0x%x\n", wszTrace, hRes );
        }
        else if ( g_bVerbose ) 
        {
            wprintf(L"Trace: %s, HR: 0x%x\n", wszTrace, hRes );
        }

        return S_OK;
    }
};

BOOL ParseArg( LPWSTR wszArg )
{
    WCHAR* pCurr = wszArg;
        
    if ( *pCurr != '/' && *pCurr != '-' )
    {
        g_awszTargets[g_cTargets++] = pCurr;
        return TRUE;
    }

    pCurr++; // remove the / or -
    
    if ( _wcsicmp( pCurr, L"auth" ) == 0 )
    {
        g_dwFlags |= WMIMSG_FLAG_SNDR_AUTHENTICATE;
    }
    else if ( _wcsicmp( pCurr, L"encrypt" ) == 0 )
    {
        g_dwFlags |= WMIMSG_FLAG_SNDR_ENCRYPT;
    }
    else if ( _wcsicmp( pCurr, L"txn" ) == 0 )
    {
        g_dwFlags &= ~WMIMSG_MASK_QOS;
        g_dwFlags |= WMIMSG_FLAG_QOS_XACT;
    }
    else if ( _wcsicmp( pCurr, L"express" ) == 0 )
    {
        g_dwFlags &= ~WMIMSG_MASK_QOS;
        g_dwFlags |= WMIMSG_FLAG_QOS_EXPRESS;
    }
    else if ( _wcsicmp( pCurr, L"guaranteed" ) == 0 )
    {
        g_dwFlags &= ~WMIMSG_MASK_QOS;
        g_dwFlags |= WMIMSG_FLAG_QOS_GUARANTEED;
    }
    else if ( _wcsicmp( pCurr, L"sync" ) == 0 )
    {
        g_dwFlags &= ~WMIMSG_MASK_QOS;
        g_dwFlags |= WMIMSG_FLAG_QOS_SYNCHRONOUS;
    }
    else if ( _wcsicmp( pCurr, L"verbose") == 0 )
    {
        g_bVerbose = TRUE;
    }
    else if ( _wcsicmp( pCurr, L"sign") == 0 )
    {
        g_dwFlags |= WMIMSG_FLAG_SNDR_PRIV_SIGN;
    }
    else if ( _wcsnicmp( pCurr, L"ack", 3 ) == 0 )
    {
        pCurr += 3;
        
        if ( *pCurr++ != ':' )
        {
            return FALSE;
        }

        g_wszAckTarget = pCurr;
    }
    else if ( _wcsnicmp( pCurr, L"tgtprinc", 8 ) == 0 )
    {
        pCurr += 8;
        
        if ( *pCurr++ != ':' )
        {
            return FALSE;
        }

        g_wszTargetPrincipal = pCurr;
    }
    else if ( _wcsnicmp( pCurr, L"nummsgs", 7 ) == 0 )
    {
        pCurr += 7;
        
        if ( *pCurr++ != ':' )
        {
            return FALSE;
        }

        g_ulNumMsgs = _wtol( pCurr );
    }
    else if ( _wcsnicmp( pCurr, L"msgsize", 7 ) == 0 )
    {
        pCurr += 7;
        
        if ( *pCurr++ != ':' )
        {
            return FALSE;
        }

        g_ulSizeMsg = _wtol( pCurr );
    }
    else
    {
        return FALSE;
    }
    return TRUE;
}

BOOL ParseArgs( int nArgs, LPWSTR* awszArgs )
{
    if ( nArgs < 2 )
    {
        return FALSE;
    }

    for( int i=1; i < nArgs; i++ )
    {
        if ( !ParseArg( awszArgs[i] ) )
        {
            return FALSE;
        }
    }

    return TRUE;
}

int TestMain( CLSID ClsidSender )
{
    HRESULT hr;
    
    CWbemPtr<IWmiMessageSender> pSender;

    hr = CoCreateInstance( ClsidSender, 
                           NULL, 
                           CLSCTX_INPROC, 
                           IID_IWmiMessageSender,
                           (void**)&pSender );

    if ( FAILED(hr) )
    {
        printf( "Failed Creating Sender. HR = 0x%x\n", hr );
        return 1;
    }

    CWbemPtr<IWmiMessageMultiSendReceive> pMultiSend;

    hr = CoCreateInstance( CLSID_WmiMessageMultiSendReceive, 
                           NULL, 
                           CLSCTX_INPROC, 
                           IID_IWmiMessageMultiSendReceive,
                           (void**)&pMultiSend );

    if ( FAILED(hr) )
    {
        printf( "Failed Creating Multi Send. HR = 0x%x\n", hr );
        return 1;
    }

    CTestErrorSink ErrorSink;

    for( ULONG i=0; i < g_cTargets; i++ )
    {
        CWbemPtr<IWmiMessageSendReceive> pSend;

        WMIMSG_SNDR_AUTH_INFO AuthInfo;
        ZeroMemory( &AuthInfo, sizeof(WMIMSG_SNDR_AUTH_INFO) );

        AuthInfo.wszTargetPrincipal = g_wszTargetPrincipal;

        hr = pSender->Open( g_awszTargets[i],
                            g_dwFlags,
                            &AuthInfo,
                            g_wszAckTarget,
                            &ErrorSink,
                            &pSend );
        if ( FAILED(hr) )
        {
            printf( "Failed Opening Sender. HR = 0x%x\n", hr );
            return 1;
        }

        hr = pMultiSend->Add( 0, pSend );

        if ( FAILED(hr) )
        {
            printf( "Failed Adding to Multi Send. HR = 0x%x\n", hr );
            return 1;
        }
    }

    BYTE* pMsg = new BYTE[g_ulSizeMsg];
    BYTE achAuxMsg[256];

    for( i=0; i < g_ulNumMsgs; i++ )
    {
        hr = pMultiSend->SendReceive( pMsg, g_ulSizeMsg, achAuxMsg, 256, 0, NULL );

        if ( FAILED(hr) )
        {
            printf( "Failed sending message. HR = 0x%x\n", hr );
            return 1;
        }
    }

    printf("Test Complete!\n");

    return 0;
}

extern "C" int __cdecl wmain( int argc, wchar_t** argv )
{
    CoInitialize( NULL );

    if ( !ParseArgs( argc, argv ) )
    {
        wprintf( L"Usage : msgsend [-sync|-express|-guaranteed|-txn] \n"
                 L"                [-auth] [-encrypt] [-ack:target] \n"
                 L"                [-nummsgs:#] [-msgsize:#] [-sign]\n"
                 L"                [-verbose] [-tgtprinc:princname] \n"
                 L"                target1 target2..\n"); 
                        
        return 1;
    }

    DWORD dwQos = g_dwFlags & WMIMSG_MASK_QOS;

    if ( g_bVerbose )
    {
        if (g_dwFlags & WMIMSG_FLAG_SNDR_AUTHENTICATE) printf( "-Authenticate\n" );
        if ( g_dwFlags & WMIMSG_FLAG_SNDR_ENCRYPT ) printf( "-Encryption\n" );
        if ( dwQos == WMIMSG_FLAG_QOS_SYNCHRONOUS  ) printf( "-Sync QoS\n" );
        if ( dwQos == WMIMSG_FLAG_QOS_EXPRESS ) printf( "-Express QoS\n" );
        if ( dwQos == WMIMSG_FLAG_QOS_GUARANTEED ) printf("-Guaranteed QoS\n");
        if ( dwQos == WMIMSG_FLAG_QOS_XACT ) printf( "-Xact QoS\n" );

        if ( g_wszAckTarget != NULL )
        {
            wprintf( L"-Ack Target: %s \n", g_wszAckTarget );
        }
        
        if ( g_wszTargetPrincipal != NULL )
        {
            wprintf( L"-Target Principal: %s \n", g_wszTargetPrincipal );
        }

        for( ULONG i=0; i < g_cTargets; i++ )
        {
            wprintf( L"-Target: %s \n", g_awszTargets[i] );
        }

        printf( "---------------------------------\n\n" );
    }

    CLSID ClsidSender;

    if ( dwQos == WMIMSG_FLAG_QOS_SYNCHRONOUS )
    {
        ClsidSender = CLSID_WmiMessageRpcSender;
    }
    else
    {
        ClsidSender = CLSID_WmiMessageMsmqSender;
    }

    int ret = TestMain( ClsidSender );

    CoUninitialize();

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntperf\flexarry.h ===
//***************************************************************************
//
//  (c) 1996-2001 by Microsoft Corp.
//
//  FLEXARRY.H
//
//  CFlexArray and CWStringArray implementation.
//
//  This
//
//  15-Jul-97   raymcc    This implementation is not based on arenas.
//
//***************************************************************************

#ifndef _FLEXARRY_H_
#define _FLEXARRY_H_

//***************************************************************************
//
//  class CFlexArray
//
//  This class is a generic pointer array.
//
//***************************************************************************

class CFlexArray
{
    int m_nSize;            // apparent size
    int m_nExtent;          // de facto size
    int m_nGrowBy;          
    void** m_pArray;
            
public:
    enum { no_error, failed, out_of_memory, array_full, range_error };

    // Constructs a flex array at an initial size and
    // specifies the initial size and growth-size chunk.
    // =================================================
    CFlexArray(
        IN int nInitialSize = 32, 
        IN int nGrowBy = 32
        );

   ~CFlexArray(); 
    CFlexArray(CFlexArray &);
    CFlexArray& operator=(CFlexArray &);

    // Gets an element at a particular location.
    // =========================================
    void *  GetAt(int nIndex) const { return m_pArray[nIndex]; }

    // Returns a ptr in the array; allows use on left-hand side of assignment.
    // =======================================================================
    void * operator[](int nIndex) const { return m_pArray[nIndex]; }
    void *& operator[](int nIndex) { return m_pArray[nIndex]; }

    // Sets the element at the requested location.
    // ===========================================
    void  SetAt(int nIndex, void *p) { m_pArray[nIndex] = p; }

    // Removes an element.
    // ====================
    int   RemoveAt(int nIndex);

    // Inserts an element.
    // ===================
    int   InsertAt(int nIndex, void *);

    // Removes all zero entries (null ptrs) and shrinks the array size.
    // ================================================================
    void  Compress();    

    // Adds a new element to the end of the array.
    // ===========================================
    int   Add(void *pSrc) { return InsertAt(m_nSize, pSrc); }    

    // Gets the apparent size of the array (number of used elements)
    // =============================================================
    int   Size() const { return m_nSize; }

    // Removes all entries and reduces array size to zero. The elements
    // are simply removed; not deallocated (this class doesn't know what
    // they are).
    // =================================================================
    void  Empty();

    // Gets a pointer to the internal array.
    // =====================================
    void** GetArrayPtr() { return m_pArray; }
    
    // Gets a pointer to the internal array and Resets the contents to none
    // ====================================================================

    void** UnbindPtr();

    // For debugging.
    // ==============
    void  DebugDump();
};

//***************************************************************************
//
//  class CWStringArray
//
//  This class is a generic wide-string array.
//
//***************************************************************************


class CWStringArray
{
    CFlexArray m_Array;
    
public:
    enum { no_error, failed, out_of_memory, array_full, range_error };
    enum { not_found = -1, no_case, with_case };
        
    CWStringArray(
        int nSize = 32, 
        int nGrowBy = 32
        );

    CWStringArray(CWStringArray &Src);
   ~CWStringArray();
            
    CWStringArray& operator =(CWStringArray &Src);

    // Gets the read-only ptr to the string at the requested index.
    // =============================================================    
    wchar_t *GetAt(int nIndex) { return (wchar_t *) m_Array[nIndex]; }

    // Same as GetAt().
    // ================
    wchar_t *operator[](int nIndex) { return (wchar_t *) m_Array[nIndex]; }

    // Appends a new element to the end of the array. Copies the param.
    // ================================================================
    int  Add(wchar_t *pStr);

    // Inserts a new element within the array.
    // =======================================
    int  InsertAt(int nIndex, wchar_t *pStr);

    // Removes an element at the specified index.  Takes care of
    // cleanup.
    // =========================================================
    int  RemoveAt(int nIndex);

    // Inserts a copy of <pStr> at that location after removing
    // the prior string and deallocating it.
    // ========================================================
    int  SetAt(int nIndex, wchar_t *pStr);

    // Directly replaces the pointer at the specified location
    // with the ptr value in <pStr>. No allocs or deallocs are done.
    // =============================================================
    int  ReplaceAt(int nIndex, wchar_t *pStr);
        // Unchecked replacement

    // Deletes the string at the location and sets the entry to zero
    // without compressing the array.
    // =============================================================
    int  DeleteStr(int nIndex);  

    // Returns the 'apparent' size of the array.
    // =========================================
    int  Size() { return m_Array.Size(); }

    // Empties the array by cleaning up after all strings and
    // setting the size to zero.
    // ======================================================
    void Empty();

    // Locates a string or returns -1 if not found.
    // ============================================
    int  FindStr(wchar_t *pTarget, int nFlags);  

    // Compresses the array by removing all zero elements.
    // ===================================================
    void Compress() { m_Array.Compress(); }

    // Sorts the array according to UNICODE order.
    // ===========================================
    void Sort();

    // Standard set-theoretic operations.
    // ==================================
    static void Difference(
        CWStringArray &Src1, 
        CWStringArray &Src2,
        CWStringArray &Diff
        );

    static void Intersection(
        CWStringArray &Src1,
        CWStringArray &Src2,
        CWStringArray &Output
        );

    static void Union(
        CWStringArray &Src1,
        CWStringArray &Src2,
        CWStringArray &Output
        );
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntperf\oahelp.inl ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//  
//  OAHELP.INL
//
//  OLE Automation Helpers for client code
//
//  raymcc  21-Jul-97
//  
//***************************************************************************

#ifndef _OAHELP_INL_
#define _OAHELP_INL_

class CBSTR
{
    BSTR m_pStr;
public:
    CBSTR() { m_pStr = 0; }
    CBSTR(LPWSTR pSrc) { m_pStr = SysAllocString(pSrc); }
   ~CBSTR() { if (m_pStr) SysFreeString(m_pStr); }
    operator BSTR() { return m_pStr; }

    void Unbind() { m_pStr = 0; }
};

class CVARIANT
{
    VARIANT v;
public:
    CVARIANT() { VariantInit(&v); }
   ~CVARIANT() { VariantClear(&v); }
    void Clear()  { VariantClear(&v); }

    operator VARIANT *() { return &v; }
    VARIANT *operator &() { return &v; }

    CVARIANT(LPWSTR pSrc)   { VariantInit(&v); SetStr(pSrc); }
    CVARIANT(LONG lSrc)     { VariantInit(&v); SetLONG(lSrc); }
    CVARIANT(BOOL b)        { VariantInit(&v); SetBool(b); }
    CVARIANT(short i)       { VariantInit(&v); SetShort(i); }
    CVARIANT(double d)      { VariantInit(&v); SetDouble(d); }
    CVARIANT(BYTE b)        { VariantInit(&v); SetByte(b); }
    CVARIANT(IDispatch * pDisp) { VariantInit(&v); pDisp->AddRef(); SetDispatch(pDisp); }

    void   SetStr(LPWSTR pSrc)
    { Clear(); V_VT(&v) = pSrc ? VT_BSTR : VT_NULL; 
      V_BSTR(&v) = pSrc ? SysAllocString(pSrc) : 0; 
    }

    LPWSTR GetStr() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }
    operator LPWSTR() { return V_VT(&v) == VT_BSTR ? V_BSTR(&v) : 0; }

    void SetLONG(LONG lSrc) { Clear(); V_VT(&v) = VT_I4; V_I4(&v) = lSrc; }
    LONG GetLONG() { return V_I4(&v); }
    operator LONG() { return V_I4(&v);  }

    void SetDouble(double dSrc) { Clear(); V_VT(&v) = VT_R8; V_R8(&v) = dSrc; }
    double GetDouble() { return V_R8(&v); }
    operator double() { return V_R8(&v);  }

    void SetByte(BYTE bySrc) { Clear(); V_VT(&v) = VT_UI1; V_UI1(&v) = bySrc; }
    BYTE GetByte() { return V_UI1(&v); }
    operator BYTE() { return V_UI1(&v);  }

    void SetBool(BOOL b) { V_VT(&v) = VT_BOOL; V_BOOL(&v) = b ? VARIANT_TRUE : VARIANT_FALSE; }
    BOOL GetBool() { return V_BOOL(&v) == VARIANT_TRUE; }
    operator BOOL() { return V_BOOL(&v); }

    void SetDispatch(IDispatch* pDisp) { V_VT(&v) = VT_DISPATCH; V_DISPATCH(&v) = pDisp; }
    IDispatch * GetDispatch() { return V_DISPATCH(&v); }

    void SetUnknown(IUnknown* pUnk) { V_VT(&v) = VT_UNKNOWN; V_UNKNOWN(&v) = pUnk; }
    IUnknown * GetUnknown() { return V_UNKNOWN(&v); }

    void SetShort(short i) { V_VT(&v) = VT_I2; V_I2(&v) = i; }
    short GetShort() { return V_I2(&v); }
    operator short() { return V_I2(&v); }

    VARTYPE GetType() { return V_VT(&v); }

    void SetArray(SAFEARRAY *p, VARTYPE vt) { Clear(); V_VT(&v) = vt; V_ARRAY(&v) = p; }
        // This function acquires the SAFEARRAY pointer and it is no longer owned
        // by the caller.

    operator SAFEARRAY *() { return (V_VT(&v) & VT_ARRAY ? V_ARRAY(&v) : 0); }

    void Unbind() { VariantInit(&v); }
};

class CSAFEARRAY
{
    SAFEARRAY *p;
public:
    CSAFEARRAY(VARTYPE v, int nSize) 
    {
        SAFEARRAYBOUND rgsabound[1];
    	rgsabound[0].lLbound = 0;
    	rgsabound[0].cElements = nSize;
        p = SafeArrayCreate(v, 1, rgsabound);
    }
    
    ~CSAFEARRAY() { if (p) SafeArrayDestroy(p); }
    CSAFEARRAY(SAFEARRAY *pSrc) { p = pSrc; }

    HRESULT Put(long nLocation, LPVOID pData) {
        return SafeArrayPutElement(p, &nLocation, pData);                
    }

    HRESULT Get(long nLocation, LPVOID pData) { 
        return SafeArrayGetElement(p, &nLocation, pData);                
    }

    HRESULT Access(void **pData) { return SafeArrayAccessData(p, pData); }
    HRESULT Unaccess() { return SafeArrayUnaccessData(p); }

    operator SAFEARRAY *() { return p; }
    long GetNumElements() { long upper; SafeArrayGetUBound(p, 1, &upper); return upper + 1; }

    void Unbind() { p = 0; }
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntperf\perfhelp.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  PERFHELP.CPP
//  
//  Registry-based performance counter reading helper
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>

#include <wbemidl.h>

#include <wbemint.h>

#include "flexarry.h"
#include "ntperf.h"
#include "perfhelp.h"
#include "refreshr.h"


//***************************************************************************
//
//  PerfHelper::GetInstances
//
//  This is called to retrieve all instances of a given class. 
//
//  Parameters:
//  <pBuf>          The perf blob retrieved from HKEY_PERFORMANCE_DATA.
//  <pClassMap>     A map object of the class required.
//  <pSink>         The sink to which to deliver the objects.
//
//***************************************************************************

void PerfHelper::GetInstances(
    LPBYTE pBuf,
    CClassMapInfo *pClassMap,
    IWbemObjectSink *pSink
    )
{
    PPERF_OBJECT_TYPE PerfObj = 0;
    PPERF_INSTANCE_DEFINITION PerfInst = 0;
    PPERF_COUNTER_DEFINITION PerfCntr = 0, CurCntr = 0;
    PPERF_COUNTER_BLOCK PtrToCntr = 0;
    PPERF_DATA_BLOCK PerfData = (PPERF_DATA_BLOCK) pBuf;
    DWORD i, j, k;

    // Get the first object type.
    // ==========================
    
    PerfObj = (PPERF_OBJECT_TYPE)((PBYTE)PerfData +
        PerfData->HeaderLength);

    // Process all objects.
    // ====================
    
    for (i = 0; i < PerfData->NumObjectTypes; i++ )
    {
        // Within each PERF_OBJECT_TYPE is a series of 
        // PERF_COUNTER_DEFINITION blocks.
        // ==========================================
  
        PerfCntr = (PPERF_COUNTER_DEFINITION) ((PBYTE)PerfObj +
            PerfObj->HeaderLength);

        // If the current object isn't of the class we requested,
        // simply skip over it.  I am not sure if this can really
        // happen or not in practice.
        // ======================================================
        
        if (PerfObj->ObjectNameTitleIndex != pClassMap->m_dwObjectId)
        {
            PerfObj = (PPERF_OBJECT_TYPE)((PBYTE)PerfObj +
                PerfObj->TotalByteLength);
            continue;
        }

        if (PerfObj->NumInstances > 0)
        {
            // Get the first instance.
            // =======================
         
            PerfInst = (PPERF_INSTANCE_DEFINITION)((PBYTE)PerfObj +
                PerfObj->DefinitionLength);

            // Retrieve all instances.
            // =======================
         
            for (k = 0; k < DWORD(PerfObj->NumInstances); k++ )
            {
                CurCntr = PerfCntr;

                // Get the first counter.
                // ======================
                
                PtrToCntr = (PPERF_COUNTER_BLOCK)((PBYTE)PerfInst +
                    PerfInst->ByteLength);

                // Quickly clone a new instance to send back to the user.
                // Since SpawnInstance() returns an IWbemClassObject and
                // we really need an IWbemObjectAccess,we have to QI
                // after the spawn.  We need to fix this, as this number
                // of calls is too time consuming.
                // ======================================================

                IWbemObjectAccess *pNewInst = 0;
                IWbemClassObject *pClsObj = 0;
                
                pClassMap->m_pClassDef->SpawnInstance(0, &pClsObj);
                pClsObj->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) &pNewInst);

                pClsObj->Release(); // We only need the IWbemObjectAccess pointer

                // Locate the instance name.
                // ==========================
                
                LPWSTR pName = (LPWSTR) ((PBYTE)PerfInst + PerfInst->NameOffset);
                
                // Retrieve all counters.
                // ======================
                
                for(j = 0; j < PerfObj->NumCounters; j++ )
                {
                    // Find the WBEM property handle based on the counter title index.
                    // This function does a quick binary search of the class map object
                    // to find the handle that goes with this counter.
                    // ================================================================
                    
                    LONG hPropHandle = pClassMap->GetPropHandle(CurCntr->CounterNameTitleIndex);
                    if (hPropHandle == 0)
                        continue;

                    // Data is (LPVOID)((PBYTE)PtrToCntr + CurCntr->CounterOffset);

                    // Only supporting simple DWORD types for now.  BobW knows more about
                    // all this stuff and can extend it properly.
                    // ==================================================================
                    
                    if ((CurCntr->CounterType & 0x700) == 0)
                    {
                        LPDWORD pdwVal = LPDWORD((LPVOID)((PBYTE)PtrToCntr + CurCntr->CounterOffset));
                        HRESULT hRes = pNewInst->WriteDWORD(hPropHandle, *pdwVal);
                    }
                    
                    // Get next counter.
                    // =================
                    
                    CurCntr =  (PPERF_COUNTER_DEFINITION)((PBYTE)CurCntr +
                        CurCntr->ByteLength);
                }

                // Write the instance 'name'
                // =========================

                if (pName && pClassMap->m_dwNameHandle)
                {
                    pNewInst->WritePropertyValue(
                        pClassMap->m_dwNameHandle,                                                                            
                        (wcslen(pName) + 1) * 2,
                        LPBYTE(pName)
                        );
                }

                // Deliver the instance to the user.
                // =================================
                
                pSink->Indicate(1, (IWbemClassObject **) &pNewInst);
                pNewInst->Release();
                
                // Move to the next perf instance.
                // ================================
                PerfInst = (PPERF_INSTANCE_DEFINITION)((PBYTE)PtrToCntr +
                    PtrToCntr->ByteLength);
            }
        }

        // Cases where the counters have no instances.
        // ===========================================
        
        else  
        {
            // Get the first counter.
            // ======================
        
            PtrToCntr = (PPERF_COUNTER_BLOCK) ((PBYTE)PerfObj +
                PerfObj->DefinitionLength );

            // Quickly clone a new instance to send back to the user.
            // Since SpawnInstance() returns an IWbemClassObject and
            // we really need an IWbemObjectAccess,we have to QI
            // after the spawn.  We need to fix this, as this number
            // of calls is too time consuming.
            // ======================================================

            IWbemObjectAccess *pNewInst = 0;
            IWbemClassObject *pClsObj = 0;
            pClassMap->m_pClassDef->SpawnInstance(0, &pClsObj);
            pClsObj->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) &pNewInst);
            pClsObj->Release();
            
            // Retrieve all counters.
            // ======================
        
            for( j=0; j < PerfObj->NumCounters; j++ )
            {
                // Find the WBEM property handle based on the counter title index.
                // This function does a quick binary search of the class map object
                // to find the handle that goes with this counter.
                // ================================================================
                    
                LONG hPropHandle = pClassMap->GetPropHandle(PerfCntr->CounterNameTitleIndex);
                if (hPropHandle == 0)
                    continue;

                // Data is (LPVOID)((PBYTE)PtrToCntr + PerfCntr->CounterOffset);

                // We will ignore non-DWORD types for now.
                // =======================================

                if ((PerfCntr->CounterType & 0x700) == 0)   
                {
                    LPDWORD pdwVal = LPDWORD((LPVOID)((PBYTE)PtrToCntr + PerfCntr->CounterOffset));
                    HRESULT hRes = pNewInst->WriteDWORD(hPropHandle, *pdwVal);
                }

                PerfCntr = (PPERF_COUNTER_DEFINITION)((PBYTE)PerfCntr +
                       PerfCntr->ByteLength);
            }

            // Since IWbemObjectAccess derives from IWbemClassObject, the following
            // cast is legal.  Note that indicate wants IWbemClassObject objects.
            // ====================================================================

            pSink->Indicate(1, (IWbemClassObject **) &pNewInst);
            pNewInst->Release();
        }

        // Get the next object type.
        // =========================
        
        PerfObj = (PPERF_OBJECT_TYPE)((PBYTE)PerfObj +
            PerfObj->TotalByteLength);
    }
}


//***************************************************************************
//
//  PerfHelper::RefreshInstances
//
//***************************************************************************

void PerfHelper::RefreshInstances(
    LPBYTE pBuf,
    CNt5Refresher *pRef
    )
{
    PPERF_OBJECT_TYPE PerfObj = 0;
    PPERF_INSTANCE_DEFINITION PerfInst = 0;
    PPERF_COUNTER_DEFINITION PerfCntr = 0, CurCntr = 0;
    PPERF_COUNTER_BLOCK PtrToCntr = 0;
    PPERF_DATA_BLOCK PerfData = (PPERF_DATA_BLOCK) pBuf;
    DWORD i, j, k;

    // Get the first object type.
    // ==========================
    
    PerfObj = (PPERF_OBJECT_TYPE)((PBYTE)PerfData +
        PerfData->HeaderLength);

    // Process all objects.
    // ====================
    
    for (i = 0; i < PerfData->NumObjectTypes; i++ )
    {
        // Within each PERF_OBJECT_TYPE is a series of 
        // PERF_COUNTER_DEFINITION blocks.
        // ==========================================
  
        PerfCntr = (PPERF_COUNTER_DEFINITION) ((PBYTE)PerfObj +
            PerfObj->HeaderLength);

        if (PerfObj->NumInstances > 0)
        {
            // Get the first instance.
            // =======================
         
            PerfInst = (PPERF_INSTANCE_DEFINITION)((PBYTE)PerfObj +
                PerfObj->DefinitionLength);

            // Retrieve all instances.
            // =======================
         
            for (k = 0; k < DWORD(PerfObj->NumInstances); k++ )
            {
                CurCntr = PerfCntr;

                // Get the first counter.
                // ======================
                
                PtrToCntr = (PPERF_COUNTER_BLOCK)((PBYTE)PerfInst +
                    PerfInst->ByteLength);


                // Locate the instance name.
                // ==========================
                
                LPWSTR pName = (LPWSTR) ((PBYTE)PerfInst + PerfInst->NameOffset);

                // Find the instance in the refresher, if there is one, which
                // corresponds to the instance we are looking at.
                // ==========================================================

                CClassMapInfo *pClassMap = 0;
                IWbemObjectAccess *pInst = 0;

                BOOL bRes = pRef->FindInst(
                    PerfObj->ObjectNameTitleIndex,              // Object type (WBEM Class)
                    pName,                                       // Instance name
                    &pInst,
                    &pClassMap
                    );
                
                // Retrieve all counters for the instance if it was one of the instances
                // we are supposed to be refreshing.
                // =====================================================================

                if (bRes)
                {                
                    for (j = 0; j < PerfObj->NumCounters; j++ )
                    {
                        LONG hPropHandle = pClassMap->GetPropHandle(CurCntr->CounterNameTitleIndex);
                        if (hPropHandle == 0)
                            continue;

                        // Data is (LPVOID)((PBYTE)PtrToCntr + CurCntr->CounterOffset);
    
                        if ((CurCntr->CounterType & 0x700) == 0)
                        {
                            LPDWORD pdwVal = LPDWORD((LPVOID)((PBYTE)PtrToCntr + CurCntr->CounterOffset));
                            HRESULT hRes = pInst->WriteDWORD(hPropHandle, *pdwVal);
                        }
                    
                        // Get next counter.
                        // =================
                        CurCntr =  (PPERF_COUNTER_DEFINITION)((PBYTE)CurCntr +
                            CurCntr->ByteLength);
                    }
                }                    

                // Get the next instance.
                // ======================
                PerfInst = (PPERF_INSTANCE_DEFINITION)((PBYTE)PtrToCntr +
                    PtrToCntr->ByteLength);
            }
        }

        // Cases where the counters have no instances.
        // ===========================================
        
        else  
        {
            // Get the first counter.
            // ======================
        
            PtrToCntr = (PPERF_COUNTER_BLOCK) ((PBYTE)PerfObj +
                PerfObj->DefinitionLength );

            // Find the singleton WBEM instance which correponds to the singleton perf instance
            // along with its class def so that we have the property handles.
            //
            // Note that since the perf object index translates to a WBEM class and there
            // can only be one instance, all that is required to find the instance in the
            // refresher is the perf object title index.
            // =================================================================================

            CClassMapInfo *pClassMap = 0;
            IWbemObjectAccess *pInst = 0;

            BOOL bRes = pRef->FindSingletonInst(
                PerfObj->ObjectNameTitleIndex,
                &pInst,
                &pClassMap
                );
            
            // Retrieve all counters if the instance is one we are supposed to be refreshing.
            // ==============================================================================
        
            if (bRes)
            {                
                for( j=0; j < PerfObj->NumCounters; j++ )
                {
                    // Get the property handle for the counter.
                    // ========================================
    
                    LONG hPropHandle = pClassMap->GetPropHandle(PerfCntr->CounterNameTitleIndex);
                    if (hPropHandle == 0)
                        continue;
    
                    // Data is (LPVOID)((PBYTE)PtrToCntr + PerfCntr->CounterOffset);
    
                    // We will ignore non-DWORD types for now.
                    // =======================================
    
                    if ((PerfCntr->CounterType & 0x700) == 0)   
                    {
                        LPDWORD pdwVal = LPDWORD((LPVOID)((PBYTE)PtrToCntr + PerfCntr->CounterOffset));
                        HRESULT hRes = pInst->WriteDWORD(hPropHandle, *pdwVal);
                    }
    
                    PerfCntr = (PPERF_COUNTER_DEFINITION)((PBYTE)PerfCntr +
                           PerfCntr->ByteLength);
                }                           
            }
        }

        // Get the next object type.
        // =========================
        
        PerfObj = (PPERF_OBJECT_TYPE)((PBYTE)PerfObj +
            PerfObj->TotalByteLength);
    }
}







//***************************************************************************
//
//  QueryInstances
//  
//  Used to send back all instances of a perf counter.  The counter
//  is specified by the <pClassMap> object, which is tightly bound to
//  a particular counter.
//
//***************************************************************************


BOOL PerfHelper::QueryInstances(
    CClassMapInfo *pClassMap,
    IWbemObjectSink *pSink
    )
{
    DWORD dwBufSize = 0;
    DWORD dwType = 0;
    LPBYTE pBuf = 0;
    
    for (;;)
    {
        dwBufSize += 0x20000;   // 128K

        pBuf = new BYTE[dwBufSize];

        wchar_t ID[32];
        LONG lStatus;

        swprintf(ID, L"%d", pClassMap->m_dwObjectId);
        
        lStatus = RegQueryValueExW(
             HKEY_PERFORMANCE_DATA,
             ID,
             0,
             &dwType,
             pBuf,
             &dwBufSize
             );

        if (lStatus == ERROR_MORE_DATA)
        {
            continue;
        }

        if (lStatus)
            return FALSE;

        break;
    }


    // Decode the instances and send them back.
    // ========================================
    
    GetInstances(pBuf, pClassMap, pSink);
    
    // Cleanup.
    // ========
    

    delete [] pBuf;

    return TRUE;
}





//***************************************************************************
//
//  RefreshInstances
//  
//  Used to refresh a set of instances.
//
//***************************************************************************


BOOL PerfHelper::RefreshInstances(
    CNt5Refresher *pRef
    )
{
    DWORD dwBufSize = 0;
    DWORD dwType = 0;
    LPBYTE pBuf = 0;

    // Build up the Perf Object ID list.
    // =================================

    DWORD dwNumIds;
    DWORD *pdwIdList;
    pRef->GetObjectIds(&dwNumIds, &pdwIdList);

    wchar_t *IDList = new wchar_t[dwNumIds * 8];    // Allow 8 wide chars per id
    IDList[0] = 0;

    for (DWORD n = 0; n < dwNumIds; n++)
    {
        wchar_t Tmp[32];
        swprintf(Tmp, L"%d", pdwIdList[n]);
        if (n > 0)
            wcscat(IDList, L" ");
        wcscat(IDList, Tmp);
    }

    delete [] pdwIdList;

    for (;;)
    {
        dwBufSize += 0x20000;   // 128K

        pBuf = new BYTE[dwBufSize];

        LONG lStatus;

        lStatus = RegQueryValueExW(
             HKEY_PERFORMANCE_DATA,
             IDList,
             0,
             &dwType,
             pBuf,
             &dwBufSize
             );

        if (lStatus == ERROR_MORE_DATA)
        {
            continue;
        }

        if (lStatus)
        {
            delete [] pBuf;
            delete [] IDList;
            return FALSE;
        }

        break;
    }


    // Decode the instances and send them back.
    // ========================================
    
    RefreshInstances(pBuf, pRef);
    
    // Cleanup.
    // ========
    
    delete [] pBuf;
    delete [] IDList;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntperf\ntperf.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  NTPERF.CPP
//  
//  Mapped NT5 Perf Counter Provider
//
//  raymcc      02-Dec-97   Created.        
//  raymcc      20-Feb-98   Updated to use new initializer.
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>

#include <wbemidl.h>

#include <wbemint.h>

#include "flexarry.h"
#include "ntperf.h"
#include "oahelp.inl"
#include "perfhelp.h"
#include "refreshr.h"

//***************************************************************************
//
//  CNt5PerfProvider constructor
//
//***************************************************************************
// ok

CNt5PerfProvider::CNt5PerfProvider()
{
    m_lRef = 0;
}

//***************************************************************************
//
//  CNt5PerfProvider destructor
//
//***************************************************************************
// ok

CNt5PerfProvider::~CNt5PerfProvider()
{
    for (int i = 0; i < m_aCache.Size(); i++)
        delete (CClassMapInfo *) m_aCache[i];

    RegCloseKey(HKEY_PERFORMANCE_DATA);
}


//***************************************************************************
//
//  CNt5Refresher::AddRef
//
//  Standard COM AddRef().
//
//***************************************************************************
// ok

ULONG CNt5PerfProvider::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CNt5Refresher::Release
//
//  Standard COM Release().
//
//***************************************************************************
// ok

ULONG CNt5PerfProvider::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//  CNt5Refresher::QueryInterface
//
//  Standard COM QueryInterface().  We have to support two interfaces,
//  the IWbemHiPerfProvider interface itself to provide the objects and
//  the IWbemProviderInit interface to initialize the provider.
//
//***************************************************************************
// ok

HRESULT CNt5PerfProvider::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemHiPerfProvider)
    {
        *ppv = (IWbemHiPerfProvider*) this;
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IWbemProviderInit)
    {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}


//***************************************************************************
//
//  CNt5Refresher::Initialize
//
//  Called once during startup.  Indicates to the provider which
//  namespace it is being invoked for and which User.  It also supplies
//  a back pointer to WINMGMT so that class definitions can be retrieved.
//
//  We perform any one-time initialization in this routine. The
//  final call to Release() is for any cleanup.
//
//  <wszUser>           The current user.
//  <lFlags>            Reserved.
//  <wszNamespace>      The namespace for which we are being activated.
//  <wszLocale>         The locale under which we are to be running.
//  <pNamespace>        An active pointer back into the current namespace
//                      from which we can retrieve schema objects.
//  <pCtx>              The user's context object.  We simply reuse this
//                      during any reentrant operations into WINMGMT.
//  <pInitSink>         The sink to which we indicate our readiness.
//
//***************************************************************************
// ok

HRESULT CNt5PerfProvider::Initialize( 
    /* [unique][in] */  LPWSTR wszUser,
    /* [in] */          LONG lFlags,
    /* [in] */          LPWSTR wszNamespace,
    /* [unique][in] */  LPWSTR wszLocale,
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemProviderInitSink __RPC_FAR *pInitSink
    )
{
    pInitSink->SetStatus(0, WBEM_S_INITIALIZED);

    return NO_ERROR;
}
    

//***************************************************************************
//
//  CNt5Refresher::QueryInstances
//
//  Called whenever a complete, fresh list of instances for a given
//  class is required.   The objects are constructed and sent back to the
//  caller through the sink.  The sink can be used in-line as here, or
//  the call can return and a separate thread could be used to deliver
//  the instances to the sink.
//
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace.  This
//                      should not be AddRef'ed or retained past the
//                      execution of this method.
//  <wszClass>          The class name for which instances are required.
//  <lFlags>            Reserved.
//  <pCtx>              The user-supplied context (used during callbacks
//                      into WINMGMT).
//  <pSink>             The sink to which to deliver the objects.  The objects
//                      can be delivered synchronously through the duration
//                      of this call or asynchronously (assuming we
//                      had a separate thread).  A IWbemObjectSink::SetStatus
//                      call is required at the end of the sequence.
//
//***************************************************************************
//  ok
        
HRESULT CNt5PerfProvider::QueryInstances( 
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [string][in] */  WCHAR __RPC_FAR *wszClass,
    /* [in] */          long lFlags,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemObjectSink __RPC_FAR *pSink
    )
{
    if (pNamespace == 0 || wszClass == 0 || pSink == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Ensure the class is in our cache and mapped.
    // ============================================

    BOOL bRes = MapClass(pNamespace, wszClass, pCtx);
    
    if (bRes == FALSE)
    {
        // Class is not one of ours.
        return WBEM_E_INVALID_CLASS;
    }

    CClassMapInfo *pClsMap = FindClassMap(wszClass);

    // Refresh the instances.
    // ======================
    
    PerfHelper::QueryInstances(pClsMap, pSink);

    // Tell WINMGMT we are finished.
    // ===========================
    
    pSink->SetStatus(0, WBEM_NO_ERROR, 0, 0);
    
    return NO_ERROR;
}    



//***************************************************************************
//
//  CNt5Refresher::CreateRefresher
//
//  Called whenever a new refresher is needed by the client.
//
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace.  Not used.
//  <lFlags>            Not used.
//  <ppRefresher>       Receives the requested refresher.
//
//***************************************************************************        
// ok

HRESULT CNt5PerfProvider::CreateRefresher( 
     /* [in] */ IWbemServices __RPC_FAR *pNamespace,
     /* [in] */ long lFlags,
     /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher
     )
{
    if (pNamespace == 0 || ppRefresher == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Construct a new empty refresher.
    // ================================        

    CNt5Refresher *pNewRefresher = new CNt5Refresher;

    // Follow COM rules and AddRef() the thing before sending it back.
    // ===============================================================
    
    pNewRefresher->AddRef();
    *ppRefresher = pNewRefresher;
    
    return NO_ERROR;
}

//***************************************************************************
//
//  CNt5Refresher::CreateRefreshableObject
//
//  Called whenever a user wants to include an object in a refresher.
//     
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace in WINMGMT.
//  <pTemplate>         A pointer to a copy of the object which is to be
//                      added.  This object itself cannot be used, as
//                      it not owned locally.        
//  <pRefresher>        The refresher to which to add the object.
//  <lFlags>            Not used.
//  <pContext>          Not used here.
//  <ppRefreshable>     A pointer to the internal object which was added
//                      to the refresher.
//  <plId>              The Object Id (for identification during removal).        
//
//***************************************************************************        
// ok

HRESULT CNt5PerfProvider::CreateRefreshableObject( 
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
    /* [out] */ long __RPC_FAR *plId
    )
{
    *ppRefreshable = 0;

    // Make a copy of the template object.
    // ===================================
    
    IWbemClassObject *pOriginal = 0;
    pTemplate->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pOriginal);

    IWbemClassObject *pNewCopy = 0;    
    pOriginal->Clone(&pNewCopy);

    // Get the class name of the object.
    // =================================

    VARIANT v; 
    VariantInit(&v);
    BSTR strClassProp = SysAllocString(L"__CLASS");
    pOriginal->Get(strClassProp, 0, &v, 0, 0);
    SysFreeString(strClassProp);

    // We are now done with the original object
    // ========================================

    pOriginal->Release();   

    // We now get the IWbemObjectAccess form of the cloned object
    // and release the unused interface.
    // ==========================================================
        
    IWbemObjectAccess *pNewAccess = 0;
    pNewCopy->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) &pNewAccess);
    pNewCopy->Release();    // We don't need the IWbemClassObject interface any more


    // We now have an IWbemObjectAccess pointer for the refreshable
    // object in <pNewAccess>.
    // ============================================================

    CNt5Refresher *pRef = (CNt5Refresher *) pRefresher;

    // Map the class info for this instance.
    // =====================================

    BOOL bRes = MapClass(pNamespace, V_BSTR(&v), pContext);
    
    if (bRes == FALSE)
    {
        // Class is not one of ours.
        pNewAccess->Release();
        VariantClear(&v);
        return WBEM_E_INVALID_CLASS;
    }

    CClassMapInfo *pClsMap = FindClassMap(V_BSTR(&v));
    if (pClsMap == 0)
    {
        pNewAccess->Release();
        VariantClear(&v);
        return WBEM_E_INVALID_CLASS;
    }

    // Add the object to the refresher.
    // This method will AddRef() the object before returning.
    // ======================================================

    pRef->AddObject(
        pNewAccess, 
        pClsMap,        
        plId
        );
    
    // Return object to the user.
    // ==========================
    
    *ppRefreshable = pNewAccess;

    VariantClear(&v);    

    return NO_ERROR;
}
    

//***************************************************************************
//
//  CNt5Refresher::StopRefreshing
//
//  Called whenever a user wants to remove an object from a refresher.
//     
//  Parameters:
//  <pRefresher>            The refresher object from which we are to 
//                          remove the perf object.
//  <lId>                   The ID of the object.
//  <lFlags>                Not used.
//  
//***************************************************************************        
// ok
        
HRESULT CNt5PerfProvider::StopRefreshing( 
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lId,
    /* [in] */ long lFlags
    )
{
    CNt5Refresher *pRef = (CNt5Refresher *) pRefresher;
    BOOL bRes = pRef->RemoveObject(lId);
    if (bRes == FALSE)
        return WBEM_E_FAILED;
    return WBEM_NO_ERROR;
}
    
//***************************************************************************
//
//  CNt5Refresher::CreateRefreshableEnum
//
//  Called whenever a user wants to create an enumeration in a refresher.
//     
//  Parameters:
//  <pNamespace>            The namespace this is for
//  <wszClass>              Name of the class we are enumerating
//  <pRefresher>            The refresher object from which we are to 
//                          remove the perf object.
//  <lFlags>                Not used.
//  <pContext>              Wbem Context object
//  <pHiPerfEnum>           Enumerator object into which refresher should place
//                          its results
//  <plId>                  The enum id (for identification during removal)
//  
//***************************************************************************        
// ok
HRESULT CNt5PerfProvider::CreateRefreshableEnum( 
    /* [in] */ IWbemServices* pNamespace,
    /* [in, string] */ LPCWSTR wszClass,
    /* [in] */ IWbemRefresher* pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext* pContext,
    /* [in] */ IWbemHiPerfEnum* pHiPerfEnum,
    /* [out] */ long* plId )
{
    // Just a placeholder for now
    return E_NOTIMPL;
}

//***************************************************************************
//
//  CNt5Refresher::GetObjects
//
//  Called whenever a user wants to create an enumeration in a refresher.
//     
//  Parameters:
//  <pNamespace>            The namespace this is for
//  <lNumObjects>           Number of objects in the array
//  <apObj>                 Objects to retrieve (keys are set)
//  <lFlags>                Not used.
//  <pContext>              Wbem Context object
//  <pHiPerfEnum>           Enumerator object into which refresher should place
//                          its results
//  <plId>                  The enum id (for identification during removal)
//  
//***************************************************************************        
// ok
HRESULT CNt5PerfProvider::GetObjects( 
    /* [in] */ IWbemServices* pNamespace,
    /* [in] */ long lNumObjects,
    /* [in,size_is(lNumObjects)] */ IWbemObjectAccess** apObj,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext* pContext)
{
    // Just a placeholder for now
    return E_NOTIMPL;
}

//***************************************************************************
//
//  CNt5Refresher::MapClass
//
//  Adds the class map to an internal cache.
//
//  <pClsMap>           The pointer to the map info to add.  This pointer
//                      is acquired by this function and should not be
//                      deleted by the caller.
//
//***************************************************************************
// ok

void CNt5PerfProvider::AddClassMap(
    IN CClassMapInfo *pClsMap
    )
{
    for (int i = 0; i < m_aCache.Size(); i++)
    {
        CClassMapInfo *pTracer = (CClassMapInfo *) m_aCache[i];

        if (_wcsicmp(pClsMap->m_pszClassName, pTracer->m_pszClassName) < 0)
        {
            m_aCache.InsertAt(i, pClsMap);
            return;
        }
    }
    
    // If here, add it to the end.
    // ===========================

    m_aCache.Add(pClsMap);
}    


//***************************************************************************
//
//  CNt5Refresher::FindClassMap
//
//***************************************************************************
// ok

CClassMapInfo *CNt5PerfProvider::FindClassMap(
    LPWSTR pszClassName
    )
{
    // Binary search the cache.
    // ========================

    int l = 0, u = m_aCache.Size() - 1;

    while (l <= u)
    {
        int m = (l + u) / 2;

        CClassMapInfo *pClsMap = (CClassMapInfo *) m_aCache[m];

        if (_wcsicmp(pszClassName, pClsMap->m_pszClassName) < 0)
            u = m - 1;
        else if (_wcsicmp(pszClassName, pClsMap->m_pszClassName) > 0)
            l = m + 1;
        else    // Hit!
            return pClsMap;
    }

    return NULL;
}


//***************************************************************************
//
//  CNt5Refresher::MapClass
//
//  Retrieves the requested class and places it in the cache.
//  
//  Parameters:
//      pNs         The namespace which contains the class definition.
//      wsClass     The class name.
//      pCtx        The inbound context object.  Only used for reentrant
//                  calls.
//
//***************************************************************************
// ok

BOOL CNt5PerfProvider::MapClass(
    IN IWbemServices *pNs,
    IN WCHAR *wszClass,
    IN IWbemContext *pCtx    
    )
{
    HRESULT hRes = 0;

    // See if the class is already in the cache.
    // =========================================
    if (FindClassMap(wszClass) != 0)
        return TRUE;
         
    // Get the class definition from WINMGMT.
    // ====================================

    IWbemClassObject *pClsDef = 0;
    hRes = pNs->GetObject(CBSTR(wszClass), 0, pCtx, &pClsDef, 0);
    if (hRes)
    {
        // Unable to retrieve the class definition
        return FALSE;
    }

    // Verify the class is one of ours by checking
    // the "provider" qualifier to ensure it matches
    // the name that we we have for this component.
    // =============================================

    IWbemQualifierSet *pQSet = 0;
    hRes = pClsDef->GetQualifierSet(&pQSet);
    
    if (hRes)
    {   
        pClsDef->Release();
        return FALSE;
    }

    VARIANT v;
    VariantInit(&v);
    pQSet->Get(CBSTR(L"Provider"), 0, &v, 0);
    pQSet->Release();
    
    if (_wcsicmp(V_BSTR(&v), PROVIDER_NAME) != 0)
    {
        pClsDef->Release();
        return FALSE;
    }

    // Get the property handles and mappings to the perf counter ids
    // by calling the Map() method of CClassMapInfo.
    // ==============================================================
    
    CClassMapInfo *pMapInfo = new CClassMapInfo;
    
    if (pMapInfo->Map(pClsDef) == FALSE)
    {
        delete pMapInfo;
        pClsDef->Release();
        return FALSE;        
    }

    // Add it to the cache.
    // ====================
        
    AddClassMap(pMapInfo);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntperf\refreshr.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  REFRESHR.CPP
//
//  Mapped NT5 Perf Counter Provider
//
//  raymcc      02-Dec-97   Created.
//  raymcc      20-Feb-98   Updated to use new initializer.
//
//***************************************************************************


#include "precomp.h"
#include <stdio.h>

#include <wbemidl.h>

#include <wbemint.h>

#include "flexarry.h"
#include "ntperf.h"
#include "oahelp.inl"
#include "refreshr.h"
#include "perfhelp.h"


inline wchar_t *Macro_CloneLPWSTR(LPCWSTR src)
{
    if (!src)
        return 0;
    wchar_t *dest = new wchar_t[wcslen(src) + 1];
    if (!dest)
        return 0;
    return wcscpy(dest, src);
}



//***************************************************************************
//
//  RefresherCacheEl::RefresherCacheEl
//
//  Constructor
//
//***************************************************************************
// ok

RefresherCacheEl::RefresherCacheEl()
{
    m_dwPerfObjIx = 0;
    m_pClassMap = 0;
    m_pSingleton = 0;
}

//***************************************************************************
//
//  RefresherCacheEl::~RefresherCacheEl()
//
//  Destructor
//
//***************************************************************************
//  ok

RefresherCacheEl::~RefresherCacheEl()
{
    delete m_pClassMap;
    if (m_pSingleton)
        m_pSingleton->Release();

    for (int i = 0; i < m_aInstances.Size(); i++)
        delete (CachedInst *) m_aInstances[i];
}

//***************************************************************************
//
//  CNt5Refresher constructor
//
//***************************************************************************
// ok

CNt5Refresher::CNt5Refresher()
{
    m_lRef = 0;             // COM Ref Count
    m_lProbableId = 1;      // Used for new IDs
}

//***************************************************************************
//
//  CNt5Refresher destructor
//
//***************************************************************************
// ok

CNt5Refresher::~CNt5Refresher()
{
    for (int i = 0; i < m_aCache.Size(); i++)
        delete PRefresherCacheEl(m_aCache[i]);
}

//***************************************************************************
//
//  CNt5Refresher::Refresh
//
//  Executed to refresh a set of instances bound to the particular
//  refresher.
//
//***************************************************************************
// ok

HRESULT CNt5Refresher::Refresh(/* [in] */ long lFlags)
{
    BOOL bRes = PerfHelper::RefreshInstances(this);
    if (!bRes)
        return WBEM_E_FAILED;

    return WBEM_S_NO_ERROR;
}


//***************************************************************************
//
//  CNt5Refresher::AddRef
//
//  Standard COM AddRef().
//
//***************************************************************************
// ok

ULONG CNt5Refresher::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CNt5Refresher::Release
//
//  Standard COM Release().
//
//***************************************************************************
// ok

ULONG CNt5Refresher::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//  CNt5Refresher::QueryInterface
//
//  Standard COM QueryInterface().
//
//***************************************************************************
// ok

HRESULT CNt5Refresher::QueryInterface(REFIID riid, void** ppv)
{
    if (riid == IID_IUnknown || riid == IID_IWbemRefresher)
    {
        *ppv = (IWbemRefresher *) this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}


//***************************************************************************
//
//  CNt5Refresher::RemoveObject
//
//  Removes an object from the refresher.   Since we don't know
//  by ID alone which class it is, we loop through all the ones we
//  have until somebody claims it and returns TRUE for a removal.(
//
//***************************************************************************
// ok

BOOL CNt5Refresher::RemoveObject(LONG lId)
{
    for (int i = 0; i < m_aCache.Size(); i++)
    {
        PRefresherCacheEl pCacheEl = PRefresherCacheEl(m_aCache[i]);

        BOOL bRes = pCacheEl->RemoveInst(lId);
        if (bRes == TRUE)
            return TRUE;
    }

    return FALSE;
}


//***************************************************************************
//
//  CNt5Refresher::FindSingletonInst
//
//  Based on a perf object identification, locates a singleton WBEM
//  instance of that class within this refresher and returns the pointer
//  to it and its WBEM class info.
//
//  Note that the <dwPerfObjIx> maps directly to a WBEM Class entry.
//
//  To save execution time, we don't AddRef() the return value and the
//  caller doesn't Release().
//
//***************************************************************************
// ok

BOOL CNt5Refresher::FindSingletonInst(
    IN  DWORD dwPerfObjIx,
    OUT IWbemObjectAccess **pInst,
    OUT CClassMapInfo **pClsMap
    )
{
    // Binary search the cache.
    // ========================

    int l = 0, u = m_aCache.Size() - 1;

    while (l <= u)
    {
        int m = (l + u) / 2;

        PRefresherCacheEl pCacheEl = PRefresherCacheEl(m_aCache[m]);

        if (dwPerfObjIx < pCacheEl->m_dwPerfObjIx)
            u = m - 1;
        else if (dwPerfObjIx > pCacheEl->m_dwPerfObjIx)
            l = m + 1;
        else
        {
            *pClsMap = pCacheEl->m_pClassMap;
            *pInst = pCacheEl->m_pSingleton; // No AddRef() caller doesn't
                                             // change ref count
            return TRUE;
        }
    }

    // Not found
    // =========

    return FALSE;
}

//***************************************************************************
//
//  CNt5Refresher::FindInst
//
//  Based on a perf object identification, locates a WBEM instance of
//  that class within this refresher and returns the pointer to it.
//
//  Note that the <dwPerfObjIx> maps directly to a WBEM Class entry.
//
//  To save execution time, we don't AddRef() the return value and the
//  caller doesn't Release().
//
//***************************************************************************
// ok

BOOL CNt5Refresher::FindInst(
    IN  DWORD dwPerfObjIx,
    IN  LPWSTR pszInstName,
    OUT IWbemObjectAccess **pInst,
    OUT CClassMapInfo **pClsMap
    )
{
    // Binary search the cache.
    // ========================

    int l = 0, u = m_aCache.Size() - 1;

    while (l <= u)
    {
        int m = (l + u) / 2;

        PRefresherCacheEl pCacheEl = PRefresherCacheEl(m_aCache[m]);

        if (dwPerfObjIx < pCacheEl->m_dwPerfObjIx)
            u = m - 1;
        else if (dwPerfObjIx > pCacheEl->m_dwPerfObjIx)
            l = m + 1;
        else
        {
            // We found the class.  Now do we have the instance?
            // =================================================
            IWbemObjectAccess *pTmp = pCacheEl->FindInst(pszInstName);
            if (pTmp == 0)
                return FALSE;   // Didn't have it.
            *pInst = pTmp;
            *pClsMap = pCacheEl->m_pClassMap;
            return TRUE;
        }
    }

    // Not found
    // =========

    return FALSE;
}


//***************************************************************************
//
//  CNt5Refresher::GetObjectIds
//
//  Gets a list of all the perf object Ids corresponding to the instances
//  in the refresher.
//
//  Caller uses operator delete to deallocate the returned array.
//
//***************************************************************************
// ok

BOOL CNt5Refresher::GetObjectIds(
    DWORD *pdwNumIds,
    DWORD **pdwIdList
    )
{
    DWORD *pdwIds = new DWORD[m_aCache.Size()];

    for (int i = 0; i < m_aCache.Size(); i++)
        pdwIds[i] = PRefresherCacheEl(m_aCache[i])->m_dwPerfObjIx;

    *pdwIdList = pdwIds;
    *pdwNumIds = DWORD(m_aCache.Size());

    return TRUE;
}

//***************************************************************************
//
//  CNt5Refresher::FindUnusedId
//
//  Finds an ID not in use for new objects to be added to the refresher.
//
//***************************************************************************
// ok

LONG CNt5Refresher::FindUnusedId()
{
    PRefresherCacheEl pEl;
    int nRetries = 0x100000;    // A million retries

    Restart: while (nRetries--)
    {
        for (int i = 0; i < m_aCache.Size(); i++)
            pEl = PRefresherCacheEl(m_aCache[i]);
        {
            for (int i2 = 0; i2 < pEl->m_aInstances.Size(); i2++)
            {
                PCachedInst pInst = (PCachedInst) pEl->m_aInstances[i2];

                if (pInst->m_lId == m_lProbableId)
                {
                    m_lProbableId++;
                    goto Restart;
                }
            }
        }

        return m_lProbableId;
    }

    return -1;
}



//***************************************************************************
//
//  RefresherCacheEl::RemoveInst
//
//  Removes the requested instances from the cache element for a particular
//  class.
//
//***************************************************************************
// ok

BOOL RefresherCacheEl::RemoveInst(LONG lId)
{
    for (int i = 0; i < m_aInstances.Size(); i++)
    {
        PCachedInst pInst = (PCachedInst) m_aInstances[i];
        if (lId == pInst->m_lId)
        {
            delete pInst;
            m_aInstances.RemoveAt(i);
            return TRUE;
        }
    }

    return FALSE;
}



//***************************************************************************
//
//  CNt5Refresher::AddObject
//
//  Adds the requested object to the refresher and assigns an ID
//  to it.
//
//***************************************************************************
// ?

BOOL CNt5Refresher::AddObject(
    IN  IWbemObjectAccess *pObj,    // Object to add
    IN  CClassMapInfo *pClsMap,     // Class of object
    OUT LONG *plId                  // The id of the object added
    )
{
    BOOL bRes;
    LONG lNewId = FindUnusedId();

    if (lNewId == -1)
        return FALSE;

    // First, find the cache element corresponding to this object.
    // ===========================================================

    PRefresherCacheEl pWorkEl = GetCacheEl(pClsMap);

    // If <pWorkEl> is NULL, we didn't have anything in the cache
    // and have to add a new one.
    // ==========================================================

    if (pWorkEl == 0)
    {
        bRes = AddNewCacheEl(pClsMap, &pWorkEl);
        if (bRes == FALSE)
            return FALSE;
    }

    // If here, we have successfully added a new cache element.
    // ========================================================

    bRes = pWorkEl->InsertInst(pObj, lNewId);

    return bRes;
}


//***************************************************************************
//
//  CNt5Refresher::AddNewCacheEl
//
//  Adds a new cache element in the proper position so that a binary
//  search on perf object id can occur later.
//
//***************************************************************************
// ok
BOOL CNt5Refresher::AddNewCacheEl(
    IN CClassMapInfo *pClsMap,
    PRefresherCacheEl *pOutput
    )
{
    PRefresherCacheEl pWorkEl;
    PRefresherCacheEl pNew = new RefresherCacheEl;

    pNew->m_dwPerfObjIx = pClsMap->GetObjectId();
    pNew->m_pClassMap = pClsMap;

    for (int i = 0; i < m_aCache.Size(); i++)
    {
        pWorkEl = PRefresherCacheEl(m_aCache[i]);

        if (pNew->m_dwPerfObjIx < pWorkEl->m_dwPerfObjIx)
        {
            m_aCache.InsertAt(i, pNew);
            *pOutput = pNew;
            return TRUE;
        }
    }

    // Add it to the end.
    // ==================

    m_aCache.Add(pNew);
    *pOutput = pNew;

    return TRUE;
}


//***************************************************************************
//
//  CNt5Refresher::GetCacheEl
//
//***************************************************************************
// ok

PRefresherCacheEl CNt5Refresher::GetCacheEl(
    CClassMapInfo *pClsMap
    )
{
    PRefresherCacheEl pWorkEl;

    for (int i = 0; i < m_aCache.Size(); i++)
    {
        pWorkEl = PRefresherCacheEl(m_aCache[i]);
        if (pWorkEl->m_pClassMap == pClsMap)
            return pWorkEl;
    }

    return 0;
}


//***************************************************************************
//
//  RefresherCacheEl::FindInstance
//
//  Finds an instance in the current cache element for a particular instance.
//  For this to work, the instances have to be sorted by name.
//
//***************************************************************************
// ok

IWbemObjectAccess *RefresherCacheEl::FindInst(
    LPWSTR pszInstName
    )
{
    // Binary search the cache.
    // ========================

    int l = 0, u = m_aInstances.Size() - 1;

    while (l <= u)
    {
        int m = (l + u) / 2;

        CachedInst *pInst = PCachedInst(m_aInstances[m]);

        if (_wcsicmp(pszInstName, pInst->m_pName) < 0)
            u = m - 1;
        else if (_wcsicmp(pszInstName, pInst->m_pName) > 0)
            l = m + 1;
        else
        {
            // We found the instance.
            // ======================
            return pInst->m_pInst;
        }
    }

    // Not found
    // =========

    return 0;
}

//***************************************************************************
//
//  Inserts a new instance.
//
//***************************************************************************

BOOL RefresherCacheEl::InsertInst(IWbemObjectAccess *pNew, LONG lNewId)
{
    // Check for singleton.
    // ====================

    if (m_pClassMap->IsSingleton())
    {
        m_pSingleton = pNew;
        m_lSingletonId = lNewId;
        m_pSingleton->AddRef();
        return TRUE;
    }

    // For multi-instance, get the instance name.
    // ==========================================

    IWbemClassObject *pObj;
    pNew->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pObj);

    VARIANT v;
    VariantInit(&v);
    BSTR pNameProp = SysAllocString(L"Name");
    pObj->Get(pNameProp, 0, &v, 0, 0);
    SysFreeString(pNameProp);
    pObj->Release();

    // Construct the new instance.
    // ===========================

    PCachedInst pNewInst = new CachedInst;
    pNewInst->m_lId = lNewId;
    pNewInst->m_pInst = pNew;
    pNewInst->m_pInst->AddRef();
    pNewInst->m_pName = Macro_CloneLPWSTR(V_BSTR(&v));

    // Now place the name in the instance cache element.
    // =================================================

    for (int i = 0; i < m_aInstances.Size(); i++)
    {
        PCachedInst pTest = PCachedInst(m_aInstances[i]);
        if (_wcsicmp(V_BSTR(&v), pTest->m_pName) < 0)
        {
            m_aInstances.InsertAt(i, pNewInst);
            return TRUE;
        }
    }

    m_aInstances.Add(pNewInst);
    return TRUE;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntperf\ntperf.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  NTPERF.H
//
//  NT5 Perf Counter Provider
//
//  raymcc      02-Dec-97
//
//***************************************************************************

#ifndef _NTPERF_H_
#define _NTPERF_H_


#include "flexarry.h"
#include "classmap.h"

#define NUM_SAMPLE_INSTANCES   10

#define PROVIDER_NAME   L"NT5_GenericPerfProvider_V1"

inline wchar_t *Macro_CloneLPWSTR(LPCWSTR src)
{
    if (!src)
        return 0;
    wchar_t *dest = new wchar_t[wcslen(src) + 1];
    if (!dest)
        return 0;
    return wcscpy(dest, src);
}



class CNt5PerfProvider;




//***************************************************************************
//
//  class CNt5PerfProvider
//
//***************************************************************************

class CNt5PerfProvider : public IWbemHiPerfProvider, public IWbemProviderInit
{
    LONG        m_lRef;
    CFlexArray  m_aCache;           // Array of CClassMapInfo pointers

    friend class CNt5Refresher;

public:
    CNt5PerfProvider();
   ~CNt5PerfProvider();

    BOOL MapClass(
        IWbemServices *pNs,
        WCHAR *wszClass,
        IWbemContext *pCtx
        );


    void AddClassMap(CClassMapInfo *pCls);
    CClassMapInfo *FindClassMap(LPWSTR pszClassName);

    // Interface members.
    // ==================

        ULONG STDMETHODCALLTYPE AddRef();
        ULONG STDMETHODCALLTYPE Release();
        STDMETHODIMP QueryInterface(REFIID riid, void** ppv);


    // IWbemHiPerfProvider methods.
    // ============================

        virtual HRESULT STDMETHODCALLTYPE QueryInstances(
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [string][in] */ WCHAR __RPC_FAR *wszClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink
            );

        virtual HRESULT STDMETHODCALLTYPE CreateRefresher(
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ long lFlags,
            /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher
            );

        virtual HRESULT STDMETHODCALLTYPE CreateRefreshableObject(
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
            /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pContext,
            /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
            /* [out] */ long __RPC_FAR *plId
            );

        virtual HRESULT STDMETHODCALLTYPE StopRefreshing(
            /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
            /* [in] */ long lId,
            /* [in] */ long lFlags
            );

		virtual HRESULT STDMETHODCALLTYPE CreateRefreshableEnum(
			/* [in] */ IWbemServices* pNamespace,
			/* [in, string] */ LPCWSTR wszClass,
			/* [in] */ IWbemRefresher* pRefresher,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext* pContext,
			/* [in] */ IWbemHiPerfEnum* pHiPerfEnum,
			/* [out] */ long* plId
			);

		virtual HRESULT STDMETHODCALLTYPE GetObjects(
            /* [in] */ IWbemServices* pNamespace,
			/* [in] */ long lNumObjects,
			/* [in,size_is(lNumObjects)] */ IWbemObjectAccess** apObj,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pContext);


        // IWbemProviderInit method.
        // =========================

        virtual HRESULT STDMETHODCALLTYPE Initialize(
            /* [unique][in] */ LPWSTR wszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR wszNamespace,
            /* [unique][in] */ LPWSTR wszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
            );

};

extern void ObjectCreated();
extern void ObjectDestroyed();

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntperf\perfhelp.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  PERFHELP.H
//
//
//***************************************************************************

#ifndef _PERFHELP_H_
#define _PERFHELP_H_

class PerfHelper
{
    static void GetInstances(
        LPBYTE pBuf,
        CClassMapInfo *pClassMap,
        IWbemObjectSink *pSink
        );

    static void RefreshInstances(
        LPBYTE pBuf,
        CNt5Refresher *pRef
        );

public:
    static BOOL QueryInstances(
        CClassMapInfo *pClassMap,
        IWbemObjectSink *pSink
        );

    static BOOL RefreshInstances(
        CNt5Refresher *pRef
        );
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntperf\flexarry.cpp ===
//***************************************************************************
//
//  (c) 1996-2001 by Microsoft Corp.
//
//  FLEXARRY.CPP
//
//  CFlexArray implementation (non-arena).
//
//  15-Jul-97  raymcc    Created.
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <flexarry.h>

//***************************************************************************
//
//  CFlexArray::CFlexArray
//
//  Constructs the array.
//
//  Parameters:
//  <nSize>         The starting preallocated size of the array.
//  <nGrowBy>       The amount to grow by when the array fills up.
//
//  Size() returns the number of elements in use, not the 'true' size.
//
//***************************************************************************
// ok

CFlexArray::CFlexArray(
    int nSize, 
    int nGrowBy
    )
{
    m_nExtent = nSize;
    m_nSize = 0;
    m_nGrowBy = nGrowBy;

    m_pArray = (void **) LocalAlloc(LMEM_ZEROINIT, sizeof(void *) * nSize);
}
    
//***************************************************************************
//
//  CFlexArray::~CFlexArray
//
//***************************************************************************
// ok
CFlexArray::~CFlexArray()
{
    LocalFree(m_pArray);
}


//***************************************************************************
//
//  Copy constructor.
//  
//  Copies the pointers, not their contents.
//
//***************************************************************************
// ok

CFlexArray::CFlexArray(CFlexArray &Src)
{
    m_pArray = 0;
    m_nSize = 0;
    m_nExtent = 0;
    m_nGrowBy = 0;

    *this = Src;
}

//***************************************************************************
//
//  operator =
//
//  Assignment operator.
//
//  Arenas are not copied.  This allows transfer of arrays between arenas.
//  Arrays are copied by pointer only.
//
//***************************************************************************
// ok

CFlexArray& CFlexArray::operator=(CFlexArray &Src)
{
    m_nSize   = Src.m_nSize;
    m_nExtent = Src.m_nExtent;
    m_nGrowBy = Src.m_nGrowBy;

    LocalFree(m_pArray);
    m_pArray = (void **) LocalAlloc(LMEM_ZEROINIT, sizeof(void *) * m_nExtent);
    memcpy(m_pArray, Src.m_pArray, sizeof(void *) * m_nExtent);
        
    return *this;    
}

//***************************************************************************
//
//  CFlexArray::RemoveAt
//
//  Removes the element at the specified location.  Does not
//  actually delete the pointer. Shrinks the array over the top of
//  the 'doomed' element.
//
//  Parameters:
//  <nIndex>    The location of the element.
//    
//  Return value:
//  range_error     The index is not legal.
//  no_error        Success.
//  
//***************************************************************************
// ok

int CFlexArray::RemoveAt(int nIndex)
{
    if (nIndex >= m_nSize)
        return range_error;
        
    for (int i = nIndex; i < m_nSize - 1; i++) 
        m_pArray[i] = m_pArray[i + 1];

    m_nSize--;
    m_pArray[m_nSize] = 0;

    return no_error;
}

//***************************************************************************
//
//  CFlexArray::InsertAt
//
//  Inserts a new element at the specified location.  The pointer is copied.
//
//  Parameters:
//  <nIndex>        The 0-origin location at which to insert the new element.
//  <pSrc>          The pointer to copy. (contents are not copied).
//
//  Return value:
//  array_full
//  out_of_memory
//  no_error
//
//***************************************************************************
// ok

int CFlexArray::InsertAt(int nIndex, void *pSrc)
{
    // If the array is full, we need to expand it.
    // ===========================================
    
    if (m_nSize == m_nExtent) 
    {
        if (m_nGrowBy == 0)
            return array_full;
        m_nExtent += m_nGrowBy;
        void **pTmp = (void **) LocalAlloc(LMEM_ZEROINIT, sizeof(void *) * m_nExtent);
        if (!pTmp)
            return out_of_memory;                
        for (int i = 0; i < m_nSize; i++)
            pTmp[i] = m_pArray[i];
        LocalFree(m_pArray);
        m_pArray = pTmp;
    }

    // Special case of appending.  This is so frequent
    // compared to true insertion that we want to optimize.
    // ====================================================
    
    if (nIndex == m_nSize) 
    {
        m_pArray[m_nSize++] = pSrc;
        return no_error;
    }
    
    // If here, we are inserting at some random location.
    // We start at the end of the array and copy all the elements 
    // one position farther to the end to make a 'hole' for
    // the new element.
    // ==========================================================
    
    for (int i = m_nSize; i > nIndex; i--) 
        m_pArray[i] = m_pArray[i - 1];

    m_pArray[nIndex] = pSrc;
    m_nSize++;
            
    return no_error;    
}

//***************************************************************************
//
//  CFlexArray::DebugDump
//
//***************************************************************************
void CFlexArray::DebugDump()
{
    printf("----CFlexArray Debug Dump----\n");
    printf("m_pArray = 0x%X\n", m_pArray);
    printf("m_nSize = %d\n", m_nSize);
    printf("m_nExtent = %d\n", m_nExtent);
    printf("m_nGrowBy = %d\n", m_nGrowBy);

    for (int i = 0; i < m_nExtent; i++)
    {
        if (i < m_nSize)
            printf("![%d] = %X\n", i, m_pArray[i]);
        else
            printf("?[%d] = %X\n", i, m_pArray[i]);                    
    }        
}

//***************************************************************************
//
//  CFlexArray::Compress
//
//  Removes NULL elements by moving all non-NULL pointers to the beginning
//  of the array.  The array "Size" changes, but the extent is untouched.
//
//***************************************************************************
// ok

void CFlexArray::Compress()
{
    int nLeftCursor = 0, nRightCursor = 0;
    
    while (nLeftCursor < m_nSize - 1) {
        if (m_pArray[nLeftCursor]) {
            nLeftCursor++;
            continue;
        }
        else {
            nRightCursor = nLeftCursor + 1;
            while (m_pArray[nRightCursor] == 0 && nRightCursor < m_nSize)
                nRightCursor++;
            if (nRightCursor == m_nSize)
                break;  // Short circuit, no more nonzero elements.
            m_pArray[nLeftCursor] = m_pArray[nRightCursor];
            m_pArray[nRightCursor] = 0;                                            
        }                    
    }
    
    while (m_pArray[m_nSize - 1] == 0 && m_nSize > 0) m_nSize--;
}    

//***************************************************************************
//
//  CFlexArray::Empty
//
//  Clears the array of all pointers (does not deallocate them) and sets
//  its apparent size to zero.
//
//***************************************************************************
// ok
void CFlexArray::Empty()
{
    LocalFree(m_pArray);
    m_pArray = (void **) LocalAlloc(LMEM_ZEROINIT, sizeof(void *) * m_nGrowBy);
    m_nSize = 0;
    m_nExtent = m_nGrowBy;
}

//***************************************************************************
//
//  CFlexArray::UnbindPtr
//
//  Empties the array and returns the pointer to the data it contained
//
//***************************************************************************

void** CFlexArray::UnbindPtr()
{
    void** pp = m_pArray;
    Empty();
    return pp;
}

//***************************************************************************
//
//  CWStringArray::CWStringArray
//
//  Constructs a wide-string array.
//
//  Parameters:
//  <nSize>         The starting preallocated size of the array.
//  <nGrowBy>       The amount to grow by when the array fills up.
//
//  Size() returns the number of elements in use, not the 'true' size.
//
//***************************************************************************

CWStringArray::CWStringArray(
        int nSize, 
        int nGrowBy
        )
        : 
        m_Array(nSize, nGrowBy)
{
}        

//***************************************************************************
//
//  Copy constructor.
//
//***************************************************************************

CWStringArray::CWStringArray(CWStringArray &Src)
{
    *this = Src;    
}

//***************************************************************************
//
//  Destructor.  Cleans up all the strings.
//
//***************************************************************************

CWStringArray::~CWStringArray()
{
    Empty();
}

//***************************************************************************
//
//  CWStringArray::DeleteStr
//
//  Frees the string at the specified index and sets the element to NULL.  
//  Does not compress array.
// 
//  Does not currently do a range check.
//
//  Parameters:
//  <nIndex>    The 0-origin index of the string to remove.
//
//  Return values:
//  no_error
//  
//***************************************************************************

int CWStringArray::DeleteStr(int nIndex)
{
    LocalFree(m_Array[nIndex]);
    m_Array[nIndex] = 0;
    return no_error;
}   

//***************************************************************************
//
//  CWStringArray::FindStr
//
//  Finds the specified string and returns its location.
//
//  Parameters:
//  <pTarget>       The string to find.
//  <nFlags>        <no_case> or <with_case>
//  
//  Return value:
//  The 0-origin location of the string, or -1 if not found.
//
//***************************************************************************

int CWStringArray::FindStr(wchar_t *pTarget, int nFlags)
{
    if (nFlags == no_case) 
    {
        for (int i = 0; i < m_Array.Size(); i++)
            if (_wcsicmp((wchar_t *) m_Array[i], pTarget) == 0)
                return i;
    }
    else 
    {
        for (int i = 0; i < m_Array.Size(); i++)
            if (wcscmp((wchar_t *) m_Array[i], pTarget) == 0)
                return i;
    }
    return not_found;
}

//***************************************************************************
//
//  operator =
//  
//***************************************************************************

//  Heap handle & allocation functions are not copied. This allows
//  transfer of arrays between heaps.
         
CWStringArray& CWStringArray::operator =(CWStringArray &Src)
{
    Empty();
    
    for (int i = 0; i < Src.Size(); i++) 
    {
        wchar_t *pSrc = (wchar_t *) Src.m_Array[i];
        wchar_t *pCopy = (wchar_t *) LocalAlloc(LMEM_ZEROINIT, (wcslen(pSrc) + 1) * 2);
        wcscpy(pCopy, pSrc);
        m_Array.Add(pCopy);
    }

    return *this;
}

//***************************************************************************
//
//  CWStringArray::Add
//
//  Appends a new string to the end of the array.
//
//  Parameters:
//  <pSrc>      The string to copy.
//
//  Return value:
//  The return values of CFlexArray::Add.
//  
//***************************************************************************
    
int CWStringArray::Add(wchar_t *pSrc)
{
    wchar_t *pNewStr = (wchar_t *) LocalAlloc(LMEM_ZEROINIT, (wcslen(pSrc) + 1) * 2);
    wcscpy(pNewStr, pSrc);
    return m_Array.Add(pNewStr);
}
//***************************************************************************
//
//  CWStringArray::InsertAt
//
//  Inserts a copy of a string in the array.
//
//  Parameters:
//  <nIndex>    The 0-origin location at which to insert the string.
//  <pSrc>      The string to copy.
//
//  Return values:
//  The return values of CFlexArray::InsertAt
//
//***************************************************************************

int CWStringArray::InsertAt(int nIndex, wchar_t *pSrc)
{
    wchar_t *pNewStr = (wchar_t *) LocalAlloc(LMEM_ZEROINIT, (wcslen(pSrc) + 1) * 2);
    wcscpy(pNewStr, pSrc);
    return m_Array.InsertAt(nIndex, pNewStr);
}


//***************************************************************************
//
//  CWStringArray::RemoveAt
//
//  Removes and deallocates the string at the specified location.
//  Shrinks the array.
//
//  Parameters:
//  <nIndex>    The 0-origin index of the 'doomed' string.
//  
//  Return value:
//  Same as CFlexArray::RemoveAt.
//
//***************************************************************************

int CWStringArray::RemoveAt(int nIndex)
{
    wchar_t *pDoomedString = (wchar_t *) m_Array[nIndex];
    LocalFree(pDoomedString);
    return m_Array.RemoveAt(nIndex);
}

//***************************************************************************
//
//  CWStringArray::SetAt
//
//  Replaces the string at the targeted location with the new one.
//  The old string at the location is cleaned up.
//
//  No range checking or out-of-memory checks at present.
//
//  Parameters:
//  <nIndex>        The 0-origin location at which to replace the string.
//  <pSrc>          The string to copy.  
//
//  Return value:
//  no_error
//   
//***************************************************************************

int CWStringArray::SetAt(int nIndex, wchar_t *pSrc)
{
    wchar_t *pDoomedString = (wchar_t *) m_Array[nIndex];
    if (pDoomedString)
        LocalFree(pDoomedString);

    wchar_t *pNewStr = (wchar_t *) LocalAlloc(LMEM_ZEROINIT, (wcslen(pSrc) + 1) * 2);
    wcscpy(pNewStr, pSrc);
    m_Array[nIndex] = pNewStr;

    return no_error;
}

//***************************************************************************
//
//  CWStringArray::ReplaceAt
//
//  Directly replaces the pointer at the specified location with the
//  one in the parameter.   No copy or cleanup.
//
//  Parameters:
//  <nIndex>     The 0-origin location at which to replace.
//  <pSrc>       The new pointer to copy over the old one.
//
//  Return value:
//  no_error        (No checking done at present).
//  
//***************************************************************************

int CWStringArray::ReplaceAt(int nIndex, wchar_t *pSrc)
{
    m_Array[nIndex] = pSrc;
    return no_error;
}



//***************************************************************************
//
//  CWStringArray::Empty
//
//  Empties the array, deallocates all strings, and sets the apparent
//  array size to zero.
//
//***************************************************************************

void CWStringArray::Empty()
{
    for (int i = 0; i < m_Array.Size(); i++)
        LocalFree(m_Array[i]);
    m_Array.Empty();        
}

//***************************************************************************
//
//  CWStringArray::Sort
//
//  Sorts the array according to UNICODE order.  
//  (Shell sort).
//
//***************************************************************************
void CWStringArray::Sort()
{
    for (int nInterval = 1; nInterval < m_Array.Size() / 9; nInterval = nInterval * 3 + 1);    

    while (nInterval) 
    {
        for (int iCursor = nInterval; iCursor < m_Array.Size(); iCursor++) 
        {
            int iBackscan = iCursor;
            while (iBackscan - nInterval >= 0 &&
               _wcsicmp((const wchar_t *) m_Array[iBackscan],
                    (const wchar_t *) m_Array[iBackscan-nInterval]) < 0) 
            {
                wchar_t *pTemp = (wchar_t *) m_Array[iBackscan - nInterval];
                m_Array[iBackscan - nInterval] = m_Array[iBackscan];
                m_Array[iBackscan] = pTemp;
                iBackscan -= nInterval;
            }
        }
        nInterval /= 3;
    }
}


//***************************************************************************
//
//  CWStringArray::Difference
//
//  Set-theoretic difference operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array which is 'subtracted' from first (not modified).    
//  <Diff>      Receives the difference.  Should be an empty array on entry.
//
//***************************************************************************
void CWStringArray::Difference(
    CWStringArray &Src1, 
    CWStringArray &Src2,
    CWStringArray &Diff
    )
{
    for (int i = 0; i < Src1.Size(); i++)
        if (Src2.FindStr(Src1[i], no_case) == -1)
            Diff.Add(Src1[i]);    
}

//***************************************************************************
//
//  CWStringArray::Intersection
//
//  Set-theoretic intersection operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array (not modified).    
//  <Diff>      Receives the intersection.  Should be an empty array on entry.

//***************************************************************************

void CWStringArray::Intersection(
    CWStringArray &Src1,
    CWStringArray &Src2,
    CWStringArray &Output
    )
{
    for (int i = 0; i < Src1.Size(); i++)
        if (Src2.FindStr(Src1[i], no_case) != -1)
            Output.Add(Src1[i]);
}    

//***************************************************************************
//
//  CWStringArray::Union
//
//  Set-theoretic union operation on the arrays.
//  
//  Parameters:
//  <Src1>      First array (not modified).
//  <Src2>      Second array (not modified).    
//  <Diff>      Receives the union.  Should be an empty array on entry.
//
//***************************************************************************

void CWStringArray::Union(
    CWStringArray &Src1,
    CWStringArray &Src2,
    CWStringArray &Output
    )
{
    Output = Src1;
    for (int i = 0; i < Src2.Size(); i++)
        if (Output.FindStr(Src2[i], no_case) == not_found)
            Output.Add(Src2[i]);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntperf\refreshr.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/



//***************************************************************************
//
//  REFRESHR.H
//
//***************************************************************************

#ifndef _REFRESHR_H_
#define _REFRESHR_H_


//***************************************************************************
//
//***************************************************************************

struct CachedInst
{
    LPWSTR             m_pName;         // Instance name
    IWbemObjectAccess *m_pInst;         // Pointer to WBEM object
    LONG               m_lId;           // ID for this object
                
    CachedInst() { m_pName = 0; m_pInst = 0; m_lId = 0; }
    ~CachedInst() { delete [] m_pName; if (m_pInst) m_pInst->Release(); }
};
  
typedef CachedInst *PCachedInst;


//***************************************************************************
//
//  RefresherCacheEl
//
//  Each CNt5Refresher has a cache of <RefresherCacheEl> elements.  There
//  is one RefresherCacheEl struct for each class of object in the refresher.
//
//  As each object is added to the refresher, we locate the corresponding
//  <RefresherCacheEl> for the class of the object.  We then add the
//  instance into the instance cache of the <RefresherCacheEl>. If there
//  is no RefresherCacheEl, we create one.
//
//  For singleton instances, we simply special case by having a dedicated
//  pointer.
//
//  For multi-instance counters, we use a binary search lookup.
//  
//***************************************************************************
// ok

struct RefresherCacheEl
{
    DWORD              m_dwPerfObjIx;       // Perf object index for Class Def
    CClassMapInfo     *m_pClassMap;         // WBEM Class def stuff
    IWbemObjectAccess *m_pSingleton;        // Optional Singleton instance
    LONG               m_lSingletonId;
    CFlexArray         m_aInstances;        // Instance list for non-singleton
                                            // of CachedInst pointers.
    RefresherCacheEl();
   ~RefresherCacheEl(); 
   
    IWbemObjectAccess *FindInst(LPWSTR pszName);  // Already scoped by class
    BOOL RemoveInst(LONG lId);
    BOOL InsertInst(IWbemObjectAccess *p, LONG lNewId);
};

typedef RefresherCacheEl *PRefresherCacheEl;

class CNt5Refresher : public IWbemRefresher
{
    LONG                m_lRef;
    LONG                m_lProbableId;
    CFlexArray          m_aCache;   
        // Pointers to RefresherCacheEl objects which contain
        // all classes and their instances used in this refresher.

public:
    CNt5Refresher();
   ~CNt5Refresher();

    // Interface members.
    // ==================

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);

    // Primary WBEM method for updating.
    // =================================
    virtual HRESULT STDMETHODCALLTYPE Refresh(/* [in] */ long lFlags);


    // Private members used by NTPERF.CPP
    // ==================================
    
    BOOL AddObject(
        IN  IWbemObjectAccess *pObj,    // Object to add
        IN  CClassMapInfo *pClsMap,     // Class of object
        OUT LONG *plId                  // The id of the object added
        );

    BOOL RemoveObject(LONG lId);

    CClassMapInfo * FindClassMap(
        DWORD dwObjectTitleIx
        );

    BOOL FindSingletonInst(
        IN  DWORD dwPerfObjIx,
        OUT IWbemObjectAccess **pInst,
        OUT CClassMapInfo **pClsMap
        );

    BOOL FindInst(
        IN  DWORD dwObjectClassIx,
        IN  LPWSTR pszInstName,
        OUT IWbemObjectAccess **pInst,
        OUT CClassMapInfo **pClsMap
        );

    BOOL GetObjectIds(DWORD *pdwNumIds, DWORD **pdwIdList); 
        // Use operator delete on returned <pdwIdList>

    LONG FindUnusedId();
        // Returns -1 on error or an unused id.

    PRefresherCacheEl GetCacheEl(CClassMapInfo *pClsMap);


    BOOL AddNewCacheEl(
        IN CClassMapInfo *pClsMap, 
        PRefresherCacheEl *pOutput
        );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntperfclient\refresh.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  REFRESH.H
//
//  APIs to the refresher module
//
//***************************************************************************

#ifndef _REFRESH_H_
#define _REFRESH_H_


#define MAX_OBJECTS     128

BOOL CreateRefresher();

BOOL DestroyRefresher();

BOOL Refresh();

BOOL AddObject(
    IN IWbemServices *pSvc,
    IN LPWSTR pszPath
    );

BOOL RemoveObject(IN LONG lObjId);

BOOL ShowObjectList();

BOOL DumpObjectById(LONG);
BOOL DumpObject(IWbemClassObject *);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntperfclient\perfclnt.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  PERFCLNT.CPP
//
//  WBEM perf counter client sample
//
//  raymcc  17-Dec-97       Created.
//  
//***************************************************************************

#define _WIN32_WINNT    0x0400

#include "precomp.h"
#include <stdio.h>
#include <locale.h>

#include <wbemidl.h>
#include <wbemint.h>

#include "refresh.h"


//***************************************************************************
//
//  Prototypes of internally used functions
//
//***************************************************************************

BOOL Startup(OUT IWbemServices **pRetSvc);

void Menu(IN IWbemServices *pSvc);
void MenuEnumClasses(IN IWbemServices *pSvc);
void MenuEnumInstances(IN IWbemServices *pSvc);
void MenuCreateRefresher();
void MenuDeleteRefresher();
void MenuAddObjectsToRefresher(IN IWbemServices *pSvc);
void MenuRemoveObjectsFromRefresher();
void MenuShowObjectList();
void MenuRefresh();
void MenuDumpObject();
void TightRefreshLoop();
void AddALotOfObjects(IWbemServices *pSvc);

//***************************************************************************
//
//  main
//  
//***************************************************************************

void main()
{
    printf("---WBEM Perf Sample Client---\n");

    // Start up by connecting to WBEM.
    // ===============================
    
    IWbemServices *pSvc = 0;
    BOOL bRes = Startup(&pSvc);
    if (bRes == FALSE)
    {
        printf("Unable to start. Terminating\n");
        return;
    }

    // If here, we are operational.
    // ============================

    Menu(pSvc);

    // Cleanup.
    // ========

    DestroyRefresher();
    pSvc->Release();
    CoUninitialize();
}

//***************************************************************************
//
//  Menu
//
//***************************************************************************

void Menu(IN IWbemServices *pSvc)
{
    while (1)
    {   
        printf(
            "\n\n-----------------------------\n"
            "99....Quit\n"
            "1.....Enumerate classes\n"
            "2.....Enumerate instances\n"
            "3.....Create the refresher\n"
            "4.....Delete the refresher\n"
            "5.....Add objects to the refresher\n"
            "6.....Remove objects from the refresher\n"
            "7.....Refresh!\n"
            "8.....Execute tight test loop against the refresher\n"
            "9.....List objects in the refresher\n"
            "10....Dump an object\n"
            "11....Add a lot of objects to the refresher\n"
            ">"
            );

        char buf[32];
        int nChoice = atoi(gets(buf));

        switch (nChoice)
        {
            case 99: return;
            case 1:  MenuEnumClasses(pSvc); break;
            case 2:  MenuEnumInstances(pSvc); break;

            case 3:  MenuCreateRefresher(); break;
            case 4:  MenuDeleteRefresher(); break;
            case 5:  MenuAddObjectsToRefresher(pSvc); break;
            case 6:  MenuRemoveObjectsFromRefresher(); break;
            
            case 7:  MenuRefresh(); break;
            case 8:  TightRefreshLoop(); break;
            case 9:  MenuShowObjectList(); break;
            case 10: MenuDumpObject(); break;
            case 11: AddALotOfObjects(pSvc); break;
        }
    }
}

//***************************************************************************
//
//  Startup
//
//  Logs in to WBEM and returns an active IWbemServices pointer.
//
//***************************************************************************

BOOL Startup(OUT IWbemServices **pRetSvc)
{
    CoInitializeEx(0, COINIT_MULTITHREADED);
    printf("Locale info = %s\n", setlocale(LC_ALL, ""));
    *pRetSvc = 0;

    // Try to bring up the locator.
    // ============================

    IWbemLocator *pLoc = 0;

    DWORD dwRes = CoCreateInstance(CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, (LPVOID *) &pLoc);
 
    if (dwRes != S_OK)
    {
        printf("Failed to create IWbemLocator object.\n");
        CoUninitialize();
        return FALSE;
    }

    // Connect.
    // ========

    IWbemServices *pSvc = 0;

    BSTR Ns = SysAllocString(L"\\\\.\\ROOT\\DEFAULT");

    HRESULT hRes = pLoc->ConnectServer(
            Ns,                                 // NT perf data namespace 
            NULL,                               // User
            NULL,                               // Password
            0,                                  // Locale
            0,                                  // Authentication type
            0,                                  // Authority
            0,                                  // Context
            &pSvc
            );

    SysFreeString(Ns);

    if (hRes)
    {
        printf("Could not connect. Error code = 0x%X\n", hRes);
        CoUninitialize();
        return FALSE;
    }

    pLoc->Release();    // Don't need the locator any more.

    // Return pointer to user.
    // =======================
        
    *pRetSvc = pSvc;
    return TRUE;
}

//***************************************************************************
//
//  EnumClasses
//
//  Enumerates all the available classes, showing only perf-related classes
//  (filtering out WBEM-specific classes).
//
//***************************************************************************

void MenuEnumClasses(IN IWbemServices *pSvc)
{
    IEnumWbemClassObject *pEnum = 0;

    HRESULT hRes = pSvc->CreateClassEnum(
        NULL,
        WBEM_FLAG_DEEP,
        NULL,
        &pEnum
        );


    if (hRes != WBEM_NO_ERROR)
    {
        printf("Failed to create enumerator\n");
        return;
    }
    
    // If here, we can show all the available classes.
    // ===============================================

    ULONG uTotalClasses = 0;
    ULONG uTotalPerfClasses = 0;

    for (;;)
    {
        // Ask for the classes one at a time.
        // ==================================

        IWbemClassObject *pObj = 0;
        ULONG uReturned = 0;

        hRes = pEnum->Next(
            0,                  // timeout
            1,                  // Ask for one object
            &pObj,
            &uReturned
            );

        uTotalClasses += uReturned;

        if (uReturned == 0)
            break;

        // See whether the class is perf-related or not by
        // checking for the "perf" qualifier on the class def.
        // ===================================================
        
        IWbemQualifierSet *pQSet = 0;
        pObj->GetQualifierSet(&pQSet);

        BSTR TargetQualifier = SysAllocString(L"perf");
        HRESULT hRes = pQSet->Get(TargetQualifier, 0, 0, 0);
        SysFreeString(TargetQualifier);        
        
        if (hRes == WBEM_E_NOT_FOUND)
        {
            // Must be a WBEM class and not a perf class, so skip it.
            // ======================================================
            pObj->Release();
            continue;       // Back to top of the forever loop
        }
    
        uTotalPerfClasses++;

        // Get the class name.
        // ===================
        
        VARIANT v;
        VariantInit(&v);

        BSTR PropName = SysAllocString(L"__CLASS");

        pObj->Get(PropName, 0, &v, 0, 0);
        printf("Retrieved perf class %S\n", V_BSTR(&v));

        SysFreeString(PropName);
        
        // Done with this object.
        // ======================

        pObj->Release();
    }

    // Cleanup.
    // ========

    pEnum->Release();
    
    printf("A total of %u WBEM classes and %u Perf Classes were retrieved\n", 
        uTotalClasses,
        uTotalPerfClasses
        );
}


//***************************************************************************
//
//  MenuEnumInstances
//
//  Enumerates available instances for a given class.
//
//***************************************************************************

void MenuEnumInstances(IWbemServices *pSvc)
{
    wchar_t ClassName[128];
        
    printf("Enter class name:\n");
    _getws(ClassName);

    BSTR bstrClassName = SysAllocString(ClassName);

    IEnumWbemClassObject *pEnum = 0;

    HRESULT hRes = pSvc->CreateInstanceEnum(
        bstrClassName,
        WBEM_FLAG_DEEP,
        NULL,
        &pEnum
        );

    SysFreeString(bstrClassName);

    if (hRes != WBEM_NO_ERROR)
    {
        printf("Failed to create enumerator. Error code = 0x%X\n", hRes);
        return;
    }
    
    // If here, we can show all the available instances.
    // =================================================

    ULONG uTotalInstances = 0;

    for (;;)
    {
        // Ask for the classes one at a time.
        // ==================================

        IWbemClassObject *pObj = 0;
        ULONG uReturned = 0;

        hRes = pEnum->Next(
            0,                  // timeout
            1,                  // Ask for one object
            &pObj,
            &uReturned
            );

        uTotalInstances += uReturned;

        if (uReturned == 0)
            break;

        // Get the path so that we can identify the object.
        // ================================================
        
        VARIANT v;
        VariantInit(&v);
        
        BSTR Path = SysAllocString(L"__RELPATH");
        
        pObj->Get(Path, 0, &v, 0, 0);

        printf("Object = %S\n", V_BSTR(&v));

        VariantClear(&v);
        SysFreeString(Path);

        // Done with this object.
        // ======================

        pObj->Release();
    }

    // Cleanup.
    // ========

    pEnum->Release();
    
    printf("A total of %u instances were retrieved\n", uTotalInstances);
}


//***************************************************************************
//
//  MenuCreateRefresher
//
//  Creates the refresher for this sample.
//
//***************************************************************************

void MenuCreateRefresher()
{
    BOOL bRes = CreateRefresher();
    if (bRes == TRUE)
        printf("New refresher created.\n");
    else
        printf("Refresher failed to create\n");        
}

//***************************************************************************
//
//  MenuDeleteRefresher
//
//  Deletes the refresher for this sample.
//
//***************************************************************************

void MenuDeleteRefresher()
{
    BOOL bRes = DestroyRefresher();
    if (bRes)
        printf("Success\n");
    else
        printf("Failed\n");        
}


//***************************************************************************
//
//  MenuAddObjectsToRefresher
//
//  Adds arbitrary objects to the refresher.
//
//***************************************************************************

void MenuAddObjectsToRefresher(IWbemServices *pSvc)
{
    wchar_t ObjPath[256];
    
    printf("Enter object path:");
    _getws(ObjPath);

    BOOL bRes = AddObject(pSvc, ObjPath);
    
    if (bRes == FALSE)
    {
        printf("Failed to add object\n");
        return;
    }
    
    printf("Added object successfully\n");
}

//***************************************************************************
//
//  MenuRemoveObjectsFromRefresher
//
//  Removes a selected object from the refresher.
//
//***************************************************************************

void MenuRemoveObjectsFromRefresher()
{
    char buf[32];
    
    printf("Enter object id to remove:");
    LONG lObjId = atol(gets(buf));
    
    BOOL bRes = RemoveObject(lObjId);

    if (bRes)
        printf("Success\n");
    else
        printf("Failed to remove object\n");        
}


//***************************************************************************
//
//  MenuRefresh
//
//  Executes a single refresh, which refreshes all the objects in the
//  refresher.
//
//***************************************************************************

void MenuRefresh()
{
    BOOL bRes = Refresh();
    if (bRes)
        printf("Sucess\n");
    else
        printf("Failed\n");        
}


//***************************************************************************
//
//  MenuShowObjectList
//
//  Shows the paths of all the objects in the refresher.
//
//***************************************************************************

void MenuShowObjectList()
{
    ShowObjectList();
}

//***************************************************************************
//
//  MenuDumpObject
//
//  Given an ID, dumps that object to the screen.
//
//***************************************************************************

void MenuDumpObject()
{
    char buf[32];
    
    printf("Enter object id to dump:\n");
    LONG lObjId = atol(gets(buf));    
    
    
    BOOL bRes = DumpObjectById(lObjId);
    
    if (bRes)
        printf("Success\n");
    else
        printf("Failed to locate and dump object\n");
}

//***************************************************************************
//
//  TightRefreshLoop
//
//  Executes a tight refresh loop with user-specified iterations and
//  Sleep time in between iterations.  Used to check performance during
//  refresh execution.
//
//***************************************************************************

void TightRefreshLoop()
{
    char buf[32];
    LONG lSleep = 0;
    int nIterations = 0;

    printf("Enter total number of iterations:");
    nIterations = atoi(gets(buf));
    printf("Enter Sleep() time between iterations:");
    lSleep = atol(gets(buf));

    DWORD dwStart = GetCurrentTime();
    
    for (int i = 0; i < nIterations; i++)
    {
        Refresh();
        if (lSleep)
            Sleep(lSleep);
    }
    
    DWORD dwElapsed = GetCurrentTime() - dwStart;
    
    printf("Elapsed time = %d milliseconds\n", dwElapsed);
}

//***************************************************************************
//
//  AddALotOfObjects
//
//  Adds a bunch of copies of the same object to the refresher.  This
//  helps to quickly simulate a load, since it is as difficult to refresh
//  10 copies of the same object as to refresh 10 different objects.
//
//***************************************************************************

void AddALotOfObjects(IWbemServices *pSvc)
{
    printf("Adding many copies of the same object to the refresher to simulate a load.\n");

    wchar_t ObjPath[256];
    
    printf("Enter object path:");
    _getws(ObjPath);

    char buf[32];
    printf("Number of copies:");
    int nNumObjects = atoi(gets(buf));

    for (int i = 0; i < nNumObjects; i++)
    {    
        BOOL bRes = AddObject(pSvc, ObjPath);
        
        if (bRes == FALSE)
        {
            printf("Failed to add object\n");
            return;
        }
    }        
    
    printf("Added objects successfully\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntperfshell\ntperf.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

//***************************************************************************
//
//  NTPERF.CPP
//  
//  Sample NT5 Perf Counter Provider
//
//  raymcc      02-Dec-97   Created        
//  raymcc      20-Feb-98   Updated to use new initializer
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>

#include <wbemidl.h>

#include <wbemint.h>

#include "ntperf.h"

//***************************************************************************
//
//  CNt5Refresher constructor
//
//***************************************************************************
// ok

CNt5Refresher::CNt5Refresher()
{
    m_lRef = 0;     // COM Ref Count
    
    // Set the instance cache to all zeros.
    // As objects are added to the refresher
    // we simply put them in unused slots in the array.
    // ================================================
    
    for (int i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        m_aInstances[i] = 0;
    }

    // Set the values of the property handles to zero.
    // ===============================================

    m_hName     = 0;
    m_hCounter1 = 0;
    m_hCounter2 = 0;
    m_hCounter3 = 0;
}

//***************************************************************************
//
//  CNt5Refresher destructor
//
//***************************************************************************
// ok

CNt5Refresher::~CNt5Refresher()
{
    // Release the cached IWbemObjectAccess instances.
    // ===============================================
    
    for (DWORD i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        if (m_aInstances[i])
            m_aInstances[i]->Release();
    }            
}

//***************************************************************************
//
//  CNt5Refresher::Refresh
//
//  Executed to refresh a set of instances bound to the particular 
//  refresher.
//
//***************************************************************************
// ok

HRESULT CNt5Refresher::Refresh(/* [in] */ long lFlags)
{
    // Zip through all the objects and increment the values.
    // =====================================================
    
    for (DWORD i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        // Get the object at this location.
        // ================================

        IWbemObjectAccess *pAccess = m_aInstances[i];

        // If there is no object in this array slot (a NULL pointer)
        // there is nothing to refresh.
        // =========================================================

        if (pAccess == 0)       
            continue;

        // Increment all the counter values to simulate an update.
        // The client already has a pointer to this object, so
        // all we have to do is update the values.
        // =======================================================
                        
        DWORD dwVal;
        pAccess->ReadDWORD(m_hCounter1, &dwVal);
        dwVal++;
        pAccess->WriteDWORD(m_hCounter1, dwVal);
        
        pAccess->ReadDWORD(m_hCounter3, &dwVal); 
        dwVal++;       
        pAccess->WriteDWORD(m_hCounter3, dwVal);

        unsigned __int64 qwVal;
        pAccess->ReadQWORD(m_hCounter2, &qwVal);
        qwVal++;
        pAccess->WriteQWORD(m_hCounter2, qwVal);
    }        

    return NO_ERROR;
}

//***************************************************************************
//
//  CNt5Refresher::TransferPropHandles
//
//  This is a private mechanism used by CNt5PerfProvider.
//  It is used to copy the property handles from the
//  hi-perf provider object to the refresher.  We need these handles to 
//  quickly access the properties in each instance.  The same handles are 
//  used for all instances.
//
//***************************************************************************
// ok

void CNt5Refresher::TransferPropHandles(CNt5PerfProvider *pSrc)
{
    m_hName     = pSrc->m_hName;
    m_hCounter1 = pSrc->m_hCounter1;
    m_hCounter2 = pSrc->m_hCounter2;
    m_hCounter3 = pSrc->m_hCounter3;
}

//***************************************************************************
//
//  CNt5Refresher::AddRef
//
//  Standard COM AddRef().
//
//***************************************************************************
// ok
ULONG CNt5Refresher::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CNt5Refresher::Release
//
//  Standard COM Release().
//
//***************************************************************************
// ok
ULONG CNt5Refresher::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//  CNt5Refresher::QueryInterface
//
//  Standard COM QueryInterface().
//
//***************************************************************************
// ok

HRESULT CNt5Refresher::QueryInterface(REFIID riid, void** ppv)
{
    if (riid == IID_IUnknown || riid == IID_IWbemRefresher)
    {
        *ppv = (IWbemRefresher *) this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}

//***************************************************************************
//
//  CNt5Refresher::AddObject
//
//  Adds an object to the refresher.   This is a private mechanism
//  used by CNt5PerfProvider and not part of the COM interface.
//
//  The ID we return for future identification is simply
//  the array index.
//
//***************************************************************************
// ok

BOOL CNt5Refresher::AddObject(
    IWbemObjectAccess *pObj, 
    LONG *plId
    )
{
    for (DWORD i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        if (m_aInstances[i] == 0)
        {
            pObj->AddRef();
            m_aInstances[i] = pObj;
            
            // The ID we return for future identification is simply
            // the array index.
            // ====================================================
            *plId = i;
            return TRUE;
        }
    }        

    return FALSE;
}


//***************************************************************************
//
//  CNt5Refresher::RemoveObject
//
//  This is a private mechanism used by CNt5PerfProvider and not 
//  part of the COM interface.
//
//  Removes an object from the refresher by ID.   In our case, the ID
//  is actually the array index we used internally, so it is simple
//  to locate and remove the object.
//
//***************************************************************************

BOOL CNt5Refresher::RemoveObject(LONG lId)
{
    if (m_aInstances[lId] == 0)
        return FALSE;
        
    m_aInstances[lId]->Release();
    m_aInstances[lId] = 0;
    
    return TRUE;        
}



//***************************************************************************
//
//  CNt5PerfProvider constructor
//
//***************************************************************************
// ok

CNt5PerfProvider::CNt5PerfProvider()
{
    m_lRef = 0;
    m_pSampleClass = 0;

    // All the instances we work with are cached internally.
    // =====================================================
    
    for (int i = 0; i < NUM_SAMPLE_INSTANCES; i++)
        m_aInstances[i] = 0;

    // Property value handles.
    // =======================

    m_hName    = 0;         // "Name" property in the MOF
    m_hCounter1 = 0;        // "Counter1" in the MOF
    m_hCounter2 = 0;        // "Counter2" in the MOF
    m_hCounter3 = 0;        // "Counter3" in the MOF
}

//***************************************************************************
//
//  CNt5PerfProvider destructor
//
//***************************************************************************
// ok

CNt5PerfProvider::~CNt5PerfProvider()
{
    // Release all the objects which have been added to the array.
    // ===========================================================

    for (int i = 0; i < NUM_SAMPLE_INSTANCES; i++)
        if (m_aInstances[i])
            m_aInstances[i]->Release();
        
    if (m_pSampleClass)
        m_pSampleClass->Release();        
}


//***************************************************************************
//
//  CNt5Refresher::AddRef
//
//  Standard COM AddRef().
//
//***************************************************************************
// ok

ULONG CNt5PerfProvider::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CNt5Refresher::Release
//
//  Standard COM Release().
//
//***************************************************************************
// ok

ULONG CNt5PerfProvider::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//  CNt5Refresher::QueryInterface
//
//  Standard COM QueryInterface().  We have to support two interfaces,
//  the IWbemHiPerfProvider interface itself to provide the objects and
//  the IWbemProviderInit interface to initialize the provider.
//
//***************************************************************************
// ok

HRESULT CNt5PerfProvider::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemHiPerfProvider)
    {
        *ppv = (IWbemHiPerfProvider*) this;
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IWbemProviderInit)
    {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}


//***************************************************************************
//
//  CNt5Refresher::Initialize
//
//  Called once during startup.  Insdicates to the provider which
//  namespace it is being invoked for and which User.  It also supplies
//  a back pointer to WINMGMT so that class definitions can be retrieved.
//
//  We perform any one-time initialization in this routine. The
//  final call to Release() is for any cleanup.
//
//  <wszUser>           The current user.
//  <lFlags>            Reserved.
//  <wszNamespace>      The namespace for which we are being activated.
//  <wszLocale>         The locale under which we are to be running.
//  <pNamespace>        An active pointer back into the current namespace
//                      from which we can retrieve schema objects.
//  <pCtx>              The user's context object.  We simply reuse this
//                      during any reentrant operations into WINMGMT.
//  <pInitSink>         The sink to which we indicate our readiness.
//
//***************************************************************************
// ok

HRESULT CNt5PerfProvider::Initialize( 
    /* [unique][in] */  LPWSTR wszUser,
    /* [in] */          LONG lFlags,
    /* [in] */          LPWSTR wszNamespace,
    /* [unique][in] */  LPWSTR wszLocale,
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemProviderInitSink __RPC_FAR *pInitSink
    )
{
    BSTR PropName = 0;
    IWbemObjectAccess *pAccess = 0;
        
    // Get a copy of our sample class def so that we can create & maintain
    // instances of it.
    // ===================================================================

    HRESULT hRes = pNamespace->GetObject(BSTR(L"Win32_Nt5PerfTest"), 
        0, pCtx, &m_pSampleClass, 0
        );

    if (hRes)
        return hRes;

    // Precreate 10 instances, and set them up in an array which
    // is a member of this C++ class.
    //
    // We only store the IWbemObjectAccess pointers, since
    // we are updating 'well-known' properties and already 
    // know their names.
    // ==========================================================

    for (int i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        IWbemClassObject *pInst = 0;
        m_pSampleClass->SpawnInstance(0, &pInst);

        // Write out the instance name.
        // ============================

        wchar_t buf[128];
        swprintf(buf, L"Inst_%d", i);

        VARIANT vName;
        VariantInit(&vName);
        V_BSTR(&vName) = SysAllocString(buf);
        V_VT(&vName) = VT_BSTR;

        BSTR PropName = SysAllocString(L"Name");
        pInst->Put(PropName, 0, &vName, 0);
        SysFreeString(PropName);
        VariantClear(&vName);
                        
        pInst->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) &pAccess);
        
        m_aInstances[i] = pAccess;
        pInst->Release();
    }


    // Get the property handles for the well-known properties in
    // this counter type.  We cache the property handles
    // for each property so that we can transfer them to the
    // refresher later on.
    // =========================================================    

    m_pSampleClass->QueryInterface(IID_IWbemObjectAccess, 
        (LPVOID *) &pAccess);


    PropName = SysAllocString(L"Name");
    hRes = pAccess->GetPropertyHandle(PropName, 0, &m_hName);
    SysFreeString(PropName);

    PropName = SysAllocString(L"Counter1");
    hRes = pAccess->GetPropertyHandle(PropName, 0, &m_hCounter1);
    SysFreeString(PropName);

    PropName = SysAllocString(L"Counter2");    
    hRes = pAccess->GetPropertyHandle(PropName, 0, &m_hCounter2);
    SysFreeString(PropName);
    
    PropName = SysAllocString(L"Counter3");    
    hRes = pAccess->GetPropertyHandle(PropName, 0, &m_hCounter3);
    SysFreeString(PropName);

    pAccess->Release();

    // Now let's set all the instance to some default values.
    // ======================================================
    
    for (i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        IWbemObjectAccess *pAccess = m_aInstances[i];

        hRes = pAccess->WriteDWORD(m_hCounter1, DWORD(i));
        hRes = pAccess->WriteQWORD(m_hCounter2, (_int64) + 100 + i);
        hRes = pAccess->WriteDWORD(m_hCounter3, DWORD(i + 1000));        
    }
    

    // We now have all the instances ready to go and all the 
    // property handles cached.   Tell WINMGMT that we're
    // ready to start 'providing'.
    // =====================================================

    pInitSink->SetStatus(0, WBEM_S_INITIALIZED);

    return NO_ERROR;
}
    

//***************************************************************************
//
//  CNt5Refresher::QueryInstances
//
//  Called whenever a complete, fresh list of instances for a given
//  class is required.   The objects are constructed and sent back to the
//  caller through the sink.  The sink can be used in-line as here, or
//  the call can return and a separate thread could be used to deliver
//  the instances to the sink.
//
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace.  This
//                      should not be AddRef'ed.
//  <wszClass>          The class name for which instances are required.
//  <lFlags>            Reserved.
//  <pCtx>              The user-supplied context (not used here).
//  <pSink>             The sink to which to deliver the objects.  The objects
//                      can be delivered synchronously through the duration
//                      of this call or asynchronously (assuming we
//                      had a separate thread).  A IWbemObjectSink::SetStatus
//                      call is required at the end of the sequence.
//
//***************************************************************************
// ok
        
HRESULT CNt5PerfProvider::QueryInstances( 
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [string][in] */  WCHAR __RPC_FAR *wszClass,
    /* [in] */          long lFlags,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemObjectSink __RPC_FAR *pSink
    )
{
    if (pNamespace == 0 || wszClass == 0 || pSink == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Quickly zip through the instances and update the values before 
    // returning them.  This is just a dummy operation to make it
    // look like the instances are continually changing like real
    // perf counters.
    // ==============================================================

    for (int i = 0; i < NUM_SAMPLE_INSTANCES; i++)
    {
        IWbemObjectAccess *pAccess = m_aInstances[i];
        
        // Every object can be access one of two ways.  In this case
        // we get the 'other' (primary) interface to this same object.
        // ===========================================================
        
        IWbemClassObject *pOtherFormat = 0;
        pAccess->QueryInterface(IID_IWbemClassObject, (LPVOID *) &pOtherFormat);
        
        
        // Send a copy back to the caller.
        // ===============================
        
        pSink->Indicate(1, &pOtherFormat);

        pOtherFormat->Release();    // Don't need this any more
    }
    
    // Tell WINMGMT we are all finished supplying objects.
    // =================================================

    pSink->SetStatus(0, WBEM_NO_ERROR, 0, 0);

    return NO_ERROR;
}    


//***************************************************************************
//
//  CNt5Refresher::CreateRefresher
//
//  Called whenever a new refresher is needed by the client.
//
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace.  Not used.
//  <lFlags>            Not used.
//  <ppRefresher>       Receives the requested refresher.
//
//***************************************************************************        
// ok

HRESULT CNt5PerfProvider::CreateRefresher( 
     /* [in] */ IWbemServices __RPC_FAR *pNamespace,
     /* [in] */ long lFlags,
     /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher
     )
{
    if (pNamespace == 0 || ppRefresher == 0)
        return WBEM_E_INVALID_PARAMETER;

    // Construct a new empty refresher.
    // ================================        

    CNt5Refresher *pNewRefresher = new CNt5Refresher();

    // Move copies of the property handles to the refresher
    // so that it can quickly update property values during
    // a refresh operation.
    // ====================================================
    
    pNewRefresher->TransferPropHandles(this);
    
    // Follow COM rules and AddRef() the thing before sending it back.
    // ===============================================================
    
    pNewRefresher->AddRef();
    *ppRefresher = pNewRefresher;
    
    return NO_ERROR;
}

//***************************************************************************
//
//  CNt5Refresher::CreateRefreshableObject
//
//  Called whenever a user wants to include an object in a refresher.
//     
//  Parameters:
//  <pNamespace>        A pointer to the relevant namespace in WINMGMT.
//  <pTemplate>         A pointer to a copy of the object which is to be
//                      added.  This object itself cannot be used, as
//                      it not owned locally.        
//  <pRefresher>        The refresher to which to add the object.
//  <lFlags>            Not used.
//  <pContext>          Not used here.
//  <ppRefreshable>     A pointer to the internal object which was added
//                      to the refresher.
//  <plId>              The Object Id (for identification during removal).        
//
//***************************************************************************        
// ok

HRESULT CNt5PerfProvider::CreateRefreshableObject( 
    /* [in] */ IWbemServices __RPC_FAR *pNamespace,
    /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext __RPC_FAR *pContext,
    /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
    /* [out] */ long __RPC_FAR *plId
    )
{
    // The object supplied by <pTemplate> must not be copied.
    // Instead, we want to find out which object the caller is after
    // and return a pointer to *our* own private instance which is 
    // already set up internally.  This value will be sent back to the
    // caller so that everyone is sharing the same exact instance
    // in memory.
    // ===============================================================

    // Find out which object is being requested for addition.
    // ======================================================
    
    wchar_t buf[128];
    *buf = 0;
    LONG lNameLength = 0;    
    pTemplate->ReadPropertyValue(m_hName, 128, &lNameLength, LPBYTE(buf));
    
    // Scan out the index from the instance name.  We only do this
    // because the instance name is a string.
    // ===========================================================

    DWORD dwIndex = 0;    
    swscanf(buf, L"Inst_%u", &dwIndex);
    // Now we know which object is desired.
    // ====================================
    
    IWbemObjectAccess *pOurCopy = m_aInstances[dwIndex];

    // The refresher being supplied by the caller is actually
    // one of our own refreshers, so a simple cast is convenient
    // so that we can access private members.
    // =========================================================
        
    CNt5Refresher *pOurRefresher = (CNt5Refresher *) pRefresher;

    pOurRefresher->AddObject(pOurCopy, plId);

    // Return a copy of the internal object.
    // =====================================
        
    pOurCopy->AddRef();
    *ppRefreshable = pOurCopy;
    *plId = LONG(dwIndex);

    return NO_ERROR;
}
    

//***************************************************************************
//
//  CNt5Refresher::StopRefreshing
//
//  Called whenever a user wants to remove an object from a refresher.
//     
//  Parameters:
//  <pRefresher>            The refresher object from which we are to 
//                          remove the perf object.
//  <lId>                   The ID of the object.
//  <lFlags>                Not used.
//  
//***************************************************************************        
// ok
        
HRESULT CNt5PerfProvider::StopRefreshing( 
    /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
    /* [in] */ long lId,
    /* [in] */ long lFlags
    )
{
    // The refresher being supplied by the caller is actually
    // one of our own refreshers, so a simple cast is convenient
    // so that we can access private members.
    // =========================================================
        
    CNt5Refresher *pOurRefresher = (CNt5Refresher *) pRefresher;

    pOurRefresher->RemoveObject(lId);

    return NO_ERROR;
}
    
//***************************************************************************
//
//  CNt5Refresher::CreateRefreshableEnum
//
//  Called whenever a user wants to create an enumeration in a refresher.
//     
//  Parameters:
//  <pNamespace>            The namespace this is for
//  <wszClass>              Name of the class we are enumerating
//  <pRefresher>            The refresher object from which we are to 
//                          remove the perf object.
//  <lFlags>                Not used.
//  <pContext>              Wbem Context object
//  <pHiPerfEnum>           Enumerator object into which refresher should place
//                          its results
//  <plId>                  The enum id (for identification during removal)
//  
//***************************************************************************        
// ok
HRESULT CNt5PerfProvider::CreateRefreshableEnum( 
    /* [in] */ IWbemServices* pNamespace,
    /* [in, string] */ LPCWSTR wszClass,
    /* [in] */ IWbemRefresher* pRefresher,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext* pContext,
    /* [in] */ IWbemHiPerfEnum* pHiPerfEnum,
    /* [out] */ long* plId )
{
    // Just a placeholder for now
    return E_NOTIMPL;
}

//***************************************************************************
//
//  CNt5Refresher::CreateRefreshableEnum
//
//  Called whenever a user wants to create an enumeration in a refresher.
//     
//  Parameters:
//  <pNamespace>            The namespace this is for
//  <lNumObjects>           Number of objects in the array
//  <apObj>                 Objects to retrieve (keys are set)
//  <lFlags>                Not used.
//  <pContext>              Wbem Context object
//  <pHiPerfEnum>           Enumerator object into which refresher should place
//                          its results
//  <plId>                  The enum id (for identification during removal)
//  
//***************************************************************************        
// ok
HRESULT CNt5PerfProvider::GetObjects( 
    /* [in] */ IWbemServices* pNamespace,
    /* [in] */ long lNumObjects,
    /* [in,size_is(lNumObjects)] */ IWbemObjectAccess** apObj,
    /* [in] */ long lFlags,
    /* [in] */ IWbemContext* pContext)
{
    // Just a placeholder for now
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntperf\server.cpp ===
//***************************************************************************
//
//  Copyright (c) 1996-2001, Microsoft Corporation, All rights reserved
//
//  SERVER.CPP
//
//  Generic COM server framework, adapted for the NT perf counter sample
//
//  This module contains nothing specific to the NT perf counter provider
//  except what is defined in the section bracketed by the CLSID SPECIFIC
//  comments below.
//
//  History:
//  raymcc        25-Nov-97     Created.
//  raymcc        18-Feb-98     Updated for NT5 Beta 2 version.
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <initguid.h>


/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN CLSID SPECIFIC SECTION
//
//

#include <wbemidl.h>
#include <wbemint.h>
#include <ntperf.h>

// {FF37A93C-C28E-11d1-AEB6-00C04FB68820}
DEFINE_GUID(CLSID_NT5PerfProvider_V1,
0xff37a93c, 0xc28e, 0x11d1, 0xae, 0xb6, 0x0, 0xc0, 0x4f, 0xb6, 0x88, 0x20);


#define IMPLEMENTED_CLSID           CLSID_NT5PerfProvider_V1
#define SERVER_REGISTRY_COMMENT     L"WBEM NT5 Base Perf Provider"
#define CPP_CLASS_NAME              CNt5PerfProvider
#define INTERFACE_CAST              (IWbemHiPerfProvider *)

//
//  END CLSID SPECIFIC SECTION
//
/////////////////////////////////////////////////////////////////////////////




HINSTANCE g_hInstance;
static ULONG g_cLock = 0;

void ObjectCreated()    { g_cLock++; }
void ObjectDestroyed() { g_cLock--; }


//***************************************************************************
//
//  class CFactory
//
//  Generic implementation of IClassFactory for CWbemLocator.
//
//***************************************************************************

class CFactory : public IClassFactory
{
    ULONG           m_cRef;
    CLSID           m_ClsId;

public:
    CFactory(const CLSID & ClsId);
    ~CFactory();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IClassFactory members
    //
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP     LockServer(BOOL);
};




//***************************************************************************
//
//  DllMain
//
//  Dll entry point.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        setlocale(LC_ALL, "");      // Set to the 'current' locale
        g_hInstance = hinstDLL;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
    }

    return TRUE;
}



//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance.
//
//  PARAMETERS:
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    CFactory *pFactory;

    //
    //  Verify the caller is asking for our type of object.
    //
    if (IMPLEMENTED_CLSID != rclsid) 
            return ResultFromScode(E_FAIL);

    //
    // Check that we can provide the interface.
    //
    if (IID_IUnknown != riid && IID_IClassFactory != riid)
        return ResultFromScode(E_NOINTERFACE);

    //
    // Get a new class factory.
    //
    pFactory = new CFactory(rclsid);

    if (!pFactory)
        return ResultFromScode(E_OUTOFMEMORY);

    //
    // Verify we can get an instance.
    //
    HRESULT hRes = pFactory->QueryInterface(riid, ppv);

    if (FAILED(hRes))
        delete pFactory;

    return hRes;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllCanUnloadNow(void)
{
    SCODE sc = TRUE;

    if (g_cLock)
        sc = S_FALSE;

    return sc;
}

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllRegisterServer(void)
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];

    // Where are we?
    // =============
    GetModuleFileNameW(g_hInstance, Path, 1024);

    // Convert CLSID to string.
    // ========================

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Place it in registry.
    // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
    //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 : <no_name> : "path to DLL"
    //                                    : ThreadingModel : "both"
    // ==============================================================

    HKEY hKey;
    LONG lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    wchar_t *pName = SERVER_REGISTRY_COMMENT; 
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, wcslen(pName) * 2 + 2);

    HKEY hSubkey;
    lRes = RegCreateKey(hKey, "InprocServer32", &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, wcslen(Path) * 2 + 2);
    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Delete InProcServer32 subkey.
    // =============================
    LONG lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, L"InprocServer32");
    RegCloseKey(hKey);

    // Delete CLSID GUID key.
    // ======================

    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}




//***************************************************************************
//
//  CFactory::CFactory
//
//  Constructs the class factory given the CLSID of the objects it is supposed
//  to create.
//
//  PARAMETERS:
//
//      const CLSID & ClsId     The CLSID. 
//
//***************************************************************************
CFactory::CFactory(const CLSID & ClsId)
{
    m_cRef = 0;
    ObjectCreated();
    m_ClsId = ClsId;
}

//***************************************************************************
//
//  CFactory::~CFactory
//
//  Destructor.
//
//***************************************************************************
CFactory::~CFactory()
{
    ObjectDestroyed();
}

//***************************************************************************
//
//  CFactory::QueryInterface, AddRef and Release
//
//  Standard IUnknown methods.
//
//***************************************************************************
STDMETHODIMP CFactory::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
    {
        *ppv = this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


ULONG CFactory::AddRef()
{
    return ++m_cRef;
}


ULONG CFactory::Release()
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  CFactory::CreateInstance
//
//  PARAMETERS:
//
//      LPUNKNOWN pUnkOuter     IUnknown of the aggregator. Must be NULL.
//      REFIID riid             Interface ID required.
//      LPVOID * ppvObj         Destination for the interface pointer.
//
//  RETURN VALUES:
//
//      S_OK                        Success
//      CLASS_E_NOAGGREGATION       pUnkOuter must be NULL
//      E_NOINTERFACE               No such interface supported.
//      
//***************************************************************************

STDMETHODIMP CFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID * ppvObj)
{
    IUnknown* pObj;
    HRESULT  hr;

    //
    //  Defaults
    //
    *ppvObj=NULL;
    hr = ResultFromScode(E_OUTOFMEMORY);

    //
    // We aren't supporting aggregation.
    //
    if (pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    if (m_ClsId == IMPLEMENTED_CLSID)
    {
        pObj = INTERFACE_CAST new CPP_CLASS_NAME;
    }

    if (!pObj)
        return hr;

    //
    //  Initialize the object and verify that it can return the
    //  interface in question.
    //
    hr = pObj->QueryInterface(riid, ppvObj);

    //
    // Kill the object if initial creation or Init failed.
    //
    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//  CFactory::LockServer
//
//  Increments or decrements the lock count of the server. The DLL will not
//  unload while the lock count is positive.
//
//  PARAMETERS:
//
//      BOOL fLock      If TRUE, locks; otherwise, unlocks.
//
//  RETURN VALUES:
//
//      S_OK
//
//***************************************************************************
STDMETHODIMP CFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *) &g_cLock);
    else
        InterlockedDecrement((LONG *) &g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntperfclient\refresh.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  REFRESH.CPP
//
//  Contains a single sample global refresher
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <wbemidl.h>

#include <wbemint.h>

#include "refresh.h"

//***************************************************************************
//
// Local globals (!)
//
//***************************************************************************

static DWORD             g_dwNumObjects = 0;
static IWbemRefresher   *g_pRefresher = 0;

static IWbemClassObject *g_aObjects[MAX_OBJECTS];
static LONG              g_aObjIDs[MAX_OBJECTS];

static IWbemConfigureRefresher *g_pCfgRef = 0;

//***************************************************************************
//
//  CreateRefresher
//
//***************************************************************************

BOOL CreateRefresher()
{
    if (g_pCfgRef != 0)
    {
        printf("Refresher already created\n");
        return FALSE;       
    }

    // Create an empty refresher.
    // ===========================

    DWORD dwRes = CoCreateInstance(CLSID_WbemRefresher, 0, CLSCTX_SERVER,
            IID_IWbemRefresher, (LPVOID *) &g_pRefresher);
 
    if (dwRes != S_OK)
    {
        printf("Failed to create a new refresher.\n");
        return FALSE;
    }

    // Create the refresher manager.
    // =============================

    dwRes = g_pRefresher->QueryInterface(IID_IWbemConfigureRefresher, 
        (LPVOID *) &g_pCfgRef);


    if (dwRes)
    {
        g_pRefresher->Release();
        g_pRefresher = 0;
        printf("Failed to create the refresher manager\n");
        return FALSE;
    }

    return TRUE;
}

//***************************************************************************
//
//  Refresh
//
//  Called to refresh all the objects in the refresher.
// 
//***************************************************************************
// ok

BOOL Refresh()
{
    if (g_pRefresher == 0)
    {
        printf("No active refresher!\n");
        return FALSE;
    }

    HRESULT hRes = g_pRefresher->Refresh(0);  
    if (hRes)
        return FALSE;
    return TRUE;
}


//***************************************************************************
//
//  DestroyRefresher
//
//***************************************************************************
// ok

BOOL DestroyRefresher()
{
    if (g_pRefresher == 0)
    {
        printf("No active refresher!\n");
        return FALSE;
    }

    g_pRefresher->Release();
    g_pRefresher = 0;

    g_pCfgRef->Release();
    g_pCfgRef = 0;

    for (DWORD i = 0; i < g_dwNumObjects; i++)
    {
        g_aObjIDs[i] = 0;
        g_aObjects[i]->Release();
        g_aObjects[i] = 0;
    }

    g_dwNumObjects = 0;

    return TRUE;
}

//***************************************************************************
//
//  AddObject
//  
//  Adds an object to the refresher and returns its ID.  The ID is
//  refresher specific (if more than one refresher is used, the
//  IDs can overlap).
//
//  Parameters:
//      pSvc            IWbemServices pointing to the correct namespace
//      pszPath         The path to the object
//
//  Return value:
//      TRUE on success, FALSE on fail.
//  
//***************************************************************************
// ok

BOOL AddObject(
    IN IWbemServices *pSvc,
    IN LPWSTR pszPath
    )
{
    LONG lObjId;

    if (g_pRefresher == 0)
    {
        printf("No active refresher!\n");
        return FALSE;
    }

    // Make sure there is room.
    // ========================

    if (g_dwNumObjects == MAX_OBJECTS)
    {
        printf("No more room in object array\n");
        return FALSE;
    }

    // Add the object to the refresher.
    // =================================

    IWbemClassObject *pRefreshableCopy = 0;

    HRESULT hRes = g_pCfgRef->AddObjectByPath(
        pSvc,
        pszPath,
        0,
        0,
        &pRefreshableCopy,
        &lObjId
        );

    // See if we succeeded.
    // ====================
    if (hRes)
    {
        printf("Failed to add object %S to refresher. WBEM error code = 0x%X\n",
            pszPath,
            hRes
            );
        return FALSE;
    }

    // Record the object and its id.
    // =============================
    g_aObjects[g_dwNumObjects] = pRefreshableCopy;
    g_aObjIDs[g_dwNumObjects] = lObjId;

    g_dwNumObjects++;   // Keeps track of how many objects we have


    return TRUE;
}

//***************************************************************************
//
//  RemoveObject
//
//  Removes an object from the refresher.
//
//***************************************************************************
// ok

BOOL RemoveObject(IN LONG lObjId)
{
    if (g_pRefresher == 0)
    {
        printf("No active refresher!\n");
        return FALSE;
    }
    
    // Remove the obejct from our local bookkeeping.
    // =============================================

    for (DWORD i = 0; i < g_dwNumObjects; i++)
    {
        if (g_aObjIDs[i] == lObjId)
        {
            g_aObjIDs[i] = 0;                   // Remove the ID
            g_aObjects[i]->Release();           // Release the object
            g_aObjects[i] = 0;                  // Zero it for purity

            // Remove this element from the two arrays.            
            // ========================================

            for (DWORD i2 = i; i2 < g_dwNumObjects - 1; i2++)
            {
                g_aObjIDs[i2] = g_aObjIDs[i2 + 1];
                g_aObjects[i2] = g_aObjects[i2 + 1];
            }                

            g_dwNumObjects--;
        }
    }

    // Officially remove the object from the WBEM refresher.
    // =====================================================

    HRESULT hRes = g_pCfgRef->Remove(
        lObjId,
        0
        );

    if (hRes)
    {
        return FALSE;
    }

    return TRUE;
}


//***************************************************************************
//
//  ShowObjectList
//
//  Shows all the objects in the refresher.
//
//***************************************************************************

BOOL ShowObjectList()
{
    if (g_pRefresher == 0)
    {
        printf("No active refresher!\n");
        return FALSE;
    }

    BSTR PropName = SysAllocString(L"__RELPATH");

    for (DWORD i = 0; i < g_dwNumObjects; i++)
    {
        VARIANT v;
        VariantInit(&v);

        g_aObjects[i]->Get(PropName, 0, &v, 0, 0);

        printf("Object ID = %u  Path = %S\n", g_aObjIDs[i], V_BSTR(&v));

        VariantClear(&v);
    }

    SysFreeString(PropName);

    printf("---Total of %u object(s)\n", g_dwNumObjects);

    return TRUE;
}

//***************************************************************************
//
//  DumpObjectById
//
//  Dumps the object's contents.
//
//***************************************************************************

BOOL DumpObjectById(LONG lObjId)
{
    for (DWORD i = 0; i < g_dwNumObjects; i++)
    {
        if (g_aObjIDs[i] == lObjId)
        {
            DumpObject(g_aObjects[i]);
            return TRUE;
        }
    }
    return FALSE;    
}


//***************************************************************************
//
//  DumpObject
//
//  Dumps out the contents of the object.
//
//***************************************************************************

BOOL DumpObject(IWbemClassObject *pObj)
{
    DWORD i;
    BSTR PropNames[64] = {0};
    DWORD dwNumPropNames = 0;
    VARIANT v;
    VariantInit(&v);


    printf("----Object Dump----\n");

    // Print out the object path to identify it.
    // =========================================

    BSTR PropName = SysAllocString(L"__RELPATH");

    pObj->Get(PropName, 0, &v, 0, 0);
    printf("Path    = %S\n", V_BSTR(&v));

    VariantClear(&v);
    SysFreeString(PropName);

    // Enumerate through the 'real' properties, ignoring
    // standard WBEM system properties.
    // =================================================

    pObj->BeginEnumeration(WBEM_FLAG_NONSYSTEM_ONLY);

    BSTR bstrName = 0;
    LONG vt = 0;

    while (WBEM_NO_ERROR ==  pObj->Next(0, &bstrName, &v, &vt, 0))
    {
        printf("Property = %S\t", bstrName);

        PropNames[dwNumPropNames++] = bstrName; // Save the name for later use

        switch (vt)
        {
            case VT_I4:
                printf("\tType = VT_I4\tValue = %d\n", V_I4(&v));
                break;

            case VT_UI4:
                printf("\tType = VT_UI4\tValue = %u\n", V_I4(&v));
                break;

            case VT_BSTR:
                printf("\tType = VT_BSTR\tValue = %S\n", V_BSTR(&v));
                break;

            // Note that VARIANTs can't hold 64-bit integers,
            // so we have to use BSTRs for this.
            // ==============================================

            case VT_I8:
                printf("\tType = VT_I8\tValue = %S\n", V_BSTR(&v));
                break;

            case VT_UI8:
                printf("\tType = VT_UI8\tValue = %S\n", V_BSTR(&v));
                break;

            default:
                printf("\tType = complex\n");
        }

    }

    pObj->EndEnumeration();


    // Next, we can get the property values if we know the names
    // ahead of time through a more efficient access mechanism.
    // Since we saved all the property names, we can use these
    // to get handles to the properties of interest.  In this
    // case, we get handles for all the properties.  In real life,
    // you would just use this for properties of interest to
    // the end user.
    // ==========================================================

    IWbemObjectAccess *pAccess = 0;
    pObj->QueryInterface(IID_IWbemObjectAccess, (LPVOID *) &pAccess);

    LONG Handles[64] = {0};
    LONG Types[64] = {0};

    for (i = 0; i < dwNumPropNames; i++)
    {
        // Get handles for each of the properties.  We actually
        // only have to do this once and could reuse the handles
        // in the future between refreshes for all instances of
        // this class.
        // =====================================================

        pAccess->GetPropertyHandle(PropNames[i], &Types[i], &Handles[i]);
    }


    // We can now pull in the values by the handles.
    // Note that these handles can be 'saved' for use
    // with other instances or a newly refreshed generation
    // of the same instance.
    // =====================================================

    DWORD dwValue;
    unsigned __int64 qwValue;

    for (i = 0; i < dwNumPropNames; i++)
    {

        switch (Types[i])
        {
            case VT_I4:
            case VT_UI4:
                pAccess->ReadDWORD(Handles[i], &dwValue);
                printf("Property %S has value %u\n", PropNames[i], dwValue);
                break;

            case VT_I8:
            case VT_UI8:
                pAccess->ReadQWORD(Handles[i], &qwValue);
                printf("Property %S has value %lu\n", PropNames[i], qwValue);
                break;

            // Other types
            // ===========
            default:        
                printf("Property %S is Non integral type.\n", PropNames[i]);
                    // We could have used pAccess->ReadPropertyValue for this.
        }
    }


    // Done with the dump.  Cleanup time.
    // ==================================

    pAccess->Release(); // Done with this interface

    for (i = 0; i < dwNumPropNames; i++)    
        SysFreeString(PropNames[i]);        // Free prop names

    // Go home.
    // ========

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntperfshell\ntperf.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  NTPERF.H
//  
//  NT5 Perf Counter Provider
//
//  raymcc      02-Dec-97       
//
//***************************************************************************

#ifndef _NTPERF_H_
#define _NTPERF_H_

#define NUM_SAMPLE_INSTANCES   10

class CNt5PerfProvider;


class CNt5Refresher : public IWbemRefresher
{
    LONG m_lRef;

    IWbemObjectAccess *m_aInstances[NUM_SAMPLE_INSTANCES];

    LONG m_hName;
    LONG m_hCounter1;
    LONG m_hCounter2;
    LONG m_hCounter3;

public:
    CNt5Refresher();
   ~CNt5Refresher();

    void TransferPropHandles(CNt5PerfProvider *);

    BOOL AddObject(IWbemObjectAccess *pObj, LONG *plId);
    BOOL RemoveObject(LONG lId);

    // Interface members.
    // ==================

    ULONG STDMETHODCALLTYPE AddRef();
    ULONG STDMETHODCALLTYPE Release();
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);

    virtual HRESULT STDMETHODCALLTYPE Refresh(/* [in] */ long lFlags);
};


class CNt5PerfProvider : public IWbemHiPerfProvider, public IWbemProviderInit
{
    LONG m_lRef;
    IWbemClassObject  *m_pSampleClass;
    IWbemObjectAccess *m_aInstances[NUM_SAMPLE_INSTANCES];

    LONG m_hName;
    LONG m_hCounter1;
    LONG m_hCounter2;
    LONG m_hCounter3;

    friend class CNt5Refresher;
    
public:
    CNt5PerfProvider();
   ~CNt5PerfProvider();

    // Interface members.
    // ==================

        ULONG STDMETHODCALLTYPE AddRef();
        ULONG STDMETHODCALLTYPE Release();
        STDMETHODIMP QueryInterface(REFIID riid, void** ppv);


    // IWbemHiPerfProvider methods.
    // ============================
            
        virtual HRESULT STDMETHODCALLTYPE QueryInstances( 
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [string][in] */ WCHAR __RPC_FAR *wszClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateRefresher( 
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ long lFlags,
            /* [out] */ IWbemRefresher __RPC_FAR *__RPC_FAR *ppRefresher
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateRefreshableObject( 
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemObjectAccess __RPC_FAR *pTemplate,
            /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pContext,
            /* [out] */ IWbemObjectAccess __RPC_FAR *__RPC_FAR *ppRefreshable,
            /* [out] */ long __RPC_FAR *plId
            );
        
        virtual HRESULT STDMETHODCALLTYPE StopRefreshing( 
            /* [in] */ IWbemRefresher __RPC_FAR *pRefresher,
            /* [in] */ long lId,
            /* [in] */ long lFlags
            );

		virtual HRESULT STDMETHODCALLTYPE CreateRefreshableEnum(
			/* [in] */ IWbemServices* pNamespace,
			/* [in, string] */ LPCWSTR wszClass,
			/* [in] */ IWbemRefresher* pRefresher,
			/* [in] */ long lFlags,
			/* [in] */ IWbemContext* pContext,
			/* [in] */ IWbemHiPerfEnum* pHiPerfEnum,
			/* [out] */ long* plId
			);

		virtual HRESULT STDMETHODCALLTYPE GetObjects(
            /* [in] */ IWbemServices* pNamespace,
			/* [in] */ long lNumObjects,
			/* [in,size_is(lNumObjects)] */ IWbemObjectAccess** apObj,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext* pContext);
		
        // IWbemProviderInit method.
        // =========================
            
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [unique][in] */ LPWSTR wszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR wszNamespace,
            /* [unique][in] */ LPWSTR wszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
            );
  
};

void ObjectCreated();
void ObjectDestroyed();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntperfshell\server.cpp ===
//***************************************************************************
//
//  Copyright (c) 1996-2001, Microsoft Corporation, All rights reserved
//
//  SERVER.CPP
//
//  Generic COM server framework, adapted for the NT perf counter sample
//
//  This module contains nothing specific to the NT perf counter provider
//  except what is defined in the section bracketed by the CLSID SPECIFIC
//  comments below.
//
//  History:
//  raymcc        25-Nov-97     Created.
//  raymcc        18-Feb-98     Updated for NT5 Beta 2 version.
//
//***************************************************************************

#include "precomp.h"
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <initguid.h>


/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN CLSID SPECIFIC SECTION
//
//

#include <wbemidl.h>
#include <wbemint.h>
#include <ntperf.h>


// {C93F65F2-BA02-11d1-AEB6-00C04FB68820}
DEFINE_GUID(CLSID_Nt5PerProvider_v1,
0xc93f65f2, 0xba02, 0x11d1, 0xae, 0xb6, 0x0, 0xc0, 0x4f, 0xb6, 0x88, 0x20);


#define IMPLEMENTED_CLSID           CLSID_Nt5PerProvider_v1
#define SERVER_REGISTRY_COMMENT     L"WBEM NT5 Base Perf Provider"
#define CPP_CLASS_NAME              CNt5PerfProvider
#define INTERFACE_CAST              (IWbemHiPerfProvider *)

//
//  END CLSID SPECIFIC SECTION
//
/////////////////////////////////////////////////////////////////////////////




HINSTANCE g_hInstance;
static ULONG g_cLock = 0;

void ObjectCreated()    { g_cLock++; }
void ObjectDestroyed() { g_cLock--; }


//***************************************************************************
//
//  class CFactory
//
//  Generic implementation of IClassFactory for CWbemLocator.
//
//***************************************************************************

class CFactory : public IClassFactory
{
    ULONG           m_cRef;
    CLSID           m_ClsId;

public:
    CFactory(const CLSID & ClsId);
    ~CFactory();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IClassFactory members
    //
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP     LockServer(BOOL);
};




//***************************************************************************
//
//  DllMain
//
//  Dll entry point.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        setlocale(LC_ALL, "");      // Set to the 'current' locale
        g_hInstance = hinstDLL;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
    }

    return TRUE;
}



//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance.
//
//  PARAMETERS:
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    CFactory *pFactory;

    //
    //  Verify the caller is asking for our type of object.
    //
    if (IMPLEMENTED_CLSID != rclsid) 
            return ResultFromScode(E_FAIL);

    //
    // Check that we can provide the interface.
    //
    if (IID_IUnknown != riid && IID_IClassFactory != riid)
        return ResultFromScode(E_NOINTERFACE);

    //
    // Get a new class factory.
    //
    pFactory = new CFactory(rclsid);

    if (!pFactory)
        return ResultFromScode(E_OUTOFMEMORY);

    //
    // Verify we can get an instance.
    //
    HRESULT hRes = pFactory->QueryInterface(riid, ppv);

    if (FAILED(hRes))
        delete pFactory;

    return hRes;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllCanUnloadNow(void)
{
    SCODE sc = TRUE;

    if (g_cLock)
        sc = S_FALSE;

    return sc;
}

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllRegisterServer(void)
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];

    // Where are we?
    // =============
    GetModuleFileNameW(g_hInstance, Path, 1024);

    // Convert CLSID to string.
    // ========================

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Place it in registry.
    // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
    //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 : <no_name> : "path to DLL"
    //                                    : ThreadingModel : "both"
    // ==============================================================

    HKEY hKey;
    LONG lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    wchar_t *pName = SERVER_REGISTRY_COMMENT; 
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, wcslen(pName) * 2 + 2);

    HKEY hSubkey;
    lRes = RegCreateKey(hKey, "InprocServer32", &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, wcslen(Path) * 2 + 2);
    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Delete InProcServer32 subkey.
    // =============================
    LONG lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, L"InprocServer32");
    RegCloseKey(hKey);

    // Delete CLSID GUID key.
    // ======================

    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}




//***************************************************************************
//
//  CFactory::CFactory
//
//  Constructs the class factory given the CLSID of the objects it is supposed
//  to create.
//
//  PARAMETERS:
//
//      const CLSID & ClsId     The CLSID. 
//
//***************************************************************************
CFactory::CFactory(const CLSID & ClsId)
{
    m_cRef = 0;
    ObjectCreated();
    m_ClsId = ClsId;
}

//***************************************************************************
//
//  CFactory::~CFactory
//
//  Destructor.
//
//***************************************************************************
CFactory::~CFactory()
{
    ObjectDestroyed();
}

//***************************************************************************
//
//  CFactory::QueryInterface, AddRef and Release
//
//  Standard IUnknown methods.
//
//***************************************************************************
STDMETHODIMP CFactory::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
    {
        *ppv = this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


ULONG CFactory::AddRef()
{
    return ++m_cRef;
}


ULONG CFactory::Release()
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  CFactory::CreateInstance
//
//  PARAMETERS:
//
//      LPUNKNOWN pUnkOuter     IUnknown of the aggregator. Must be NULL.
//      REFIID riid             Interface ID required.
//      LPVOID * ppvObj         Destination for the interface pointer.
//
//  RETURN VALUES:
//
//      S_OK                        Success
//      CLASS_E_NOAGGREGATION       pUnkOuter must be NULL
//      E_NOINTERFACE               No such interface supported.
//      
//***************************************************************************

STDMETHODIMP CFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID * ppvObj)
{
    IUnknown* pObj;
    HRESULT  hr;

    //
    //  Defaults
    //
    *ppvObj=NULL;
    hr = ResultFromScode(E_OUTOFMEMORY);

    //
    // We aren't supporting aggregation.
    //
    if (pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    if (m_ClsId == IMPLEMENTED_CLSID)
    {
        pObj = INTERFACE_CAST new CPP_CLASS_NAME;
    }

    if (!pObj)
        return hr;

    //
    //  Initialize the object and verify that it can return the
    //  interface in question.
    //
    hr = pObj->QueryInterface(riid, ppvObj);

    //
    // Kill the object if initial creation or Init failed.
    //
    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//  CFactory::LockServer
//
//  Increments or decrements the lock count of the server. The DLL will not
//  unload while the lock count is positive.
//
//  PARAMETERS:
//
//      BOOL fLock      If TRUE, locks; otherwise, unlocks.
//
//  RETURN VALUES:
//
//      S_OK
//
//***************************************************************************
STDMETHODIMP CFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *) &g_cLock);
    else
        InterlockedDecrement((LONG *) &g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntsdext\wmiext.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef WMIEXT_H_
#define WMIEXT_H_ 

#ifdef WMIEXT_EXPORTS
#define WMIEXT_API __declspec(dllexport)
#else
#define WMIEXT_API __declspec(dllimport)
#endif

extern WINDBG_EXTENSION_APIS ExtensionApis;


extern "C" WMIEXT_API void wmiver(HANDLE,
							      HANDLE,
								  DWORD, 
								  PWINDBG_EXTENSION_APIS,
								  LPSTR);


extern "C" WMIEXT_API void mermaid(HANDLE,
								   HANDLE,
								   DWORD, 
								   PWINDBG_EXTENSION_APIS,
								   LPSTR);

extern "C" WMIEXT_API void mem(HANDLE,
							   HANDLE,
							   DWORD, 
							   PWINDBG_EXTENSION_APIS,
							   LPSTR);

#endif /*WMIEXT_H_*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntsdext\utils.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/

#include "precomp.h"
#include "utils.h"


DWORD WaitOnProcess(char *szExe, char *szParams, bool bHidden/*=true*/, bool bWait/*=true*/)
{
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    BOOL bRet;
    DWORD dwExitCode=STILL_ACTIVE;


    ZeroMemory(&si,sizeof(si));
    si.cb=sizeof(si);

    bRet=CreateProcess(szExe,szParams,NULL,NULL,NULL,
        ((bHidden)?DETACHED_PROCESS:CREATE_NEW_CONSOLE),NULL,NULL,&si,&pi);

    //wait until done
    //===============

    if (bRet && bWait)
    {
        while(dwExitCode==STILL_ACTIVE)
        {
            Sleep(100); //don't be a pig
            GetExitCodeProcess(pi.hProcess,&dwExitCode);
        }

        CloseHandle(pi.hThread);
        CloseHandle(pi.hProcess);
    }
    else
    {
        dwExitCode=(bRet)?0:1;
    }

    return dwExitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntsdext\utils.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#ifndef _UTILS_H_
#define _UTILS_H_

DWORD WaitOnProcess(char *szExe, char *szParams, bool bHidden=true, bool bWait=true); 

#endif /*_UTILS_H*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provshell\stdprov.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  PERFSAMP.CPP
//  
//  Sample NT5 Perf Counter Provider
//
//  raymcc      02-Dec-97   Created        
//  raymcc      20-Feb-98   Updated to use new initializer
//
//***************************************************************************

#include <windows.h>
#include <stdio.h>

#include <wbemidl.h>

#include <stdprov.h>

#include <oahelp.inl>


#define MAX_INSTANCES 40000

//***************************************************************************
//
//  CStdProvider constructor
//
//***************************************************************************
// ok

CStdProvider::CStdProvider()
{
    m_lRef = 0;
    m_pClassDef = 0;
}

//***************************************************************************
//
//  CStdProvider destructor
//
//***************************************************************************
// ok

CStdProvider::~CStdProvider()
{
    if (m_pClassDef)
        m_pClassDef->Release();
}


//***************************************************************************
//
//  CNt5Refresher::AddRef
//
//  Standard COM AddRef().
//
//***************************************************************************
// ok

ULONG CStdProvider::AddRef()
{
    return InterlockedIncrement(&m_lRef);
}

//***************************************************************************
//
//  CNt5Refresher::Release
//
//  Standard COM Release().
//
//***************************************************************************
// ok

ULONG CStdProvider::Release()
{
    long lRef = InterlockedDecrement(&m_lRef);
    if(lRef == 0)
        delete this;
    return lRef;
}

//***************************************************************************
//
//  CNt5Refresher::QueryInterface
//
//  Standard COM QueryInterface().  We have to support two interfaces,
//  the IWbemHiPerfProvider interface itself to provide the objects and
//  the IWbemProviderInit interface to initialize the provider.
//
//***************************************************************************
// ok

HRESULT CStdProvider::QueryInterface(REFIID riid, void** ppv)
{
    if(riid == IID_IUnknown || riid == IID_IWbemServices)
    {
        *ppv = (IWbemServices *) this;
        AddRef();
        return S_OK;
    }
    else if (riid == IID_IWbemProviderInit)
    {
        *ppv = (IWbemProviderInit *) this;
        AddRef();
        return S_OK;
    }
    else return E_NOINTERFACE;
}


//***************************************************************************
//
//  CNt5Refresher::Initialize
//
//  Called once during startup.  Insdicates to the provider which
//  namespace it is being invoked for and which User.  It also supplies
//  a back pointer to WINMGMT so that class definitions can be retrieved.
//
//  We perform any one-time initialization in this routine. The
//  final call to Release() is for any cleanup.
//
//  <wszUser>           The current user.
//  <lFlags>            Reserved.
//  <wszNamespace>      The namespace for which we are being activated.
//  <wszLocale>         The locale under which we are to be running.
//  <pNamespace>        An active pointer back into the current namespace
//                      from which we can retrieve schema objects.
//  <pCtx>              The user's context object.  We simply reuse this
//                      during any reentrant operations into WINMGMT.
//  <pInitSink>         The sink to which we indicate our readiness.
//
//***************************************************************************
// ok

HRESULT CStdProvider::Initialize( 
    /* [unique][in] */  LPWSTR wszUser,
    /* [in] */          LONG lFlags,
    /* [in] */          LPWSTR wszNamespace,
    /* [unique][in] */  LPWSTR wszLocale,
    /* [in] */          IWbemServices __RPC_FAR *pNamespace,
    /* [in] */          IWbemContext __RPC_FAR *pCtx,
    /* [in] */          IWbemProviderInitSink __RPC_FAR *pInitSink
    )
{
    // Get the class definition.
    // =========================
    
    HRESULT hRes = pNamespace->GetObject(BSTR(L"TestClass"), 
        0, pCtx, &m_pClassDef, 0
        );

    if (hRes)
        return hRes;

    pInitSink->SetStatus(0, WBEM_S_INITIALIZED);
    return NO_ERROR;
}
    

//*****************************************************************************
//
//*****************************************************************************        


HRESULT CStdProvider::OpenNamespace( 
            /* [in] */ BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult
            )
{
    return WBEM_E_NOT_SUPPORTED;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink
            )
{
    return WBEM_E_NOT_SUPPORTED;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler
            )
{
    return WBEM_E_NOT_SUPPORTED;
}

//*****************************************************************************
//
//*****************************************************************************        

HRESULT CStdProvider::GetObject( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return WBEM_E_NOT_SUPPORTED;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::GetObjectAsync( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{

    IWbemClassObject *pInst = 0;
    
    HRESULT hRes = m_pClassDef->SpawnInstance(0, &pInst);
    if (hRes)
        return hRes;

    // Copy the key value back.
    
    
    VARIANT v;
    VariantInit(&v);

    BSTR PropName = SysAllocString(L"KeyVal");
    pInst->Put(PropName, 0, &v, 0);
    SysFreeString(PropName);
    VariantClear(&v);

    // IntVal1.
    // ========
    
    V_VT(&v) = VT_I4;
    V_I4(&v) = 100;
    PropName = SysAllocString(L"IntVal1");
    pInst->Put(PropName, 0, &v, 0);
    SysFreeString(PropName);
    VariantClear(&v);
    
    // IntVal2.
    // ========
    
    V_VT(&v) = VT_I4;
    V_I4(&v) = 200;
    PropName = SysAllocString(L"IntVal2");
    pInst->Put(PropName, 0, &v, 0);
    SysFreeString(PropName);
    VariantClear(&v);

    // IntVal3.
    // ========
    
    V_VT(&v) = VT_I4;
    V_I4(&v) = 300;
    PropName = SysAllocString(L"IntVal3");
    pInst->Put(PropName, 0, &v, 0);
    SysFreeString(PropName);
    VariantClear(&v);
    
    // IntVal4.
    // ========
    
    V_VT(&v) = VT_I4;
    V_I4(&v) = 400;
    PropName = SysAllocString(L"IntVal4");
    pInst->Put(PropName, 0, &v, 0);
    SysFreeString(PropName);
    VariantClear(&v);


    // Fill in props
    //    string StrVal1;
    //    string StrVal2;
    //    string StrVal3;
    //    string StrVal4;
    //
    //    sint32 IntVal1;
    //    sint32 IntVal2;
    //    sint32 IntVal3;
    //    sint32 IntVal4;    
    //
    //    sint32 IntArray1[];
    //    sint32 IntArray2[];
    

    pResponseHandler->Indicate(1, &pInst);
    pResponseHandler->SetStatus(0, WBEM_NO_ERROR, 0, 0);

    return WBEM_NO_ERROR;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return WBEM_E_NOT_SUPPORTED;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_NOT_SUPPORTED;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::DeleteClass( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return WBEM_E_NOT_SUPPORTED;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::DeleteClassAsync( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_NOT_SUPPORTED;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::CreateClassEnum( 
            /* [in] */ BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            )
{
    return WBEM_E_NOT_SUPPORTED;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::CreateClassEnumAsync( 
            /* [in] */ BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_NOT_SUPPORTED;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return WBEM_E_NOT_SUPPORTED;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_NOT_SUPPORTED;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::DeleteInstance( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return WBEM_E_NOT_SUPPORTED;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::DeleteInstanceAsync( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_NOT_SUPPORTED;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::CreateInstanceEnum( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            )
{
    return WBEM_E_NOT_SUPPORTED;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::CreateInstanceEnumAsync( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    wchar_t buf[256];
    IWbemClassObject *BufArray[10];
    int nLoad = 0;
        
        IWbemClassObject *pInst = 0;
    
        HRESULT hRes = m_pClassDef->SpawnInstance(0, &pInst);
        if (hRes)
            return hRes;
    

    for (int i = 0; i < MAX_INSTANCES; i++)
    {
        VARIANT v;
        VariantInit(&v);

        swprintf(buf, L"Inst%d", i);
        V_VT(&v) = VT_BSTR;
        V_BSTR(&v) = SysAllocString(buf);

        BSTR PropName = SysAllocString(L"KeyVal");
        pInst->Put(PropName, 0, &v, 0);
        SysFreeString(PropName);
        VariantClear(&v);

        // IntVal1.
        // ========
    
        V_VT(&v) = VT_I4;
        V_I4(&v) = 100 + i;
        PropName = SysAllocString(L"IntVal1");
        pInst->Put(PropName, 0, &v, 0);
        SysFreeString(PropName);
        VariantClear(&v);
    
        // IntVal2.
        // ========
    
        V_VT(&v) = VT_I4;
        V_I4(&v) = 200 + i;
        PropName = SysAllocString(L"IntVal2");
        pInst->Put(PropName, 0, &v, 0);
        SysFreeString(PropName);
        VariantClear(&v);

        // IntVal3.
        // ========
    
        V_VT(&v) = VT_I4;
        V_I4(&v) = 300 + i;
        PropName = SysAllocString(L"IntVal3");
        pInst->Put(PropName, 0, &v, 0);
        SysFreeString(PropName);
        VariantClear(&v);
    
        // IntVal4.
        // ========
    
        V_VT(&v) = VT_I4;
        V_I4(&v) = 400 + i;
        PropName = SysAllocString(L"IntVal4");
        pInst->Put(PropName, 0, &v, 0);
        SysFreeString(PropName);
        VariantClear(&v);


        // StrVal1
        // =======

        V_VT(&v) = VT_BSTR;
        swprintf(buf, L"StrVal1=%d", i);
        V_BSTR(&v) = SysAllocString(buf);
        PropName = SysAllocString(L"StrVal1");
        pInst->Put(PropName, 0, &v, 0);
        SysFreeString(PropName);
        VariantClear(&v);

        // StrVal2
        // =======

        V_VT(&v) = VT_BSTR;
        swprintf(buf, L"StrVal2=%d !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!", i);
        V_BSTR(&v) = SysAllocString(buf);
        PropName = SysAllocString(L"StrVal2");
        pInst->Put(PropName, 0, &v, 0);
        SysFreeString(PropName);
        VariantClear(&v);

        // StrVal3
        // =======

        V_VT(&v) = VT_BSTR;
        swprintf(buf, L"StrVal3=%d", i);
        V_BSTR(&v) = SysAllocString(buf);
        PropName = SysAllocString(L"StrVal3");
        pInst->Put(PropName, 0, &v, 0);
        SysFreeString(PropName);
        VariantClear(&v);

        // StrVal4
        // =======

        V_VT(&v) = VT_BSTR;
        swprintf(buf, L"StrVal4=%d &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&", i);
        V_BSTR(&v) = SysAllocString(buf);
        PropName = SysAllocString(L"StrVal4");
        pInst->Put(PropName, 0, &v, 0);
        SysFreeString(PropName);
        VariantClear(&v);
    


        pResponseHandler->Indicate(1, &pInst);
//        pInst->Release();
    }

    pInst-Release();
    pResponseHandler->SetStatus(0, WBEM_NO_ERROR, 0, 0);
    
    return WBEM_NO_ERROR;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::ExecQuery( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            )
{
    return WBEM_E_NOT_SUPPORTED;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::ExecQueryAsync( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
//    pResponseHandler->Indicate(1, &pInst);
    pResponseHandler->SetStatus(0, WBEM_NO_ERROR, 0, 0);
    return WBEM_NO_ERROR;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::ExecNotificationQuery( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            )
{
    return WBEM_E_NOT_SUPPORTED;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::ExecNotificationQueryAsync( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_NOT_SUPPORTED;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::ExecMethod( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            )
{
    return WBEM_E_NOT_SUPPORTED;
}

//*****************************************************************************
//
//*****************************************************************************        
        
HRESULT CStdProvider::ExecMethodAsync( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            )
{
    return WBEM_E_NOT_SUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provshell\server.cpp ===
//***************************************************************************
//
//  Copyright (c) 1996-2001, Microsoft Corporation, All rights reserved
//
//  SERVER.CPP
//
//  Generic COM server framework, adapted for the NT perf counter sample
//
//  This module contains nothing specific to the NT perf counter provider
//  except what is defined in the section bracketed by the CLSID SPECIFIC
//  comments below.
//
//  History:
//  raymcc        25-Nov-97     Created.
//  raymcc        18-Feb-98     Updated for NT5 Beta 2 version.
//
//***************************************************************************

#include <windows.h>
#include <stdio.h>
#include <time.h>
#include <locale.h>
#include <initguid.h>


/////////////////////////////////////////////////////////////////////////////
//
//  BEGIN CLSID SPECIFIC SECTION
//
//

#include <wbemidl.h>

#include <stdprov.h>


// {A41602A4-C038-11d1-AEB6-00C04FB68820}
DEFINE_GUID(CLSID_RayMccProv,
0xa41602a4, 0xc038, 0x11d1, 0xae, 0xb6, 0x0, 0xc0, 0x4f, 0xb6, 0x88, 0x20);


#define IMPLEMENTED_CLSID           CLSID_RayMccProv
#define SERVER_REGISTRY_COMMENT     L"WBEM Test Provider"
#define CPP_CLASS_NAME              CStdProvider
#define INTERFACE_CAST              (IWbemProviderInit *)

//
//  END CLSID SPECIFIC SECTION
//
/////////////////////////////////////////////////////////////////////////////




HINSTANCE g_hInstance;
static ULONG g_cLock = 0;

void ObjectCreated()    { g_cLock++; }
void ObjectDestroyed() { g_cLock--; }


//***************************************************************************
//
//  class CFactory
//
//  Generic implementation of IClassFactory for CWbemLocator.
//
//***************************************************************************

class CFactory : public IClassFactory
{
    ULONG           m_cRef;
    CLSID           m_ClsId;

public:
    CFactory(const CLSID & ClsId);
    ~CFactory();

    //
    // IUnknown members
    //
    STDMETHODIMP         QueryInterface(REFIID, LPVOID *);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IClassFactory members
    //
    STDMETHODIMP     CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP     LockServer(BOOL);
};




//***************************************************************************
//
//  DllMain
//
//  Dll entry point.
//
//  PARAMETERS:
//
//      HINSTANCE hinstDLL      The handle to our DLL.
//      DWORD dwReason          DLL_PROCESS_ATTACH on load,
//                              DLL_PROCESS_DETACH on shutdown,
//                              DLL_THREAD_ATTACH/DLL_THREAD_DETACH otherwise.
//      LPVOID lpReserved       Reserved
//
//  RETURN VALUES:
//
//      TRUE is successful, FALSE if a fatal error occured.
//      NT behaves very ugly if FALSE is returned.
//
//***************************************************************************
BOOL WINAPI DllMain(
    HINSTANCE hinstDLL,
    DWORD dwReason,
    LPVOID lpReserved
    )
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        setlocale(LC_ALL, "");      // Set to the 'current' locale
        g_hInstance = hinstDLL;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
    }

    return TRUE;
}



//***************************************************************************
//
//  DllGetClassObject
//
//  Standard OLE In-Process Server entry point to return an class factory
//  instance.
//
//  PARAMETERS:
//
//  RETURNS:
//
//      S_OK                Success
//      E_NOINTERFACE       An interface other that IClassFactory was asked for
//      E_OUTOFMEMORY
//      E_FAILED            Initialization failed, or an unsupported clsid was
//                          asked for.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllGetClassObject(
    REFCLSID rclsid,
    REFIID riid,
    LPVOID * ppv
    )
{
    CFactory *pFactory;

    //
    //  Verify the caller is asking for our type of object.
    //
    if (IMPLEMENTED_CLSID != rclsid) 
            return ResultFromScode(E_FAIL);

    //
    // Check that we can provide the interface.
    //
    if (IID_IUnknown != riid && IID_IClassFactory != riid)
        return ResultFromScode(E_NOINTERFACE);

    //
    // Get a new class factory.
    //
    pFactory = new CFactory(rclsid);

    if (!pFactory)
        return ResultFromScode(E_OUTOFMEMORY);

    //
    // Verify we can get an instance.
    //
    HRESULT hRes = pFactory->QueryInterface(riid, ppv);

    if (FAILED(hRes))
        delete pFactory;

    return hRes;
}

//***************************************************************************
//
//  DllCanUnloadNow
//
//  Standard OLE entry point for server shutdown request. Allows shutdown
//  only if no outstanding objects or locks are present.
//
//  RETURN VALUES:
//
//      S_OK        May unload now.
//      S_FALSE     May not.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllCanUnloadNow(void)
{
    SCODE sc = TRUE;

    if (g_cLock)
        sc = S_FALSE;

    return sc;
}

//***************************************************************************
//
//  DllRegisterServer
//
//  Standard OLE entry point for registering the server.
//
//  RETURN VALUES:
//
//      S_OK        Registration was successful
//      E_FAIL      Registration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllRegisterServer(void)
{
    wchar_t Path[1024];
    wchar_t *pGuidStr = 0;
    wchar_t KeyPath[1024];

    // Where are we?
    // =============
    GetModuleFileNameW(g_hInstance, Path, 1024);

    // Convert CLSID to string.
    // ========================

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Place it in registry.
    // CLSID\\CLSID_Nt5PerProvider_v1 : <no_name> : "name"
    //      \\CLSID_Nt5PerProvider_v1\\InProcServer32 : <no_name> : "path to DLL"
    //                                    : ThreadingModel : "both"
    // ==============================================================

    HKEY hKey;
    LONG lRes = RegCreateKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    wchar_t *pName = SERVER_REGISTRY_COMMENT; 
    RegSetValueExW(hKey, 0, 0, REG_SZ, (const BYTE *) pName, wcslen(pName) * 2 + 2);

    HKEY hSubkey;
    lRes = RegCreateKey(hKey, "InprocServer32", &hSubkey);

    RegSetValueExW(hSubkey, 0, 0, REG_SZ, (const BYTE *) Path, wcslen(Path) * 2 + 2);
    RegSetValueExW(hSubkey, L"ThreadingModel", 0, REG_SZ, (const BYTE *) L"Both", wcslen(L"Both") * 2 + 2);

    RegCloseKey(hSubkey);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}

//***************************************************************************
//
//  DllUnregisterServer
//
//  Standard OLE entry point for unregistering the server.
//
//  RETURN VALUES:
//
//      S_OK        Unregistration was successful
//      E_FAIL      Unregistration failed.
//
//***************************************************************************

extern "C"
HRESULT APIENTRY DllUnregisterServer(void)
{
    wchar_t *pGuidStr = 0;
    HKEY hKey;
    wchar_t KeyPath[256];

    StringFromCLSID(IMPLEMENTED_CLSID, &pGuidStr);
    swprintf(KeyPath, L"Software\\Classes\\CLSID\\\\%s", pGuidStr);

    // Delete InProcServer32 subkey.
    // =============================
    LONG lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, KeyPath, &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, L"InprocServer32");
    RegCloseKey(hKey);

    // Delete CLSID GUID key.
    // ======================

    lRes = RegOpenKeyW(HKEY_LOCAL_MACHINE, L"Software\\Classes\\CLSID", &hKey);
    if (lRes)
        return E_FAIL;

    RegDeleteKeyW(hKey, pGuidStr);
    RegCloseKey(hKey);

    CoTaskMemFree(pGuidStr);

    return S_OK;
}




//***************************************************************************
//
//  CFactory::CFactory
//
//  Constructs the class factory given the CLSID of the objects it is supposed
//  to create.
//
//  PARAMETERS:
//
//      const CLSID & ClsId     The CLSID. 
//
//***************************************************************************
CFactory::CFactory(const CLSID & ClsId)
{
    m_cRef = 0;
    ObjectCreated();
    m_ClsId = ClsId;
}

//***************************************************************************
//
//  CFactory::~CFactory
//
//  Destructor.
//
//***************************************************************************
CFactory::~CFactory()
{
    ObjectDestroyed();
}

//***************************************************************************
//
//  CFactory::QueryInterface, AddRef and Release
//
//  Standard IUnknown methods.
//
//***************************************************************************
STDMETHODIMP CFactory::QueryInterface(REFIID riid, LPVOID * ppv)
{
    *ppv = 0;

    if (IID_IUnknown==riid || IID_IClassFactory==riid)
    {
        *ppv = this;
        AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


ULONG CFactory::AddRef()
{
    return ++m_cRef;
}


ULONG CFactory::Release()
{
    if (0 != --m_cRef)
        return m_cRef;
    delete this;
    return 0;
}

//***************************************************************************
//
//  CFactory::CreateInstance
//
//  PARAMETERS:
//
//      LPUNKNOWN pUnkOuter     IUnknown of the aggregator. Must be NULL.
//      REFIID riid             Interface ID required.
//      LPVOID * ppvObj         Destination for the interface pointer.
//
//  RETURN VALUES:
//
//      S_OK                        Success
//      CLASS_E_NOAGGREGATION       pUnkOuter must be NULL
//      E_NOINTERFACE               No such interface supported.
//      
//***************************************************************************

STDMETHODIMP CFactory::CreateInstance(
    LPUNKNOWN pUnkOuter,
    REFIID riid,
    LPVOID * ppvObj)
{
    IUnknown* pObj;
    HRESULT  hr;

    //
    //  Defaults
    //
    *ppvObj=NULL;
    hr = ResultFromScode(E_OUTOFMEMORY);

    //
    // We aren't supporting aggregation.
    //
    if (pUnkOuter)
        return ResultFromScode(CLASS_E_NOAGGREGATION);

    if (m_ClsId == IMPLEMENTED_CLSID)
    {
        pObj = INTERFACE_CAST new CPP_CLASS_NAME;
    }

    if (!pObj)
        return hr;

    //
    //  Initialize the object and verify that it can return the
    //  interface in question.
    //
    hr = pObj->QueryInterface(riid, ppvObj);

    //
    // Kill the object if initial creation or Init failed.
    //
    if (FAILED(hr))
        delete pObj;

    return hr;
}

//***************************************************************************
//
//  CFactory::LockServer
//
//  Increments or decrements the lock count of the server. The DLL will not
//  unload while the lock count is positive.
//
//  PARAMETERS:
//
//      BOOL fLock      If TRUE, locks; otherwise, unlocks.
//
//  RETURN VALUES:
//
//      S_OK
//
//***************************************************************************
STDMETHODIMP CFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *) &g_cLock);
    else
        InterlockedDecrement((LONG *) &g_cLock);

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\client\client.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <stdio.h>

// this redefines the DEFINE_GUID() macro to do allocation.
//
#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemint.h>

#include <Allocator.h>
#include <HelperFuncs.h>
#include "Globals.h"
#include "Task.h"
#include "CThread.h"
#include "Core.h"

#if 1
#define SAMPLE_NAMESPACE L"Root\\Cimv2"
#else
#define SAMPLE_NAMESPACE L"Root\\Default"
#endif

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT WmiSetSecurity ( IWbemServices *a_Service ) 
{
	IClientSecurity *t_Security = NULL ;
	HRESULT t_Result = a_Service->QueryInterface ( IID_IClientSecurity , ( void ** ) & t_Security ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_Security->SetBlanket ( 

			a_Service , 
			RPC_C_AUTHN_WINNT, 
			RPC_C_AUTHZ_NONE, 
			NULL,
			RPC_C_AUTHN_LEVEL_CONNECT , 
			RPC_C_IMP_LEVEL_IMPERSONATE, 
			NULL,
			EOAC_NONE
		) ;

		t_Security->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CreateContext ( IWbemServices *&a_Context )
{
	HRESULT t_Result = CoCreateInstance (
  
		CLSID_WbemContext ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IWbemContext ,
		( void ** )  & a_Context 
	) ;

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT WmiConnect ( LPWSTR a_Namespace , IWbemServices *&a_Service )
{
	IWbemLocator *t_Locator = NULL ;

	HRESULT t_Result = CoCreateInstance (
  
		CLSID_WbemLocator ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IUnknown ,
		( void ** )  & t_Locator
	);

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_Locator->ConnectServer (

			a_Namespace ,
			NULL ,
			NULL,
			NULL ,
			0 ,
			NULL,
			NULL,
			&a_Service
		) ;

		if ( SUCCEEDED ( t_Result ) )
		{
			t_Result = WmiSetSecurity ( a_Service ) ;
		}

		t_Locator->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT SetSecurity ( _IWmiProvSS *a_Service ) 
{
	IClientSecurity *t_Security = NULL ;
	HRESULT t_Result = a_Service->QueryInterface ( IID_IClientSecurity , ( void ** ) & t_Security ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_Security->SetBlanket ( 

			a_Service , 
			RPC_C_AUTHN_WINNT, 
			RPC_C_AUTHZ_NONE, 
			NULL,
			RPC_C_AUTHN_LEVEL_CONNECT , 
			RPC_C_IMP_LEVEL_IMPERSONATE, 
			NULL,
			EOAC_NONE
		) ;

		t_Security->Release () ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Connect ( LPWSTR a_Namespace , _IWmiProvSS *&a_Service )
{
#if 1
	HRESULT t_Result = CoCreateInstance (
  
		CLSID_WmiProvSS ,
		NULL ,
		// CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		//CLSCTX_LOCAL_SERVER ,
		CLSCTX_INPROC_SERVER ,
		IID__IWmiProvSS ,
		( void ** )  & a_Service
	);
#else

	COAUTHIDENTITY t_AuthenticationIdentity ;
	ZeroMemory ( & t_AuthenticationIdentity , sizeof ( t_AuthenticationIdentity ) ) ;

	t_AuthenticationIdentity.User = NULL ; 
	t_AuthenticationIdentity.UserLength = 0 ;
	t_AuthenticationIdentity.Domain = NULL ; 
	t_AuthenticationIdentity.DomainLength = 0 ; 
	t_AuthenticationIdentity.Password = NULL ; 
	t_AuthenticationIdentity.PasswordLength = 0 ; 
	t_AuthenticationIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE ; 

	COAUTHINFO t_AuthenticationInfo ;
	ZeroMemory ( & t_AuthenticationInfo , sizeof ( t_AuthenticationInfo ) ) ;

    t_AuthenticationInfo.dwAuthnSvc = RPC_C_AUTHN_DEFAULT ;
    t_AuthenticationInfo.dwAuthzSvc = RPC_C_AUTHZ_DEFAULT ;
    t_AuthenticationInfo.pwszServerPrincName = NULL ;
    t_AuthenticationInfo.dwAuthnLevel = RPC_C_AUTHN_LEVEL_CONNECT ;
    t_AuthenticationInfo.dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE  ;
    t_AuthenticationInfo.dwCapabilities = EOAC_NONE ;
    t_AuthenticationInfo.pAuthIdentityData = NULL ;

	COSERVERINFO t_ServerInfo ;
	ZeroMemory ( & t_ServerInfo , sizeof ( t_ServerInfo ) ) ;

	t_ServerInfo.pwszName;
    t_ServerInfo.dwReserved2 = 0 ;
    t_ServerInfo.pAuthInfo = & t_AuthenticationInfo ;

	IClassFactory *t_ClassFactory = NULL ;

	HRESULT t_Result = CoGetClassObject (

		CLSID_WmiProvSS ,
		/* CLSCTX_INPROC_SERVER , */
		/* CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER , */
		CLSCTX_LOCAL_SERVER , 
		& t_ServerInfo ,
		IID_IClassFactory ,
		( void ** )  & t_ClassFactory
	) ;
 
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = t_ClassFactory->CreateInstance (

			NULL ,
			IID__IWmiProvSS ,
			( void ** ) & a_Service 
		);	

		t_ClassFactory->Release () ;
	}

#endif

	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = SetSecurity ( a_Service ) ;

		t_Result = S_OK ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT InitializeSubSystem ( BSTR a_Namespace , _IWmiProvSS *& a_SubSystem )
{
	a_SubSystem = NULL ;

	HRESULT t_Result = Connect ( a_Namespace , a_SubSystem ) ;
	if ( SUCCEEDED ( t_Result ) )
	{
        CCoreServices *t_Core = new CCoreServices ;
		t_Result = t_Core->Initialize () ;

		if ( SUCCEEDED ( t_Result ) )
		{
			long t_Flags = 0 ;
			IWbemContext *t_Context = NULL ;

			t_Result = a_SubSystem->Initialize (

				t_Flags , 
				t_Context ,
				t_Core
			) ;

			t_Core->Release () ;

		}

		if ( SUCCEEDED ( t_Result ) )
		{
		}
		else
		{
			a_SubSystem->Release () ;
		}		
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	`
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT Process_MultiThread (

	_IWmiProvSS *a_SubSystem ,
	IWbemServices *a_WmiService
)
{
	HRESULT t_Result = S_OK ;

	WmiAllocator t_Allocator ;
	WmiStatusCode t_StatusCode = t_Allocator.Initialize () ;
	if ( t_StatusCode == e_StatusCode_Success )
	{
		WmiStatusCode t_StatusCode = WmiThread <ULONG> :: Static_Initialize ( t_Allocator ) ;

		WmiThread < ULONG > *t_Thread1 = new ClientThread ( t_Allocator ) ;
		if ( t_Thread1 )
		{
			t_Thread1->AddRef () ;

			t_StatusCode = t_Thread1->Initialize () ;

			WmiThread < ULONG > *t_Thread2 = new ClientThread ( t_Allocator ) ;
			if ( t_Thread2 )
			{
				t_Thread2->AddRef () ;

				t_StatusCode = t_Thread2->Initialize () ;

				Task_Execute t_Task1 ( t_Allocator , 10 , a_SubSystem , a_WmiService ) ;
				t_Task1.Initialize () ;
				t_Thread1->EnQueue ( 0 , t_Task1 ) ;

				t_Task1.WaitInterruptable () ;

#if 0
				Task_Execute t_Task2 ( t_Allocator , 10 , a_SubSystem , a_WmiService ) ;
				t_Task2.Initialize () ;
				t_Thread2->EnQueue ( 0 , t_Task2 ) ;


				t_Task2.WaitInterruptable () ;
#endif

				HANDLE t_Thread1Handle = NULL ;

				BOOL t_Status = DuplicateHandle ( 

					GetCurrentProcess () ,
					t_Thread1->GetHandle () ,
					GetCurrentProcess () ,
					& t_Thread1Handle, 
					0 , 
					FALSE , 
					DUPLICATE_SAME_ACCESS
				) ;

				t_Thread1->Release () ;

				WaitForSingleObject ( t_Thread1Handle , INFINITE ) ;

				CloseHandle ( t_Thread1Handle ) ;

#if 0
				HANDLE t_Thread2Handle = NULL ; 

				t_Status = DuplicateHandle ( 

					GetCurrentProcess () ,
					t_Thread2->GetHandle () ,
					GetCurrentProcess () ,
					& t_Thread2Handle, 
					0 , 
					FALSE , 
					DUPLICATE_SAME_ACCESS
				) ;

				t_Thread2->Release () ;
	
				WaitForSingleObject ( t_Thread2Handle , INFINITE ) ;

				CloseHandle ( t_Thread2Handle ) ;

#endif

			}
		}

		t_StatusCode = WmiThread <ULONG> :: Static_UnInitialize ( t_Allocator ) ;
	}	
	else
	{
		t_Result = WBEM_E_OUT_OF_MEMORY ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

void Process ()
{
	IWbemServices *t_WmiService = NULL ;
	_IWmiProviderFactory *t_Factory = NULL ;
	_IWmiProvSS *t_SubSystem = NULL ;
	IWbemServices *t_Provider = NULL ;

	HRESULT t_Result = CoInitializeEx(0, COINIT_MULTITHREADED) ;
	if ( SUCCEEDED ( t_Result ) )
	{
		t_Result = CoInitializeSecurity (

			NULL, 
			-1, 
			NULL, 
			NULL,
			RPC_C_AUTHN_LEVEL_NONE,
			RPC_C_IMP_LEVEL_IMPERSONATE,
			NULL, 
			EOAC_NONE, 
			0
		);

		if ( SUCCEEDED ( t_Result ) )
		{
			BSTR t_String = SysAllocString ( SAMPLE_NAMESPACE ) ;

			t_Result = WmiConnect ( t_String , t_WmiService ) ;

			SysFreeString ( t_String ) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				t_Result = InitializeSubSystem ( t_String , t_SubSystem ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					IWbemShutdown *t_SubSysShutdown = NULL ;

					t_Result = Process_MultiThread ( 

						t_SubSystem ,
						t_WmiService 
					) ;

					t_Result = t_SubSystem->QueryInterface ( IID_IWbemShutdown , ( void ** ) & t_SubSysShutdown ) ;

					if ( SUCCEEDED ( t_Result ) )
					{
						t_Result = t_SubSysShutdown->Shutdown (

							0 ,	
							0 ,
							NULL
						) ;

						t_SubSysShutdown->Release () ;
					}

					t_SubSystem->Release () ;
				}

				t_WmiService->Release () ;
			}
		}
		else
		{
			// fwprintf ( stderr , L"CoInitilizeSecurity: %lx\n" , t_Result ) ;
		}


		for ( ULONG t_Index = 0 ; t_Index < 10 ; t_Index ++ ) 
		{
			CoFreeUnusedLibraries () ;
			Sleep ( 500 ) ;
		}

		Sleep ( 1000 ) ;

		CoUninitialize () ;

	}
	else
	{
		// fwprintf ( stderr , L"CoInitilize: %lx\n" , t_Result ) ;
	}
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

EXTERN_C int __cdecl wmain (

	int argc ,
	char **argv 
)
{
	Process () ;
	
	return 0 ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\client\globals.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	Globals.cpp

Abstract:


History:

--*/

#include "PreComp.h"

#include <initguid.h>
#ifndef INITGUID
#define INITGUID
#endif

#include <wbemint.h>

#include <Exception.h>
#include <Thread.h>

#include <Allocator.cpp>
#include <HelperFuncs.cpp>

#include "Globals.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\ntsdext\wmiext.cpp ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


#include "precomp.h"
#include <stdlib.h> 
#include <string.h> 
#include <wdbgexts.h>   
#include <ntsdexts.h>
#include "wmiext.h"
#include "utils.h"

WINDBG_EXTENSION_APIS ExtensionApis;

BOOL APIENTRY DllMain( HANDLE hModule, 
                       DWORD  ul_reason_for_call, 
                       LPVOID lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
        case DLL_PROCESS_ATTACH:
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
        case DLL_PROCESS_DETACH:
            break;
    }
    return TRUE;
}

//========================
// output the wbem version
//========================


WMIEXT_API void wmiver(HANDLE hCurrentProcess,
                       HANDLE hCurrentThread,
                       DWORD dwCurrentPc, 
                       PWINDBG_EXTENSION_APIS lpExtensionApis,
                       LPSTR lpArgumentString)
{
    HKEY hCimomReg;
    char szWbemVersion[100];
    DWORD dwSize = 100;

    DWORD lResult=RegOpenKeyEx(HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\WBEM", 
                        NULL, KEY_READ, &hCimomReg);

    if (lResult==ERROR_SUCCESS) 
    {
        lResult=RegQueryValueEx(hCimomReg, "Build", NULL, NULL, 
                        (unsigned char *)szWbemVersion, &dwSize);

        RegCloseKey(hCimomReg);
    }


    if(lResult==ERROR_SUCCESS)
    {
        lpExtensionApis->lpOutputRoutine("\nWMI build %s is installed.\n\n",szWbemVersion);
    }
    else
    {
        lpExtensionApis->lpOutputRoutine("\nHKLM\\SOFTWARE\\Microsoft\\WBEM\\BUILD registry key not found!\n\n");
    }
}

//====================================
//Connect to mermaid\debug as smsadmin 
//====================================

WMIEXT_API void mermaid(HANDLE hCurrentProcess,
                       HANDLE hCurrentThread,
                       DWORD dwCurrentPc, 
                       PWINDBG_EXTENSION_APIS lpExtensionApis,
                       LPSTR lpArgumentString)
{
    lpExtensionApis->lpOutputRoutine("\nConnecting to mermaid\\debug for source... ");
    
    //construct paths first
    //=====================

    char szFirst[MAX_PATH+100],szSecond[MAX_PATH+100];

    GetSystemDirectory(szFirst,MAX_PATH);

    strcat(szFirst,"\\net.exe");
    strcpy(szSecond,szFirst);
    strcat(szSecond," use \\\\mermaid\\debug /u:wbem\\smsadmin Elvis1"); 

    //now net use to mermaid\debug
    //============================

    DWORD dwRes=WaitOnProcess(szFirst,szSecond,false);  

    if (0==dwRes)
    {
        lpExtensionApis->lpOutputRoutine("Succeeded!\n");       
    }
    else
    {
        lpExtensionApis->lpOutputRoutine("Failed!\n");
    }
}

//=======================
//Give memory information
//=======================

WMIEXT_API void mem(HANDLE hCurrentProcess,
                    HANDLE hCurrentThread,
                    DWORD dwCurrentPc, 
                    PWINDBG_EXTENSION_APIS lpExtensionApis,
                    LPSTR lpArgumentString)
{
    MEMORYSTATUS mem;
    memset(&mem, 0, sizeof(MEMORYSTATUS));
    mem.dwLength = sizeof(MEMORYSTATUS);

    GlobalMemoryStatus(&mem);

    lpExtensionApis->lpOutputRoutine("Total memory = %d mb / "
                                     "Available memory = %d mb\n",
                                     (mem.dwTotalPageFile+mem.dwTotalPhys)/(1 << 20),
                                     (mem.dwAvailPageFile+mem.dwAvailPhys)/(1 << 20));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provshell\stdprov.h ===
/*++

Copyright (C) 1997-2001 Microsoft Corporation

Module Name:

Abstract:

History:

--*/


//***************************************************************************
//
//  STDPROV.H
//  
//  Test instance provider
//
//  raymcc      02-Dec-97       
//
//***************************************************************************

#ifndef _STDPROV_H_
#define _STDPROV_H_

class CStdProvider : public IWbemServices, public IWbemProviderInit
{
    LONG m_lRef;
    IWbemClassObject *m_pClassDef;
        
public:
    CStdProvider();
   ~CStdProvider();

    // Interface members.
    // ==================

        ULONG STDMETHODCALLTYPE AddRef();
        ULONG STDMETHODCALLTYPE Release();
        STDMETHODIMP QueryInterface(REFIID riid, void** ppv);


        // IWbemProviderInit method.
        // =========================
            
        virtual HRESULT STDMETHODCALLTYPE Initialize( 
            /* [unique][in] */ LPWSTR wszUser,
            /* [in] */ LONG lFlags,
            /* [in] */ LPWSTR wszNamespace,
            /* [unique][in] */ LPWSTR wszLocale,
            /* [in] */ IWbemServices __RPC_FAR *pNamespace,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemProviderInitSink __RPC_FAR *pInitSink
            );



        // IWbemServices methods.
        // ======================

        virtual HRESULT STDMETHODCALLTYPE OpenNamespace( 
            /* [in] */ BSTR strNamespace,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemServices __RPC_FAR *__RPC_FAR *ppWorkingNamespace,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE CancelAsyncCall( 
            /* [in] */ IWbemObjectSink __RPC_FAR *pSink
            );
        
        virtual HRESULT STDMETHODCALLTYPE QueryObjectSink( 
            /* [in] */ long lFlags,
            /* [out] */ IWbemObjectSink __RPC_FAR *__RPC_FAR *ppResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE GetObject( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppObject,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectAsync( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE PutClass( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE PutClassAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pObject,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClass( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE DeleteClassAsync( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnum( 
            /* [in] */ BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateClassEnumAsync( 
            /* [in] */ BSTR strSuperclass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE PutInstance( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE PutInstanceAsync( 
            /* [in] */ IWbemClassObject __RPC_FAR *pInst,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstance( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE DeleteInstanceAsync( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnum( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            );
        
        virtual HRESULT STDMETHODCALLTYPE CreateInstanceEnumAsync( 
            /* [in] */ BSTR strClass,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            );
        
        virtual HRESULT STDMETHODCALLTYPE ExecQueryAsync( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQuery( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [out] */ IEnumWbemClassObject __RPC_FAR *__RPC_FAR *ppEnum
            );
        
        virtual HRESULT STDMETHODCALLTYPE ExecNotificationQueryAsync( 
            /* [in] */ BSTR strQueryLanguage,
            /* [in] */ BSTR strQuery,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethod( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [unique][in][out] */ IWbemClassObject __RPC_FAR *__RPC_FAR *ppOutParams,
            /* [unique][in][out] */ IWbemCallResult __RPC_FAR *__RPC_FAR *ppCallResult
            );
        
        virtual HRESULT STDMETHODCALLTYPE ExecMethodAsync( 
            /* [in] */ BSTR strObjectPath,
            /* [in] */ BSTR strMethodName,
            /* [in] */ long lFlags,
            /* [in] */ IWbemContext __RPC_FAR *pCtx,
            /* [in] */ IWbemClassObject __RPC_FAR *pInParams,
            /* [in] */ IWbemObjectSink __RPC_FAR *pResponseHandler
            );
            
};

void ObjectCreated();
void ObjectDestroyed();

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\wmi\wbem\winmgmt\provsubsys\client\core.cpp ===
/*++

Copyright (C) 1996-2001 Microsoft Corporation

Module Name:

	ProvFact.cpp

Abstract:


History:

--*/

#include "PreComp.h"
#include <wbemint.h>

#include "Globals.h"
#include "Core.h"

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CCoreServices :: CCoreServices () : m_Locator ( NULL ) , m_ReferenceCount ( 1 ) 
{
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

CCoreServices  :: ~CCoreServices  ()
{
	if ( m_Locator ) 
	{
		m_Locator->Release () ;
	}
}


/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

STDMETHODIMP CCoreServices :: QueryInterface (

	REFIID iid , 
	LPVOID FAR *iplpv 
) 
{
	*iplpv = NULL ;

	if ( iid == IID_IUnknown )
	{
		*iplpv = ( LPVOID ) this ;
	}
	else if ( iid == IID__IWmiCoreServices )
	{
		*iplpv = ( LPVOID ) ( _IWmiCoreServices * ) this ;		
	}	

	if ( *iplpv )
	{
		( ( LPUNKNOWN ) *iplpv )->AddRef () ;

		return ResultFromScode ( S_OK ) ;
	}
	else
	{
		return ResultFromScode ( E_NOINTERFACE ) ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


STDMETHODIMP_( ULONG ) CCoreServices :: AddRef ()
{
	return InterlockedIncrement ( & m_ReferenceCount ) ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


STDMETHODIMP_(ULONG) CCoreServices :: Release ()
{
	LONG t_Reference ;
	if ( ( t_Reference = InterlockedDecrement ( & m_ReferenceCount ) ) == 0 )
	{
		delete this ;
		return 0 ;
	}
	else
	{
		return t_Reference ;
	}
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/

HRESULT CCoreServices  :: Initialize ()
{
	HRESULT t_Result = CoCreateInstance (
  
		CLSID_WbemLocator ,
		NULL ,
		CLSCTX_INPROC_SERVER | CLSCTX_LOCAL_SERVER ,
		IID_IUnknown ,
		( void ** )  & m_Locator
	);

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT CCoreServices  :: GetObjFactory (

	long a_Flags,
	_IWmiObjectFactory **a_Factory
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT CCoreServices  :: GetServices (

	LPCWSTR a_Namespace,
	long a_Flags,
	REFIID a_Riid,
	void **a_Services
)
{
	HRESULT t_Result = S_OK ;

	if ( a_Riid == IID_IWbemServices )
	{
		BSTR t_Namespace = SysAllocString ( a_Namespace ) ;
		if ( t_Namespace ) 
		{
			t_Result = m_Locator->ConnectServer (

				( LPWSTR ) t_Namespace ,
				NULL ,
				NULL,
				NULL ,
				0 ,
				NULL,
				NULL,
				( IWbemServices ** ) a_Services
			) ;

			SysFreeString ( t_Namespace ) ;

			if ( SUCCEEDED ( t_Result ) )
			{
				IClientSecurity *t_Security = NULL ;
				t_Result = ( ( IWbemServices * ) * a_Services )->QueryInterface ( IID_IClientSecurity , ( void ** ) & t_Security ) ;
				if ( SUCCEEDED ( t_Result ) )
				{
					t_Result = t_Security->SetBlanket ( 

						( IUnknown * ) *a_Services , 
						RPC_C_AUTHN_WINNT, 
						RPC_C_AUTHZ_NONE, 
						NULL,
						RPC_C_AUTHN_LEVEL_CONNECT , 
						RPC_C_IMP_LEVEL_IMPERSONATE, 
						NULL,
						EOAC_NONE
					) ;

					t_Security->Release () ;
				}
			}
		}
		else
		{
			t_Result = WBEM_E_OUT_OF_MEMORY ;
		}
	}
	else
	{
		t_Result = E_NOINTERFACE ;
	}

	return t_Result ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT CCoreServices  :: GetRepositoryDriver (

	long a_Flags,
	REFIID a_Riid,
	void **a_Driver
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT CCoreServices  :: GetCallSec (

	long a_Flags,
	_IWmiCallSec **pCallSec
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT CCoreServices  :: GetProviderSubsystem (

	long a_Flags,
	_IWmiProvSS **a_ProvSS
)
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 *****************************************************************************/


HRESULT CCoreServices  :: GetLogonManager ()
{
	return WBEM_E_NOT_AVAILABLE ;
}

/******************************************************************************
 *
 *	Name:
 *
 *	
 *  Description:
 *
 *	
 **********************************************