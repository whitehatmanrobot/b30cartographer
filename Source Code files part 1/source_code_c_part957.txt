TY     	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0043)

#define DISPID_UL_UPLOADJOB_CREATIONTIME 	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0050)
#define DISPID_UL_UPLOADJOB_COMPLETETIME 	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0051)
#define DISPID_UL_UPLOADJOB_EXPIRATIONTIME 	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0052)
 
#define DISPID_UL_UPLOADJOB_ONSTATUSCHANGE  	 (DISPID_UL_BASE_UPLOADJOB + 0x0060)
#define DISPID_UL_UPLOADJOB_ONPROGRESSCHANGE	 (DISPID_UL_BASE_UPLOADJOB + 0x0061)

#define DISPID_UL_UPLOADJOB_ACTIVATESYNC 	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0080)
#define DISPID_UL_UPLOADJOB_ACTIVATEASYNC	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0081)
#define DISPID_UL_UPLOADJOB_SUSPEND      	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0082)
#define DISPID_UL_UPLOADJOB_DELETE       	 	 (DISPID_UL_BASE_UPLOADJOB + 0x0083)

#define DISPID_UL_UPLOADJOB_GETDATAFROMFILE  	 (DISPID_UL_BASE_UPLOADJOB + 0x0090)
#define DISPID_UL_UPLOADJOB_PUTDATAINTOFILE  	 (DISPID_UL_BASE_UPLOADJOB + 0x0091)
#define DISPID_UL_UPLOADJOB_GETDATAFROMSTREAM	 (DISPID_UL_BASE_UPLOADJOB + 0x0092)
#define DISPID_UL_UPLOADJOB_PUTDATAINTOSTREAM	 (DISPID_UL_BASE_UPLOADJOB + 0x0093)
#define DISPID_UL_UPLOADJOB_GETRESPONSEASSTREAM	 (DISPID_UL_BASE_UPLOADJOB + 0x0094)

/////////////////////////////////////////////////////////////////////////

#define DISPID_UL_UPLOADEVENTS_ONSTATUSCHANGE    (DISPID_UL_BASE_UPLOADEVENTS + 0x0000)
#define DISPID_UL_UPLOADEVENTS_ONPROGRESSCHANGE  (DISPID_UL_BASE_UPLOADEVENTS + 0x0001)

/////////////////////////////////////////////////////////////////////////

#define DISPID_UL_CONNECTION_AVAILABLE    		 (DISPID_UL_BASE_CONNECTION + 0x0000)
#define DISPID_UL_CONNECTION_ISAMODEM     		 (DISPID_UL_BASE_CONNECTION + 0x0001)
#define DISPID_UL_CONNECTION_BANDWIDTH    		 (DISPID_UL_BASE_CONNECTION + 0x0002)

/////////////////////////////////////////////////////////////////////////

#endif // !defined(__INCLUDED___UL___UPLOADLIBRARYDID_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\upload\server\isapi\config.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Config.cpp

Abstract:
    This file contains the implementation of the MPCConfig class,
    that extends the CISAPIconfig class.

Revision History:
    Davide Massarenti   (Dmassare)  05/02/99
        created

******************************************************************************/

#include "stdafx.h"


static MPC::wstring l_DefaultInstance   = L"DEFAULT";
static DWORD        l_MaximumPacketSize = 64*1024;


HRESULT Config_GetInstance( /*[in] */ const MPC::wstring& szURL         ,
                            /*[out]*/ CISAPIinstance*&    isapiInstance ,
                            /*[out]*/ bool&               fFound        )
{
    __ULT_FUNC_ENTRY("Config_GetInstance");

    HRESULT            hr;
    CISAPIconfig::Iter it;

    isapiInstance = NULL;

    __MPC_EXIT_IF_METHOD_FAILS(hr, g_Config.GetInstance( it, fFound, szURL ));

    if(fFound == false)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, g_Config.GetInstance( it, fFound, l_DefaultInstance ));
    }

    if(fFound)
    {
        isapiInstance = &(*it);
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT Config_GetProvider( /*[in] */ const MPC::wstring& szURL         ,
                            /*[in] */ const MPC::wstring& szName        ,
                            /*[out]*/ CISAPIprovider*&    isapiProvider ,
                            /*[out]*/ bool&               fFound        )
{
    __ULT_FUNC_ENTRY("Config_GetProvider");

    HRESULT                  hr;
    CISAPIinstance*          isapiInstance;
    CISAPIinstance::ProvIter it;

    isapiProvider = NULL;

    //
    // First of all, check if the provider is supplied directly by the instance.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::Config_GetInstance( szURL, isapiInstance, fFound ));
    if(fFound == false)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, isapiInstance->GetProvider( it, fFound, szName ));
    if(fFound == false)
    {
        //
        // No, the provider is not provided directly by this instance, try using the DEFAULT one.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, ::Config_GetInstance( l_DefaultInstance, isapiInstance, fFound ));
        if(fFound == false)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, isapiInstance->GetProvider( it, fFound, szName ));
    }

    if(fFound)
    {
        isapiProvider = &((*it).second);
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT Config_GetMaximumPacketSize( /*[in] */ const MPC::wstring& szURL               ,
                                     /*[out]*/ DWORD&              dwMaximumPacketSize )
{
    __ULT_FUNC_ENTRY("Config_GetMaximumPacketSize");

    HRESULT         hr;
    CISAPIinstance* isapiInstance;
    bool            fFound;


    dwMaximumPacketSize = l_MaximumPacketSize;

    __MPC_EXIT_IF_METHOD_FAILS(hr, ::Config_GetInstance( szURL, isapiInstance, fFound ));
    if(fFound)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, isapiInstance->get_MaximumPacketSize( dwMaximumPacketSize ));
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT Util_CheckDiskSpace( /*[in] */ const MPC::wstring& szFile     ,
							 /*[in] */ DWORD               dwLowLevel ,
							 /*[out]*/ bool&               fEnough    )
{
    __ULT_FUNC_ENTRY("Util_CheckDiskSpace");

	HRESULT        hr;
	ULARGE_INTEGER liFree;
	ULARGE_INTEGER liTotal;


	fEnough = false;


	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::GetDiskSpace( szFile, liFree, liTotal ));

	if(liFree.HighPart > 0          ||
	   liFree.LowPart  > dwLowLevel  )
	{
		fEnough = true;
	}

	hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\upload\server\isapi\client.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Client.h

Abstract:
    This file contains the declaration of the MPCClient class,
    that describes a client's state.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULSERVER___CLIENT_H___)
#define __INCLUDED___ULSERVER___CLIENT_H___


#include <Wrapper.h>


#define CLIENT_DB_VERSION 0xDB000003

#define CLIENT_CONST__DB_EXTENSION  L".db"


class MPCClient : public MPCPersist
{
public:
    typedef UploadLibrary::Signature Sig;
    typedef std::list<MPCSession>    List;
    typedef List::iterator           Iter;
    typedef List::const_iterator     IterConst;

private:
    MPCServer*         m_mpcsServer;
    MPC::wstring       m_szFile; // For direct access.
   
    Sig                m_sigID;
    List               m_lstActiveSessions;
    SYSTEMTIME         m_stLastUsed;
    DWORD              m_dwLastSession;
   
    mutable bool       m_fDirty;
    mutable HANDLE     m_hfFile;

	static const DWORD c_dwVersion = CLIENT_DB_VERSION;

    //////////////////////////////////////////////////////////////////

    HRESULT IDtoPath( /*[out]*/ MPC::wstring& szStr ) const;

    //////////////////////////////////////////////////////////////////

public:
    MPCClient( /*[in]*/ MPCServer* mpcsServer, /*[in]*/ const Sig&          sigID  );
    MPCClient( /*[in]*/ MPCServer* mpcsServer, /*[in]*/ const MPC::wstring& szFile );
    virtual ~MPCClient();

	MPCServer* GetServer();

    /////////////////////////////////////////////

    virtual bool    IsDirty() const;

    virtual HRESULT Load( /*[in]*/ MPC::Serializer& streamIn  );
    virtual HRESULT Save( /*[in]*/ MPC::Serializer& streamOut ) const;

    /////////////////////////////////////////////

    bool operator==( /*[in]*/ const UploadLibrary::Signature& rhs );

    bool Find ( /*[in]*/ const MPC::wstring& szJobID, /*[out]*/ Iter& it );
    void Erase(                                       /*[in] */ Iter& it );

    /////////////////////////////////////////////

    HRESULT GetInstance( /*[out]*/ CISAPIinstance*& isapiInstance, /*[out]*/ bool& fFound ) const;
    HRESULT GetInstance( /*[out]*/ MPC::wstring&    szURL                                 ) const;

    /////////////////////////////////////////////

    HRESULT BuildClientPath( /*[out]*/ MPC::wstring& szPath ) const;
    HRESULT GetFileName    ( /*[out]*/ MPC::wstring& szFile ) const;
    HRESULT GetFileSize    ( /*[out]*/ DWORD&        dwSize ) const;
    HRESULT FormatID       ( /*[out]*/ MPC::wstring& szID   ) const;

    bool CheckSignature() const;

    /////////////////////////////////////////////

    HRESULT OpenStorage ( /*[in]*/ bool fCheckFreeSpace );
    HRESULT InitFromDisk( /*[in]*/ bool fCheckFreeSpace );
    HRESULT SaveToDisk  (                               );
    HRESULT SyncToDisk  (                               );

    HRESULT GetSessions( /*[out]*/ Iter& itBegin, /*[out]*/ Iter& itEnd );

    /////////////////////////////////////////////

    Iter NewSession( /*[in]*/ UploadLibrary::ClientRequest_OpenSession& crosReq );

    HRESULT AppendData( /*[in]*/ MPCSession& mpcsSession, /*[in]*/ MPC::Serializer& streamConn, /*[in]*/ DWORD dwSize );

    HRESULT CheckQuotas( /*[in]*/ MPCSession& mpcsSession, /*[out]*/ bool& fServerBusy, /*[out]*/ bool& fAccessDenied, /*[out]*/ bool& fExceeded );
};

#endif // !defined(__INCLUDED___ULSERVER___CLIENT_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\upload\server\isapi\httpcontext.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    HttpContext.h

Abstract:
    This file contains the declaration of the MPCHttpContext class,
    which handles the interface with IIS.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULSERVER___HTTPCONTEXT_H___)
#define __INCLUDED___ULSERVER___HTTPCONTEXT_H___

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

//
// Forward declarations.
//
class MPCServer;
class MPCHttpPipe;


class MPCHttpContext
{
    enum FSMstate
    {
        FSM_REGISTER,
        FSM_INPUT   ,
        FSM_PROCESS ,
        FSM_OUTPUT  ,
        FSM_DELETE
    };

    enum IOstate
    {
        IO_IDLE   ,
        IO_READING,
        IO_WRITING
    };


    LPEXTENSION_CONTROL_BLOCK m_pECB;

    MPCServer*                m_mpcsServer;
	DWORD                     m_dwSkippedInput;
    BOOL                      m_fRequestProcessed;
    BOOL                      m_fKeepConnection;

    BOOL                      m_fAsync;
    FSMstate                  m_FSMstate;
    IOstate                   m_IOstate;


    MPC::Serializer_Memory    m_hsInput;
    MPC::Serializer_Memory    m_hsOutput;

    BYTE                      m_rgBuffer[4096];
    DWORD                     m_dwIOcount;

    //////////////////////////////////////////////////////////////////

protected:
    DWORD AsyncRead();
    DWORD AsyncWrite();

    DWORD AdvanceFSM();

    DWORD Fsm_Register();
    DWORD Fsm_ReceiveInput();
    DWORD Fsm_Process();
    DWORD Fsm_SendOutput();

    static VOID WINAPI IOCompletion( /*[in]*/ EXTENSION_CONTROL_BLOCK* pECB     ,
                                     /*[in]*/ PVOID                    pContext ,
                                     /*[in]*/ DWORD                    cbIO     ,
                                     /*[in]*/ DWORD                    dwError  );

    //////////////////////////////////////////////////////////////////

public:
    MPCHttpContext();
    virtual ~MPCHttpContext();

    DWORD Init( /*[in]*/ LPEXTENSION_CONTROL_BLOCK pECB );

    HRESULT GetServerVariable ( /*[in]*/ LPCSTR      szVar  , /*[out]*/ MPC::wstring& szValue                             );
    HRESULT GetRequestSize    (                               /*[out]*/ DWORD& 		  dwCount                             );
    HRESULT CheckDataAvailable(                               /*[in] */ DWORD  		  dwCount, /*[out]*/ bool& fAvailable );
    HRESULT Read              ( /*[in]*/       void* pBuffer, /*[in] */ DWORD  		  dwCount                             );
    HRESULT Write             ( /*[in]*/ const void* pBuffer, /*[in] */ DWORD  		  dwCount                             );

    //////////////////////////////////////////////////////////////////

#ifdef DEBUG
    bool                      m_Debug_NO_RESPONSE_TO_OPEN;

    bool                      m_Debug_NO_RESPONSE_TO_WRITE;

    bool                      m_Debug_RESPONSE_TO_OPEN;
    DWORD                     m_Debug_RESPONSE_TO_OPEN_response;
    DWORD                     m_Debug_RESPONSE_TO_OPEN_position;
    DWORD                     m_Debug_RESPONSE_TO_OPEN_protocol;

    bool                      m_Debug_RESPONSE_TO_WRITE;
    DWORD                     m_Debug_RESPONSE_TO_WRITE_response;
    DWORD                     m_Debug_RESPONSE_TO_WRITE_position;
    DWORD                     m_Debug_RESPONSE_TO_WRITE_protocol;

    bool                      m_Debug_RANDOM_POINTER_ERROR;
    DWORD                     m_Debug_RANDOM_POINTER_ERROR_pos_low;
    DWORD                     m_Debug_RANDOM_POINTER_ERROR_pos_high;

    bool                      m_Debug_FIXED_POINTER_ERROR;
    DWORD                     m_Debug_FIXED_POINTER_ERROR_pos;
#endif

    //////////////////////////////////////////////////////////////////
};

#endif // !defined(__INCLUDED___ULSERVER___HTTPCONTEXT_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\upload\server\isapi\config.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Config.h

Abstract:
    This file contains the declaration of the MPCConfig class,
    that extends the CISAPIconfig class.

Revision History:
    Davide Massarenti   (Dmassare)  05/02/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULSERVER___CONFIG_H___)
#define __INCLUDED___ULSERVER___CONFIG_H___

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


HRESULT Config_GetInstance         ( /*[in]*/ const MPC::wstring& szURL,                                      /*[out]*/ CISAPIinstance*& isapiInstance      , /*[out]*/ bool& fFound );
HRESULT Config_GetProvider         ( /*[in]*/ const MPC::wstring& szURL, /*[in]*/ const MPC::wstring& szName, /*[out]*/ CISAPIprovider*& isapiProvider      , /*[out]*/ bool& fFound );
HRESULT Config_GetMaximumPacketSize( /*[in]*/ const MPC::wstring& szURL,                                      /*[out]*/ DWORD&           dwMaximumPacketSize                         );

HRESULT Util_CheckDiskSpace( /*[in]*/ const MPC::wstring& szFile, /*[in]*/ DWORD dwLowLevel, /*[out]*/ bool& fEnough );


#endif // !defined(__INCLUDED___ULSERVER___CONFIG_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\upload\server\isapi\client.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Client.cpp

Abstract:
    This file contains the implementation of the MPCClient class,
    that describes a client's state.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#include "stdafx.h"

#define BUFFER_SIZE_FILECOPY (512)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Construction/Destruction
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::MPCClient
//
// Parameters  : MPCServer* mpcsServer: callback for getting information about the current request.
//               const Sig& sigID     : a reference to the ID for this client.
//
// Synopsis    : Initializes the MPCClient object with the ID of a client.
//
/////////////////////////////////////////////////////////////////////////////
MPCClient::MPCClient( /*[in]*/ MPCServer* mpcsServer ,
                      /*[in]*/ const Sig& sigID      )
{
    __ULT_FUNC_ENTRY("MPCClient::MPCClient");

    m_mpcsServer    = mpcsServer;  // MPCServer*     m_mpcsServer;
                                   // MPC::wstring   m_szFile;
                                   //
    m_sigID         = sigID;       // Sig            m_sigID;
                                   // List           m_lstActiveSessions;
                                   // SYSTEMTIME     m_stLastUsed;
    m_dwLastSession = 0;           // DWORD          m_dwLastSession;
                                   //
    m_fDirty        = false;       // mutable bool   m_fDirty;
    m_hfFile        = NULL;        // mutable HANDLE m_hfFile;
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::MPCClient
//
// Parameters  : MPCServer*          mpcsServer : callback for getting information about the current request.
//               const MPC::wstring& szFile     : the file holding the DB.
//
// Synopsis    : Initializes the MPCClient object suppling the filename of the DB of a client.
//
/////////////////////////////////////////////////////////////////////////////
MPCClient::MPCClient( /*[in]*/ MPCServer*          mpcsServer ,
                      /*[in]*/ const MPC::wstring& szFile     )
{
    __ULT_FUNC_ENTRY("MPCClient::MPCClient");

    MPC::wstring::size_type iPos;

    m_mpcsServer    = mpcsServer;  // MPCServer*     m_mpcsServer;
    m_szFile        = szFile;      // MPC::wstring   m_szFile;
                                   //
                                   // Sig            m_sigID;
                                   // List           m_lstActiveSessions;
                                   // SYSTEMTIME     m_stLastUsed;
    m_dwLastSession = 0;           // DWORD          m_dwLastSession;
                                   //
    m_fDirty        = false;       // mutable bool   m_fDirty;
    m_hfFile        = NULL;        // mutable HANDLE m_hfFile;


    if((iPos = szFile.find( CLIENT_CONST__DB_EXTENSION, 0 )) != MPC::wstring::npos)
    {
        m_szFile = MPC::wstring( &szFile[0], &szFile[iPos] );
    }
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::~MPCClient
//
// Synopsis    : Before destructing the object, ensures its state is updated
//               to disk.
//
/////////////////////////////////////////////////////////////////////////////
MPCClient::~MPCClient()
{
    __ULT_FUNC_ENTRY("MPCClient::~MPCClient");

    if(m_hfFile)
    {
        (void)SyncToDisk();

        ::CloseHandle( m_hfFile ); m_hfFile = NULL;
    }
}

MPCServer* MPCClient::GetServer() { return m_mpcsServer; }

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Persistence
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::IsDirty
//
// Return      : bool : 'true' is the object is out-of-sync with the disk.
//
// Synopsis    : Checks if the object needs to be written to disk.
//
/////////////////////////////////////////////////////////////////////////////
bool MPCClient::IsDirty() const
{
    __ULT_FUNC_ENTRY("MPCClient::IsDirty");

    bool fRes = true; // Default result.


    if(m_fDirty)
    {
        __ULT_FUNC_LEAVE;
    }
    else
    {
        //
        // Recursively check the 'Dirty' state of each session.
        //
        for(IterConst it = m_lstActiveSessions.begin(); it != m_lstActiveSessions.end(); it++)
        {
            if(it->IsDirty()) __ULT_FUNC_LEAVE;
        }
    }

    fRes = false;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(fRes);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::Load
//
// Parameters  : MPC::Serializer& in : the stream used to initialize the object.
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : Loads the state of this object from the stream.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::Load( /*[in]*/ MPC::Serializer& streamIn )
{
    __ULT_FUNC_ENTRY("MPCClient::Load");

    HRESULT    hr;
    DWORD      dwVer;
    Sig        sigID;
    MPCSession mpcsSession(this);


    //
    // Clean up the previous state of the object.
    //
    m_lstActiveSessions.clear();


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> dwVer);

    if(dwVer != c_dwVersion)
    {
        m_fDirty = true; // Force rewrite...

        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> sigID          );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_stLastUsed   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dwLastSession);

    if(m_szFile.length())
    {
        //
        // In case of direct access (m_szFile != ""), initialize the sigID from disk.
        //
        m_sigID = sigID;
    }
    else if(m_sigID == sigID)
    {
        //
        // IDs match...
        //
    }
    else
    {
        //
        // IDs don't match, fail.
        //
        __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
    }


    //
    // While it's successful to read MPCSession objects from the stream,
    // keep adding them to the list of active sessions.
    //
    while(SUCCEEDED(mpcsSession.Load( streamIn )))
    {
        m_lstActiveSessions.push_back( mpcsSession );
    }

    m_fDirty = false;
    hr       = S_OK;


    __ULT_FUNC_CLEANUP;


    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::Save
//
// Parameters  : MPC::Serializer& out : the stream used to persist the state of the object.
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : Saves the state of this object to the stream.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::Save( /*[in]*/ MPC::Serializer& streamOut ) const
{
    __ULT_FUNC_ENTRY("MPCClient::Save");

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << c_dwVersion    );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_sigID        );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_stLastUsed   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dwLastSession);

    //
    // Recursively save each session.
    //
    {
        for(IterConst it = m_lstActiveSessions.begin(); it != m_lstActiveSessions.end(); it++)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, it->Save( streamOut ));
        }
    }

    m_fDirty = false;
    hr       = S_OK;


    __ULT_FUNC_CLEANUP;


    __ULT_FUNC_EXIT(hr);
}


//////////////////////////////////////////////////////////////////////
// Operators
//////////////////////////////////////////////////////////////////////

bool MPCClient::operator==( /*[in]*/ const UploadLibrary::Signature& rhs )
{
    __ULT_FUNC_ENTRY("MPCClient::operator==");


    bool fRes = (m_sigID == rhs);


    __ULT_FUNC_EXIT(fRes);
}

bool MPCClient::Find( /*[in] */ const MPC::wstring& szJobID ,
                      /*[out]*/ Iter&               it      )
{
    __ULT_FUNC_ENTRY("MPCClient::Find");

    bool fRes;


    it = std::find( m_lstActiveSessions.begin(), m_lstActiveSessions.end(), szJobID );

    fRes = (it != m_lstActiveSessions.end());


    __ULT_FUNC_EXIT(fRes);
}

void MPCClient::Erase( /*[in]*/ Iter& it )
{
    __ULT_FUNC_ENTRY("MPCClient::Erase");


    m_lstActiveSessions.erase( it );
    m_fDirty = true;
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Methods
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::GetInstance
//
// Parameters  : CISAPIistance*& isapiInstance : instance of this request.
//               bool&           fFound        : true if instance exists.
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : Locates the configuration settings for the server
//               associated with this client.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::GetInstance( /*[out]*/ CISAPIinstance*& isapiInstance ,
                                /*[out]*/ bool&            fFound        ) const
{
    __ULT_FUNC_ENTRY("MPCClient::GetInstance");

    HRESULT hr;

    isapiInstance = m_mpcsServer->getInstance();
    fFound        = (isapiInstance != NULL);

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::GetInstance
//
// Parameters  : MPC::wstring& szURL : variable where to store the server name.
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : Returns the URL associated with this client.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::GetInstance( /*[out]*/ MPC::wstring& szURL ) const
{
    __ULT_FUNC_ENTRY("MPCClient::GetInstance");

    HRESULT hr;


    m_mpcsServer->getURL( szURL );
    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::IDtoPath
//
// Parameters  : MPC::wstring& szStr : output buffer for the path.
//
// Synopsis    : Hashing algorithm, to transform from the client ID to the
//               temporary queue location.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::IDtoPath( /*[out]*/ MPC::wstring& szStr ) const
{
    __ULT_FUNC_ENTRY("MPCClient::IDtoPath");

    HRESULT hr;
    WCHAR   rgBuf1[4*2+1];
    WCHAR   rgBuf2[2*2+1];
    WCHAR   rgBuf3[2*2+1];
    WCHAR   rgBuf4[8*2+1];


    swprintf( rgBuf1, L"%08lx",      m_sigID.guidMachineID.Data1 );
    swprintf( rgBuf2, L"%04x" , (int)m_sigID.guidMachineID.Data2 );
    swprintf( rgBuf3, L"%04x" , (int)m_sigID.guidMachineID.Data3 );

    for(int i=0; i<8; i++)
    {
        swprintf( &rgBuf4[i*2], L"%02x", (int)m_sigID.guidMachineID.Data4[i] );
    }

    //
    // Debug Format: XXYYYZZZ-AAAA-BBBB-CCCCCCCC
    //
    szStr.append( L"\\"  );
    szStr.append( rgBuf1 );
    szStr.append( L"-"   );
    szStr.append( rgBuf2 );
    szStr.append( L"-"   );
    szStr.append( rgBuf3 );
    szStr.append( L"-"   );
    szStr.append( rgBuf4 );

    //
    // Format: XX\YYY\ZZZ\AAAA-BBBB-CCCCCCCC
    //
/*
    szStr.append( &rgBuf1[0], &rgBuf1[2] );
    szStr.append( L"\\"                  );
    szStr.append( &rgBuf1[2], &rgBuf1[5] );
    szStr.append( L"\\"                  );
    szStr.append( &rgBuf1[5], &rgBuf1[8] );
    szStr.append( L"\\"                  );
    szStr.append(  rgBuf2                );
    szStr.append( L"-"                   );
    szStr.append(  rgBuf3                );
    szStr.append( L"-"                   );
    szStr.append(  rgBuf4                );
*/
    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::BuildClientPath
//
// Parameters  : MPC::wstring& szPath : output buffer for the path.
//
// Synopsis    : Returns in 'szPath' the location of this client's data.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::BuildClientPath( /*[out]*/ MPC::wstring& szPath ) const
{
    __ULT_FUNC_ENTRY("MPCClient::BuildClientPath");

    HRESULT hr;


    if(m_szFile.length())
    {
        szPath = m_szFile;
    }
    else
    {
        CISAPIinstance* isapiInstance;
        bool            fFound;

        __MPC_EXIT_IF_METHOD_FAILS(hr, GetInstance( isapiInstance, fFound ));
        if(fFound == false)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
        }
        else
        {
            CISAPIinstance::PathIter itBegin;
            CISAPIinstance::PathIter itEnd;

            __MPC_EXIT_IF_METHOD_FAILS(hr, isapiInstance->GetLocations( itBegin, itEnd ));

            if(itBegin == itEnd)
            {
                __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
            }

            szPath = *itBegin; IDtoPath( szPath );
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::GetFileName
//
// Parameters  : MPC::wstring& szFile : output buffer for the path.
//
// Synopsis    : Returns the filename of the directory file.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::GetFileName( /*[out]*/ MPC::wstring& szFile ) const
{
    __ULT_FUNC_ENTRY("MPCClient::GetFileName");

    //
    // The filename for the Directory File is "<ID>.db"
    //
    BuildClientPath( szFile );

    szFile.append( CLIENT_CONST__DB_EXTENSION );


    __ULT_FUNC_EXIT(S_OK);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::GetFileSize
//
// Parameters  : DWORD& dwSize : size of the Directory File.
//
// Synopsis    : Returns the size of the directory file, if opened.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::GetFileSize( /*[out]*/ DWORD& dwSize ) const
{
    __ULT_FUNC_ENTRY("MPCClient::GetFileSize");

    HRESULT hr;


    if(m_hfFile)
    {
        BY_HANDLE_FILE_INFORMATION info;

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::GetFileInformationByHandle( m_hfFile, &info ));

        dwSize = info.nFileSizeLow;
    }
    else
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT( hr, ERROR_INVALID_HANDLE );
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::FormatID
//
// Parameters  : MPC::wstring& szID : output buffer for the ID.
//
// Synopsis    : Returns a textual representation of the client ID.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::FormatID( /*[out]*/ MPC::wstring& szID ) const
{
    __ULT_FUNC_ENTRY("MPCClient::FormatID");

    HRESULT  hr;
    CComBSTR bstrSig;

    bstrSig = m_sigID.guidMachineID;
    szID    = bstrSig;
    hr      = S_OK;


    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::CheckSignature
//
// Return      : bool : 'true' on success.
//
// Synopsis    : Validates the ID of this client, to ensure it's not a fake.
//
/////////////////////////////////////////////////////////////////////////////
bool MPCClient::CheckSignature() const
{
    __ULT_FUNC_ENTRY("MPCClient::CheckSignature");

    bool fRes = true;

    __ULT_FUNC_EXIT(fRes);
}

/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::OpenStorage
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : Opens the Directory File for this client, trying to
//               lock it for exclusive usage.
//               The file is kept open until this object is deleted.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::OpenStorage( /*[in]*/ bool fCheckFreeSpace )
{
    __ULT_FUNC_ENTRY("MPCClient::OpenStorage");

    HRESULT      hr;
    MPC::wstring szFile;
    bool         fLocked = false;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetFileName( szFile ));

    //
    // If requested, make sure there's enough free space before opening the file.
    //
    if(fCheckFreeSpace)
    {
        bool fEnough;

        __MPC_EXIT_IF_METHOD_FAILS(hr, ::Util_CheckDiskSpace( szFile, DISKSPACE_SAFETYMARGIN, fEnough ));
        if(fEnough == false)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_DISK_FULL );
        }
    }


    if(m_hfFile == NULL)
    {

        // Ensure the directory exists.
        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( szFile ) );

        m_hfFile = ::CreateFileW( szFile.c_str(), GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
        if(m_hfFile == INVALID_HANDLE_VALUE)
        {
            m_hfFile = NULL;

            DWORD dwRes = ::GetLastError();
            if(dwRes == ERROR_SHARING_VIOLATION)
            {
                fLocked = true;
            }

            __MPC_SET_WIN32_ERROR_AND_EXIT( hr, dwRes );
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    if(FAILED(hr))
    {
        MPC::wstring szURL;      m_mpcsServer->getURL( szURL );
        MPC::wstring szID; (void)FormatID            ( szID  );

        if(fLocked)
        {
            (void)g_NTEvents.LogEvent( EVENTLOG_INFORMATION_TYPE, PCHUL_WARN_COLLISION,
                                       szURL .c_str(), // %1 = SERVER
                                       szID  .c_str(), // %2 = CLIENT
                                       szFile.c_str(), // %3 = FILE
                                       NULL          );
        }
        else
        {
            (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, PCHUL_ERR_CLIENT_DB,
                                       szURL .c_str(), // %1 = SERVER
                                       szID  .c_str(), // %2 = CLIENT
                                       szFile.c_str(), // %3 = FILE
                                       NULL          );
        }
    }

    __ULT_FUNC_EXIT(hr);
}


/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::InitFromDisk
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : Opens the Directory File (if not already opened) and reads
//               the state of the client from disk.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::InitFromDisk( /*[in]*/ bool fCheckFreeSpace )
{
    __ULT_FUNC_ENTRY("MPCClient::InitFromDisk");

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, OpenStorage( fCheckFreeSpace ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, Load( MPC::Serializer_File( m_hfFile ) ));


    //
    // Now check that all the files exist.
    //
    {
        Iter it = m_lstActiveSessions.begin();
        while(it != m_lstActiveSessions.end())
        {
            bool    fPassed;
            HRESULT hr2 = it->Validate( true, fPassed );

            if(FAILED(hr2) || fPassed == false)
            {
                m_lstActiveSessions.erase( it ); // Remove session.
                m_fDirty = true;

                it = m_lstActiveSessions.begin(); // Iterator corrupted, restart from beginning.
            }
            else
            {
                it++;
            }
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    //
    // If the file is not correctly loaded, try to recreate it.
    //
    if(hr == HRESULT_FROM_WIN32( ERROR_HANDLE_EOF ))
    {
        hr = SaveToDisk();
    }

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::SaveToDisk
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : Opens the Directory File (if not already opened) and writes
//               the state of the client to disk.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::SaveToDisk()
{
    __ULT_FUNC_ENTRY("MPCClient::SaveToDisk");

    HRESULT hr;
    DWORD   dwRes;


    __MPC_EXIT_IF_METHOD_FAILS(hr, OpenStorage( false ));


    //
    // Move to the beginning of the file and truncate it.
    //
    __MPC_EXIT_IF_CALL_RETURNS_THISVALUE(hr, ::SetFilePointer( m_hfFile, 0, NULL, FILE_BEGIN ), INVALID_SET_FILE_POINTER);

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::SetEndOfFile( m_hfFile ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, Save( MPC::Serializer_File( m_hfFile ) ));

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::SyncToDisk
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : If the Directory File has been read and modified, update it to disk.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::SyncToDisk()
{
    __ULT_FUNC_ENTRY("MPCClient::SyncToDisk");

    HRESULT hr;


    if(m_hfFile && IsDirty())
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, SaveToDisk());
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::GetSessions
//
// Parameters  : Iter& itBegin : first session.
//               Iter& itEnd   : end session marker.
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : Returns two iterators to access the sessions.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::GetSessions( /*[out]*/ Iter& itBegin ,
                                /*[out]*/ Iter& itEnd   )
{
    __ULT_FUNC_ENTRY("MPCClient::GetSessions");

    HRESULT hr;


    itBegin = m_lstActiveSessions.begin();
    itEnd   = m_lstActiveSessions.end  ();
    hr      = S_OK;


    __ULT_FUNC_EXIT(hr);
}


/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::NewSession
//
// Parameters  : UploadLibrary::ClientRequest_OpenSession& req :
//                holds the information for the new session about to create.
//
// Return      : MPCClient::Iter : an iterator pointing to the new session.
//
// Synopsis    : Based on the values of 'req', creates a new session.
//
/////////////////////////////////////////////////////////////////////////////
MPCClient::Iter MPCClient::NewSession( /*[in]*/ UploadLibrary::ClientRequest_OpenSession& crosReq )
{
    __ULT_FUNC_ENTRY("MPCClient::NewSession");

    MPCClient::Iter it;
    MPCSession      mpcsNewSession( this, crosReq, m_dwLastSession++ );

    it = m_lstActiveSessions.insert( m_lstActiveSessions.end(), mpcsNewSession );

    ::GetSystemTime( &m_stLastUsed );
    m_fDirty = true;


    __ULT_FUNC_EXIT(it);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCClient::AppendData
//
// Parameters  : UploadLibrary::ClientRequest_OpenSession& req : holds the information for the new session about to create.
//
// Return      : MPCClient::Iter : an iterator pointing to the new session.
//
// Synopsis    : Based on the values of 'req', creates a new session.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCClient::AppendData( /*[in]*/ MPCSession&      mpcsSession ,
                               /*[in]*/ MPC::Serializer& streamConn  ,
                               /*[in]*/ DWORD            dwSize      )
{
    __ULT_FUNC_ENTRY("MPCClient::AppendData");

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, mpcsSession.AppendData( streamConn, dwSize ));

    ::GetSystemTime( &m_stLastUsed );
    m_fDirty = true;
    hr       = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPCClient::CheckQuotas( /*[in] */ MPCSession& mpcsSession  ,
                                /*[out]*/ bool&       fServerBusy  ,
                                /*[out]*/ bool&       fAccessDenied,
                                /*[out]*/ bool&       fExceeded    )
{
    __ULT_FUNC_ENTRY("MPCClient::CheckQuotas");

    HRESULT         hr;
    DWORD           dwError       = 0;
    DWORD           dwJobsPerDay  = 0;
    DWORD           dwBytesPerDay = 0;
    DWORD           dwJobSize     = 0;
    DWORD           dwMaxJobsPerDay;
    DWORD           dwMaxBytesPerDay;
    DWORD           dwMaxJobSize;
    DWORD           fProcessingMode;
    CISAPIprovider* isapiProvider;
    IterConst       it;
    bool            fFound;


    fServerBusy   = false;
    fAccessDenied = false;
    fExceeded     = false;


    //
    // If the related provider doesn't exist, validation fails.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, mpcsSession.GetProvider( isapiProvider, fFound ));
    if(fFound == false)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, isapiProvider->get_MaxJobSize    ( dwMaxJobSize     ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, isapiProvider->get_MaxJobsPerDay ( dwMaxJobsPerDay  ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, isapiProvider->get_MaxBytesPerDay( dwMaxBytesPerDay ));
    __MPC_EXIT_IF_METHOD_FAILS(hr, isapiProvider->get_ProcessingMode( fProcessingMode  ));

    if(fProcessingMode != 0)
    {
        fServerBusy = true;
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    mpcsSession.get_TotalSize( dwJobSize );

	//
	// Find inactive sessions.
	//
	{
		double dblNow = MPC::GetSystemTime();

		for(it = m_lstActiveSessions.begin(); it != m_lstActiveSessions.end(); it++)
		{
			double dblLastModified;

			it->get_LastModified( dblLastModified );
			
			if(dblNow - dblLastModified < 1.0) // Within 24 hours.
			{
				DWORD dwTotalSize; it->get_TotalSize( dwTotalSize );

				dwJobsPerDay  += 1;
				dwBytesPerDay += dwTotalSize;
			}
		}
	}

    if(dwMaxJobSize && dwMaxJobSize < dwJobSize)
    {
        dwError       = PCHUL_INFO_QUOTA_JOB_SIZE;
        fAccessDenied = true;
    }

    if(dwMaxJobsPerDay && dwMaxJobsPerDay < dwJobsPerDay)
    {
        dwError   = PCHUL_INFO_QUOTA_DAILY_JOBS;
        fExceeded = true;
    }

    if(dwMaxBytesPerDay && dwMaxBytesPerDay < dwBytesPerDay)
    {
        dwError   = PCHUL_INFO_QUOTA_DAILY_BYTES;
        fExceeded = true;
    }


    //
    // Check if enough free space is available.
    //
    {
        MPC::wstring szFile;
        bool         fEnough;

        __MPC_EXIT_IF_METHOD_FAILS(hr, GetFileName( szFile ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, ::Util_CheckDiskSpace( szFile, DISKSPACE_SAFETYMARGIN, fEnough ));
        if(fEnough == false)
        {
            dwError   = PCHUL_INFO_QUOTA_DAILY_BYTES;
            fExceeded = true;
        }
    }


    if(dwError != 0)
    {
        //
        // Quota limits exceeded.
        //
        MPC::wstring szURL;        m_mpcsServer->getURL   ( szURL  );
        MPC::wstring szID;   (void)FormatID               ( szID   );
        MPC::wstring szName; (void)isapiProvider->get_Name( szName );

        (void)g_NTEvents.LogEvent( EVENTLOG_INFORMATION_TYPE, dwError,
                                   szURL .c_str(), // %1 = SERVER
                                   szID  .c_str(), // %2 = CLIENT
                                   szName.c_str(), // %3 = PROVIDER
                                   NULL          );
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\upload\server\isapi\httpcontext.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    HttpContext.cpp

Abstract:
    This file contains the implementation of the MPCHttpContext class,
    which handles the interface with IIS.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#include "stdafx.h"


#define BUFFER_SIZE_TMP      (64)


static const char szStatus [] = "200 OK";
static const char szNewLine[] = "\r\n";


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//
// Static functions.
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


static void SupportAddHeader( /*[in/out]*/ MPC::string& szHeaders     ,
                              /*[in]    */ const char*  szHeaderName  ,
                              /*[in]    */ const char*  szHeaderValue )
{
    __ULT_FUNC_ENTRY("SupportAddHeader");


    szHeaders.append( szHeaderName  );
    szHeaders.append( ": "          );
    szHeaders.append( szHeaderValue );
    szHeaders.append( szNewLine     );
}

static void SupportAddHeader( /*[in/out]*/ MPC::string& szHeaders     ,
                              /*[in]    */ const char*  szHeaderName  ,
                              /*[in]    */ DWORD        dwHeaderValue )
{
    __ULT_FUNC_ENTRY("SupportAddHeader");

    char rgBuf[BUFFER_SIZE_TMP];


    sprintf( rgBuf, "%lu", dwHeaderValue );

    SupportAddHeader( szHeaders, szHeaderName, rgBuf );
}

static void SupportEndHeaders( /*[in/out]*/ MPC::string& szHeaders )
{
    __ULT_FUNC_ENTRY("SupportEndHeaders");


    szHeaders.append( szNewLine );
}

//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//
// Construction/Destruction
//
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

MPCHttpContext::MPCHttpContext() : m_hsInput (g_Heap),
                                   m_hsOutput(g_Heap)
{
    __ULT_FUNC_ENTRY("MPCHttpContext::MPCHttpContext");


    m_pECB              = NULL;

    m_mpcsServer        = NULL;
    m_dwSkippedInput    = 0;
    m_fRequestProcessed = FALSE;
    m_fKeepConnection   = TRUE;

    m_fAsync            = FALSE;
    m_FSMstate          = FSM_REGISTER;
    m_IOstate           = IO_IDLE;


#ifdef DEBUG
    m_Debug_NO_RESPONSE_TO_OPEN           = false;

    m_Debug_NO_RESPONSE_TO_WRITE          = false;

    m_Debug_RESPONSE_TO_OPEN              = false;
    m_Debug_RESPONSE_TO_OPEN_response     = 0;
    m_Debug_RESPONSE_TO_OPEN_position     = -1;
    m_Debug_RESPONSE_TO_OPEN_protocol     = UPLOAD_LIBRARY_PROTOCOL_VERSION_SRV;

    m_Debug_RESPONSE_TO_WRITE             = false;
    m_Debug_RESPONSE_TO_WRITE_response    = 0;
    m_Debug_RESPONSE_TO_WRITE_position    = -1;
    m_Debug_RESPONSE_TO_WRITE_protocol    = UPLOAD_LIBRARY_PROTOCOL_VERSION_SRV;

    m_Debug_RANDOM_POINTER_ERROR          = false;
    m_Debug_RANDOM_POINTER_ERROR_pos_low  = 0;
    m_Debug_RANDOM_POINTER_ERROR_pos_high = -1;

    m_Debug_FIXED_POINTER_ERROR           = false;
    m_Debug_FIXED_POINTER_ERROR_pos       = 0;
#endif
}

MPCHttpContext::~MPCHttpContext()
{
    __ULT_FUNC_ENTRY("MPCHttpContext::~MPCHttpContext");


    if(m_mpcsServer) delete m_mpcsServer;

    if(m_fAsync && m_pECB)
    {
        //
        //  Close session.
        //
        m_pECB->ServerSupportFunction( m_pECB->ConnID            ,
                                       HSE_REQ_DONE_WITH_SESSION ,
                                       NULL                      ,
                                       NULL                      ,
                                       NULL                      );
    }
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//
// Callbacks
//
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

VOID WINAPI MPCHttpContext::IOCompletion( /*[in]*/ EXTENSION_CONTROL_BLOCK* pECB     ,
                                          /*[in]*/ PVOID                    pContext ,
                                          /*[in]*/ DWORD                    cbIO     ,
                                          /*[in]*/ DWORD                    dwError  )
{
    __ULT_FUNC_ENTRY("MPCHttpContext::IOCompletion");

    MPCHttpContext* ptr = NULL;

    try
    {
        ptr = reinterpret_cast<MPCHttpContext*>(pContext);

        ptr->m_pECB = pECB;

        if(dwError != ERROR_SUCCESS)
        {
            delete ptr; ptr = NULL;
        }
        else
        {
            switch( ptr->m_IOstate )
            {
            case IO_IDLE:
                break;

            case IO_READING:
                //
                // If the request has already been processed, simply count the number of bytes received.
                //
                if(ptr->m_fRequestProcessed)
                {
                    ptr->m_dwSkippedInput += cbIO;
                }
                else
                {
                    ptr->m_hsInput.write( ptr->m_rgBuffer, cbIO );
                }

                //
                // If this is the last request (cbIO==0) or the number of bytes skipped is equal to the number of missing bytes,
                // proceed to the next phase.
                //
                if(cbIO == 0 || ptr->m_dwSkippedInput == ptr->m_hsInput.GetAvailableForWrite())
                {
                    ptr->m_IOstate = IO_IDLE;
                }
                else
                {
                    if(ptr->Fsm_Process() == HSE_STATUS_ERROR)
                    {
                        delete ptr; ptr = NULL;
                    }
                    else
                    {
                        ptr->AsyncRead();
                    }
                }
                break;

            case IO_WRITING:
                if(cbIO == 0 || ptr->m_hsOutput.IsEOR())
                {
                    ptr->m_IOstate = IO_IDLE;
                }
                else
                {
                    ptr->AsyncWrite();
                }
                break;
            }

            if(ptr->m_IOstate == IO_IDLE)
            {
                ptr->AdvanceFSM();
            }
        }
    }
    catch(...)
    {
        __ULT_TRACE_ERROR( UPLOADLIBID, "Upload Server raised an exception. Gracefully exiting..." );

        (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, PCHUL_ERR_EXCEPTION,
                                   L""            , // %1 = SERVER
                                   L"IOCompletion", // %2 = CLIENT
                                   NULL           );

        if(ptr)
        {
            delete ptr; ptr = NULL;
        }
    }
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//
// Protected Methods.
//
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

DWORD MPCHttpContext::AsyncRead()
{
    __ULT_FUNC_ENTRY("MPCHttpContext::AsyncRead");

    DWORD dwRes  = HSE_STATUS_SUCCESS;
    DWORD dwSize = m_hsInput.GetAvailableForWrite();


    //
    // If not all the data has been read, ask for async I/O operation.
    //
    if(dwSize)
    {
        DWORD dwTmp = HSE_IO_ASYNC;

        m_fAsync  = TRUE;
        m_IOstate = IO_READING;

        dwSize = min( dwSize, sizeof(m_rgBuffer) );

        if(!m_pECB->ServerSupportFunction(  m_pECB->ConnID           ,
                                            HSE_REQ_ASYNC_READ_CLIENT,
                                            m_rgBuffer               ,
                                           &dwSize                   ,
                                           &dwTmp                    ))
        {
            dwRes = HSE_STATUS_ERROR; __ULT_FUNC_LEAVE;
        }
        else
        {
            dwRes = HSE_STATUS_PENDING; __ULT_FUNC_LEAVE;
        }
    }


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(dwRes);
}

DWORD MPCHttpContext::AsyncWrite()
{
    __ULT_FUNC_ENTRY("MPCHttpContext::AsyncWrite");

    DWORD dwRes  = HSE_STATUS_SUCCESS;
    DWORD dwSize = m_hsOutput.GetAvailableForRead();


    //
    // If not all the data has been read, ask for async I/O operation.
    //
    if(dwSize)
    {
        m_fAsync  = TRUE;
        m_IOstate = IO_WRITING;

        dwSize = min( dwSize, sizeof(m_rgBuffer) );

        if(FAILED(m_hsOutput.read( m_rgBuffer, dwSize )))
        {
            dwRes = HSE_STATUS_ERROR; __ULT_FUNC_LEAVE;
        }

        if(m_pECB->WriteClient( m_pECB->ConnID, m_rgBuffer, &dwSize, HSE_IO_ASYNC ) == FALSE)
        {
            dwRes = HSE_STATUS_ERROR; __ULT_FUNC_LEAVE;
        }

        dwRes = HSE_STATUS_PENDING; __ULT_FUNC_LEAVE;
    }


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(dwRes);
}


DWORD MPCHttpContext::AdvanceFSM()
{
    __ULT_FUNC_ENTRY("MPCHttpContext::AdvanceFSM");

    DWORD dwRes  = HSE_STATUS_SUCCESS;
    bool  fClean = false;


    while(dwRes == HSE_STATUS_SUCCESS)
    {
        switch(m_FSMstate)
        {
        case FSM_REGISTER: m_FSMstate = FSM_INPUT  ; dwRes = Fsm_Register    (); break; // Register IO callback.
        case FSM_INPUT   : m_FSMstate = FSM_PROCESS; dwRes = Fsm_ReceiveInput(); break; // Read all the input.
        case FSM_PROCESS : m_FSMstate = FSM_OUTPUT ; dwRes = Fsm_Process     (); break; // Process request.
        case FSM_OUTPUT  : m_FSMstate = FSM_DELETE ; dwRes = Fsm_SendOutput  (); break; // Send output.
        case FSM_DELETE  : fClean     = true;        __ULT_FUNC_LEAVE;                  // Delete the request object.
        }
    }

    if(dwRes != HSE_STATUS_SUCCESS &&
       dwRes != HSE_STATUS_PENDING  )
    {
        fClean = true;
    }


    __ULT_FUNC_CLEANUP;

    if(fClean) delete this;

    __ULT_FUNC_EXIT(dwRes);
}


DWORD MPCHttpContext::Fsm_Register()
{
    __ULT_FUNC_ENTRY("MPCHttpContext::Fsm_Register");

    DWORD dwRes = HSE_STATUS_SUCCESS;


    if(!m_pECB->ServerSupportFunction( m_pECB->ConnID       ,
                                       HSE_REQ_IO_COMPLETION,
                                       IOCompletion         ,
                                       NULL                 ,
                                       (LPDWORD)this        ))
    {
        dwRes = HSE_STATUS_ERROR; __ULT_FUNC_LEAVE;
    }


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(dwRes);
}

DWORD MPCHttpContext::Fsm_ReceiveInput()
{
    __ULT_FUNC_ENTRY("MPCHttpContext::Fsm_ReceiveInput");

    DWORD dwRes = HSE_STATUS_SUCCESS;


    //
    // Alloc a buffer large enough to hold the request data.
    //
    if(FAILED(m_hsInput.SetSize(                  m_pECB->cbTotalBytes ))) { dwRes = HSE_STATUS_ERROR; __ULT_FUNC_LEAVE; }
    if(FAILED(m_hsInput.write  ( m_pECB->lpbData, m_pECB->cbAvailable  ))) { dwRes = HSE_STATUS_ERROR; __ULT_FUNC_LEAVE; }

    dwRes = AsyncRead();


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(dwRes);
}

DWORD MPCHttpContext::Fsm_Process()
{
    __ULT_FUNC_ENTRY("MPCHttpContext::Fsm_Process");

    HRESULT hr;
    DWORD   dwRes = HSE_STATUS_SUCCESS;


    if(m_fRequestProcessed == TRUE) __ULT_FUNC_LEAVE;

    m_hsInput .Rewind();
    m_hsOutput.Reset ();

    if(FAILED(hr = m_mpcsServer->Process( m_fKeepConnection )))
    {
        if(hr == E_PENDING)
        {
            dwRes = HSE_STATUS_PENDING; __ULT_FUNC_LEAVE;
        }

        m_fRequestProcessed = TRUE;

        dwRes = HSE_STATUS_ERROR; __ULT_FUNC_LEAVE;
    }

    m_fRequestProcessed = TRUE;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(dwRes);
}

DWORD MPCHttpContext::Fsm_SendOutput()
{
    __ULT_FUNC_ENTRY("MPCHttpContext::Fsm_SendOutput");

    HSE_SEND_HEADER_EX_INFO headerInfo;
    MPC::string             szHeaders;
    DWORD                   dwRes;


    //
    // Built headers.
    //
    SupportAddHeader( szHeaders, "Content-Length", m_hsOutput.GetSize()        );
    SupportAddHeader( szHeaders, "Content-Type"  , "application/uploadlibrary" );

    SupportEndHeaders( szHeaders );

    //
    //  Populate HSE_SEND_HEADER_EX_INFO struct.
    //
    headerInfo.pszStatus = szStatus;
    headerInfo.cchStatus = strlen( szStatus );
    headerInfo.pszHeader = szHeaders.c_str();
    headerInfo.cchHeader = szHeaders.length();
    headerInfo.fKeepConn = TRUE;

    //
    //  Send response.
    //
    if(!m_pECB->ServerSupportFunction(  m_pECB->ConnID                  ,
                                        HSE_REQ_SEND_RESPONSE_HEADER_EX ,
                                       &headerInfo                      ,
                                        NULL                            ,
                                        NULL                            ))
    {
        dwRes = HSE_STATUS_ERROR; __ULT_FUNC_LEAVE;
    }

    //
    // Send data, if present.
    //
    dwRes = AsyncWrite();


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(dwRes);
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//
// Methods.
//
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

DWORD MPCHttpContext::Init( /*[in]*/ LPEXTENSION_CONTROL_BLOCK pECB )
{
    __ULT_FUNC_ENTRY("MPCHttpContext::Init");

    DWORD        dwRes;
    MPC::wstring szURL;
    MPC::wstring szUser;


    m_pECB = pECB;


    if(FAILED(GetServerVariable( "URL", szURL )))
    {
        szURL = L"DEFAULT";
    }

    if(FAILED(GetServerVariable( "REMOTE_USER", szUser )))
    {
        szUser = L"";
    }


#ifdef DEBUG
    if(pECB->lpszQueryString)
    {
        static MPC::string constNO_RESPONSE_TO_OPEN ( "NO_RESPONSE_TO_OPEN"  );
        static MPC::string constNO_RESPONSE_TO_WRITE( "NO_RESPONSE_TO_WRITE" );
        static MPC::string constRESPONSE_TO_OPEN    ( "RESPONSE_TO_OPEN"     );
        static MPC::string constRESPONSE_TO_WRITE   ( "RESPONSE_TO_WRITE"    );
        static MPC::string constRANDOM_POINTER_ERROR( "RANDOM_POINTER_ERROR" );
        static MPC::string constFIXED_POINTER_ERROR ( "FIXED_POINTER_ERROR"  );


        std::vector<MPC::string> vec;
        std::vector<MPC::string> vec2;
        std::vector<MPC::string> vec3;
        MPC::NocaseCompare       cmp;
        int                      i;

        MPC::SplitAtDelimiter( vec, pECB->lpszQueryString, "&" );

        for(i=0; i<vec.size(); i++)
        {
            MPC::SplitAtDelimiter( vec2, vec[i].c_str(), "=" );

            switch( vec2.size() )
            {
            default:
            case 2 : MPC::SplitAtDelimiter( vec3, vec2[1].c_str(), "," );
            case 1 : break;
            case 0 : continue;
            }

            MPC::string& name = vec2[0];

            if(cmp( name, constNO_RESPONSE_TO_OPEN ))
            {
                m_Debug_NO_RESPONSE_TO_OPEN = true;
            }
            else if(cmp( name, constNO_RESPONSE_TO_WRITE ))
            {
                m_Debug_NO_RESPONSE_TO_WRITE = true;
            }
            else if(cmp( name, constRESPONSE_TO_OPEN ))
            {
                switch( vec3.size() )
                {
                case 3 : m_Debug_RESPONSE_TO_OPEN_protocol = atol( vec3[2].c_str() );
                case 2 : m_Debug_RESPONSE_TO_OPEN_position = atol( vec3[1].c_str() );
                case 1 : m_Debug_RESPONSE_TO_OPEN_response = atol( vec3[0].c_str() );
                         m_Debug_RESPONSE_TO_OPEN          = true;
                }
            }
            else if(cmp( name, constRESPONSE_TO_WRITE ))
            {
                switch( vec3.size() )
                {
                case 3 : m_Debug_RESPONSE_TO_WRITE_protocol = atol( vec3[2].c_str() );
                case 2 : m_Debug_RESPONSE_TO_WRITE_position = atol( vec3[1].c_str() );
                case 1 : m_Debug_RESPONSE_TO_WRITE_response = atol( vec3[0].c_str() );
                         m_Debug_RESPONSE_TO_WRITE          = true;
                }
            }
            else if(cmp( name, constRANDOM_POINTER_ERROR ))
            {
                switch( vec3.size() )
                {
                case 2: m_Debug_RANDOM_POINTER_ERROR_pos_high = atol( vec3[1].c_str() );
                        m_Debug_RANDOM_POINTER_ERROR_pos_low  = atol( vec3[0].c_str() );
                        m_Debug_RANDOM_POINTER_ERROR          = true;
                }
            }
            else if(cmp( name, constFIXED_POINTER_ERROR ))
            {
                switch( vec3.size() )
                {
                case 1 : m_Debug_FIXED_POINTER_ERROR_pos = atol( vec3[0].c_str() );
                         m_Debug_FIXED_POINTER_ERROR     = true;
                }
            }
        }
    }
#endif

    m_mpcsServer = new MPCServer( this, szURL.c_str(), szUser.c_str() );

    if(m_mpcsServer == NULL)
    {
        dwRes = HSE_STATUS_ERROR; __ULT_FUNC_LEAVE;
    }

    dwRes = AdvanceFSM();


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(dwRes);
}


HRESULT MPCHttpContext::GetServerVariable( /*[in]*/ LPCSTR szVar, /*[out]*/ MPC::wstring& szValue )
{
    __ULT_FUNC_ENTRY("MPCHttpContext::GetServerVariable");

    USES_CONVERSION;

    HRESULT hr;
    DWORD   dwRes;
    LPSTR   szData = NULL;
    DWORD   dwSize = 0;


    m_pECB->GetServerVariable( m_pECB->ConnID, (LPSTR)szVar, NULL, &dwSize );

    dwRes = ::GetLastError();
    if(dwRes != ERROR_INSUFFICIENT_BUFFER)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, dwRes);
    }

    __MPC_EXIT_IF_ALLOC_FAILS(hr, szData, new CHAR[dwSize+1]);

    __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, m_pECB->GetServerVariable( m_pECB->ConnID, (LPSTR)szVar, szData, &dwSize ));

    szValue = A2W( szData );
    hr      = S_OK;


    __ULT_FUNC_CLEANUP;

    if(szData) delete [] szData;

    __ULT_FUNC_EXIT(hr);

}
HRESULT MPCHttpContext::GetRequestSize( /*[out]*/ DWORD& dwCount )
{
    __ULT_FUNC_ENTRY("MPCHttpContext::GetRequestSize");

    HRESULT hr;


    dwCount = m_hsInput.GetSize();
    hr      = S_OK;


    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCHttpContext::CheckDataAvailable( /*[in] */ DWORD dwCount    ,
                                            /*[out]*/ bool& fAvailable )
{
    __ULT_FUNC_ENTRY("MPCHttpContext::CheckDataAvailable");

    HRESULT hr;


    fAvailable = (m_hsInput.GetAvailableForRead() >= dwCount);
    hr         = S_OK;


    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCHttpContext::Read( /*[in]*/ void* pBuffer ,
                              /*[in]*/ DWORD dwCount )
{
    __ULT_FUNC_ENTRY("MPCHttpContext::Read");

    HRESULT hr = m_hsInput.read( pBuffer, dwCount );


    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCHttpContext::Write( /*[in]*/ const void* pBuffer ,
                               /*[in]*/ DWORD       dwCount )
{
    __ULT_FUNC_ENTRY("MPCHttpContext::Write");

    HRESULT hr = m_hsOutput.write( pBuffer, dwCount );


    __ULT_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\upload\server\isapi\persist.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Persist.h

Abstract:
    This file contains the declaration of the MPCPersist interface,
    used by MPCClient and MPCSession to persist their state.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULSERVER___PERSIST_H___)
#define __INCLUDED___ULSERVER___PERSIST_H___

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class MPCPersist
{
public:
    virtual bool    IsDirty() const = 0;

    virtual HRESULT Load( /*[in]*/ MPC::Serializer& streamIn  )       = 0;
    virtual HRESULT Save( /*[in]*/ MPC::Serializer& streamOut ) const = 0;
};


#endif // !defined(__INCLUDED___ULSERVER___PERSIST_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\upload\server\isapi\purgeengine.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    PurgeEngine.cpp

Abstract:
    This file contains the implementation of the MPCPurgeEngine class,
    that controls the cleaning of the temporary directories.

Revision History:
    Davide Massarenti   (Dmassare)  07/12/99
        created

******************************************************************************/

#include "stdafx.h"


HRESULT MPCPurgeEngine::Process()
{
    __ULT_FUNC_ENTRY("MPCPurgeEngine::Process");

    HRESULT                  hr;
    HRESULT                  hr2;
    CISAPIconfig::Iter       itInstanceBegin;
    CISAPIconfig::Iter       itInstanceEnd;
    CISAPIinstance::PathIter itPathBegin;
    CISAPIinstance::PathIter itPathEnd;
    double                   dblNow = MPC::GetSystemTime();


    //
    // Enumerate all the instances.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, g_Config.GetInstances( itInstanceBegin, itInstanceEnd ));
    for(;itInstanceBegin != itInstanceEnd; itInstanceBegin++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, itInstanceBegin->get_URL               ( m_szURL                ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, itInstanceBegin->get_QueueSizeMax      ( m_dwQueueSizeMax       ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, itInstanceBegin->get_QueueSizeThreshold( m_dwQueueSizeThreshold ));
        __MPC_EXIT_IF_METHOD_FAILS(hr, itInstanceBegin->get_MaximumJobAge     ( m_dwMaximumJobAge      ));

        m_dblMaximumJobAge = dblNow - m_dwMaximumJobAge;


		MPCServer mpcsServer( NULL, m_szURL.c_str(), NULL );
		m_mpcsServer = &mpcsServer;

        //
        // For each instance, enumerate all the temporary directories.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, itInstanceBegin->GetLocations( itPathBegin, itPathEnd ));
        for(;itPathBegin != itPathEnd; itPathBegin++)
        {
            MPC::FileSystemObject fso( itPathBegin->c_str() );

            if(SUCCEEDED(hr2 = fso.Scan( true )))
            {
                DWORD dwTotalSize = 0;

                m_lstClients.clear();

                __MPC_EXIT_IF_METHOD_FAILS(hr, AnalyzeFolders( &fso, dwTotalSize ));

                __MPC_EXIT_IF_METHOD_FAILS(hr, RemoveOldJobs( dwTotalSize ));

                if(dwTotalSize > m_dwQueueSizeMax)
                {
                    while(dwTotalSize && dwTotalSize > m_dwQueueSizeThreshold)
                    {
                        __MPC_EXIT_IF_METHOD_FAILS(hr, RemoveOldestJob   ( dwTotalSize ));
                        __MPC_EXIT_IF_METHOD_FAILS(hr, RemoveEmptyClients( dwTotalSize ));
                    }
                }
            }
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////

static bool MatchExtension( const MPC::wstring& szPath ,
                            LPCWSTR             szExt  )
{
    MPC::wstring::size_type iPos;

    iPos = szPath.find( szExt, 0 );
    if(iPos != MPC::wstring::npos && iPos + wcslen( szExt ) == szPath.length())
    {
        return true;
    }

    return false;
}

HRESULT MPCPurgeEngine::AnalyzeFolders( /*[in]*/ MPC::FileSystemObject* fso         ,
                                        /*[in]*/ DWORD&                 dwTotalSize )
{
    __ULT_FUNC_ENTRY("MPCPurgeEngine::AnalyzeFolders");

    HRESULT                     hr;
    HRESULT                     hr2;
    MPC::FileSystemObject::List lst;
    MPC::FileSystemObject::Iter it;


    //
    // Process all folders.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, fso->EnumerateFolders( lst ));
    for(it = lst.begin(); it != lst.end(); it++)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, AnalyzeFolders( *it, dwTotalSize ));
    }

    //
    // Process all files.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, fso->EnumerateFiles( lst ));
    for(it = lst.begin(); it != lst.end(); it++)
    {
        MPC::wstring szPath;

        __MPC_EXIT_IF_METHOD_FAILS(hr, (*it)->get_Path( szPath ));

        if(MatchExtension( szPath, CLIENT_CONST__DB_EXTENSION ))
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, AddClient( szPath, dwTotalSize ));
        }
        else if(MatchExtension( szPath, SESSION_CONST__IMG_EXTENSION ))
        {
            ;
        }
        else
        {
            //
            // Any other file should be deleted.
            //
            (void)(*it)->Delete();
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPCPurgeEngine::AddClient( /*[in]*/     const MPC::wstring& szPath      ,
                                   /*[in/out]*/ DWORD&              dwTotalSize )
{
    __ULT_FUNC_ENTRY("MPCPurgeEngine::AddClient");

    HRESULT   hr;
    HRESULT   hr2;
    MPCClient mpccClient( m_mpcsServer, szPath );
    Iter      itClient = m_lstClients.insert( m_lstClients.end(), MPCPurge_ClientSummary( szPath ) );

    if(SUCCEEDED(hr2 = mpccClient.InitFromDisk( false )))
    {
        MPCClient::Iter itBegin;
        MPCClient::Iter itEnd;

        //
        // Adjust total count with size of the Directory File.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, mpccClient.GetFileSize( itClient->m_dwFileSize ));
        dwTotalSize += itClient->m_dwFileSize;


        __MPC_EXIT_IF_METHOD_FAILS(hr, mpccClient.GetSessions( itBegin, itEnd ));
        while(itBegin != itEnd)
        {
            MPCPurge_SessionSummary pssSession;

            itBegin->get_JobID       ( pssSession.m_szJobID         );
            itBegin->get_LastModified( pssSession.m_dblLastModified );
            itBegin->get_CurrentSize ( pssSession.m_dwCurrentSize   );

            //
            // Don't count "committed" jobs in total size, because the file has already been moved.
            //
            if(itBegin->get_Committed())
            {
                pssSession.m_dwCurrentSize = 0;
            }

            itClient->m_lstSessions.push_back( pssSession );

            dwTotalSize += pssSession.m_dwCurrentSize;
            itBegin++;
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPCPurgeEngine::RemoveOldJobs( /*[in/out]*/ DWORD& dwTotalSize )
{
    __ULT_FUNC_ENTRY("MPCPurgeEngine::RemoveOldJobs");

    HRESULT hr;
    HRESULT hr2;
    Iter    it;

    for(it = m_lstClients.begin(); it != m_lstClients.end(); it++)
    {
        MPCPurge_ClientSummary::Iter itSession;
        MPCClient                    mpccClient( m_mpcsServer, it->m_szPath );
        bool                         fInitialized = false;

        while(it->GetOldestSession( itSession ))
        {
            //
            // If the oldest session is younger than the limit, leave the loop.
            //
            if(itSession->m_dblLastModified > m_dblMaximumJobAge)
            {
                break;
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, RemoveSession( mpccClient, fInitialized, it, itSession, dwTotalSize ));
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPCPurgeEngine::RemoveOldestJob( /*[in/out]*/ DWORD& dwTotalSize )
{
    __ULT_FUNC_ENTRY("MPCPurgeEngine::RemoveOldestJob");

    HRESULT hr;
    HRESULT hr2;
    Iter    it;
    Iter    itOldestClient;
    double  dblOldestClient = DBL_MAX;
    bool    fFound          = false;

    //
    // Look for the oldest job.
    //
    for(it = m_lstClients.begin(); it != m_lstClients.end(); it++)
    {
        if(it->m_dblLastModified < dblOldestClient)
        {
            itOldestClient  = it;
            dblOldestClient = it->m_dblLastModified;
            fFound          = true;
        }
    }

    if(fFound)
    {
        MPCPurge_ClientSummary::Iter itSession;
        MPCClient                    mpccClient( m_mpcsServer, itOldestClient->m_szPath );
        bool                         fInitialized = false;

        if(itOldestClient->GetOldestSession( itSession ))
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, RemoveSession( mpccClient, fInitialized, itOldestClient, itSession, dwTotalSize ));

            //
            // Update the m_dblLastModified of the MPCPurge_ClientSummary object.
            //
            itOldestClient->GetOldestSession( itSession );
        }

        if(fInitialized)
        {
            DWORD dwPost;

            __MPC_EXIT_IF_METHOD_FAILS(hr, mpccClient.SyncToDisk (        ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, mpccClient.GetFileSize( dwPost ));

            //
            // Update Directory File size.
            //
            dwTotalSize                  -= itOldestClient->m_dwFileSize;
            dwTotalSize                  += dwPost;
            itOldestClient->m_dwFileSize  = dwPost;
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPCPurgeEngine::RemoveSession( /*[in]*/     MPCClient&                    mpccClient   ,
                                       /*[in/out]*/ bool&                         fInitialized ,
                                       /*[in]*/     Iter                          itClient     ,
                                       /*[in]*/     MPCPurge_ClientSummary::Iter& itSession    ,
                                       /*[in/out]*/ DWORD&                        dwTotalSize  )
{
    __ULT_FUNC_ENTRY("MPCPurgeEngine::RemoveSession");

    HRESULT hr;
    HRESULT hr2;


    //
    // Lock the client.
    //
    if(fInitialized == false)
    {
        if(SUCCEEDED(hr2 = mpccClient.InitFromDisk( false )))
        {
            fInitialized = true;
        }
    }

    if(fInitialized)
    {
        MPCClient::Iter itSessionReal;

        //
        // If the session exists, remove it.
        //
        if(mpccClient.Find( itSession->m_szJobID, itSessionReal ) == true)
        {
            __MPC_EXIT_IF_METHOD_FAILS(hr, itSessionReal->RemoveFile());

            mpccClient.Erase( itSessionReal );
        }

        //
        // Update the total size counter and remove the session from memory.
        //
        dwTotalSize -=                 itSession->m_dwCurrentSize;
        itClient->m_lstSessions.erase( itSession );
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPCPurgeEngine::RemoveEmptyClients( /*[in/out]*/ DWORD& dwTotalSize )
{
    __ULT_FUNC_ENTRY("MPCPurgeEngine::RemoveEmptyClients");

    HRESULT hr;
    Iter    it;

    for(it = m_lstClients.begin(); it != m_lstClients.end(); it++)
    {
        //
        // If the client has no more sessions, don't count it.
        //
        if(it->m_lstSessions.size() == 0)
        {
            dwTotalSize -= it->m_dwFileSize;

            m_lstClients.erase( it ); it = m_lstClients.begin();
        }
    }

    hr = S_OK;


    //    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

MPCPurge_ClientSummary::MPCPurge_ClientSummary( const MPC::wstring& szPath )
{
    m_szPath          = szPath; // MPC::wstring m_szPath;
                              	// List         m_lstSessions;
    m_dwFileSize      = 0;    	// DWORD        m_dwFileSize;
    m_dblLastModified = 0;    	// double       m_dblLastModified;
}

bool MPCPurge_ClientSummary::GetOldestSession( /*[out]*/ Iter& itSession )
{
    Iter it;

    m_dblLastModified = DBL_MAX;
    itSession         = m_lstSessions.end();

    for(it = m_lstSessions.begin(); it != m_lstSessions.end(); it++)
    {
        if(it->m_dblLastModified < m_dblLastModified)
        {
            itSession = it;
            m_dblLastModified = it->m_dblLastModified;
        }
    }

    return (itSession != m_lstSessions.end());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\upload\server\isapi\serializer.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Serializer.cpp

Abstract:
    This file contains the implementation of some Serializer interfaces,
    allowing to use the FileSystem or the HTTP channel in a similar way.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#include "stdafx.h"
#include "Serializer.h"


//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

MPCSerializerHttp::MPCSerializerHttp( /*[in]*/ MPCHttpContext* context )
{
    __ULT_FUNC_ENTRY( "MPCSerializerHttp::MPCSerializerHttp" );


    m_context = context;
}

//////////////////////////////////////////////////////////////////////
// Methods.
//////////////////////////////////////////////////////////////////////

HRESULT MPCSerializerHttp::read( /*[in]*/  void*   pBuf   ,
								 /*[in]*/  DWORD   dwLen  ,
								 /*[out]*/ DWORD* pdwRead )
{
    __ULT_FUNC_ENTRY("MPCSerializerHttp::read");


    HRESULT hr = m_context->Read( pBuf, dwLen );

	if(pdwRead) *pdwRead = dwLen;

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCSerializerHttp::write( /*[in]*/ const void* pBuf  ,
                                  /*[in]*/ DWORD       dwLen )
{
    __ULT_FUNC_ENTRY("MPCSerializerHttp::write");


    HRESULT hr = m_context->Write( pBuf, dwLen );


    __ULT_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\upload\server\isapi\purgeengine.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    PurgeEngine.h

Abstract:
    This file contains the declaration of the MPCPurgeEngine class,
    that controls the cleaning of the temporary directories.

Revision History:
    Davide Massarenti   (Dmassare)  07/12/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULSERVER___PURGEENGINE_H___)
#define __INCLUDED___ULSERVER___PURGEENGINE_H___

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


struct MPCPurge_SessionSummary // Hungarian: pss
{
    MPC::wstring m_szJobID;
    double       m_dblLastModified;
    DWORD        m_dwCurrentSize;
};

struct MPCPurge_ClientSummary // Hungarian: pcs
{
    typedef std::list<MPCPurge_SessionSummary> List;
    typedef List::iterator                     Iter;
    typedef List::const_iterator               IterConst;

    MPC::wstring m_szPath;
    List         m_lstSessions;
    DWORD        m_dwFileSize;
    double       m_dblLastModified;


    MPCPurge_ClientSummary( /*[in]*/ const MPC::wstring& szPath );

    bool GetOldestSession( /*[out]*/ Iter& itSession );
};

class MPCPurgeEngine
{
    typedef std::list<MPCPurge_ClientSummary> List;
    typedef List::iterator                    Iter;
    typedef List::const_iterator              IterConst;

    MPC::wstring m_szURL;
	MPCServer*   m_mpcsServer;
    DWORD        m_dwQueueSizeMax;
    DWORD        m_dwQueueSizeThreshold;
    DWORD        m_dwMaximumJobAge;
    double       m_dblMaximumJobAge;

    List         m_lstClients;


    HRESULT AnalyzeFolders    ( /*[in]*/ MPC::FileSystemObject* fso, /*[in/out]*/ DWORD& dwTotalSize );
    HRESULT AddClient         ( /*[in]*/ const MPC::wstring& szPath, /*[in/out]*/ DWORD& dwTotalSize );
    HRESULT RemoveOldJobs     (                                      /*[in/out]*/ DWORD& dwTotalSize );
    HRESULT RemoveOldestJob   (                                      /*[in/out]*/ DWORD& dwTotalSize );
    HRESULT RemoveEmptyClients(                                      /*[in/out]*/ DWORD& dwTotalSize );

    HRESULT RemoveSession  ( /*[in]*/     MPCClient&                    mpccClient   ,
                             /*[in/out]*/ bool&                         fInitialized ,
                             /*[in]*/     Iter                          itClient     ,
                             /*[in]*/     MPCPurge_ClientSummary::Iter& itSession    ,
                             /*[in/out]*/ DWORD&                        dwTotalSize  );

public:
    HRESULT Process();
};


#endif // !defined(__INCLUDED___ULSERVER___PURGEENGINE_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\upload\server\isapi\server.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Server.h

Abstract:
    This file contains the declaration of the MPCServer class,
    that controls the overall interaction between client and server.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULSERVER___SERVER_H___)
#define __INCLUDED___ULSERVER___SERVER_H___


#include <Wrapper.h>


class MPCServer // Hungarian: mpcs
{
	friend class MPCServerCOMWrapper;
	friend class MPCSessionCOMWrapper;

	////////////////////

    MPC::wstring    	   		  m_szURL;
    MPC::wstring    	   		  m_szUser;
	CISAPIinstance* 	   		  m_isapiInstance;
	MPC::FileLog*   	   		  m_flLogHandle;
	BOOL            	   		  m_fKeepAlive;
	   		  
    MPCHttpContext* 	   		  m_hcCallback;
    MPCClient*      	   		  m_mpccClient;

    UploadLibrary::ClientRequest  m_crClientRequest;
    UploadLibrary::ServerResponse m_srServerResponse;

	MPC::Serializer_Memory 		  m_streamResponseData;
	MPCServerCOMWrapper    		  m_SelfCOM;
	MPCSession*            		  m_Session;
	IULProvider*           		  m_customProvider;
	bool                          m_fTerminated;

	////////////////////////////////////////

    HRESULT GrabClient   ();
    HRESULT ReleaseClient();


    HRESULT HandleCommand_OpenSession ( /*[in] */ MPC::Serializer& streamConn );
    HRESULT HandleCommand_WriteSession( /*[in] */ MPC::Serializer& streamConn );

	void SetResponse( /*[in]*/ DWORD fResponse, /*[in]*/ BOOL fKeepAlive = FALSE );

	////////////////////////////////////////

	HRESULT CustomProvider_Create          ( /*[in]*/ MPCSession& mpcsSession );
	HRESULT CustomProvider_ValidateClient  (                                  );
	HRESULT CustomProvider_DataAvailable   (                                  );
	HRESULT CustomProvider_TransferComplete(                                  );
	HRESULT CustomProvider_SetResponse     ( /*[in]*/ IStream*    data        );
	HRESULT CustomProvider_Release         (                                  );

    //////////////////////////////////////////////////////////////////

public:
    MPCServer( /*[in]*/ MPCHttpContext* hcCallback, /*[in]*/ LPCWSTR szURL, /*[in]*/ LPCWSTR szUser );
    virtual ~MPCServer();

	IULServer* COM();

    /////////////////////////////////////////////

    HRESULT Process( BOOL& fKeepAlive );

    /////////////////////////////////////////////

	void getURL ( MPC::wstring& szURL  );
	void getUser( MPC::wstring& szUser );

	CISAPIinstance* getInstance();
	MPC::FileLog*   getFileLog ();
};

#endif // !defined(__INCLUDED___ULSERVER___SERVER_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\upload\server\isapi\serializer.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Serializer.h

Abstract:
    This file contains the declaration of some Serializer interfaces,
    allowing to use the FileSystem or the HTTP channel in a similar way.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULSERVER___SERIALIZER_H___)
#define __INCLUDED___ULSERVER___SERIALIZER_H___

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class MPCSerializerHttp : public MPC::Serializer
{
    MPCHttpContext* m_context;

    //////////////////////////////////////////////////////////////////

public:
    MPCSerializerHttp( /*[in]*/ MPCHttpContext* context );

    virtual HRESULT read ( /*[in]*/       void* pBuf, /*[in]*/ DWORD dwLen, /*[out]*/ DWORD* dwRead = NULL );
    virtual HRESULT write( /*[in]*/ const void* pBuf, /*[in]*/ DWORD dwLen                                 );
};


#endif // !defined(__INCLUDED___ULSERVER___SERIALIZER_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\upload\server\isapi\server.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Server.cpp

Abstract:
    This file contains the implementation of the MPCServer class,
    that controls the overall interaction between client and server.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#include "stdafx.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

MPCServer::MPCServer( /*[in]*/ MPCHttpContext* hcCallback, /*[in]*/ LPCWSTR szURL, /*[in]*/ LPCWSTR szUser )
    : m_SelfCOM         ( this                                ),
      m_crClientRequest ( 0                                   ),
      m_srServerResponse( UPLOAD_LIBRARY_PROTOCOL_VERSION_SRV ) // Prepare default response protocol.
{
    __ULT_FUNC_ENTRY("MPCServer::MPCServer");

    bool fFound;

    m_szURL          = SAFEWSTR( szURL  ); // MPC::wstring                  m_szURL;
    m_szUser         = SAFEWSTR( szUser ); // MPC::wstring                  m_szUser;
    m_isapiInstance  = NULL;               // CISAPIinstance*               m_isapiInstance;
    m_flLogHandle    = NULL;               // MPC::FileLog*                 m_flLogHandle;
                                           //
    m_hcCallback     = hcCallback;         // MPCHttpContext*               m_hcCallback;
    m_mpccClient     = NULL;               // MPCClient*                    m_mpccClient;
                                           //
                                           // UploadLibrary::ClientRequest  m_crClientRequest;
                                           // UploadLibrary::ServerResponse m_srServerResponse;
                                           //
                                           // MPC::Serializer_Memory        m_streamResponseData;
                                           // MPCServerCOMWrapper           m_SelfCOM;
    m_Session        = NULL;               // MPCSession*            		m_Session;
    m_customProvider = NULL;               // IULProvider*                  m_customProvider;
	m_fTerminated    = false;              // bool                          m_fTerminated;


    if(SUCCEEDED(::Config_GetInstance( m_szURL, m_isapiInstance, fFound )))
    {
        if(fFound)
        {
            m_isapiInstance->get_LogHandle( m_flLogHandle );
        }
    }
}

MPCServer::~MPCServer()
{
    __ULT_FUNC_ENTRY("MPCServer::~MPCServer");


    ReleaseClient();
}

IULServer* MPCServer::COM() { return &m_SelfCOM; }

//////////////////////////////////////////////////////////////////////
// Methods.
//////////////////////////////////////////////////////////////////////

void MPCServer::getURL ( MPC::wstring& szURL  ) { szURL  = m_szURL ; }
void MPCServer::getUser( MPC::wstring& szUser ) { szUser = m_szUser; }

CISAPIinstance* MPCServer::getInstance() { return m_isapiInstance;  }
MPC::FileLog*   MPCServer::getFileLog () { return m_flLogHandle  ;  }

//////////////////////////////////////////////////////////////////////

HRESULT MPCServer::Process( BOOL& fKeepAlive )
{
    __ULT_FUNC_ENTRY("MPCServer::Process");

    MPC::Serializer& streamConn = MPCSerializerHttp( m_hcCallback );
    HRESULT          hr;

    m_fKeepAlive = TRUE;

    try
    {
#ifdef DEBUG
        if(m_hcCallback->m_Debug_FIXED_POINTER_ERROR)
        {
            m_srServerResponse.dwPosition = m_hcCallback->m_Debug_FIXED_POINTER_ERROR_pos;

			SetResponse( UploadLibrary::UL_RESPONSE_SKIPPED, TRUE );
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
#endif

        //
        // Enforce maximum request size.
        //
        {
            DWORD dwMaximumPacketSize;
            DWORD dwCount;


            __MPC_EXIT_IF_METHOD_FAILS(hr, ::Config_GetMaximumPacketSize( m_szURL, dwMaximumPacketSize ));

            __MPC_EXIT_IF_METHOD_FAILS(hr, m_hcCallback->GetRequestSize( dwCount ));

            if(dwCount > dwMaximumPacketSize)
            {
                WCHAR rgSize[16]; swprintf( rgSize, L"%d", dwCount );

                (void)g_NTEvents.LogEvent( EVENTLOG_WARNING_TYPE, PCHUL_WARN_PACKET_SIZE,
                                           m_szURL.c_str(), // %1 = SERVER
                                           rgSize         , // %2 = SIZE
                                           NULL           );

                if(m_flLogHandle)
                {
                    m_flLogHandle->LogRecord( L"ERROR     | Received a packet too large: %ld, limit %ld", dwCount, dwMaximumPacketSize );
                }


				SetResponse( UploadLibrary::UL_RESPONSE_BAD_REQUEST );
                __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
            }
        }


        //
        // Read request.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, streamConn >> m_crClientRequest);

        if(m_srServerResponse.MatchVersion( m_crClientRequest ) == false)
        {
            if(m_flLogHandle)
            {
                m_flLogHandle->LogRecord( L"ERROR     | Received an invalid packet: SIG:%08lx VER:%08lx", m_crClientRequest.rhProlog.dwSignature, m_crClientRequest.rhProlog.dwVersion );
            }

			SetResponse( UploadLibrary::UL_RESPONSE_BAD_REQUEST );
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        if(FAILED(hr = GrabClient()))
        {
            //
            // If another process is handling the file, reply with warning BUSY.
            //
            if(hr == HRESULT_FROM_WIN32( ERROR_SHARING_VIOLATION ))
            {
				SetResponse( UploadLibrary::UL_RESPONSE_BUSY );

                hr = S_OK;
            }

            __ULT_FUNC_LEAVE;
        }


        if(m_crClientRequest.dwCommand == UploadLibrary::UL_COMMAND_OPENSESSION)
        {
            hr = HandleCommand_OpenSession ( streamConn );
        }
        else if(m_crClientRequest.dwCommand == UploadLibrary::UL_COMMAND_WRITESESSION)
        {
            hr = HandleCommand_WriteSession( streamConn );
        }
        else
        {
			SetResponse( UploadLibrary::UL_RESPONSE_BAD_REQUEST );
        }
    }
    catch(...)
    {
        __ULT_TRACE_ERROR( UPLOADLIBID, "Upload Server raised an exception. Gracefully exiting..." );

        MPC::wstring szID;

        if(m_mpccClient)
        {
            (void)m_mpccClient->FormatID( szID );
        }
        else
        {
            szID = L"<UNKNOWN>";
        }

        (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, PCHUL_ERR_EXCEPTION,
                                   m_szURL.c_str(), // %1 = SERVER
                                   szID   .c_str(), // %2 = CLIENT
                                   NULL           );

        //
        // Something ugly happened, reply with SERVER_BUSY...
        //
        SetResponse( UploadLibrary::UL_RESPONSE_BUSY );
    }


    __ULT_FUNC_CLEANUP;


    if(hr != S_FALSE   &&
       hr != E_PENDING  )
    {
        MPC::Serializer_Memory streamRes;

        streamRes << m_srServerResponse;

        m_hcCallback->Write( streamRes           .GetData(), streamRes           .GetSize() );
        m_hcCallback->Write( m_streamResponseData.GetData(), m_streamResponseData.GetSize() );
    }

    //
    // Never return a real failure!
    //
    if(hr != E_PENDING) hr = S_OK;

    ReleaseClient();

    fKeepAlive = m_fKeepAlive;

    __ULT_FUNC_EXIT(hr);
}

//////////////////////////////////////////////////////////////////////
// Helpers.
//////////////////////////////////////////////////////////////////////

HRESULT MPCServer::GrabClient()
{
    __ULT_FUNC_ENTRY("MPCServer::GrabClient");

    HRESULT hr;


    if(m_mpccClient)
    {
        if(*m_mpccClient == m_crClientRequest.sigClient)
        {
            //
            // It's for the same client, dont' do anything...
            //
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, ReleaseClient());
    }


    //
    // Get instance's settings and create client object.
    //
    m_mpccClient = new MPCClient( this, m_crClientRequest.sigClient );


    //
    // Check authenticity of ID.
    //
    if(m_mpccClient->CheckSignature() == false)
    {
        SetResponse( UploadLibrary::UL_RESPONSE_DENIED );
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    if(FAILED(hr = m_mpccClient->InitFromDisk( true )))
    {
        if(hr == HRESULT_FROM_WIN32( ERROR_DISK_FULL ))
        {
            SetResponse( UploadLibrary::UL_RESPONSE_QUOTA_EXCEEDED );

            hr = S_OK;
        }

        __ULT_FUNC_LEAVE;
    }


    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCServer::ReleaseClient()
{
    __ULT_FUNC_ENTRY("MPCServer::ReleaseClient");


    HRESULT hr;


    (void)CustomProvider_Release();


    if(m_mpccClient)
    {
        hr = m_mpccClient->SyncToDisk();

        delete m_mpccClient; m_mpccClient = NULL;

        if(FAILED(hr)) __ULT_FUNC_LEAVE;
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPCServer::HandleCommand_OpenSession( /*[in] */ MPC::Serializer& streamConn )
{
    __ULT_FUNC_ENTRY("MPCServer::HandleCommand_OpenSession");

    UploadLibrary::ClientRequest_OpenSession crosReq( 0 );
    MPCClient::Iter                          it;
    HRESULT                                  hr;
    bool                                     fServerBusy;
    bool                                     fAccessDenied;
    bool                                     fExceeded;

    crosReq.crHeader = m_crClientRequest;


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamConn >> crosReq );


#ifdef DEBUG
    if(m_hcCallback->m_Debug_NO_RESPONSE_TO_OPEN)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

    if(m_hcCallback->m_Debug_RESPONSE_TO_OPEN)
    {
        m_srServerResponse.dwPosition         = m_hcCallback->m_Debug_RESPONSE_TO_OPEN_position;
        m_srServerResponse.rhProlog.dwVersion = m_hcCallback->m_Debug_RESPONSE_TO_OPEN_protocol;

        SetResponse( m_hcCallback->m_Debug_RESPONSE_TO_OPEN_response );
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }
#endif

    //
    // Reject any request whose length is zero.
    //
    if(crosReq.dwSize         == 0 ||
       crosReq.dwSizeOriginal == 0  )
    {
        SetResponse( UploadLibrary::UL_RESPONSE_BAD_REQUEST );
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    if(m_mpccClient->Find( crosReq.szJobID, it ))
    {
        if(it->get_Committed() == true)
        {
            if(it->MatchRequest( crosReq ) == true)
            {
                SetResponse( UploadLibrary::UL_RESPONSE_COMMITTED, TRUE );
            }
            else
            {
                SetResponse( UploadLibrary::UL_RESPONSE_EXISTS );
            }
        }
        else
        {
            SetResponse( UploadLibrary::UL_RESPONSE_SKIPPED, TRUE );
        }
    }
    else
    {
        bool fPassed;

        if(m_flLogHandle)
        {
            m_flLogHandle->LogRecord( L"PROGRESS  | Created new session: '%s' (%s)", crosReq.szJobID.c_str(), crosReq.szProviderID.c_str() );
        }


        it = m_mpccClient->NewSession( crosReq );

        if(SUCCEEDED(hr = it->Validate( false, fPassed )) && fPassed)
        {
            if(SUCCEEDED(hr = m_mpccClient->CheckQuotas( *it, fServerBusy, fAccessDenied, fExceeded  )))
            {
                if(fServerBusy == true)
                {
                    SetResponse( UploadLibrary::UL_RESPONSE_BUSY );
                }
                else if(fAccessDenied == true)
                {
                    SetResponse( UploadLibrary::UL_RESPONSE_DENIED );
                }
                else if(fExceeded == true)
                {
                    SetResponse( UploadLibrary::UL_RESPONSE_QUOTA_EXCEEDED );
                }
                else
                {
                    SetResponse( UploadLibrary::UL_RESPONSE_SUCCESS, TRUE );
                }
            }
        }

        if(FAILED(hr)         ||
           fPassed   == false ||
           fExceeded == true   )
        {
            m_mpccClient->Erase( it );

            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
    }

    __MPC_EXIT_IF_METHOD_FAILS(hr, CustomProvider_Create( *it ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, CustomProvider_ValidateClient());
	if(m_fTerminated) __MPC_SET_ERROR_AND_EXIT(hr, S_OK);


    it->get_CurrentSize( m_srServerResponse.dwPosition );
    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCServer::HandleCommand_WriteSession( /*[in] */ MPC::Serializer& streamConn )
{
    __ULT_FUNC_ENTRY("MPCServer::HandleCommand_WriteSession");

    HRESULT                                   hr;
    UploadLibrary::ClientRequest_WriteSession crwsReq( 0 );
    MPCClient::Iter                           it;
    DWORD                                     dwCurrentSize;
    DWORD                                     dwTotalSize;
    bool                                      fServerBusy;
    bool                                      fAccessDenied;
    bool                                      fExceeded;
    bool                                      fAvailable;


    crwsReq.crHeader = m_crClientRequest;


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamConn >> crwsReq);


#ifdef DEBUG
    if(m_hcCallback->m_Debug_NO_RESPONSE_TO_WRITE)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_FALSE);
    }

    if(m_hcCallback->m_Debug_RESPONSE_TO_WRITE)
    {
        m_srServerResponse.dwPosition         = m_hcCallback->m_Debug_RESPONSE_TO_WRITE_position;
        m_srServerResponse.rhProlog.dwVersion = m_hcCallback->m_Debug_RESPONSE_TO_WRITE_protocol;

        SetResponse( m_hcCallback->m_Debug_RESPONSE_TO_WRITE_response );
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }
#endif


    //
    // Session couldn't be found, reply with error NOTACTIVE.
    //
    if(m_mpccClient->Find( crwsReq.szJobID, it ) == false)
    {
        SetResponse( UploadLibrary::UL_RESPONSE_NOTACTIVE );
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, CustomProvider_Create( *it ));


    __MPC_EXIT_IF_METHOD_FAILS(hr, CustomProvider_ValidateClient());
	if(m_fTerminated) __MPC_SET_ERROR_AND_EXIT(hr, S_OK);


    if(SUCCEEDED(hr = m_mpccClient->CheckQuotas( *it, fServerBusy, fAccessDenied, fExceeded )))
    {
        if(fServerBusy == true)
        {
            SetResponse( UploadLibrary::UL_RESPONSE_BUSY );
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        if(fAccessDenied == true)
        {
            SetResponse( UploadLibrary::UL_RESPONSE_DENIED );
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }

        if(fExceeded == true)
        {
            SetResponse( UploadLibrary::UL_RESPONSE_QUOTA_EXCEEDED );
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
    }


    //
    // Session has already being finished, reply with warning COMMITTED.
    //
    if(it->get_Committed())
    {
        SetResponse( UploadLibrary::UL_RESPONSE_COMMITTED, TRUE );
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


#ifdef DEBUG
    if(m_hcCallback->m_Debug_RANDOM_POINTER_ERROR)
    {
        double pick = (double)rand() / (double)RAND_MAX;

        m_srServerResponse.dwPosition =  m_hcCallback->m_Debug_RANDOM_POINTER_ERROR_pos_low +
                                        (m_hcCallback->m_Debug_RANDOM_POINTER_ERROR_pos_high - m_hcCallback->m_Debug_RANDOM_POINTER_ERROR_pos_low) * pick;

        SetResponse( UploadLibrary::UL_RESPONSE_SKIPPED, TRUE );
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }
#endif

    it->get_CurrentSize( dwCurrentSize );
    it->get_TotalSize  ( dwTotalSize   );

    //
    // If request offset and file size don't match, reply with warning SKIPPED.
    //
    if(dwCurrentSize != crwsReq.dwOffset)
    {
        if(m_flLogHandle)
        {
            m_flLogHandle->LogRecord( L"WARN      | Resync the client to %ld", dwCurrentSize );
        }

        m_srServerResponse.dwPosition = dwCurrentSize;

        SetResponse( UploadLibrary::UL_RESPONSE_SKIPPED, TRUE );
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    //
    // Trim request size (don't overwrite past the declared file size).
    //
    crwsReq.dwSize = min( dwTotalSize - dwCurrentSize, crwsReq.dwSize );

    //
    // If data is not all available, wait.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_hcCallback->CheckDataAvailable( crwsReq.dwSize, fAvailable ));
    if(fAvailable == false)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, E_PENDING);
    }


    if(m_flLogHandle)
    {
        m_flLogHandle->LogRecord( L"PROGRESS  | Writing chunk: %ld bytes at %ld", crwsReq.dwSize, crwsReq.dwOffset );
    }


    //
    // Try to add the chunk to the file. If it fails due to low free disk space, reply with QUOTA_EXCEEDED.
    //
    {
        MPC::Serializer_Text streamText( streamConn );
        MPC::Serializer*     pstream = UploadLibrary::SelectStream( streamConn, streamText );

        if(FAILED(hr = m_mpccClient->AppendData( *it, *pstream, crwsReq.dwSize )))
        {
            if(hr == HRESULT_FROM_WIN32( ERROR_DISK_FULL ))
            {
                SetResponse( UploadLibrary::UL_RESPONSE_QUOTA_EXCEEDED );

                hr = S_OK;
            }

            __ULT_FUNC_LEAVE;
        }

        __MPC_EXIT_IF_METHOD_FAILS(hr, CustomProvider_DataAvailable());
		if(m_fTerminated) __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    //
    // Check for end of transmission.
    //
    it->get_CurrentSize( dwCurrentSize );
    if(dwCurrentSize >= dwTotalSize)
    {
        bool fMatch;

        __MPC_EXIT_IF_METHOD_FAILS(hr, it->CompareCRC( fMatch ));

        if(fMatch == false)
        {
            if(m_flLogHandle)
            {
                m_flLogHandle->LogRecord( L"WARN      | Wrong CRC, restarting..." );
            }

            //
            // The CRC is wrong, so remove the session completely...
            //
            (void)it->RemoveFile();

            m_mpccClient->Erase( it );

            SetResponse( UploadLibrary::UL_RESPONSE_BADCRC );
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
        else
        {
            if(m_flLogHandle)
            {
                m_flLogHandle->LogRecord( L"PROGRESS  | Transfer complete" );
            }

            __MPC_EXIT_IF_METHOD_FAILS(hr, CustomProvider_TransferComplete());
			if(m_fTerminated) __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
    }
    else
    {
        SetResponse( UploadLibrary::UL_RESPONSE_SUCCESS, TRUE );
    }

    it->get_CurrentSize( m_srServerResponse.dwPosition );
    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

void MPCServer::SetResponse( /*[in]*/ DWORD fResponse, /*[in]*/ BOOL fKeepAlive )
{
	m_srServerResponse.fResponse = fResponse;
	m_fKeepAlive                 = fKeepAlive;
}

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////

HRESULT MPCServer::CustomProvider_Create( /*[in]*/ MPCSession& mpcsSession )
{
    __ULT_FUNC_ENTRY("MPCServer::CustomProvider_Create");

    HRESULT hr;


    if(m_customProvider == NULL)
    {
        CISAPIprovider* isapiProvider;
        bool            fFound;

        __MPC_EXIT_IF_METHOD_FAILS(hr, mpcsSession.GetProvider( isapiProvider, fFound ));
        if(fFound)
        {
            MPC::wstring szProviderGUID;
            CLSID        guid;

            __MPC_EXIT_IF_METHOD_FAILS(hr, isapiProvider->get_ProviderGUID( szProviderGUID ));

            if(szProviderGUID.size() && SUCCEEDED(::CLSIDFromString( (LPOLESTR)szProviderGUID.c_str(), &guid )))
            {
                hr = ::CoCreateInstance( guid, NULL, CLSCTX_INPROC_SERVER, IID_IULProvider, (void**)&m_customProvider );

                if(FAILED(hr))
                {
					m_customProvider = NULL;
                }
            }
        }
    }

	m_Session = &mpcsSession;
    hr        = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCServer::CustomProvider_ValidateClient()
{
    __ULT_FUNC_ENTRY("MPCServer::CustomProvider_ValidateClient");

    HRESULT hr;
    bool    fMatch;


    //
    // Before doing anything, check client identity.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, m_Session->CheckUser( m_szUser, fMatch ))
    if(fMatch == false)
    {
		SetResponse( UploadLibrary::UL_RESPONSE_NOT_AUTHORIZED );
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    if(m_customProvider)
    {
        hr = m_customProvider->ValidateClient( COM(), m_Session->COM() );

        if(FAILED(hr) && hr != E_NOTIMPL) __ULT_FUNC_LEAVE;
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}


HRESULT MPCServer::CustomProvider_DataAvailable()
{
    __ULT_FUNC_ENTRY("MPCServer::CustomProvider_DataAvailable");

    HRESULT hr;


    if(m_customProvider)
    {
        hr = m_customProvider->DataAvailable( COM(), m_Session->COM() );

        if(FAILED(hr) && hr != E_NOTIMPL) __ULT_FUNC_LEAVE;
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCServer::CustomProvider_TransferComplete()
{
    __ULT_FUNC_ENTRY("MPCServer::CustomProvider_TransferComplete");

    HRESULT hr;


	//
	// Set the commit flag, but only move the file if we don't have a custom provider.
	//
	if(FAILED(hr = m_Session->put_Committed( true, m_customProvider ? false : true )))
	{
		if(hr == HRESULT_FROM_WIN32( ERROR_DISK_FULL ))
		{
			SetResponse( UploadLibrary::UL_RESPONSE_QUOTA_EXCEEDED );

			hr = S_OK;
		}

		__ULT_FUNC_LEAVE;
	}


	SetResponse( UploadLibrary::UL_RESPONSE_COMMITTED, TRUE );


    if(m_customProvider)
    {
        hr = m_customProvider->TransferComplete( COM(), m_Session->COM() );

        if(FAILED(hr) && hr != E_NOTIMPL) __ULT_FUNC_LEAVE;
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCServer::CustomProvider_SetResponse( /*[in]*/ IStream* data )
{
    __ULT_FUNC_ENTRY("MPCServer::CustomProvider_SetResponse");

    HRESULT hr;


	//
	// Set the commit flag, but only move the file if we don't have a custom provider.
	//
	if(FAILED(hr = m_Session->put_Committed( true, m_customProvider ? false : true )))
	{
		if(hr == HRESULT_FROM_WIN32( ERROR_DISK_FULL ))
		{
			SetResponse( UploadLibrary::UL_RESPONSE_QUOTA_EXCEEDED );

			hr = S_OK;
		}

		__ULT_FUNC_LEAVE;
	}


	SetResponse( UploadLibrary::UL_RESPONSE_COMMITTED, TRUE );


    if(data)
    {
		BYTE  buf[512];
		DWORD dwRead;

		while(1)
		{
			__MPC_EXIT_IF_METHOD_FAILS(hr, data->Read( buf, sizeof(buf), &dwRead ));

			if(dwRead == 0) break;

			__MPC_EXIT_IF_METHOD_FAILS(hr, m_streamResponseData.write( buf, dwRead ));
		}
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}


HRESULT MPCServer::CustomProvider_Release()
{
    __ULT_FUNC_ENTRY("MPCServer::CustomProvider_Release");

    HRESULT hr;


    if(m_customProvider)
    {
		if(m_fTerminated)
		{
			if(m_Session) m_Session->RemoveFile();
		}

        m_customProvider->Release();
		m_customProvider = NULL;
    }

	m_Session = NULL;

    hr = S_OK;


    __ULT_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\upload\server\isapi\session.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Session.cpp

Abstract:
    This file contains the implementation of the MPCSession class,
    that describes the state of a transfer.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#include "stdafx.h"


#define BUFFER_SIZE_FILECOPY (512)


static void EncodeBuffer( /*[in]*/ LPWSTR  rgBufOut ,
                          /*[in]*/ LPCWSTR rgBufIn  ,
                          /*[in]*/ DWORD   iSize    )
{
    int   iLen;
    WCHAR c;

    iLen     = wcslen( rgBufOut );
    iSize    -= iLen + 1;
    rgBufOut += iLen;


    while(iSize > 0 && (c = *rgBufIn++))
    {
        if(_istalnum( c ))
        {
            if(iSize > 1)
            {
                *rgBufOut = c;

                rgBufOut += 1;
                iSize    -= 1;
            }
        }
        else
        {
            if(iSize > 3)
            {
                swprintf( rgBufOut, L"%%%02x", (int)c );

                rgBufOut += 3;
                iSize    -= 3;
            }
        }
    }

    *rgBufOut = 0;
}


//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////
//
// Construction/Destruction
//
//////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////

MPCSession::MPCSession( /*[in]*/ MPCClient* mpccParent ) : m_SelfCOM( this )
{
    __ULT_FUNC_ENTRY("MPCSession::MPCSession");

                                   // MPCSessionCOMWrapper m_SelfCOM;
    m_mpccParent     = mpccParent; // MPCClient*           m_mpccParent;
    m_dwID           = 0;          // DWORD                m_dwID;
                                   //
                                   // MPC::wstring         m_szJobID;
                                   // MPC::wstring         m_szProviderID;
                                   // MPC::wstring         m_szUsername;
                                   //
    m_dwTotalSize    = 0;          // DWORD                m_dwTotalSize;
    m_dwOriginalSize = 0;          // DWORD                m_dwOriginalSize;
    m_dwCRC          = 0;          // DWORD                m_dwCRC;
    m_fCompressed    = false;      // bool                 m_fCompressed;
                                   //
    m_dwCurrentSize  = 0;          // DWORD                m_dwCurrentSize;
                                   // SYSTEMTIME           m_stLastModified;
    m_fCommitted     = false;      // bool                 m_fCommitted;
                                   //
    m_dwProviderData = 0;          // DWORD                m_dwProviderData;
                                   //
    m_fDirty         = false;      // mutable bool         m_fDirty;
}

MPCSession::MPCSession( /*[in]*/ MPCClient*                                      mpccParent ,
                        /*[in]*/ const UploadLibrary::ClientRequest_OpenSession& crosReq    ,
                        /*[in]*/ DWORD                                           dwID       ) : m_SelfCOM( this )
{
    __ULT_FUNC_ENTRY("MPCSession::MPCSession");

                                                     // MPCSessionCOMWrapper m_SelfCOM;
    m_mpccParent     = mpccParent;                   // MPCClient*           m_mpccParent;
    m_dwID           = dwID;                         // DWORD                m_dwID;
                                                     //
    m_szJobID        = crosReq.szJobID;              // MPC::wstring         m_szJobID;
    m_szProviderID   = crosReq.szProviderID;         // MPC::wstring         m_szProviderID;
    m_szUsername     = crosReq.szUsername;           // MPC::wstring         m_szUsername;
                                                     //
    m_dwTotalSize    = crosReq.dwSize;               // DWORD                m_dwTotalSize;
    m_dwOriginalSize = crosReq.dwSizeOriginal;       // DWORD                m_dwOriginalSize;
    m_dwCRC          = crosReq.dwCRC;                // DWORD                m_dwCRC;
    m_fCompressed    = crosReq.fCompressed;          // bool                 m_fCompressed;
                                                     //
    m_dwCurrentSize  = 0;                            // DWORD                m_dwCurrentSize;
    m_fCommitted     = false;                        // SYSTEMTIME           m_stLastModified;
    ::GetSystemTime( &m_stLastModified );            // bool                 m_fCommitted;
                                                     //
    m_dwProviderData = 0;                            // DWORD                m_dwProviderData;
                                                     //
    m_fDirty         = true;                         // mutable bool         m_fDirty;
}

MPCSession::MPCSession( /*[in]*/ const MPCSession& sess ) : m_SelfCOM( this )
{
    __ULT_FUNC_ENTRY("MPCSession::MPCSession");

                                               // MPCSessionCOMWrapper m_SelfCOM;
    m_mpccParent      = sess.m_mpccParent;     // MPCClient*           m_mpccParent;
    m_dwID            = sess.m_dwID;           // DWORD                m_dwID;
                                               //
    m_szJobID         = sess.m_szJobID;        // MPC::wstring         m_szJobID;
    m_szProviderID    = sess.m_szProviderID;   // MPC::wstring         m_szProviderID;
    m_szUsername      = sess.m_szUsername;     // MPC::wstring         m_szUsername;
                                               //
    m_dwTotalSize     = sess.m_dwTotalSize;    // DWORD                m_dwTotalSize;
    m_dwOriginalSize  = sess.m_dwOriginalSize; // DWORD                m_dwOriginalSize;
    m_dwCRC           = sess.m_dwCRC;          // DWORD                m_dwCRC;
    m_fCompressed     = sess.m_fCompressed;    // bool                 m_fCompressed;
                                               //
    m_dwCurrentSize   = sess.m_dwCurrentSize;  // DWORD                m_dwCurrentSize;
    m_stLastModified  = sess.m_stLastModified; // SYSTEMTIME           m_stLastModified;
    m_fCommitted      = sess.m_fCommitted;     // bool                 m_fCommitted;
                                               //
    m_dwProviderData  = sess.m_dwProviderData; // DWORD                m_dwProviderData;
                                               //
    m_fDirty          = sess.m_fDirty;         // mutable bool         m_fDirty;
}

MPCSession::~MPCSession()
{
    __ULT_FUNC_ENTRY("MPCSession::~MPCSession");
}

MPCClient* MPCSession::GetClient() { return m_mpccParent; }

IULSession* MPCSession::COM() { return &m_SelfCOM; }

//////////////////////////////////////////////////////////////////////
// Persistence
//////////////////////////////////////////////////////////////////////

bool MPCSession::IsDirty() const
{
    __ULT_FUNC_ENTRY("MPCSession::IsDirty");


    bool fRes = m_fDirty;


    __ULT_FUNC_EXIT(fRes);
}

HRESULT MPCSession::Load( /*[in]*/ MPC::Serializer& streamIn )
{
    __ULT_FUNC_ENTRY("MPCSession::Load");

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dwID          );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_szJobID       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_szProviderID  );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_szUsername    );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dwTotalSize   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dwOriginalSize);
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dwCRC         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_fCompressed   );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dwCurrentSize );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_stLastModified);
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_fCommitted    );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamIn >> m_dwProviderData);

    m_fDirty = false;
    hr       = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCSession::Save( /*[in]*/ MPC::Serializer& streamOut ) const
{
    __ULT_FUNC_ENTRY("MPCSession::Save");

    HRESULT hr;


    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dwID          );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_szJobID       );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_szProviderID  );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_szUsername    );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dwTotalSize   );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dwOriginalSize);
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dwCRC         );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_fCompressed   );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dwCurrentSize );
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_stLastModified);
    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_fCommitted    );

    __MPC_EXIT_IF_METHOD_FAILS(hr, streamOut << m_dwProviderData);

    m_fDirty = false;
    hr       = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}


//////////////////////////////////////////////////////////////////////
// Operators
//////////////////////////////////////////////////////////////////////

bool MPCSession::operator==( /*[in]*/ const MPC::wstring& rhs )
{
    __ULT_FUNC_ENTRY("MPCSession::operator==");


    bool fRes = (m_szJobID == rhs);


    __ULT_FUNC_EXIT(fRes);
}


bool MPCSession::MatchRequest( /*[in]*/ const UploadLibrary::ClientRequest_OpenSession& crosReq )
{
    __ULT_FUNC_ENTRY("MPCSession::MatchRequest");

    bool fRes = false;

    if(m_szProviderID   == crosReq.szProviderID   &&
       m_szUsername     == crosReq.szUsername     &&
       m_dwTotalSize    == crosReq.dwSize         &&
       m_dwOriginalSize == crosReq.dwSizeOriginal &&
       m_dwCRC          == crosReq.dwCRC          &&
       m_fCompressed    == crosReq.fCompressed     )
    {
        fRes = true;
    }

    return fRes;
}


bool MPCSession::get_Committed() const
{
    bool fRes = m_fCommitted;

    return fRes;
}

HRESULT MPCSession::put_Committed( /*[in]*/ bool fState, /*[in]*/ bool fMove )
{
    __ULT_FUNC_ENTRY("MPCSession::put_Committed");

    HRESULT         hr;


    if(fState)
    {
        if(fMove)
        {
            CISAPIprovider* isapiProvider;
            bool            fFound;

            __MPC_EXIT_IF_METHOD_FAILS(hr, GetProvider( isapiProvider, fFound ));
            if(fFound)
            {
                MPC::wstring szFileDst;

                __MPC_EXIT_IF_METHOD_FAILS(hr, SelectFinalLocation( isapiProvider, szFileDst, fFound ));
                if(fFound == false)
                {
                    __MPC_SET_ERROR_AND_EXIT(hr, E_FAIL);
                }

                __MPC_EXIT_IF_METHOD_FAILS(hr, MoveToFinalLocation( szFileDst ));
            }

            //
            // Make sure we get rid of the file.
            //
            (void)RemoveFile();
        }
    }

    m_fCommitted = fState;
    m_fDirty     = true;

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

void MPCSession::get_JobID( MPC::wstring& szJobID ) const
{
    szJobID = m_szJobID;
}

void MPCSession::get_LastModified( SYSTEMTIME& stLastModified ) const
{
    stLastModified = m_stLastModified;
}

void MPCSession::get_LastModified( double& dblLastModified ) const
{
    ::SystemTimeToVariantTime( const_cast<SYSTEMTIME*>(&m_stLastModified), &dblLastModified );
}

void MPCSession::get_CurrentSize( DWORD& dwCurrentSize ) const
{
    dwCurrentSize = m_dwCurrentSize;
}

void MPCSession::get_TotalSize( DWORD& dwTotalSize ) const
{
    dwTotalSize = m_dwTotalSize;
}

//////////////////////////////////////////////////////////////////////
// Methods
//////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCSession::GetProvider
//
// Parameters  : CISAPIprovider*& isapiProvider : provider of current session.
//               bool&            fFound        : true if provider exists.
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    :
//
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCSession::GetProvider( /*[out]*/ CISAPIprovider*& isapiProvider ,
                                 /*[out]*/ bool&            fFound        )
{
    __ULT_FUNC_ENTRY("MPCSession::GetProvider");

    HRESULT         hr;
    CISAPIinstance* isapiInstance;
    MPC::wstring    szURL;


    isapiProvider = NULL;


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_mpccParent->GetInstance( isapiInstance, fFound ));
    if(fFound)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, isapiInstance->get_URL( szURL ));

        __MPC_EXIT_IF_METHOD_FAILS(hr, Config_GetProvider( szURL, m_szProviderID, isapiProvider, fFound ));
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCSession::SelectFinalLocation
//
// Parameters  : CISAPIprovider* isapiProvider : provider of current session.
//               MPC::wstring&   szFileDst     : Output file directory
//               bool&           fFound        : true if successful.
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    :
//
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCSession::SelectFinalLocation( /*[in] */ CISAPIprovider* isapiProvider ,
                                         /*[out]*/ MPC::wstring&   szFileDst     ,
                                         /*[out]*/ bool&           fFound        )
{
    __ULT_FUNC_ENTRY("MPCSession::SelectFinalLocation");

    HRESULT                  hr;
    CISAPIprovider::PathIter itBegin;
    CISAPIprovider::PathIter itEnd;


    fFound = false;


    __MPC_EXIT_IF_METHOD_FAILS(hr, isapiProvider->GetLocations( itBegin, itEnd ));

    if(itBegin != itEnd)
    {
        WCHAR        rgBuf[MAX_PATH+1];
        MPC::wstring szID;

        __MPC_EXIT_IF_METHOD_FAILS(hr, m_mpccParent->FormatID( szID ));

        wcsncpy     ( rgBuf, L"U_"                 , MAX_PATH );
        EncodeBuffer( rgBuf, m_szProviderID.c_str(), MAX_PATH );
        wcsncat     ( rgBuf, L"_"                  , MAX_PATH );
        wcsncat     ( rgBuf, szID          .c_str(), MAX_PATH );
        wcsncat     ( rgBuf, L"_"                  , MAX_PATH );
        EncodeBuffer( rgBuf, m_szJobID     .c_str(), MAX_PATH );
        wcsncat     ( rgBuf, L"_"                  , MAX_PATH );
        EncodeBuffer( rgBuf, m_szUsername  .c_str(), MAX_PATH );

        szFileDst = *itBegin;
        szFileDst.append( L"\\" );
        szFileDst.append( rgBuf );

        fFound = true;
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCSession::MoveToFinalLocation
//
// Parameters  : MPC::wstring& szFileDst : Output file name
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    :
//
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCSession::MoveToFinalLocation( /*[in]*/ const MPC::wstring& szFileDst )
{
    __ULT_FUNC_ENTRY("MPCSession::MoveToFinalLocation");

    HRESULT      hr;
    ULONG        dwRes;
    MPC::wstring szFileSrc;
    MPC::wstring szFileSrcUncompressed;
    bool         fEnough;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetFileName( szFileSrc ));

    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( szFileDst ) );

    //
    // Check for space in the final destination.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, ::Util_CheckDiskSpace( szFileDst, m_dwOriginalSize + DISKSPACE_SAFETYMARGIN, fEnough ));
    if(fEnough == false)
    {
        __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_DISK_FULL );
    }


    if(m_fCompressed)
    {
        //
        // Check for space in the queue directory.
        //
        __MPC_EXIT_IF_METHOD_FAILS(hr, ::Util_CheckDiskSpace( szFileSrc, m_dwOriginalSize + DISKSPACE_SAFETYMARGIN, fEnough ));
        if(fEnough == false)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_DISK_FULL );
        }


        szFileSrcUncompressed = szFileSrc;
        szFileSrcUncompressed.append( L"_decomp" );

		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::DecompressFromCabinet( szFileSrc.c_str(), szFileSrcUncompressed.c_str(), L"PAYLOAD" ));


        __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MoveFile( szFileSrcUncompressed, szFileDst ));
    }
    else
    {
		__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MoveFile( szFileSrc, szFileDst ));
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    if(szFileSrcUncompressed.length() != 0)
    {
        (void)MPC::DeleteFile( szFileSrcUncompressed );
    }

    //
    // Create entry in the Event Log.
    //
    {
        MPC::wstring    szURL;      (void)m_mpccParent->GetInstance( szURL );
        MPC::wstring    szID;       (void)m_mpccParent->FormatID   ( szID  );
        WCHAR           rgSize[16]; (void)swprintf( rgSize, L"%d", m_dwOriginalSize );

        if(SUCCEEDED(hr))
        {
#ifdef DEBUG
            (void)g_NTEvents.LogEvent( EVENTLOG_INFORMATION_TYPE, PCHUL_SUCCESS_COMPLETEJOB,
                                       szURL         .c_str(), // %1 = SERVER
                                       szID          .c_str(), // %2 = CLIENT
                                       m_szProviderID.c_str(), // %3 = PROVIDER
                                       rgSize                , // %4 = BYTES
                                       szFileDst     .c_str(), // %5 = DESTINATION
                                       NULL                  );
#endif
        }
        else
        {
            (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, PCHUL_ERR_FINALCOPY,
                                       szURL         .c_str(), // %1 = SERVER
                                       szID          .c_str(), // %2 = CLIENT
                                       m_szProviderID.c_str(), // %3 = PROVIDER
                                       rgSize                , // %4 = BYTES
                                       szFileDst     .c_str(), // %5 = DESTINATION
                                       NULL                  );
        }
    }

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPCSession::GetFileName( /*[out]*/ MPC::wstring& szFile )
{
    __ULT_FUNC_ENTRY("MPCSession::GetFileName");

    HRESULT hr;
    WCHAR   rgBuf[32];


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_mpccParent->BuildClientPath( szFile ));

    //
    // The filename for the Data File is "<ID>-<SEQ>.img"
    //
    swprintf( rgBuf, SESSION_CONST__IMG_FORMAT, m_dwID ); szFile.append( rgBuf );

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}


HRESULT MPCSession::RemoveFile()
{
    __ULT_FUNC_ENTRY("MPCSession::RemoveFile");

    HRESULT      hr;
    MPC::wstring szFile;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetFileName( szFile ));

    (void)MPC::DeleteFile( szFile );

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCSession::OpenFile( /*[out]*/ HANDLE& hfFile             ,
                              /*[in] */ DWORD   dwMinimumFreeSpace ,
                              /*[in] */ bool    fSeek              )
{
    __ULT_FUNC_ENTRY("MPCSession::OpenFile");

    HRESULT      hr;
    MPC::wstring szFile;


    __MPC_EXIT_IF_METHOD_FAILS(hr, GetFileName( szFile ));


    //
    // Check if enough free space is available.
    //
    if(dwMinimumFreeSpace)
    {
        bool fEnough;

        __MPC_EXIT_IF_METHOD_FAILS(hr, ::Util_CheckDiskSpace( szFile, dwMinimumFreeSpace, fEnough ));
        if(fEnough == false)
        {
            __MPC_SET_WIN32_ERROR_AND_EXIT(hr, ERROR_DISK_FULL );
        }
    }


    //
    // Ensure the directory exists.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, MPC::MakeDir( szFile ) );

	__MPC_EXIT_IF_INVALID_HANDLE__CLEAN(hr, hfFile, ::CreateFileW( szFile.c_str(), GENERIC_WRITE | GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL ));

    if(fSeek)
    {
        //
        // Move to the correct Last Written position.
        //
        ::SetFilePointer( hfFile, m_dwCurrentSize, NULL, FILE_BEGIN );

        //
        // If current position differs from wanted position, truncate to zero the file.
        //
        if(::SetFilePointer( hfFile, 0, NULL, FILE_CURRENT ) != m_dwCurrentSize)
        {
            ::SetFilePointer( hfFile, 0, NULL, FILE_BEGIN );
            ::SetEndOfFile  ( hfFile                      );

            m_dwCurrentSize = 0;
            m_fDirty        = true;
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCSession::Validate( /*[in] */ bool  fCheckFile ,
                              /*[out]*/ bool& fPassed    )
{
    __ULT_FUNC_ENTRY("MPCSession::Validate");

    HRESULT         hr;
    HANDLE          hfFile = NULL;
    CISAPIprovider* isapiProvider;
    bool            fFound;


    fPassed = false;


    //
    // If the related provider doesn't exist, validation fails.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, GetProvider( isapiProvider, fFound ));
    if(fFound == false)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }

    if(m_fCommitted == true)
    {
        fPassed = true;

        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    /////////////////////////////////////////////////////////
    //
    // If we reach this point, the session is still not committed.
    //

    if(fCheckFile)
    {
        __MPC_EXIT_IF_METHOD_FAILS(hr, OpenFile( hfFile ));

        //
        // All the bytes have been received, so try to commit the job (deferred due to low disk probably).
        //
        if(m_dwCurrentSize >= m_dwTotalSize)
        {
            //
            // Ignore result, if it fails the session won't be committed.
            //
            (void)put_Committed( true, true );
        }
    }

    fPassed = true;
    hr      = S_OK;


    __ULT_FUNC_CLEANUP;

    if(hfFile) ::CloseHandle( hfFile );

    __ULT_FUNC_EXIT(hr);
}

HRESULT MPCSession::CheckUser( /*[in] */ const MPC::wstring& szUser ,
                               /*[out]*/ bool&               fMatch )
{
    __ULT_FUNC_ENTRY("MPCSession::CheckUser");

    HRESULT         hr;
    CISAPIprovider* isapiProvider;
    BOOL            fAuthenticated;
    bool            fFound;


    fMatch = false;

    //
    // If the related provider doesn't exist, validation fails.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, GetProvider( isapiProvider, fFound ));
    if(fFound == false)
    {
        __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
    }


    __MPC_EXIT_IF_METHOD_FAILS(hr, isapiProvider->get_Authenticated( fAuthenticated ));
    if(fAuthenticated)
    {
        if(m_szUsername != szUser)
        {
            __MPC_SET_ERROR_AND_EXIT(hr, S_OK);
        }
    }

    fMatch = true; // User check is positive.
    hr     = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

/////////////////////////////////////////////////////////////////////////////

HRESULT MPCSession::CompareCRC( /*[out]*/ bool& fMatch )
{
    __ULT_FUNC_ENTRY("MPCSession::CompareCRC");

    HRESULT hr;
    HANDLE  hfFile = NULL;
    UCHAR   rgBuf[BUFFER_SIZE_FILECOPY];
    DWORD   dwCRC;


    fMatch = false;

    MPC::InitCRC( dwCRC );


    __MPC_EXIT_IF_METHOD_FAILS(hr, OpenFile( hfFile ));

    //
    // Move to the beginning.
    //
    ::SetFilePointer( hfFile, 0, NULL, FILE_BEGIN );


    //
    // Calculate the CRC, reading all the data.
    //
    while(1)
    {
        DWORD dwRead;

        __MPC_EXIT_IF_CALL_RETURNS_FALSE(hr, ::ReadFile( hfFile, rgBuf, sizeof( rgBuf ), &dwRead, NULL ));

        if(dwRead == 0) // End of File.
        {
            break;
        }


        MPC::ComputeCRC( dwCRC, rgBuf, dwRead );
    }

    fMatch = (dwCRC == m_dwCRC);
    hr     = S_OK;


    __ULT_FUNC_CLEANUP;

    if(hfFile) ::CloseHandle( hfFile );

    __ULT_FUNC_EXIT(hr);
}


/////////////////////////////////////////////////////////////////////////////
//
// Method Name : MPCSession::AppendData
//
// Parameters  : MPC::Serializer& conn : stream sourcing the data.
//               DWORD                   size : size of the data.
//
// Return      : HRESULT : S_OK on success, failed otherwise.
//
// Synopsis    : Writes a block of data from the 'conn' stream to the end of
//               the Data File for this session.
//
/////////////////////////////////////////////////////////////////////////////
HRESULT MPCSession::AppendData( /*[in]*/ MPC::Serializer& streamConn ,
                                /*[in]*/ DWORD            dwSize     )
{
    __ULT_FUNC_ENTRY("MPCSession::AppendData");

    HRESULT hr;
    HANDLE  hfFile = NULL;


    //
    // Open file and make sure there's enough free space.
    //
    __MPC_EXIT_IF_METHOD_FAILS(hr, OpenFile( hfFile, dwSize * 3 ));


    {
        MPC::Serializer_File streamConnOut( hfFile );
        BYTE                 rgBuf[BUFFER_SIZE_FILECOPY];

        hr = S_OK;
        while(dwSize)
        {
            DWORD dwRead = min( BUFFER_SIZE_FILECOPY, dwSize );

            __MPC_EXIT_IF_METHOD_FAILS(hr, streamConn   .read ( rgBuf, dwRead ));
            __MPC_EXIT_IF_METHOD_FAILS(hr, streamConnOut.write( rgBuf, dwRead ));

            dwSize          -= dwRead;
            m_dwCurrentSize += dwRead;

            ::GetSystemTime( &m_stLastModified );
            m_fDirty         = true;
        }
    }

    hr = S_OK;


    __ULT_FUNC_CLEANUP;

    if(hfFile) ::CloseHandle( hfFile );

    __ULT_FUNC_EXIT(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\upload\server\isapi\stdafx.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    StdAfx.h

Abstract:
    Include file for standard system include files or project specific include
    files that are used frequently, but are changed infrequently

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#if !defined(AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_)
#define AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_

#include <windows.h>
#include <atlbase.h>

extern CComModule _Module;

#include <stdio.h>
#include <stdlib.h>
#include <float.h>

#include <httpext.h>
#include <lzexpand.h>

#include <UploadLibrary.h>

#include <UploadLibraryTrace.h>
#include <UploadLibraryISAPI.h>

#include <MPC_Main.h>
#include <MPC_Utils.h>
#include <MPC_Logging.h>
#include <MPC_COM.h>

// For NT Event messages.
#include "UploadServerMsg.h"

#include "HttpContext.h"

#include "Serializer.h"
#include "Persist.h"
#include "Config.h"
#include "Session.h"
#include "Client.h"
#include "Server.h"
#include "Wrapper.h"
#include "PurgeEngine.h"


#define DISKSPACE_SAFETYMARGIN (100*1024)


extern HANDLE       g_Heap;
extern CISAPIconfig g_Config;
extern MPC::NTEvent g_NTEvents;


#endif // !defined(AFX_STDAFX_H__35881994_CD02_11D2_9370_00C04F72DAF7__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\published\dload\adminpch.h ===
#pragma once

#include <dloadexcept.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\upload\server\isapi\session.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Session.h

Abstract:
    This file contains the declaration of the MPCSession class,
    that describes the state of a transfer.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#if !defined(__INCLUDED___ULSERVER___SESSION_H___)
#define __INCLUDED___ULSERVER___SESSION_H___


#include <Wrapper.h>


#define SESSION_CONST__IMG_FORMAT    L"-%08x.img"
#define SESSION_CONST__IMG_EXTENSION L".img"


class MPCSession : public MPCPersist
{
	friend class MPCSessionCOMWrapper;

	////////////////////

	MPCSessionCOMWrapper m_SelfCOM;
    MPCClient*   		 m_mpccParent;
    DWORD        		 m_dwID;

    MPC::wstring 		 m_szJobID;
    MPC::wstring 		 m_szProviderID;
    MPC::wstring 		 m_szUsername;
		
    DWORD        		 m_dwTotalSize;
    DWORD        		 m_dwOriginalSize;
    DWORD        		 m_dwCRC;
    bool         		 m_fCompressed;
		
    DWORD        		 m_dwCurrentSize;
    SYSTEMTIME   		 m_stLastModified;
    bool         		 m_fCommitted;

    DWORD        		 m_dwProviderData;
		
    mutable bool 		 m_fDirty;

    //////////////////////////////////////////////////////////////////

private:
	MPCSession& operator=( /*[in]*/ const MPCSession& sess );

public:
    MPCSession( /*[in]*/ MPCClient* mpccParent                                                                                        );
    MPCSession( /*[in]*/ MPCClient* mpccParent, /*[in]*/ const UploadLibrary::ClientRequest_OpenSession& crosReq, /*[in]*/ DWORD dwID );
	MPCSession( /*[in]*/ const MPCSession& sess                                                                                       );
    virtual ~MPCSession();

	MPCClient*  GetClient();

	IULSession* COM();

    /////////////////////////////////////////////

    virtual bool    IsDirty() const;

    virtual HRESULT Load( /*[in]*/ MPC::Serializer& streamIn  );
    virtual HRESULT Save( /*[in]*/ MPC::Serializer& streamOut ) const;

    bool operator==( /*[in]*/ const MPC::wstring& rhs );

    bool MatchRequest( /*[in]*/ const UploadLibrary::ClientRequest_OpenSession& crosReq );

    bool    get_Committed(                                           ) const;
    HRESULT put_Committed( /*[in]*/ bool fState, /*[in]*/ bool fMove );

    void    get_JobID       ( MPC::wstring& szJobID         ) const;
    void    get_LastModified( SYSTEMTIME&   stLastModified  ) const;
    void    get_LastModified( double&       dblLastModified ) const;
    void    get_CurrentSize ( DWORD&        dwCurrentSize   ) const;
    void    get_TotalSize   ( DWORD&        dwTotalSize     ) const;

    /////////////////////////////////////////////

    HRESULT GetProvider( /*[out]*/ CISAPIprovider*& isapiProvider, /*[out]*/ bool& fFound );

    HRESULT SelectFinalLocation( /*[in]*/ CISAPIprovider* isapiProvider, /*[out]*/ MPC::wstring&       szFileDst, /*[out]*/ bool& fFound );
    HRESULT MoveToFinalLocation(                                         /*[in] */ const MPC::wstring& szFileDst                         );

    /////////////////////////////////////////////

    HRESULT GetFileName( /*[out]*/ MPC::wstring&       szFile                                                                );
    HRESULT RemoveFile (                                                                                                     );
    HRESULT OpenFile   ( /*[out]*/ HANDLE&             hfFile    , /*[in] */ DWORD dwMinimumFreeSpace = 0, bool fSeek = true );
    HRESULT Validate   ( /*[in] */ bool                fCheckFile, /*[out]*/ bool& fPassed                                   );
    HRESULT CheckUser  ( /*[in] */ const MPC::wstring& szUser    , /*[out]*/ bool& fMatch                                    );
    HRESULT CompareCRC (                                           /*[out]*/ bool& fMatch                                    );

    HRESULT AppendData( /*[in]*/ MPC::Serializer& streamConn, /*[in]*/ DWORD dwSize );
};

#endif // !defined(__INCLUDED___ULSERVER___SESSION_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\upload\server\isapi\wrapper.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Wrapper.h

Abstract:
    This file contains the declaration of the COM wrapper classes,
	used for interfacing with the Custom Providers.

Revision History:
    Davide Massarenti   (Dmassare)  04/25/2000
        created

******************************************************************************/

#if !defined(__INCLUDED___ULSERVER___WRAPPER_H___)
#define __INCLUDED___ULSERVER___WRAPPER_H___

#include <UploadServerCustom.h>

class MPCServer;
class MPCClient;
class MPCSession;

template <class Base> class CComUnknown : public Base
{
public:
	STDMETHOD_(ULONG, AddRef )() { return 2; }
	STDMETHOD_(ULONG, Release)() { return 1; }

	STDMETHOD(QueryInterface)( REFIID iid, void* *ppvObject )
	{
		if(ppvObject == NULL) return E_POINTER;

		if(IsEqualGUID( iid, IID_IUnknown   ) ||
		   IsEqualGUID( iid, __uuidof(Base) )  )
		{
			*ppvObject = this;
			return S_OK;
		}
			
		return E_NOINTERFACE;
	}
};

class MPCServerCOMWrapper : public CComUnknown<IULServer>
{
    MPCServer* m_mpcsServer;

public:
	MPCServerCOMWrapper( /*[in]*/ MPCServer* mpcsServer );
	virtual ~MPCServerCOMWrapper();

	// IULServer
    STDMETHOD(GetRequestVariable)( /*[in]*/ BSTR bstrName, /*[out]*/ BSTR *pbstrVal );

    STDMETHOD(AbortTransfer   )(                        );
    STDMETHOD(CompleteTransfer)( /*[in]*/ IStream* data );
};

class MPCSessionCOMWrapper : public CComUnknown<IULSession>
{
    MPCSession* m_mpcsSession;

public:
	MPCSessionCOMWrapper( /*[in]*/ MPCSession* mpcsSession );
	virtual ~MPCSessionCOMWrapper();

	// IULSession
    STDMETHOD(get_Client       )( /*[out]*/ BSTR     *pVal   );
    STDMETHOD(get_Command      )( /*[out]*/ DWORD    *pVal   );

    STDMETHOD(get_ProviderID   )( /*[out]*/ BSTR     *pVal   );
    STDMETHOD(get_Username     )( /*[out]*/ BSTR     *pVal   );

    STDMETHOD(get_JobID        )( /*[out]*/ BSTR     *pVal   );
    STDMETHOD(get_SizeAvailable)( /*[out]*/ DWORD    *pVal   );
    STDMETHOD(get_SizeTotal    )( /*[out]*/ DWORD    *pVal   );
    STDMETHOD(get_SizeOriginal )( /*[out]*/ DWORD    *pVal   );

    STDMETHOD(get_Data         )( /*[out]*/ IStream* *pStm   );

    STDMETHOD(get_ProviderData )( /*[out]*/ DWORD    *pVal   );
    STDMETHOD(put_ProviderData )( /*[in]*/  DWORD     newVal );
};

#endif // !defined(__INCLUDED___ULSERVER___SERVER_H___)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\upload\server\isapi\uploadserver.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    UploadServer.cpp

Abstract:
    This file contains the implementation of the stubs needed
    by an ISAPI extension.

Revision History:
    Davide Massarenti   (Dmassare)  04/20/99
        created

******************************************************************************/

#include "stdafx.h"

#include <initguid.h>

#include "UploadServerCustom_i.c"


////////////////////////////////////////////////////////////////////////////////

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

////////////////////////////////////////////////////////////////////////////////

HANDLE                  g_Heap;
CISAPIconfig            g_Config;
MPC::NTEvent            g_NTEvents;

static CRITICAL_SECTION g_CritSec;
static BOOL             g_Initialized;

static WCHAR	 		g_AppName     [] = L"UploadServer";
static WCHAR	 		g_RegistryBase[] = L"SOFTWARE\\Microsoft\\UploadLibrary\\Settings";


BOOL WINAPI DllMain( HINSTANCE hinstDLL    ,
                     DWORD     fdwReason   ,
                     LPVOID    lpvReserved )
{
    switch( fdwReason )
    {
    case DLL_PROCESS_ATTACH:
        g_Heap = HeapCreate( 0, 0, 0 ); if(g_Heap == NULL) return FALSE;

        InitializeCriticalSection( &g_CritSec );
        g_Initialized = false;

        _Module.Init( ObjectMap, hinstDLL );
        break;

    case DLL_PROCESS_DETACH:
        _Module.Term();

        if(g_Initialized)
        {
            ;
        }

        DeleteCriticalSection( &g_CritSec );

        HeapDestroy( g_Heap );
        break;
    }

    return TRUE;
}

DWORD WINAPI HttpExtensionProc( LPEXTENSION_CONTROL_BLOCK pECB )
{
    __ULT_FUNC_ENTRY("HttpExtensionProc");

	DWORD dwRes;


    if(pECB->lpszQueryString)
    {
        //
        // Exit if there's a query string beginning with DEBUG
        //
        if(!strncmp( pECB->lpszQueryString, "DEBUG", 5 ))
        {
            return HSE_STATUS_ERROR;
        }
    }

	//
	// Process the request.
	//
	try
	{
		MPCHttpContext* ptr = new MPCHttpContext();

		dwRes = ptr->Init( pECB );
	}
	catch(...)
	{
        __ULT_TRACE_ERROR( UPLOADLIBID, "Upload Server raised an exception. Gracefully exiting..." );

        (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, PCHUL_ERR_EXCEPTION,
                                   L""                 , // %1 = SERVER
                                   L"HttpExtensionProc", // %2 = CLIENT
                                   NULL			       );

		dwRes =  HSE_STATUS_ERROR;
    }

	return dwRes;
}

BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO* pVer )
{
    BOOL fRes = TRUE;

    // Create the extension version string, and
    // copy string to HSE_VERSION_INFO structure
    pVer->dwExtensionVersion = MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

    // Copy description string into HSE_VERSION_INFO structure
    strcpy( pVer->lpszExtensionDesc, "My ISAPI Extension" );


    //
    // Load config settings if it's the first time we are invoked.
    //
    if(g_Initialized == FALSE)
    {
        EnterCriticalSection( &g_CritSec );

        if(g_Initialized == FALSE)
        {
            g_Initialized = TRUE;

			__MPC_TRACE_INIT();

            (void)g_NTEvents.Init   ( g_AppName      );
            (void)g_Config  .SetRoot( g_RegistryBase );

            if(FAILED(g_Config.Load()))
            {
                (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, PCHUL_ERR_NOCONFIG, NULL );

                fRes = FALSE;
            }
        }

        LeaveCriticalSection( &g_CritSec );
    }

    (void)g_NTEvents.LogEvent( EVENTLOG_INFORMATION_TYPE, PCHUL_SUCCESS_STARTED, NULL );


    return fRes;
}

BOOL WINAPI TerminateExtension( DWORD dwFlags )
{
    (void)g_NTEvents.LogEvent( EVENTLOG_INFORMATION_TYPE, PCHUL_SUCCESS_STOPPED, NULL );

	__MPC_TRACE_TERM();

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////

void WINAPI PurgeEngine(void)
{
	__MPC_TRACE_INIT();

    (void)g_NTEvents.Init   ( g_AppName      );
    (void)g_Config  .SetRoot( g_RegistryBase );

    if(FAILED(g_Config.Load()))
    {
        (void)g_NTEvents.LogEvent( EVENTLOG_ERROR_TYPE, PCHUL_ERR_NOCONFIG, NULL );
    }
    else
    {
        MPCPurgeEngine mpcpe;

        mpcpe.Process();
    }

	__MPC_TRACE_TERM();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\published\dload\mprui.c ===
#include "adminpch.h"
#pragma hdrstop


static
DWORD
MPRUI_DoPasswordDialog(
    HWND          hwndOwner,
    TCHAR *       pchResource,
    TCHAR *       pchUserName,
    TCHAR *       pchPasswordReturnBuffer,
    DWORD         cbPasswordReturnBuffer,
    BOOL *        pfDidCancel,
    BOOL          fDownLevel
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD
MPRUI_DoProfileErrorDialog(
    HWND          hwndOwner,
    const TCHAR * pchDevice,
    const TCHAR * pchResource,
    const TCHAR * pchProvider,
    DWORD         dwError,
    BOOL          fAllowCancel,
    BOOL *        pfDidCancel,
    BOOL *        pfDisconnect,
    BOOL *        pfHideErrors
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MPRUI_ShowReconnectDialog(
    HWND    hwndParent,
    LPVOID  Params
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MPRUI_WNetClearConnections(
     HWND    hWnd
     )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MPRUI_WNetConnectionDialog(
    IN HWND  hwnd,
    IN DWORD dwType
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MPRUI_WNetConnectionDialog1A(
    IN OUT LPCONNECTDLGSTRUCTA lpConnDlgStruct
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MPRUI_WNetConnectionDialog1W(
    IN OUT LPCONNECTDLGSTRUCTW lpConnDlgStruct
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MPRUI_WNetDisconnectDialog(
    IN HWND  hwnd,
    IN DWORD dwType
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MPRUI_WNetDisconnectDialog1A(
    IN LPDISCDLGSTRUCTA lpConnDlgStruct
    )
{
    return ERROR_PROC_NOT_FOUND;
}


static
DWORD APIENTRY
MPRUI_WNetDisconnectDialog1W(
    IN LPDISCDLGSTRUCTW lpConnDlgStruct
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order
// and are CASE SENSITIVE (i.e., lower case comes last!)
//

DEFINE_PROCNAME_ENTRIES(mprui)
{
    DLPENTRY(MPRUI_DoPasswordDialog)
    DLPENTRY(MPRUI_DoProfileErrorDialog)
    DLPENTRY(MPRUI_ShowReconnectDialog)
    DLPENTRY(MPRUI_WNetClearConnections)
    DLPENTRY(MPRUI_WNetConnectionDialog)
    DLPENTRY(MPRUI_WNetConnectionDialog1A)
    DLPENTRY(MPRUI_WNetConnectionDialog1W)
    DLPENTRY(MPRUI_WNetDisconnectDialog)
    DLPENTRY(MPRUI_WNetDisconnectDialog1A)
    DLPENTRY(MPRUI_WNetDisconnectDialog1W)
};

DEFINE_PROCNAME_MAP(mprui)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\pchealth\upload\server\isapi\wrapper.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    Wrapper.cpp

Abstract:
    This file contains the implementation of the COM wrapper classes,
	used for interfacing with the Custom Providers.

Revision History:
    Davide Massarenti   (Dmassare)  04/25/2000
        created

******************************************************************************/

#include "stdafx.h"

////////////////////////////////////////////////////////////////////////////////

MPCServerCOMWrapper::MPCServerCOMWrapper( /*[in]*/ MPCServer* mpcsServer )
{
	m_mpcsServer = mpcsServer; // MPCServer* m_mpcsServer;
}

MPCServerCOMWrapper::~MPCServerCOMWrapper()
{
}

STDMETHODIMP MPCServerCOMWrapper::GetRequestVariable( /*[in]*/ BSTR bstrName, /*[out]*/ BSTR *pbstrVal )
{
    __ULT_FUNC_ENTRY( "MPCServerCOMWrapper::GetRequestVariable" );

	USES_CONVERSION;

	HRESULT      hr;
	MPC::wstring szValue;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_STRING_NOT_EMPTY(bstrName);
		__MPC_PARAMCHECK_POINTER_AND_SET(pbstrVal,NULL);
	__MPC_PARAMCHECK_END();


	__MPC_EXIT_IF_METHOD_FAILS(hr, m_mpcsServer->m_hcCallback->GetServerVariable( W2A( bstrName ), szValue ));

	hr = MPC::GetBSTR( szValue.c_str(), pbstrVal );


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

STDMETHODIMP MPCServerCOMWrapper::AbortTransfer()
{
    __ULT_FUNC_ENTRY( "MPCServerCOMWrapper::AbortTransfer" );


	m_mpcsServer->SetResponse( UploadLibrary::UL_RESPONSE_DENIED );
	m_mpcsServer->m_fTerminated = true;


    __ULT_FUNC_EXIT(S_OK);
}

STDMETHODIMP MPCServerCOMWrapper::CompleteTransfer( /*[in]*/ IStream* data )
{
    __ULT_FUNC_ENTRY( "MPCServerCOMWrapper::CompleteTransfer" );

	HRESULT hr;


	__MPC_EXIT_IF_METHOD_FAILS(hr, m_mpcsServer->CustomProvider_SetResponse( data ));
	m_mpcsServer->m_fTerminated = true;

	hr = S_OK;


    __ULT_FUNC_CLEANUP;

    __ULT_FUNC_EXIT(hr);
}

////////////////////////////////////////////////////////////////////////////////

MPCSessionCOMWrapper::MPCSessionCOMWrapper( /*[in]*/ MPCSession* mpcsSession )
{
	m_mpcsSession = mpcsSession; // MPCSession* m_mpcsSession;
}

MPCSessionCOMWrapper::~MPCSessionCOMWrapper()
{
}

////////////////////

STDMETHODIMP MPCSessionCOMWrapper::get_Client( /*[out]*/ BSTR *pVal )
{
	CComBSTR tmp( m_mpcsSession->GetClient()->GetServer()->m_crClientRequest.sigClient.guidMachineID );

	return MPC::GetBSTR( tmp, pVal );
}

STDMETHODIMP MPCSessionCOMWrapper::get_Command( /*[out]*/ DWORD *pVal )
{
	if(pVal == NULL) return E_POINTER;

	*pVal = m_mpcsSession->GetClient()->GetServer()->m_crClientRequest.dwCommand;

	return S_OK;
}

STDMETHODIMP MPCSessionCOMWrapper::get_ProviderID( /*[out]*/ BSTR *pVal )
{
	return MPC::GetBSTR( m_mpcsSession->m_szProviderID.c_str(), pVal );
}

STDMETHODIMP MPCSessionCOMWrapper::get_Username( /*[out]*/ BSTR *pVal )
{
	return MPC::GetBSTR( m_mpcsSession->m_szUsername.c_str(), pVal );
}

STDMETHODIMP MPCSessionCOMWrapper::get_JobID( /*[out]*/ BSTR *pVal )
{
	return MPC::GetBSTR( m_mpcsSession->m_szJobID.c_str(), pVal );
}

STDMETHODIMP MPCSessionCOMWrapper::get_SizeAvailable( /*[out]*/ DWORD *pVal )
{
	if(pVal == NULL) return E_POINTER;

	*pVal = m_mpcsSession->m_dwCurrentSize;

	return S_OK;
}

STDMETHODIMP MPCSessionCOMWrapper::get_SizeTotal( /*[out]*/ DWORD *pVal )
{
	if(pVal == NULL) return E_POINTER;

	*pVal = m_mpcsSession->m_dwTotalSize;

	return S_OK;
}

STDMETHODIMP MPCSessionCOMWrapper::get_SizeOriginal( /*[out]*/ DWORD *pVal )
{
	if(pVal == NULL) return E_POINTER;

	*pVal = m_mpcsSession->m_dwOriginalSize;

	return S_OK;
}


STDMETHODIMP MPCSessionCOMWrapper::get_Data( /*[out]*/ IStream* *pStm )
{
    __ULT_FUNC_ENTRY( "MPCServerCOMWrapper::GetRequestVariable" );

	HRESULT                  hr;
	HANDLE                   hfFile = NULL;
    CComPtr<MPC::FileStream> stream;

	__MPC_PARAMCHECK_BEGIN(hr)
		__MPC_PARAMCHECK_POINTER_AND_SET(pStm,NULL);
	__MPC_PARAMCHECK_END();


    __MPC_EXIT_IF_METHOD_FAILS(hr, m_mpcsSession->OpenFile( hfFile, 0, false ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, MPC::CreateInstance( &stream ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, stream->InitForRead( L"", hfFile ));

	__MPC_EXIT_IF_METHOD_FAILS(hr, stream.QueryInterface( pStm ));


    __ULT_FUNC_CLEANUP;

    if(hfFile) ::CloseHandle( hfFile );

    __ULT_FUNC_EXIT(hr);
}


STDMETHODIMP MPCSessionCOMWrapper::get_ProviderData( /*[out]*/ DWORD *pVal )
{
	if(pVal == NULL) return E_POINTER;

	*pVal = m_mpcsSession->m_dwProviderData;

	return S_OK;
}

STDMETHODIMP MPCSessionCOMWrapper::put_ProviderData( /*[in]*/ DWORD newVal )
{
	m_mpcsSession->m_dwProviderData = newVal;
	m_mpcsSession->m_fDirty         = true;

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\published\dload\ntlanman.c ===
#include "adminpch.h"
#pragma hdrstop

DWORD APIENTRY
NPAddConnection3ForCSCAgent(
    HWND            hwndOwner,
    LPNETRESOURCE   lpNetResource,
    LPTSTR          pszPassword,
    LPTSTR          pszUserName,
    DWORD           dwFlags,
    BOOL            *lpfIsDfsConnect
    )
{
    return ERROR_PROC_NOT_FOUND;
}

DWORD APIENTRY
NPCancelConnectionForCSCAgent(
    LPCTSTR         szName,
    BOOL            fForce
    )
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in alphabetical order, and are CASE SENSITIVE (eg lower case comes last!)
//
DEFINE_PROCNAME_ENTRIES(ntlanman)
{
    DLPENTRY(NPAddConnection3ForCSCAgent)
    DLPENTRY(NPCancelConnectionForCSCAgent)
};

DEFINE_PROCNAME_MAP(ntlanman)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\published\mmc\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

TARGETSRCS= $(SDK_INC_PATH)\mmc.h \
            $(SDK_INC_PATH)\mmc.idl \
            $(PRIVATE_INC_PATH)\mmc\mmcGUID.h 

TARGETMOVED= $(BASEDIR)\private\admin\activec\inc\mmc.h \
             $(BASEDIR)\private\admin\activec\lib\mmc_i.c

mmc: $(TARGETSRCS)

clean:
    del /Q /F $(TARGETSRCS)
    del /Q /F $(TARGETMOVED) 

$(SDK_INC_PATH)\mmc.h: $(PASS0_HEADERDIR)\mmc.h
    copy $** $@

$(PRIVATE_INC_PATH)\mmc\mmcGUID.h: $(PASS0_HEADERDIR)\mmc_i.c
    copy $** $@
   
$(SDK_INC_PATH)\mmc.idl: mmc.idl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\published\dload\msi.c ===
#include "adminpch.h"
#pragma hdrstop

#include <msi.h>

static
INSTALLSTATE
WINAPI
MsiGetComponentPathW(LPCWSTR  szProduct,
	             LPCWSTR  szComponent,
                     LPWSTR   lpPathBuf,
                     DWORD    *pcchBuf)
{
    return INSTALLSTATE_UNKNOWN;
}

static
UINT
WINAPI
MsiGetProductInfoW(LPCWSTR  szProduct,
	               LPCWSTR  szAttribute,
                   LPWSTR   lpValueBuf,
                   DWORD    *pcchValueBuf)
{
    return ERROR_PROC_NOT_FOUND;
}

static
INSTALLSTATE
WINAPI
MsiQueryFeatureStateFromDescriptorW(LPCWSTR szDescriptor)
{
    return INSTALLSTATE_UNKNOWN;
}

static
INSTALLSTATE
WINAPI
MsiQueryFeatureStateW(LPCWSTR szProduct, LPCWSTR szFeature)
{
    return INSTALLSTATE_UNKNOWN;
}

static
UINT
WINAPI
MsiDecomposeDescriptorW(LPCWSTR	szDescriptor,
                        LPWSTR szProductCode,
                        LPWSTR szFeatureId,
                        LPWSTR szComponentCode,
                        DWORD* pcchArgsOffset)
{
    return ERROR_PROC_NOT_FOUND;
}


//
// !! WARNING !! The entries below must be in order by ORDINAL
//
DEFINE_ORDINAL_ENTRIES(msi)
{
    DLOENTRY(70, MsiGetProductInfoW)
    DLOENTRY(111, MsiQueryFeatureStateW)
    DLOENTRY(173, MsiGetComponentPathW)
    DLOENTRY(188, MsiQueryFeatureStateFromDescriptorW)
    DLOENTRY(201, MsiDecomposeDescriptorW)
};

DEFINE_ORDINAL_MAP(msi);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\published\wmi\makefile.inc ===
$(O)\wmicore.bmf: wmicore.mof

$(O)\wmidata.h : $(O)\wmicore.bmf
    wmimofck -h$@ $?
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\published\wmiscmgr\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    makefile.inc.

!ENDIF

TARGETSRCS= $(ADMIN_INC_PATH)\SchemaManager.h \
            $(ADMIN_INC_PATH)\SchemaManager.idl 

clean:
    del /Q /F $(TARGETSRCS)

$(ADMIN_INC_PATH)\SchemaManager.h: $(PASS0_HEADERDIR)\SchemaManager.h
    copy $** $@

$(ADMIN_INC_PATH)\SchemaManager.idl: SchemaManager.idl
    copy $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\published\mstask\idletask.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    idletask.h

Abstract:

    This module contains the API and type declaration to support
    idle/background tasks.

Author:

    Dave Fields (davidfie) 26-July-1998
    Cenk Ergan (cenke) 14-June-2000

Revision History:

--*/

#ifndef _IDLETASK_H_
#define _IDLETASK_H_

#ifdef __cplusplus
extern "C" {
#endif

//
// Idle task identifier, used as aid in tracking registered idle
// tasks, especially for debugging. Contact code's maintainers if you
// wish to use idletask functionality.
//

typedef enum _IT_IDLE_TASK_ID {
    ItPrefetcherMaintenanceIdleTaskId,
    ItSystemRestoreIdleTaskId,
    ItOptimalDiskLayoutTaskId,
    ItPrefetchDirectoryCleanupTaskId,
    ItDiskMaintenanceTaskId,
    ItHelpSvcDataCollectionTaskId,
    ItMaxIdleTaskId
} IT_IDLE_TASK_ID, *PIT_IDLE_TASK_ID;

#ifndef MIDL_PASS

DWORD
RegisterIdleTask (
    IN IT_IDLE_TASK_ID IdleTaskId,
    OUT HANDLE *ItHandle,
    OUT HANDLE *StartEvent,
    OUT HANDLE *StopEvent
    );

DWORD
UnregisterIdleTask (
    IN HANDLE ItHandle,
    IN HANDLE StartEvent,
    IN HANDLE StopEvent
    );

DWORD
ProcessIdleTasks (
    VOID
    );

#endif // MIDL_PASS

#ifdef __cplusplus
}
#endif

#endif // _IDLETASK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\published\msi\makefile.inc ===
#
# Build for public Windows installer headers.
#

!IFNDEF NO_STRICT
STRICT=1
!ENDIF

msiinc:\
        $(SDK_INC_PATH)\msi.h \
        $(ADMIN_INC_PATH)\msip.h \
        $(SDK_INC_PATH)\msiquery.h

#
# msi.h, msip.h
#

$(O)\msi.x $(O)\msip.x: msi.w
    hsplit -e -o $(O)\msi.x $(O)\msip.x msi.w

$(O)\msi.h: $(O)\msi.x
    wcshdr < $? > $@

$(O)\msip.h: $(O)\msip.x
    wcshdr < $? > $@
    
$(O)\msiquery.h: msiquery.w
    wcshdr < $? > $@

$(SDK_INC_PATH)\msi.h: $(O)\msi.h
    $(PUBLISH_CMD) {$?=$@}

$(ADMIN_INC_PATH)\msip.h: $(O)\msip.h
    $(PUBLISH_CMD) {$?=$@}
    
$(SDK_INC_PATH)\msiquery.h: $(O)\msiquery.h
    $(PUBLISH_CMD) {$?=$@}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\published\msi\msidefs.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1996 - 2001
//
//  File:       msidefs.h
//
//--------------------------------------------------------------------------

/* msidefs.h   Windows Installer data definitions

____________________________________________________________________________*/

#ifndef __MSIDEFS
#define __MSIDEFS

#ifndef _WIN32_MSI
#if (_WIN32_WINNT >= 0x0510)
#define _WIN32_MSI   200
#elif (_WIN32_WINNT >= 0x0500)
#define _WIN32_MSI   110
#else
#define _WIN32_MSI   100
#endif //_WIN32_WINNT
#endif // !_WIN32_MSI

//__________________________________________________________________________
//
// INSTALLER PROPERTY DEFINITIONS
//__________________________________________________________________________

// Required properties: set in Property table
#define IPROPNAME_PRODUCTNAME      TEXT("ProductName")      // name registered for display
#define IPROPNAME_PRODUCTCODE      TEXT("ProductCode")      // unique string GUID for product
#define IPROPNAME_PRODUCTVERSION   TEXT("ProductVersion")   // string product version
#define IPROPNAME_INSTALLLANGUAGE  TEXT("ProductLanguage")  // install language of product, use to load resources        
#define IPROPNAME_MANUFACTURER     TEXT("Manufacturer")     // name of manufacturer

// Customization properties: set in Property table
#define IPROPNAME_UPGRADECODE      TEXT("UpgradeCode")      // unique string GUID for product family
#define IPROPNAME_PIDTEMPLATE      TEXT("PIDTemplate")      // drives Product ID processing
#define IPROPNAME_DISKPROMPT       TEXT("DiskPrompt")       // prompt for CD
#define IPROPNAME_LEFTUNIT         TEXT("LeftUnit")         // name of unit placed to left of number instead of right
#define IPROPNAME_ADMIN_PROPERTIES TEXT("AdminProperties")  // properties to stuff in admin package
#define IPROPNAME_DEFAULTUIFONT    TEXT("DefaultUIFont")    // the font used in the UI if no other font is specified
#define IPROPNAME_ALLOWEDPROPERTIES TEXT("SecureCustomProperties")
#define IPROPNAME_ENABLEUSERCONTROL TEXT("EnableUserControl") // allows user to specify any public property
#define IPROPNAME_HIDDEN_PROPERTIES TEXT("MsiHiddenProperties")  // properties that should not be dumped into the log file

// Customization properties: set on command-line or in Property table
#define IPROPNAME_USERNAME         TEXT("USERNAME")
#define IPROPNAME_COMPANYNAME      TEXT("COMPANYNAME")
#define IPROPNAME_PIDKEY           TEXT("PIDKEY")           // used with PIDTemplate to form ProductID
#define IPROPNAME_PATCH            TEXT("PATCH")            // patch package to apply - SET BY INSTALLER
#define IPROPNAME_TARGETDIR        TEXT("TARGETDIR")        // target location - defaults to ROOTDRIVE
#define IPROPNAME_ACTION           TEXT("ACTION")           // top-level action to perform - default to INSTALL
#define IPROPNAME_LIMITUI          TEXT("LIMITUI")          // limit ui level to Basic
#define IPROPNAME_LOGACTION        TEXT("LOGACTION")        // log only these actions
#define IPROPNAME_ALLUSERS         TEXT("ALLUSERS")         // install for all users
#define IPROPNAME_INSTALLLEVEL     TEXT("INSTALLLEVEL")
#define IPROPNAME_REBOOT           TEXT("REBOOT")           // force or suppress reboot
#if (_WIN32_MSI >=  110)
#define IPROPNAME_REBOOTPROMPT     TEXT("REBOOTPROMPT")     // allow or suppress reboot prompt
#endif //(_WIN32_MSI >=  110)
#define IPROPNAME_EXECUTEMODE      TEXT("EXECUTEMODE")      // NONE or SCRIPT
#define IPROPVALUE_EXECUTEMODE_NONE TEXT("NONE")            // do not update system
#define IPROPVALUE_EXECUTEMODE_SCRIPT TEXT("SCRIPT")        // default - run script to update system
#define IPROPNAME_EXECUTEACTION    TEXT("EXECUTEACTION")    // run action on server side
#define IPROPNAME_SOURCELIST       TEXT("SOURCELIST")
#define IPROPNAME_ROOTDRIVE        TEXT("ROOTDRIVE")        // default drive to install - SET BY INSTALLER
#define IPROPNAME_TRANSFORMS       TEXT("TRANSFORMS")       // transforms to apply
#define IPROPNAME_TRANSFORMSATSOURCE TEXT("TRANSFORMSATSOURCE") // transforms can be found at source
#define IPROPNAME_TRANSFORMSSECURE   TEXT("TRANSFORMSSECURE")   // file transforms are secured
#define IPROPNAME_SEQUENCE         TEXT("SEQUENCE")         // sequence table to run with SEQUENCE action
#define IPROPNAME_SHORTFILENAMES   TEXT("SHORTFILENAMES")   // force short file names
#define IPROPNAME_PRIMARYFOLDER    TEXT("PRIMARYFOLDER")	   // Folder on the volume the author wants costing info for
#define IPROPNAME_AFTERREBOOT      TEXT("AFTERREBOOT")      // install is after a ForceReboot triggered reboot
#define IPROPNAME_NOCOMPANYNAME    TEXT("NOCOMPANYNAME")
#define IPROPNAME_NOUSERNAME       TEXT("NOUSERNAME")
#define IPROPNAME_DISABLEROLLBACK  TEXT("DISABLEROLLBACK")  // disable rollback for this install
#define IPROPNAME_AVAILABLEFREEREG TEXT("AVAILABLEFREEREG") // set up the free space in the registry before commencing the install
#define IPROPNAME_DISABLEADVTSHORTCUTS TEXT("DISABLEADVTSHORTCUTS") // disable creating darwin shortcuts even if supported
#define IPROPNAME_PATCHNEWPACKAGECODE TEXT("PATCHNEWPACKAGECODE")   // added to property table by patch transforms - used to update
																						  // PackageCode of admin packages when patching admin installs
#define IPROPNAME_PATCHNEWSUMMARYSUBJECT TEXT("PATCHNEWSUMMARYSUBJECT") // added to property table by patch transforms - used to update
																								// Subject summary info property of admin packages when patching admin installs
#define IPROPNAME_PATCHNEWSUMMARYCOMMENTS TEXT("PATCHNEWSUMMARYCOMMENTS") // added to property table by patch transforms - used to update
																								  // Comments summary info property of admin packages when patching admin installs
#define IPROPNAME_PRODUCTLANGUAGE  TEXT("PRODUCTLANGUAGE")   // requested language, must be one in summary information list, selects language transform
#if (_WIN32_MSI >= 150)
#define IPROPNAME_CHECKCRCS        TEXT("MSICHECKCRCS")      // requests Darwin to check CRCs after copying, moving, patching & duplicating files.
#define IPROPNAME_MSINODISABLEMEDIA TEXT("MSINODISABLEMEDIA")  // if set, DISABLEMEDIA won't be set in the AdminProperties stream during an admin install of
																					// a package with compressed source
																					
// property used for URT bootstrapping
#define IPROPNAME_CARRYINGNDP	TEXT("CARRYINGNDP")
#define IPROPVALUE__CARRYINGNDP_URTREINSTALL  TEXT("URTREINSTALL")   // reinstalling/ uninstalling core URT files
#define IPROPVALUE__CARRYINGNDP_URTUPGRADE  TEXT("URTUPGRADE")  // upgrading core URT files

// properties used for multiple instance support
#define IPROPNAME_MSINEWINSTANCE TEXT("MSINEWINSTANCE")
#define IPROPNAME_MSIINSTANCEGUID TEXT("MSIINSTANCEGUID")

#endif // (_WIN32_MSI >= 150)

// Properties used to populate Add/Remove Control Panel values 
#define IPROPNAME_ARPAUTHORIZEDCDFPREFIX  TEXT("ARPAUTHORIZEDCDFPREFIX")
#define IPROPNAME_ARPCOMMENTS             TEXT("ARPCOMMENTS")
#define IPROPNAME_ARPCONTACT              TEXT("ARPCONTACT")
#define IPROPNAME_ARPHELPLINK             TEXT("ARPHELPLINK")
#define IPROPNAME_ARPHELPTELEPHONE        TEXT("ARPHELPTELEPHONE")
#define IPROPNAME_ARPINSTALLLOCATION      TEXT("ARPINSTALLLOCATION")
#define IPROPNAME_ARPNOMODIFY             TEXT("ARPNOMODIFY")
#define IPROPNAME_ARPNOREMOVE             TEXT("ARPNOREMOVE")
#define IPROPNAME_ARPNOREPAIR             TEXT("ARPNOREPAIR")
#define IPROPNAME_ARPREADME               TEXT("ARPREADME")
#define IPROPNAME_ARPSIZE                 TEXT("ARPSIZE")
#define IPROPNAME_ARPSYSTEMCOMPONENT      TEXT("ARPSYSTEMCOMPONENT")
#define IPROPNAME_ARPURLINFOABOUT         TEXT("ARPURLINFOABOUT")
#define IPROPNAME_ARPURLUPDATEINFO        TEXT("ARPURLUPDATEINFO")
#if (_WIN32_MSI >=  110)
#define IPROPNAME_ARPPRODUCTICON          TEXT("ARPPRODUCTICON")
#endif //(_WIN32_MSI >=  110)

// Dynamic properties set by installer during install
#define IPROPNAME_INSTALLED        TEXT("Installed")        // product already installed
#define IPROPNAME_PRODUCTSTATE     TEXT("ProductState")     // state of product (installed,advertised,etc...)
#define IPROPNAME_PRESELECTED      TEXT("Preselected")      // selections made on command line
#define IPROPNAME_RESUME           TEXT("RESUME")           // resuming suspended install
#define IPROPNAME_UPDATESTARTED    TEXT("UpdateStarted")    // have begun to update system
#define IPROPNAME_PRODUCTID        TEXT("ProductID")        // the complete validated Product ID
#define IPROPNAME_OUTOFDISKSPACE   TEXT("OutOfDiskSpace")
#define IPROPNAME_OUTOFNORBDISKSPACE TEXT("OutOfNoRbDiskSpace")
#define IPROPNAME_COSTINGCOMPLETE  TEXT("CostingComplete")
#define IPROPNAME_SOURCEDIR        TEXT("SourceDir")        // source location - SET BY INSTALLER
#define IPROPNAME_REPLACEDINUSEFILES TEXT("ReplacedInUseFiles") // need reboot to completely install one or more files
#define IPROPNAME_PRIMARYFOLDER_PATH TEXT("PrimaryVolumePath")
#define IPROPNAME_PRIMARYFOLDER_SPACEAVAILABLE TEXT("PrimaryVolumeSpaceAvailable")
#define IPROPNAME_PRIMARYFOLDER_SPACEREQUIRED TEXT("PrimaryVolumeSpaceRequired")
#define IPROPNAME_PRIMARYFOLDER_SPACEREMAINING TEXT("PrimaryVolumeSpaceRemaining")
#define IPROPNAME_ISADMINPACKAGE   TEXT("IsAdminPackage")
#define IPROPNAME_ROLLBACKDISABLED TEXT("RollbackDisabled")
#define IPROPNAME_RESTRICTEDUSERCONTROL TEXT("RestrictedUserControl")

// Dynamic properties evaluated upon use
#define IPROPNAME_TIME             TEXT("Time")
#define IPROPNAME_DATE             TEXT("Date")
#define IPROPNAME_DATETIME         TEXT("DateTime")

// Hardware properties: set by installer at initialization
#define IPROPNAME_INTEL            TEXT("Intel")
#define IPROPNAME_ALPHA            TEXT("Alpha")
#if (_WIN32_MSI >=  110)
#define IPROPNAME_ALPHA64          TEXT("Alpha64")
#if (_WIN32_MSI >= 150)
#define IPROPNAME_INTEL64          TEXT("Intel64")
#else // (_WIN32_MSI >= 150)
#define IPROPNAME_IA64             TEXT("IA64")
#endif // (_WIN32_MSI >= 150)
#endif //(_WIN32_MSI >=  110)
#define IPROPNAME_TEXTHEIGHT       TEXT("TextHeight")
#define IPROPNAME_SCREENX          TEXT("ScreenX")
#define IPROPNAME_SCREENY          TEXT("ScreenY")
#define IPROPNAME_CAPTIONHEIGHT    TEXT("CaptionHeight")
#define IPROPNAME_BORDERTOP        TEXT("BorderTop")
#define IPROPNAME_BORDERSIDE       TEXT("BorderSide")
#define IPROPNAME_COLORBITS        TEXT("ColorBits")
#define IPROPNAME_PHYSICALMEMORY   TEXT("PhysicalMemory")
#define IPROPNAME_VIRTUALMEMORY    TEXT("VirtualMemory")
#if (_WIN32_MSI >= 150)
#define IPROPNAME_TEXTHEIGHT_CORRECTION  TEXT("TextHeightCorrection")
#endif // (_WIN32_MSI >= 150)

// Operating System properties: set by installer at initialization
#define IPROPNAME_VERSIONNT         TEXT("VersionNT")
#define IPROPNAME_VERSION9X         TEXT("Version9X")
#if (_WIN32_MSI >= 150)
#define IPROPNAME_VERSIONNT64       TEXT("VersionNT64")
#endif // (_WIN32_MSI >= 150)
#define IPROPNAME_WINDOWSBUILD      TEXT("WindowsBuild")
#define IPROPNAME_SERVICEPACKLEVEL  TEXT("ServicePackLevel")
#if (_WIN32_MSI >=  110)
#define IPROPNAME_SERVICEPACKLEVELMINOR TEXT("ServicePackLevelMinor")
#endif //(_WIN32_MSI >=  110)
#define IPROPNAME_SHAREDWINDOWS     TEXT("SharedWindows")
#define IPROPNAME_COMPUTERNAME      TEXT("ComputerName")
#define IPROPNAME_SHELLADVTSUPPORT  TEXT("ShellAdvtSupport")
#define IPROPNAME_OLEADVTSUPPORT    TEXT("OLEAdvtSupport")
#define IPROPNAME_SYSTEMLANGUAGEID  TEXT("SystemLanguageID")
#define IPROPNAME_TTCSUPPORT        TEXT("TTCSupport")
#define IPROPNAME_TERMSERVER		TEXT("TerminalServer")
#if (_WIN32_MSI >=  110)
#define IPROPNAME_REMOTEADMINTS		TEXT("RemoteAdminTS")
#define IPROPNAME_REDIRECTEDDLLSUPPORT TEXT("RedirectedDllSupport")
#endif //(_WIN32_MSI >=  110)
#if (_WIN32_MSI >= 150)
#define IPROPNAME_NTPRODUCTTYPE                   TEXT("MsiNTProductType")
#define IPROPNAME_NTSUITEBACKOFFICE               TEXT("MsiNTSuiteBackOffice")
#define IPROPNAME_NTSUITEDATACENTER               TEXT("MsiNTSuiteDataCenter")
#define IPROPNAME_NTSUITEENTERPRISE               TEXT("MsiNTSuiteEnterprise")
#define IPROPNAME_NTSUITESMALLBUSINESS            TEXT("MsiNTSuiteSmallBusiness")
#define IPROPNAME_NTSUITESMALLBUSINESSRESTRICTED  TEXT("MsiNTSuiteSmallBusinessRestricted")
#define IPROPNAME_NTSUITEPERSONAL                 TEXT("MsiNTSuitePersonal")
#define IPROPNAME_NETASSEMBLYSUPPORT              TEXT("MsiNetAssemblySupport")
#define IPROPNAME_WIN32ASSEMBLYSUPPORT            TEXT("MsiWin32AssemblySupport")
#endif // (_WIN32_MSI >= 150)


// User properties: set by installer at initialization
#define IPROPNAME_LOGONUSER        TEXT("LogonUser")
#define IPROPNAME_USERSID          TEXT("UserSID")
#define IPROPNAME_ADMINUSER        TEXT("AdminUser")
#define IPROPNAME_USERLANGUAGEID   TEXT("UserLanguageID")
#define IPROPNAME_PRIVILEGED       TEXT("Privileged")

// System folder properties: set by installer at initialization
#define IPROPNAME_WINDOWS_FOLDER   TEXT("WindowsFolder")
#define IPROPNAME_SYSTEM_FOLDER    TEXT("SystemFolder")
#define IPROPNAME_SYSTEM16_FOLDER  TEXT("System16Folder")
#define IPROPNAME_WINDOWS_VOLUME   TEXT("WindowsVolume")
#define IPROPNAME_TEMP_FOLDER      TEXT("TempFolder")
#define IPROPNAME_PROGRAMFILES_FOLDER TEXT("ProgramFilesFolder")
#define IPROPNAME_COMMONFILES_FOLDER TEXT("CommonFilesFolder")
#if (_WIN32_MSI >= 150)
#define IPROPNAME_SYSTEM64_FOLDER    TEXT("System64Folder")
#define IPROPNAME_PROGRAMFILES64_FOLDER TEXT("ProgramFiles64Folder")
#define IPROPNAME_COMMONFILES64_FOLDER TEXT("CommonFiles64Folder")
#endif // (_WIN32_MSI >= 150)
#define IPROPNAME_STARTMENU_FOLDER TEXT("StartMenuFolder")
#define IPROPNAME_PROGRAMMENU_FOLDER TEXT("ProgramMenuFolder")
#define IPROPNAME_STARTUP_FOLDER   TEXT("StartupFolder")
#define IPROPNAME_NETHOOD_FOLDER   TEXT("NetHoodFolder")
#define IPROPNAME_PERSONAL_FOLDER  TEXT("PersonalFolder")
#define IPROPNAME_SENDTO_FOLDER    TEXT("SendToFolder")
#define IPROPNAME_DESKTOP_FOLDER   TEXT("DesktopFolder")
#define IPROPNAME_TEMPLATE_FOLDER  TEXT("TemplateFolder")
#define IPROPNAME_FONTS_FOLDER     TEXT("FontsFolder")
#define IPROPNAME_FAVORITES_FOLDER TEXT("FavoritesFolder")
#define IPROPNAME_RECENT_FOLDER    TEXT("RecentFolder")
#define IPROPNAME_APPDATA_FOLDER   TEXT("AppDataFolder")
#define IPROPNAME_PRINTHOOD_FOLDER TEXT("PrintHoodFolder")
#if (_WIN32_MSI >=  110)
#define IPROPNAME_ADMINTOOLS_FOLDER TEXT("AdminToolsFolder")
#define IPROPNAME_COMMONAPPDATA_FOLDER TEXT("CommonAppDataFolder")
#define IPROPNAME_LOCALAPPDATA_FOLDER TEXT("LocalAppDataFolder")
#define IPROPNAME_MYPICTURES_FOLDER TEXT("MyPicturesFolder")
#endif //(_WIN32_MSI >=  110)

// Feature/Component installation properties: set on command-line
#define IPROPNAME_FEATUREADDLOCAL  TEXT("ADDLOCAL")
#define IPROPNAME_FEATUREADDSOURCE TEXT("ADDSOURCE")
#define IPROPNAME_FEATUREADDDEFAULT TEXT("ADDDEFAULT")
#define IPROPNAME_FEATUREREMOVE    TEXT("REMOVE")
#define IPROPNAME_FEATUREADVERTISE TEXT("ADVERTISE")
#define IPROPVALUE_FEATURE_ALL  TEXT("ALL")

#define IPROPNAME_COMPONENTADDLOCAL  TEXT("COMPADDLOCAL")
#define IPROPNAME_COMPONENTADDSOURCE TEXT("COMPADDSOURCE")
#define IPROPNAME_COMPONENTADDDEFAULT TEXT("COMPADDDEFAULT")

#define IPROPNAME_FILEADDLOCAL     TEXT("FILEADDLOCAL")
#define IPROPNAME_FILEADDSOURCE    TEXT("FILEADDSOURCE")
#define IPROPNAME_FILEADDDEFAULT   TEXT("FILEADDDEFAULT")

#define IPROPNAME_REINSTALL        TEXT("REINSTALL")
#define IPROPNAME_REINSTALLMODE    TEXT("REINSTALLMODE")
#define IPROPNAME_PROMPTROLLBACKCOST  TEXT("PROMPTROLLBACKCOST")
#define IPROPVALUE_RBCOST_PROMPT      TEXT("P")
#define IPROPVALUE_RBCOST_SILENT      TEXT("D")
#define IPROPVALUE_RBCOST_FAIL        TEXT("F")

// Property for custom actions to communicate
#define IPROPNAME_CUSTOMACTIONDATA     TEXT("CustomActionData")

//__________________________________________________________________________
//
// TOP-LEVEL ACTION NAMES
//__________________________________________________________________________

#define IACTIONNAME_INSTALL        TEXT("INSTALL")
#define IACTIONNAME_ADVERTISE      TEXT("ADVERTISE")
#define IACTIONNAME_ADMIN          TEXT("ADMIN")
#define IACTIONNAME_SEQUENCE       TEXT("SEQUENCE")
#define IACTIONNAME_COLLECTUSERINFO TEXT("CollectUserInfo")
#define IACTIONNAME_FIRSTRUN       TEXT("FirstRun")

//__________________________________________________________________________
//
//  SummaryInformation property stream property IDs
//__________________________________________________________________________

#undef PID_SECURITY // defined as ( 0x80000002 ) in objidl.h, need to redefine here

// standard property definitions, from OLE2 documentation
#define PID_DICTIONARY  ( 0 )// integer count + array of entries
#define PID_CODEPAGE  ( 0x1 )// short integer
#define PID_TITLE         2  // string
#define PID_SUBJECT       3  // string
#define PID_AUTHOR        4  // string
#define PID_KEYWORDS      5  // string
#define PID_COMMENTS      6  // string
#define PID_TEMPLATE      7  // string
#define PID_LASTAUTHOR    8  // string
#define PID_REVNUMBER     9  // string
#define PID_EDITTIME     10  // datatime
#define PID_LASTPRINTED  11  // datetime
#define PID_CREATE_DTM   12  // datetime
#define PID_LASTSAVE_DTM 13  // datetime
#define PID_PAGECOUNT    14  // integer 
#define PID_WORDCOUNT    15  // integer 
#define PID_CHARCOUNT    16  // integer 
#define PID_THUMBNAIL    17  // clipboard format + metafile/bitmap (not supported)
#define PID_APPNAME      18  // string
#define PID_SECURITY     19  // integer

// PIDs given specific meanings for Installer
#define PID_MSIVERSION     PID_PAGECOUNT  // integer, Installer version number (major*100+minor)
#define PID_MSISOURCE      PID_WORDCOUNT  // integer, type of file image, short/long, media/tree
#define PID_MSIRESTRICT    PID_CHARCOUNT  // integer, transform restrictions

//__________________________________________________________________________
//
// INSTALLER DATABASE INTEGER COLUMN DEFINITIONS
//__________________________________________________________________________

// BBControl.Attributes
// Control.Attributes
enum msidbControlAttributes
{
	msidbControlAttributesVisible           = 0x00000001,
	msidbControlAttributesEnabled           = 0x00000002,
	msidbControlAttributesSunken            = 0x00000004,
	msidbControlAttributesIndirect          = 0x00000008,
	msidbControlAttributesInteger           = 0x00000010,
	msidbControlAttributesRTLRO             = 0x00000020,
	msidbControlAttributesRightAligned      = 0x00000040,
	msidbControlAttributesLeftScroll        = 0x00000080,
	msidbControlAttributesBiDi              = msidbControlAttributesRTLRO |
	                                          msidbControlAttributesRightAligned |
										               msidbControlAttributesLeftScroll,
	
	// Text controls
	msidbControlAttributesTransparent       = 0x00010000,
	msidbControlAttributesNoPrefix          = 0x00020000,
	msidbControlAttributesNoWrap            = 0x00040000,
	msidbControlAttributesFormatSize        = 0x00080000,
	msidbControlAttributesUsersLanguage     = 0x00100000,

	// Edit controls
	msidbControlAttributesMultiline         = 0x00010000,
#if (_WIN32_MSI >=  110)
	msidbControlAttributesPasswordInput     = 0x00200000,
#endif //(_WIN32_MSI >=  110)
	
	// ProgressBar controls
	msidbControlAttributesProgress95        = 0x00010000,
	
	// VolumeSelectCombo and DirectoryCombo controls
	msidbControlAttributesRemovableVolume   = 0x00010000,
	msidbControlAttributesFixedVolume       = 0x00020000,
	msidbControlAttributesRemoteVolume      = 0x00040000,
	msidbControlAttributesCDROMVolume       = 0x00080000,
	msidbControlAttributesRAMDiskVolume     = 0x00100000,
	msidbControlAttributesFloppyVolume      = 0x00200000,
	// VolumeCostList controls
	msidbControlShowRollbackCost            = 0x00400000,
	
	// ListBox and ComboBox controls
	msidbControlAttributesSorted            = 0x00010000,
	msidbControlAttributesComboList         = 0x00020000,
	
	// picture button controls
	msidbControlAttributesImageHandle       = 0x00010000,
	msidbControlAttributesPushLike          = 0x00020000,
	msidbControlAttributesBitmap            = 0x00040000,
	msidbControlAttributesIcon              = 0x00080000,
	msidbControlAttributesFixedSize         = 0x00100000,
	msidbControlAttributesIconSize16        = 0x00200000,
	msidbControlAttributesIconSize32        = 0x00400000,
	msidbControlAttributesIconSize48        = 0x00600000,
	
	// RadioButton controls
	msidbControlAttributesHasBorder         = 0x01000000,
};

// CompLocator.Type
// IniLocator.Type
// RegLocator.Type
typedef enum _msidbLocatorType
{
	msidbLocatorTypeDirectory = 0x00000000,
	msidbLocatorTypeFileName  = 0x00000001,
#if (_WIN32_MSI >=  110)
	msidbLocatorTypeRawValue  = 0x00000002,
#endif //(_WIN32_MSI >=  110)
#if (_WIN32_MSI >= 150)
	msidbLocatorType64bit     = 0x00000010,
#endif //(_WIN32_MSI >= 150)
} msidbLocatorType;

// Component.Attributes
enum msidbComponentAttributes
{
	msidbComponentAttributesLocalOnly          = 0x00000000,
	msidbComponentAttributesSourceOnly         = 0x00000001,
	msidbComponentAttributesOptional           = 0x00000002, // local or source
	msidbComponentAttributesRegistryKeyPath    = 0x00000004, // KeyPath is key to Registry table
	msidbComponentAttributesSharedDllRefCount  = 0x00000008, // increment SharedDll count
	msidbComponentAttributesPermanent          = 0x00000010, // never uninstall component
	msidbComponentAttributesODBCDataSource     = 0x00000020, // KeyFile is key to ODBCDataSource table
	msidbComponentAttributesTransitive         = 0x00000040, // Can transition to/from installed/uninstalled based on changing conditional
	msidbComponentAttributesNeverOverwrite     = 0x00000080, // dont stomp over existing component if key path exists (file/ regkey)
#if (_WIN32_MSI >= 150)
	msidbComponentAttributes64bit              = 0x00000100, // designates a 64-bit component; 32-bit if missing.
#endif // (_WIN32_MSI >= 150)
};

#if (_WIN32_MSI >= 150)
// Assembly.Attributes
enum msidbAssemblyAttributes
{
	msidbAssemblyAttributesURT   = 0x00000000,
	msidbAssemblyAttributesWin32 = 0x00000001,
};
#endif // (_WIN32_MSI >= 150)

// CustomAction.Type
enum msidbCustomActionType
{
	// executable types
	msidbCustomActionTypeDll              = 0x00000001,  // Target = entry point name
	msidbCustomActionTypeExe              = 0x00000002,  // Target = command line args
	msidbCustomActionTypeTextData         = 0x00000003,  // Target = text string to be formatted and set into property
	msidbCustomActionTypeJScript          = 0x00000005,  // Target = entry point name, null if none to call
	msidbCustomActionTypeVBScript         = 0x00000006,  // Target = entry point name, null if none to call
	msidbCustomActionTypeInstall          = 0x00000007,  // Target = property list for nested engine initialization

	// source of code
	msidbCustomActionTypeBinaryData       = 0x00000000,  // Source = Binary.Name, data stored in stream
	msidbCustomActionTypeSourceFile       = 0x00000010,  // Source = File.File, file part of installation
	msidbCustomActionTypeDirectory        = 0x00000020,  // Source = Directory.Directory, folder containing existing file
	msidbCustomActionTypeProperty         = 0x00000030,  // Source = Property.Property, full path to executable

	// return processing                  // default is syncronous execution, process return code
	msidbCustomActionTypeContinue         = 0x00000040,  // ignore action return status, continue running
	msidbCustomActionTypeAsync            = 0x00000080,  // run asynchronously
	
	// execution scheduling flags               // default is execute whenever sequenced
	msidbCustomActionTypeFirstSequence    = 0x00000100,  // skip if UI sequence already run
	msidbCustomActionTypeOncePerProcess   = 0x00000200,  // skip if UI sequence already run in same process
	msidbCustomActionTypeClientRepeat     = 0x00000300,  // run on client only if UI already run on client
	msidbCustomActionTypeInScript         = 0x00000400,  // queue for execution within script
	msidbCustomActionTypeRollback         = 0x00000100,  // in conjunction with InScript: queue in Rollback script
	msidbCustomActionTypeCommit           = 0x00000200,  // in conjunction with InScript: run Commit ops from script on success

	// security context flag, default to impersonate as user, valid only if InScript
	msidbCustomActionTypeNoImpersonate    = 0x00000800,  // no impersonation, run in system context

#if (_WIN32_MSI >= 150)
	// script requires 64bit process
	msidbCustomActionType64BitScript      = 0x00001000,  // script should run in 64bit process

	// don't record the contents of the Target field in the log file.
	msidbCustomActionTypeHideTarget       = 0x00002000,
#endif // (_WIN32_MSI >= 150)
};

// Dialog.Attributes
enum msidbDialogAttributes
{
	msidbDialogAttributesVisible          = 0x00000001,
	msidbDialogAttributesModal            = 0x00000002,
	msidbDialogAttributesMinimize         = 0x00000004,
	msidbDialogAttributesSysModal         = 0x00000008,
	msidbDialogAttributesKeepModeless     = 0x00000010,
	msidbDialogAttributesTrackDiskSpace   = 0x00000020,
	msidbDialogAttributesUseCustomPalette = 0x00000040,
	msidbDialogAttributesRTLRO            = 0x00000080,
	msidbDialogAttributesRightAligned     = 0x00000100,
	msidbDialogAttributesLeftScroll       = 0x00000200,
	msidbDialogAttributesBiDi             = msidbDialogAttributesRTLRO |
										             msidbDialogAttributesRightAligned |
										             msidbDialogAttributesLeftScroll,
	msidbDialogAttributesError            = 0x00010000,
};

// Feature.Attributes
enum msidbFeatureAttributes
{
	msidbFeatureAttributesFavorLocal            = 0x00000000,
	msidbFeatureAttributesFavorSource           = 0x00000001,
	msidbFeatureAttributesFollowParent          = 0x00000002,
	msidbFeatureAttributesFavorAdvertise        = 0x00000004,
	msidbFeatureAttributesDisallowAdvertise     = 0x00000008,
	msidbFeatureAttributesUIDisallowAbsent      = 0x00000010,
	msidbFeatureAttributesNoUnsupportedAdvertise= 0x00000020,
};

// File.Attributes
enum msidbFileAttributes
{
	msidbFileAttributesReadOnly       = 0x00000001,
	msidbFileAttributesHidden         = 0x00000002,
	msidbFileAttributesSystem         = 0x00000004,
	msidbFileAttributesReserved0      = 0x00000008, // Internal use only - must be 0
	msidbFileAttributesReserved1      = 0x00000040, // Internal use only - must be 0
	msidbFileAttributesReserved2      = 0x00000080, // Internal use only - must be 0
	msidbFileAttributesReserved3      = 0x00000100, // Internal use only - must be 0
	msidbFileAttributesVital          = 0x00000200,
	msidbFileAttributesChecksum       = 0x00000400,
	msidbFileAttributesPatchAdded     = 0x00001000, // Internal use only - set by patches
	msidbFileAttributesNoncompressed  = 0x00002000,
	msidbFileAttributesCompressed     = 0x00004000,
	msidbFileAttributesReserved4      = 0x00008000, // Internal use only - must be 0
};

// IniFile.Action
// RemoveIniFile.Action
typedef enum _msidbIniFileAction
{
	msidbIniFileActionAddLine    = 0x00000000,
	msidbIniFileActionCreateLine = 0x00000001,
	msidbIniFileActionRemoveLine = 0x00000002,
	msidbIniFileActionAddTag     = 0x00000003,
	msidbIniFileActionRemoveTag  = 0x00000004,
} msidbIniFileAction;

// MoveFile.Options
enum msidbMoveFileOptions
{
	msidbMoveFileOptionsMove = 0x00000001,
};

// ODBCDataSource.Registration
typedef enum _msidbODBCDataSourceRegistration
{
	msidbODBCDataSourceRegistrationPerMachine  = 0x00000000,
	msidbODBCDataSourceRegistrationPerUser     = 0x00000001,
} msidbODBCDataSourceRegistration;

#if (_WIN32_MSI >=  110)

// Class.Attributes
enum msidbClassAttributes
{
	msidbClassAttributesRelativePath  = 0x00000001,
};

#endif //(_WIN32_MSI >=  110)

// Patch.Attributes
enum msidbPatchAttributes
{
	msidbPatchAttributesNonVital = 0x00000001,
};

// Registry.Root
// RegLocator.Root
// RemoveRegistry.Root
enum msidbRegistryRoot
{
	msidbRegistryRootClassesRoot  = 0,
	msidbRegistryRootCurrentUser  = 1,
	msidbRegistryRootLocalMachine = 2,
	msidbRegistryRootUsers        = 3,
};

// RemoveFile.InstallMode
enum msidbRemoveFileInstallMode
{
	msidbRemoveFileInstallModeOnInstall = 0x00000001,
	msidbRemoveFileInstallModeOnRemove  = 0x00000002,
	msidbRemoveFileInstallModeOnBoth    = 0x00000003,
};

// ServiceControl.Event
enum msidbServiceControlEvent
{
	msidbServiceControlEventStart             = 0x00000001,
	msidbServiceControlEventStop              = 0x00000002,
	msidbServiceControlEventDelete            = 0x00000008,
	msidbServiceControlEventUninstallStart    = 0x00000010,
	msidbServiceControlEventUninstallStop     = 0x00000020,
	msidbServiceControlEventUninstallDelete   = 0x00000080,
};

// ServiceInstall.ErrorControl
enum msidbServiceInstallErrorControl
{
	msidbServiceInstallErrorControlVital = 0x00008000,
};

// TextStyle.StyleBits
enum msidbTextStyleStyleBits
{
	msidbTextStyleStyleBitsBold         = 0x00000001,
	msidbTextStyleStyleBitsItalic       = 0x00000002,
	msidbTextStyleStyleBitsUnderline    = 0x00000004,
	msidbTextStyleStyleBitsStrike       = 0x00000008,
};

#if (_WIN32_MSI >=  110)

// Upgrade.Attributes
enum msidbUpgradeAttributes
{
	msidbUpgradeAttributesMigrateFeatures     = 0x00000001,
	msidbUpgradeAttributesOnlyDetect          = 0x00000002,
	msidbUpgradeAttributesIgnoreRemoveFailure = 0x00000004,
	msidbUpgradeAttributesVersionMinInclusive = 0x00000100,
	msidbUpgradeAttributesVersionMaxInclusive = 0x00000200,
	msidbUpgradeAttributesLanguagesExclusive  = 0x00000400,
};

#endif //(_WIN32_MSI >=  110)


//__________________________________________________________________________
//
// SUMMARY INFORMATION PROPERTY DEFINITIONS
//__________________________________________________________________________

enum msidbSumInfoSourceType
{
	msidbSumInfoSourceTypeSFN            = 0x00000001,  // source uses short filenames
	msidbSumInfoSourceTypeCompressed     = 0x00000002,  // source is compressed
	msidbSumInfoSourceTypeAdminImage     = 0x00000004,  // source is an admin image
};

#endif // __MSIDEFS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\sample\sample.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       sample.cxx
//
//  Contents:   Sample DS object picker client.
//
//---------------------------------------------------------------------------

#define INC_OLE2
#include <windows.h>
#include <stdio.h>
#include <objsel.h>

#define BREAK_ON_FAIL_HRESULT(hr)       \
    if (FAILED(hr)) { printf("line %u err 0x%x\n", __LINE__, hr); break; }

#undef ASSERT
#define ASSERT(x) \
    if (!(x)) printf("line %u assert failed\n", __LINE__)


UINT g_cfDsObjectPicker = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);


//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForGroups
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick one or more groups.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//---------------------------------------------------------------------------

HRESULT
InitObjectPickerForGroups(
    IDsObjectPicker *pDsObjectPicker)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 5;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Target computer scope.  This adds a "Look In" entry for the
    // target computer.  Computer scopes are always treated as
    // downlevel (i.e., they use the WinNT provider).
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
    aScopeInit[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;

    //
    // The domain to which the target computer is joined.  Note we're
    // combining two scope types into flType here for convenience.
    //

    aScopeInit[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[1].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                          | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    aScopeInit[1].FilterFlags.Uplevel.flNativeModeOnly =
        DSOP_FILTER_GLOBAL_GROUPS_SE
      | DSOP_FILTER_UNIVERSAL_GROUPS_SE
      | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;
    aScopeInit[1].FilterFlags.Uplevel.flMixedModeOnly =
      DSOP_FILTER_GLOBAL_GROUPS_SE;
    aScopeInit[1].FilterFlags.flDownlevel =
      DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;

    //
    // The domains in the same forest (enterprise) as the domain to which
    // the target machine is joined.  Note these can only be DS-aware
    //

    aScopeInit[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[2].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    aScopeInit[2].FilterFlags.Uplevel.flNativeModeOnly =
       DSOP_FILTER_GLOBAL_GROUPS_SE
       | DSOP_FILTER_UNIVERSAL_GROUPS_SE;
    aScopeInit[2].FilterFlags.Uplevel.flMixedModeOnly =
      DSOP_FILTER_GLOBAL_GROUPS_SE;

    //
    // Domains external to the enterprise but trusted directly by the
    // domain to which the target machine is joined.
    //
    // If the target machine is joined to an NT4 domain, only the
    // external downlevel domain scope applies, and it will cause
    // all domains trusted by the joined domain to appear.
    //

    aScopeInit[3].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[3].flType =
       DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
       | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;

    aScopeInit[3].FilterFlags.Uplevel.flNativeModeOnly =
       DSOP_FILTER_GLOBAL_GROUPS_SE
       | DSOP_FILTER_UNIVERSAL_GROUPS_SE;

    aScopeInit[3].FilterFlags.Uplevel.flMixedModeOnly =
       DSOP_FILTER_GLOBAL_GROUPS_SE;

    aScopeInit[3].FilterFlags.flDownlevel =
       DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;

    //
    // The Global Catalog
    //

    aScopeInit[4].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[4].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;
    aScopeInit[4].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;

    // Only native mode applies to gc scope.

    aScopeInit[4].FilterFlags.Uplevel.flNativeModeOnly =
         DSOP_FILTER_GLOBAL_GROUPS_SE
      | DSOP_FILTER_UNIVERSAL_GROUPS_SE
      | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);

    //
    // The pwzTargetComputer member allows the object picker to be
    // retargetted to a different computer.  It will behave as if it
    // were being run ON THAT COMPUTER.
    //

    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;
    InitInfo.flOptions = DSOP_FLAG_MULTISELECT;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    HRESULT hr = pDsObjectPicker->Initialize(&InitInfo);

    if (FAILED(hr))
    {
        ULONG i;

        for (i = 0; i < SCOPE_INIT_COUNT; i++)
        {
            if (FAILED(InitInfo.aDsScopeInfos[i].hr))
            {
                printf("Initialization failed because of scope %u\n", i);
            }
        }
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   InitObjectPickerForComputers
//
//  Synopsis:   Call IDsObjectPicker::Initialize with arguments that will
//              set it to allow the user to pick a single computer object.
//
//  Arguments:  [pDsObjectPicker] - object picker interface instance
//
//  Returns:    Result of calling IDsObjectPicker::Initialize.
//
//---------------------------------------------------------------------------

HRESULT
InitObjectPickerForComputers(
    IDsObjectPicker *pDsObjectPicker)
{
    //
    // Prepare to initialize the object picker.
    // Set up the array of scope initializer structures.
    //

    static const int     SCOPE_INIT_COUNT = 1;
    DSOP_SCOPE_INIT_INFO aScopeInit[SCOPE_INIT_COUNT];

    ZeroMemory(aScopeInit, sizeof(DSOP_SCOPE_INIT_INFO) * SCOPE_INIT_COUNT);

    //
    // Since we just want computer objects from every scope, combine them
    // all in a single scope initializer.
    //

    aScopeInit[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopeInit[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                           | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN
                           | DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                           | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                           | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                           | DSOP_SCOPE_TYPE_WORKGROUP
                           | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                           | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
    aScopeInit[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_COMPUTERS;
    aScopeInit[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    //
    // Put the scope init array into the object picker init array
    //

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.pwzTargetComputer = NULL;  // NULL == local machine
    InitInfo.cDsScopeInfos = SCOPE_INIT_COUNT;
    InitInfo.aDsScopeInfos = aScopeInit;

    //
    // Note object picker makes its own copy of InitInfo.  Also note
    // that Initialize may be called multiple times, last call wins.
    //

    return pDsObjectPicker->Initialize(&InitInfo);
}




//+--------------------------------------------------------------------------
//
//  Function:   ProcessSelectedObjects
//
//  Synopsis:   Retrieve the list of selected items from the data object
//              created by the object picker and print out each one.
//
//  Arguments:  [pdo] - data object returned by object picker
//
//---------------------------------------------------------------------------

void
ProcessSelectedObjects(
    IDataObject *pdo)
{
    HRESULT hr = S_OK;

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    FORMATETC formatetc =
    {
        g_cfDsObjectPicker,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    bool fGotStgMedium = false;

    do
    {
        hr = pdo->GetData(&formatetc, &stgmedium);
        BREAK_ON_FAIL_HRESULT(hr);

        fGotStgMedium = true;

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        if (!pDsSelList)
        {
            printf("GlobalLock error %u\n", GetLastError());
            break;
        }

        ULONG i;

        for (i = 0; i < pDsSelList->cItems; i++)
        {
            printf("Object %u'\n", i);
            printf("  Name '%ws'\n", pDsSelList->aDsSelection[i].pwzName);
            printf("  Class '%ws'\n", pDsSelList->aDsSelection[i].pwzClass);
            printf("  Path '%ws'\n", pDsSelList->aDsSelection[i].pwzADsPath);
            printf("  UPN '%ws'\n", pDsSelList->aDsSelection[i].pwzUPN);
        }

        GlobalUnlock(stgmedium.hGlobal);
    } while (0);

    if (fGotStgMedium)
    {
        ReleaseStgMedium(&stgmedium);
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   Demonstrate use of DS object picker.
//
//---------------------------------------------------------------------------

void _cdecl
main(int argc, char * argv[])
{
    HRESULT hr = S_OK;
    IDsObjectPicker *pDsObjectPicker = NULL;
    IDataObject *pdo = NULL;

    hr = CoInitialize(NULL);
    if (FAILED(hr)) return;

    do
    {
        //
        // Create an instance of the object picker.
        //

        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = InitObjectPickerForGroups(pDsObjectPicker);

        //
        // Invoke the modal dialog.
        //

        HWND hwndParent = NULL; // supply a window handle to your app

        hr = pDsObjectPicker->InvokeDialog(hwndParent, &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // If the user hit Cancel, hr == S_FALSE
        //

        if (hr == S_FALSE)
        {
            printf("User canceled object picker dialog\n");
            break;
        }

        //
        // Process the user's selections
        //

        ASSERT(pdo);
        ProcessSelectedObjects(pdo);

        pdo->Release();
        pdo = NULL;

        //
        // Reinitialize the object picker to choose computers
        //

        hr = InitObjectPickerForComputers(pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Now pick a computer
        //

        hr = pDsObjectPicker->InvokeDialog(hwndParent, &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(pdo);
        ProcessSelectedObjects(pdo);

        pdo->Release();
        pdo = NULL;
    } while (0);

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }
    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\admincustomizer.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       AdminCustomizer.cxx
//
//  Contents:   Implementation of class to provide default customization
//              of queries by adding objects and offering prefix searching
//              of those objects.
//
//  Classes:    CAdminCustomizer
//
//  History:    03-10-2000   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::CAdminCustomizer
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - containing object picker instance
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CAdminCustomizer::CAdminCustomizer(
    const CObjectPicker &rop):
        m_rop(rop)
{
    TRACE_CONSTRUCTOR(CAdminCustomizer);

    ZeroMemory(m_aSidInfo, sizeof m_aSidInfo);

    SID_IDENTIFIER_AUTHORITY siiWorld   = SECURITY_WORLD_SID_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siiNT      = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY siiCreator = SECURITY_CREATOR_SID_AUTHORITY;

    m_aSidInfo[0].sii = siiWorld;
    m_aSidInfo[0].rid = SECURITY_WORLD_RID;

    m_aSidInfo[1].sii = siiNT;
    m_aSidInfo[1].rid = SECURITY_AUTHENTICATED_USER_RID;

    m_aSidInfo[2].sii = siiNT;
    m_aSidInfo[2].rid = SECURITY_ANONYMOUS_LOGON_RID;

    m_aSidInfo[3].sii = siiNT;
    m_aSidInfo[3].rid = SECURITY_BATCH_RID;

    m_aSidInfo[4].sii = siiCreator;
    m_aSidInfo[4].rid = SECURITY_CREATOR_OWNER_RID;

    m_aSidInfo[5].sii = siiCreator;
    m_aSidInfo[5].rid = SECURITY_CREATOR_GROUP_RID;

    m_aSidInfo[6].sii = siiNT;
    m_aSidInfo[6].rid = SECURITY_DIALUP_RID;

    m_aSidInfo[7].sii = siiNT;
    m_aSidInfo[7].rid = SECURITY_INTERACTIVE_RID;

    m_aSidInfo[8].sii = siiNT;
    m_aSidInfo[8].rid = SECURITY_NETWORK_RID;

    m_aSidInfo[9].sii = siiNT;
    m_aSidInfo[9].rid = SECURITY_SERVICE_RID;

    m_aSidInfo[10].sii = siiNT;
    m_aSidInfo[10].rid = SECURITY_LOCAL_SYSTEM_RID;

    m_aSidInfo[11].sii = siiNT;
    m_aSidInfo[11].rid = SECURITY_TERMINAL_SERVER_RID;

    m_aSidInfo[12].sii = siiNT;
    m_aSidInfo[12].rid = SECURITY_LOCAL_SERVICE_RID;

    m_aSidInfo[13].sii = siiNT;
    m_aSidInfo[13].rid = SECURITY_NETWORK_SERVICE_RID;

    m_aSidInfo[14].sii = siiNT;
    m_aSidInfo[14].rid = SECURITY_REMOTE_LOGON_RID;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::~CAdminCustomizer
//
//  Synopsis:   dtor
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CAdminCustomizer::~CAdminCustomizer()
{
    TRACE_DESTRUCTOR(CAdminCustomizer);

    for (ULONG i = 0; i < ARRAYLEN(m_aSidInfo); i++)
    {
        if (m_aSidInfo[i].psid)
        {
            FreeSid(m_aSidInfo[i].psid);
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Interface:  ICustomizeDsBrowser
//
//  Member:     CAdminCustomizer::AddObjects
//
//  Synopsis:   Adds whatever custom objects caller asked for via flags
//              such as DSOP_FILTER_WELL_KNOWN_PRINCIPALS or
//              DSOP_DOWNLEVEL_FILTER_CREATOR_OWNER.
//
//  Arguments:  [hwnd]         - for bind
//              [ForScope]     - current scope
//              [pdsolMatches] - filled with objects to add
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::AddObjects(
    HWND hwnd,
    const CScope &ForScope,
    CDsObjectList *pdsolMatches) const
{
    if (IsUplevel(ForScope))
    {
        _GetUplevelAddition(hwnd, ForScope.GetID(), pdsolMatches);
    }
    else
    {
        _GetDownlevelAddition(pdsolMatches);
    }
}

#define ADD_IF_MATCHES(x)      _AddDownlevelIfMatches(idOwningScope,\
                                                      (x),          \
                                                      flFilter,     \
                                                      strName,      \
                                                      pdsol)


//+--------------------------------------------------------------------------
//
//  Interface:  ICustomizeDsBrowser
//
//  Member:     CAdminCustomizer::LookupDownlevelName
//
//  Synopsis:   Return the SID of downlevel object with name [strName]
//
//  Arguments:  [strName] - name of object to look for
//
//  Returns:    SID or NULL if name not found
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

PSID
CAdminCustomizer::LookupDownlevelName(
    const String &strName) const
{
    ULONG i;

    for (i = 0; i < NUM_SID_INFOS; i++)
    {
        if (!strName.icompare(m_aSidInfo[i].wzAccountName))
        {
            return m_aSidInfo[i].psid;
        }
    }

    return NULL;
}




//+--------------------------------------------------------------------------
//
//  Interface:  ICustomizeDsBrowser
//
//  Member:     CAdminCustomizer::LookupDownlevelPath
//
//  Synopsis:   Return the ADsPath of downlevel object with name
//              [pwzAccountName].
//
//  Arguments:  [pwzAccountName] - name of object to search for
//
//  Returns:    Path of object, or NULL if name not found
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

PCWSTR
CAdminCustomizer::LookupDownlevelPath(
    PCWSTR pwzAccountName) const
{
    TRACE_METHOD(CCustomizeDsBrowser, LookupDownlevelName);

    ULONG i;

    for (i = 0; i < NUM_SID_INFOS; i++)
    {
        if (!lstrcmpi(pwzAccountName, m_aSidInfo[i].wzAccountName))
        {
            return m_aSidInfo[i].wzPath;
        }
    }

    return NULL;
}



//+--------------------------------------------------------------------------
//
//  Interface:  ICustomizeDsBrowser
//
//  Member:     CAdminCustomizer::PrefixSearch
//
//  Synopsis:   Add to [pdsol] all objects that would belong in scope
//              [ForScope] which have names starting with [strName].
//
//  Arguments:  [hwnd]     - for bind
//              [ForScope] - scope in which added objects should live
//              [strName]  - start of name of objects to find
//              [pdsol]    - list to which objects are added
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::PrefixSearch(
    HWND hwnd,
    const CScope &ForScope,
    const String &strName,
    CDsObjectList *pdsol) const
{
    TRACE_METHOD(CAdminCustomizer, PrefixSearch);

    //
    // Add matching objects for downlevel scopes
    //

    ULONG flFilter;
    HRESULT hr = m_rop.GetFilterManager().GetSelectedFilterFlags(hwnd,
                                                                 ForScope,
                                                                 &flFilter);
    RETURN_ON_FAIL_HRESULT(hr);

    if (IsDownlevel(ForScope))
    {
        //
        // Add NT4 well known sids matching prefix
        //

        if (flFilter)
        {
            ULONG idOwningScope = ForScope.GetID();

            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_WORLD             );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER);
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_ANONYMOUS         );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_BATCH             );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_CREATOR_OWNER     );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_CREATOR_GROUP     );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_DIALUP            );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_INTERACTIVE       );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_NETWORK           );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_SERVICE           );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_SYSTEM            );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_TERMINAL_SERVER   );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_LOCAL_SERVICE     );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_NETWORK_SERVICE   );
            ADD_IF_MATCHES(DSOP_DOWNLEVEL_FILTER_REMOTE_LOGON      );
        }
    }

    //
    // Add matching objects for uplevel scopes
    //

    if (IsUplevel(ForScope))
    {
        //
        // Add matching items from builtin container
        //

        if (flFilter & DSOP_FILTER_BUILTIN_GROUPS)
        {
            const CAdsiScope *pAdsiScope =
                dynamic_cast<const CAdsiScope *>(&ForScope);

            if (pAdsiScope)
            {
                String strScopeADsPath;
                HRESULT hr = pAdsiScope->GetADsPath(hwnd,
                                                    &strScopeADsPath);

                if (SUCCEEDED(hr))
                {
                    _AddBuiltins(hwnd,
                                 pAdsiScope->GetID(),
                                 strScopeADsPath,
                                 strName,
                                 pdsol);
                }
            }
        }

        //
        // Add matching items from well-known principals container
        //

        if (flFilter & DSOP_FILTER_WELL_KNOWN_PRINCIPALS)
        {
            _AddWellKnownPrincipals(hwnd, ForScope.GetID(), strName, pdsol);
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_AddWellKnownPrincipals
//
//  Synopsis:   Add the contents of the Well Known Security Principals
//              container to [pDsSelList].
//
//  Arguments:  [pDsScope]   - scope for which to add well known principals
//                              from well known security principals
//                              container.
//              [pDsSelList] - selection list to which contents of container
//                              should be added.
//
//  History:    02-24-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::_AddWellKnownPrincipals(
    HWND hwnd,
    ULONG idOwningScope,
    const String &strSearchFor,
    CDsObjectList *pdsol) const
{
    TRACE_METHOD(CAdminCustomizer, _AddWellKnownPrincipals);

    if (m_dsolWKSP.empty())
    {
        _InitWellKnownPrincipalsList(hwnd, idOwningScope);
    }

    if (!m_dsolWKSP.empty())
    {
        _AddFromList(strSearchFor, &m_dsolWKSP, pdsol);
        ASSERT(!m_dsolWKSP.empty());
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_InitWellKnownPrincipalsList
//
//  Synopsis:   Fill the cached list of objects appearing in the "Well-Known
//              security principals" container.
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::_InitWellKnownPrincipalsList(
    HWND hwnd,
    ULONG idOwningScope) const
{
    TRACE_METHOD(CAdminCustomizer, _InitWellKnownPrincipalsList);

    HRESULT                 hr = S_OK;
    IADsContainer          *pADsContainer = NULL;
    IEnumVARIANT           *pEnumVariant = NULL;
    VARIANT                 var;
    VARIANT                 varFilter;
    ULONG                   cFetched;
    NTSTATUS                nts;
    LSA_HANDLE              hLsa = NULL;
    LSA_OBJECT_ATTRIBUTES   ObjectAttributes;
    PCWSTR                  apwzFilter[1] = { c_wzForeignPrincipalsClass };

    VariantInit(&var);
    VariantInit(&varFilter);

    do
    {
        //
        // Need an lsa policy handle to do sid name lookup.  Failing to
        // obtain one is a nonfatal error, since it just means the names
        // of the well-known security principals will not appear in
        // localized form.
        //

        ZeroMemory(&ObjectAttributes, sizeof ObjectAttributes);

        ObjectAttributes.Length = sizeof ObjectAttributes;

        nts = LsaOpenPolicy(NULL,
                            &ObjectAttributes,
                            POLICY_EXECUTE,
                            &hLsa);

        if (NT_ERROR(nts))
        {
            DBG_OUT_HRESULT(nts);
            ASSERT(!hLsa);
        }

        const CRootDSE &RootDSE = m_rop.GetRootDSE();
        hr = RootDSE.BindToWellKnownPrincipalsContainer(hwnd,
                                                        IID_IADsContainer,
                                                        (void**)&pADsContainer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = ADsBuildVarArrayStr((PWSTR*)apwzFilter, 1, &varFilter);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pADsContainer->put_Filter(varFilter);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = ADsBuildEnumerator(pADsContainer, &pEnumVariant);
        BREAK_ON_FAIL_HRESULT(hr);

        while (1)
        {
            IADs *pADs = NULL;

            hr = ADsEnumerateNext(pEnumVariant, 1, &var, &cFetched);
            BREAK_ON_FAIL_HRESULT(hr);

            if (!cFetched)
            {
                break;
            }

            if (var.vt != VT_DISPATCH)
            {
                hr = S_FALSE;
                Dbg(DEB_ERROR,
                    "_AddWellKnownPrincipals: unexpected vt %uL\n",
                    var.vt);
                break;
            }

            hr = var.pdispVal->QueryInterface(IID_IADs, (void**)&pADs);
            BREAK_ON_FAIL_HRESULT(hr);

            VariantClear(&var);

            if (hLsa)
            {
                hr = pADs->Get((PWSTR)c_wzObjectSidAttr, &var);

                if (SUCCEEDED(hr))
                {
                    _AddLocalizedWKSP(idOwningScope, hLsa, pADs, &var);
                    VariantClear(&var);
                }
                else
                {
                    DBG_OUT_HRESULT(hr);
                }
            }
            else
            {
                m_dsolWKSP.push_back(CDsObject(idOwningScope, pADs));
            }

            pADs->Release();
            pADs = NULL;
        }

    } while (0);

    if (hLsa)
    {
        LsaClose(hLsa);
    }

    SAFE_RELEASE(pADsContainer);
    ADsFreeEnumerator(pEnumVariant);
    VariantClear(&var);
    VariantClear(&varFilter);
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_AddLocalizedWKSP
//
//  Synopsis:   Look up the localized name of the sid [pvarSid] and add
//              the object [pADs] to m_dsolWKSP.
//
//  Arguments:  [hLsa]           - lsa policy handle
//              [pADs]           - object to add
//              [pvarSid]        - objectSid of object to add
//
//  History:    11-13-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::_AddLocalizedWKSP(
    ULONG idOwningScope,
    LSA_HANDLE hLsa,
    IADs *pADs,
    VARIANT *pvarSid) const
{
    VOID   *pvData = NULL;
    PLSA_TRANSLATED_NAME    pTranslatedName = NULL;
    PLSA_REFERENCED_DOMAIN_LIST pReferencedDomains = NULL;
    HRESULT hr;
    NTSTATUS nts;
    BOOL fAccessed = FALSE;
    BOOL fAdded = FALSE;

    do
    {
        hr = SafeArrayAccessData(V_ARRAY(pvarSid), &pvData);
        BREAK_ON_FAIL_HRESULT(hr);

        fAccessed = TRUE;

        PSID psid = (PSID) pvData;

        ASSERT(IsValidSid(psid));

        nts = LsaLookupSids(hLsa,
                            1,
                            &psid,
                            &pReferencedDomains,
                            &pTranslatedName);
        BREAK_ON_FAIL_NTSTATUS(nts);

        if (pTranslatedName->Use == SidTypeInvalid ||
            pTranslatedName->Use == SidTypeUnknown)
        {
            Dbg(DEB_ERROR,
                "pTranslatedName->Use == %uL\n",
                pTranslatedName->Use);
            break;
        }

        WCHAR wzLocalizedName[MAX_PATH];

        UnicodeStringToWsz(pTranslatedName->Name,
                           wzLocalizedName,
                           ARRAYLEN(wzLocalizedName));

        PCWSTR pwzName;
        Bstr bstrName;
        Bstr bstrClass;
        Bstr bstrPath;

        hr = pADs->get_Name(&bstrName);
        BREAK_ON_FAIL_HRESULT(hr);

        PWSTR pwzEqual = wcschr(bstrName.c_str(), L'=');

        if (pwzEqual)
        {
            pwzName = pwzEqual + 1;
        }
        else
        {
            pwzName = bstrName.c_str();
        }

        hr = pADs->get_Class(&bstrClass);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pADs->get_ADsPath(&bstrPath);
        BREAK_ON_FAIL_HRESULT(hr);

        SDsObjectInit Init;

        Init.pwzName = pwzName;
        Init.pwzLocalizedName = wzLocalizedName;
        Init.pwzClass = bstrClass.c_str();
        Init.pwzADsPath = bstrPath.c_str();
        Init.fDisabled = IsDisabled(pADs);
        Init.idOwningScope = idOwningScope;

        m_dsolWKSP.push_back(CDsObject(Init));
        fAdded = TRUE;

    } while (0);

    //
    // On failure, just add the unlocalized version.
    //

    if (!fAdded)
    {
        m_dsolWKSP.push_back(CDsObject(idOwningScope, pADs));
    }

    if (fAccessed)
    {
        SafeArrayUnaccessData(V_ARRAY(pvarSid));
    }

    if (pTranslatedName)
    {
        LsaFreeMemory((PVOID)pTranslatedName);
    }

    if (pReferencedDomains)
    {
        LsaFreeMemory((PVOID)pReferencedDomains);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_AddDownlevelIfMatches
//
//  Synopsis:   Add the NT4 well-known SID object represented by
//              [flCurObject] to [pdsol] if it is one of the bits set
//              in [flObjectsToCompare] AND its name starts with the string
//              in [pwzSearchFor].
//
//  Arguments:  [flCurObject]        - exactly one of UGOP_USER_* bits
//              [flObjectsToCompare] - bitmask of UGOP_USER_* bits
//              [pwzSearchFor]       - string for prefix match
//              [pdsol]              - list to which to add items
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::_AddDownlevelIfMatches(
    ULONG idOwningScope,
    ULONG flCurObject,
    ULONG flObjectsToCompare,
    const String &strSearchFor,
    CDsObjectList *pdsol) const
{
    if ((flObjectsToCompare & flCurObject) == flCurObject)
    {
        String strCurName = _GetAccountName(flCurObject);
        PWSTR pwzMatch = wcsistr(strCurName.c_str(), strSearchFor.c_str());

        if (pwzMatch == strCurName.c_str())
        {
            pdsol->push_back(CDsObject(idOwningScope, strCurName, c_wzGlobalGroupClass));
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_GetUplevelAddition
//
//  Synopsis:   Find the builtin and well-known security principals and
//              create a list in [pdsol] to contain them.
//
//  Arguments:  [pdsol]    - list to which to add items
//
//  Modifies:   *[pdsol]
//
//  History:    02-16-1998   DavidMun   Created
//              03-10-2000   davidmun   convert from old code
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::_GetUplevelAddition(
    HWND hwnd,
    ULONG idOwningScope,
    CDsObjectList *pdsol) const
{
    TRACE_METHOD(CAdminCustomizer, _GetUplevelAddition);

    //
    // GC & NT5 Domain scope - enumerate from
    //
    // LDAP://CN=WellKnown Security Principals, CN=Configuration,
    //  DC=<domain>... and
    // LDAP://CN=Builtin,DC=<domain>....
    //

    const CFilterManager &rfm = m_rop.GetFilterManager();
    const CScopeManager &rsm = m_rop.GetScopeManager();
    ULONG flObjectsToAdd = rfm.GetCurScopeSelectedFilterFlags();

    //
    // If the scope for which to add custom objects is the Global Catalog,
    // and it doesn't already include the builtin and WKSP objects, we
    // should add them if there is a joined domain scope and that scope
    // wants them, since the joined domain query is integrated with the GC's.
    //

    if (rsm.GetCurScope().Type() == DSOP_SCOPE_TYPE_GLOBAL_CATALOG)
    {
        const CScope &rJoinedDomainScope = rsm.LookupScopeByType(
                                            ST_UPLEVEL_JOINED_DOMAIN);

        if (!IsInvalid(rJoinedDomainScope))
        {
            ULONG flJoined;
            HRESULT hr = rfm.GetSelectedFilterFlags(hwnd,
                                                    rJoinedDomainScope,
                                                    &flJoined);
            RETURN_ON_FAIL_HRESULT(hr);


            if (flJoined & DSOP_FILTER_WELL_KNOWN_PRINCIPALS)
            {
                flObjectsToAdd |= DSOP_FILTER_WELL_KNOWN_PRINCIPALS;
            }

            if (!(flObjectsToAdd & DSOP_FILTER_BUILTIN_GROUPS) &&
                (flJoined & DSOP_FILTER_BUILTIN_GROUPS))
            {
                const CAdsiScope *padsiJoinedDomainScope =
                    dynamic_cast<const CAdsiScope*>(&rJoinedDomainScope);
                ASSERT(padsiJoinedDomainScope);

                if (padsiJoinedDomainScope)
                {
                    String strADsPath;
                    HRESULT hr;
                    hr = padsiJoinedDomainScope->GetADsPath(hwnd, &strADsPath);

                    if (SUCCEEDED(hr))
                    {
                        _AddBuiltins(hwnd,
                                     idOwningScope,
                                     strADsPath,
                                     L"",
                                     pdsol);
                    }
                }
            }
        }
    }

    do
    {
        //
        // If caller doesn't want contents of builtin or well known
        // principals containers, there's nothing to add.
        //

        if (!(flObjectsToAdd &
             (DSOP_FILTER_BUILTIN_GROUPS | DSOP_FILTER_WELL_KNOWN_PRINCIPALS)))
        {
            break;
        }

        if (flObjectsToAdd & DSOP_FILTER_BUILTIN_GROUPS)
        {
            const CAdsiScope *padsiCurScope =
                dynamic_cast<const CAdsiScope*>(&rsm.GetCurScope());
            ASSERT(padsiCurScope);

            if (padsiCurScope)
            {
                String strADsPath;
                HRESULT hr = padsiCurScope->GetADsPath(hwnd, &strADsPath);

                if (SUCCEEDED(hr))
                {
                    _AddBuiltins(hwnd,
                                 idOwningScope,
                                 strADsPath,
                                 L"",
                                 pdsol);
                }
            }
        }

        if (flObjectsToAdd & DSOP_FILTER_WELL_KNOWN_PRINCIPALS)
        {
            _AddWellKnownPrincipals(hwnd, idOwningScope, L"", pdsol);
        }
    } while (0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_AddBuiltins
//
//  Synopsis:   Add the contents of the Builtin container to [pdsol].
//
//  Arguments:  [pDsScope]     - scope for which to add builtin objects
//              [pwzSearchFor] - NULL or prefix string to match against
//              [pdsol]        - list to which to add objects
//
//  History:    02-24-1998   DavidMun   Created
//
//  Notes:      If [pwzSearchFor] is non-NULL, only builtin objects whose
//              names start with a string matching [pwzSearchFor] will be
//              added.
//
//              Don't pop up errors here since failure isn't necessarily
//              fatal; it just means some objects won't appear that should.
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::_AddBuiltins(
    HWND hwnd,
    ULONG idOwningScope,
    const String &strScopePath,
    const String &strSearchFor,
    CDsObjectList *pdsol) const
{
    TRACE_METHOD(CAdminCustomizer, _AddBuiltins);

    //
    // Search for an entry in the map for this scope's path
    //

    CStringDsObjectListMap::iterator itmap;

    itmap = m_dsomapBuiltins.find(strScopePath);

    if (itmap == m_dsomapBuiltins.end())
    {
        CDsObjectList dsolBuiltins;

        //
        // Not found.  Add a new entry.
        //

        _InitBuiltinsList(hwnd, idOwningScope, strScopePath, &dsolBuiltins);
        CStringDsObjectListMap::value_type v(strScopePath, dsolBuiltins);
        itmap = m_dsomapBuiltins.insert(m_dsomapBuiltins.begin(), v);
    }

    ASSERT(itmap != m_dsomapBuiltins.end());

    _AddFromList(strSearchFor, &itmap->second, pdsol);
}




#define BUILTIN_SEARCH_PAGE_SIZE    100


//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_InitBuiltinsList
//
//  Synopsis:   Fill [pdsol] with the list of Builtin type security enabled
//              domain local groups.
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::_InitBuiltinsList(
    HWND hwnd,
    ULONG idOwningScope,
    const String &strScopePath,
    CDsObjectList *pdsol) const
{
    TRACE_METHOD(CAdminCustomizer, _InitBuiltinsList);

    HRESULT hr = S_OK;

    do
    {
        //
        // Get the dir search interface.  If it isn't available, bail since
        // we won't be able to get any objects to add.
        //

        RpIDirectorySearch rpDirSearch;

        hr = g_pBinder->BindToObject(hwnd,
                                     strScopePath.c_str(),
                                     IID_IDirectorySearch,
                                     (void**)&rpDirSearch);
        BREAK_ON_FAIL_HRESULT(hr);

        ADS_SEARCHPREF_INFO aSearchPrefs[4];

        aSearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
        aSearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
        aSearchPrefs[0].vValue.Integer = BUILTIN_SEARCH_PAGE_SIZE;

        aSearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_DEREF_ALIASES;
        aSearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
        aSearchPrefs[1].vValue.Integer = ADS_DEREF_NEVER;

        aSearchPrefs[2].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
        aSearchPrefs[2].vValue.dwType = ADSTYPE_INTEGER;
        aSearchPrefs[2].vValue.Integer = ADS_SCOPE_SUBTREE;

        aSearchPrefs[3].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
        aSearchPrefs[3].vValue.dwType = ADSTYPE_BOOLEAN;
        aSearchPrefs[3].vValue.Integer = FALSE;

        hr = rpDirSearch->SetSearchPreference(aSearchPrefs,
                                              ARRAYLEN(aSearchPrefs));
        BREAK_ON_FAIL_HRESULT(hr);

        AttrKeyVector vAttrToRead;

        vAttrToRead.push_back(AK_NAME);
        vAttrToRead.push_back(AK_OBJECT_CLASS);
        vAttrToRead.push_back(AK_ADSPATH);
        vAttrToRead.push_back(AK_USER_ACCT_CTRL);
        vAttrToRead.push_back(AK_USER_PRINCIPAL_NAME);

        CRow Row(hwnd,
                 m_rop,
                 rpDirSearch.get(),
                 c_wzBuiltinGroupFilter,
                 vAttrToRead);

#if (DBG == 1)
        ULONG cRows = 0;
#endif // (DBG == 1)

        while (1)
        {
            hr = Row.Next();

            if (hr == S_ADS_NOMORE_ROWS)
            {
#if (DBG == 1)
                Dbg(DEB_TRACE,
                    "S_ADS_NOMORE_ROWS (got %u) for builtin query\n",
                    cRows);
#endif // (DBG == 1)
                ULONG ulADsLastError;
                WCHAR wzError[MAX_PATH];
                WCHAR wzProvider[MAX_PATH];

                HRESULT hr2 = ADsGetLastError(&ulADsLastError,
                                              wzError,
                                              ARRAYLEN(wzError),
                                              wzProvider,
                                              ARRAYLEN(wzProvider));

                if (SUCCEEDED(hr2) && ulADsLastError == ERROR_MORE_DATA)
                {
                    Dbg(DEB_TRACE, "Got ERROR_MORE_DATA, trying again\n");
                    continue;
                }
                break;
            }

            if (FAILED(hr))
            {
                DBG_OUT_HRESULT(hr);
                break;
            }

            SDsObjectInit Init;

            Init.pwzName = Row.GetColumnStr(AK_NAME);
            Init.pwzClass = Row.GetColumnStr(AK_OBJECT_CLASS);
            Init.pwzADsPath = Row.GetColumnStr(AK_ADSPATH);

            if (!Init.pwzClass || !Init.pwzName || !Init.pwzADsPath)
            {
                Dbg(DEB_WARN,
                    "Skipping item missing class ('%ws'), name ('%ws'), or path ('%ws')\n",
                    Init.pwzClass ? Init.pwzClass : L"",
                    Init.pwzName ? Init.pwzName : L"",
                    Init.pwzADsPath ? Init.pwzADsPath : L"");
                continue;
            }

            Init.idOwningScope = idOwningScope;
            Init.pwzUpn = Row.GetColumnStr(AK_USER_PRINCIPAL_NAME);
            Init.fDisabled = (Row.GetColumnInt(AK_USER_ACCT_CTRL) & UF_ACCOUNTDISABLE);

            CDsObject dsoNew(Init);

            pdsol->push_back(dsoNew);

#if (DBG == 1)
            cRows++;
#endif // (DBG == 1)
        }
    } while (0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_AddFromList
//
//  Synopsis:   Add all objects in [pdsolIn] which have name starting with
//              [strSearchFor] (or all objects if [strSearchFor] is empty)
//              to [pdsolOut].
//
//  Arguments:  [strSearchFor] - empty string or prefix to match
//              [pdsolIn]      - source list
//              [pdsolOut]     - destination list
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::_AddFromList(
    const String &strSearchFor,
    const CDsObjectList *pdsolIn,
    CDsObjectList *pdsolOut) const
{
    //
    // If no prefix search is required, add all input list objects
    // to output list.  Note splice removes everything from the source
    // list, hence we make a copy of pdsolIn in a temporary variable.
    //

    if (strSearchFor.empty())
    {
        CDsObjectList   dsolTemp(*pdsolIn);

        pdsolOut->splice(pdsolOut->end(), dsolTemp);
        return;
    }

    //
    // Add only those objects having names that start with
    // pwzSearchFor.
    //

    CDsObjectList::const_iterator itdso;

    for (itdso = pdsolIn->begin();
         itdso != pdsolIn->end();
         itdso++)
    {
        PCWSTR pwzVisibleName = itdso->GetLocalizedName();

        if (!*pwzVisibleName)
        {
            pwzVisibleName = itdso->GetName();
        }

        if (wcsistr(pwzVisibleName, strSearchFor.c_str()) == pwzVisibleName)
        {
            pdsolOut->push_back(*itdso);
        }
    }
}





#define ADD_IF_SET(flag)                                        \
    if ((flObjectsToAdd & (flag)) == (flag))                    \
    {                                                           \
        pdsol->push_back(CDsObject(idOwningScope,               \
                                   _GetAccountName(flag),       \
                                   c_wzGlobalGroupClass));      \
    }

//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_GetDownlevelAddition
//
//  Synopsis:   Add the downlevel well-known SIDs as specified by the caller
//              into [pdsol].
//
//  Arguments:  [pDsScope] - current scope
//              [pdsol]    - list to which to add items
//
//  Returns:    S_OK
//
//  Modifies:   *[pdsol]
//
//  History:    02-26-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdminCustomizer::_GetDownlevelAddition(
    CDsObjectList *pdsol) const
{
    TRACE_METHOD(CAdminCustomizer, _GetDownlevelAddition);

    const CFilterManager &rfm = m_rop.GetFilterManager();
    const CScopeManager &rsm = m_rop.GetScopeManager();

    ULONG idOwningScope = rsm.GetCurScope().GetID();
    ULONG flObjectsToAdd = rfm.GetCurScopeSelectedFilterFlags();

    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_WORLD             );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER);
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_ANONYMOUS         );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_BATCH             );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_CREATOR_OWNER     );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_CREATOR_GROUP     );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_DIALUP            );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_INTERACTIVE       );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_NETWORK           );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_SERVICE           );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_SYSTEM            );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_TERMINAL_SERVER   );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_LOCAL_SERVICE     );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_NETWORK_SERVICE   );
    ADD_IF_SET(DSOP_DOWNLEVEL_FILTER_REMOTE_LOGON      );
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdminCustomizer::_GetAccountName
//
//  Synopsis:   Return the account name associated with the well-known sid
//              flag in [flUser].
//
//  Arguments:  [flUser] - one of the UGOP_USER_* flags.
//
//  Returns:    Account name, or empty string on error.
//
//  History:    02-26-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

String
CAdminCustomizer::_GetAccountName(
    ULONG flUser) const
{
    ULONG idx;

    switch (flUser)
    {
    case DSOP_DOWNLEVEL_FILTER_WORLD:
        idx = 0;
        break;

    case DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER:
        idx = 1;
        break;

    case DSOP_DOWNLEVEL_FILTER_ANONYMOUS:
        idx = 2;
        break;

    case DSOP_DOWNLEVEL_FILTER_BATCH:
        idx = 3;
        break;

    case DSOP_DOWNLEVEL_FILTER_CREATOR_OWNER:
        idx = 4;
        break;

    case DSOP_DOWNLEVEL_FILTER_CREATOR_GROUP:
        idx = 5;
        break;

    case DSOP_DOWNLEVEL_FILTER_DIALUP:
        idx = 6;
        break;

    case DSOP_DOWNLEVEL_FILTER_INTERACTIVE:
        idx = 7;
        break;

    case DSOP_DOWNLEVEL_FILTER_NETWORK:
        idx = 8;
        break;

    case DSOP_DOWNLEVEL_FILTER_SERVICE:
        idx = 9;
        break;

    case DSOP_DOWNLEVEL_FILTER_SYSTEM:
        idx = 10;
        break;

    case DSOP_DOWNLEVEL_FILTER_TERMINAL_SERVER:
        idx = 11;
        break;

    case DSOP_DOWNLEVEL_FILTER_LOCAL_SERVICE:
        idx = 12;
        break;

    case DSOP_DOWNLEVEL_FILTER_NETWORK_SERVICE:
        idx = 13;
        break;

    case DSOP_DOWNLEVEL_FILTER_REMOTE_LOGON:
        idx = 14;
        break;

    default:
        ASSERT(FALSE && "_GetAccountName: invalid user flag");
        return L"";
    }

    //
    // If we've already done a LookupAccountSid to get the name,
    // return it.
    //

    if (m_aSidInfo[idx].wzAccountName[0])
    {
        return m_aSidInfo[idx].wzAccountName;
    }

    //
    // Create the sid and get its name
    //

    BOOL fOk;

    fOk = AllocateAndInitializeSid(&m_aSidInfo[idx].sii,
                                   1,
                                   m_aSidInfo[idx].rid,
                                   0,0,0,0,0,0,0,
                                   &m_aSidInfo[idx].psid);

    if (!fOk || !m_aSidInfo[idx].psid)
    {
        DBG_OUT_LASTERROR;
        return L"";
    }

    ULONG cchAccount = MAX_PATH;
    WCHAR wzDomain[MAX_PATH];
    ULONG cchDomain = MAX_PATH;
    SID_NAME_USE snu;

    fOk = LookupAccountSid(NULL,
                           m_aSidInfo[idx].psid,
                           m_aSidInfo[idx].wzAccountName,
                           &cchAccount,
                           wzDomain,
                           &cchDomain,
                           &snu);

    if (!fOk)
    {
        DBG_OUT_LASTERROR;
        return L"";
    }

    if (*wzDomain)
    {
        wsprintf(m_aSidInfo[idx].wzPath,
                 L"WinNT://%ws/%ws",
                 wzDomain,
                 m_aSidInfo[idx].wzAccountName);
    }
    else
    {
        wsprintf(m_aSidInfo[idx].wzPath,
                 L"WinNT://%ws",
                 m_aSidInfo[idx].wzAccountName);
    }

    return m_aSidInfo[idx].wzAccountName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\addclausedlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       AddClauseDlg.cxx
//
//  Contents:   Implementation of class which drives the dialog used to
//              add query clauses to the Query Builder tab of the
//              Advanced dialog.
//
//  Classes:    CAddClauseDlg
//
//  History:    05-18-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//
// saved state struct needs to indicate:
//  which attribute was selected
//  the saved state blob for that attribute's type dialog (string, dn, time, etc.)

struct SAddClauseDlgSavedState
{
    SAddClauseDlgSavedState():
        Type(ADSTYPE_INVALID),
        pvChildDlgSavedState(NULL)
    {
        wzSelectedLdapAttribute[0] = L'\0';
    }

    ADSTYPE         Type;
    VOID           *pvChildDlgSavedState;
    WCHAR           wzSelectedLdapAttribute[ANYSIZE_ARRAY];

private:

    // not supported: copy ctor and assignment operator

    SAddClauseDlgSavedState(const SAddClauseDlgSavedState &);
    SAddClauseDlgSavedState &
    operator= (const SAddClauseDlgSavedState &);
};


//+--------------------------------------------------------------------------
//
//  Member:     CAddClauseDlg::DoModal
//
//  Synopsis:   Invoke the dialog as modal
//
//  Arguments:  [hwndParent] - parent window
//
//  Returns:    S_OK    - dialog closed via OK button
//              S_FALSE - dialog closed via Cancel button
//              E_*     - error
//
//  History:    05-24-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CAddClauseDlg::DoModal(
    HWND hwndParent) const
{
    return static_cast<HRESULT>(_DoModalDlg(hwndParent, IDD_ADDCLAUSE));
}




//+--------------------------------------------------------------------------
//
//  Member:     CAddClauseDlg::Save
//
//  Synopsis:   Save the state of this dialog and the child dialog
//              associated with the type of the currently selected
//              attribute.
//
//  Arguments:  [ppv] - pointer to value which is filled with a blob
//                      containing the saved state of this dialog.
//
//  History:    05-31-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAddClauseDlg::Save(
    VOID **ppv) const
{
    TRACE_METHOD(CAddClauseDlg, Save);
    ASSERT(ppv);

    if (!ppv)
    {
        return;
    }

    String strSelectedAttrLdapName;
    const CAttributeManager &ram = m_rop.GetAttributeManager();

    if (m_akCurAttribute != AK_INVALID)
    {
        strSelectedAttrLdapName = ram.GetAttrAdsiName(m_akCurAttribute);
    }

    BYTE *pb = new BYTE [sizeof(SAddClauseDlgSavedState) +
                  strSelectedAttrLdapName.length() * sizeof(WCHAR)];

    SAddClauseDlgSavedState *pSavedState =
        reinterpret_cast<SAddClauseDlgSavedState *>(pb);

    if (m_akCurAttribute != AK_INVALID)
    {
        pSavedState->Type = ram.GetAttrType(m_akCurAttribute);
    }

    if (!strSelectedAttrLdapName.empty() && m_pCurDlg)
    {
        m_pCurDlg->Save(&pSavedState->pvChildDlgSavedState);
    }
    lstrcpy(pSavedState->wzSelectedLdapAttribute,
            strSelectedAttrLdapName.c_str());

    *ppv = static_cast<VOID *>(pSavedState);
}





//+--------------------------------------------------------------------------
//
//  Member:     CAddClauseDlg::Load
//
//  Synopsis:   Init the current state of this dialog and the child dialog
//              which represents the currently selected attribute.
//
//  Arguments:  [pv] - pointer to SAddClauseDlgSavedState instance created
//                     by CAddClauseDlg::Save.
//
//  History:    05-31-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAddClauseDlg::Load(
    VOID *pv)
{
    TRACE_METHOD(CAddClauseDlg, Load);
    ASSERT(pv);

    if (!pv)
    {
        return;
    }

    SAddClauseDlgSavedState *pState =
        static_cast<SAddClauseDlgSavedState *>(pv);

    m_strInitialAttrSelection = pState->wzSelectedLdapAttribute;
    m_InitialAttrType = pState->Type;

    switch (pState->Type)
    {
    case ADSTYPE_CASE_IGNORE_STRING:
    case ADSTYPE_NUMERIC_STRING:
    case ADSTYPE_PRINTABLE_STRING:
    case ADSTYPE_OCTET_STRING:
        m_StringDlg.Load(pState->pvChildDlgSavedState);
        break;

    case ADSTYPE_DN_STRING:
        m_DnDlg.Load(pState->pvChildDlgSavedState);
        break;

    default:
        Dbg(DEB_ERROR, "unrecognized type %#x\n", pState->Type);
        ASSERT(0 && "unrecognized adstype");
        break;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CAddClauseDlg::Free
//
//  Synopsis:   Free the saved state structure pointed to by [pv].
//
//  Arguments:  [pv] - NULL or a pointer to a SAddClauseDlgSavedState
//                     instance.
//
//  History:    05-31-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAddClauseDlg::Free(
    VOID *pv) const
{
    TRACE_METHOD(CAddClauseDlg, Free);

    if (!pv)
    {
        return;
    }

    SAddClauseDlgSavedState *pSavedState =
        static_cast<SAddClauseDlgSavedState *>(pv);

    switch (pSavedState->Type)
    {
    case ADSTYPE_CASE_IGNORE_STRING:
    case ADSTYPE_NUMERIC_STRING:
    case ADSTYPE_PRINTABLE_STRING:
    case ADSTYPE_OCTET_STRING:
        m_StringDlg.Free(pSavedState->pvChildDlgSavedState);
        pSavedState->pvChildDlgSavedState = NULL;
        break;

    case ADSTYPE_DN_STRING:
        m_DnDlg.Free(pSavedState->pvChildDlgSavedState);
        pSavedState->pvChildDlgSavedState = NULL;
        break;

    default:
        Dbg(DEB_ERROR, "unrecognized type %#x\n", pSavedState->Type);
        ASSERT(0 && "unrecognized adstype");
        break;
    }

    BYTE *pb = static_cast<BYTE *>(pv);
    delete [] pb;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAddClauseDlg::_OnInit
//
//  Synopsis:   Handle dialog initialization by populating child listview
//              control with the names of attributes of the selected classes.
//
//  Arguments:  [pfSetFocus] - unused
//
//  Returns:    S_OK
//
//  History:    05-25-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CAddClauseDlg::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CAddClauseDlg, _OnInit);

    HWND hwndLV = _hCtrl(IDC_ATTR_LIST);

    //
    // Be consistent with other listviews in this ui: full row select and label
    // tips.  (Given the width of the listview vs. its contents, however, it is
    // unlikely the label tips will ever appear.)
    //

    ListView_SetExtendedListViewStyleEx(hwndLV,
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT,
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT);

    //
    // Add a single column
    //

    RECT rcLV;
    VERIFY(GetClientRect(hwndLV, &rcLV));
    rcLV.right -= GetSystemMetrics(SM_CXVSCROLL);

    LVCOLUMN col;
    ZeroMemory(&col, sizeof col);

    col.mask = LVCF_WIDTH;
    col.cx = rcLV.right;

    int iCol = ListView_InsertColumn(hwndLV, 0, &col);
    if (iCol == -1)
    {
        DBG_OUT_LASTERROR;
    }

    const CAttributeManager &ram = m_rop.GetAttributeManager();
    AttrKeyVector vakAvailable = ram.GetAttrKeysForSelectedClasses(m_hwnd);
    ASSERT(!vakAvailable.empty());

    LVITEM lvi;
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_TEXT | LVIF_PARAM;

    AttrKeyVector::const_iterator it;

    for (it = vakAvailable.begin(); it != vakAvailable.end(); it++)
    {
        const String &strName = ram.GetAttrDisplayName(*it);

        lvi.pszText = const_cast<PWSTR>(strName.c_str());
        lvi.lParam = *it;
        lvi.iItem = INT_MAX;

        if (!m_strInitialAttrSelection.icompare(strName))
        {
            lvi.mask |= LVIF_STATE;
            lvi.state = LVIS_FOCUSED | LVIS_SELECTED;
            lvi.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
        }

        LONG lResult = ListView_InsertItem(hwndLV, &lvi);

        lvi.mask &= ~LVIF_STATE;

        if (lResult == -1)
        {
            Dbg(DEB_ERROR,
                "Error %u inserting '%ws' in listview\n",
                GetLastError(),
                lvi.pszText);
            continue;
        }
    }

    //
    // Create the child attribute dialogs, position them below the
    // attribute listview, and hide them.
    //

    _GetChildWindowRect(_hCtrl(IDC_ATTR_LIST), &rcLV);

    RECT rc;

    rc.left = rc.top = 1;
    rc.right = DIALOG_SEPARATION_X;
    rc.bottom = DIALOG_SEPARATION_Y;
    VERIFY(MapDialogRect(m_hwnd, &rc));

    m_StringDlg.DoModeless(m_hwnd);
    SetWindowPos(m_StringDlg.GetHwnd(),
                 _hCtrl(IDC_ATTR_LIST),
                 rcLV.left,
                 rcLV.bottom + rc.bottom,
                 0,
                 0,
                 SWP_NOACTIVATE
                 | SWP_NOSIZE);
    m_StringDlg.Hide();

    m_DnDlg.DoModeless(m_hwnd);
    SetWindowPos(m_DnDlg.GetHwnd(),
                 _hCtrl(IDC_ATTR_LIST),
                 rcLV.left,
                 rcLV.bottom + rc.bottom,
                 0,
                 0,
                 SWP_NOACTIVATE
                 | SWP_NOSIZE);
    m_DnDlg.Hide();

    //
    // If Load was called there should be a type of the selected attribute.
    // If there is one show the appropriate child dialog.
    //

    switch (m_InitialAttrType)
    {
    case ADSTYPE_CASE_IGNORE_STRING:
    case ADSTYPE_NUMERIC_STRING:
    case ADSTYPE_PRINTABLE_STRING:
    case ADSTYPE_OCTET_STRING:
        m_StringDlg.Show();
        break;

    case ADSTYPE_DN_STRING:
        m_DnDlg.Show();
        break;

    case ADSTYPE_INVALID:
        break;

    default:
        Dbg(DEB_ERROR, "unrecognized type %#x\n", m_InitialAttrType);
        ASSERT(0 && "unrecognized adstype");
        break;
    }

    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAddClauseDlg::_OnCommand
//
//  Synopsis:   Handle button press messages.
//
//  Arguments:  standard Windows
//
//  Returns:    TRUE if message handled, FALSE if not
//
//  History:    05-26-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CAddClauseDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CAddClauseDlg, _OnCommand);
    BOOL fNotHandled = FALSE;

    switch (LOWORD(wParam))
    {
    case IDOK:
    {
        Dbg(DEB_TRACE, "UA: (AddClauseDlg) hit OK\n");
        ASSERT(m_pCurDlg);
        ASSERT(m_akCurAttribute != AK_INVALID);

        if (!m_pCurDlg || m_akCurAttribute == AK_INVALID)
        {
            break;
        }

        if (!m_pCurDlg->QueryClose(m_akCurAttribute))
        {
            break;
        }

        m_strFilter = m_pCurDlg->GetLdapFilter(m_akCurAttribute);
        m_strDescription = m_pCurDlg->GetDescription(m_akCurAttribute);
        EndDialog(m_hwnd, S_OK);
        break;
    }

    case IDCANCEL:
        Dbg(DEB_TRACE, "UA: (AddClauseDlg) hit Cancel\n");
        EndDialog(m_hwnd, S_FALSE);
        break;

    default:
        fNotHandled = TRUE;
        break;
    }
    return fNotHandled;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAddClauseDlg::_OnNotify
//
//  Synopsis:   Handle control notifications
//
//  Arguments:  Standard Windows
//
//  Returns:    FALSE
//
//  History:    05-26-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CAddClauseDlg::_OnNotify(
    WPARAM wParam,
    LPARAM lParam)
{
    LPNMHDR pnmh = reinterpret_cast<LPNMHDR> (lParam);
    BOOL    fReturn = FALSE;

    switch (pnmh->code)
    {
    case LVN_ITEMCHANGED:
        if (pnmh->idFrom == IDC_ATTR_LIST)
        {
            _OnAttrListSelChange();
        }
        break;
    }

    return fReturn;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAddClauseDlg::_OnAttrListSelChange
//
//  Synopsis:   Show the appropriate child dialog based on the attribute
//              type selected (string, date, etc.).
//
//  History:    05-26-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAddClauseDlg::_OnAttrListSelChange()
{
    m_akCurAttribute = _UpdateCurAttr();

    EnableWindow(_hCtrl(IDOK), FALSE);

    if (m_akCurAttribute == AK_INVALID)
    {
        m_StringDlg.Hide();
        m_DnDlg.Hide();
        m_pCurDlg = NULL;
        return;
    }

    const CAttributeManager &ram = m_rop.GetAttributeManager();

    switch (ram.GetAttrType(m_akCurAttribute))
    {
    case ADSTYPE_DN_STRING:
        if (m_pCurDlg != &m_DnDlg)
        {
            m_pCurDlg = &m_DnDlg;
            m_StringDlg.Hide();
            m_DnDlg.Show();
        }
        break;

    case ADSTYPE_CASE_IGNORE_STRING:
    case ADSTYPE_PRINTABLE_STRING:
    case ADSTYPE_NUMERIC_STRING:
    case ADSTYPE_OCTET_STRING:
        if (m_pCurDlg != &m_StringDlg)
        {
            m_pCurDlg = &m_StringDlg;
            m_DnDlg.Hide();
            m_StringDlg.Show();
        }
        break;

    default:
        m_pCurDlg = NULL;
        Dbg(DEB_ERROR,
            "unexpected ADSTYPE %#X\n",
            ram.GetAttrType(m_akCurAttribute));
        ASSERT(0 && "unexpected ADSTYPE");
        break;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CAddClauseDlg::_UpdateCurAttr
//
//  Synopsis:   Return the currently selected attribute key
//
//  Returns:    Currently selected attribute key, or AK_INVALID if none
//              selected.
//
//  History:    05-26-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

ATTR_KEY
CAddClauseDlg::_UpdateCurAttr() const
{
    HWND hwndLV = _hCtrl(IDC_ATTR_LIST);
    int iItem = ListView_GetNextItem(hwndLV, -1, LVNI_SELECTED);

    if (iItem == -1)
    {
        return AK_INVALID;
    }

    LVITEM lvi;
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_PARAM;
    lvi.iItem = iItem;

    if (!ListView_GetItem(hwndLV, &lvi))
    {
        DBG_OUT_LASTERROR;
        return AK_INVALID;
    }

    return static_cast<ATTR_KEY>(lvi.lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\admindbg.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1996, Microsoft Corporation.
//
//  File:       AdminDbg.h
//
//  Contents:   Debugging macros. Stolen from old Cairo debnot.h with the
//              following history...
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              29-Apr-92   BartoszM    Moved from win4p.h
//              18-Jun-94   AlexT       Make Assert a better statement
//               7-Oct-94   BruceFo     Stole and ripped out everything except
//                                      debug prints and asserts.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//              26-Feb-96   EricB       Renamed Win4xxx exported fcns to not
//                                      conflict with ole32.lib.
//
//
//  NOTE: you must call the InitializeDebugging() API before calling any other
//  APIs!
//
//  To set a non-default debug info level outside of the debugger, create the
//  below registry key:
//
//   "HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AdminDebug"
//
//  and in it create a value whose name is the component's debugging tag name
//  (the "comp" parameter to the DECLARE_INFOLEVEL macro) and whose data is
//  the desired infolevel in REG_DWORD format.
//  e.g. Sched = REG_DWORD 0x707
//
//----------------------------------------------------------------------------

#ifndef __DEBUG_H__
#define __DEBUG_H__

//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
//-----------------------------------------------------------------------



#if DBG==1

class CDbg
{
public:
    CDbg(LPTSTR str);
   ~CDbg();

    void __cdecl Trace(PWSTR pszfmt, ...);
    void __cdecl Trace(LPSTR pszfmt, ...);
    void __cdecl DebugOut(unsigned long fDebugMask, LPSTR pszfmt, ...);
    void __cdecl DebugOut(unsigned long fDebugMask, PWSTR pszfmt, ...);
    void DebugMsg(LPSTR file, unsigned long line, PWSTR  msg);
    void DebugMsg(LPSTR file, unsigned long line, LPSTR  msg);
    void DebugErrorL(LPSTR file, ULONG line, LONG err);
    void DebugErrorX(LPSTR file, ULONG line, LONG err);
    void IncIndent();
    void DecIndent();

    static void AssertEx(LPSTR pszFile, int iLine, LPTSTR pszMsg);

    static ULONG s_idxTls;

private:

    ULONG
    _GetIndent();

    unsigned long   m_flInfoLevel; // must be the first data member
    unsigned long   m_flOutputOptions;
    LPTSTR          m_InfoLevelString;
};  // class CDbg

class CIndenter
{
public:

    CIndenter(CDbg *pdbg): m_pDbg(pdbg) { m_pDbg->IncIndent(); }
    ~CIndenter() { m_pDbg->DecIndent(); m_pDbg = NULL; }

private:

    CDbg *m_pDbg;
};

#define DECLARE_DEBUG(comp)     extern "C" CDbg comp##InfoLevel;
#define DECLARE_INFOLEVEL(comp) CDbg comp##InfoLevel(_T(#comp));
#define Win4Assert(x) (void)((x) || (CDbg::AssertEx(THIS_FILE,__LINE__, _T(#x)),0))

#else  // ! DBG==1

#define DECLARE_DEBUG(comp)
#define DECLARE_INFOLEVEL(comp)
#define Win4Assert(x)      NULL

#endif // ! DBG==1





////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
//
//  Debug info levels
//
////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////

#define DEB_ERROR           0x00000001      // exported error paths
#define DEB_WARN            0x00000002      // exported warnings
#define DEB_TRACE           0x00000004      // exported trace messages

#define DEB_DBGOUT          0x00000010      // Output to debugger
#define DEB_STDOUT          0x00000020      // Output to stdout

#define DEB_IERROR          0x00000100      // internal error paths
#define DEB_IWARN           0x00000200      // internal warnings
#define DEB_ITRACE          0x00000400      // internal trace messages

#define DEB_USER1           0x00010000      // User defined
#define DEB_USER2           0x00020000      // User defined
#define DEB_USER3           0x00040000      // User defined
#define DEB_USER4           0x00080000      // User defined
#define DEB_USER5           0x00100000      // User defined
#define DEB_USER6           0x00200000      // User defined
#define DEB_USER7           0x00400000      // User defined

#define DEB_FUNCTION        0x00800000
#define DEB_RESOURCE        0x01000000
#define DEB_METHOD          0x02000000
#define DEB_DSOBJECT        0x04000000
#define DEB_DATAOBJECT      0x08000000
#define DEB_RICHEDIT        0x10000000      // text processing
#define DEB_ELAPSEDTIME     0x20000000      // output elapsed time
#define DEB_NOCOMPNAME      0x40000000      // suppress component name

#define DEB_FORCE           0x1fffffff      // force message

#define ASSRT_MESSAGE       0x00000001      // Output a message
#define ASSRT_BREAK         0x00000002      // Int 3 on assertion
#define ASSRT_POPUP         0x00000004      // And popup message

#ifndef DEF_INFOLEVEL
#define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
#endif

#endif // __DEBUG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\assert.cxx ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991-1994, Microsoft Corporation.
//
//  File:       assert.cpp
//
//  Contents:   Debugging output routines
//
//  History:    23-Jul-91   KyleP       Created.
//              09-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        moved debug print routines out
//              10-Jun-92   BryanT      Switched to w4crt.h instead of wchar.h
//               7-Oct-94   BruceFo     Ripped out all kernel, non-FLAT,
//                                      DLL-specific, non-Win32 functionality.
//                                      Now it's basically "print to the
//                                      debugger" code.
//              20-Oct-95   EricB       Set component debug level in the
//                                      registry.
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#include <shlwapi.h>
#include <objbase.h>
#include <basetyps.h>
#include <tchar.h>

#if DBG==1


    #include "malloc.h" // alloca

//
//  Globals
//

ULONG g_AdminAssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;
BOOL  g_fInitializedTickCount = FALSE;
ULONG g_ulTickCountAtStart;
BOOL  g_fCritSecInit = FALSE;
CRITICAL_SECTION g_csMessageBuf;
static TCHAR g_szMessageBuf[2048];        // this is the message buffer

DECLARE_HEAPCHECKING;

//
//  Forward declration of local functions
//

LPSTR AnsiPathFindFileName(LPSTR pPath);
void  InitializeDebugging(void);
void  smprintf(ULONG ulCompMask, ULONG cchIndent, LPTSTR  pszComp, LPTSTR  ppszfmt, va_list pargs);
static int   w4smprintf(LPTSTR format, va_list arglist);

//+---------------------------------------------------------------------------
//
//  Function:   w4dprintf
//
//  Synopsis:   Calls w4smprintf to output a formatted message.
//
//----------------------------------------------------------------------------

static int __cdecl w4dprintf(LPTSTR  format, ...)
{
    int ret;

    va_list va;
    va_start(va, format);
    ret = w4smprintf(format, va);
    va_end(va);

    return ret;
}

//+---------------------------------------------------------------------------
//
//  Function:   w4smprintf
//
//  Synopsis:   Calls OutputDebugStringA to output a formatted message.
//
//----------------------------------------------------------------------------

static int w4smprintf(LPTSTR  format, va_list arglist)
{
    int ret;

    EnterCriticalSection(&g_csMessageBuf);
    ret = wvsprintf(g_szMessageBuf,
                    format,
                    arglist);
    OutputDebugString(g_szMessageBuf);
    LeaveCriticalSection(&g_csMessageBuf);
    return ret;
}




//+------------------------------------------------------------
// Function:    smprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguements:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

CRITICAL_SECTION g_csDebugPrint;

void smprintf(
             ULONG ulCompMask,
             ULONG cchIndent,
             LPTSTR  pszComp,
             LPTSTR  ppszfmt,
             va_list pargs)
{
    if (ulCompMask & DEB_FORCE)
    {
        EnterCriticalSection(&g_csDebugPrint);

        if (ulCompMask & DEB_ELAPSEDTIME)
        {
            ULONG ulTicksNow = GetTickCount();

            if (!g_fInitializedTickCount)
            {
                g_fInitializedTickCount = TRUE;
                g_ulTickCountAtStart = ulTicksNow;
            }

            ULONG ulDelta;

            if (g_ulTickCountAtStart > ulTicksNow)
            {
                ulDelta = ulTicksNow + ((ULONG)-1) - g_ulTickCountAtStart;
            }
            else
            {
                ulDelta = ulTicksNow - g_ulTickCountAtStart;
            }
            w4dprintf(_T("%04u.%03u "), ulDelta / 1000, ulDelta % 1000);
        }

        if (!(ulCompMask & DEB_NOCOMPNAME))
        {
            DWORD pid = GetCurrentProcessId();
            DWORD tid = GetCurrentThreadId();

            w4dprintf(_T("%x.%03x> %s: "), pid, tid, pszComp);
        }

        if (cchIndent)
        {
            TCHAR tzFmt[] = _T("%999s");

            wsprintf(tzFmt, _T("%%%us"), cchIndent);
            w4dprintf(tzFmt, _T(""));
        }
        w4smprintf(ppszfmt, pargs);

        LeaveCriticalSection(&g_csDebugPrint);
    }
}

//+----------------------------------------------------------------------------
//
// Admin debuggging library inititalization.
//
// To set a non-default debug info level outside of the debugger, create the
// below registry key and in it create a value whose name is the component's
// debugging tag name (the "comp" parameter to the DECLARE_INFOLEVEL macro) and
// whose data is the desired infolevel in REG_DWORD format.
//-----------------------------------------------------------------------------

    #define CURRENT_VERSION_KEY _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion")
    #define ADMINDEBUGKEY _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\AdminDebug")
    #define ADMINDEBUG _T("AdminDebug")

//+----------------------------------------------------------------------------
// Function:    CheckInit
//
// Synopsis:    Performs debugging library initialization
//              including reading the registry for the desired infolevel
//
//-----------------------------------------------------------------------------

void CheckInit(LPTSTR  pInfoLevelString, ULONG * pulInfoLevel)
{
    HKEY hKey;
    LONG lRet;
    DWORD dwSize;

    if (!g_fCritSecInit) InitializeDebugging();

    *pulInfoLevel = DEF_INFOLEVEL;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        ADMINDEBUGKEY,
                        0,
                        KEY_READ,
                        &hKey);

    if (lRet == ERROR_FILE_NOT_FOUND)
    {
        HKEY hkCV;

        lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, CURRENT_VERSION_KEY, 0,
                            KEY_ALL_ACCESS, &hkCV);
        if (lRet == ERROR_SUCCESS)
        {
            lRet = RegCreateKeyEx(hkCV, ADMINDEBUG, 0, _T(""),
                                  REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, NULL);

            RegCloseKey(hkCV);
        }
    }

    if (lRet == ERROR_SUCCESS)
    {
        dwSize = sizeof(ULONG);

        lRet = RegQueryValueEx(hKey, pInfoLevelString, NULL, NULL,
                               (LPBYTE)pulInfoLevel, &dwSize);

        if (lRet != ERROR_SUCCESS)
        {
            lRet = RegSetValueEx(hKey, pInfoLevelString, 0, REG_DWORD,
                                 (CONST BYTE *)pulInfoLevel, sizeof(ULONG));
        }

        RegCloseKey(hKey);
    }
}

void InitializeDebugging(void)
{
    if (g_fCritSecInit) return;
    InitializeCriticalSection(&g_csMessageBuf);
    InitializeCriticalSection(&g_csDebugPrint);
    g_fCritSecInit = TRUE;
}



// Returns a pointer to the last component of a path string.
//
// in:
//      path name, either fully qualified or not
//
// returns:
//      pointer into the path where the path is.  if none is found
//      returns a poiter to the start of the path
//
//  c:\foo\bar  -> bar
//  c:\foo      -> foo
//  c:\foo\     -> c:\foo\      (REVIEW: is this case busted?)
//  c:\         -> c:\          (REVIEW: this case is strange)
//  c:          -> c:
//  foo         -> foo

LPSTR AnsiPathFindFileName(LPSTR pPath)
{
    LPSTR pT;

    for (pT = pPath; *pPath; pPath = CharNextA(pPath))
    {
        if ((pPath[0] == '\\' || pPath[0] == ':')
            && pPath[1] && (pPath[1] != '\\'))

            pT = pPath + 1;
    }

    return(LPSTR)pT;   // const -> non const
}



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//////////////   ASSERT CODE   //////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

int PopUpError(LPTSTR  szMsg, int iLine, LPSTR szFile)
{
    //
    //  Create caption
    //

    static TCHAR szAssertCaption[128];

    //
    // get process
    //

    static CHAR szModuleName[128];
    LPSTR pszModuleName;

    if (GetModuleFileNameA(NULL, szModuleName, 128))
    {
        pszModuleName = szModuleName;
    }
    else
    {
        pszModuleName = "Unknown";
    }

    LPSTR pProcess = AnsiPathFindFileName(pszModuleName);

    wsprintf(szAssertCaption, _T("%hs: Assertion Failed"), pProcess);


    //
    //  Create details.
    //

    TCHAR szDetails[1024];
    DWORD tid = GetCurrentThreadId();
    DWORD pid = GetCurrentProcessId();

    wsprintf(szDetails, _T(" Assertion:\t %s\n\n")       \
             _T(" File:   \t\t %hs\n")        \
             _T(" Line:   \t\t %d\n\n")       \
             _T(" Module:   \t %hs\n")        \
             _T(" Thread ID:\t %d.%d\n"),
             szMsg, szFile, iLine, pszModuleName, pid, tid);


    int id = MessageBox(NULL,
                        szDetails,
                        szAssertCaption,
                        MB_SETFOREGROUND
                        | MB_DEFAULT_DESKTOP_ONLY
                        | MB_TASKMODAL
                        | MB_ICONEXCLAMATION
                        | MB_OKCANCEL);

    //
    // If id == 0, then an error occurred.  There are two possibilities
    // that can cause the error:  Access Denied, which means that this
    // process does not have access to the default desktop, and everything
    // else (usually out of memory).
    //

    if (0 == id)
    {
        if (GetLastError() == ERROR_ACCESS_DENIED)
        {
            //
            // Retry this one with the SERVICE_NOTIFICATION flag on.  That
            // should get us to the right desktop.
            //
            id = MessageBox(NULL,
                            szMsg,
                            szAssertCaption,
                            MB_SETFOREGROUND
                            | MB_TASKMODAL
                            | MB_ICONEXCLAMATION
                            | MB_OKCANCEL);
        }
    }

    return id;
}


//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls smprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------

inline void __cdecl _asdprintf(LPTSTR  pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    smprintf(DEB_FORCE, 0, _T("Assert"), pszfmt, va);

    va_end(va);
}

//+---------------------------------------------------------------------------
//
//  Function:   AdminAssertEx, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//----------------------------------------------------------------------------

void AdminAssertEx(LPSTR szFile, int iLine, LPTSTR szMessage)
{
    if (g_AdminAssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

        LPSTR pszFileName = AnsiPathFindFileName(szFile);

        _asdprintf(_T("%s <%hs, l %u, thread %d>\n"),
                   szMessage, pszFileName, iLine, tid);
    }

    if (g_AdminAssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (g_AdminAssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}






//____________________________________________________________________________
//____________________________________________________________________________
//________________                   _________________________________________
//________________    class CDbg     _________________________________________
//________________                   _________________________________________
//____________________________________________________________________________
//____________________________________________________________________________



CDbg::CDbg(LPTSTR  str)
    :
m_InfoLevelString(str),
    m_flInfoLevel(DEF_INFOLEVEL),
    m_flOutputOptions(0)
{
    ULONG flRegistry = 0;

    CheckInit(m_InfoLevelString, &flRegistry);

    m_flInfoLevel = flRegistry & DEB_FORCE;
    m_flOutputOptions = flRegistry & ~DEB_FORCE;
}

CDbg::~CDbg()
{
}


void __cdecl CDbg::Trace(LPSTR pszfmt, ...)
{
#ifdef UNICODE
    ULONG convert = static_cast<ULONG>(strlen(pszfmt)) + 1;
    LPTSTR ptcfmt = (PWSTR)alloca(convert * sizeof(WCHAR));
    ptcfmt[0] = '\0';
    (void) MultiByteToWideChar(CP_ACP, 0, pszfmt, -1, ptcfmt, convert);
#else
    LPTSTR ptcfmt = pszfmt;
#endif

    if (m_flInfoLevel & DEB_TRACE)
    {
        va_list va;
        va_start (va, pszfmt);
        ULONG cchIndent = _GetIndent();
        smprintf(DEB_TRACE, cchIndent, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void __cdecl CDbg::Trace(PWSTR pwzfmt, ...)
{
#ifndef UNICODE
    int convert = wcslen(pwzfmt) + 1;
    LPTSTR ptcfmt = (LPSTR)alloca(convert * sizeof(CHAR));
    ptcfmt[0] = '\0';
    (void) WideCharToMultiByte(CP_ACP, 0, pwzfmt, -1, ptcfmt, convert, NULL, NULL);
#else
    LPTSTR ptcfmt = pwzfmt;
#endif

    if (m_flInfoLevel & DEB_TRACE)
    {
        va_list va;
        va_start (va, pwzfmt);
        ULONG cchIndent = _GetIndent();
        smprintf(DEB_TRACE, cchIndent, m_InfoLevelString, ptcfmt, va);
        va_end(va);
    }
}

void __cdecl CDbg::DebugOut(ULONG fDebugMask, LPSTR pszfmt, ...)
{
#ifdef UNICODE
    ULONG convert = static_cast<ULONG>(strlen(pszfmt)) + 1;
    LPTSTR ptcfmt = (PWSTR)alloca(convert * sizeof(WCHAR));
    ptcfmt[0] = '\0';
    (void) MultiByteToWideChar(CP_ACP, 0, pszfmt, -1, ptcfmt, convert);
#else
    LPTSTR ptcfmt = pszfmt;
#endif

    va_list va;
    va_start (va, pszfmt);
    ULONG cchIndent = _GetIndent();
    smprintf(m_flOutputOptions | (m_flInfoLevel & fDebugMask)
             | (fDebugMask & DEB_NOCOMPNAME),
             cchIndent,
             m_InfoLevelString,
             ptcfmt,
             va);
    va_end(va);
}

void __cdecl CDbg::DebugOut(ULONG fDebugMask, PWSTR pwzfmt, ...)
{
#ifndef UNICODE
    int convert = wcslen(pwzfmt) + 1;
    LPTSTR ptcfmt = (LPSTR)alloca(convert * sizeof(CHAR));
    ptcfmt[0] = '\0';
    (void) WideCharToMultiByte(CP_ACP, 0, pwzfmt, -1, ptcfmt, convert, NULL, NULL);
#else
    LPTSTR ptcfmt = pwzfmt;
#endif

    va_list va;
    va_start (va, pwzfmt);
    ULONG cchIndent = _GetIndent();
    smprintf(m_flOutputOptions | (m_flInfoLevel & fDebugMask)
             | (fDebugMask & DEB_NOCOMPNAME),
             cchIndent,
             m_InfoLevelString,
             ptcfmt,
             va);
    va_end(va);
}

void CDbg::DebugErrorX(LPSTR  file, ULONG line, LONG err)
{
    if (m_flInfoLevel & DEB_ERROR)
    {
        file = AnsiPathFindFileName(file);

        this->DebugOut(DEB_ERROR, "error<0x%08x> %hs, l %u\n",
                       err, file, line);
    }
}

void CDbg::DebugErrorL(LPSTR  file, ULONG line, LONG err)
{
    if (m_flInfoLevel & DEB_ERROR)
    {
        file = AnsiPathFindFileName(file);

        this->DebugOut(DEB_ERROR, "error<%uL> %hs, l %u\n", err, file, line);
    }
}

void CDbg::DebugMsg(LPSTR  file, ULONG line, LPSTR  msg)
{
    file = AnsiPathFindFileName(file);

    this->DebugOut(DEB_FORCE, "asrt %hs, l %u, <%s>\n", file, line, msg);
}

void CDbg::DebugMsg(LPSTR  file, ULONG line, PWSTR  msg)
{
    file = AnsiPathFindFileName(file);

    this->DebugOut(DEB_FORCE, _T("asrt %hs, l %u, <%s>\n"), file, line, msg);
}

void CDbg::AssertEx(LPSTR pszFile, int iLine, LPTSTR pszMsg)
{
#if 0
    LPTSTR ptcMsg = NULL;

#ifdef UNICODE
    int convert = strlen(pszMsg) + 1;
    ptcMsg = (PWSTR)alloca(convert * sizeof(WCHAR));
    ptcMsg[0] = '\0';
    (void) MultiByteToWideChar(CP_ACP, 0, pszMsg, -1, ptcMsg, convert);
#else
    ptcMsg = pszMsg;
#endif

    AdminAssertEx(pszFile, iLine, ptcMsg);
#endif //0

    AdminAssertEx(pszFile, iLine, pszMsg);

}


ULONG
    CDbg::_GetIndent()
{
    ULONG cchIndent = 0;

    if (s_idxTls != 0xFFFFFFFF)
    {
        cchIndent = static_cast<ULONG>
                        (reinterpret_cast<ULONG_PTR>
                            (TlsGetValue(s_idxTls)));
    }
    return cchIndent;
}

void CDbg::IncIndent()
{
    if (s_idxTls != 0xFFFFFFFF)
    {
        ULONG_PTR cchIndent = reinterpret_cast<ULONG_PTR>(TlsGetValue(s_idxTls));
        cchIndent++;
        TlsSetValue(s_idxTls, reinterpret_cast<PVOID>(cchIndent));
    }
}

void CDbg::DecIndent()
{
    if (s_idxTls != 0xFFFFFFFF)
    {
        ULONG_PTR cchIndent = reinterpret_cast<ULONG_PTR>(TlsGetValue(s_idxTls));
        cchIndent--;
        TlsSetValue(s_idxTls, reinterpret_cast<PVOID>(cchIndent));
    }
}




#endif // DBG==1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\advanceddlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       AdvancedDlg.cxx
//
//  Contents:   Declaration of dialog that appears when user hits
//              Advanced button on base dialog.
//
//  Classes:    CAdvancedDlg
//
//  History:    04-03-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

const WCHAR c_wzBannerClass[] = L"ObjectPickerQueryBanner";

static ULONG
s_aulHelpIds[] =
{
    IDC_LOOK_FOR_PB,        IDH_LOOK_FOR_PB,
    IDC_LOOK_FOR_EDIT,      IDH_LOOK_FOR_EDIT,
    IDC_LOOK_IN_PB,         IDH_LOOK_IN_PB,
    IDC_LOOK_IN_EDIT,       IDH_LOOK_IN_EDIT,
    IDC_COLUMNS_PB,         IDH_COLUMNS_PB,
    IDC_FIND_NOW_PB,        IDH_FIND_NOW_PB,
    IDC_STOP_PB,            IDH_STOP_PB,
    IDC_QUERY_LISTVIEW,     IDH_QUERY_LISTVIEW,
    IDC_ANIMATION,          ULONG_MAX,
    IDC_TAB,                ULONG_MAX,
    0,0
};


//
// Forward refs
//

LRESULT CALLBACK
_BannerWndProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam);

AttrKeyVector
AttributesFromColumns(
    const AttrKeyVector &vakListviewColumns);

//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::CAdvancedDlg
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - owning object picker instance
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CAdvancedDlg::CAdvancedDlg(
    const CObjectPicker &rop):
        m_rop(rop),
        m_CommonQueriesTab(rop),
#ifdef QUERY_BUILDER
        m_QueryBuilderTab(rop),
#endif // QUERY_BUILDER
        m_pCurTab(&m_CommonQueriesTab),
        m_fResizeableModeOn(FALSE),
        m_usnLatestQueryWorkItem(0),
        m_pvSelectedObjects(NULL),
        m_ulPrevFilterFlags(0),
        m_hwndAnimation(NULL),
        m_hwndBanner(NULL),
        m_cxMin(0),
        m_cyMin(0),
        m_cxSeparation(0),
        m_cySeparation(0),
        m_cxLvSeparation(0),
        m_cyLvSeparation(0),
        m_cxFrameLast(0),
        m_cyFrameLast(0),
		m_cxFour(0)
{
    TRACE_CONSTRUCTOR(CAdvancedDlg);
    ZeroMemory(&m_rcDlgOriginal, sizeof m_rcDlgOriginal);
    ZeroMemory(&m_rcWrDlgOriginal, sizeof m_rcWrDlgOriginal);
}



//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::DoModalDlg
//
//  Synopsis:   Invoke the advanced dialog and block until it is closed.
//
//  Arguments:  [hwndParent]        - parent of modal dialog
//              [pvSelectedObjects] - filled with objects user selected
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::DoModalDlg(
    HWND hwndParent,
    vector<CDsObject> *pvSelectedObjects)
{
    m_pvSelectedObjects = pvSelectedObjects;
    ASSERT(m_pvSelectedObjects);

    if (!m_pvSelectedObjects)
    {
        return;
    }
    _DoModalDlg(hwndParent, IDD_ADVANCED);
    m_cxMin= 0;
    m_cyMin= 0;
    m_cxSeparation= 0;
    m_cySeparation= 0;
	m_cxFour = 0;
    m_cxLvSeparation= 0;
    m_cyLvSeparation= 0;
    m_cxFrameLast= 0;
    m_cyFrameLast= 0;
    m_pCurTab = &m_CommonQueriesTab;
    m_fResizeableModeOn = FALSE;
    m_pvSelectedObjects = NULL;
    m_ulPrevFilterFlags = 0;
    m_vakListviewColumns.clear();
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_OnInit
//
//  Synopsis:   Initialize the dialog
//
//  Arguments:  [pfSetFocus] -
//
//  Returns:    S_OK
//
//  History:    06-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CAdvancedDlg::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CAdvancedDlg, _OnInit);

    //
    // Make prefix shut up
    //

    if (!_hCtrl(IDC_TAB) ||
        !_hCtrl(IDOK) ||
        !_hCtrl(IDC_FIND_NOW_PB) ||
        !_hCtrl(IDC_STOP_PB) ||
        !_hCtrl(IDC_QUERY_LISTVIEW))
    {
        return E_FAIL;
    }

    //
    // Init data needed for resizing.
    //
    // First translate the separation distance between controls from
    // dialog units to pixels.
    //

    RECT rc;

    rc.left = rc.top = 1;
    rc.right = DIALOG_SEPARATION_X;
    rc.bottom = DIALOG_SEPARATION_Y;
    VERIFY(MapDialogRect(m_hwnd, &rc));
    m_cxSeparation = rc.right;
    m_cySeparation = rc.bottom;

    rc.left = rc.top = 1;
    rc.right = 4;
    rc.bottom = DIALOG_SEPARATION_Y;
    VERIFY(MapDialogRect(m_hwnd, &rc));
    m_cxFour = rc.right;

    GetWindowRect(m_hwnd, &rc);

    m_cxFrameLast = WindowRectWidth(rc);
    m_cyFrameLast = WindowRectHeight(rc);

    GetWindowRect(m_hwnd, &rc);
    m_cxMin = rc.right - rc.left + 1;
    m_cyMin = rc.bottom - rc.top + 1;

    //
    // Init the Look For and Look In r/o edit controls and the caption
    //

    UpdateLookForInText(m_hwnd, m_rop);

    //
    // Add the Common Queries and Query Builder tabs
    //

    TCITEM tci;

    ZeroMemory(&tci, sizeof tci);
    tci.mask = TCIF_TEXT;

    String  strTabCaption;

    strTabCaption = String::load(IDS_COMMON_QUERIES, g_hinst);
    tci.pszText = const_cast<PWSTR>(strTabCaption.c_str());
    TabCtrl_InsertItem(_hCtrl(IDC_TAB), 0, &tci);
#ifdef QUERY_BUILDER
    strTabCaption = String::load(IDS_QUERY_BUILDER, g_hinst);
    tci.pszText = const_cast<PWSTR>(strTabCaption.c_str());
    TabCtrl_InsertItem(_hCtrl(IDC_TAB), 1, &tci);
#endif // QUERY_BUILDER

    //
    // Give the enable-find-now method to the tabs for callback
    //

    m_CommonQueriesTab.SetFindValidCallback(
        &FindValidCallback,
        reinterpret_cast<LPARAM>(this));
#ifdef QUERY_BUILDER
    m_QueryBuilderTab.SetFindValidCallback(
        &FindValidCallback,
        reinterpret_cast<LPARAM>(this));
#endif // QUERY_BUILDER

    //
    // Create the corresponding Common Queries and Query Builder dialogs
    //

    HWND hwndTab = _hCtrl(IDC_TAB);

    m_CommonQueriesTab.DoModelessDlg(hwndTab);
#ifdef QUERY_BUILDER
    m_QueryBuilderTab.DoModelessDlg(hwndTab);
#endif // QUERY_BUILDER

    //
    // Position them so they fit within tab's bounding rectangle
    //

    RECT rcTab;

    VERIFY(GetWindowRect(hwndTab, &rcTab));
    TabCtrl_AdjustRect(hwndTab, FALSE, &rcTab);
    //ScreenToClient(hwndTab, reinterpret_cast<LPPOINT>(&rcTab.left));
    //ScreenToClient(hwndTab, reinterpret_cast<LPPOINT>(&rcTab.right));
    //ScreenToClient has some problem with mirrored apps and was causing
    //problems in Arabic build
    MapWindowPoints(NULL, hwndTab, (LPPOINT)&rcTab, 2);

    SetWindowPos(m_CommonQueriesTab.GetHwnd(),
                 hwndTab,
                 rcTab.left,
                 rcTab.top,
                 0,
                 0,
                 SWP_NOSIZE | SWP_NOZORDER);

#ifdef QUERY_BUILDER
    SetWindowPos(m_QueryBuilderTab.GetHwnd(),
                 hwndTab,
                 rcTab.left,
                 rcTab.top,
                 0,
                 0,
                 SWP_NOSIZE | SWP_NOZORDER);
#endif // QUERY_BUILDER

    //
    // Disable OK, it is only enabled if a find has been done and a
    // selection in the find results listview has been made.
    //

    EnableWindow(_hCtrl(IDOK), FALSE);

    //
    // Disable both Find Now and Stop.  Stop is only enabled after
    // Find Now has been clicked and a query is ongoing.  Find Now
    // is enabled whenever the current tab tells us it should be.
    //

    EnableWindow(_hCtrl(IDC_FIND_NOW_PB), FALSE);
    EnableWindow(_hCtrl(IDC_STOP_PB), FALSE);

    //
    // Disable Columns button if we're in a downlevel scope, column chooser
    // is for uplevel only.
    //

    if (IsDownlevel(m_rop.GetScopeManager().GetCurScope().Type()))
    {
        EnableWindow(_hCtrl(IDC_COLUMNS_PB), FALSE);
    }

    //
    // Put the listview in single select mode if that's how the object
    // picker was invoked.
    //

    HWND hwndLv = _hCtrl(IDC_QUERY_LISTVIEW);

    if (!(m_rop.GetInitInfoOptions() & DSOP_FLAG_MULTISELECT))
    {
        LONG_PTR lStyle = GetWindowLongPtr(hwndLv, GWL_STYLE);
        SetWindowLongPtr(hwndLv, GWL_STYLE, lStyle | LVS_SINGLESEL);
    }

    //
    // Put the display cache's imagelist in the listview
    //

    const CAttributeManager &ram = m_rop.GetAttributeManager();
    HIMAGELIST himl = NULL;
    HRESULT hrImageList = ram.GetImageList(&himl);

    if (SUCCEEDED(hrImageList))
    {
        ListView_SetImageList(hwndLv, himl, LVSIL_SMALL);
    }

    //
    // Make sure we start out looking at the tab 0 dialog.
    //

#ifdef QUERY_BUILDER
    m_QueryBuilderTab.Hide();
#endif // QUERY_BUILDER
    m_CommonQueriesTab.Show(); // does a refresh

    //
    // Save the client area size before we allow resizing
    //

    GetClientRect(m_hwnd, &m_rcDlgOriginal);
    GetWindowRect(m_hwnd, &m_rcWrDlgOriginal);

    //
    // Create the animation control
    //

    m_hwndAnimation = Animate_Create(m_hwnd,
                                     IDC_ANIMATION,
                                     WS_CHILD
                                     | WS_VISIBLE
                                     | ACS_CENTER
                                     | ACS_TRANSPARENT,
                                     g_hinst);
    if (m_hwndAnimation)
    {
        Animate_Open(m_hwndAnimation, MAKEINTRESOURCE(IDA_SEARCH));
    }
    else
    {
        DBG_OUT_LASTERROR;
    }

    //
    // Register banner window class and create a banner instance
    //

    WNDCLASS wc;
    ZeroMemory(&wc, sizeof wc);
    wc.lpfnWndProc = _BannerWndProc;
    wc.hInstance = g_hinst;
    wc.lpszClassName = c_wzBannerClass;
    RegisterClass(&wc);

    // Create the banner window, this is a child of the ListView, it is used to display
    // information about the query being issued

    m_hwndBanner = CreateWindow(c_wzBannerClass, NULL,
                                WS_CHILD,
                                0, 0, 0, 0,               // nb: size fixed later
                                hwndLv,
                                0,
                                g_hinst,
                                NULL);
    if (!m_hwndBanner)
    {
        DBG_OUT_LASTERROR;
    }

    HRESULT hr = _ResizeableModeOn();
	if(FAILED(hr))
	{
		//
		//Show a popup
		//
		String strError = GetErrorMessage(hr);
		String strMsg;
		if(strError.empty())
			PopupMessage(GetParent(m_hwnd),IDS_CANNOT_INVOKE_ADV_NOERROR);
		else
			PopupMessage(GetParent(m_hwnd),IDS_CANNOT_INVOKE_ADV, strError.c_str());
	}
	return hr;
     
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_OnCommand
//
//  Synopsis:   Handle notification that the user has entered or changed
//              something in the UI.
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CAdvancedDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fHandled = TRUE;

    switch (LOWORD(wParam))
    {
    case IDC_LOOK_IN_PB:
    {
        Dbg(DEB_TRACE, "UA: (AdvancedDlg) hit Look In button\n");
        const CScopeManager &rsm = m_rop.GetScopeManager();

        //
        // do the look in dlg and update look in/for text
        //

        rsm.DoLookInDialog(m_hwnd);
        m_rop.GetFilterManager().HandleScopeChange(m_hwnd);
        UpdateLookForInText(m_hwnd, m_rop);
        _UpdateColumns();

        EnableWindow(_hCtrl(IDC_COLUMNS_PB),
                     IsUplevel(m_rop.GetScopeManager().GetCurScope()));

        //
        // tell current tab to update itself per current look in.
        // since changing the look in might have changed the look for,
        // request an update of that also.
        //

        m_pCurTab->Refresh();
        break;
    }

    case IDC_LOOK_FOR_PB:
    {
        Dbg(DEB_TRACE, "UA: (AdvancedDlg) hit Look For button\n");
        const CFilterManager &rfm = m_rop.GetFilterManager();

        rfm.DoLookForDialog(m_hwnd);

        Edit_SetText(GetDlgItem(m_hwnd, IDC_LOOK_FOR_EDIT),
                     rfm.GetFilterDescription(m_hwnd, FOR_LOOK_FOR).c_str());
        _UpdateColumns();
        m_pCurTab->Refresh();
        break;
    }

    case IDC_COLUMNS_PB:
        _InvokeColumnChooser();
        break;

    case IDC_FIND_NOW_PB:
        Dbg(DEB_TRACE, "UA: (AdvancedDlg) hit Find Now button\n");

        //
        // If we're querying against an uplevel scope, we'll need
        // to ensure the attribute manager has been initialized
        // first.
        //

        if (IsUplevel(m_rop.GetScopeManager().GetCurScope().Type()))
        {
            HRESULT hr = m_rop.GetAttributeManager().DemandInit(m_hwnd);

            if (FAILED(hr))
            {
                DBG_OUT_HRESULT(hr);
                break;
            }
        }
        EnableWindow(_hCtrl(IDC_STOP_PB), TRUE);
        SetFocus(_hCtrl(IDC_STOP_PB));
        EnableWindow(_hCtrl(IDC_FIND_NOW_PB), FALSE);
        ListView_DeleteAllItems(_hCtrl(IDC_QUERY_LISTVIEW));
        EnableWindow(_hCtrl(IDOK), FALSE);
        Animate_Play(m_hwndAnimation, 0, -1, -1);
        _StartQuery();
        break;

    case IDC_STOP_PB:
        Dbg(DEB_TRACE, "UA: (AdvancedDlg) hit Stop button\n");
        _StopQuery();
        Animate_Stop(m_hwndAnimation);
        Animate_Seek(m_hwndAnimation, 0);
        EnableWindow(_hCtrl(IDC_FIND_NOW_PB), TRUE);
        SetFocus(_hCtrl(IDC_QUERY_LISTVIEW));
        EnableWindow(_hCtrl(IDC_STOP_PB), FALSE);
        break;

    case IDOK:
        _OnOk();
        m_pvSelectedObjects = NULL;
        EndDialog(GetHwnd(), TRUE);
        break;

    case IDCANCEL:
        Dbg(DEB_TRACE, "UA: (AdvancedDlg) hit Cancel\n");
        _StopQuery();
        m_pvSelectedObjects = NULL;
        EndDialog(GetHwnd(), FALSE);
        break;

    default:
        fHandled = FALSE;
        Dbg(DEB_WARN,
            "CAdvancedDlg WM_COMMAND code=%#x, id=%#x, hwnd=%#x\n",
            HIWORD(wParam),
            LOWORD(wParam),
            lParam);
        break;
    }

    return fHandled;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_OnNotify
//
//  Synopsis:   Handle UI change notification
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CAdvancedDlg::_OnNotify(
    WPARAM wParam,
    LPARAM lParam)
{
    LPNMHDR pnmh = reinterpret_cast<LPNMHDR> (lParam);
    BOOL    fReturn = FALSE;

    switch (pnmh->code)
    {
    case LVN_ITEMCHANGED:
        EnableWindow(_hCtrl(IDOK), ListView_GetSelectedCount(pnmh->hwndFrom));
        break;

#ifdef QUERY_BUILDER
    case TCN_SELCHANGE:
        Dbg(DEB_TRACE,
            "UA: (AdvancedDlg) select tab %d\n",
            TabCtrl_GetCurSel(_hCtrl(IDC_TAB)));

        if (!TabCtrl_GetCurSel(_hCtrl(IDC_TAB)))
        {
            m_CommonQueriesTab.Show();
            m_QueryBuilderTab.Hide();
            m_pCurTab = &m_CommonQueriesTab;
        }
        else
        {
            ASSERT(TabCtrl_GetCurSel(_hCtrl(IDC_TAB)) == 1);
            m_CommonQueriesTab.Hide();
            m_QueryBuilderTab.Show();
            m_pCurTab = &m_QueryBuilderTab;
        }
        break;
#endif // QUERY_BUILDER

    default:
/*
        Dbg(DEB_ITRACE,
            "WM_NOTIFY idCtrl=%u hwndFrom=%#x code=%d\n",
            wParam,
            ((LPNMHDR)lParam)->hwndFrom,
            ((LPNMHDR)lParam)->code);
*/
        break;
    }

    return fReturn;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_OnHelp
//
//  Synopsis:   Handle the WM_HELP or WM_CONTEXTMENU message
//
//  Arguments:  [message] - WM_HELP or WM_CONTEXTMENU
//              [wParam]  - standard windows
//              [lParam]  - standard windows
//
//  History:    06-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CAdvancedDlg, _OnHelp);

    HMENU hmenu = NULL;

    //
    // If the window in which this was invoked was the header or listview
    // window, display a context menu containing an item to invoke the
    // column picker.
    //

    do
    {
        if (message == WM_HELP)
        {
            InvokeWinHelp(message, wParam, lParam, c_wzHelpFilename, s_aulHelpIds);
            break;
        }
        ASSERT(message == WM_CONTEXTMENU);

        HWND hwndClickedIn = reinterpret_cast<HWND>(wParam);

        if (hwndClickedIn != _hCtrl(IDC_QUERY_LISTVIEW))
        {
            break;
        }

        //
        // Column chooser not supported in downlevel mode
        //

        if (IsDownlevel(m_rop.GetScopeManager().GetCurScope()))
        {
            break;
        }

        hmenu = CreatePopupMenu();

        if (!hmenu)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        String strMenuItem = String::load(IDS_CHOOSE_COLUMNS);

        if (strMenuItem.empty())
        {
            break;
        }

        UINT uiFlags = MF_STRING;

        if (!IsWindowEnabled(_hCtrl(IDC_TAB)))
        {
            uiFlags |= (MF_GRAYED | MF_DISABLED);
        }

        BOOL fOk = AppendMenu(hmenu, uiFlags, 101, strMenuItem.c_str());

        if (!fOk)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        int x = GET_X_LPARAM(lParam);
        int y = GET_Y_LPARAM(lParam);

        if (x == -1 || y == -1)
        {
            Dbg(DEB_TRACE, "UA: WM_CONTEXTMENU generated via keyboard\n");
            HWND hwndFocus = GetFocus();
            RECT rc;

            if (GetWindowRect((hwndFocus ? hwndFocus : m_hwnd), &rc))
            {
                x = (rc.left + rc.right) / 2;
                y = (rc.top + rc.bottom) / 2;
            }
            else
            {
                DBG_OUT_LASTERROR;
                break;
            }
        }

        BOOL fReturn = TrackPopupMenu(hmenu,
                                      TPM_NONOTIFY | TPM_RETURNCMD,
                                      x,
                                      y,
                                      0,
                                      m_hwnd,
                                      NULL);

        if (!fReturn)
        {
            Dbg(DEB_TRACE, "UA: user cancelled context menu\n");
            break;
        }

        _InvokeColumnChooser();
    } while (0);

    if (hmenu)
    {
        VERIFY(DestroyMenu(hmenu));
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_InvokeColumnChooser
//
//  Synopsis:   Present the column chooser dialog and allow the user to
//              change the set of columns displayed in the listview.
//
//  History:    07-31-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_InvokeColumnChooser()
{
    //
    // Invoke the column chooser dialog
    //

    AttrKeyVector vakNew(m_vakListviewColumns);
    CColumnPickerDlg Dlg(m_rop, &vakNew);

    BOOL fMadeChanges = Dlg.DoModal(m_hwnd);

    if (!fMadeChanges)
    {
        return;
    }

    //
    // Remove all items from the listview
    //

    HWND hwndLV = _hCtrl(IDC_QUERY_LISTVIEW);
    ListView_DeleteAllItems(hwndLV);

    //
    // Remove all listview columns
    //

    int i;

    for (i = 0; i < m_vakListviewColumns.size(); i++)
    {
        ListView_DeleteColumn(hwndLV, 0);
    }

    //
    // Insert new set of columns
    //

    m_vakListviewColumns = vakNew;

    for (i = 0; i < m_vakListviewColumns.size(); i++)
    {
        _AddColToListview(m_vakListviewColumns[i]);
    }

    //
    // Disable the OK button, since the listview is empty
    //

    if (GetFocus() == _hCtrl(IDOK))
    {
        SetFocus(_hCtrl(IDCANCEL));
    }
    EnableWindow(_hCtrl(IDOK), FALSE);
}



//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_StartQuery
//
//  Synopsis:   Ensure the dialog is in resizeable mode and ask the
//              QueryEngine to start an asynchronous query (an LDAP query or
//              a WinNT enumeration).
//
//  History:    06-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_StartQuery()
{
    TRACE_METHOD(CAdvancedDlg, _StartQuery);

    //
    // Ask the current tab for any extra columns we should have
    //

    AttrKeyVector vakTabColumns;

    m_pCurTab->GetDefaultColumns(&vakTabColumns);

    AttrKeyVector::iterator itCol;

    for (itCol = vakTabColumns.begin(); itCol != vakTabColumns.end(); itCol++)
    {
        _AddColIfNotPresent(*itCol);
    }

    //
    // Disable look for, look in, and tabs
    //

    EnableWindow(_hCtrl(IDC_LOOK_FOR_PB), FALSE);
    EnableWindow(_hCtrl(IDC_LOOK_IN_PB), FALSE);
    EnableWindow(_hCtrl(IDC_COLUMNS_PB), FALSE);
    EnableWindow(_hCtrl(IDC_TAB), FALSE);
    m_pCurTab->Disable();

    //
    // If current scope is downlevel perform an enumeration
    //

    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rCurScope = rsm.GetCurScope();

    if (rCurScope.Type() == ST_INVALID)
    {
        Dbg(DEB_ERROR, "Cur scope invalid, can't do query\n");
        return;
    }

    //
    // Display "Searching..." in the banner window
    //

    _ShowBanner(SWP_SHOWWINDOW, IDS_SEARCHING);

    //
    // Kick off the query in the worker thread
    //

    if (IsDownlevel(rCurScope))
    {
        _StartWinNtQuery();
    }
    else
    {
        _StartLdapQuery();
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_StartWinNtQuery
//
//  Synopsis:   Ask the QueryEngine to perform an asynchronous WinNT
//              enumeration
//
//  History:    06-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_StartWinNtQuery()
{
    TRACE_METHOD(CAdvancedDlg, _StartWinNtQuery);

    const CQueryEngine &rqe = m_rop.GetQueryEngine();
    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rCurScope = rsm.GetCurScope();
    const CWinNtScope *pCurScopeWinNt =
        dynamic_cast<const CWinNtScope *>(&rCurScope);
    const CFilterManager &rfm = m_rop.GetFilterManager();

    do
    {
        if (!pCurScopeWinNt)
        {
            Dbg(DEB_ERROR,
                "Current scope '%ws' is not WinNT container\n",
                rCurScope.GetDisplayName().c_str());
            break;
        }

        SQueryParams qp;
        HRESULT hr;

        hr = pCurScopeWinNt->GetADsPath(m_hwnd, &qp.strADsPath);
        BREAK_ON_FAIL_HRESULT(hr);

        qp.rpScope = const_cast<CScope *>(&rCurScope);
        qp.vakAttributesToRead.push_back(AK_NAME);
        qp.vakAttributesToRead.push_back(AK_ADSPATH);
        qp.vakAttributesToRead.push_back(AK_OBJECT_CLASS);
        qp.hwndCredPromptParentDlg = m_hwnd;
        qp.hwndNotify = m_hwnd;
        qp.Limit = QL_NO_LIMIT;
        rfm.GetWinNtFilter(m_hwnd, rCurScope, &qp.vstrWinNtFilter);
        qp.CustomizerInteraction = CUSTINT_INCLUDE_ALL_CUSTOM_OBJECTS;

        hr = rqe.AsyncDirSearch(qp, &m_usnLatestQueryWorkItem);
        BREAK_ON_FAIL_HRESULT(hr);

    } while (0);
}



//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_StartLdapQuery
//
//  Synopsis:   Ask the QueryEngine to perform an asynchronous LDAP query
//
//  History:    06-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_StartLdapQuery()
{
    TRACE_METHOD(CAdvancedDlg, _StartLdapQuery);

    const CQueryEngine &rqe = m_rop.GetQueryEngine();
    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rCurScope = rsm.GetCurScope();
    const CLdapContainerScope *pCurScopeLdap =
        dynamic_cast<const CLdapContainerScope *>(&rCurScope);

    if (!pCurScopeLdap)
    {
        Dbg(DEB_ERROR,
            "Current scope '%ws' is not LDAP container\n",
            rCurScope.GetDisplayName().c_str());
        return;
    }

    SQueryParams qp;

    HRESULT hr = pCurScopeLdap->GetADsPath(m_hwnd, &qp.strADsPath);
    RETURN_ON_FAIL_HRESULT(hr);

    qp.strLdapFilter = m_pCurTab->GetLdapFilter();
    qp.rpScope = const_cast<CScope *>(&rCurScope);
    qp.ADsScope = ADS_SCOPE_SUBTREE;
    qp.hwndCredPromptParentDlg = m_hwnd;
    qp.hwndNotify = m_hwnd;
    qp.Limit = QL_USE_REGISTRY_LIMIT;
    m_pCurTab->GetCustomizerInteraction(&qp.CustomizerInteraction,
                                        &qp.strCustomizerArg);
    qp.vakAttributesToRead = AttributesFromColumns(m_vakListviewColumns);

    //
    // If there is an LDAP filter, tack on a bit to prevent disabled
    // objects from being returned, if applicable.
    //

    if (!qp.strLdapFilter.empty() && g_fExcludeDisabled)
    {
        qp.strLdapFilter.insert(0, L"(&");
        qp.strLdapFilter += L"(!";
        qp.strLdapFilter += c_wzDisabledUac;
        qp.strLdapFilter += L"))";
    }

    const CFilterManager &rfm = m_rop.GetFilterManager();

    if (rfm.GetCurScopeSelectedFilterFlags() &
        (DSOP_FILTER_CONTACTS | DSOP_FILTER_USERS))
    {
        AddIfNotPresent(&qp.vakAttributesToRead, AK_USER_PRINCIPAL_NAME);
    }

    // Dbg(DEB_TRACE, "ldap filter: \n%ws\n", qp.strLdapFilter.c_str());
    
    hr = rqe.AsyncDirSearch(qp, &m_usnLatestQueryWorkItem);
    CHECK_HRESULT(hr);
}




//+--------------------------------------------------------------------------
//
//  Function:   AttributesFromColumns
//
//  Synopsis:   Return a vector of ATTR_KEYs which is a copy of
//              [vakListviewColumns] modified so that it doesn't contain any
//              duplicates, and all synthesized attributes are replaced by
//              the non-synthesized attributes on which they depend.
//
//  Arguments:  [vakListviewColumns] - vector of attribute keys representing
//                                      the columns to display in a listview
//
//  Returns:    Modified copy of [vakListviewColumns].
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

AttrKeyVector
AttributesFromColumns(
    const AttrKeyVector &vakListviewColumns)
{
    TRACE_FUNCTION(AttributesFromColumns);

    AttrKeyVector vak;
    AttrKeyVector::const_iterator it;

    for (it = vakListviewColumns.begin();
         it != vakListviewColumns.end();
         it++)
    {
        switch (*it)
        {
        case AK_FLAGS:
        case AK_USER_ENTERED_TEXT:
        case AK_PROCESSED_ADSPATH:
            ASSERT(0 && "unexpected synthesized attribute key in column vector");
            break;

        case AK_LOCALIZED_NAME:
        case AK_NAME:
        case AK_DISPLAY_PATH:
            // These are always added, see below
            break;

        default:
            AddIfNotPresent(&vak, *it);
            break;
        }
    }

    //
    // There are a few attributes which should always be read, add
    // them in regardless of whether they appear in the columns.
    //

    AddIfNotPresent(&vak, AK_NAME);
    AddIfNotPresent(&vak, AK_ADSPATH);
    AddIfNotPresent(&vak, AK_OBJECT_CLASS);
    AddIfNotPresent(&vak, AK_USER_ACCT_CTRL);

    return vak;
}



//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_OnNewBlock
//
//  Synopsis:   Handle a notification message from the query engine that it
//              has added more items to its buffer of objects.
//
//  Arguments:  [wParam] - number of rows in buffer
//              [lParam] - work item number the rows were fetched for
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_OnNewBlock(
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CAdvancedDlg, _OnNewBlock);

    ULONG cRowsInBuffer = static_cast<ULONG>(wParam);
    ULONG usnWorkItem = static_cast<ULONG>(lParam);

    // ignore notifications for old queries
    if (usnWorkItem != m_usnLatestQueryWorkItem)
    {
        Dbg(DEB_TRACE,
            "Ignoring notification for old work item %u, current is %u\n",
            usnWorkItem,
            m_usnLatestQueryWorkItem);
        return;
    }

    // add the rows that aren't already in the listview

    HWND hwndLv = _hCtrl(IDC_QUERY_LISTVIEW);
    ULONG cRowsInLv = ListView_GetItemCount(hwndLv);

    ASSERT(cRowsInBuffer >= cRowsInLv);

    //
    // If we're about to add items to the listview and it doesn't have any,
    // hide the banner window
    //

    if (cRowsInBuffer > cRowsInLv
        && m_hwndBanner
        && IsWindowVisible(m_hwndBanner))
    {
        ASSERT(!cRowsInLv);
        _ShowBanner(SWP_HIDEWINDOW, 0);
    }

    const CQueryEngine &rqe = m_rop.GetQueryEngine();
    const CAttributeManager &ram = m_rop.GetAttributeManager();

    ULONG idxRow;
    for (idxRow = cRowsInLv; idxRow < cRowsInBuffer; idxRow++)
    {
        CDsObject dso(rqe.GetObject(idxRow));
        LVITEM lvi;

        //
        // Skip disabled items if we're supposed to.  Even though we modify
        // the LDAP query to filter these out server-side, there's still
        // the customizer which might unknowingly supply disabled objects,
        // plus we could also get disabled objects via the WinNT provider.
        //

        if (g_fExcludeDisabled && dso.GetDisabled())
        {
            continue;
        }

        ZeroMemory(&lvi, sizeof lvi);
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.lParam = idxRow;
        lvi.pszText = dso.GetAttr(m_vakListviewColumns[0]).GetBstr();

        HRESULT hrImage;

        hrImage = ram.GetIconIndexFromObject(m_hwnd, dso, &lvi.iImage);

        if (SUCCEEDED(hrImage))
        {
            lvi.mask |= LVIF_IMAGE;
        }

        int iRet = ListView_InsertItem(hwndLv, &lvi);

        if (iRet == -1)
        {
            DBG_OUT_LASTERROR;
            continue;
        }

        size_t i;

        for (i = 1; i < m_vakListviewColumns.size(); i++)
        {
            ListView_SetItemText(hwndLv,
                                 iRet,
                                 static_cast<int>(i),
                                 const_cast<PWSTR>(dso.GetAttr(m_vakListviewColumns[i]).GetBstr()));
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_OnQueryDone
//
//  Synopsis:   Handle a notification from the query engine that it has
//              completed (or stopped) a query.
//
//  Arguments:  [wParam] - number of rows in buffer
//              [lParam] - work item number the rows were fetched for
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_OnQueryDone(
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CAdvancedDlg, _OnQueryDone);

    // ignore notifications for old queries
    if (lParam != (LPARAM)(m_usnLatestQueryWorkItem))
    {
        return;
    }

    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rCurScope = rsm.GetCurScope();

    _OnNewBlock(wParam, lParam);
    Animate_Stop(m_hwndAnimation);
    Animate_Seek(m_hwndAnimation, 0);
    EnableWindow(_hCtrl(IDC_FIND_NOW_PB), TRUE);
    EnableWindow(_hCtrl(IDC_LOOK_FOR_PB), TRUE);
    EnableWindow(_hCtrl(IDC_LOOK_IN_PB), TRUE);
    EnableWindow(_hCtrl(IDC_TAB), TRUE);

    if (IsUplevel(rCurScope))
    {
        EnableWindow(_hCtrl(IDC_COLUMNS_PB), TRUE);
    }

    m_pCurTab->Enable();

    if (ListView_GetItemCount(_hCtrl(IDC_QUERY_LISTVIEW)) <= 0)
    {
        CQueryEngine &rqe = m_rop.GetQueryEngine();
        HRESULT hrQuery = rqe.GetLastQueryResult();
        String strEmptyText;

        if (FAILED(hrQuery))
        {
            String strTemp = String::load(IDS_QUERY_ERROR);
            strEmptyText = String::format(strTemp.c_str(),
                                            GetErrorMessage(hrQuery).c_str());
        }
        else
        {
            strEmptyText = String::load(IDS_NOTHINGFOUND);
        }

        _ShowBanner(SWP_SHOWWINDOW, strEmptyText);

        if (GetFocus() == _hCtrl(IDC_STOP_PB))
        {
            SetFocus(_hCtrl(IDC_FIND_NOW_PB));
        }
    }
    else
    {
        ListView_SetItemState(_hCtrl(IDC_QUERY_LISTVIEW),
                              0,
                              LVIS_FOCUSED | LVIS_SELECTED,
                              LVIS_FOCUSED | LVIS_SELECTED);

        if (GetFocus() == _hCtrl(IDC_STOP_PB))
        {
            SetFocus(_hCtrl(IDC_QUERY_LISTVIEW));
        }
    }
    ASSERT(GetFocus() != _hCtrl(IDC_STOP_PB));
    EnableWindow(_hCtrl(IDC_STOP_PB), FALSE);
}




const ULONG c_ulStyle = LVS_EX_LABELTIP
                        | LVS_EX_FULLROWSELECT
                        | LVS_EX_HEADERDRAGDROP;

//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_ResizeableModeOn
//
//  Synopsis:   Make the listview visible and make the dialog window
//              resizeable
//
//  History:    06-14-2000   DavidMun   Created
//
//  Notes:      Once the dialog has entered resizeable mode, it stays in
//              that mode.
//
//---------------------------------------------------------------------------

HRESULT
CAdvancedDlg::_ResizeableModeOn()
{
    TRACE_METHOD(CAdvancedDlg, _ResizeableModeOn);

    if (m_fResizeableModeOn)
    {
        return S_OK;
    }

    HRESULT hr = _UpdateColumns();

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    m_fResizeableModeOn = TRUE;

    //
    // Double (roughly) the vertical client size
    //
	// NTRAID#NTBUG9-191862-2001/03/06-hiteshr
	// 
	//
	//
	GetClientRect(m_hwnd, &m_rcDlgOriginal);


	//
	//Get the workarea info. 
	//
	RECT rcWorkArea;
	SystemParametersInfo(SPI_GETWORKAREA,
						 NULL,
						 &rcWorkArea,
						 0);

	//
	//Limit the height of the dialog to WorkArea height
	//
	int yDlg = WindowRectHeight(m_rcDlgOriginal) * 17/10;

	if( yDlg > WindowRectHeight(rcWorkArea))
		yDlg = WindowRectHeight(rcWorkArea);

    SetWindowPos(m_hwnd,
                 NULL,
                 0,0,
                 WindowRectWidth(m_rcWrDlgOriginal),
                 yDlg,
                 SWP_NOMOVE | SWP_NOZORDER | SWP_NOOWNERZORDER);

    //
    // Resize, reposition, and make visible child listview
    //

    RECT rcDlgNew;
    GetClientRect(m_hwnd, &rcDlgNew);
    HWND hwndLv = _hCtrl(IDC_QUERY_LISTVIEW);

    SetWindowPos(hwndLv,
                 NULL,
                 rcDlgNew.left,
                 m_rcDlgOriginal.bottom,
                 rcDlgNew.right,
                 rcDlgNew.bottom - m_rcDlgOriginal.bottom,
                 SWP_NOZORDER | SWP_NOOWNERZORDER);

	//
	// If taskbar is covering listview move the dialog box up.
	//

	RECT rcDlgNewW;
	GetWindowRect(m_hwnd, &rcDlgNewW);
	if(rcDlgNewW.bottom > rcWorkArea.bottom)
	{
		SetWindowPos(m_hwnd,
					 NULL,
					 rcDlgNewW.left,
					 rcDlgNewW.top - (rcDlgNewW.bottom - rcWorkArea.bottom),
					 0,
					 0,
					 SWP_NOZORDER | SWP_NOOWNERZORDER |SWP_NOSIZE);
	}

    //
    // Initialize listview
    //

    ListView_SetExtendedListViewStyleEx(hwndLv, c_ulStyle, c_ulStyle);
    ShowWindow(hwndLv, SW_SHOW);

    //
    // Increase the minimum size so the listview can't be completely
    // hidden
    //

    DWORD dwLvMinSize = ListView_ApproximateViewRect(hwndLv, -1, -1, 1);
    m_cyMin += HIWORD(dwLvMinSize);

    RECT rcLv;
    _GetChildWindowRect(hwndLv, &rcLv);
    m_cxLvSeparation = rcDlgNew.right - rcLv.right;
    m_cyLvSeparation = rcDlgNew.bottom - rcLv.bottom;
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_StopQuery
//
//  Synopsis:   Ask the query engine to stop whatever query it's working on
//              and update the UI to reflect a stopping query.
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_StopQuery()
{
    const CQueryEngine &rqe = m_rop.GetQueryEngine();

    rqe.StopWorkItem();
    EnableWindow(_hCtrl(IDC_LOOK_FOR_PB), TRUE);
    EnableWindow(_hCtrl(IDC_LOOK_IN_PB), TRUE);
    EnableWindow(_hCtrl(IDC_TAB), TRUE);
    m_pCurTab->Enable();

    if (m_hwndBanner && IsWindowVisible(m_hwndBanner))
    {
        _ShowBanner(0, IDS_STOPPING_QUERY);
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_OnMinMaxInfo
//
//  Synopsis:   Respond to a WM_MINMAXINFO message based on whether the
//              dialog is in resizeable mode.
//
//  Arguments:  [lpmmi] - pointer to struct to fill with minimum and maximum
//                          allowed window size
//
//  Returns:    FALSE
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CAdvancedDlg::_OnMinMaxInfo(
    LPMINMAXINFO lpmmi)
{
    if (m_fResizeableModeOn)
    {
        lpmmi->ptMinTrackSize.x = m_cxMin;
        lpmmi->ptMinTrackSize.y = m_cyMin;
    }
    else
    {
        lpmmi->ptMaxTrackSize.x = m_cxMin - 1;
        lpmmi->ptMaxTrackSize.y = m_cyMin - 1;
        lpmmi->ptMinTrackSize.x = m_cxMin - 1;
        lpmmi->ptMinTrackSize.y = m_cyMin - 1;
    }
    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_OnSize
//
//  Synopsis:   Handle a WM_SIZE message.
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CAdvancedDlg::_OnSize(
    WPARAM wParam,
    LPARAM lParam)
{
    if (!m_fResizeableModeOn)
    {
        return TRUE;
    }

    RECT rcDlg;
    GetClientRect(m_hwnd, &rcDlg);

    if (!m_cxFrameLast || !m_cyFrameLast)
    {
        Dbg(DEB_TRACE, "FrameLast not set yet, returning\n");
        m_cxFrameLast = rcDlg.right;
        m_cyFrameLast = rcDlg.bottom;
        return TRUE;
    }

    LONG cxDelta = rcDlg.right - m_cxFrameLast;

    //
    // Move the OK/Cancel buttons so they're always at lower right
    // corner of upper half of dialog.
    //

    RECT rcCancel;
    RECT rcLv;

    GetWindowRect(_hCtrl(IDCANCEL), &rcCancel);
    _GetChildWindowRect(_hCtrl(IDC_QUERY_LISTVIEW), &rcLv);

    SetWindowPos(_hCtrl(IDCANCEL),
                 NULL,
                 rcDlg.right - WindowRectWidth(rcCancel) - m_cxSeparation,
                 rcLv.top - WindowRectHeight(rcCancel) - m_cySeparation,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    RECT rcOk;
    _GetChildWindowRect(_hCtrl(IDOK), &rcOk);
    _GetChildWindowRect(_hCtrl(IDCANCEL), &rcCancel);

    SetWindowPos(_hCtrl(IDOK),
                 NULL,
                 rcCancel.left - WindowRectWidth(rcCancel) - m_cxFour,
                 rcCancel.top,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    //
    // Find now, Columns, and stop buttons never change their vertical
    // position; their right edge stays aligned with the Cancel button.
    //

    RECT rcFindNow;
    _GetChildWindowRect(_hCtrl(IDC_FIND_NOW_PB), &rcFindNow);

    SetWindowPos(_hCtrl(IDC_FIND_NOW_PB),
                 NULL,
                 rcCancel.right - WindowRectWidth(rcFindNow),
                 rcFindNow.top,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    RECT rcStop;
    _GetChildWindowRect(_hCtrl(IDC_STOP_PB), &rcStop);

    SetWindowPos(_hCtrl(IDC_STOP_PB),
                 NULL,
                 rcCancel.right - WindowRectWidth(rcStop),
                 rcStop.top,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    RECT rcColumns;
    _GetChildWindowRect(_hCtrl(IDC_COLUMNS_PB), &rcColumns);

    SetWindowPos(_hCtrl(IDC_COLUMNS_PB),
                 NULL,
                 rcCancel.right - WindowRectWidth(rcColumns),
                 rcColumns.top,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);


    //
    // Animate control is always centered beneath the stop PB
    //

    RECT rcAni;
    _GetChildWindowRect(m_hwndAnimation, &rcAni);

    SetWindowPos(m_hwndAnimation,
                 NULL,
                 rcCancel.left +
                    (WindowRectWidth(rcStop) - 64) / 2,
                 rcStop.bottom + m_cySeparation,
                 64,
                 64,
                 SWP_NOOWNERZORDER
                 | SWP_NOZORDER);

    //
    // Resize tab control
    //

    RECT rcTab;
    _GetChildWindowRect(_hCtrl(IDC_TAB), &rcTab);

    SetWindowPos(_hCtrl(IDC_TAB),
                 NULL,
                 0,
                 0,
                 WindowRectWidth(rcTab) + cxDelta,
                 WindowRectHeight(rcTab),
                 SWP_NOMOVE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    //
    // Resize listview
    //

    SetWindowPos(_hCtrl(IDC_QUERY_LISTVIEW),
                 NULL,
                 0,
                 0,
                 rcDlg.right - m_cxLvSeparation,
                 rcDlg.bottom - rcLv.top - m_cyLvSeparation,
                 SWP_NOMOVE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);


    //
    // Resize look in edit and button
    //

    RECT rcLookIn;
    _GetChildWindowRect(_hCtrl(IDC_LOOK_IN_EDIT), &rcLookIn);

    SetWindowPos(_hCtrl(IDC_LOOK_IN_EDIT),
                 NULL,
                 0,
                 0,
                 WindowRectWidth(rcLookIn) + cxDelta,
                 WindowRectHeight(rcLookIn),
                 SWP_NOMOVE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

	_GetChildWindowRect(_hCtrl(IDC_LOOK_IN_EDIT), &rcLookIn);
	RECT rcLookInPb;
	_GetChildWindowRect(_hCtrl(IDC_LOOK_IN_PB), &rcLookInPb);

	//
	//Button's left is FOUR DLU right of Edit's Right
	//

	SetWindowPos(_hCtrl(IDC_LOOK_IN_PB),
                 NULL,
                 rcLookIn.right + m_cxFour,
                 rcLookInPb.top,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);


	//
    // Resize look for(locations) edit and button
    //

    RECT rcLookFor;
    _GetChildWindowRect(_hCtrl(IDC_LOOK_FOR_EDIT), &rcLookFor);

    SetWindowPos(_hCtrl(IDC_LOOK_FOR_EDIT),
                 NULL,
                 0,
                 0,
                 WindowRectWidth(rcLookFor) + cxDelta,
                 WindowRectHeight(rcLookFor),
                 SWP_NOMOVE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

	
	_GetChildWindowRect(_hCtrl(IDC_LOOK_FOR_EDIT), &rcLookFor);
	RECT rcLookForPb;
	_GetChildWindowRect(_hCtrl(IDC_LOOK_FOR_PB), &rcLookForPb);

	SetWindowPos(_hCtrl(IDC_LOOK_FOR_PB),
                 NULL,
                 rcLookFor.right + m_cxFour,
                 rcLookForPb.top,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);


    //
    // Update the saved size of the advanced dialog
    //

    m_cxFrameLast = rcDlg.right;
    m_cyFrameLast = rcDlg.bottom;

    //
    // Force banner to resize
    //

    _ShowBanner(0, 0);

    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::FindValidCallback
//
//  Synopsis:   Called by child dialog to enable or disable the find now
//              button.
//
//  Arguments:  [fValid] - TRUE=>enable Find Now, FALSE=>disable
//              [lParam] - pointer to this
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::FindValidCallback(
    BOOL fValid,
    LPARAM lParam)
{
    TRACE_FUNCTION(FindValidCallback);

    CAdvancedDlg *pThis = reinterpret_cast<CAdvancedDlg *>(lParam);
    EnableWindow(pThis->_hCtrl(IDC_FIND_NOW_PB), fValid);
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_OnOk
//
//  Synopsis:   Stop any query in progress and fill the output vector with
//              the items in the listview which are selected.
//
//  History:    06-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_OnOk()
{
    TRACE_METHOD(CAdvancedDlg, _OnOk);
    HWND hwndLV = _hCtrl(IDC_QUERY_LISTVIEW);
    const CQueryEngine &rqe = m_rop.GetQueryEngine();

    rqe.StopWorkItem();

    //
    // Copy each of the ds objects whose item in the listview is
    // selected to the output list.
    //

    LVITEM lvi;
    int iItem = -1;
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_PARAM;

    while ((iItem = ListView_GetNextItem(hwndLV,
                                         iItem,
                                         LVNI_SELECTED)) != -1)
    {
        lvi.iItem = iItem;
        ListView_GetItem(hwndLV, &lvi);
        m_pvSelectedObjects->push_back(rqe.GetObject(lvi.lParam));
    }

    ASSERT(!m_pvSelectedObjects->empty());

    Dbg(DEB_TRACE,
        "UA: (AdvancedDlg) hit OK, %u items in output vector, first is %ws\n",
        m_pvSelectedObjects->size(),
        m_pvSelectedObjects->front().GetName());

    //
    // No need to leave a large buffer of query results lying around
    //

    rqe.Clear();
}




//+--------------------------------------------------------------------------
//
//  Function:   _BannerWndProc
//
//  Synopsis:   Paint the current message inside the banner window.
//
//  Arguments:  standard Windows
//
//  Returns:    standard Windows
//
//  History:    06-22-2000   DavidMun   Ported from DS Find source
//
//  Notes:      The banner window covers the top portion of the listview's
//              client area when the listview is empty.  Its purpose is to
//              display some text that indicates why the listview is empty.
//
//---------------------------------------------------------------------------

LRESULT CALLBACK
_BannerWndProc(
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT lResult = 0;

    switch ( uMsg )
    {
        case WM_SIZE:
            InvalidateRect(hwnd, NULL, FALSE);
            break;

        case WM_ERASEBKGND:
           // NTRAID#NTBUG9-421812-2001/06/22-lucios - Begin
           // The background must be explicitly erased here 
           // since this window's brush is NULL
           RECT rect;
           GetClientRect(hwnd,&rect);
           FillRect(
                        (HDC)wParam,
                        &rect,
                        static_cast<HBRUSH>
                        (
                           LongToHandle
                           (
                              ListView_GetBkColor(GetParent(hwnd))+1
                           )
                        )
                    );
           lResult=1;
           break;
           // NTRAID#NTBUG9-421812-2001/06/22-lucios - Begin
        case WM_PAINT:
        {
            HFONT hFont, hOldFont;
            RECT rcClient;
            PAINTSTRUCT paint;
            COLORREF oldFgColor, oldBkColor;

            BeginPaint(hwnd, &paint);

            hFont = (HFONT)SendMessage(GetParent(hwnd), WM_GETFONT, 0, 0L);
            hOldFont = (HFONT)SelectObject(paint.hdc, hFont);

            if ( hOldFont )
            {
                oldFgColor = SetTextColor(paint.hdc, GetSysColor(COLOR_WINDOWTEXT));
                oldBkColor = SetBkColor(paint.hdc, ListView_GetBkColor(GetParent(hwnd)));

                int cch = GetWindowTextLength(hwnd);
                String strText;

                if (cch > 0)
                {
                    PWSTR pwz = new WCHAR [cch + 1];
                    int iRet = GetWindowText(hwnd, pwz, cch + 1);
                    if (iRet)
                    {
                        strText = pwz;
                    }
                    else
                    {
                        DBG_OUT_LASTERROR;
                    }
                    delete [] pwz;
                }

                if (!strText.empty())
                {
                    GetClientRect(GetParent(hwnd), &rcClient);
                    int iRet;

                    // NTRAID#NTBUG9-421812-2001/06/22-lucios - Begin
                    // Now we center unconditionally since the previous calculation
                    // does not work for error messages with \n's
                    iRet = DrawTextEx(paint.hdc,
                                      const_cast<PWSTR>(strText.c_str()),
                                      cch,
                                      &rcClient,
                                      DT_WORDBREAK | DT_TOP |DT_CENTER,
                                      NULL);
                    // NTRAID#NTBUG9-421812-2001/06/22-lucios - End
                    if (!iRet)
                    {
                        DBG_OUT_LASTERROR;
                    }
                }

                SetTextColor(paint.hdc, oldFgColor);
                SetBkColor(paint.hdc, oldBkColor);
                SelectObject(paint.hdc, hOldFont);
            }

            EndPaint(hwnd, &paint);
            break;
        }

        case WM_SETTEXT:
        {
            InvalidateRect(hwnd, NULL, TRUE);
            //break;                                // deliberate drop through..
        }

        default:
            lResult = DefWindowProc(hwnd, uMsg, wParam, lParam);
            break;
    }

    return lResult;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_ShowBanner
//
//  Synopsis:   Show or hide the banner window.
//
//  Arguments:  [ulFlags]   - 0 to leave visibility unchanged
//                             SW_SHOW to make banner window visible
//                             SW_HIDE to hide banner window
//              [idsPrompt] - 0 or the ID of a resource string to load and
//                             display in the window.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_ShowBanner(
    ULONG ulFlags,
    ULONG idsPrompt)
{
    String strMsg;

    if (idsPrompt)
    {
        strMsg = String::load(static_cast<int>(idsPrompt));
    }

    _ShowBanner(ulFlags, strMsg);
}




/*-----------------------------------------------------------------------------
/ CAdvancedDlg::_ShowBanner
/ --------------------
/   Show the views banner, including sizing it to obscure only the top section
/   of the window.
/
/ In:
/   uFlags = flags to combine when calling SetWindowPos
/   idPrompt = resource ID of prompt text ot be displayed
/
/----------------------------------------------------------------------------*/
void
CAdvancedDlg::_ShowBanner(
    ULONG ulFlags,
    const String &strMsg)
{
    TRACE_METHOD(CAdvancedDlg, _ShowBanner);

    WINDOWPOS wpos;
    RECT rcClient;
    HD_LAYOUT hdl;

    do
    {
        if (!m_hwndBanner)
        {
            break;
        }

        // if we have a resource id then lets load the string and
        // set the window text to have it

        if (!strMsg.empty())
        {
            SetWindowText(m_hwndBanner, strMsg.c_str());
        }

        // now position the window back to real location, this we need to
        // talk to the listview/header control to work out exactly where it
        // should be living

        GetClientRect(_hCtrl(IDC_QUERY_LISTVIEW), &rcClient);

        wpos.hwnd = ListView_GetHeader(_hCtrl(IDC_QUERY_LISTVIEW));

        if (!IsWindow(wpos.hwnd))
        {
            if (strMsg.empty())
            {
                Dbg(DEB_ERROR,
                    "error: no header; can't set window flags %#x\n",
                    ulFlags);
            }
            else
            {
                Dbg(DEB_ERROR,
                    "error: no header; can't display '%ws'\n",
                    strMsg.c_str());
            }
            break;
        }

        wpos.hwndInsertAfter = NULL;
        wpos.x = 0;
        wpos.y = 0;
        wpos.cx = rcClient.right;
        wpos.cy = rcClient.bottom;
        wpos.flags = SWP_NOZORDER;

        hdl.prc = &rcClient;
        hdl.pwpos = &wpos;

        if ( !Header_Layout(wpos.hwnd, &hdl) )
        {
            DBG_OUT_LASTERROR;
            break;
        }

        SetWindowPos(m_hwndBanner,
                     HWND_TOP,
                     rcClient.left, rcClient.top,
                     rcClient.right - rcClient.left, 100,
                     ulFlags);
    } while (0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_UpdateColumns
//
//  Synopsis:   For all classes checked in the Look For since last visit,
//              add their default columns, remove columns that now refer
//              to classes which are no longer selected.
//
//  History:    06-15-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CAdvancedDlg::_UpdateColumns()
{
    TRACE_METHOD(CAdvancedDlg, _UpdateColumns);

    HRESULT hr = S_OK;
    size_t i = 0;
    HWND hwndLV = _hCtrl(IDC_QUERY_LISTVIEW);

    //
    // If we're in downlevel mode, only two columns are allowed: name and
    // display path
    //

    if (IsDownlevel(m_rop.GetScopeManager().GetCurScope()))
    {
        while (i < m_vakListviewColumns.size())
        {
            if (m_vakListviewColumns[i] != AK_NAME &&
                m_vakListviewColumns[i] != AK_DISPLAY_PATH)
            {
                ListView_DeleteColumn(hwndLV, i);
                m_vakListviewColumns.erase(m_vakListviewColumns.begin() + i);
            }
            else
            {
                i++;
            }
        }

        _AddColIfNotPresent(AK_NAME);
        _AddColIfNotPresent(AK_DISPLAY_PATH);
        m_ulPrevFilterFlags = 0;
        return hr;
    }

    //
    // For each of the selected classes that have been added since the
    // last time we were here, add the default set of attributes for that
    // class to the listview.
    //

    const CFilterManager &rfm = m_rop.GetFilterManager();
    ULONG ulCurFilterFlags = rfm.GetCurScopeSelectedFilterFlags();
    const CAttributeManager &ram = m_rop.GetAttributeManager();

    if ((ulCurFilterFlags & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS) &&
        !(m_ulPrevFilterFlags & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS))
    {
        _AddColIfNotPresent(AK_NAME);
    }

    if ((ulCurFilterFlags & DSOP_FILTER_USERS) &&
        !(m_ulPrevFilterFlags & DSOP_FILTER_USERS))
    {
        hr = ram.EnsureAttributesLoaded(m_hwnd, FALSE, c_wzUserObjectClass);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            return hr;
        }

        _AddColIfNotPresent(AK_NAME);
        _AddColIfNotPresent(AK_EMAIL_ADDRESSES);
    }

    if ((ulCurFilterFlags & DSOP_FILTER_COMPUTERS) &&
        !(m_ulPrevFilterFlags & DSOP_FILTER_COMPUTERS))
    {
        hr = ram.EnsureAttributesLoaded(m_hwnd, FALSE, c_wzComputerObjectClass);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            return hr;
        }

        _AddColIfNotPresent(AK_NAME);
        _AddColIfNotPresent(AK_DESCRIPTION);
    }

    if ((ulCurFilterFlags & ALL_UPLEVEL_GROUP_FILTERS) &&
        !(m_ulPrevFilterFlags & ALL_UPLEVEL_GROUP_FILTERS))
    {
        hr = ram.EnsureAttributesLoaded(m_hwnd, FALSE, c_wzGroupObjectClass);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            return hr;
        }

        _AddColIfNotPresent(AK_NAME);
        _AddColIfNotPresent(AK_DESCRIPTION);
    }

    if ((ulCurFilterFlags & DSOP_FILTER_CONTACTS) &&
        !(m_ulPrevFilterFlags & DSOP_FILTER_CONTACTS))
    {
        hr = ram.EnsureAttributesLoaded(m_hwnd, FALSE, c_wzContactObjectClass);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            return hr;
        }

        _AddColIfNotPresent(AK_NAME);
        _AddColIfNotPresent(AK_SAMACCOUNTNAME);
        _AddColIfNotPresent(AK_EMAIL_ADDRESSES);
        _AddColIfNotPresent(AK_COMPANY);
    }

    _AddColIfNotPresent(AK_DISPLAY_PATH);

    m_ulPrevFilterFlags = ulCurFilterFlags;

    //
    // For each of the columns, if there are no selected classes in that
    // column's attribute's owning class list, remove that column.
    //

    vector<String> vstrSelectedClasses;
    String::EqualIgnoreCase comp;
    i = 0;

    ram.GetSelectedClasses(&vstrSelectedClasses);

    while (i < m_vakListviewColumns.size())
    {
        const vector<String> &vstrOwning =
            ram.GetOwningClasses(m_vakListviewColumns[i]);

        if (!vstrOwning.empty() && !vstrOwning[0].icompare(L"*"))
        {
            i++;
            continue;
        }

        vector<String>::const_iterator itFound;

        itFound = find_first_of(vstrOwning.begin(),
                                vstrOwning.end(),
                                vstrSelectedClasses.begin(),
                                vstrSelectedClasses.end(),
                                comp);

        if (itFound == vstrOwning.end())
        {
            ListView_DeleteColumn(hwndLV, i);
            m_vakListviewColumns.erase(m_vakListviewColumns.begin() + i);
        }
        else
        {
            i++;
        }
    }



    //
    // Insert new set of columns
    //
    for (i = 0; i < m_vakListviewColumns.size(); i++)
    {
		const String &strAttrDisplayName = ram.GetAttrDisplayName(m_vakListviewColumns[i]);
		LVCOLUMN col;
		ZeroMemory(&col, sizeof col);
		col.mask = LVCF_TEXT;
		col.pszText = const_cast<PWSTR>(strAttrDisplayName.c_str());
        ListView_SetColumn(hwndLV,
						   i,
						   &col);
    }

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_AddColIfNotPresent
//
//  Synopsis:   If the column with key [ak] isn't already in the vector of
//              attributes m_vakListViewColumns and to the listview itself.
//
//  Arguments:  [ak]   - ATTR_KEY of attribute to add
//              [iPos] - 0 based position to insert column into listview
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_AddColIfNotPresent(
    ATTR_KEY ak,
    int iPos)
{
    BOOL fAdded = AddIfNotPresent(&m_vakListviewColumns, ak);

    if (!fAdded)
    {
        return;
    }

    _AddColToListview(ak, iPos);
}



//+--------------------------------------------------------------------------
//
//  Member:     CAdvancedDlg::_AddColToListview
//
//  Synopsis:   Add column with key [ak] to listview at position [iPos].
//
//  Arguments:  [ak]   - ATTR_KEY representing attribute
//              [iPos] - 0 based position to insert column into listview
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAdvancedDlg::_AddColToListview(
    ATTR_KEY ak,
    int iPos)
{
    LV_COLUMN   lvc;
    ZeroMemory(&lvc, sizeof lvc);
    lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt  = LVCFMT_LEFT;
    lvc.cx = 100;

    const CAttributeManager &ram = m_rop.GetAttributeManager();
    const String &strAttrDisplayName = ram.GetAttrDisplayName(ak);

    lvc.pszText = const_cast<PWSTR>(strAttrDisplayName.c_str());
    int iResult = ListView_InsertColumn(_hCtrl(IDC_QUERY_LISTVIEW),
                                        iPos,
                                        &lvc);
    if (iResult == -1)
    {
        DBG_OUT_LASTERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\basedlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       BaseDlg.cxx
//
//  Contents:   Implementation of class to drive the base object picker
//              dialog.
//
//  Classes:    CBaseDlg
//
//  History:    05-02-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

static ULONG
s_aulHelpIds[] =
{
	IDC_OBJECT_TYPE_LBL,	IDH_LOOK_FOR_EDIT,
    IDC_LOOK_FOR_PB,        IDH_LOOK_FOR_PB,
    IDC_LOOK_FOR_EDIT,      IDH_LOOK_FOR_EDIT,
    IDC_LOOK_IN_PB,         IDH_LOOK_IN_PB,
	IDC_LOCATION_LBL,		IDH_LOOK_IN_EDIT,
    IDC_LOOK_IN_EDIT,       IDH_LOOK_IN_EDIT,
    IDC_NAME_LBL,           IDH_NAME_LBL,
    IDC_RICHEDIT,           IDH_RICHEDIT,
    IDC_CHECK_NAMES_PB,     IDH_CHECK_NAMES_PB,
    IDC_ADVANCED_PB,        IDH_ADVANCED_PB,
    0,0
};


#define CY_SLE_IN_DLUS      6


#define LINKWINDOW_CLASSW       L"Link Window"



//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::CBaseDlg
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - reference to owning CObjectPicker instance
//
//  History:    05-02-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CBaseDlg::CBaseDlg(
    const CObjectPicker &rop):
        m_rop(rop),
        m_AdvancedDlg(rop)
{
    TRACE_CONSTRUCTOR(CBaseDlg);

    Clear();
}



//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::Clear
//
//  Synopsis:   Reset all internal variables (used for both initialization
//              and shutdown).
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CBaseDlg::Clear()
{
    TRACE_METHOD(CBaseDlg, Clear);

    m_hpenUnderline = NULL;
    m_ppdoSelections = NULL;
    m_cxMin = 0;
    m_cyMin = 0;
    m_cxSeparation = 0;
    m_cySeparation = 0;
    m_cxFrameLast = 0;
    m_cyFrameLast = 0;
	m_cxFour = 0;
    m_fMultiSelect = FALSE;
    m_rpRichEditOle = NULL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::DoModal
//
//  Synopsis:   Create the modal base dialog.
//
//  Arguments:  [ppdoSelections] - filled with resulting selections if
//                                  return value is S_OK.
//
//  Returns:    S_OK    - user made selections and hit OK, *[ppdoSelections]
//                          is valid and caller must Release() it.
//              S_FALSE - user hit Cancel button, *[ppdoSelections] is NULL.
//              E_*     - error occurred, *[ppdoSelections] is NULL.
//
//  History:    05-02-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CBaseDlg::DoModal(
    IDataObject **ppdoSelections) const
{
    TRACE_METHOD(CBaseDlg, DoModal);

    m_ppdoSelections = ppdoSelections;
    INT_PTR pi = _DoModalDlg(m_rop.GetParentHwnd(), IDD_STANDALONE_TEXT);
    m_ppdoSelections = NULL;
    return static_cast<HRESULT>(pi);
}




//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::_OnInit
//
//  Synopsis:   Handle WM_INITDIALOG.
//
//  Arguments:  [pfSetFocus] - set to FALSE if focus changed.
//
//  Returns:    S_OK
//
//  History:    05-02-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CBaseDlg::_OnInit(
        BOOL *pfSetFocus)
{
    TRACE_METHOD(CBaseDlg, _OnInit);

    //
    // Make prefix shut up
    //

    if (!_hCtrl(IDC_RICHEDIT) ||
        !_hCtrl(IDC_CHECK_NAMES_PB) ||
        !_hCtrl(IDOK) ||
        !_hCtrl(IDC_SIZEGRIP))
    {
        return E_FAIL;
    }

    if (m_rop.GetInitInfoOptions() & DSOP_FLAG_MULTISELECT)
    {
        m_fMultiSelect = TRUE;
    }
    else
    {
        m_fMultiSelect = FALSE;
    }

    //
    // Init data needed for sizing.
    //
    // First translate the separation distance between controls from
    // dialog units to pixels.
    //

    RECT rc;

    rc.left = rc.top = 1;
    rc.right = DIALOG_SEPARATION_X;
    rc.bottom = DIALOG_SEPARATION_Y;
    VERIFY(MapDialogRect(m_hwnd, &rc));
    m_cxSeparation = rc.right;
    m_cySeparation = rc.bottom;

	rc.left = rc.top = 1;
	rc.right = 4;
	rc.bottom = 4;
	VERIFY(MapDialogRect(m_hwnd, &rc));
	m_cxFour = rc.right;

    //
    // Next shrink the dialog if we're in single select mode; the rich
    // edit should be the height of an SLE (14 DLUs).
    //

    if (!m_fMultiSelect)
    {
        //
        // Replace multiselect instruction text with single-select instruction
        // text.
        //

        String strText(String::load(IDS_SINGLE_SELECT_INSTRUCTIONS));

        if (!strText.empty())
        {
            Static_SetText(_hCtrl(IDC_NAME_LBL), strText.c_str());
        }
    }

    GetClientRect(m_hwnd, &rc);

    //
    // Now save the starting size; _OnMinMaxInfo will prevent the dialog
    // from being sized smaller than this.
    //

    m_cxFrameLast = rc.right;
    m_cyFrameLast = rc.bottom;

    GetWindowRect(m_hwnd, &rc);
    m_cxMin = rc.right - rc.left + 1;
    m_cyMin = rc.bottom - rc.top + 1;

    //
    // Get rich edit's ole interface, give it our callback
    //

    HWND hwndRichEdit = _hCtrl(IDC_RICHEDIT);

    ASSERT(!m_rpRichEditOle.get());
    LRESULT lResult = SendMessage(hwndRichEdit,
                                 EM_GETOLEINTERFACE,
                                 0,
                                 (LPARAM) &m_rpRichEditOle);

    if (!lResult)
    {
        DBG_OUT_LASTERROR;
        return HRESULT_FROM_LASTERROR;
    }
    ASSERT(m_rpRichEditOle.get());

	SendMessage( hwndRichEdit,EM_LIMITTEXT,0x7FFFFFFE,0);


    CRichEditOleCallback *pRichEditOleCallback =
        new CRichEditOleCallback(hwndRichEdit);

    SendMessage(hwndRichEdit,
                EM_SETOLECALLBACK,
                0,
                (LPARAM) pRichEditOleCallback);

    pRichEditOleCallback->Release();

    SendMessage(hwndRichEdit,
                EM_SETEVENTMASK,
                0,
                (LPARAM) ENM_CHANGE);

    //
    // Subclass the rich edit control for keystroke notification and
    // Enter key forwarding.
    //

    SetWindowLongPtr(_hCtrl(IDC_RICHEDIT), GWLP_USERDATA, (LONG_PTR) this);

    m_OriginalRichEditWndProc = (WNDPROC) SetWindowLongPtr(_hCtrl(IDC_RICHEDIT),
                                                   GWLP_WNDPROC,
                                                   (LONG_PTR)_EditWndProc);

    //
    // Init Look For readonly edit control, Look In readonly edit control,
    // and window caption.
    //

    UpdateLookForInText(m_hwnd, m_rop);

#if (DBG == 1)
    const CFilterManager &rfm = m_rop.GetFilterManager();
    Dbg(DEB_TRACE,
        "UA: initial Look For setting '%ws'\n",
        rfm.GetFilterDescription(m_hwnd, FOR_LOOK_FOR).c_str());

    const CScopeManager &rsm = m_rop.GetScopeManager();
    Dbg(DEB_TRACE,
        "UA: initial Look In setting '%ws'\n",
         rsm.GetCurScope().GetDisplayName().c_str());
#endif // (DBG == 1)

    m_hpenUnderline = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_WINDOWTEXT));

    // these are disabled till user types something
    EnableWindow(_hCtrl(IDC_CHECK_NAMES_PB), FALSE);
    EnableWindow(_hCtrl(IDOK), FALSE);

    //
    // Set the focus to the rich edit control
    //

#if (DBG == 1)
    HWND hwndPrev =
#endif
    SetFocus(_hCtrl(IDC_RICHEDIT));
#if (DBG == 1)
    if (!hwndPrev)
    {
        DBG_OUT_LASTERROR;
    }
#endif
    *pfSetFocus = FALSE;

    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::_OnSysColorChange
//
//  Synopsis:   Update the pen used for drawing objects in the rich edit
//              control.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CBaseDlg::_OnSysColorChange()
{
    TRACE_METHOD(CBaseDlg, _OnSysColorChange);

    if (m_hpenUnderline)
    {
        VERIFY(DeleteObject(m_hpenUnderline));
    }
    m_hpenUnderline = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_WINDOWTEXT));
}



//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::_OnDestroy
//
//  Synopsis:   Free resources on dialog destruction
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CBaseDlg::_OnDestroy()
{
    TRACE_METHOD(CBaseDlg, _OnDestroy);

    if (m_hpenUnderline)
    {
        VERIFY(DeleteObject(m_hpenUnderline));
    }
    Clear();
}


//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::_OnCommand
//
//  Synopsis:   Handle WM_COMMAND messages
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CBaseDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fHandled = TRUE;

    switch (LOWORD(wParam))
    {
    case IDC_LOOK_IN_PB:
        Dbg(DEB_TRACE, "UA: (BaseDlg) hit Look In button\n");

        m_rop.GetScopeManager().DoLookInDialog(m_hwnd);
        m_rop.GetFilterManager().HandleScopeChange(m_hwnd);
        UpdateLookForInText(m_hwnd, m_rop);
        SetFocus(_hCtrl(IDC_RICHEDIT));
        break;

    case IDC_LOOK_FOR_PB:
    {
        Dbg(DEB_TRACE, "UA: (BaseDlg) hit Look For button\n");
        const CFilterManager &rfm = m_rop.GetFilterManager();

        rfm.DoLookForDialog(m_hwnd);

        Edit_SetText(_hCtrl(IDC_LOOK_FOR_EDIT),
                     rfm.GetFilterDescription(m_hwnd, FOR_LOOK_FOR).c_str());
        SetFocus(_hCtrl(IDC_RICHEDIT));
        break;
    }

    case IDC_CHECK_NAMES_PB:
        Dbg(DEB_TRACE, "UA: (BaseDlg) hit Check Names button\n");
        m_rop.ProcessNames(_hCtrl(IDC_RICHEDIT), this);
        UpdateLookForInText(m_hwnd, m_rop);
        SetFocus(_hCtrl(IDC_RICHEDIT));
        break;

    case IDC_ADVANCED_PB:
    {
        Dbg(DEB_TRACE, "UA: (BaseDlg) hit Advanced button\n");
        vector<CDsObject>   vSelectedObjects;

        m_AdvancedDlg.DoModalDlg(m_hwnd, &vSelectedObjects);
        UpdateLookForInText(m_hwnd, m_rop);

        //
        // Add all selected objects to richedit
        //

        HWND hwndRichEdit = _hCtrl(IDC_RICHEDIT);
        IRichEditOle *pRichEditOle = NULL;
        LRESULT lResult = SendMessage(hwndRichEdit,
                                     EM_GETOLEINTERFACE,
                                     0,
                                     (LPARAM) &pRichEditOle);
        if (!lResult)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        CRichEditHelper re(m_rop, hwndRichEdit, this, pRichEditOle, FALSE);
        LONG cpEnd;
        CHARRANGE chrg;

        bool fNeedDelim = FALSE;
        
        if (m_fMultiSelect)
        {
            // append the new objects.
            
           LRESULT cchInEdit = SendMessage(hwndRichEdit,
                                           WM_GETTEXTLENGTH,
                                           0,
                                           0);

           SendMessage(hwndRichEdit, EM_SETSEL, cchInEdit, cchInEdit);

           fNeedDelim = (cchInEdit != 0);
        }
        else
        {
            // replace the old objects with the new ones
            // NTRAID#NTBUG9-191537-2000/11/13-sburns
            
            if (vSelectedObjects.size())
            {
               re.Erase(re.begin(), re.end());
            }
        }

        SendMessage(hwndRichEdit,
                    EM_EXGETSEL,
                    0,
                    reinterpret_cast<LPARAM>(&chrg));
        cpEnd = chrg.cpMax;

        for (size_t i = 0; i < vSelectedObjects.size(); i++)
        {
            if (!re.AlreadyInRichEdit(vSelectedObjects[i]))
            {
                if (fNeedDelim)
                {
                    re.Insert(cpEnd, L"; ");
                    cpEnd += 2;
                }
                re.InsertObject(cpEnd++, vSelectedObjects[i]);
                fNeedDelim = TRUE;
            }
        }

        SAFE_RELEASE(pRichEditOle);
        SetFocus(_hCtrl(IDC_RICHEDIT));
        break;
    }

    case IDC_RICHEDIT:
        if (HIWORD(wParam) == EN_CHANGE)
        {
            BOOL fNonEmpty = Edit_GetTextLength(_hCtrl(IDC_RICHEDIT));
            EnableWindow(_hCtrl(IDOK), fNonEmpty);

            // if the check names button has the focus, put it in
            // the richedit before disabling the button

            if (GetFocus() == _hCtrl(IDC_CHECK_NAMES_PB))
            {
                SetFocus(_hCtrl(IDC_RICHEDIT));
            }
            EnableWindow(_hCtrl(IDC_CHECK_NAMES_PB), fNonEmpty);
        }
        break;

    case IDM_CUT:
        Dbg(DEB_TRACE, "UA: (BaseDlg) selected rich edit cmenu CUT\n");
        SendMessage(_hCtrl(IDC_RICHEDIT), WM_CUT, 0, 0);
        break;

    case IDM_COPY:
        Dbg(DEB_TRACE, "UA: (BaseDlg) selected rich edit cmenu COPY\n");
        SendMessage(_hCtrl(IDC_RICHEDIT), WM_COPY, 0, 0);
        break;

    case IDM_PASTE:
        Dbg(DEB_TRACE, "UA: (BaseDlg) selected rich edit cmenu PASTE\n");
        SendMessage(_hCtrl(IDC_RICHEDIT), WM_PASTE, 0, 0);
        break;

    case IDOK:
        Dbg(DEB_TRACE, "UA: (BaseDlg) hit OK\n");
        if (m_rop.ProcessNames(_hCtrl(IDC_RICHEDIT), this))
        {
			//
			//Only one object can be returned in case of single select
			//
			if(m_rpRichEditOle->GetObjectCount() > 1 && !m_fMultiSelect)
			{
				PopupMessage(m_hwnd,IDS_SINGLE_SEL_MSG);
			}
			else
			{
				HRESULT hr = _CreateDataObjectFromSelections();
				BREAK_ON_FAIL_HRESULT(hr);
				EndDialog(GetHwnd(), S_OK);
			}
        }
        else
        {
            UpdateLookForInText(m_hwnd, m_rop);
			SetFocus(_hCtrl(IDC_RICHEDIT));
        }
        break;

    case IDCANCEL:
        Dbg(DEB_TRACE, "UA: (BaseDlg) hit Cancel\n");
        EndDialog(GetHwnd(), S_FALSE);
        break;

    default:
        fHandled = FALSE;
        Dbg(DEB_WARN,
            "CBaseDlg WM_COMMAND code=%#x, id=%#x, hwnd=%#x\n",
            HIWORD(wParam),
            LOWORD(wParam),
            lParam);
        break;
    }

    return fHandled;
}

BOOL
CBaseDlg::_OnNotify(WPARAM wParam, LPARAM lParam)
{
	if(wParam == IDC_NAME_LBL)
	{
		switch (((NMHDR FAR*)lParam)->code)
		{
			//
			//Show the help popup for Examples
			//
			case NM_CLICK:
			case NM_RETURN:
			{
				WinHelp(_hCtrl((ULONG)wParam),
						c_wzHelpFilename,
						HELP_WM_HELP,
						(DWORD_PTR) s_aulHelpIds);

				return TRUE;
			}
			break;
		}
	}
    return FALSE;
}


//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::_CreateDataObjectFromSelections
//
//  Synopsis:   Create a data object, which caller can use, containing
//              entries for all objects the user has selected.
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CBaseDlg::_CreateDataObjectFromSelections()
{
    TRACE_METHOD(CBaseDlg, _CreateDataObjectFromSelections);

    LONG cObjects = m_rpRichEditOle->GetObjectCount();
    CDsObjectList dsol;
    LONG i;

    ASSERT(cObjects > 0);

    *m_ppdoSelections = NULL;

    for (i = 0; i < cObjects; i++)
    {
        REOBJECT reobj;
        HRESULT hr;

        ZeroMemory(&reobj, sizeof reobj);
        reobj.cbStruct = sizeof(reobj);

        hr = m_rpRichEditOle->GetObject(i, &reobj, REO_GETOBJ_POLEOBJ);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            continue;
        }

        ASSERT(reobj.poleobj);

        CDsObject *pdso = (CDsObject *)(CEmbeddedDsObject*)reobj.poleobj;
        dsol.push_back(*pdso);
        reobj.poleobj->Release();
    }
    CObjectPicker *pop = const_cast<CObjectPicker *>(&m_rop);
    *m_ppdoSelections = new CDataObject(pop, dsol);
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::_OnSize
//
//  Synopsis:   Handle window resizing
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CBaseDlg::_OnSize(
    WPARAM wParam,
    LPARAM lParam)
{
    WORD nWidth = LOWORD(lParam);  // width of client area
    WORD nHeight = HIWORD(lParam); // height of client area

    //
    // Move the OK/Cancel buttons so they're always at lower right
    // corner of dialog.
    //

    RECT rcDlg;
    GetClientRect(m_hwnd, &rcDlg);

    if (!m_cxFrameLast || !m_cyFrameLast)
    {
        m_cxFrameLast = rcDlg.right;
        m_cyFrameLast = rcDlg.bottom;
        return TRUE;
    }

    RECT rcCancel;
    GetWindowRect(_hCtrl(IDCANCEL), &rcCancel);

    SetWindowPos(_hCtrl(IDCANCEL),
                 NULL,
                 rcDlg.right - WindowRectWidth(rcCancel) - m_cxSeparation,
                 rcDlg.bottom - WindowRectHeight(rcCancel) - m_cySeparation,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    RECT rcOKWR;
    GetWindowRect(_hCtrl(IDOK), &rcOKWR);
    _GetChildWindowRect(_hCtrl(IDCANCEL), &rcCancel);

    SetWindowPos(_hCtrl(IDOK),
                 NULL,
                 rcCancel.left - WindowRectWidth(rcOKWR) - m_cxFour,
                 rcDlg.bottom - WindowRectHeight(rcOKWR) - m_cySeparation,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);


    //
    // Advanced buttons so they its always at lower left
    // corner of dialog.
    //
    RECT rcAdvanced;

    _GetChildWindowRect(_hCtrl(IDC_ADVANCED_PB), &rcAdvanced);

    SetWindowPos(_hCtrl(IDC_ADVANCED_PB),
                 NULL,
                 rcAdvanced.left,
                 rcDlg.bottom - WindowRectHeight(rcOKWR) - m_cySeparation,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);


	//
    // Move the check names, object types and Locations 
    // buttons so their right edge stays aligned with right edge of Cancel
    // button.
    //

   
    //
    //check names button
    //
    RECT rcCheckNames;
    _GetChildWindowRect(_hCtrl(IDC_CHECK_NAMES_PB), &rcCheckNames);
    RECT rcCheckNamesWR;
    GetWindowRect(_hCtrl(IDC_CHECK_NAMES_PB), &rcCheckNamesWR);

    SetWindowPos(_hCtrl(IDC_CHECK_NAMES_PB),
                 NULL,
                 rcCancel.right - WindowRectWidth(rcCheckNamesWR),
                 rcCheckNames.top,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    //
    //object types button
    //
    RECT rcObjectType;
    _GetChildWindowRect(_hCtrl(IDC_LOOK_FOR_PB), &rcObjectType);
    RECT rcObjectTypeWR;
    GetWindowRect(_hCtrl(IDC_LOOK_FOR_PB), &rcObjectTypeWR);

    SetWindowPos(_hCtrl(IDC_LOOK_FOR_PB),
                 NULL,
                 rcCancel.right - WindowRectWidth(rcObjectTypeWR),
                 rcObjectType.top,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    //
    //Locations button
    //
    RECT rcLocations;
    _GetChildWindowRect(_hCtrl(IDC_LOOK_IN_PB), &rcLocations);
    RECT rcLocationsWR;
    GetWindowRect(_hCtrl(IDC_LOOK_IN_PB), &rcLocationsWR);

    SetWindowPos(_hCtrl(IDC_LOOK_IN_PB),
                 NULL,
                 rcCancel.right - WindowRectWidth(rcLocationsWR),
                 rcLocations.top,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);


    

    //
    // resize look in and look for edit so its right edge is aligned with 
    // left edge of checkname - minimum x separation
    //

    _GetChildWindowRect(_hCtrl(IDC_CHECK_NAMES_PB), &rcCheckNames);

    RECT rcLookInEdit;
    _GetChildWindowRect(_hCtrl(IDC_LOOK_IN_EDIT), &rcLookInEdit);

    SetWindowPos(_hCtrl(IDC_LOOK_IN_EDIT),
                 NULL,
                 0,
                 0,
                 rcCheckNames.left - rcLookInEdit.left - m_cxFour,
                 rcLookInEdit.bottom - rcLookInEdit.top,
                 SWP_NOMOVE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);


    RECT rcLookForEdit;
    _GetChildWindowRect(_hCtrl(IDC_LOOK_FOR_EDIT), &rcLookForEdit);

    SetWindowPos(_hCtrl(IDC_LOOK_FOR_EDIT),
                 NULL,
                 0,
                 0,
                 rcCheckNames.left - rcLookForEdit.left - m_cxFour,
                 rcLookForEdit.bottom - rcLookForEdit.top,
                 SWP_NOMOVE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);


    //
    // resize rich edit so its bottom edge is just above top of OK
    //

    RECT rcRichEdit;
    RECT rcOK;
    _GetChildWindowRect(_hCtrl(IDC_RICHEDIT), &rcRichEdit);
    _GetChildWindowRect(_hCtrl(IDOK), &rcOK);

    SetWindowPos(_hCtrl(IDC_RICHEDIT),
                    NULL,
                    0,
                    0,
                    rcCheckNames.left - rcRichEdit.left - m_cxFour,
                    rcOK.top - rcRichEdit.top - m_cySeparation,
                    SWP_NOMOVE
                    | SWP_NOCOPYBITS
                    | SWP_NOZORDER);

    //
    // Size gripper goes in bottom right corner
    //

    RECT rc;

    _GetChildWindowRect(_hCtrl(IDC_SIZEGRIP), &rc);

    SetWindowPos(_hCtrl(IDC_SIZEGRIP),
                 NULL,
                 nWidth - (rc.right - rc.left),
                 nHeight - (rc.bottom - rc.top),
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOOWNERZORDER
                 | SWP_NOZORDER);
    
    m_cxFrameLast = rcDlg.right;
    m_cyFrameLast = rcDlg.bottom;
    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::_OnMinMaxInfo
//
//  Synopsis:   Enforce minimum window size
//
//  Arguments:  [lpmmi] - from WM_SIZE message
//
//  Returns:    FALSE if dialog has valid size constraints to return.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CBaseDlg::_OnMinMaxInfo(
    LPMINMAXINFO lpmmi)
{
    //
    // If we haven't gotten WM_INITDIALOG and set m_cxMin yet, we don't
    // know what the min size will be, so return nonzero to indicate we
    // didn't process this message.

    if (!m_cxMin) 
    {
        return TRUE;
    }

    lpmmi->ptMinTrackSize.x = m_cxMin;
    lpmmi->ptMinTrackSize.y = m_cyMin;
    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::_EditWndProc
//
//  Synopsis:   Subclassing window proc for rich edit control.
//
//  Arguments:  Standard Windows.
//
//  Returns:    Standard Windows.
//
//  History:    4-20-1999   DavidMun   Created
//
//  Notes:      If the user hits the Enter key and the OK button is enabled,
//              posts a press of that button to the main window.
//
//              Forwards everything except VK_RETURN keys to rich edit
//              window proc.
//
//---------------------------------------------------------------------------

LRESULT CALLBACK
CBaseDlg::_EditWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT         lResult = 0;
    BOOL            fCallWinProc = TRUE;
    CBaseDlg       *pThis =
        reinterpret_cast<CBaseDlg *>(GetWindowLongPtr(hwnd, GWLP_USERDATA));

    switch (msg)
    {
    case WM_KEYDOWN:
        if (wParam == VK_RETURN)
        {
            fCallWinProc = FALSE;
        }
        break;

    case WM_CHAR:
        if (wParam == VK_RETURN)
        {
            HWND hwndFrame = GetParent(hwnd);
            HWND hwndOK = GetDlgItem(hwndFrame, IDOK);

            if (IsWindowEnabled(hwndOK))
            {
                Dbg(DEB_TRACE, "CDsSelectDlg::_EditWndProc: Forwarding Return key\n");
                PostMessage(hwndFrame,
                            WM_COMMAND,
                            MAKEWPARAM(IDOK, BN_CLICKED),
                            (LPARAM) hwndOK);
            }
        }
        break;
    }

    if (fCallWinProc)
    {
        lResult = CallWindowProc(pThis->m_OriginalRichEditWndProc,
                                 hwnd,
                                 msg,
                                 wParam,
                                 lParam);

        //
        // Prevent dialog manager from telling the edit control to select
        // all of its contents when the focus has moved into it.  This is
        // necessary because otherwise tabbing into and out of the rich edit
        // makes it too easy to accidentally replace its contents with the
        // next addition.
        //

        if (msg == WM_GETDLGCODE)
        {
            lResult &= ~DLGC_HASSETSEL;
        }
    }
    return lResult;
}





//+--------------------------------------------------------------------------
//
//  Member:     CBaseDlg::_OnHelp
//
//  Synopsis:   Display context sensitive help for requested item
//
//  Arguments:  [message] -
//              [wParam]  -
//              [lParam]  -
//
//  History:    10-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CBaseDlg::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CBaseDlg, _OnHelp);

    InvokeWinHelp(message, wParam, lParam, c_wzHelpFilename, s_aulHelpIds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\attributemanager.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       AttributeManager.cxx
//
//  Contents:   Implementation of class to cache class and attribute
//              strings and class icons used to display LDAP and WinNT
//              classes and attributes.
//
//  Classes:    CAttributeManager
//
//  History:    05-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


const vector<ATTR_INFO> CAttributeManager::s_AttrEmpty;

//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::CAttributeManager
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - containing instance of Object Picker
//
//  History:    05-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CAttributeManager::CAttributeManager(
    const CObjectPicker &rop):
        m_rop(rop),
        m_ulNextNewAttrIndex(AK_LAST)
{
    TRACE_CONSTRUCTOR(CAttributeManager);

    InitializeCriticalSection(&m_cs);
    m_himlClassIcons = ImageList_Create(

      // NTRAID#NTBUG9-193518-2000/11/21-sburns
      // NTRAID#NTBUG9-191961-2000/11/21-sburns
      
      GetSystemMetrics(SM_CXSMICON),
      GetSystemMetrics(SM_CYSMICON),
      ILC_COLOR16 | ILC_MASK,
      1,
      1);
      
    if (!m_himlClassIcons)
    {
        DBG_OUT_LASTERROR;
    }

    Clear();
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::~CAttributeManager
//
//  Synopsis:   dtor
//
//  History:    05-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CAttributeManager::~CAttributeManager()
{
    TRACE_DESTRUCTOR(CAttributeManager);

    if (m_himlClassIcons)
    {
        // bvt break fix: jdh  VERIFY(ImageList_Destroy(m_himlClassIcons));
        ImageList_Destroy(m_himlClassIcons);
        m_himlClassIcons = NULL;
    }
    DeleteCriticalSection(&m_cs);
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::Clear
//
//  Synopsis:   Discard the cache
//
//  History:    05-25-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAttributeManager::Clear()
{
    TRACE_METHOD(CAttributeManager, Clear);

    if (m_himlClassIcons)
    {
        ImageList_RemoveAll(m_himlClassIcons);
    }
    m_vClasses.clear();
    m_AttrInfoMap.clear();
    m_rpDispSpec.Relinquish();
	m_rpDispSpecContainer.Relinquish();

    //
    // Restore the common attributes which have predefined ATTR_KEY values.
    // The display name is initialized on-demand at runtime, since it's
    // localized.
    //

    m_AttrInfoMap[AK_NAME].strAdsiName                  = L"name";
    m_AttrInfoMap[AK_NAME].Type                         = ADSTYPE_CASE_IGNORE_STRING;
    m_AttrInfoMap[AK_NAME].vstrDisplayName.push_back(String::load(IDS_LVCOLUMN_0));
    m_AttrInfoMap[AK_NAME].vstrOwningClassesAdsiNames.push_back(L"*");

    m_AttrInfoMap[AK_DISPLAY_PATH].vstrDisplayName.push_back(String::load(IDS_LVCOLUMN_1));
    m_AttrInfoMap[AK_DISPLAY_PATH].vstrOwningClassesAdsiNames.push_back(L"*");

    m_AttrInfoMap[AK_EMAIL_ADDRESSES].strAdsiName       = L"mail";
    m_AttrInfoMap[AK_EMAIL_ADDRESSES].Type              = ADSTYPE_CASE_IGNORE_STRING;

    m_AttrInfoMap[AK_ADSPATH].strAdsiName               = L"adsPath";
    m_AttrInfoMap[AK_ADSPATH].Type                      = ADSTYPE_CASE_IGNORE_STRING;

    m_AttrInfoMap[AK_OBJECT_CLASS].strAdsiName          = L"objectClass";
    m_AttrInfoMap[AK_OBJECT_CLASS].Type                 = ADSTYPE_CASE_IGNORE_STRING;

    m_AttrInfoMap[AK_USER_PRINCIPAL_NAME].strAdsiName   = L"userPrincipalName";
    m_AttrInfoMap[AK_USER_PRINCIPAL_NAME].Type          = ADSTYPE_CASE_IGNORE_STRING;

    m_AttrInfoMap[AK_COMPANY].strAdsiName               = L"company";
    m_AttrInfoMap[AK_COMPANY].Type                      = ADSTYPE_CASE_IGNORE_STRING;

    m_AttrInfoMap[AK_DESCRIPTION].strAdsiName           = L"description";
    m_AttrInfoMap[AK_DESCRIPTION].Type                  = ADSTYPE_CASE_IGNORE_STRING;

    m_AttrInfoMap[AK_SAMACCOUNTNAME].strAdsiName        = L"sAMAccountName";
    m_AttrInfoMap[AK_SAMACCOUNTNAME].Type               = ADSTYPE_CASE_IGNORE_STRING;

    m_AttrInfoMap[AK_OBJECT_SID].strAdsiName            = L"objectSid";
    m_AttrInfoMap[AK_OBJECT_SID].Type                   = ADSTYPE_OCTET_STRING;

    m_AttrInfoMap[AK_GROUP_TYPE].strAdsiName            = L"groupType";
    m_AttrInfoMap[AK_GROUP_TYPE].Type                   = ADSTYPE_INTEGER;

    m_AttrInfoMap[AK_USER_ACCT_CTRL].strAdsiName        = L"userAccountControl";
    m_AttrInfoMap[AK_USER_ACCT_CTRL].Type               = ADSTYPE_INTEGER;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::GetImageList
//
//  Synopsis:   Return the imagelist owned by this class
//
//  Arguments:  [phiml] - filled with pointer to this class's imagelist.
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      Caller (or common controls that caller associates the
//              imagelist with) must NOT free the imagelist.
//
//---------------------------------------------------------------------------

HRESULT
CAttributeManager::GetImageList(
    HIMAGELIST *phiml) const
{
    HRESULT hr = S_OK;
    ASSERT(phiml);

    *phiml = m_himlClassIcons;

    if (!m_himlClassIcons)
    {
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        hr = E_OUTOFMEMORY;
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Class:      CFindClass
//
//  Purpose:    Functor for looking up an element of m_vClasses by class
//              name.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

class CFindClass
{
public:

    CFindClass(
        const String &strClass,
        BOOL fDownlevel):
            m_strClass(strClass),
            m_fDownlevel(fDownlevel)
    {
    }

    BOOL
    operator()(const CLASS_INFO &ci)
    {
        return ((m_fDownlevel && (ci.ulFlags & CI_FLAG_IS_DOWNLEVEL)) ||
               (!m_fDownlevel && !(ci.ulFlags & CI_FLAG_IS_DOWNLEVEL))) &&
                !m_strClass.icompare(ci.strAdsiName);
    }

private:

    BOOL m_fDownlevel;
    const String &m_strClass;
};




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::GetIconIndexFromObject
//
//  Synopsis:   Wrapper for GetIconIndexFromClass--extracts necessary
//              arguments (flags and class) from [dso] and forwards call.
//
//  Arguments:  [hwnd]      - for binding
//              [dso]       - object
//              [pintIndex] - on success, filled with index to icon
//
//  Returns:
//
//  History:    08-02-2000   DavidMun   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

HRESULT
CAttributeManager::GetIconIndexFromObject(
    HWND hwnd,
    const CDsObject &dso,
    INT *pintIndex) const
{
    ULONG ulFlags = 0;

    if (dso.GetDisabled())
    {
        ulFlags |= DSOP_GETICON_FLAG_DISABLED;
    }

    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rScope = rsm.LookupScopeById(dso.GetOwningScopeID());

    if (IsDownlevel(rScope))
    {
        ulFlags |= DSOP_GETICON_FLAG_DOWNLEVEL;
    }

    ASSERT(dso.GetClass());

    if (!dso.GetClass())
    {
        DBG_OUT_HRESULT(E_FAIL);
        return E_FAIL;
    }
    return GetIconIndexFromClass(hwnd, dso.GetClass(), ulFlags, pintIndex);
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::GetIconIndexFromClass
//
//  Synopsis:   Return an index into the imagelist owned by this
//              which contains an icon representing class named [strClass].
//
//  Arguments:  [hwnd]      - for binding
//              [strClass]  - class to look up
//              [ulFlags]   - DSOP_GETICON_FLAG_*
//              [pintIndex] - filled with index to icon, -1 if none could
//                              be found
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      May access DS or resource file to procure the icon.
//
//---------------------------------------------------------------------------

HRESULT
CAttributeManager::GetIconIndexFromClass(
    HWND hwnd,
    const String &strClass,
    ULONG ulFlags,
    INT *pintIndex) const
{
    ASSERT(pintIndex);

    HRESULT hr = S_OK;

    do
    {
        // init out param for failure
        *pintIndex = -1;

        // find the entry in m_vClasses for class with ldap name strClass
        ClassInfoVector::iterator it;

        hr = _ReadClassInfo(hwnd,
                            strClass,
                            (ulFlags & DSOP_GETICON_FLAG_DOWNLEVEL),
                            &it);
        BREAK_ON_FAIL_HRESULT(hr);

        if (ulFlags & DSOP_GETICON_FLAG_DISABLED)
        {
            *pintIndex = it->iDisabledIcon;
        }
        else
        {
            *pintIndex = it->iIcon;
        }
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::CopyIconToImageList
//
//  Synopsis:   Copy the icon representing class [strClass] from the
//              imagelist owned by this to the imagelist with handle
//              pointed to by [phimlDest].
//
//  Arguments:  [hwnd]      - for bind
//              [strClass]  - class for which to find icon
//              [ulFlags]   - DSOP_GETICON_FLAG_*
//              [phimlDest] - destination imagelist
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CAttributeManager::CopyIconToImageList(
    HWND hwnd,
    const String &strClass,
    ULONG ulFlags,
    HIMAGELIST *phimlDest) const
{
    TRACE_METHOD(CAttributeManager, CopyIconToImageList);
    ASSERT(phimlDest);

    HRESULT hr = S_OK;

    do
    {
        // find the entry in m_vClasses for class with ldap name strClass
        ClassInfoVector::iterator it;

        hr = _ReadClassInfo(hwnd,
                            strClass,
                            (ulFlags & DSOP_GETICON_FLAG_DOWNLEVEL),
                            &it);
        BREAK_ON_FAIL_HRESULT(hr);

        HICON hIcon = NULL;

        if (ulFlags & DSOP_GETICON_FLAG_DISABLED)
        {
            // must Destroy this HICON
            
            hIcon = ImageList_GetIcon(m_himlClassIcons,
                                      it->iDisabledIcon,
                                      ILD_NORMAL);
        }
        else
        {
            // must Destroy this HICON

            hIcon = ImageList_GetIcon(m_himlClassIcons,
                                      it->iIcon,
                                      ILD_NORMAL);
        }

        if (hIcon)
        {
            ImageList_AddIcon(*phimlDest, hIcon);
            DestroyIcon(hIcon);  // NTRAID#NTBUG9-212260-2000/11/13-sburns
        }
        else
        {
            hr = HRESULT_FROM_LASTERROR;
            DBG_OUT_LASTERROR;
            break;
        }
    } while (0);
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::GetAttrKeysForSelectedClasses
//
//  Synopsis:   Return a vector of ATTR_KEYs denoting all the attributes
//              available for the classes which are currently selected in
//              the 'look for' control.
//
//  Arguments:  [hwnd] - for bind
//
//  Returns:    Vector as described.
//
//  History:    06-13-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

AttrKeyVector
CAttributeManager::GetAttrKeysForSelectedClasses(
    HWND hwnd) const
{
    TRACE_METHOD(CAttributeManager, GetAttrKeysForSelectedClasses);

    vector<String> vstrClasses;
    GetSelectedClasses(&vstrClasses);
    BOOL fDownlevel = FALSE;

    if (IsDownlevel(m_rop.GetScopeManager().GetCurScope()))
    {
        fDownlevel = TRUE;
    }
    return GetAttrKeysForClasses(hwnd, fDownlevel, vstrClasses);
}



//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::GetSelectedClasses
//
//  Synopsis:   Fill [pvstrClasses] with the LDAP class name strings for
//              all the classes currently selected in Look For.
//
//  Arguments:  [pvstrClasses] - filled with class strings as described
//
//  History:    06-15-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CAttributeManager::GetSelectedClasses(
    vector<String> *pvstrClasses) const
{
    ULONG flSelectedClasses =
        m_rop.GetFilterManager().GetCurScopeSelectedFilterFlags();
    ASSERT(flSelectedClasses);
    ASSERT(!(flSelectedClasses & DOWNLEVEL_FILTER_BIT));

    if (flSelectedClasses & DSOP_FILTER_USERS)
    {
        pvstrClasses->push_back(c_wzUserObjectClass);
    }

    if (flSelectedClasses & ALL_UPLEVEL_GROUP_FILTERS)
    {
        pvstrClasses->push_back(c_wzGroupObjectClass);
    }

    if (flSelectedClasses & DSOP_FILTER_COMPUTERS)
    {
        pvstrClasses->push_back(c_wzComputerObjectClass);
    }

    if (flSelectedClasses & DSOP_FILTER_CONTACTS)
    {
        pvstrClasses->push_back(c_wzContactObjectClass);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::GetAttrKeysForClasses
//
//  Synopsis:   Return attribute keys for only the classes [vstrClasses].
//
//  Arguments:  [hwnd]        - for bind
//              [fDownlevel]  - TRUE  => all classes downlevel,
//                              FALSE => all classes uplevel
//              [vstrClasses] - classes that should be represented by
//                               entries in returned vector
//
//  Returns:    AttrKeyVector containing ATTR_KEYs for only the
//              classes in [vstrClasses].
//
//  History:    06-12-2000   DavidMun   Created
//
//  Notes:      The attribute infos in the returned vector may list classes
//              in addition to those in [vstrClasses].
//
//---------------------------------------------------------------------------

AttrKeyVector
CAttributeManager::GetAttrKeysForClasses(
    HWND hwnd,
    BOOL fDownlevel,
    const vector<String> &vstrClasses) const
{
    TRACE_METHOD(CAttributeManager, GetAttrKeysForClasses);

    AttrKeyVector vakResult;

    //
    // First ensure that we've read display specifier info on all the
    // classes in vstrClasses, as well as all their attributes.
    //

    vector<String>::const_iterator itvstr;

    for (itvstr = vstrClasses.begin(); itvstr != vstrClasses.end(); itvstr++)
    {
        _ReadAttrInfo(hwnd, fDownlevel, *itvstr); // calls _ReadClassInfo first
    }

    //
    // Now populate a new AttrKeyVector with the keys of all the attributes
    // that apply to any class in vstrClasses.
    //

    AttrInfoMap::const_iterator itAttrInfoMap;

    for (itAttrInfoMap = m_AttrInfoMap.begin();
         itAttrInfoMap != m_AttrInfoMap.end();
         itAttrInfoMap++)
    {
        vector<String>::const_iterator itOwning;

        //
        // Iterate over the owning classes of the current attribute.  If
        // any of those classes matches one in [vstrClasses], then the
        // key of the current ATTR_INFO should be copied into the output vector.
        //

        BOOL fMatch = FALSE;

        for (itOwning = itAttrInfoMap->second.vstrOwningClassesAdsiNames.begin();
             itOwning != itAttrInfoMap->second.vstrOwningClassesAdsiNames.end();
             itOwning++)
        {
            for (itvstr = vstrClasses.begin();
                 itvstr != vstrClasses.end();
                 itvstr++)
            {
                if (!itvstr->icompare(*itOwning))
                {
                    fMatch = TRUE;
                    vakResult.push_back(itAttrInfoMap->first);
                    break;
                }
            }

            if (fMatch)
            {
                break;
            }
        }
    }
    return vakResult;
}

//
// A pointer to an ATTR_CALLBACK_INFO instance is passed to static
// function CAttributeManager::_AttrEnumCallback() as its lParam.
//

struct ATTR_CALLBACK_INFO
{
    ATTR_CALLBACK_INFO():
        pThis(NULL)
    {
    }

    ~ATTR_CALLBACK_INFO()
    {
        pThis = NULL;
    }

    const CAttributeManager *pThis;
    String strClass;
};




//+--------------------------------------------------------------------------
//
//  Class:      CFindAttrByAdsiName
//
//  Purpose:    Used as a functor to look up the attribute key of a given
//              class name.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

class CFindAttrByAdsiName
{
public:

    CFindAttrByAdsiName(
        const String &strAdsiName):
            m_strAdsiName(strAdsiName)
    {
    }

    BOOL
    operator()(const pair<ATTR_KEY, ATTR_INFO> &rKeyInfoPair)
    {
        return !m_strAdsiName.icompare(rKeyInfoPair.second.strAdsiName);
    }

private:

    const String &m_strAdsiName;
};



//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::DemandInit
//
//  Synopsis:   Bind to the display specifier container if we haven't already
//
//  Returns:    Result of attempting bind.
//
//  History:    05-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CAttributeManager::DemandInit(
    HWND hwnd) const
{
    HRESULT hr = S_OK;
    WCHAR   wzUserName[MAX_PATH];
    WCHAR   wzPassword[MAX_PATH];

    do
    {
        //
        // If DS is not available, there's nothing to do here
        //

        if (!ConfigSupportsDs(m_rop.GetTargetComputerConfig()))
        {
            break;
        }

        //
        // Create display specifier instance if we haven't already.
        //

        if (!m_rpDispSpec.get())
        {
            hr = m_rpDispSpec.AcquireViaCreateInstance(CLSID_DsDisplaySpecifier,
                                                     NULL,
                                                     CLSCTX_INPROC,
                                                     IID_IDsDisplaySpecifier);
            BREAK_ON_FAIL_HRESULT(hr);
        }

        ASSERT(m_rpDispSpec.get());

        //
        // Bind to display specifier container if necessary
        // If we are already bound and the target hasn't changed
        // there is no need to bind again so break.
        //
        if (m_rpDispSpecContainer.get())
        {
            break;
        }

        VOID *pv = NULL;
        hr = m_rop.GetRootDSE().BindToDisplaySpecifiersContainer(hwnd,
                                                                 IID_IADsContainer,
                                                                 &pv);
        BREAK_ON_FAIL_HRESULT(hr);

        m_rpDispSpecContainer.Acquire(
            static_cast<IADsContainer *>(pv));

        ASSERT(m_rpDispSpecContainer.get());

        g_pBinder->GetDefaultCreds(PROVIDER_LDAP,
								   wzUserName, 
								   wzPassword);

        if (*wzUserName)
        {
            String strDcName = m_rop.GetTargetDomainDc();
            if(strDcName.size() > 2 && strDcName[0] == L'\\' && strDcName[1] == L'\\')
                 strDcName.erase(0, 2);
            hr = m_rpDispSpec->SetServer(strDcName.c_str(), 
                                         wzUserName, 
                                         wzPassword, 
                                         DSSSF_DSAVAILABLE);
            BREAK_ON_FAIL_HRESULT(hr);
        }
    } while (0);

    ZeroMemory(wzPassword, sizeof wzPassword);
    ZeroMemory(wzUserName, sizeof wzUserName);
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::_ReadClassInfo
//
//  Synopsis:   Read and cache display specifier information for [strClass].
//
//  Arguments:  [hwnd]       - for binding
//              [strClass]   - name of class to read info for
//              [fDownlevel] - TRUE => [strClass] is name of downlevel class,
//                             FALSE => [strClass] is LDAP class name
//              [pit]        - filled with iterator at relevant CLASS_INFO
//
//  Returns:    HRESULT
//
//  History:    05-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CAttributeManager::_ReadClassInfo(
    HWND hwnd,
    const String &strClass,
    BOOL fDownlevel,
    ClassInfoVector::iterator *pit) const
{
    //TRACE_METHOD(CAttributeManager, _ReadClassInfo);
    ASSERT(pit);

    HRESULT hr = S_OK;
    CLASS_INFO ci;
    PWSTR pwzBuf = NULL;

    ci.strAdsiName = strClass;

    do
    {
        //
        // See if we've already got info on this class
        //

        CFindClass predicate(strClass, fDownlevel);

        *pit = find_if(m_vClasses.begin(), m_vClasses.end(), predicate);

        if (*pit != m_vClasses.end())
        {
            // success, return iterator pointing to cached info
            break;
        }

        Dbg(DEB_TRACE,
            "CAttributeManager::_ReadClassInfo<%#x> Reading class %ws\n",
            this,
            strClass.c_str());

        //
        // If DS is not available on target machine class info must be
        // hardcoded.
        //

        BOOL fDsAvailable = ConfigSupportsDs(m_rop.GetTargetComputerConfig());

        //
        // Don't have cached info for this class.
        // Read display info from the specifier for this class
        //
        // Special-case downlevel classes, as they won't appear in the
        // DS.
        //

        BOOL fIsLocalGroup = !strClass.icompare(c_wzLocalGroupClass);
        BOOL fIsGlobalGroup = !strClass.icompare(c_wzGlobalGroupClass);
        BOOL fIsGroup = !strClass.icompare(c_wzGroupObjectClass);
        BOOL fIsUser = !strClass.icompare(c_wzUserObjectClass);
        BOOL fIsComputer = !strClass.icompare(c_wzComputerObjectClass);

        if (fIsLocalGroup || fIsGlobalGroup)
        {
            HICON hIcon;
            ULONG idiGroup = fIsLocalGroup ? IDI_LOCAL_GROUP : IDI_GROUP;
            int   idsGroup = fIsLocalGroup ? IDS_LOCAL_GROUP : IDS_GLOBAL_GROUP;

            hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(idiGroup));

            ci.iIcon = ImageList_AddIcon(m_himlClassIcons, hIcon);
            ci.strDisplayName = String::load(idsGroup);
        }
        else if (fDownlevel || !fDsAvailable)
        {
            HICON hIcon;
            ULONG idi;
            ULONG idiDisabled = 0;
            int   ids;

            if (fIsUser)
            {
                idi = IDI_USER;
                idiDisabled = IDI_DISABLED_USER;
                ids = IDS_USER;
            }
            else if (fIsGroup)
            {
                idi = IDI_GROUP;
                ids = IDS_GROUP;
            }
            else if (fIsComputer)
            {
                idi = IDI_COMPUTER;
                idiDisabled = IDI_DISABLED_COMPUTER;
                ids = IDS_COMPUTER;
            }
            else
            {
                Dbg(DEB_ERROR,
                    "unexpected class %ws for non-DS machine config\n",
                    strClass.c_str());
                hr = E_INVALIDARG;
                break;
            }

            hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(idi));
            ci.iIcon = ImageList_AddIcon(m_himlClassIcons, hIcon);

            if (idiDisabled)
            {
                hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(idiDisabled));
                ci.iDisabledIcon = ImageList_AddIcon(m_himlClassIcons, hIcon);
            }
            ci.strDisplayName = String::load(ids);
            ci.ulFlags |= CI_FLAG_IS_DOWNLEVEL;
        }
        else
        {
            CWaitCursor Hourglass;

            hr = DemandInit(hwnd);
            BREAK_ON_FAIL_HRESULT(hr);

            HICON hIcon;

            {
                TIMER("IDsDisplaySpecifier::GetIcon(%ws)", strClass.c_str());
                hIcon = m_rpDispSpec->GetIcon(strClass.c_str(),
                                              DSGIF_ISNORMAL
                                              | DSGIF_GETDEFAULTICON,
                                              16,
                                              16);
            }
            ci.iIcon = ImageList_AddIcon(m_himlClassIcons, hIcon);
			DestroyIcon(hIcon);

            {
                TIMER("IDsDisplaySpecifier::GetIcon(%ws, DSGIF_ISDISABLED)",
                      strClass.c_str());
                hIcon = m_rpDispSpec->GetIcon(strClass.c_str(),
                                            DSGIF_ISDISABLED
                                            | DSGIF_GETDEFAULTICON,
                                            16,
                                            16);
            }
            ci.iDisabledIcon = ImageList_AddIcon(m_himlClassIcons, hIcon);
			DestroyIcon(hIcon);

            pwzBuf = new WCHAR [MAX_PATH + 1];

            {
                TIMER("IDsDisplaySpecifier::GetFriendlyClassName(%ws)",
                      strClass.c_str());
                hr = m_rpDispSpec->GetFriendlyClassName(strClass.c_str(),
                                                      pwzBuf,
                                                      MAX_PATH);
            }

            if (SUCCEEDED(hr))
            {
                ci.strDisplayName = pwzBuf;
            }
            else
            {
                ci.strDisplayName = strClass;
            }
        }

        //
        // Add new info to class vector
        //

        m_vClasses.push_back(ci);
        *pit = m_vClasses.end() - 1;
    } while (0);

    delete [] pwzBuf;
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::_ReadAttrInfo
//
//  Synopsis:   Read all class and attribute information for class with ADSI
//              name [strClass] from the display specifier interface.
//
//  Arguments:  [hwnd]     - for bind
//              [strClass] - class for which to read attributes
//
//  History:    06-12-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CAttributeManager::_ReadAttrInfo(
    HWND hwnd,
    BOOL fDownlevel,
    const String &strClass) const
{
    //TRACE_METHOD(CAttributeManager, _ReadAttrInfo);

    ClassInfoVector::iterator itClass;
    HRESULT hr = S_OK;

    do
    {
        hr = _ReadClassInfo(hwnd, strClass, fDownlevel, &itClass); // calls DemandInit
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // If we've been here before for this class and successfully read its
        // attributes, leave.
        //

        if (itClass->ulFlags & CI_FLAG_READ_ATTR_INFO)
        {
            break;
        }

        //
        // If the DS is not available, then leave, as there are no
        // attributes to be read.
        //

        BOOL fDsAvailable = ConfigSupportsDs(m_rop.GetTargetComputerConfig());

        if (!fDsAvailable)
        {
            break;
        }

        //
        // Remember the last attribute we know about before doing the enum.
        //

        AttrInfoMap::iterator itLastOld = m_AttrInfoMap.end();
        itLastOld--;

        //
        // Enumerate via callback all the display specifer attributes for class
        //

        Dbg(DEB_TRACE, "Reading attributes for class %ws\n", strClass.c_str());

        ATTR_CALLBACK_INFO aci;

        aci.pThis = this;
        aci.strClass = strClass;

        hr = m_rpDispSpec->EnumClassAttributes(strClass.c_str(),
                                               _AttrEnumCallback,
                                               reinterpret_cast<LPARAM>(&aci));

        //
        // Now for any attributes added, set their type
        //

        AttrInfoMap::iterator itMap = itLastOld;
        itMap++;

        for (; itMap != m_AttrInfoMap.end(); itMap++)
        {
            itMap->second.Type =
                m_rpDispSpec->GetAttributeADsType(itMap->second.strAdsiName.c_str());
//            Dbg(DEB_TRACE,
//                "%ws, %ws, %#x\n",
//                itMap->second.strAdsiName.c_str(),
//                itMap->second.strDisplayName.c_str(),
//                itMap->second.Type);
        }

        //
        // Remember that we read the attributes for this class
        //

        itClass->ulFlags |= CI_FLAG_READ_ATTR_INFO;
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::_AttrEnumCallback
//
//  Synopsis:   Receive the callback from the display specifier enumerator
//              for the attributes of a specific class.
//
//  Arguments:  [lParam]           - ATTR_CALLBACK_INFO *
//              [pszAttributeName] - ADSI (LDAP) name of attribute
//              [pszDisplayName]   - human-readable name of attribute
//              [dwFlags]          - unused
//
//  Returns:    S_OK (an error would only halt the enumeration)
//
//  History:    06-12-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT CALLBACK
CAttributeManager::_AttrEnumCallback(
    LPARAM lParam,
    LPCWSTR pszAttributeName,
    LPCWSTR pszDisplayName,
    DWORD dwFlags)
{
    ATTR_CALLBACK_INFO *paci = reinterpret_cast<ATTR_CALLBACK_INFO *>(lParam);
    const CAttributeManager *pThis = paci->pThis;
    ASSERT(pszAttributeName);
    ASSERT(pszDisplayName);
    CAutoCritSec Lock(const_cast<CRITICAL_SECTION*>(&pThis->m_cs));

    do
    {
        if (!pszAttributeName)
        {
            DBG_OUT_HRESULT(E_POINTER);
            break;
        }

        //
        // See if there's already an entry in m_AttrInfoMap for this
        // attribute.
        // This can happen because more than one class of object might have the
        // same attribute.
        //

        ATTR_KEY key = pThis->GetAttrKey(pszAttributeName);

        if(AddIfNotPresent(&pThis->m_AttrInfoMap[key].vstrOwningClassesAdsiNames,
						   paci->strClass))
		{
			if (pszDisplayName)
			{
				pThis->m_AttrInfoMap[key].vstrDisplayName.push_back(pszDisplayName);
			}
			else 
			{
				//
				// not localized, but better than nothing.  will be overwritten
				// with localized name should a later enumeration of some other
				// class' attributes have one for this attribute.
				//

				pThis->m_AttrInfoMap[key].vstrDisplayName.push_back(pszAttributeName);
			}
		}
        //
        // _ReadAttrInfo will go back and set the Type values for all
        // enumerated attributes
        //

    } while (0);

    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::GetAttrKey
//
//  Synopsis:   Return the key for attribute with ADSI name [strAdsiName],
//              creating one if necessary.
//
//  Arguments:  [strAdsiName] - name of attribute to find in
//                                  m_AttrInfoMap.
//
//  Returns:    New or existing key
//
//  History:    06-13-2000   DavidMun   Created
//
//  Note:       Only caller is dsobject which has a class and VARTYPE in
//              addition to attribute name.  It could supply those to make
//              the new ATTR_INFO structure contain more data, but right now
//              nothing needs to use that.
//
//---------------------------------------------------------------------------

ATTR_KEY
CAttributeManager::GetAttrKey(
    const String &strAdsiName) const
{
    //TRACE_METHOD(CAttributeManager, GetAttrKey);

    CFindAttrByAdsiName pred(strAdsiName);
    AttrInfoMap::iterator itAttr;

    itAttr = find_if(m_AttrInfoMap.begin(),
                     m_AttrInfoMap.end(),
                     pred);

    if (itAttr != m_AttrInfoMap.end())
    {
        return itAttr->first;
    }

    //
    // Master attribute list doesn't contain an entry for this attribute
    // (pszAttributeName) yet.  Create one.
    //

    ATTR_KEY key = static_cast<ATTR_KEY>(++m_ulNextNewAttrIndex);

    m_AttrInfoMap[key].strAdsiName = strAdsiName;
    return key;
}

BOOL
CAttributeManager::    
IsAttributeLoaded(
    ATTR_KEY ak) const
{

    CAutoCritSec Lock(const_cast<CRITICAL_SECTION *>(&m_cs));
    return !m_AttrInfoMap[ak].vstrDisplayName.empty();
}

//+--------------------------------------------------------------------------
//
//  Member:     CAttributeManager::GetAttrDisplayName
//
//  Synopsis:   Return the human-readable name for attribute with key [ak]
//
//  Arguments:  [ak] - represents attribute for which to return name
//
//  Returns:    Localized name of attribute
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const String &
CAttributeManager::GetAttrDisplayName(
    ATTR_KEY ak) const
{
    CAutoCritSec Lock(const_cast<CRITICAL_SECTION *>(&m_cs));
	String strClass = GetClassName(m_rop);

    vector<String>::const_iterator itClass;
	vector<String>::const_iterator itDisplayName;

    //
    // Iterate over the owning classes of the current attribute.  If
    // any of those classes matches one in [vstrClasses], then the
    // key of the current ATTR_INFO should be copied into the output vector.
    //

    BOOL fMatch = FALSE;

    for (itClass = m_AttrInfoMap[ak].vstrOwningClassesAdsiNames.begin(),
		 itDisplayName = m_AttrInfoMap[ak].vstrDisplayName.begin();
		 itClass != m_AttrInfoMap[ak].vstrOwningClassesAdsiNames.end() &&
		 itDisplayName != m_AttrInfoMap[ak].vstrDisplayName.end();
		 itClass++,
		 itDisplayName++)
	{

		if (!itClass->icompare(strClass))
        {
			fMatch = TRUE;
            break;
		}
		if (fMatch)
        {
			break;
		}
	}
	if(!fMatch)
		itDisplayName = m_AttrInfoMap[ak].vstrDisplayName.begin();

	const String *pstrDisplayName = NULL;

	if(itDisplayName != m_AttrInfoMap[ak].vstrDisplayName.end())
		pstrDisplayName = &*itDisplayName;
	else
		pstrDisplayName = &m_AttrInfoMap[ak].strAdsiName;


    //
    // If we don't have a display name for the attribute yet, then we
    // haven't read the attr info from the DS yet. Caller is responsible
    // for telling us which classes to read before attempting to get
    // display info about them.
    //



    if (pstrDisplayName->empty())
    {
        Dbg(DEB_ERROR, "No display name for ATTR_KEY=%u\n", ak);
    }
    ASSERT(!pstrDisplayName->empty());

    return *pstrDisplayName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\bindinfo.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       bindinfo.cxx
//
//  Contents:   Class for keeping bind hanles in cache.
//
//  Classes:    CBindInfo
//
//  History:    20-oct-2000     hiteshr   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

DEBUG_DECLARE_INSTANCE_COUNTER(CBindInfo)


//===========================================================================
//
// CBindInfo
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CBindInfo::CBindInfo
//
//  Synopsis:   ctor
//
//  Arguments:  [pBinder]   - backpointer to parent
//              [pwzDomainDns] - Bind to a dc of this domain.
//---------------------------------------------------------------------------

CBindInfo::CBindInfo(
    CBinder *pBinder,
    PCWSTR pwzDomainDns,
	DWORD dwFlag):
        m_pBinder(pBinder),
        m_hrLastCredError(S_OK),
        m_pNext(NULL),
        m_hDs(0),
		m_dwFlag(dwFlag)

{
    //TRACE_CONSTRUCTOR(CBindInfo);
    Dbg(DEB_BIND, "CBindInfo::CBindInfo(%x) '%ws'\n", this, pwzDomainDns);
    DBG_INDENTER;
    DEBUG_INCREMENT_INSTANCE_COUNTER(CBindInfo);

    m_strDomainPath = pwzDomainDns;

    //
    // Truncate at a trailing dot because sometimes we'll get it as
    // part of the server and sometimes we won't, and we don't want the
    // string comparison of server names to fail to match because of it.
    //
    m_strDomainPath.strip(String::TRAILING, L'.');
}




//+--------------------------------------------------------------------------
//
//  Member:     CBindInfo::IsForDomain
//
//  Synopsis:   Return TRUE if this has a container interface for server
//              [pwzServer].
//
//  Arguments:  [flProvider] - PROVIDER_*
//              [pwzServer]  - server name
//
//  History:    08-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CBindInfo::IsForDomain(
    PCWSTR pwzDomain)
{
    return !m_strDomainPath.icompare(pwzDomain);
}



//+--------------------------------------------------------------------------
//
//  Member:     CBindInfo::Init
//
//  Synopsis:   Perform the first part of the initialization of this which
//              can fail and is therefore done outside the ctor
//
//  Arguments:  [hwnd]    - for binding
//              [pwzPath] - NULL or path to bind to
//              [riid]    - identifies desired interface
//              [ppv]     - optional; on success filled with requested
//                           interface
//
//  Returns:    HRESULT
//
//  History:    07-14-1998   DavidMun   Created
//
//  Notes:      This method is only called once for each instance of this
//              class.  The _RepeatableInit() method may be called multiple
//              times.
//
//---------------------------------------------------------------------------

HRESULT
CBindInfo::Init(
    HWND    hwnd)
{
    TRACE_METHOD(CBindInfo, Init);

    HRESULT hr = S_OK;
    BOOL    fUserIsLocal = IsCurrentUserLocalUser();
    BOOL    fUseDefaultCred = FALSE;
    BOOL    fPromptForCred = FALSE;
    WCHAR   wzUserName[MAX_PATH];
    WCHAR   wzUserNameCopy[MAX_PATH];
    WCHAR   wzPassword[MAX_PATH];
    BOOL    bDoneForceDiscovery = FALSE;
    DWORD   dwErr = ERROR_SUCCESS;
    BOOL    bHadDefaultCred = FALSE;
    String  strServer;

    do
    {   
        if (!m_strDomainPath.length())
        {
            hr = E_POINTER;
            DBG_OUT_HRESULT(hr);
            break;
        }

       //
       //if User is logged in locally, don't attempt to bind
       //Use DefaultCred
       //
       if (fUserIsLocal)
       {
            fUseDefaultCred = TRUE;
            m_hrLastCredError = E_ACCESSDENIED;
       }
       
       while(true)
       {
            RPC_AUTH_IDENTITY_HANDLE AuthIdentity = 0;
            if (fUseDefaultCred || fPromptForCred)
            {
                if(fPromptForCred)
                {
                    Dbg(DEB_BIND, "Previous call tried default creds\n");
                    fPromptForCred = TRUE;

                    hr = _AskForCreds(hwnd, wzUserName, wzPassword);
                    BREAK_ON_FAIL_HRESULT(hr);
                }
                else
                {
                    //
                    // Obtaining the container interface requires credentials.  If
                    // there are default credentials available from the binder, try
                    // using those first.  If they aren't available or result in a
                    // credential error, go into a loop prompting for and using
                    // credentials from user.
                    //

                    g_pBinder->GetDefaultCreds(PROVIDER_LDAP,
											   wzUserName, 
											   wzPassword);

                    if (*wzUserName)
                    {
                        bHadDefaultCred = TRUE;
                        Dbg(DEB_BIND, "Using default credentials (%ws)\n", wzUserName);
                    }
                    else
                    {
                        Dbg(DEB_BIND, "No default credentials, prompting\n", hr);
                        fPromptForCred = TRUE;
                        hr = _AskForCreds(hwnd, wzUserName, wzPassword);
                        BREAK_ON_FAIL_HRESULT(hr);
                    }
                }
                //
                //UserName is in the format Domain\UserName
                //
                LPWSTR pszDomain = NULL;
                LPWSTR pszUser = NULL;
                wcscpy(wzUserNameCopy,wzUserName);
                LPTSTR pszWhack = wcschr(wzUserNameCopy,L'\\');
                LPTSTR pszAt    = wcschr(wzUserNameCopy, L'@');
                if(pszWhack)
                {
                    *pszWhack = L'\0';
                    pszUser = pszWhack + 1;
                    pszDomain = wzUserNameCopy;
                }
                else if(pszAt)
                {
                    *pszAt = L'\0';
                    pszUser = wzUserNameCopy;
                    pszDomain = pszAt + 1;
                }
                else
                {
                    ASSERT(FALSE);
                }

                if(pszUser && pszDomain)
                {
                    dwErr = DsMakePasswordCredentials(pszUser,
                                                      pszDomain,
                                                      wzPassword,
                                                      &AuthIdentity);
                    hr = HRESULT_FROM_WIN32(dwErr);
                    BREAK_ON_FAIL_HRESULT(hr);
                }

            }

            PDOMAIN_CONTROLLER_INFOW pDCInfo = NULL;

            ULONG GetDcFlags = DS_DIRECTORY_SERVICE_REQUIRED | DS_IP_REQUIRED;
			if(m_dwFlag & OP_GC_SERVER_REQUIRED)
				GetDcFlags |= DS_GC_SERVER_REQUIRED;
            
            //If is DsGetDcName is not called already
            if(!strServer.length())
            {
                dwErr = DsGetDcNameW(NULL, 
                                     m_strDomainPath.c_str(), 
                                     NULL, 
                                     NULL, 
                                    GetDcFlags,
                                    &pDCInfo);
            
                hr = HRESULT_FROM_WIN32(dwErr);
                BREAK_ON_FAIL_HRESULT(hr);
                //Get the DCNAme
                strServer = pDCInfo->DomainControllerName;
                LocalFree(pDCInfo);
                pDCInfo = NULL;
            }

            //Bind            
            if(!AuthIdentity)
            {
                dwErr = DsBind(strServer.c_str(), NULL, &m_hDs);
            }
            else
            {
                dwErr = DsBindWithCred(strServer.c_str(), 
                                       NULL, 
                                       AuthIdentity,
                                       &m_hDs);
                DsFreePasswordCredentials(AuthIdentity);
                AuthIdentity = 0;
            }

            hr = HRESULT_FROM_WIN32(dwErr);

            if (FAILED(hr))
            {
                if (IsCredError(hr))
                {
                    Dbg(DEB_BIND,
                    "NULL credentials returned credential hr %#x\n",
                    hr);

                    m_hrLastCredError = hr;
                    
                    if(!fUseDefaultCred)
                    {   
                        //
                        //Use Default Cred
                        //
                        fUseDefaultCred = TRUE;
                        continue;
                    }

                    if(!fPromptForCred)
                    {
                        //
                        //Prompt for Cred
                        //
                        fPromptForCred = TRUE;
                        continue;
                    }
                    //
                    //Keep Prompting until user presses cancel
                    //
                    continue;
                }                    
                else if(!bDoneForceDiscovery)
                {
                 
                    // Try again, the DC returned above was unavailable (i.e., the
                    // cache list was stale).
                    //
                    bDoneForceDiscovery = TRUE;
                    
                    GetDcFlags |= DS_FORCE_REDISCOVERY;
                    dwErr = DsGetDcNameW(NULL, 
                                         m_strDomainPath.c_str(), 
                                         NULL, 
                                         NULL, 
                                         GetDcFlags,
                                         &pDCInfo);

                    hr = HRESULT_FROM_WIN32(dwErr);
                    BREAK_ON_FAIL_HRESULT(hr);
                    
                    strServer = pDCInfo->DomainControllerName;                                            
                    LocalFree(pDCInfo);
                    pDCInfo = NULL;            
                    
                     //Bind            
                    if(!AuthIdentity)
                    {
                        dwErr = DsBind(strServer.c_str(), NULL, &m_hDs);
                    }
                    else
                    {
                        dwErr = DsBindWithCred(strServer.c_str(), 
                                               NULL, 
                                               AuthIdentity,
                                               &m_hDs);
                        DsFreePasswordCredentials(AuthIdentity);
                        AuthIdentity = 0;
                    }
                    
                    hr = HRESULT_FROM_WIN32(dwErr);
                    if (FAILED(hr))
                    {
                        if (IsCredError(hr))
                        {                                
                            Dbg(DEB_BIND,
                            "NULL credentials returned credential hr %#x\n",
                            hr);
                            m_hrLastCredError = hr;                                
                            
                            if(!fUseDefaultCred)                            
                            {
                                fUseDefaultCred = TRUE;
                                continue;
                            }

                            if(!fPromptForCred)
                            {
                                fPromptForCred = TRUE;
                                continue;
                            }

                            continue;
                        }
                    }
                }
            }

            if(SUCCEEDED(hr) && fPromptForCred && !bHadDefaultCred)
            {
                g_pBinder->SetDefaultCreds(wzUserName,
										   wzPassword);
                ZeroMemory(wzPassword, sizeof(wzPassword));
            }

            //If we fall through here, we don't need to reloop
            break;
        }
    } while (0);

    return hr;
}





//+--------------------------------------------------------------------------
//
//  Member:     CBindInfo::~CBindInfo
//
//  Synopsis:   dtor
//
//  History:    04-26-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CBindInfo::~CBindInfo()
{
    TRACE_DESTRUCTOR(CBindInfo);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CBindInfo);
    if(m_hDs)
        DsUnBind(&m_hDs);

}




//+--------------------------------------------------------------------------
//
//  Member:     CBindInfo::_AskForCreds
//
//  Synopsis:   Dispatch based on whether we're running in the thread that
//              created [hwndParent].
//
//  Arguments:  [hwndParent] - parent for modal password dialog
//              [wzUserName] - buffer to fill with name entered by user
//              [wzPassword] - buffer to fill with password entered by user
//
//  Returns:    S_OK if user enters credentials.
//              E_* if password dialog couldn't be opened.
//              Last credential error if user cancels password dialog.
//
//  Modifies:   *[wzUserName], *[wzPassword]
//
//  History:    04-29-1998   DavidMun   Created
//
//  Notes:      Called by CBindInfo::OpenObject when it gets a credential
//              error.
//
//              This method blocks until password dialog is closed.
//
//---------------------------------------------------------------------------

HRESULT
CBindInfo::_AskForCreds(
    HWND hwndParent,
    PWSTR wzUserName,
    PWSTR wzPassword)
{
    TRACE_METHOD(CBindInfo, _AskForCreds);

    HRESULT hr;

    //
    // This method is called via g_pBinder->BindToObject which itself may
    // be called from either thread.
    //
    // If we're running in the primary thread, use SendMessage to call
    // the routine that invokes the password dialog.
    //
    // If in non-primary thread post message to main thread to
    // pop up password dialog, then wait on event for it to complete.
    //

    ASSERT(!hwndParent || IsWindow(hwndParent));

    if (!hwndParent
        || GetWindowLongPtr(hwndParent, DWLP_DLGPROC) != (LONG_PTR) CDlg::_DlgProc)
    {
        Dbg(DEB_TRACE, "hwndParent = %#x, invoking password dialog directly\n", hwndParent);
        CPasswordDialog PasswordDlg(PROVIDER_LDAP,
                                    m_strDomainPath.c_str(),
                                    wzUserName,
                                    wzPassword);

        hr = PasswordDlg.DoModalDialog(hwndParent);
    }
    else if (GetWindowThreadProcessId(hwndParent, NULL) == GetCurrentThreadId())
    {
        hr = _AskForCredsViaSendMessage(hwndParent, wzUserName, wzPassword);
    }
    else
    {
        hr = _AskForCredsViaPostMessage(hwndParent, wzUserName, wzPassword);
    }

    if (hr == S_FALSE)
    {
        hr = m_hrLastCredError;
    }
    else if (SUCCEEDED(hr))
    {
        //
        // If the username is neither in NT4 (domain\user) or UPN
        // (user@domain) format, then the bind will definitely fail.
        // If that's the case, change the name to domain\user, where
        // domain is the name of the thing we're trying to get access
        // to.
        //

        if (!wcschr(wzUserName, L'\\') && !wcschr(wzUserName, L'@'))
        {
            String strNewName(m_strDomainPath);

            //
            // Strip port number, if any
            //

            if (strNewName.find(L':') != String::npos)
            {
                strNewName.erase(strNewName.find(L':'),
                                 String::npos);
            }

            //
            // If the server looks like a DNS name (contains at least one
            // '.' and one alpha character), use UPN format.
            // Otherwise assume it is a netbios or ip address and use NT4
            // format.
            //

            if (strNewName.find(L'.') != String::npos &&
                find_if(strNewName.begin(), strNewName.end(), IsCharAlpha) !=
                strNewName.end())
            {
                strNewName.insert(0, L"@");
                strNewName.insert(0, wzUserName);

                Dbg(DEB_TRACE,
                    "Replacing user name %ws with %ws\n",
                    wzUserName,
                    strNewName.c_str());

                lstrcpyn(wzUserName, strNewName.c_str(), MAX_PATH);
            }
            else
            {
                strNewName += L"\\";
                strNewName += wzUserName;

                Dbg(DEB_TRACE,
                    "Replacing user name %ws with %ws\n",
                    wzUserName,
                    strNewName.c_str());

                lstrcpyn(wzUserName, strNewName.c_str(), MAX_PATH);
            }
        }
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBindInfo::_AskForCredsViaSendMessage
//
//  Synopsis:   Use SendMessage to call the CDsBrowseMgr routine that invokes
//              the password dialog.
//
//  Arguments:  See _AskForCreds.
//
//  Returns:    HRESULT from password dialog.
//
//  History:    04-29-1998   DavidMun   Created
//
//  Notes:      Called only from main thread.  Blocks until password dialog
//              closes.
//
//---------------------------------------------------------------------------

HRESULT
CBindInfo::_AskForCredsViaSendMessage(
    HWND hwndParent,
    PWSTR wzUserName,
    PWSTR wzPassword)
{
    TRACE_METHOD(CBindInfo, _AskForCredsViaSendMessage);
    CRED_MSG_INFO cmi = {
                            PROVIDER_LDAP,
                            m_strDomainPath.c_str(),
                            wzUserName,
                            wzPassword,
                            NULL,
                            S_OK
                        };

    SendMessage(hwndParent, OPM_PROMPT_FOR_CREDS, 0, (LPARAM)&cmi);
    return cmi.hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBindInfo::_AskForCredsViaPostMessage
//
//  Synopsis:   Request that the main thread put up the password dialog.
//
//  Arguments:  See _AskForCreds.
//
//  Returns:    HRESULT from password dialog.
//
//  History:    04-29-1998   DavidMun   Created
//
//  Notes:      Called only from worker thread.  Blocks until main thread
//              sets event after password dialog closes.
//
//---------------------------------------------------------------------------

HRESULT
CBindInfo::_AskForCredsViaPostMessage(
    HWND hwndParent,
    PWSTR wzUserName,
    PWSTR wzPassword)
{
    TRACE_METHOD(CBindInfo, _AskForCredsViaPostMessage);
    ASSERT(hwndParent && IsWindow(hwndParent));

    CRED_MSG_INFO cmi = {
                            PROVIDER_LDAP,
                            m_strDomainPath.c_str(),
                            wzUserName,
                            wzPassword,
                            NULL,
                            S_OK
                        };

    cmi.hPrompt = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!cmi.hPrompt)
    {
        DBG_OUT_LASTERROR;
        cmi.hr = HRESULT_FROM_LASTERROR;
        return cmi.hr;
    }

    PostMessage(hwndParent, OPM_PROMPT_FOR_CREDS, 0, (LPARAM)&cmi);

    WaitForSingleObject(cmi.hPrompt, INFINITE);
    CloseHandle(cmi.hPrompt);
    return cmi.hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBindInfo::_PopupCredErr
//
//  Synopsis:   Pop up a dialog indicating a failure with the credentials
//              the user entered and block until the dialog is dismissed
//
//  Arguments:  [hwnd]        - parent wiindow
//              [ids]         - resource id of dialog message
//              [pwzUserName] - name used in creds
//              [pwzError]    - error received when using them
//
//  History:    06-23-2000   DavidMun   Created
//
//  Notes:      This method may safely be called from the worker thread
//
//---------------------------------------------------------------------------

void
CBindInfo::_PopupCredErr(
    HWND hwnd,
    ULONG ids,
    PCWSTR pwzUserName,
    PCWSTR pwzError)
{
    TRACE_METHOD(CBindInfo, _PopupCredErr);

    //
    // If we're in same thread that created [hwnd], just pop up the message
    //

    if (!hwnd || GetWindowThreadProcessId(hwnd, NULL) == GetCurrentThreadId())
    {
        PopupMessage(hwnd, ids, pwzUserName, pwzError);
        return;
    }

    //
    // We're not running in the thread that created [hwnd], so post a message
    // to it and ask it to display message.
    //

    POPUP_MSG_INFO mi = {
                            hwnd,
                            ids,
                            pwzUserName,
                            pwzError,
                            NULL
                        };

    mi.hPrompt = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (mi.hPrompt)
    {
        PostMessage(hwnd,
                    OPM_POPUP_CRED_ERROR,
                    0,
                    reinterpret_cast<LPARAM>(&mi));
        WaitForSingleObject(mi.hPrompt, INFINITE);
        CloseHandle(mi.hPrompt);
    }
    else
    {
        DBG_OUT_LASTERROR;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\class.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       class.cxx
//
//  Contents:   Simple cache of DS class information
//
//  Classes:    CClassCache
//
//  History:    12-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#define STARTING_CACHE_SIZE         5


//+--------------------------------------------------------------------------
//
//  Member:     CClassCache::Initialize
//
//  Synopsis:   Finish object construction.
//
//  Returns:    S_OK or E_FAIL
//
//  History:    12-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CClassCache::Initialize()
{
    HRESULT hr = S_OK;

    //
    // Create a new image list for small icons.
    //

    m_hImageList = ImageList_Create(16, 16, ILC_COLOR | ILC_MASK, 1, 1);

    if (m_hImageList == NULL)
    {
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        hr = E_OUTOFMEMORY;
    }

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CClassCache::Clear
//
//  Synopsis:   Free cached resources
//
//  History:    12-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CClassCache::Clear()
{
    TRACE_METHOD(CClassCache, Clear);

    CAutoCritSec lock(&m_cs);

    m_cItems = 0;

    for (USHORT i = 0; i < m_cMaxItems; i++)
    {
        m_pcce[i].wzClass[0] = L'\0';
        m_pcce[i].iIcon = -1;
        m_pcce[i].iDisabledIcon = -1;
        m_pcce[i].usFlags = 0;
    }

    BOOL fOk = ImageList_SetImageCount(m_hImageList, 0);

    if (!fOk)
    {
        DBG_OUT_LASTERROR;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CClassCache::_AddClass
//
//  Synopsis:   Add an entry for class [pwzClass] to the cache.
//
//  Arguments:  [pwzClass]     - class to add
//              [fSettingIcon] - if zero ignore [hIcon] and [fDisabled]
//              [hIcon]        - icon to add
//              [fDisabled]    - is it the disabled icon for the class
//              [pidxClass]    - filled with index to new cache entry
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  Modifies:   *[pidxClass]
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CClassCache::_AddClass(
    PCWSTR  pwzClass,
    BOOL    fSettingIcon,
    HICON   hIcon,
    BOOL    fDisabled,
    PUSHORT pidxClass)
{
    TRACE_METHOD(CClassCache, _AddClass);

    CAutoCritSec lock(&m_cs);

    if (m_cItems >= m_cMaxItems)
    {
        //
        // Grow the list
        //

        if (m_cMaxItems)
        {
            //
            // List has data.  Allocate a new larger one and copy over data
            //

            USHORT cNewMaxItems = (m_cMaxItems * 3) / 2;
            CLASS_CACHE_ENTRY  *pcceNew;

            pcceNew = new CLASS_CACHE_ENTRY[cNewMaxItems];
            CopyMemory(pcceNew, m_pcce, sizeof(CLASS_CACHE_ENTRY) * m_cItems);

            delete [] m_pcce;
            m_pcce = pcceNew;
            m_cMaxItems = cNewMaxItems;
        }
        else
        {
            //
            // First addition, allocate initial list
            //

            ASSERT(!m_cItems);

            m_pcce = new CLASS_CACHE_ENTRY[STARTING_CACHE_SIZE];
            m_cMaxItems = STARTING_CACHE_SIZE;
        }
    }

    //
    // If we're still here then there's enough room to add the
    // new item.
    //

    lstrcpyn(m_pcce[m_cItems].wzClass, pwzClass, MAX_PATH);

    if (fSettingIcon)
    {
        if (fDisabled)
        {
            if (hIcon)
            {
                m_pcce[m_cItems].iDisabledIcon = ImageList_AddIcon(m_hImageList,
                                                                   hIcon);
            }
            m_pcce[m_cItems].usFlags |= DSOP_CC_DISABLED_ICON_SET;
        }
        else
        {
            if (hIcon)
            {
                m_pcce[m_cItems].iIcon = ImageList_AddIcon(m_hImageList, hIcon);
            }
            m_pcce[m_cItems].usFlags |= DSOP_CC_NORMAL_ICON_SET;
        }
    }

    if (pidxClass)
    {
        *pidxClass = m_cItems;
    }

    m_cItems++;
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CClassCache::AddIcon
//
//  Synopsis:   Add an icon (or the failure to obtain one) to the class cache
//
//  Arguments:  [idxClass]  - class for which we're adding icon
//              [fDisabled] - whether it's the enabled or disabled icon
//              [hIcon]     - NULL or icon
//
//  Returns:    E_INVALIDARG if [idxClass] invalid, S_OK otherwise.
//
//  History:    09-24-1999   davidmun   Created
//
//---------------------------------------------------------------------------

HRESULT
CClassCache::AddIcon(
    USHORT idxClass,
    BOOL fDisabled,
    HICON hIcon)
{
    TRACE_METHOD(CClassCache, AddIcon);

    CAutoCritSec lock(&m_cs);

    ASSERT(idxClass < m_cItems);

    if (idxClass >= m_cItems)
    {
        Dbg(DEB_ERROR, "idxClass %u >= m_cItems %u\n", idxClass, m_cItems);
        return E_INVALIDARG;
    }

    if (fDisabled)
    {
        //
        // We should only be trying to add an icon if this flavor (enabled
        // or disabled) of icon has never been added.
        //

        ASSERT(!(m_pcce[idxClass].usFlags & DSOP_CC_DISABLED_ICON_SET));

        if (hIcon)
        {
            m_pcce[idxClass].iDisabledIcon = ImageList_AddIcon(m_hImageList,
                                                               hIcon);
        }
        m_pcce[idxClass].usFlags |= DSOP_CC_DISABLED_ICON_SET;
    }
    else
    {
        ASSERT(!(m_pcce[idxClass].usFlags & DSOP_CC_NORMAL_ICON_SET));

        if (hIcon)
        {
            m_pcce[idxClass].iIcon = ImageList_AddIcon(m_hImageList, hIcon);
        }
        m_pcce[idxClass].usFlags |= DSOP_CC_NORMAL_ICON_SET;
    }
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CClassCache::GetIconIndexFromClass
//
//  Synopsis:   Given a class name, find the index to the cached icon.
//
//  Arguments:  [pwzClass]  - class for which to find icon
//              [fDisabled] - whether to find enabled or disabled icon
//              [pidxIcon]  - filled with icon index or -1
//
//  Returns:    S_OK   - *[pidxIcon] is an icon index, or -1 if what was
//                        cached was the failure to retrieve that icon
//              E_FAIL - neither the icon (nor failure to retrieve it) has
//                        been cached for this class.
//
//  History:    09-24-1999   davidmun   Created
//
//---------------------------------------------------------------------------

HRESULT
CClassCache::GetIconIndexFromClass(
    PCWSTR pwzClass,
    BOOL fDisabled,
    INT *pidxIcon)
{
    ASSERT(!IsBadWritePtr(pidxIcon, sizeof(*pidxIcon)));
    HRESULT hr = E_FAIL; // init to failure

    CAutoCritSec lock(&m_cs);

    *pidxIcon = -1;

    for (USHORT i = 0; i < m_cItems; ++i)
    {
        if (!lstrcmpi(m_pcce[i].wzClass, pwzClass))
        {
            // found class.  now see if it has the requested icon type.

            if (fDisabled)
            {
                if (m_pcce[i].usFlags & DSOP_CC_DISABLED_ICON_SET)
                {
                    *pidxIcon = m_pcce[i].iDisabledIcon;
                    hr = S_OK;
                }
            }
            else
            {
                if (m_pcce[i].usFlags & DSOP_CC_NORMAL_ICON_SET)
                {
                    *pidxIcon = m_pcce[i].iIcon;
                    hr = S_OK;
                }
            }
            break;
        }
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CClassCache::GetIconIndexFromClassIndex
//
//  Synopsis:   Return the image list index for the icon associated with
//              class [idxClass].
//
//  Arguments:  [idxClass]  - index of class for which to return info
//              [fDisabled] - nonzero if want disabled icon for this class
//              [pidxIcon]  - filled with icon index on success
//
//  Returns:    E_INVALIDARG - [idxClass] out of range
//              E_FAIL       - specified icon hasn't been set yet
//              S_OK         - *[pidxIcon] valid
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CClassCache::GetIconIndexFromClassIndex(
    USHORT idxClass,
    BOOL   fDisabled,
    INT   *pidxIcon)
{
    ASSERT(!IsBadWritePtr(pidxIcon, sizeof(*pidxIcon)));

    *pidxIcon = -1; // init to not found value

    CAutoCritSec lock(&m_cs);

    if (idxClass >= m_cItems)
    {
        Dbg(DEB_ERROR, "idxClass %u >= m_cItems %u\n", idxClass, m_cItems);
        ASSERT(idxClass < m_cItems);
        return E_INVALIDARG;
    }

    if (fDisabled)
    {
        if (m_pcce[idxClass].usFlags & DSOP_CC_DISABLED_ICON_SET)
        {
            *pidxIcon = m_pcce[idxClass].iDisabledIcon;
        }
        else
        {
            return E_FAIL;
        }
    }
    else
    {
        if (m_pcce[idxClass].usFlags & DSOP_CC_NORMAL_ICON_SET)
        {
            *pidxIcon = m_pcce[idxClass].iIcon;
        }
        else
        {
            return E_FAIL;
        }
    }
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CClassCache::GetClassIndex
//
//  Synopsis:   Fill *[pidxClass] with the index to the cache entry for
//              class [pwzClass].
//
//  Arguments:  [pwzClass]  - class for which to search
//              [pidxClass] - filled with index to cache entry
//
//  Returns:    S_OK if class found, E_FAIL otherwise
//
//  Modifies:   *[pidxClass]
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CClassCache::GetClassIndex(
    PCWSTR pwzClass,
    PUSHORT pidxClass)
{
    CAutoCritSec lock(&m_cs);

    *pidxClass = (USHORT)-1;
    for (USHORT i = 0; i < m_cItems; i++)
    {
        if (!lstrcmpi(m_pcce[i].wzClass, pwzClass))
        {
            *pidxClass = i;
            return S_OK;
        }
    }
    return E_FAIL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CClassCache::GetClassName
//
//  Synopsis:   Return the name of the class at [idxClass] cache entry.
//
//  Arguments:  [idxClass]     - index into cache
//              [wzClassName]  - filled with class name
//              [cchClassName] - size in characters of [wzClassName]
//
//  Modifies:   *[wzClassName]
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CClassCache::GetClassName(
    USHORT idxClass,
    PWSTR wzClassName,
    ULONG cchClassName)
{
    CAutoCritSec lock(&m_cs);

    ASSERT(idxClass < m_cItems);

    if (idxClass >= m_cItems)
    {
        Dbg(DEB_ERROR, "idxClass %u >= m_cItems %u\n", idxClass, m_cItems);
        wzClassName[0] = L'\0';
        return;
    }

    lstrcpyn(wzClassName, m_pcce[idxClass].wzClass, cchClassName);
}




//+--------------------------------------------------------------------------
//
//  Member:     CClassCache::GetClassNameLength
//
//  Synopsis:   Return the length, in characters, of the name of the class
//              at cache location [idxClass].  The length returned does not
//              include space for the terminating null character.
//
//  Arguments:  [idxClass] - cache entry for which to return info
//
//  Returns:    String length, in characters
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CClassCache::GetClassNameLength(
    USHORT idxClass)
{
    CAutoCritSec lock(&m_cs);

    ASSERT(idxClass < m_cItems);

    if (idxClass >= m_cItems)
    {
        return 0;
    }

    return lstrlen(m_pcce[idxClass].wzClass);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\classfac.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       cmpdtacf.cxx
//
//  Contents:   Implementation of class factory for ComponentData object.
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

DEBUG_DECLARE_INSTANCE_COUNTER(CDsObjectPickerCF)

//============================================================================
//
// IUnknown implementation
//
//============================================================================




//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectPickerCF::QueryInterface
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDsObjectPickerCF::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    TRACE_METHOD(CDsObjectPickerCF, QueryInterface);
    HRESULT hr = S_OK;

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppvObj = (IUnknown *)(IClassFactory *)this;
        }
        else if (IsEqualIID(riid, IID_IClassFactory))
        {
            *ppvObj = (IUnknown *)(IClassFactory *)this;
        }
        else
        {
            DBG_OUT_NO_INTERFACE("CDsObjectPickerCF", riid);
            hr = E_NOINTERFACE;
            *ppvObj = NULL;
            break;
        }

        //
        // If we got this far we are handing out a new interface pointer on
        // this object, so addref it.
        //

        AddRef();
    } while (0);

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectPickerCF::AddRef
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDsObjectPickerCF::AddRef()
{
    return InterlockedIncrement((LONG *) &m_cRefs);
}




//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectPickerCF::Release
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDsObjectPickerCF::Release()
{
    ULONG cRefsTemp;

    cRefsTemp = InterlockedDecrement((LONG *)&m_cRefs);

    if (0 == cRefsTemp)
    {
        delete this;
    }

    return cRefsTemp;
}




//============================================================================
//
// IClassFactory implementation
//
//============================================================================




//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectPickerCF::CreateInstance
//
//  Synopsis:   Create a new instance of a data source object.
//
//  Arguments:  [pUnkOuter] - must be NULL
//              [riid]      - must be interface supported by DSO
//              [ppvObj]    - filled with requested interface on success
//
//  Returns:    CLASS_E_NOAGGREGATION among others
//
//  Modifies:   *[ppvObj]
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDsObjectPickerCF::CreateInstance(
    IUnknown    *pUnkOuter,
    REFIID       riid,
    LPVOID      *ppvObj)
{
    TRACE_METHOD(CDsObjectPickerCF, CreateInstance);
    HRESULT hr = S_OK;
    CObjectPicker *pop = NULL;

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        // Init for failure case

        *ppvObj = NULL;

        if (pUnkOuter != NULL)
        {
            hr = CLASS_E_NOAGGREGATION;
            DBG_OUT_HRESULT(hr);
            break;
        }

        pop = new CObjectPicker;

        //
        // Try to get the requested interface.  Since the CComponentData
        // object starts with a refcount of 1, release after the QI.  If
        // the QI succeeded, the ComponentData will end up with a refcount
        // of 1.  If it failed, the ComponentData will have self-destructed.
        //

        hr = pop->QueryInterface(riid, ppvObj);
        pop->Release();
        CHECK_HRESULT(hr);
    } while (0);

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectPickerCF::LockServer
//
//  Synopsis:   Inc or dec the DLL lock count
//
//  Arguments:  [fLock] - TRUE increment, FALSE decrement
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CDsObjectPickerCF::LockServer(
    BOOL fLock)
{
    TRACE_METHOD(CDsObjectPickerCF, LockServer);
    CDll::LockServer(fLock);

    return S_OK;
}



//============================================================================
//
// Non-interface member function implementation
//
//============================================================================



//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectPickerCF::CDsObjectPickerCF
//
//  Synopsis:   ctor
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

CDsObjectPickerCF::CDsObjectPickerCF():
    m_cRefs(1)
{
    TRACE_CONSTRUCTOR(CDsObjectPickerCF);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDsObjectPickerCF);
}




//+---------------------------------------------------------------------------
//
//  Member:     CDsObjectPickerCF::~CDsObjectPickerCF
//
//  Synopsis:   dtor
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

CDsObjectPickerCF::~CDsObjectPickerCF()
{
    TRACE_DESTRUCTOR(CDsObjectPickerCF);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CDsObjectPickerCF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\binder.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       binder.cxx
//
//  Contents:   Implementation of adsget/open object helper class
//
//  Classes:    CBinder
//
//  History:    02-16-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#define BINDER_NAME_TRANSLATE_GC_INIT_FAILED            0x0001
#define BINDER_USER_CANCELLED_PWD_DLG                   0x0002



//+--------------------------------------------------------------------------
//
//  Member:     CBinder::QueryInterface
//
//  Synopsis:   Standard OLE
//
//  History:    02-16-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CBinder::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    // TRACE_METHOD(CBinder, QueryInterface);
    HRESULT hr = S_OK;

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppvObj = (IUnknown *)this;
        }
        else if (IsEqualIID(riid, IID_IBindHelper))
        {
            *ppvObj = (IUnknown *)(IBindHelper *)this;
        }
        else
        {
            DBG_OUT_NO_INTERFACE("CBinder", riid);
            hr = E_NOINTERFACE;
            *ppvObj = NULL;
            break;
        }

        //
        // If we got this far we are handing out a new interface pointer on
        // this object, so addref it.
        //

        AddRef();
    } while (0);

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CBinder::BindToObject
//
//  Synopsis:   Call ADsOpenObject, prompting for credentials if necessary.
//
//  Arguments:  [tzPath] - ads path of desired object
//              [riid]   - interface requested on object
//              [ppv]    - out pointer for interface
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppv]
//
//  History:    02-16-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CBinder::BindToObject(
    HWND    hwnd,
    PCWSTR wzPath,
    REFIID riid,
    LPVOID *ppv,
    ULONG flags)
{
    Dbg(DEB_BIND, "BindToObject(%ws, flags=%#x)\n", wzPath, flags);
    DBG_INDENTER;

    HRESULT hr = S_OK;
    BSTR    bstrServer = NULL;
    PWSTR  pwzPathCopy = NULL;

    ASSERT(wzPath && *wzPath);

    if (!wzPath || !*wzPath)
    {
        hr = E_INVALIDARG;
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    do
    {
        //
        // Get a copy of the server portion of the path
        //
        // Work around IADsPathname failure to handle WinNT paths containing
        // commas, e.g. "WinNT://foo,Domain".
        //

        BOOL fWinntProvider = wcsstr(wzPath, c_wzWinNTPrefix) == wzPath;
        PWSTR pwzLastComma = wcsrchr(wzPath, L',');
        BOOL fWinntDomainObject = fWinntProvider &&
                                  pwzLastComma &&
                                  !lstrcmpi(pwzLastComma, L",Domain");
        BOOL fWinntComputerObject = fWinntProvider &&
                                  pwzLastComma &&
                                  !lstrcmpi(pwzLastComma, L",Computer");
        BOOL fWinntWorkgroupObject = fWinntProvider &&
                                    pwzLastComma &&
                                    !lstrcmpi(pwzLastComma, L",Workgroup");


        if (fWinntProvider)
        {
            if (pwzLastComma)
            {
                NewDupStr(&pwzPathCopy, wzPath);

                pwzPathCopy[pwzLastComma - wzPath] = L'\0';

                hr = g_pADsPath->GetMostSignificantElement(pwzPathCopy,
                                                           &bstrServer);
                BREAK_ON_FAIL_HRESULT(hr);
            }
            else
            {
                hr = g_pADsPath->GetWinntPathServerName(wzPath, &bstrServer);
                BREAK_ON_FAIL_HRESULT(hr);
            }
        }
        else
        {
            hr = g_pADsPath->SetRetrieve(ADS_SETTYPE_FULL,
                                         wzPath,
                                         ADS_FORMAT_SERVER,
                                         &bstrServer);
            BREAK_ON_FAIL_HRESULT(hr);
        }

        ASSERT(bstrServer);

        //
        // Find or create a server info object for this server
        //

        CServerInfo *pServerInfo = NULL;
        USHORT usSrvInfoFlags = 0;

        if (fWinntDomainObject)
        {
            usSrvInfoFlags |= SRVINF_WINNT_DOMAIN_OBJECT;
        }

        if (fWinntComputerObject)
        {
            usSrvInfoFlags |= SRVINF_WINNT_COMPUTER_OBJECT;
        }

        if(fWinntWorkgroupObject)
        {
            usSrvInfoFlags |= SRVINF_WINNT_WORKGROUP_OBJECT;
        }

        if (flags & DSOP_BIND_FLAG_PATH_IS_DC)
        {
            usSrvInfoFlags |= SRVINF_SERVER_COMPONENT_IS_COMPUTER;
        }

        if (flags & DSOP_BIND_FLAG_SERVER_NEQ_DN)
        {
            usSrvInfoFlags |= SRVINF_SERVER_NEQ_DN;
        }

        hr = _GetServerInfo(hwnd,
                            bstrServer,
                            fWinntWorkgroupObject?pwzPathCopy:wzPath,
                            usSrvInfoFlags,
                            &pServerInfo,
                            riid,
                            ppv);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Either a serverinfo object already existed or one was just
        // created.  Use it to try to retrieve object.
        //

        if (!(flags & DSOP_BIND_FLAG_SERVER_NEQ_DN))
        {
            hr = pServerInfo->OpenObject(hwnd, 
                                        fWinntWorkgroupObject?pwzPathCopy:wzPath, 
                                        riid, 
                                        ppv);
        }
    } while (0);

    delete [] pwzPathCopy;
    SysFreeString(bstrServer);
    return hr;
}





//+--------------------------------------------------------------------------
//
//  Member:     CBinder::GetNameTranslate
//
//  Synopsis:   Return a name translate interface initialized to work with
//              domain [pwzDomain].
//
//  Arguments:  [hwndParent]      - frame or browser hwnd, for credential
//                                   prompt.
//              [ppNameTranslate] - filled with name translate interface
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppNameTranslate], caller must release
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CBinder::GetNameTranslate(
    HWND                hwndParent,
    PCWSTR              pwzADsPath,
    IADsNameTranslate **ppNameTranslate)
{
    TRACE_METHOD(CBinder, GetNameTranslate);

    HRESULT hr = S_OK;
    CServerInfo *pServerInfo = NULL;

    do
    {
        //
        // Init out var
        //

        *ppNameTranslate = NULL;

        //
        // Domain name is required for initialization.  Don't use
        // ADS_NAME_INITTYPE_GC because the domain might not be in the
        // local enterprise; but there's no way to tell the name translate
        // interface to use the GC in a different enterprise.
        //

        if (!pwzADsPath)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            ASSERT(!"CBinder::GetNameTranslate: pwzADsPath is NULL");
            break;
        }

        Bstr bstrServer;

        hr = g_pADsPath->SetRetrieve(ADS_SETTYPE_FULL,
                                     pwzADsPath,
                                     ADS_FORMAT_SERVER,
                                     &bstrServer);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Get the name translate interface from the server info.
        //

        hr = _GetServerInfo(hwndParent,
                            bstrServer.c_str(),
                            pwzADsPath,
                            0,
                            &pServerInfo);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pServerInfo->GetNameTranslate(ppNameTranslate);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBinder::GetDomainRootDSE
//
//  Synopsis:   Retrieve an interface on the RootDSE object for domain
//              [pwzDomain].
//
//  Arguments:  [hwndParent]   - frame or browser, for credential prompt
//              [pwzDomain]    - domain for which to get rootdse
//              [ppADsRootDSE] - filled with interface on rootdse object
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppADsRootDSE]
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CBinder::GetDomainRootDSE(
    HWND    hwndParent,
    PCWSTR pwzDomain,
    IADs **ppADsRootDSE)
{
    TRACE_METHOD(CBinder, GetDomainRootDSE);

    HRESULT hr = S_OK;
    CServerInfo *pServerInfo = NULL;

    do
    {
        WCHAR wzDomainADsPath[MAX_PATH];

        wsprintf(wzDomainADsPath, L"LDAP://%ws", pwzDomain);

        hr = _GetServerInfo(hwndParent,
                            pwzDomain,
                            wzDomainADsPath,
                            0,
                            &pServerInfo);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pServerInfo->GetRootDSE(ppADsRootDSE);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CBinder::BindToDcInDomain
//
//  Synopsis:  Does a dsbind to a dc in pwzDomainName and returns Handle to it
//
//  Arguments:  [IN hwnd]      - frame or browser hwnd, for credential
//                                   prompt.
//              [IN pwzDomainName]   - Domain for to do the bind
//				[IN dwFlag]			- Flags for DsGetDCName
//
//              [OUT phDs]           - Bind Handle is returned in it				
//
//  Returns:    HRESULT
//
//  Modifies:   phDs, 
//
//  History:    07-20-1998   Hiteshr   Created
//
//---------------------------------------------------------------------------
STDMETHODIMP
CBinder::BindToDcInDomain(HWND hwnd,
                          PCWSTR pwzDomainName,
						  DWORD dwFlag,
                          PHANDLE phDs
						  )
{
    TRACE_METHOD(CBinder, BindToDcInDomain);

    ASSERT(pwzDomainName && phDs);

    CBindInfo *pCur = NULL;
    HRESULT hr = S_OK;

    if (!pwzDomainName || !phDs)
    {
        hr = E_INVALIDARG;
        DBG_OUT_HRESULT(hr);
        return hr;
    }


    *phDs = NULL;

    //
    //Check if we have it in the cache
    //
    for(pCur = m_pFirstBindInfo; pCur; pCur = pCur->Next())
    {
        if(pCur->IsForDomain(pwzDomainName))
        {
            break;
        }
    }

    if (pCur)
    {
        *phDs = pCur->GetDS();
        return hr;
    }

    //
    //Not found in the cache. Create a new entry
    //
    pCur = new CBindInfo(this, pwzDomainName, dwFlag);
    if(!pCur)
    {
        return E_OUTOFMEMORY;
    }        
    hr = pCur->Init(hwnd);
    if(FAILED(hr))
    {
        delete pCur;
        return hr;
    }

    //
    // Append to the link list
    //

    if (!m_pFirstBindInfo)
    {
        ASSERT(!m_pLastBindInfo);
        m_pFirstBindInfo = m_pLastBindInfo = pCur;
    }
    else
    {
        ASSERT(m_pLastBindInfo);
        pCur->LinkAfter(m_pLastBindInfo);
        m_pLastBindInfo = pCur;
    }

    //
    //Return the ds handle
    //
    *phDs = pCur->GetDS();

    return hr;
}
//+--------------------------------------------------------------------------
//
//  Member:     CBinder::_GetServerInfo
//
//  Synopsis:   Return a pointer to the server information object for the
//              server name [pwzServer], creating one if necessary.
//
//  Arguments:  [hwnd]         - parent for modal password dialog
//              [pwzServer]    - name of server for which to search
//              [pwzPath]      - full ADsPath for which to retrieve server
//                                info
//              [flags]        - SRVINF_* flags
//              [ppServerInfo] - filled with pointer to server info object
//                                for [pwzServer]
//              [riid]         - optional interface to get
//              [ppv]          - optional filled with retrieved interface
//
//  Returns:    HRESULT
//
//  History:    05-04-1998   DavidMun   Created
//
//  Notes:      Arguments [riid] and [ppv] are ignored unless [flags]
//              contains the flag SRVINF_SERVER_NEQ_DN, which indicates
//              that the server portion of pwzPath does not correspond to
//              the domain referenced in the DN of the path.  This can occur
//              when binding to the WKSP container.  If *[ppv] is filled in,
//              caller must Release the returned interface.
//
//---------------------------------------------------------------------------

HRESULT
CBinder::_GetServerInfo(
    HWND hwnd,
    PCWSTR pwzServer,
    PCWSTR pwzPath,
    USHORT flags,
    CServerInfo **ppServerInfo,
    REFIID riid,
    VOID **ppv)
{
    TRACE_METHOD(CBinder, _GetServerInfo);
    ASSERT(ppServerInfo);

    HRESULT hr = S_OK;
    CServerInfo *pCur;
    ULONG flProvider;

    if (!ppServerInfo)
    {
        hr = E_POINTER;
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    *ppServerInfo = NULL;

    hr = ProviderFlagFromPath(pwzPath, &flProvider);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    for (pCur = m_pFirstServerInfo; pCur; pCur = pCur->Next())
    {
        if (pCur->IsForServer(flProvider, pwzServer))
        {
            break;
        }
    }

    if (pCur)
    {
        *ppServerInfo = pCur;

        if (flags & SRVINF_SERVER_NEQ_DN)
        {
            ASSERT(ppv);

            hr = pCur->BindDirect(hwnd, pwzPath, riid, ppv);
            CHECK_HRESULT(hr);
        }
    }
    else
    {
        hr = _CreateServerInfo(hwnd,
                               pwzServer,
                               pwzPath,
                               flags,
                               ppServerInfo,
                               riid,
                               ppv);
        CHECK_HRESULT(hr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBinder::_CreateServerInfo
//
//  Synopsis:   Create a new server info object for server named [pwzServer]
//              and append it to the llist of server infos.
//
//  Arguments:  [pwzServer]    - server name associated with new server
//                                info object
//              [ppServerInfo] - filled with pointer to new object
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  Modifies:   *[ppServerInfo]
//
//  History:    05-04-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CBinder::_CreateServerInfo(
    HWND hwnd,
    PCWSTR pwzServer,
    PCWSTR pwzPath,
    USHORT flags,
    CServerInfo **ppServerInfo,
    REFIID riid,
    VOID **ppv)
{
    TRACE_METHOD(CBinder, _CreateServerInfo);

    HRESULT         hr = S_OK;
    CSpServerInfo    spServerInfo(new CServerInfo(this,
                                                 pwzServer,
                                                 flags));

    ASSERT(!*ppServerInfo);

    do
    {
        hr = spServerInfo->Init(hwnd, pwzPath, riid, ppv);

        if (FAILED(hr) && !IsCredError(hr))
        {
            DBG_OUT_HRESULT(hr);
            break;
        }

        //
        // Append to the link list
        //

        if (!m_pFirstServerInfo)
        {
            ASSERT(!m_pLastServerInfo);

            m_pFirstServerInfo = m_pLastServerInfo = spServerInfo.get();
        }
        else
        {
            ASSERT(m_pLastServerInfo);

            spServerInfo->LinkAfter(m_pLastServerInfo);
            m_pLastServerInfo = spServerInfo.get();
        }

        //
        // transfer ownership from smart pointer to output argument
        //

        *ppServerInfo = spServerInfo.release();
    }
    while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CBinder::SetDefaultCreds
//
//  Synopsis:   Save the passed in credentials in member vars.
//
//  Arguments:  [pwzUserName] - user name
//              [pwzPassword] - password
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CBinder::SetDefaultCreds(
    PWSTR pwzUserName,
    PWSTR pwzPassword)
{
    CAutoCritSec Lock(&m_cs);

    BOOL fOk;

    fOk = RtlCreateUnicodeString(&m_ustrPassword, pwzPassword);

    if (!fOk)
    {
        Dbg(DEB_ERROR, "RtlCreateUnicodeString failed\n");
        return;
    }

    RtlRunEncodeUnicodeString(&m_bSeed, &m_ustrPassword);
    lstrcpy(m_wzUserName, pwzUserName);
}




//+--------------------------------------------------------------------------
//
//  Member:     CBinder::GetDefaultCreds
//
//  Synopsis:   Fill specified buffers with previously saved user name and
//              password.
//
//  Arguments:  [pwzUserName] - filled with user name
//              [pwzPassword] - filled with password
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CBinder::GetDefaultCreds(
	ULONG flProvider,
    PWSTR pwzUserName,
    PWSTR pwzPassword
)
{
    CAutoCritSec Lock(&m_cs);

    if (!*m_wzUserName)
    {
        *pwzUserName = L'\0';
        *pwzPassword = L'\0';
    }
    else
    {
        lstrcpy(pwzUserName, m_wzUserName);        
		//
		//if the provider is WINNT and userName is in UPN format
		//try to translate user name in NT4 format and winnt provider
		//won't accept user name in UPN format
		//
		if((flProvider == PROVIDER_WINNT) && _IsUserNameUpn())
		{
			if(!m_bCnvrtToWinntAttepmted)
			{
				_ConvertUserNameToWinnt();
				m_bCnvrtToWinntAttepmted = true;
			}
			if(*m_wzWinntUserName)
				lstrcpy(pwzUserName, m_wzWinntUserName);        
		}

		RtlRunDecodeUnicodeString(m_bSeed, &m_ustrPassword);			
        UnicodeStringToWsz(m_ustrPassword, pwzPassword, MAX_PATH);
        RtlRunEncodeUnicodeString(&m_bSeed, &m_ustrPassword);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CBinder::ZeroCredentials
//
//  Synopsis:   Overwrite stored credentials with zeroes.
//
//  History:    07-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CBinder::ZeroCredentials()
{
    TRACE_METHOD(CBinder, ZeroCredentials);

    ZeroMemory(m_wzUserName, sizeof m_wzUserName);
	ZeroMemory(m_wzWinntUserName, sizeof m_wzWinntUserName);

    if (m_ustrPassword.Length && m_ustrPassword.Buffer)
    {
        //
        // Note m_ustrPassword.Length is the length in bytes
        // of the buffer.
        //
        ZeroMemory(m_ustrPassword.Buffer, m_ustrPassword.Length);
    }

    CServerInfo *pCur;
    CServerInfo *pNext;

    for (pCur = m_pFirstServerInfo; pCur; pCur = pNext)
    {
        pNext = pCur->Next();
        delete pCur;
    }

    m_pFirstServerInfo = NULL;
    m_pLastServerInfo = NULL;
}

//+--------------------------------------------------------------------------
//
//  Member:     CBinder::_IsUserNameUpn
//
//  Synopsis:   Checks if m_wzUserName is in UPN format
//
//  History:    04-02-2001 hiteshr Created
//
//---------------------------------------------------------------------------

bool
CBinder::_IsUserNameUpn()
{
    TRACE_METHOD(CBinder, _IsUserNameUpn);
	if(!*m_wzUserName)
		return FALSE;
	if(NULL != wcschr(m_wzUserName, L'@'))
		return true;
	else
		return false;

}

//+--------------------------------------------------------------------------
//
//  Member:     CBinder::_ConvertUserNameToWinnt
//
//  Synopsis:   Gets NT4 format user name from UPN format name.
//
//  History:    04-02-2001 hiteshr Created
//
//---------------------------------------------------------------------------
bool 
CBinder::_ConvertUserNameToWinnt()
{
	WCHAR wzPassword[MAX_PATH];
	TRACE_METHOD(CBinder, _ConvertUserNameToWinnt);
	
	//
	//Decode password
	//
    RtlRunDecodeUnicodeString(m_bSeed, &m_ustrPassword);
    UnicodeStringToWsz(m_ustrPassword, wzPassword, MAX_PATH);
	RtlRunEncodeUnicodeString(&m_bSeed, &m_ustrPassword);
	
	//
	//Return Value
	//
	bool bReturn = false;

	HANDLE token = NULL;	
	//
	//Logon to this machine using the credentials supplied by user
	//
	if(LogonUser(m_wzUserName,
				 NULL,
				 wzPassword,
				 LOGON32_LOGON_NEW_CREDENTIALS,
				 LOGON32_PROVIDER_WINNT50,
				 &token))
	{
		//
		//Let thread impersonate the security context of token. 
		//
		if(ImpersonateLoggedOnUser(token))
		{
			WCHAR wzWinntName[MAX_PATH];
			ULONG nSize = MAX_PATH;
			//
			//Translate the name from UPN to WINNT format
			//			
			if(TranslateName(m_wzUserName,
						     NameUserPrincipal,
						     NameSamCompatible,
						     wzWinntName,
						     &nSize))
			{
				wcscpy(m_wzWinntUserName,wzWinntName);
				bReturn = true;
				Dbg(DEB_BIND, "%ws convert to Winnt name %ws", m_wzUserName, m_wzWinntUserName);
			}
			//
			//Stop impersonation 
			//
			RevertToSelf();
		}


		//
		//Close the token
		//
		CloseHandle(token);
	}

	ZeroMemory(wzPassword,sizeof(wzPassword));
	return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\commonqueriestab.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       CommonQueriesDlg.cxx
//
//  Contents:   Implementation of dialog that produces an LDAP filter for
//              a number of common queries.
//
//  Classes:    CCommonQueriesTab
//
//  History:    04-03-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

static ULONG
s_aulHelpIds[] =
{
    IDC_NAME_COMBO,             IDH_NAME_COMBO,
    IDC_NAME_EDIT,              IDH_NAME_EDIT,
    IDC_DESCRIPTION_COMBO,      IDH_DESCRIPTION_COMBO,
    IDC_DESCRIPTION_EDIT,       IDH_DESCRIPTION_EDIT,
    IDC_DISABLED_CKBOX,         IDH_DISABLED_CKBOX,
    IDC_NON_EXPIRING_CKBOX,     IDH_NON_EXPIRING_CKBOX,
    IDC_LASTLOGON_COMBO,        IDH_LASTLOGON_COMBO,
    IDC_LASTLOGON_LBL,          IDH_LASTLOGON_LBL,
    IDC_DESCRIPTION_LBL,        IDH_DESCRIPTION_LBL,
    IDC_NAME_LBL,               IDH_NAME_LBL1,                
    0,0
};

//
// Forward references
//

void
GetCurrentTimeStampMinusInterval(
    int iDays,
    ULARGE_INTEGER* pULI);


//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::CCommonQueriesTab
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - containing object picker instance
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CCommonQueriesTab::CCommonQueriesTab(
    const CObjectPicker &rop):
        CAdvancedDlgTab(rop),
        m_pfnFindValidCallback(NULL),
        m_CallbackLparam(0),
        m_flUser(0),
        m_fDescriptionIsPrefix(TRUE),
        m_fNameIsPrefix(TRUE),
        m_cDaysSinceLastLogon(0)
{
    TRACE_CONSTRUCTOR(CCommonQueriesTab);
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::~CCommonQueriesTab
//
//  Synopsis:   dtor
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CCommonQueriesTab::~CCommonQueriesTab()
{
    TRACE_DESTRUCTOR(CCommonQueriesTab);

    m_pfnFindValidCallback = NULL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::DoModelessDlg
//
//  Synopsis:   Invoke the common queries subdialog as a child of the
//              tab control with window handle [hwndTab].
//
//  Arguments:  [hwndTab] - handle to parent tab control's window
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CCommonQueriesTab::DoModelessDlg(
    HWND hwndTab)
{
    TRACE_METHOD(CCommonQueriesTab, DoModelessDlg);

    HWND hwndDlg = _DoModelessDlg(hwndTab, IDD_COMMON_QUERIES);

    if (!hwndDlg)
    {
        DBG_OUT_LASTERROR;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::Show
//
//  Synopsis:   Make the common queries child dialog visible and enable
//              its child controls as appropriate
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CCommonQueriesTab::Show() const
{
    TRACE_METHOD(CCommonQueriesTab, Show);

    ShowWindow(m_hwnd, SW_SHOW);
    EnableWindow(m_hwnd, TRUE);
    Refresh();
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::Hide
//
//  Synopsis:   Hide the common queries child dialog and ensure its child
//              controls are disabled
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CCommonQueriesTab::Hide() const
{
    TRACE_METHOD(CCommonQueriesTab, Hide);

    ShowWindow(m_hwnd, SW_HIDE);
    _EnableChildControls(FALSE);
    EnableWindow(m_hwnd, FALSE);
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::_EnableChildControls
//
//  Synopsis:   Enable or disable child window controls.
//
//  Arguments:  [fEnable] - TRUE: enable the child window controls
//                          FALSE: disable all child controls.
//
//  History:    05-11-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CCommonQueriesTab::_EnableChildControls(
    BOOL fEnable) const
{
    const CFilterManager &rfm = m_rop.GetFilterManager();
    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rCurScope = rsm.GetCurScope();

    //
    // If caller wants to disable, or the current scope is invalid or
    // downlevel, disable all child controls.
    //

    if (!fEnable ||
        rCurScope.Type() == ST_INVALID ||
        IsDownlevel(rCurScope))
    {
        EnableWindow(_hCtrl(IDC_NAME_LBL), FALSE);
        EnableWindow(_hCtrl(IDC_NAME_COMBO), FALSE);
        EnableWindow(_hCtrl(IDC_NAME_EDIT), FALSE);
        EnableWindow(_hCtrl(IDC_DESCRIPTION_LBL), FALSE);
        EnableWindow(_hCtrl(IDC_DESCRIPTION_COMBO), FALSE);
        EnableWindow(_hCtrl(IDC_DESCRIPTION_EDIT), FALSE);
        EnableWindow(_hCtrl(IDC_DISABLED_CKBOX), FALSE);
        EnableWindow(_hCtrl(IDC_NON_EXPIRING_CKBOX), FALSE);
        Button_SetCheck(_hCtrl(IDC_DISABLED_CKBOX), FALSE);
        Button_SetCheck(_hCtrl(IDC_NON_EXPIRING_CKBOX), FALSE);
        Edit_SetText(_hCtrl(IDC_NAME_EDIT), L"");
        Edit_SetText(_hCtrl(IDC_DESCRIPTION_EDIT), L"");
        EnableWindow(_hCtrl(IDC_LASTLOGON_LBL), FALSE);
        EnableWindow(_hCtrl(IDC_LASTLOGON_COMBO), FALSE);
        return;
    }

    //
    // Figure out which controls to enable given the look-for and look-in
    // selections.  Name is always enabled.
    //

    BOOL fEnableDescription = TRUE;
    BOOL fEnableObjectDisabled = TRUE;
    BOOL fEnableNonExpPwd = TRUE;
    BOOL fEnableLastLogon = TRUE;

    ULONG flCur = rfm.GetCurScopeSelectedFilterFlags();
    ASSERT(!(flCur & DOWNLEVEL_FILTER_BIT));
    ASSERT(flCur);

    if (flCur & (ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS |
                 DSOP_FILTER_EXTERNAL_CUSTOMIZER))
    {
        fEnableDescription = FALSE;
        fEnableObjectDisabled = FALSE;
        fEnableNonExpPwd = FALSE;
        fEnableLastLogon = FALSE;
    }

    if (flCur & (ALL_UPLEVEL_GROUP_FILTERS | DSOP_FILTER_CONTACTS))
    {
        fEnableObjectDisabled = FALSE;
        fEnableNonExpPwd = FALSE;
        fEnableLastLogon = FALSE;
    }

    if (flCur & DSOP_FILTER_COMPUTERS)
    {
        fEnableNonExpPwd = FALSE;
    }

    // the lastLogonTimestamp doesn't propagate to GC
    if (rCurScope.Type() == ST_GLOBAL_CATALOG)
    {
        fEnableLastLogon = FALSE;
    }

    //
    // Set enable/disable state of all controls
    //

    // name
    EnableWindow(_hCtrl(IDC_NAME_LBL), TRUE);
    EnableWindow(_hCtrl(IDC_NAME_COMBO), TRUE);
    EnableWindow(_hCtrl(IDC_NAME_EDIT), TRUE);
    Edit_SetText(_hCtrl(IDC_NAME_EDIT), m_strName.c_str());

    // description
    EnableWindow(_hCtrl(IDC_DESCRIPTION_LBL), fEnableDescription);
    EnableWindow(_hCtrl(IDC_DESCRIPTION_COMBO), fEnableDescription);
    EnableWindow(_hCtrl(IDC_DESCRIPTION_EDIT), fEnableDescription);

    if (fEnableDescription)
    {
        Edit_SetText(_hCtrl(IDC_DESCRIPTION_EDIT), m_strDescription.c_str());
    }
    else
    {
        Edit_SetText(_hCtrl(IDC_DESCRIPTION_EDIT), L"");
    }

    // non-expiring password
    EnableWindow(_hCtrl(IDC_NON_EXPIRING_CKBOX), fEnableNonExpPwd);

    if (fEnableNonExpPwd && (m_flUser & UF_DONT_EXPIRE_PASSWD))
    {
        Button_SetCheck(_hCtrl(IDC_NON_EXPIRING_CKBOX), TRUE);
    }
    else
    {
        Button_SetCheck(_hCtrl(IDC_NON_EXPIRING_CKBOX), FALSE);
    }

    // object disabled
    if (!g_fExcludeDisabled)
    {
        EnableWindow(_hCtrl(IDC_DISABLED_CKBOX), fEnableObjectDisabled);
        if (fEnableObjectDisabled && (m_flUser & UF_ACCOUNTDISABLE))
        {
            Button_SetCheck(_hCtrl(IDC_DISABLED_CKBOX), TRUE);
        }
        else
        {
            Button_SetCheck(_hCtrl(IDC_DISABLED_CKBOX), FALSE);
        }
    }

    // last logon
    EnableWindow(_hCtrl(IDC_LASTLOGON_LBL), fEnableLastLogon);
    EnableWindow(_hCtrl(IDC_LASTLOGON_COMBO), fEnableLastLogon);
}




void
CCommonQueriesTab::Save(
    IPersistStream *pstm) const
{
}




void
CCommonQueriesTab::Load(
    IPersistStream *pstm)
{
}



//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::GetLdapFilter
//
//  Synopsis:   Return the LDAP filter specified by the settings of the
//              child controls
//
//  Returns:    LDAP filter
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      Filter returned contains the filter specified by current
//              Look For and Look In settings, concatenated with a more
//              specific filter based on child controls.
//
//---------------------------------------------------------------------------

String
CCommonQueriesTab::GetLdapFilter() const
{
    TRACE_METHOD(CCommonQueriesTab, GetLdapFilter);

    //
    // Get the LDAP filter associated with the current scope.  If it's
    // empty, return.
    //

    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rCurScope = rsm.GetCurScope();
    const CFilterManager &rfm = m_rop.GetFilterManager();
    String strScopeFilter = rfm.GetLdapFilter(m_hwnd, rCurScope);

    if (strScopeFilter.empty())
    {
        return strScopeFilter;
    }

    //
    // Construct the filter based on the dialog control values and
    // concatenate it to the scope filter.
    //

    String strQuery;

    if (!m_strName.empty())
    {
        String strEscaped(m_strName);
        LdapEscape(&strEscaped);

        if (m_fNameIsPrefix)
        {
            if (m_strName.find(L'@') != String::npos)
            {
                strQuery += String::format(c_wzUpnQueryFormat, strEscaped.c_str());
            }
            else
            {
                strQuery += String::format(c_wzCnQueryFormat, strEscaped.c_str());
            }
        }
        else
        {
            if (m_strName.find(L'@') != String::npos)
            {
                strQuery += String::format(c_wzUpnQueryFormatExact, strEscaped.c_str());
            }
            else
            {
                strQuery += String::format(c_wzCnQueryFormatExact, strEscaped.c_str());
            }
        }
    }

    if (!m_strDescription.empty())
    {
        String strEscaped(m_strDescription);
        LdapEscape(&strEscaped);

        //
        // A leading space is not significant inside the ldap filter, so we
        // must escape it to get it noticed.  We do this only for
        // descriptions, not for names, as it seems unlikely that any RDNs
        // will have leading spaces.
        //

        if (strEscaped[0] == L' ')
        {
            strEscaped.erase(strEscaped.begin());
            strEscaped.insert(0, String(L"\\20"));
        }

        strQuery += L"(description=" + strEscaped;

        if (m_fDescriptionIsPrefix)
        {
            strQuery += L"*";
        }
        strQuery += L")";
    }

    if (m_flUser)
    {
        WCHAR wzUserFlag[20];

        strQuery += L"(userAccountControl:" LDAP_MATCHING_RULE_BIT_AND_W;
        wsprintf(wzUserFlag, L":=%u", m_flUser);
        strQuery += wzUserFlag;
        strQuery += L")";
    }

    if (m_cDaysSinceLastLogon)
    {
        ULARGE_INTEGER li;

        GetCurrentTimeStampMinusInterval(m_cDaysSinceLastLogon, &li);
        strQuery += L"(lastLogonTimestamp<=" + UliToStr(li) + L")";
    }

    if (strQuery.empty())
    {
        return strScopeFilter;
    }
    return L"(&" + strScopeFilter + strQuery + L")";
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::GetCustomizerInteraction
//
//  Synopsis:   Set the interaction the query engine should use
//              with the ICustomizeDsBrowser interface.
//
//
//  Arguments:  [pInteraction]      - filled with CUSTINT_* enum
//              [pstrCustomizerArg] - if *[pInteraction] is not set to
//                                     CUSTINT_IGNORE_CUSTOM_OBJECTS this
//                                     string is optionally filled with a
//                                     value to give the customizer.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CCommonQueriesTab::GetCustomizerInteraction(
    CUSTOMIZER_INTERACTION  *pInteraction,
    String                  *pstrCustomizerArg) const
{
    TRACE_METHOD(CCommonQueriesTab, GetCustomizerInteraction);

    // set default response
    *pInteraction = CUSTINT_IGNORE_CUSTOM_OBJECTS;

    ULONG flags = m_rop.GetFilterManager().GetCurScopeSelectedFilterFlags();

    if (m_rop.GetExternalCustomizer())
    {
        if (!(flags & DSOP_FILTER_EXTERNAL_CUSTOMIZER))
        {
            return;
        }
    }
    else
    {
        ASSERT(!(flags & DOWNLEVEL_FILTER_BIT));

        if (!(flags & (DSOP_FILTER_EXTERNAL_CUSTOMIZER
                       | ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS)))
        {
            return;
        }
    }

    //
    // Custom objects will only be included if the only search is on the
    // name attribute.
    //

    if (!m_flUser && m_strDescription.empty())
    {
        *pstrCustomizerArg = m_strName;

        if (m_fNameIsPrefix)
        {
            *pInteraction = CUSTINT_PREFIX_SEARCH_CUSTOM_OBJECTS;
        }
        else
        {
            *pInteraction = CUSTINT_EXACT_SEARCH_CUSTOM_OBJECTS;
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::Refresh
//
//  Synopsis:   Enable child windows as appropriate for current Look For
//              and Look In settings and update the state of the Find Now
//              button.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CCommonQueriesTab::Refresh() const
{
    TRACE_METHOD(CCommonQueriesTab, Refresh);

    //
    // Enable whichever of the child controls are applicable for the
    // current scope and look-in
    //

    _EnableChildControls(TRUE);

    //
    // Read all child controls and update the find now button enabled state
    //

    _ReadChildControls();
    _UpdateFindNow();
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::_ReadChildControls
//
//  Synopsis:   Store the values in the child controls in member variables.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CCommonQueriesTab::_ReadChildControls() const
{
    m_fNameIsPrefix = !ComboBox_GetCurSel(_hCtrl(IDC_NAME_COMBO));
    m_fDescriptionIsPrefix = !ComboBox_GetCurSel(_hCtrl(IDC_DESCRIPTION_COMBO));

    _ReadEditCtrl(IDC_NAME_EDIT, &m_strName);
    m_strName.strip(String::BOTH);

    _ReadEditCtrl(IDC_DESCRIPTION_EDIT, &m_strDescription);

    m_flUser = 0;

    if (IsWindowEnabled(_hCtrl(IDC_DISABLED_CKBOX)) &&
        IsDlgButtonChecked(m_hwnd, IDC_DISABLED_CKBOX))
    {
        m_flUser |= UF_ACCOUNTDISABLE;
    }

    if (IsWindowEnabled(_hCtrl(IDC_NON_EXPIRING_CKBOX)) &&
        IsDlgButtonChecked(m_hwnd, IDC_NON_EXPIRING_CKBOX))
    {
        m_flUser |= UF_DONT_EXPIRE_PASSWD;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::_UpdateFindNow
//
//  Synopsis:   Use the Advanced dialog's callback function to set the
//              state of the Find Now button.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CCommonQueriesTab::_UpdateFindNow() const
{
    if (!m_pfnFindValidCallback)
    {
        return;
    }

    if (IsDownlevel(m_rop.GetScopeManager().GetCurScope()))
    {
        m_pfnFindValidCallback(TRUE, m_CallbackLparam);
        return;
    }

    const CFilterManager &rfm = m_rop.GetFilterManager();
    ULONG flCur = rfm.GetCurScopeSelectedFilterFlags();

    flCur &= (ALL_UPLEVEL_GROUP_FILTERS
              | ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS
              | DSOP_FILTER_CONTACTS
              | DSOP_FILTER_USERS
              | DSOP_FILTER_COMPUTERS);

    m_pfnFindValidCallback(flCur != 0, m_CallbackLparam);
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::SetFindValidCallback
//
//  Synopsis:   Store the Advanced dialog's callback.
//
//  Arguments:  [pfnFindValidCallback] - pointer to callback function
//              [lParam]               - argument to give it
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CCommonQueriesTab::SetFindValidCallback(
    PFN_FIND_VALID pfnFindValidCallback,
    LPARAM lParam)
{
    m_pfnFindValidCallback = pfnFindValidCallback;
    m_CallbackLparam = lParam;
}




//
// LASTLOGON_DAYS - used to initialize the combobox and compute the value
// to query for.
//

struct LASTLOGON_DAYS
{
    PCWSTR  wzDays;
    ULONG   ulDays;
};

static LASTLOGON_DAYS s_aLastLogonDays[] =
{
    { L"",      0 },
    { L"30",   30 },
    { L"60",   60 },
    { L"90",   90 },
    { L"120", 120 },
    { L"180", 180 }
};




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::_OnInit
//
//  Synopsis:   Initialize the dialog
//
//  Arguments:  [pfSetFocus] -
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CCommonQueriesTab::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CCommonQueriesTab, _OnInit);
    HRESULT hr = S_OK;

    hr = AddStringToCombo(_hCtrl(IDC_NAME_COMBO), IDS_STARTS_WITH);
    CHECK_HRESULT(hr);

    hr = AddStringToCombo(_hCtrl(IDC_NAME_COMBO), IDS_IS_EXACTLY);
    CHECK_HRESULT(hr);

    hr = AddStringToCombo(_hCtrl(IDC_DESCRIPTION_COMBO), IDS_STARTS_WITH);
    CHECK_HRESULT(hr);

    hr = AddStringToCombo(_hCtrl(IDC_DESCRIPTION_COMBO), IDS_IS_EXACTLY);
    CHECK_HRESULT(hr);

    ULONG i;

    for (i = 0; i < ARRAYLEN(s_aLastLogonDays); i++)
    {
        ComboBox_AddString(_hCtrl(IDC_LASTLOGON_COMBO),
                           s_aLastLogonDays[i].wzDays);
    }

    ComboBox_SetCurSel(_hCtrl(IDC_NAME_COMBO), 0);
    ComboBox_SetCurSel(_hCtrl(IDC_DESCRIPTION_COMBO), 0);
    ComboBox_SetCurSel(_hCtrl(IDC_LASTLOGON_COMBO), 0);

    if (g_fExcludeDisabled)
    {
        EnableWindow(_hCtrl(IDC_DISABLED_CKBOX), FALSE);
        ShowWindow(_hCtrl(IDC_DISABLED_CKBOX), SW_HIDE);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CCommonQueriesTab::_OnCommand
//
//  Synopsis:   Handle WM_COMMAND messages
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CCommonQueriesTab::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fNotHandled = FALSE;

    switch (LOWORD(wParam))
    {
    case IDC_NAME_EDIT:
        if (HIWORD(wParam) == EN_UPDATE &&
            IsWindowEnabled(reinterpret_cast<HWND>(lParam)))
        {
            _ReadEditCtrl(IDC_NAME_EDIT, &m_strName);
            m_strName.strip(String::BOTH);
            _UpdateFindNow();
        }
        break;

    case IDC_DESCRIPTION_EDIT:
        if (HIWORD(wParam) == EN_UPDATE &&
            IsWindowEnabled(reinterpret_cast<HWND>(lParam)))
        {
            _ReadEditCtrl(IDC_DESCRIPTION_EDIT, &m_strDescription);
            _UpdateFindNow();
        }
        break;

    case IDC_DISABLED_CKBOX:
        if (IsDlgButtonChecked(m_hwnd, IDC_DISABLED_CKBOX) &&
            IsWindowEnabled(reinterpret_cast<HWND>(lParam)))
        {
            m_flUser |= UF_ACCOUNTDISABLE;
        }
        else
        {
            m_flUser &= ~UF_ACCOUNTDISABLE;
        }
        _UpdateFindNow();
        break;

    case IDC_NON_EXPIRING_CKBOX:
        if (IsDlgButtonChecked(m_hwnd, IDC_NON_EXPIRING_CKBOX) &&
            IsWindowEnabled(reinterpret_cast<HWND>(lParam)))
        {
            m_flUser |= UF_DONT_EXPIRE_PASSWD;
        }
        else
        {
            m_flUser &= ~UF_DONT_EXPIRE_PASSWD;
        }
        _UpdateFindNow();
        break;

    case IDC_NAME_COMBO:
        if (IsWindowEnabled(reinterpret_cast<HWND>(lParam)))
        {
            m_fNameIsPrefix =
                !ComboBox_GetCurSel(reinterpret_cast<HWND>(lParam));
        }
        break;

    case IDC_DESCRIPTION_COMBO:
        if (IsWindowEnabled(reinterpret_cast<HWND>(lParam)))
        {
            m_fDescriptionIsPrefix =
                !ComboBox_GetCurSel(reinterpret_cast<HWND>(lParam));
        }
        break;

    case IDC_LASTLOGON_COMBO:
        if (IsWindowEnabled(reinterpret_cast<HWND>(lParam)))
        {
            int iCurSel = ComboBox_GetCurSel(reinterpret_cast<HWND>(lParam));

            if (iCurSel != CB_ERR)
            {
                m_cDaysSinceLastLogon = s_aLastLogonDays[iCurSel].ulDays;
            }
            else
            {
                m_cDaysSinceLastLogon = 0;
            }
        }
        break;

    default:
        fNotHandled = TRUE;
        break;
    }
    return fNotHandled;
}




BOOL
CCommonQueriesTab::_OnNotify(
    WPARAM wParam,
    LPARAM lParam)
{
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Function:   GetCurrentTimeStampMinusInterval
//
//  Synopsis:   Calculate a value to be used in an LDAP filter for
//              querying against the lastLogonTimestamp attribute.
//
//  Arguments:  [iDays] - number of days in the past to calculate
//              [pULI]  - filled with current time minus [iDays] days.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
GetCurrentTimeStampMinusInterval(
    int iDays,
    ULARGE_INTEGER* pULI)
{
    ASSERT(pULI);

    FILETIME ftCurrent;
    GetSystemTimeAsFileTime(&ftCurrent);

    pULI->LowPart = ftCurrent.dwLowDateTime;
    pULI->HighPart = ftCurrent.dwHighDateTime;
    pULI->QuadPart -= ((((ULONGLONG)iDays * 24) * 60) * 60) * 10000000;
}


void
CCommonQueriesTab::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CCommonQueriesTab, _OnHelp);

    InvokeWinHelp(message, wParam, lParam, c_wzHelpFilename, s_aulHelpIds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\columnpickerdlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       ColumnPickerDlg.cxx
//
//  Contents:   Implementation of class that displays the column picker
//              dialog
//
//  Classes:    CColumnPickerDlg
//
//  History:    06-10-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


static ULONG
s_aulHelpIds[] =
{
    IDC_AVAILABLE_LIST,     IDH_AVAILABLE_LIST,
    IDC_ADD_COL_BTN,        IDH_ADD_COL_BTN,
    IDC_REMOVE_COL_BTN,     IDH_REMOVE_COL_BTN,
    IDC_SHOWN_LIST,         IDH_SHOWN_LIST,
    0,0
};


//+--------------------------------------------------------------------------
//
//  Member:     CColumnPickerDlg::DoModal
//
//  Synopsis:   Invoke the Column Picker as a modal dialog
//
//  Arguments:  [hwndParent] - handle to parent window
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CColumnPickerDlg::DoModal(
    HWND hwndParent)
{
    TRACE_METHOD(CColumnPickerDlg, DoModal);

    return (BOOL) _DoModalDlg(hwndParent, IDD_COLUMN_PICKER);
}




//+--------------------------------------------------------------------------
//
//  Member:     CColumnPickerDlg::_OnInit
//
//  Synopsis:   Initialize the contents of the 'available' and 'shown'
//              listviews.
//
//  Arguments:  [pfSetFocus] - unused
//
//  Returns:    S_OK
//
//  History:    06-14-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CColumnPickerDlg::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CColumnPickerDlg, _OnInit);

    //
    // Add a full-width column to each of the listviews
    //

    HWND hwndLV = _hCtrl(IDC_AVAILABLE_LIST);
    if (!hwndLV)
    {
        DBG_OUT_LASTERROR;
        return HRESULT_FROM_LASTERROR;
    }
    RECT rcLV;
    VERIFY(GetClientRect(hwndLV, &rcLV));
    rcLV.right -= GetSystemMetrics(SM_CXVSCROLL);

    LVCOLUMN col;
    ZeroMemory(&col, sizeof col);

    col.mask = LVCF_WIDTH;
    col.cx = rcLV.right;

    int iCol = ListView_InsertColumn(hwndLV, 0, &col);
    if (iCol == -1)
    {
        DBG_OUT_LASTERROR;
    }
    ListView_SetExtendedListViewStyleEx(hwndLV,
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT,
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT);

    hwndLV = _hCtrl(IDC_SHOWN_LIST);
    if (!hwndLV)
    {
        DBG_OUT_LASTERROR;
        return HRESULT_FROM_LASTERROR;
    }

    VERIFY(GetClientRect(hwndLV, &rcLV));
    rcLV.right -= GetSystemMetrics(SM_CXVSCROLL);

    iCol = ListView_InsertColumn(hwndLV, 0, &col);
    if (iCol == -1)
    {
        DBG_OUT_LASTERROR;
    }

    ListView_SetExtendedListViewStyleEx(hwndLV,
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT,
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT);

    const CAttributeManager &ram = m_rop.GetAttributeManager();

    m_vakAvailable = ram.GetAttrKeysForSelectedClasses(m_hwnd);

    if (m_vakAvailable.empty())
    {
        EnableWindow(_hCtrl(IDC_ADD_COL_BTN), FALSE);
    }
    else
    {
        AttrKeyVector::iterator it;

        for (it = m_vakShown.begin(); it != m_vakShown.end(); it++)
        {
            AttrKeyVector::iterator itAvail;

            do
            {
                itAvail = find(m_vakAvailable.begin(), m_vakAvailable.end(), *it);
                if (itAvail != m_vakAvailable.end())
                {
                    m_vakAvailable.erase(itAvail);
                }
            } while (itAvail != m_vakAvailable.end());
        }
    }

    _EnsureAttributePresent(AK_NAME);
    _EnsureAttributePresent(AK_DISPLAY_PATH);

    _AddAttributesToListview(_hCtrl(IDC_AVAILABLE_LIST), m_vakAvailable);
    _AddAttributesToListview(_hCtrl(IDC_SHOWN_LIST), *m_pvakColumns);

    SetListViewSelection(_hCtrl(IDC_AVAILABLE_LIST), 0);
    SetListViewSelection(_hCtrl(IDC_SHOWN_LIST), 0);
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CColumnPickerDlg::_AddAttributesToListview
//
//  Synopsis:   Add the display names for all attributes in [vak] to the
//              listview with window handle [hwndLV].
//
//  Arguments:  [hwndLV] - handle to listview window
//              [vak]    - (possibly empty) vector of attribute keys
//
//  History:    06-14-2000   DavidMun   Created
//
//  Notes:      Adds ATTR_KEY values as lParam of listview items.
//
//---------------------------------------------------------------------------

void
CColumnPickerDlg::_AddAttributesToListview(
    HWND hwndLV,
    const AttrKeyVector &vak)
{
    LVITEM lvi;
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_TEXT | LVIF_PARAM;

    const CAttributeManager &ram = m_rop.GetAttributeManager();
    AttrKeyVector::const_iterator it;

    for (it = vak.begin(); it != vak.end(); it++)
    {
        lvi.pszText = const_cast<PWSTR>(ram.GetAttrDisplayName(*it).c_str());
        lvi.lParam = *it;
        lvi.iItem = INT_MAX;
        LONG lResult = ListView_InsertItem(hwndLV, &lvi);
        if (lResult == -1)
        {
            Dbg(DEB_ERROR,
                "Error %u inserting '%ws' in listview\n",
                GetLastError(),
                lvi.pszText);
            continue;
        }
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CColumnPickerDlg::_EnsureAttributePresent
//
//  Synopsis:   If [ak] is present in neither the available nor the shown
//              lists, add it to the available list.
//
//  Arguments:  [ak] - attribute key to check for
//
//  History:    06-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CColumnPickerDlg::_EnsureAttributePresent(
    ATTR_KEY ak)
{
    AttrKeyVector::iterator itAvail;
    AttrKeyVector::iterator itShown;

    itAvail = find(m_vakAvailable.begin(), m_vakAvailable.end(), ak);
    itShown = find(m_vakShown.begin(), m_vakShown.end(), ak);

    if (itAvail == m_vakAvailable.end() && itShown == m_vakShown.end())
    {
        m_vakAvailable.push_back(ak);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CColumnPickerDlg::_OnCommand
//
//  Synopsis:   Handle WM_COMMAND messages
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CColumnPickerDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fHandled = TRUE;

    switch (LOWORD(wParam))
    {
    case IDC_ADD_COL_BTN:
    {
        Dbg(DEB_TRACE, "UA: (CColumnPickerDlg) hit Add button\n");

        //
        // Move the selected item in the 'available' listview to the
        // 'shown' listview.
        //

        _MoveAttribute(IDC_AVAILABLE_LIST, IDC_SHOWN_LIST);

        //
        // Since the 'shown' listview must now contain at least one item,
        // ensure that the remove and OK buttons are enabled.
        //

        EnableWindow(_hCtrl(IDC_REMOVE_COL_BTN), TRUE);
        EnableWindow(_hCtrl(IDOK), TRUE);

        //
        // If the 'available' listview is now empty, disable the Add button.
        //

        if (!ListView_GetItemCount(_hCtrl(IDC_AVAILABLE_LIST)))
        {
            VERIFY(SetFocus(_hCtrl(IDC_REMOVE_COL_BTN)));
            EnableWindow(_hCtrl(IDC_ADD_COL_BTN), FALSE);
        }
        break;
    }

    case IDC_REMOVE_COL_BTN:
    {
        Dbg(DEB_TRACE, "UA: (CColumnPickerDlg) hit Remove button\n");

        _MoveAttribute(IDC_SHOWN_LIST, IDC_AVAILABLE_LIST);
        EnableWindow(_hCtrl(IDC_ADD_COL_BTN), TRUE);
        if (!ListView_GetItemCount(_hCtrl(IDC_SHOWN_LIST)))
        {
            SetFocus(_hCtrl(IDC_ADD_COL_BTN));
            EnableWindow(_hCtrl(IDC_REMOVE_COL_BTN), FALSE);
            EnableWindow(_hCtrl(IDOK), FALSE);
        }
        break;
    }

    case IDOK:
        ASSERT(!m_vakShown.empty());
        *m_pvakColumns = m_vakShown;
        EndDialog(m_hwnd, TRUE);
        break;

    case IDCANCEL:
        EndDialog(m_hwnd, FALSE);
        break;

    default:
        fHandled = FALSE;
        Dbg(DEB_WARN,
            "CColumnPickerDlg WM_COMMAND code=%#x, id=%#x, hwnd=%#x\n",
            HIWORD(wParam),
            LOWORD(wParam),
            lParam);
        break;
    }

    return fHandled;
}




//+--------------------------------------------------------------------------
//
//  Member:     CColumnPickerDlg::_MoveAttribute
//
//  Synopsis:   Move an entry from one listview (and its associated vector
//              of attribute keys) to the other.
//
//  Arguments:  [idFrom] - resource id of listview to take attribute from
//              [idTo]   - resource id of listview to move attribute to
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CColumnPickerDlg::_MoveAttribute(
    int idFrom,
    int idTo)
{
    TRACE_METHOD(CColumnPickerDlg, _MoveAttribute);
    HWND hwndLvFrom = _hCtrl(idFrom);
    HWND hwndLvTo = _hCtrl(idTo);

    do
    {
        //
        // Find out which item is selected in the 'from' listview
        //

        int iItem = ListView_GetNextItem(hwndLvFrom, -1, LVNI_SELECTED);
        const CAttributeManager &ram = m_rop.GetAttributeManager();

        ASSERT(iItem != -1);
        if (iItem == -1)
        {
            break;
        }

        //
        // Get the ATTR_KEY of that item
        //

        LVITEM lvi;
        ZeroMemory(&lvi, sizeof lvi);
        lvi.mask = LVIF_PARAM;
        lvi.iItem = iItem;

        if (!ListView_GetItem(hwndLvFrom, &lvi))
        {
            DBG_OUT_LASTERROR;
            break;
        }

        ATTR_KEY ak = static_cast<ATTR_KEY>(lvi.lParam);

        //
        // Remove that item from the 'from' listview
        //

        ListView_DeleteItem(hwndLvFrom, iItem);

        // Set the selection on the next item in the 'from' listview.  The
        // next item is now at the same index as the one we just deleted.
        // NTRAID#NTBUG9-361131-2001/04/11-sburns

        int lastIndex = ListView_GetItemCount(hwndLvFrom) - 1;
               
        ListView_SetItemState(
                              hwndLvFrom,
                              min(iItem, lastIndex),
                              LVIS_SELECTED,
                              LVIS_SELECTED);
        
        //
        // Also remove it from the corresponding vector
        //

        if (idFrom == IDC_AVAILABLE_LIST)
        {
            m_vakAvailable.erase(find(m_vakAvailable.begin(), m_vakAvailable.end(), ak));
        }
        else
        {
            m_vakShown.erase(find(m_vakShown.begin(), m_vakShown.end(), ak));
        }

        //
        // Now add the item to the 'to' listview
        //

        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iItem = ListView_GetNextItem(hwndLvTo, -1, LVNI_SELECTED);

        if (lvi.iItem == -1)
        {
            lvi.iItem = INT_MAX;
        }

        lvi.pszText = const_cast<PWSTR>(ram.GetAttrDisplayName(ak).c_str());

        iItem = ListView_InsertItem(hwndLvTo, &lvi);

        if (iItem == -1)
        {
            DBG_OUT_LASTERROR;
        }

        ListView_SetItemState(hwndLvTo,
                              iItem,
                              LVIS_SELECTED | LVIS_FOCUSED,
                              LVIS_SELECTED | LVIS_FOCUSED);
        ListView_EnsureVisible(hwndLvTo, iItem, FALSE);

        //
        // And add it to the corresponding vector
        //

        if (idTo == IDC_AVAILABLE_LIST)
        {
            m_vakAvailable.push_back(ak);
        }
        else
        {
            if (iItem == -1)
            {
                m_vakShown.push_back(ak);
            }
            else
            {
                m_vakShown.insert(m_vakShown.begin() + iItem, ak);
            }
        }

    } while (0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CColumnPickerDlg::_OnNotify
//
//  Synopsis:   Handle WM_NOTIFY messages
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CColumnPickerDlg::_OnNotify(
    WPARAM wParam,
    LPARAM lParam)
{
    LPNMHDR pnmh = reinterpret_cast<LPNMHDR> (lParam);

    do
    {
        // don't care about notifications from stuff other than listviews

        if (pnmh->idFrom != IDC_AVAILABLE_LIST &&
            pnmh->idFrom != IDC_SHOWN_LIST)
        {
            break;
        }

        // don't care about listview notifications other than item changed

        if (pnmh->code != LVN_ITEMCHANGED)
        {
            return FALSE;
        }

        HWND hwndBtn;
        HWND hwndFocusOnDisableBtn;

        if (pnmh->idFrom == IDC_AVAILABLE_LIST)
        {
            hwndBtn = _hCtrl(IDC_ADD_COL_BTN);
            hwndFocusOnDisableBtn = _hCtrl(IDC_SHOWN_LIST);
        }
        else
        {
            hwndBtn = _hCtrl(IDC_REMOVE_COL_BTN);
            hwndFocusOnDisableBtn = _hCtrl(IDC_AVAILABLE_LIST);
        }

        if (!hwndBtn)
        {
            DBG_OUT_HRESULT(E_OUTOFMEMORY);
            break;
        }
    } while (0);

    return FALSE;
}



void
CColumnPickerDlg::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CColumnPickerDlg, _OnHelp);

    InvokeWinHelp(message, wParam, lParam, c_wzHelpFilename, s_aulHelpIds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\dataobj.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       dataobj.cxx
//
//  Contents:   Implementation of data object class
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


UINT CDataObject::s_cfDsSelectionList =
    RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

UINT CDataObject::s_cfDsObjectList =
    RegisterClipboardFormat(CFSTR_DSOP_DS_OBJECT_LIST);

DEBUG_DECLARE_INSTANCE_COUNTER(CDataObject)


//+--------------------------------------------------------------------------
//
//  Class:      CDataObjectReleaser
//
//  Purpose:    Helper class to clean up the hglobal and associated
//              VARIANTs returned by the data object.
//
//  History:    3-08-1999   DavidMun   Created
//
//  Notes:      Inherits from IUnknown, but only Release is implemented.
//
//---------------------------------------------------------------------------

class CDataObjectReleaser: public IUnknown
{
public:

    //
    // IUnknown overrides
    //

    STDMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);

    STDMETHOD_(ULONG, AddRef) ();

    STDMETHOD_(ULONG, Release) ();


    CDataObjectReleaser(
        HGLOBAL hGlobal);

    ~CDataObjectReleaser();

private:

    HGLOBAL m_hGlobal;
};



//+--------------------------------------------------------------------------
//
//  Member:     CDataObjectReleaser::CDataObjectReleaser
//
//  Synopsis:   cdor
//
//  Arguments:  [hGlobal] - global to free on release
//
//  History:    3-08-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

CDataObjectReleaser::CDataObjectReleaser(
    HGLOBAL hGlobal):
        m_hGlobal(hGlobal)
{
    TRACE_CONSTRUCTOR_EX(DEB_DATAOBJECT, CDataObjectReleaser);
    ASSERT(hGlobal);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObjectReleaser::~CDataObjectReleaser
//
//  Synopsis:   dtor
//
//  History:    3-08-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

CDataObjectReleaser::~CDataObjectReleaser()
{
    TRACE_DESTRUCTOR_EX(DEB_DATAOBJECT, CDataObjectReleaser);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObjectReleaser::AddRef
//
//  Synopsis:   Not implemented.
//
//  History:    3-08-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDataObjectReleaser::AddRef()
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObjectReleaser, AddRef);
    ASSERT(0 && "CDataObjectReleaser::AddRef should never be called!");
    return 1;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObjectReleaser::Release
//
//  Synopsis:   Free all memory held in or referenced by the global
//              memory block containing a DS_SELECTION_LIST.
//
//  Returns:    0
//
//  History:    3-05-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDataObjectReleaser::Release()
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObjectReleaser, Release);
    ASSERT(m_hGlobal);

    PDS_SELECTION_LIST pdssel = NULL;

    do
    {
        pdssel = (PDS_SELECTION_LIST)GlobalLock(m_hGlobal);

        if (!pdssel)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        //
        // If there aren't any attributes, there are no variants to
        // worry about.
        //

        if (!pdssel->cFetchedAttributes)
        {
            break;
        }

        //
        // Clear all the variants for each object.
        //

        ULONG i;

        for (i = 0; i < pdssel->cItems; i++)
        {
            pdssel->aDsSelection[i].pvarFetchedAttributes;

            ULONG j;

            for (j = 0; j < pdssel->cFetchedAttributes; j++)
            {
                VariantClear(&pdssel->aDsSelection[i].pvarFetchedAttributes[j]);
            }
        }
    } while (0);

    if (pdssel)
    {
        GlobalUnlock(m_hGlobal);
    }

    GlobalFree(m_hGlobal);
    m_hGlobal = NULL;
    delete this;

    return 0;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObjectReleaser::QueryInterface
//
//  Synopsis:   Not implemented.
//
//  History:    3-08-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObjectReleaser::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObjectReleaser, QueryInterface);
    ASSERT(0 && "CDataObjectReleaser::QueryInteface should never be called!");
    return E_NOTIMPL;
}



//============================================================================
//
// IUnknown implementation
//
//============================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::QueryInterface
//
//  Synopsis:   Standard OLE
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    // TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, QueryInterface);
    HRESULT hr = S_OK;

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppvObj = (IUnknown *)(IDataObject *)this;
        }
        else if (IsEqualIID(riid, IID_IDataObject))
        {
            *ppvObj = (IUnknown *)(IDataObject *)this;
        }
        else
        {
            DBG_OUT_NO_INTERFACE("CDataObject", riid);
            hr = E_NOINTERFACE;
            *ppvObj = NULL;
            break;
        }

        //
        // If we got this far we are handing out a new interface pointer on
        // this object, so addref it.
        //

        AddRef();
    } while (0);

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Member:     CDataObject::AddRef
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *) &m_cRefs);
}




//+---------------------------------------------------------------------------
//
//  Member:     CDataObject::Release
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CDataObject::Release()
{
    ULONG cRefsTemp;

    cRefsTemp = InterlockedDecrement((LONG *)&m_cRefs);

    if (0 == cRefsTemp)
    {
        delete this;
    }

    return cRefsTemp;
}




//============================================================================
//
// IDataObject implementation
//
//============================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::GetData
//
//  Synopsis:   Return data in the requested format
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::GetData(
        FORMATETC *pFormatEtc,
        STGMEDIUM *pMedium)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, GetData);

    HRESULT hr = S_OK;

    //
    // Init default output medium.  If any of the individual _getdata*
    // methods use something else, they can override.
    //

    pMedium->pUnkForRelease = NULL;
    pMedium->tymed = TYMED_HGLOBAL;
    pMedium->hGlobal = NULL;

    if (m_dsol.empty() && m_strData.empty())
    {
        return S_FALSE;
    }

    try
    {
        if (pFormatEtc->cfFormat == s_cfDsObjectList)
        {
            hr = _GetDataDsol(pFormatEtc, pMedium);
        }
        else if (pFormatEtc->cfFormat == s_cfDsSelectionList)
        {
            hr = _GetDataDsSelList(pFormatEtc, pMedium);
        }
        else if (pFormatEtc->cfFormat == CF_UNICODETEXT ||
                 pFormatEtc->cfFormat == CF_TEXT)
        {
            hr = _GetDataText(pFormatEtc, pMedium, pFormatEtc->cfFormat);
        }
        else
        {
            hr = DV_E_FORMATETC;
    #if (DBG == 1)
            Dbg(DEB_WARN,
                "CDataObject::GetData: unrecognized cf %#x\n",
                pFormatEtc->cfFormat);
    #endif // (DBG == 1)
        }
    }
    catch (const exception &e)
    {
        Dbg(DEB_ERROR, "Caught exception %s\n", e.what());
        hr = E_OUTOFMEMORY;
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::_GetDataDsol
//
//  Synopsis:   Return data in the internal format of a CDsObjectList.
//
//  History:    01-18-1999   DavidMun   Created
//
//  Notes:      WinNT group classes remain "LocalGroup" and "GlobalGroup".
//
//---------------------------------------------------------------------------

HRESULT
CDataObject::_GetDataDsol(
        FORMATETC *pFormatEtc,
        STGMEDIUM *pMedium)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, _GetDataDsol);
    ASSERT(pFormatEtc->tymed & TYMED_HGLOBAL);

    CDsObjectList *pdsolCopy = new CDsObjectList(m_dsol);

    pMedium->hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD,
                                   sizeof(CDsObjectList **));

    if (!pMedium->hGlobal)
    {
        delete pdsolCopy;
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return STG_E_MEDIUMFULL;
    }

    *(CDsObjectList **)GlobalLock(pMedium->hGlobal) = pdsolCopy;
    GlobalUnlock(pMedium->hGlobal);
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::_GetDataText
//
//  Synopsis:   Return data in text format
//
//  Arguments:  [pFormatEtc] -
//              [pMedium]    -
//              [cf]         - CF_TEXT or CF_UNICODETEXT
//
//  History:    5-21-1999   davidmun   Created
//
//  Notes:      Returns empty string unless this was constructed with
//              handle to rich edit control.
//
//---------------------------------------------------------------------------

HRESULT
CDataObject::_GetDataText(
        FORMATETC *pFormatEtc,
        STGMEDIUM *pMedium,
        ULONG      cf)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, _GetDataText);
    ASSERT(cf == CF_TEXT || cf == CF_UNICODETEXT);
    ASSERT(pFormatEtc->tymed & TYMED_HGLOBAL);

    HRESULT hr = S_OK;
    ULONG   cbChar = (ULONG)((cf == CF_UNICODETEXT) ? sizeof(WCHAR) : sizeof(CHAR));
    ULONG   cbMedium = cbChar * (static_cast<ULONG>(m_strData.length()) + 1);

    pMedium->hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD,
                                   cbMedium);

    if (!pMedium->hGlobal)
    {
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return STG_E_MEDIUMFULL;
    }

    PVOID pvMedium = GlobalLock(pMedium->hGlobal);

    if (cf == CF_UNICODETEXT)
    {
        lstrcpy((PWSTR)pvMedium, m_strData.c_str());
    }
    else
    {
        hr = UnicodeToAnsi((PSTR)pvMedium, m_strData.c_str(), cbMedium);
    }
    GlobalUnlock(pMedium->hGlobal);
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::_GetDataDsSelList
//
//  Synopsis:   Return data in the public format of a buffer containing a
//              DS_SELECTION_LIST variable length structure.
//
//  History:    01-18-1999   DavidMun   Created
//
//  Notes:      WinNT group classes are translated from the internal
//              representation of "LocalGroup" and "GlobalGroup" to
//              "Group".
//
//---------------------------------------------------------------------------

HRESULT
CDataObject::_GetDataDsSelList(
        FORMATETC *pFormatEtc,
        STGMEDIUM *pMedium)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, _GetDataDsSelList);
    ASSERT(m_dsol.size());
    ASSERT(pFormatEtc->tymed & TYMED_HGLOBAL);

    //
    // Determine the amount of memory to allocate:
    // First the header structure, DS_SELECTION_LIST
    //

    BOOL  fLockedMem = FALSE;
    size_t cbRequired = sizeof(DS_SELECTION_LIST);

    //
    // DSSELECTIONLIST contains one DSSELECTION struct, include space
    // for the rest
    //

    cbRequired += (m_dsol.size() - 1) * sizeof(DS_SELECTION);

    //
    // Include the name and variable length data associated with each
    // selection.
    //

    CDsObjectList::const_iterator itSelectedObjects;

    for (itSelectedObjects = m_dsol.begin(); itSelectedObjects != m_dsol.end(); itSelectedObjects++)
    {
        cbRequired += itSelectedObjects->GetMarshalSize();
    }

#if (DBG == 1)
    size_t cbAllocatedBeforeVariants = cbRequired;
#endif // (DBG == 1)

    //
    // Each DS_SELECTION struct includes a pointer to an array of
    // VARIANTs, one for each attribute to fetch.
    //

    const vector<String> &rvAttrToFetch = m_rpop->GetAttrToFetchVector();
    ULONG cAttrToFetch = static_cast<ULONG>(rvAttrToFetch.size());

    if (cAttrToFetch)
    {
        cbRequired += m_dsol.size() *
                        sizeof(VARIANT) * cAttrToFetch;

        // add space for slack bytes so we can be sure to get pointer
        // alignment

        cbRequired += sizeof (void *);
    }

    //
    // Allocate a block
    //

    PDS_SELECTION_LIST pdssel;

    pMedium->hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD,
                                   cbRequired);

    if (!pMedium->hGlobal)
    {
        Dbg(DEB_ERROR,
            "GlobalAlloc for %uL bytes failed\n",
            cbRequired);
        return STG_E_MEDIUMFULL;
    }

    pdssel = reinterpret_cast<PDS_SELECTION_LIST>
        (GlobalLock(pMedium->hGlobal));

    fLockedMem = TRUE;
    ZeroMemory(pdssel, cbRequired);

    //
    // Fill it in
    //

    pdssel->cItems = static_cast<ULONG>(m_dsol.size());
    pdssel->cFetchedAttributes = cAttrToFetch;

    //
    // Get a pointer to just past the end of the fixed length part of the
    // buffer: the last of the DS_SELECTION structs.
    //

    PWSTR pwzNextString = (PWSTR)(PBYTE)&pdssel->aDsSelection[m_dsol.size()];

    ULONG i;

    const CScopeManager &rsm = m_rpop->GetScopeManager();

    for (i = 0, itSelectedObjects = m_dsol.begin(); itSelectedObjects != m_dsol.end(); i++, itSelectedObjects++)
    {
        PDS_SELECTION pDsCur = &pdssel->aDsSelection[i];

        pDsCur->pwzName = pwzNextString;
        lstrcpy(pwzNextString, itSelectedObjects->GetName());
        Dbg(DEB_TRACE, "*** Name '%ws'\n", pwzNextString);
        pwzNextString += lstrlen(pwzNextString) + 1;

        pDsCur->pwzClass = pwzNextString;

        //
        // Convert from internal localGroup/globalGroup class to
        // group class.
        //

        if (!lstrcmpi(itSelectedObjects->GetClass(), c_wzLocalGroupClass) ||
            !lstrcmpi(itSelectedObjects->GetClass(), c_wzGlobalGroupClass))
        {
            lstrcpy(pwzNextString, c_wzGroupObjectClass);
        }
        else
        {
            lstrcpy(pwzNextString, itSelectedObjects->GetClass());
        }

        Dbg(DEB_TRACE, "*** Class '%ws'\n", pwzNextString);
        pwzNextString += lstrlen(pwzNextString) + 1;

        pDsCur->pwzADsPath = pwzNextString;

        BSTR bstrADsPath = itSelectedObjects->GetAttr(AK_PROCESSED_ADSPATH).GetBstr();
        if (!*bstrADsPath)
        {
           bstrADsPath = itSelectedObjects->GetADsPath();
        }

        lstrcpy(pwzNextString, bstrADsPath);
        Dbg(DEB_TRACE, "*** Path '%ws'\n", pwzNextString);
        pwzNextString += lstrlen(pwzNextString) + 1;

        pDsCur->pwzUPN = pwzNextString;
        lstrcpy(pwzNextString, itSelectedObjects->GetUpn());
        Dbg(DEB_TRACE, "*** UPN '%ws'\n", pwzNextString);
        pwzNextString += lstrlen(pwzNextString) + 1;

        ULONG idOwningScope = itSelectedObjects->GetOwningScopeID();
        const CScope *pOwningScope = &rsm.LookupScopeById(idOwningScope);

        while (pOwningScope->Type() == ST_LDAP_CONTAINER)
        {
            pOwningScope = &rsm.GetParent(*pOwningScope);
        }
        ASSERT(!IsInvalid(*pOwningScope));
        pDsCur->flScopeType = static_cast<ULONG>(pOwningScope->Type());
    }

#if (DBG == 1)
    size_t cbUsedBeforeVariants = (PBYTE)pwzNextString - (PBYTE)pdssel;

    Dbg(DEB_TRACE,
        "cbAllocatedBeforeVariants=%uL, cbUsedBeforeVariants=%uL\n",
        cbAllocatedBeforeVariants,
        cbUsedBeforeVariants);
    ASSERT(cbAllocatedBeforeVariants == cbUsedBeforeVariants);
#endif // (DBG == 1)

    //
    // If there are no other attributes to fetch for each item, we're
    // done, since the buffer is zero initialized, making the
    // pvarOtherAttributes member of each DS_SELECTION structure NULL.
    //

    if (cAttrToFetch)
    {
        //
        // The variants are stored after the last of the strings.  The strings
        // are WORD aligned, introduce slack bytes before the first of the
        // variants if necessary to make it aligned on a pointer-sized
        // boundary.
        //

        ULONG_PTR ulp = reinterpret_cast<ULONG_PTR>(pwzNextString);

        if (ulp % sizeof(void *))
        {
            ulp += sizeof(void *) - (ulp % sizeof(void *));
            pwzNextString = reinterpret_cast<PWSTR>(ulp);
        }
        ASSERT(!((ULONG_PTR) pwzNextString % sizeof(ULONG_PTR)));

        LPVARIANT pvarNext = (LPVARIANT) pwzNextString;

        for (i = 0, itSelectedObjects = m_dsol.begin();
             itSelectedObjects != m_dsol.end();
             i++, itSelectedObjects++)
        {
            pdssel->aDsSelection[i].pvarFetchedAttributes = pvarNext;

            vector<String>::const_iterator itAttrToFetch;

            for (itAttrToFetch = rvAttrToFetch.begin();
                 itAttrToFetch != rvAttrToFetch.end();
                 itAttrToFetch++)
            {
                ASSERT(pvarNext);

                const Variant &varFetched =
                    itSelectedObjects->GetAttr(*itAttrToFetch, *m_rpop.get());

                HRESULT hr2;
                Variant &varFetchedNonConst =
                    const_cast<Variant &>(varFetched);
                hr2 = VariantCopy(pvarNext, &varFetchedNonConst);
                CHECK_HRESULT(hr2);
                pvarNext++;
            }
        }

        //
        // Include a punkForRelease to clean up these variants.
        //

        pMedium->pUnkForRelease = (IUnknown *)
            new CDataObjectReleaser(pMedium->hGlobal);
    }

    if (fLockedMem)
    {
        GlobalUnlock(pMedium->hGlobal);
    }
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::GetDataHere
//
//  Synopsis:   Fill the hGlobal in [pmedium] with the requested data
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::GetDataHere(
        FORMATETC *pFormatEtc,
        STGMEDIUM *pMedium)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, GetDataHere);

    return E_NOTIMPL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::QueryGetData
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::QueryGetData(
        FORMATETC *pformatetc)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, QueryGetData);
    return E_NOTIMPL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::GetCanonicalFormatEtc
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::GetCanonicalFormatEtc(
        FORMATETC *pformatectIn,
        FORMATETC *pformatetcOut)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, GetCanonicalFormatEtc);
    return E_NOTIMPL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::SetData
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::SetData(
    FORMATETC *pformatetc,
    STGMEDIUM *pmedium,
    BOOL fRelease)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, SetData);
    return E_NOTIMPL;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::EnumFormatEtc
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::EnumFormatEtc(
    DWORD dwDirection,
    IEnumFORMATETC **ppenumFormatEtc)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, EnumFormatEtc);
    return E_NOTIMPL;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::DAdvise
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::DAdvise(
    FORMATETC *pformatetc,
    DWORD advf,
    IAdviseSink *pAdvSink,
    DWORD *pdwConnection)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, DAdvise);
    return E_NOTIMPL;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::DUnadvise
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::DUnadvise(
    DWORD dwConnection)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, DUnadvise);
    return E_NOTIMPL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::EnumDAdvise
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CDataObject::EnumDAdvise(
    IEnumSTATDATA **ppenumAdvise)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CDataObject, EnumDAdvise);
    return E_NOTIMPL;
}




//============================================================================
//
// Non interface method implementation
//
//============================================================================


//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CDataObject
//
//  Synopsis:   ctor
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDataObject::CDataObject(
        CObjectPicker *pop,
        const CDsObjectList &dsol):
            m_cRefs(1),
            m_rpop(pop)
{
    TRACE_CONSTRUCTOR_EX(DEB_DATAOBJECT, CDataObject);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDataObject);

    m_dsol.assign(dsol.begin(), dsol.end());
}



//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::CDataObject
//
//  Synopsis:   ctor
//
//  Arguments:  [hwndRichEdit] - contains text and embedded objects
//              [pchrg]        - char position range to copy
//
//  History:    5-21-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CDataObject::CDataObject(
    HWND hwndRichEdit,
    CHARRANGE *pchrg):
        m_cRefs(1)
{
    TRACE_CONSTRUCTOR_EX(DEB_DATAOBJECT, CDataObject);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDataObject);
    HRESULT         hr = S_OK;
    IRichEditOle   *pRichEditOle = NULL;

    do
    {
        // If range is empty, do nothing

        if (pchrg->cpMin == pchrg->cpMax)
        {
            break;
        }

        ULONG cch = Edit_GetTextLength(hwndRichEdit);
        PWSTR pwzBuf = new WCHAR[cch + 1];

        pwzBuf[0] = L'\0'; // in case gettext fails
        Edit_GetText(hwndRichEdit, pwzBuf, cch + 1);
        m_strData = pwzBuf + pchrg->cpMin;

        if (pchrg->cpMax != -1)
        {
            if (pchrg->cpMax < cch)
            {
                m_strData.erase(pchrg->cpMax - pchrg->cpMin);
            }
        }

        delete [] pwzBuf;
        pwzBuf = NULL;

        LRESULT lResult = SendMessage(hwndRichEdit,
                                     EM_GETOLEINTERFACE,
                                     0,
                                     (LPARAM) &pRichEditOle);

        if (!lResult)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        LONG cObjects = pRichEditOle->GetObjectCount();
        LONG i;
        LONG cchOffset = 0;

        for (i = 0; i < cObjects; i++)
        {
            REOBJECT reobj;

            ZeroMemory(&reobj, sizeof reobj);
            reobj.cbStruct = sizeof(reobj);

            hr = pRichEditOle->GetObject(i, &reobj, REO_GETOBJ_POLEOBJ);

            if (FAILED(hr))
            {
                DBG_OUT_HRESULT(hr);
                continue;
            }

            ASSERT(reobj.poleobj);

            String strDisplayName;

            CDsObject *pdso = (CDsObject *)(CEmbeddedDsObject*)reobj.poleobj;
            pdso->GetDisplayName(&strDisplayName, TRUE);
            reobj.poleobj->Release();

            if (reobj.cp >= pchrg->cpMin &&
                (pchrg->cpMax == -1 || reobj.cp < pchrg->cpMax))
            {
                m_strData.erase(reobj.cp + cchOffset - pchrg->cpMin, 1);
                m_strData.insert(reobj.cp + cchOffset - pchrg->cpMin,
                                 strDisplayName);
                cchOffset += static_cast<ULONG>(strDisplayName.length()) - 1;
            }
        }

    } while (0);

    SAFE_RELEASE(pRichEditOle);
}





//+--------------------------------------------------------------------------
//
//  Member:     CDataObject::~CDataObject
//
//  Synopsis:   dtor
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDataObject::~CDataObject()
{
    TRACE_DESTRUCTOR_EX(DEB_DATAOBJECT, CDataObject);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CDataObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\debug.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       debug.cxx
//
//  Contents:   Debugging routines
//
//  History:    09-04-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

DECLARE_INFOLEVEL(opd)


#if (DBG == 1)


void __cdecl
CTimer::Init(LPCSTR pszTitleFmt, ...)
{
    va_list va;
    va_start(va, pszTitleFmt);

    m_ulStart = GetTickCount();
    WCHAR wzTitleFmt[MAX_PATH];

    MultiByteToWideChar(CP_ACP,
                        0,
                        pszTitleFmt,
                        -1,
                        wzTitleFmt,
                        ARRAYLEN(wzTitleFmt));

    int iRet = _vsnwprintf(m_wzTitle, ARRAYLEN(m_wzTitle), wzTitleFmt, va);

    if (iRet == -1)
    {
        // resulting string too large and was truncated.  ensure null
        // termination.

        m_wzTitle[ARRAYLEN(m_wzTitle) - 1] = L'\0';
    }
    va_end(va);

}




CTimer::~CTimer()
{
    ULONG ulStop = GetTickCount();
    ULONG ulElapsedMS = ulStop - m_ulStart;

    ULONG ulSec = ulElapsedMS / 1000;
    ULONG ulMillisec = ulElapsedMS - (ulSec * 1000);

    Dbg(DEB_PERF, "Timer: %ws took %u.%03us\n", m_wzTitle, ulSec, ulMillisec);
}




PCWSTR
NextNonWs(
        PCWSTR pwzCur)
{
    while (wcschr(L" \t\n", *pwzCur))
    {
        pwzCur++;
    }
    return pwzCur;
}




void
DumpQuery(
    LPCSTR pzTitle,
    LPCTSTR ptszLdapQuery)
{
    Dbg(DEB_TRACE, "%hs\n", pzTitle);

    LPCTSTR pwzCur = ptszLdapQuery;

    if (!pwzCur)
    {
        Dbg(DEB_TRACE, "Query is NULL\n");
        return;
    }

    ULONG cchIndent = 0;
    ULONG i;
    PWSTR pwzCurLine;

    while (*pwzCur)
    {
        pwzCur = NextNonWs(pwzCur);

        if (*pwzCur == L'(' && wcschr(L"!&|", *NextNonWs(pwzCur + 1)))
        {
            pwzCurLine = new WCHAR[4 + cchIndent];

            for (i = 0; i < cchIndent; i++)
            {
                pwzCurLine[i] = L' ';
            }
            pwzCurLine[i + 0] = L'(';
            pwzCurLine[i + 1] = *NextNonWs(pwzCur + 1);
            pwzCurLine[i + 2] = L'\n';
            pwzCurLine[i + 3] = L'\0';

            cchIndent++;
            pwzCur = NextNonWs(pwzCur + 1) + 1;
        }
        else if (*NextNonWs(pwzCur) == L')')
        {
            cchIndent--;

            pwzCurLine = new WCHAR[3 + cchIndent];

            for (i = 0; i < cchIndent; i++)
            {
                pwzCurLine[i] = L' ';
            }
            pwzCurLine[i + 0] = L')';
            pwzCurLine[i + 1] = L'\n';
            pwzCurLine[i + 2] = L'\0';

            pwzCur = NextNonWs(pwzCur) + 1;
        }
        else
        {
            pwzCur = NextNonWs(pwzCur);

            ASSERT(*pwzCur == L'(');
            PCWSTR pwzCloseParen;
            ULONG cOpen = 0;

            for (pwzCloseParen = pwzCur + 1; *pwzCloseParen; pwzCloseParen++)
            {
                if (*pwzCloseParen == L'(')
                {
                    cOpen++;
                }
                else if (*pwzCloseParen == L')')
                {
                    if (!cOpen)
                    {
                        break;
                    }
                    cOpen--;
                }
            }

            if (!*pwzCloseParen)
            {
                Dbg(DEB_ERROR,
                    "DumpQuery: close paren not found in '%ws'\n",
                    pwzCur);
                return;
            }

            size_t cchClause = pwzCloseParen - pwzCur + 1;

            pwzCurLine = new WCHAR[cchClause + cchIndent + 2];

            for (i = 0; i < cchIndent; i++)
            {
                pwzCurLine[i] = L' ';
            }

            CopyMemory(&pwzCurLine[i], pwzCur, sizeof(WCHAR) * cchClause);
            lstrcpy(&pwzCurLine[i + cchClause], L"\n");
            pwzCur += cchClause;
        }

        Dbg(DEB_TRACE, pwzCurLine);
        delete [] pwzCurLine;
    }

    //
    // Well formed query should have balanced parentheses
    //

    ASSERT(!cchIndent);
}




//+--------------------------------------------------------------------------
//
//  Function:   IsSingleBitFlag
//
//  Synopsis:   Return TRUE if exactly one bit in [flags] is set, FALSE
//              otherwise.
//
//  History:    08-31-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
IsSingleBitFlag(
    ULONG flags)
{
    if (!flags)
    {
        return FALSE;
    }

    while (!(flags & 1))
    {
        flags >>= 1;
    }

    return !(flags & ~1UL);
}



#define DUMP_IF_SET(fl, bit)                    \
    if (((fl) & (bit)) == (bit))                \
    {                                           \
        Dbg(DEB_TRACE, "    %hs\n", #bit);      \
    }


//+--------------------------------------------------------------------------
//
//  Function:   DumpScopeType
//
//  Synopsis:
//
//  Arguments:  [flType] -
//
//  Returns:
//
//  Modifies:
//
//  History:    09-29-1998   DavidMun   Created
//
//  Notes:
//
//---------------------------------------------------------------------------

void
DumpScopeType(
    ULONG flType)
{
    Dbg(DEB_TRACE, "  ScopeType:\n");

    if (!flType)
    {
        Dbg(DEB_TRACE, "    DSOP_SCOPE_TYPE_INVALID\n");
        return;
    }

    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_TARGET_COMPUTER);
    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN);
    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN);
    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN);
    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_GLOBAL_CATALOG);
    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN);
    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN);
    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_WORKGROUP);
    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE);
    DUMP_IF_SET(flType, DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE);
}

void
DumpScopeFlags(
    ULONG flScope)
{
    if (flScope)
    {
        Dbg(DEB_TRACE, "  flScope:\n");

        DUMP_IF_SET(flScope, DSOP_SCOPE_FLAG_STARTING_SCOPE);
        DUMP_IF_SET(flScope, DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT);
        DUMP_IF_SET(flScope, DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP);
        DUMP_IF_SET(flScope, DSOP_SCOPE_FLAG_WANT_SID_PATH);
        DUMP_IF_SET(flScope, DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS);
        DUMP_IF_SET(flScope, DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS);
        DUMP_IF_SET(flScope, DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS);
        DUMP_IF_SET(flScope, DSOP_SCOPE_FLAG_DEFAULT_FILTER_CONTACTS);
    }
}

void
_DumpUplevelFilterFlags(ULONG flags)
{
    DUMP_IF_SET(flags, DSOP_FILTER_INCLUDE_ADVANCED_VIEW);
    DUMP_IF_SET(flags, DSOP_FILTER_USERS);
    DUMP_IF_SET(flags, DSOP_FILTER_BUILTIN_GROUPS);
    DUMP_IF_SET(flags, DSOP_FILTER_WELL_KNOWN_PRINCIPALS);
    DUMP_IF_SET(flags, DSOP_FILTER_UNIVERSAL_GROUPS_DL);
    DUMP_IF_SET(flags, DSOP_FILTER_UNIVERSAL_GROUPS_SE);
    DUMP_IF_SET(flags, DSOP_FILTER_GLOBAL_GROUPS_DL);
    DUMP_IF_SET(flags, DSOP_FILTER_GLOBAL_GROUPS_SE);
    DUMP_IF_SET(flags, DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL);
    DUMP_IF_SET(flags, DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE);
    DUMP_IF_SET(flags, DSOP_FILTER_CONTACTS);
    DUMP_IF_SET(flags, DSOP_FILTER_COMPUTERS);
}

void
_DumpDownlevelFilterFlags(ULONG flags)
{
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_USERS);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_COMPUTERS);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_WORLD);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_ANONYMOUS);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_BATCH);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_CREATOR_OWNER);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_CREATOR_GROUP);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_DIALUP);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_INTERACTIVE);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_NETWORK);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_SERVICE);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_SYSTEM);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_TERMINAL_SERVER);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_LOCAL_SERVICE);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_NETWORK_SERVICE);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_REMOTE_LOGON);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS);
    DUMP_IF_SET(flags, DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS);
}


void
DumpFilterFlags(
    const DSOP_FILTER_FLAGS &FilterFlags)
{
    if (FilterFlags.Uplevel.flBothModes)
    {
        Dbg(DEB_TRACE,
            "  FilterFlags.Uplevel.flBothModes (%#x)\n",
            FilterFlags.Uplevel.flBothModes);
        _DumpUplevelFilterFlags(FilterFlags.Uplevel.flBothModes);
    }

    if (FilterFlags.Uplevel.flMixedModeOnly)
    {
        Dbg(DEB_TRACE,
            "  FilterFlags.Uplevel.flMixedModeOnly (%#x)\n",
            FilterFlags.Uplevel.flMixedModeOnly);
        _DumpUplevelFilterFlags(FilterFlags.Uplevel.flMixedModeOnly);
    }

    if (FilterFlags.Uplevel.flNativeModeOnly)
    {
        Dbg(DEB_TRACE,
            "  FilterFlags.Uplevel.flNativeModeOnly (%#x)\n",
            FilterFlags.Uplevel.flNativeModeOnly);
        _DumpUplevelFilterFlags(FilterFlags.Uplevel.flNativeModeOnly);
    }

    if (FilterFlags.flDownlevel)
    {
        Dbg(DEB_TRACE,
            "  FilterFlags.flDownlevel (%#x)\n",
            FilterFlags.flDownlevel);
        _DumpDownlevelFilterFlags(FilterFlags.flDownlevel);
    }
}

void
DumpOptionFlags(
    ULONG flOptions)
{
    if (flOptions)
    {
        Dbg(DEB_TRACE, "  Options:\n");
        DUMP_IF_SET(flOptions, DSOP_FLAG_MULTISELECT);
        DUMP_IF_SET(flOptions, DSOP_FLAG_SKIP_TARGET_COMPUTER_DC_CHECK);
    }
}


void
VarArrayToStr(
    VARIANT *pvar,
    LPWSTR wzBuf,
    ULONG cchBuf)
{
    ULONG i;
    LPWSTR pwzNext = wzBuf;
    LPWSTR pwzEnd = wzBuf + cchBuf;

    for (i = 0; i < pvar->parray->rgsabound[0].cElements && pwzNext < pwzEnd + 6; i++)
    {
        wsprintf(pwzNext, L"x%02x ", ((LPBYTE)(pvar->parray->pvData))[i]);
        pwzNext += lstrlen(pwzNext);
    }
}




LPWSTR
VariantString(
    VARIANT *pvar)
{
    static WCHAR wzBuf[1024];

    wzBuf[0] = L'\0';

    switch (pvar->vt)
    {
    case VT_EMPTY:
        lstrcpy(wzBuf, L"VT_EMPTY");
        break;

    case VT_NULL:
        lstrcpy(wzBuf, L"VT_NULL");
        break;

    case VT_I2:
        wsprintf(wzBuf, L"%d", V_I2(pvar));
        break;

    case VT_I4:
        wsprintf(wzBuf, L"%d", V_I4(pvar));
        break;

    case VT_R4:
        wsprintf(wzBuf, L"%f", V_R4(pvar));
        break;

    case VT_R8:
        wsprintf(wzBuf, L"%f", V_R8(pvar));
        break;

    case VT_CY:
        wsprintf(wzBuf, L"$%f", V_CY(pvar));
        break;

    case VT_DATE:
        wsprintf(wzBuf, L"date %f", V_DATE(pvar));
        break;

    case VT_BSTR:
        if (V_BSTR(pvar))
        {
            wsprintf(wzBuf, L"'%ws'", V_BSTR(pvar));
        }
        else
        {
            lstrcpy(wzBuf, L"VT_BSTR NULL");
        }
        break;

    case VT_DISPATCH:
        wsprintf(wzBuf, L"VT_DISPATCH 0x%x", V_DISPATCH(pvar));
        break;

    case VT_UNKNOWN:
        wsprintf(wzBuf, L"VT_UNKNOWN 0x%x", V_UNKNOWN(pvar));
        break;

    case VT_ERROR:
    case VT_HRESULT:
        wsprintf(wzBuf, L"hr 0x%x", V_ERROR(pvar));
        break;

    case VT_BOOL:
        wsprintf(wzBuf, L"%s", V_BOOL(pvar) ? "TRUE" : "FALSE");
        break;

    case VT_VARIANT:
        wsprintf(wzBuf, L"variant 0x%x", V_VARIANTREF(pvar));
        break;

    case VT_DECIMAL:
        lstrcpy(wzBuf, L"VT_DECIMAL");
        break;

    case VT_I1:
        wsprintf(wzBuf, L"%d", V_I1(pvar));
        break;

    case VT_UI1:
        wsprintf(wzBuf, L"%u", V_UI1(pvar));
        break;

    case VT_UI2:
        wsprintf(wzBuf, L"%u", V_UI2(pvar));
        break;

    case VT_UI4:
        wsprintf(wzBuf, L"%u", V_UI4(pvar));
        break;

    case VT_I8:
        lstrcpy(wzBuf, L"VT_I8");
        break;

    case VT_UI8:
        lstrcpy(wzBuf, L"VT_UI8");
        break;

    case VT_INT:
        wsprintf(wzBuf, L"%d", V_INT(pvar));
        break;

    case VT_UINT:
        wsprintf(wzBuf, L"%u", V_UINT(pvar));
        break;

    case VT_VOID:
        lstrcpy(wzBuf, L"VT_VOID");
        break;

    case VT_UI1 | VT_ARRAY:
        VarArrayToStr(pvar, wzBuf, ARRAYLEN(wzBuf));
        break;

    case VT_PTR:
    case VT_SAFEARRAY:
    case VT_CARRAY:
    case VT_USERDEFINED:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_RECORD:
    case VT_FILETIME:
    case VT_BLOB:
    case VT_STREAM:
    case VT_STORAGE:
    case VT_STREAMED_OBJECT:
    case VT_STORED_OBJECT:
    case VT_BLOB_OBJECT:
    case VT_CF:
    case VT_CLSID:
    case VT_BSTR_BLOB:
    default:
        wsprintf(wzBuf, L"VT 0x%x", V_VT(pvar));
        break;
    }
    return wzBuf;
}

void
IIDtoString(
    REFIID riid,
    String *pstr)
{
    HRESULT     hr = S_OK;
    ULONG       lResult;
    LPOLESTR    pwzIID = NULL;
    HKEY        hkInterface = NULL;
    HKEY        hkIID = NULL;

    do
    {
        hr = StringFromIID(riid, &pwzIID);
        if (FAILED(hr)) break;

        lResult = RegOpenKey(HKEY_CLASSES_ROOT, L"Interface", &hkInterface);
        if (lResult != NO_ERROR) break;

        lResult = RegOpenKey(hkInterface, pwzIID, &hkIID);
        if (lResult != NO_ERROR) break;

        WCHAR wzInterfaceName[MAX_PATH] = L"";
        ULONG cbData = sizeof(wzInterfaceName);

        lResult = RegQueryValueEx(hkIID,
                                  NULL,
                                  NULL,
                                  NULL,
                                  (PBYTE)wzInterfaceName,
                                  &cbData);

        if (*wzInterfaceName)
        {
            *pstr = wzInterfaceName;
        }
        else
        {
            *pstr = pwzIID;
        }
    } while (0);

    if (hkIID)
    {
        RegCloseKey(hkIID);
    }

    if (hkInterface)
    {
        RegCloseKey(hkInterface);
    }

    CoTaskMemFree(pwzIID);
}

void
SayNoItf(
    PCSTR szComponent,
    REFIID riid)
{
    String strIID;

    IIDtoString(riid, &strIID);
    Dbg(DEB_ERROR, "%hs::QI no interface %ws\n", szComponent, strIID.c_str());
}


String
DbgGetFilterDescr(
    const CObjectPicker &rop,
    ULONG flCurFilterFlags)
{
    String strFilter;
    String strPlural;

    if (rop.GetInitInfoOptions() & DSOP_FLAG_MULTISELECT)
    {
        strPlural = L"s";
    }

    if (!(flCurFilterFlags & DSOP_DOWNLEVEL_FILTER_BIT))
    {
        if (flCurFilterFlags & DSOP_FILTER_USERS)
        {
            strFilter = L"User" + strPlural;
        }

        if (flCurFilterFlags & DSOP_FILTER_CONTACTS)
        {
            if (!strFilter.empty())
            {
                strFilter += L", ";
            }
            strFilter += L"Contact" + strPlural;
        }

        if (flCurFilterFlags & DSOP_FILTER_COMPUTERS)
        {
            if (!strFilter.empty())
            {
                strFilter += L", ";
            }
            strFilter += L"Computer" + strPlural;
        }

        if (flCurFilterFlags & ALL_UPLEVEL_GROUP_FILTERS)
        {
            if (!strFilter.empty())
            {
                strFilter += L", ";
            }
            strFilter += L"Group" + strPlural;
        }

        if (flCurFilterFlags & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS)
        {
            if (!strFilter.empty())
            {
                strFilter += L", ";
            }
            strFilter += L"Builtin Security Principal" + strPlural;
        }

        if (flCurFilterFlags & DSOP_FILTER_EXTERNAL_CUSTOMIZER)
        {
            if (!strFilter.empty())
            {
                strFilter += L", ";
            }
            strFilter += L"Other object" + strPlural;
        }
    }
    else
    {
        if (IsDownlevelFlagSet(flCurFilterFlags, DSOP_DOWNLEVEL_FILTER_USERS))
        {
            strFilter = L"User" + strPlural;
        }

        if (IsDownlevelFlagSet(flCurFilterFlags, DSOP_DOWNLEVEL_FILTER_COMPUTERS))
        {
            if (!strFilter.empty())
            {
                strFilter += L", ";
            }
            strFilter += L"Computer" + strPlural;
        }

        if (IsDownlevelFlagSet(flCurFilterFlags, ALL_DOWNLEVEL_GROUP_FILTERS))
        {
            if (!strFilter.empty())
            {
                strFilter += L", ";
            }
            strFilter += L"Group" + strPlural;
        }

        if (IsDownlevelFlagSet(flCurFilterFlags,
                               ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS))
        {
            if (!strFilter.empty())
            {
                strFilter += L", ";
            }
            strFilter += L"Builtin Security Principal" + strPlural;
        }

        if (IsDownlevelFlagSet(flCurFilterFlags,
                               DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER))
        {
            if (!strFilter.empty())
            {
                strFilter += L", ";
            }
            strFilter += L"Other object" + strPlural;
        }
    }
    return strFilter;
}


String
DbgTvTextFromHandle(
    HWND hwndTv,
    HTREEITEM hItem)
{
    TVITEM tvi;
    WCHAR wzTextBuf[80];

    tvi.mask = TVIF_TEXT;
    tvi.hItem = hItem;
    tvi.cchTextMax = ARRAYLEN(wzTextBuf);
    tvi.pszText = wzTextBuf;

    VERIFY(TreeView_GetItem(hwndTv, &tvi));
    return tvi.pszText;
}

#endif // (DBG == 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\dllmain.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       dllmain.cxx
//
//  Contents:   DLL entry point
//
//  History:    06-26-1997  MarkBl  Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

extern "C" BOOL
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved);

//+----------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Provide a DllMain for Win32
//
//  Arguments:  hInstance - HANDLE to this dll
//              dwReason  - Reason this function was called. Can be
//                          Process/Thread Attach/Detach.
//
//  Returns:    BOOL - TRUE if no error, FALSE otherwise
//
//-----------------------------------------------------------------------------
BOOL
DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
    {
#if (DBG == 1)
            CDbg::s_idxTls = TlsAlloc();
#endif // (DBG == 1)


            Dbg(DEB_ITRACE, "DllMain: DLL_PROCESS_ATTACH\n");

            //
            // Get instance handle
            //

            g_hinst = hInstance;

            //
            // Disable thread notification from OS
            //

            DisableThreadLibraryCalls(hInstance);

            //
            // Initialize common and extended common controls
            //

            SHFusionInitialize(0);
            InitCommonControls();

            INITCOMMONCONTROLSEX icce;
            icce.dwSize = sizeof icce;
            icce.dwICC =
                ICC_USEREX_CLASSES
                | ICC_TAB_CLASSES
                | ICC_ANIMATE_CLASS
                | ICC_LISTVIEW_CLASSES
                | ICC_BAR_CLASSES;
            InitCommonControlsEx(&icce);

            InitializeCriticalSection(&g_csGlobalVarsCreation);

            //
            // Init other globals
            //

            InitGlobals();

        break;
    }

    case DLL_PROCESS_DETACH:
    {
        Dbg(DEB_ITRACE, "DllMain: DLL_PROCESS_DETACH\n");

        FreeGlobals();
        DeleteCriticalSection(&g_csGlobalVarsCreation);

        DEBUG_VERIFY_INSTANCE_COUNT(CDsObjectPickerCF);
        DEBUG_VERIFY_INSTANCE_COUNT(CDataObject);
        DEBUG_VERIFY_INSTANCE_COUNT(CDsObject);
        DEBUG_VERIFY_INSTANCE_COUNT(CObjectPicker);
        DEBUG_VERIFY_INSTANCE_COUNT(CADsPathWrapper);
        DEBUG_VERIFY_INSTANCE_COUNT(CRootDSE);
        DEBUG_VERIFY_INSTANCE_COUNT(CRow);
        DEBUG_VERIFY_INSTANCE_COUNT(RefCountPointer);
        DEBUG_VERIFY_INSTANCE_COUNT(CServerInfo);

        SHFusionUninitialize();
        
#if (DBG == 1)
        TlsFree(CDbg::s_idxTls);
        CDbg::s_idxTls = 0xFFFFFFFF;
        extern CRITICAL_SECTION g_csMessageBuf;
        extern CRITICAL_SECTION g_csDebugPrint;
        DeleteCriticalSection(&g_csMessageBuf);
        DeleteCriticalSection(&g_csDebugPrint);

#endif // (DBG == 1)
        break;
    }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\dlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       dlg.cxx
//
//  Contents:   Implementation of modeless dialog base class
//
//  Classes:    CDlg
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop





//+--------------------------------------------------------------------------
//
//  Member:     CDlg::CDlg
//
//  Synopsis:   ctor
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDlg::CDlg():
    m_hwnd(NULL)
{
    TRACE_CONSTRUCTOR(CDlg);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::~CDlg
//
//  Synopsis:   dtor
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDlg::~CDlg()
{
    TRACE_DESTRUCTOR(CDlg);
    m_hwnd = NULL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_DoModalDlg
//
//  Synopsis:   Create the dialog and return its window handle
//
//  Arguments:  [hwndParent] - handle to owner window of dialog to create
//              [idd]        - resource id of dialog template
//
//  Returns:    Dialog's return code
//
//  History:    04-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

INT_PTR
CDlg::_DoModalDlg(
    HWND hwndParent,
    INT idd) const
{
    TRACE_METHOD(CDlg, _DoModalDlg);

    ASSERT(!hwndParent || IsWindow(hwndParent));
    INT_PTR iResult = DialogBoxParam(g_hinst,
                                     MAKEINTRESOURCE(idd),
                                     hwndParent,
                                     CDlg::_DlgProc,
                                     (LPARAM) this);

    if (iResult == -1)
    {
        DBG_OUT_LASTERROR;
    }

    return iResult;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_DoModelessDlg
//
//  Synopsis:   Create the dialog and return its window handle
//
//  Arguments:  [hwndParent] - handle to owner window of dialog to create
//              [idd]        - resource id of dialog template
//
//  Returns:    Dialog window handle, or NULL on failure
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HWND
CDlg::_DoModelessDlg(
    HWND hwndParent,
    INT idd)
{
    TRACE_METHOD(CDlg, _DoModelessDlg);

    HWND hwnd;

    hwnd = CreateDialogParam(g_hinst,
                             MAKEINTRESOURCE(idd),
                             hwndParent,
                             CDlg::_DlgProc,
                             (LPARAM) this);
    if (!hwnd)
    {
        DBG_OUT_LASTERROR;
    }
    return hwnd;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_DlgProc
//
//  Synopsis:   Dispatch selected messages to derived class
//
//  Arguments:  standard windows dialog
//
//  Returns:    standard windows dialog
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

INT_PTR CALLBACK
CDlg::_DlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fReturn = TRUE;
    CDlg *pThis = (CDlg *)GetWindowLongPtr(hwnd, DWLP_USER);

    if (!pThis && message != WM_INITDIALOG)
    {
        Dbg(DEB_WARN,
            "CDlg::_DlgProc received message %#x before WM_INITDIALOG\n",
            message);
        return FALSE;
    }

    switch (message)
    {
    case WM_INITDIALOG:
    {
        HRESULT hr = S_OK;

        //
        // pThis isn't valid because we haven't set DWLP_USER yet.  Make
        // it valid.
        //

        pThis = (CDlg*) lParam;
        ASSERT(pThis);

        Dbg(DEB_ITRACE, "CDlg::_DlgProc setting DWLP_USER to %#x\n", pThis);
        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR) pThis);
        pThis->m_hwnd = hwnd;
        BOOL fInitResult = TRUE;
        hr = pThis->_OnInit(&fInitResult);
        fReturn = fInitResult;

        //
        // If the initialization failed do not allow the dialog to start.
        //

        if (FAILED(hr))
        {
            DestroyWindow(hwnd);
        }
        break;
    }

    case WM_COMMAND:
        fReturn = pThis->_OnCommand(wParam, lParam);
        break;

    case WM_SIZE:
        fReturn = pThis->_OnSize(wParam, lParam);
        break;

    case WM_GETMINMAXINFO:
        fReturn = pThis->_OnMinMaxInfo((LPMINMAXINFO) lParam);
        break;

    case WM_NOTIFY:
        fReturn = pThis->_OnNotify(wParam, lParam);
        break;

    case WM_DRAWITEM:
        fReturn = pThis->_OnDrawItem(wParam, lParam);
        break;

    case WM_CTLCOLORSTATIC:
        fReturn = (BOOL)pThis->_OnStaticCtlColor((HDC) wParam, (HWND) lParam);
        break;

    case WM_SYSCOLORCHANGE:
        pThis->_OnSysColorChange();
        break;

    case OPM_PROMPT_FOR_CREDS:
        pThis->_OnCredentialPrompt(lParam);
        break;

    case OPM_NEW_QUERY_RESULTS:
        pThis->_OnNewBlock(wParam, lParam);
        break;

    case OPM_QUERY_COMPLETE:
        pThis->_OnQueryDone(wParam, lParam);
        break;

    case OPM_HIT_QUERY_LIMIT:
        pThis->_OnQueryLimit();
        break;

    case OPM_POPUP_CRED_ERROR:
        pThis->_OnPopupCredErr(lParam);
        break;

    case WM_DESTROY:
        //
        // It's possible to get a WM_DESTROY message without having gotten
        // a WM_INITDIALOG if loading a dll that the dialog needs (e.g.
        // comctl32.dll) fails, so guard pThis access here.
        //

        if (pThis)
        {
            pThis->_OnDestroy();
            pThis->m_hwnd = NULL;
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        pThis->_OnHelp(message, wParam, lParam);
        break;

	case THREAD_SUCCEEDED:
		pThis->OnProgressMessage(message, wParam, lParam);


    default:
        fReturn = FALSE;
        break;
    }
    return fReturn;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_GetChildWindowRect
//
//  Synopsis:   Init *[prc] with the window rect, in client coordinates, of
//              child window [hwndChild].
//
//  Arguments:  [hwndChild] - child window for which to retrieve rect
//              [prc]       - pointer to rect struct to receive info
//
//  Modifies:   *[prc]
//
//  History:    07-21-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDlg::_GetChildWindowRect(
    HWND hwndChild,
    RECT *prc) const
{
    ASSERT(hwndChild && IsWindow(hwndChild));

    VERIFY(GetWindowRect(hwndChild, prc));
    VERIFY(MapWindowPoints(NULL, m_hwnd, (LPPOINT) prc, 2));
}



//+--------------------------------------------------------------------------
//
//  Member:     CDlg::PerformCredentialPrompt
//
//  Synopsis:   Pop up a credential dialog.
//
//  Arguments:  [pcmi] -
//
//  Modifies:   *[pcmi->pwzUserName], *[pcmi->pwzPassword]
//
//  History:    05-04-1998   DavidMun   Created
//
//  Notes:      Called by browse dialog in response to a
//              OPM_PROMPT_FOR_CREDS message.
//
//---------------------------------------------------------------------------

void
CDlg::_OnCredentialPrompt(
    LPARAM lParam) const
{
    TRACE_METHOD(CDlg, PerformCredentialPrompt);

    CRED_MSG_INFO *pcmi = reinterpret_cast<CRED_MSG_INFO *>(lParam);

    CPasswordDialog PasswordDlg(pcmi->flProvider,
                                pcmi->pwzServer,
                                pcmi->pwzUserName,
                                pcmi->pwzPassword);

    pcmi->hr = PasswordDlg.DoModalDialog(m_hwnd);

    //
    // If this credential prompt is being performed on behalf of the
    // worker thread, release it to process the result.
    //

    if (pcmi->hPrompt)
    {
        SetEvent(pcmi->hPrompt);
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_OnPopupCredErr
//
//  Synopsis:   Invoke a messagebox to display an error and set an event
//              when it closes.
//
//  Arguments:  [lParam] - POPUP_MSG_INFO pointer
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      Used when worker thread needs to display an error.
//
//---------------------------------------------------------------------------

void
CDlg::_OnPopupCredErr(
    LPARAM lParam) const
{
    TRACE_METHOD(CDlg, _OnPopupMessage);

    POPUP_MSG_INFO *pmi = reinterpret_cast<POPUP_MSG_INFO *>(lParam);

    PopupMessage(pmi->hwnd, pmi->ids, pmi->wzUser, pmi->wzError);

    ASSERT(pmi->hPrompt);
    if (pmi->hPrompt)
    {
        SetEvent(pmi->hPrompt);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_ReadEditCtrl
//
//  Synopsis:   Put the contents of the edit control with resource id [id]
//              into the string pointed to by [pstr].
//
//  Arguments:  [id]   - resource id of edit control
//              [pstr] - points to string to fill with edit control's
//                        contents
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDlg::_ReadEditCtrl(
    ULONG id,
    String *pstr) const
{
    pstr->erase();
    SetLastError(0);
    int cch = Edit_GetTextLength(_hCtrl(id));

    if (cch > 0)
    {
        PWSTR pwz = new WCHAR [cch + 1];
        int iRet = Edit_GetText(_hCtrl(id), pwz, cch + 1);
        if (iRet)
        {
            *pstr = pwz;
        }
        else
        {
            DBG_OUT_LASTERROR;
        }
        delete [] pwz;
    }
    else
    {
#if (DBG == 1)
        if (GetLastError())
        {
            DBG_OUT_LASTERROR;
        }
#endif // (DBG == 1)
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\dndlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       DnDlg.cxx
//
//  Contents:   Implementation of class to drive dialog used to enter names
//              which are queried as DNs.
//
//  Classes:    CDnDlg
//
//  History:    05-31-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


void
CDnDlg::Save(
    PVOID *ppv) const
{
    TRACE_METHOD(CDnDlg, Save);

    *ppv = new WCHAR [m_strValue.length() + 1];
    lstrcpy(static_cast<PWSTR>(*ppv), m_strValue.c_str());
}




void
CDnDlg::Load(
    PVOID pv)
{
    TRACE_METHOD(CDnDlg, Load);

    m_strValue = static_cast<PWSTR>(pv);
}




void
CDnDlg::Free(
    VOID *pv) const
{
    TRACE_METHOD(CDnDlg, Free);

    if (pv)
    {
        delete [] static_cast<PWSTR>(pv);
    }
}




BOOL
CDnDlg::QueryClose(
    ATTR_KEY ak) const
{
    TRACE_METHOD(CDnDlg, QueryClose);

    BOOL fAllowClose = FALSE;

    do
    {
        if (!m_rop.ProcessNames(_hCtrl(IDC_VALUE_EDIT), this, TRUE))
        {
            break;
        }

        ASSERT(m_rpRichEditOle->GetObjectCount() == 1);

        REOBJECT reobj;
        HRESULT hr;

        ZeroMemory(&reobj, sizeof reobj);
        reobj.cbStruct = sizeof(reobj);

        hr = m_rpRichEditOle->GetObject(0, &reobj, REO_GETOBJ_POLEOBJ);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(reobj.poleobj);

        CDsObject *pdso = (CDsObject *)(CEmbeddedDsObject*)reobj.poleobj;

        m_strValue = pdso->GetName();

        Bstr bstrDn;

        hr = g_pADsPath->SetRetrieve(ADS_SETTYPE_FULL,
                                     pdso->GetADsPath(),
                                     ADS_FORMAT_X500_DN,
                                     &bstrDn);
        reobj.poleobj->Release();
        reobj.poleobj = NULL;
        pdso = NULL;
        BREAK_ON_FAIL_HRESULT(hr);

        const CAttributeManager &ram = m_rop.GetAttributeManager();
        const String &strLdapName = ram.GetAttrAdsiName(ak);

        m_strFilter = L"(" +
                            strLdapName + L"=" + bstrDn.c_str() +
                      L")";
        fAllowClose = TRUE;

    } while (0);

    return fAllowClose;
}




HRESULT
CDnDlg::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CDnDlg, _OnInit);

    HRESULT hr = S_OK;
    HWND    hwndValueEdit = _hCtrl(IDC_VALUE_EDIT);

    do
    {
        HWND hwndRichEdit = _hCtrl(IDC_RICHEDIT);
        if (!hwndRichEdit)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        m_hpenUnderline = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_WINDOWTEXT));
        Edit_SetText(hwndRichEdit, m_strValue.c_str());

        ASSERT(!m_rpRichEditOle.get());
        LRESULT lResult = SendMessage(hwndValueEdit,
                                     EM_GETOLEINTERFACE,
                                     0,
                                     (LPARAM) &m_rpRichEditOle);

        if (!lResult)
        {
            DBG_OUT_LASTERROR;
            hr = HRESULT_FROM_LASTERROR;
            break;
        }

        ASSERT(m_rpRichEditOle.get());

        CRichEditOleCallback *pRichEditOleCallback =
            new CRichEditOleCallback(hwndRichEdit);

        SendMessage(hwndValueEdit,
                    EM_SETOLECALLBACK,
                    0,
                    (LPARAM) pRichEditOleCallback);

        pRichEditOleCallback->Release();

        SendMessage(hwndValueEdit,
                    EM_SETEVENTMASK,
                    0,
                    (LPARAM) ENM_CHANGE);

        //
        // Subclass the rich edit control for keystroke notification and
        // Enter key forwarding.
        //

        SetWindowLongPtr(hwndRichEdit, GWLP_USERDATA, (LONG_PTR) this);
        m_OriginalRichEditWndProc = (WNDPROC) SetWindowLongPtr(hwndRichEdit,
                                                               GWLP_WNDPROC, 
                                                               (LONG_PTR)_EditWndProc);
    } while (0);

    return hr;
}




void
CDnDlg::_OnSysColorChange()
{
    TRACE_METHOD(CDnDlg, _OnSysColorChange);

    if (m_hpenUnderline)
    {
        VERIFY(DeleteObject(m_hpenUnderline));
    }
    m_hpenUnderline = CreatePen(PS_SOLID, 0, GetSysColor(COLOR_WINDOWTEXT));
}




void
CDnDlg::_OnDestroy()
{
    TRACE_METHOD(CDnDlg, _OnDestroy);

    if (m_hpenUnderline)
    {
        VERIFY(DeleteObject(m_hpenUnderline));
    }
}




BOOL
CDnDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fNotHandled = FALSE;

    switch (LOWORD(wParam))
    {
    case IDC_VALUE_EDIT:
        if (HIWORD(wParam) == EN_UPDATE &&
            IsWindowEnabled(reinterpret_cast<HWND>(lParam)))
        {
            _ReadEditCtrl(IDC_VALUE_EDIT, &m_strValue);
            m_strValue.strip(String::BOTH);

            EnableWindow(GetDlgItem(GetParent(m_hwnd), IDOK),
                         !m_strValue.empty());
        }
        break;

    default:
        fNotHandled = TRUE;
        break;
    }
    return fNotHandled;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDnDlg::_EditWndProc
//
//  Synopsis:   Subclassing window proc for rich edit control.
//
//  Arguments:  Standard Windows.
//
//  Returns:    Standard Windows.
//
//  History:    4-20-1999   DavidMun   Created
//
//  Notes:      If the user hits the Enter key and the OK button is enabled,
//              posts a press of that button to the main window.
//
//              Forwards everything except VK_RETURN keys to rich edit
//              window proc.
//
//---------------------------------------------------------------------------

LRESULT CALLBACK
CDnDlg::_EditWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    LRESULT         lResult = 0;
    BOOL            fCallWinProc = TRUE;
    CDnDlg         *pThis =
        reinterpret_cast<CDnDlg *>(GetWindowLongPtr(hwnd, GWLP_USERDATA));

    switch (msg)
    {
    case WM_KEYDOWN:
        if (wParam == VK_RETURN)
        {
            fCallWinProc = FALSE;
        }
        break;

    case WM_CHAR:
        if (wParam == VK_RETURN)
        {
            HWND hwndFrame = GetParent(hwnd);
            HWND hwndOK = GetDlgItem(hwndFrame, IDOK);

            if (IsWindowEnabled(hwndOK))
            {
                Dbg(DEB_TRACE, "CDsSelectDlg::_EditWndProc: Forwarding Return key\n");
                PostMessage(hwndFrame,
                            WM_COMMAND,
                            MAKEWPARAM(IDOK, BN_CLICKED),
                            (LPARAM) hwndOK);
            }
        }
        break;
    }

    if (fCallWinProc)
    {
        lResult = CallWindowProc(pThis->m_OriginalRichEditWndProc,
                                 hwnd,
                                 msg,
                                 wParam,
                                 lParam);

        //
        // Prevent dialog manager from telling the edit control to select
        // all of its contents when the focus has moved into it.  This is
        // necessary because otherwise tabbing into and out of the rich edit
        // makes it too easy to accidentally replace its contents with the
        // next addition.
        //

        if (msg == WM_GETDLGCODE)
        {
            lResult &= ~DLGC_HASSETSEL;
        }
    }
    return lResult;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDnDlg::GetDescription
//
//  Synopsis:   Return a human-readable string describing this clause
//
//  Arguments:  [rAttribute] - currently selected attribute
//
//  Returns:    Localized string describing this clause.
//
//  History:    05-31-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

String
CDnDlg::GetDescription(
    ATTR_KEY ak) const
{
    TRACE_METHOD(CDnDlg, GetDescription);

    const CAttributeManager &ram = m_rop.GetAttributeManager();
    const String &strDisplayName = ram.GetAttrDisplayName(ak);
    String strTemp = String::load(IDS_STR_FILTER_EXACT_DESCRIPTION_FMT);
    return String::format(strTemp.c_str(),
                          strDisplayName.c_str(),
                          m_strValue.c_str());

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\downlvl.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       downlvl.cxx
//
//  Contents:   Functions which return information about domains when
//              uplevel (Windows 2000 or later) APIs are not available
//              (i.e. when joined to an NT4 domain or in a workgroup).
//
//  Functions:  GetLsaAccountDomainInfo
//              GetDomainSid
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------


#include "headers.hxx"
#pragma hdrstop


//+--------------------------------------------------------------------------
//
//  Function:   GetLsaAccountDomainInfo
//
//  Synopsis:   Use LSA APIs to fill *[ppAccountDomainInfo].
//
//  Arguments:  [pwzServerName]       - target computer
//              [phlsaServer]         - filled with handle returned by
//                                       LsaOpenPolicy
//              [ppAccountDomainInfo] - filled with domain info returned
//                                       by LsaQueryInformationPolicy.
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
GetLsaAccountDomainInfo(
    PCWSTR pwzServerName,
    PLSA_HANDLE  phlsaServer,
    PPOLICY_ACCOUNT_DOMAIN_INFO *ppAccountDomainInfo)

{
    TRACE_FUNCTION(GetLsaAccountDomainInfo);

    HRESULT                     hr = S_OK;
    NTSTATUS                    nts = ERROR_SUCCESS;
    LSA_OBJECT_ATTRIBUTES       oa;
    SECURITY_QUALITY_OF_SERVICE sqos;
    BOOL                        fOk;

    do
    {
        //
        // Open the lsa policy object on the target server
        //

        ZeroMemory(&sqos, sizeof sqos);
        sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        sqos.ImpersonationLevel = SecurityImpersonation;
        sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        sqos.EffectiveOnly = FALSE;

        ZeroMemory(&oa, sizeof oa);
        oa.Length = sizeof oa;
        oa.SecurityQualityOfService = &sqos;

        UNICODE_STRING uszServerName;

        if (pwzServerName)
        {
            fOk = RtlCreateUnicodeString(&uszServerName, pwzServerName);

            if (!fOk)
            {
                hr = E_OUTOFMEMORY;
                DBG_OUT_HRESULT(hr);
                break;
            }
        }

        nts = LsaOpenPolicy(pwzServerName ? &uszServerName : NULL,
                            &oa,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            phlsaServer);

        if (pwzServerName)
        {
            RtlFreeUnicodeString(&uszServerName);
        }
        BREAK_ON_FAIL_NTSTATUS(nts);

        //
        // Get the domain information for the passed-in server
        //

        nts = LsaQueryInformationPolicy(*phlsaServer,
                                        PolicyAccountDomainInformation,
                                        (LPVOID *)ppAccountDomainInfo);
        BREAK_ON_FAIL_NTSTATUS(nts);
    } while (0);

    if (NT_ERROR(nts))
    {
        hr = E_FAIL;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   GetDomainSid
//
//  Synopsis:   Get the SID of domain with name [pwzDomainName].
//
//  Arguments:  [pwzDomainName] - name of domain for which to retrieve SID
//              [ppSid]         - filled with pointer to domain's SID
//              [ppwzDC]        - if non-NULL, filled with name of DC for
//                                 domain [pwzDomainName].
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
GetDomainSid(
    PWSTR pwzDomainName,
    PSID *ppSid,
    PWSTR *ppwzDC)
{
    Dbg(DEB_TRACE, "GetDomainSid('%ws')\n", pwzDomainName);

    HRESULT hr;
    ULONG ulResult;
    PWSTR pwzPDC = NULL;
    NTSTATUS nts;
    LSA_HANDLE                  hlsaServer = NULL;
    POLICY_ACCOUNT_DOMAIN_INFO *pAccountDomainInfo = NULL;
    SECURITY_QUALITY_OF_SERVICE sqos;
    LSA_OBJECT_ATTRIBUTES       oa;
    BOOL                        fOk;

    do
    {
        //
        // First find a DC in the domain
        //

        ulResult = NetGetDCName(NULL, pwzDomainName, (LPBYTE *) &pwzPDC);

        if (ulResult != ERROR_SUCCESS)
        {
            hr = E_FAIL;
            Dbg(DEB_ERROR, "GetDomainSid: NetGetDCName err=%uL\n", ulResult);
            break;
        }

        Dbg(DEB_TRACE,
            "GetDomainSid: DC of domain '%ws' is '%ws'\n",
            pwzDomainName,
            pwzPDC);

        PWSTR pwzDCname = pwzPDC + 2;

        if (ppwzDC)
        {
            *ppwzDC = new WCHAR[lstrlen(pwzDCname) + 1];

            if (!*ppwzDC)
            {
                hr = E_OUTOFMEMORY;
                DBG_OUT_HRESULT(hr);
                break;
            }

            lstrcpy(*ppwzDC, pwzDCname);
        }

        hr = GetLsaAccountDomainInfo(pwzDCname,
                                     &hlsaServer,
                                     &pAccountDomainInfo);

        //
        // Open the lsa policy object on the DC
        //

        ZeroMemory(&sqos, sizeof sqos);
        sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        sqos.ImpersonationLevel = SecurityImpersonation;
        sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        sqos.EffectiveOnly = FALSE;

        ZeroMemory(&oa, sizeof oa);
        oa.Length = sizeof oa;
        oa.SecurityQualityOfService = &sqos;

        //
        // Get a handle to lsa policy for queries about domains
        //

        UNICODE_STRING uszServerName;

        fOk = RtlCreateUnicodeString(&uszServerName, pwzDCname);

        if (!fOk)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        nts = LsaOpenPolicy(&uszServerName,
                            &oa,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &hlsaServer);
        RtlFreeUnicodeString(&uszServerName);
        BREAK_ON_FAIL_NTSTATUS(nts);

        //
        // Get the SID for the domain
        //

        nts = LsaQueryInformationPolicy(hlsaServer,
                                        PolicyAccountDomainInformation,
                                        (LPVOID *)&pAccountDomainInfo);
        BREAK_ON_FAIL_NTSTATUS(nts);

        if (pAccountDomainInfo->DomainSid)
        {
            ULONG cbSid = GetLengthSid(pAccountDomainInfo->DomainSid);
            ASSERT(cbSid);

            *ppSid = (PSID) new BYTE[cbSid];

            if (!*ppSid)
            {
                hr = E_OUTOFMEMORY;
                DBG_OUT_HRESULT(hr);
                break;
            }

            CopyMemory(*ppSid, pAccountDomainInfo->DomainSid, cbSid);
        }
        else
        {
            hr = E_FAIL;
            Dbg(DEB_ERROR,
                "GetDomainSid: couldn't obtain sid for domain '%ws'\n",
                pwzDomainName);
        }
    } while (0);

    //
    // Release resources
    //

    if (hlsaServer)
    {
        LsaClose(hlsaServer);
    }

    if (pwzPDC)
    {
        NetApiBufferFree(pwzPDC);
    }

    if (pAccountDomainInfo)
    {
        LsaFreeMemory(pAccountDomainInfo);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\dsobject.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       dsobject.cxx
//
//  Contents:   Class that represents a single object in the DS.
//
//  Classes:    CDsObject
//
//  History:    08-07-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop




HRESULT
CrackName(IN HWND hwnd, 
          IN LPWSTR pwzNameIn,           
          IN DS_NAME_FORMAT FormatOffered,
          IN LPWSTR pwzDomainName,
          IN BOOL bCrackInExtForest,
          OUT LPWSTR * ppwzResultName, 
          OUT PBOOL pbExtForest,
		  OUT PBOOL pbAddDollar);

void AddDollarToNameToCrack(IN DS_NAME_FORMAT FormatOffered,
								  String &strNameToCrack);

DEBUG_DECLARE_INSTANCE_COUNTER(CDsObject)

#define MAX_SEARCH_HITS                     1000
#define MAX_SEARCH_HITS_STR                 L"1000"
#define NAME_QUERY_PAGE_TIME_LIMIT          45 // seconds

const Variant CDsObject::s_varEmpty;

//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::CDsObject
//
//  Synopsis:   ctor
//
//  Arguments:  [idOwningScope] - id of scope which contains (owns) this
//              [pwzName]       - name typed by user
//
//  History:    08-13-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CDsObject::CDsObject(
    ULONG idOwningScope,
    PCWSTR pwzName)
{
    Dbg(DEB_DSOBJECT,
        "CDsObject::CDsObject(%x) user entry=%ws\n",
        this,
        pwzName);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDsObject);
    ASSERT(idOwningScope);
    ASSERT(pwzName);

    _SetFlag(DSO_FLAG_UNPROCESSED_USER_ENTRY);
    _SetOwningScopeId(idOwningScope);
    m_AttrValueMap[AK_USER_ENTERED_TEXT] = Variant(pwzName);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::CDsObject
//
//  Synopsis:   ctor
//
//  Arguments:  [idOwningScope] - id of scope which contains (owns) this
//              [strName]       - object RDN
//              [strClass]      - objectClass attribute value
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CDsObject::CDsObject(
    ULONG idOwningScope,
    const String &strName,
    const String &strClass)
{
    Dbg(DEB_DSOBJECT,
        "CDsObject::CDsObject(%x) Name=%ws, Class=%ws\n",
        this,
        strName.c_str(),
        strClass.c_str());
    DBG_INDENTER;
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDsObject);
    ASSERT(idOwningScope);

    m_AttrValueMap[AK_NAME] = Variant(strName.c_str());
    m_AttrValueMap[AK_OBJECT_CLASS] = Variant(strClass.c_str());
    _SetOwningScopeId(idOwningScope);
}





//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::CDsObject
//
//  Synopsis:   ctor
//
//  Arguments:  [Init] - contains various attribute values for this object
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CDsObject::CDsObject(
    const SDsObjectInit &Init)
{
    Dbg(DEB_DSOBJECT,
        "CDsObject::CDsObject(%x) Name=%ws, Localized Name=%ws, Class=%ws\n",
        this,
        Init.pwzName,
        Init.pwzLocalizedName,
        Init.pwzClass);
    ASSERT(Init.idOwningScope);
    DBG_INDENTER;
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDsObject);

    _SetOwningScopeId(Init.idOwningScope);

    if (Init.pwzName && *Init.pwzName)
    {
        m_AttrValueMap[AK_NAME] = Variant(Init.pwzName);
    }

    if (Init.pwzLocalizedName && *Init.pwzLocalizedName)
    {
        m_AttrValueMap[AK_LOCALIZED_NAME] = Variant(Init.pwzLocalizedName);
    }

    if (Init.pwzClass && *Init.pwzClass)
    {
        m_AttrValueMap[AK_OBJECT_CLASS] = Variant(Init.pwzClass);
    }

    if (Init.pwzADsPath && *Init.pwzADsPath)
    {
        m_AttrValueMap[AK_ADSPATH] = Variant(Init.pwzADsPath);
    }

    if (Init.pwzUpn && *Init.pwzUpn)
    {
        m_AttrValueMap[AK_USER_PRINCIPAL_NAME] = Variant(Init.pwzUpn);
    }

    if (Init.fDisabled)
    {
        _SetFlag(DSO_FLAG_DISABLED);
    }
}

#define ADD_IF_SUCCEEDED(hr, idx)                           \
    if (SUCCEEDED(hr))                                      \
    {                                                       \
        ASSERT(!bstr.Empty());                              \
        m_AttrValueMap[idx] = Variant(bstr.c_str());    \
        bstr.Clear();                                       \
    }


//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::CDsObject
//
//  Synopsis:   ctor
//
//  Arguments:  [idOwningScope] - id of scope which contains (owns) this
//              [pADs]          - pointer to interface on object
//                                 represented by this
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      Initializes this by querying [pADs] for attribute values.
//              Generally used to represent objects returned from downlevel
//              scopes.
//
//---------------------------------------------------------------------------

CDsObject::CDsObject(
    ULONG idOwningScope,
    IADs *pADs)
{
    Dbg(DEB_DSOBJECT,
        "CDsObject::CDsObject(%x) pADs=%#x\n",
        this,
        pADs);
    DBG_INDENTER;
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDsObject);
    ASSERT(idOwningScope);

    HRESULT hr;
    Bstr bstr;

    hr = pADs->get_Name(&bstr);
    ADD_IF_SUCCEEDED(hr, AK_NAME);

    if (SUCCEEDED(hr))
    {
        Dbg(DEB_TRACE, "name = %ws\n", GetName());
    }

    hr = pADs->get_Class(&bstr);
    ADD_IF_SUCCEEDED(hr, AK_OBJECT_CLASS);

    hr = pADs->get_ADsPath(&bstr);
    ADD_IF_SUCCEEDED(hr, AK_ADSPATH);

    if (IsDisabled(pADs))
    {
        _SetFlag(DSO_FLAG_DISABLED);
    }

    _SetOwningScopeId(idOwningScope);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::CDsObject
//
//  Synopsis:   copy ctor
//
//  Arguments:  [dso] - object to copy
//
//  History:    03-06-2000   davidmun   Created
//
//---------------------------------------------------------------------------

CDsObject::CDsObject(
    const CDsObject &dso)
{
    Dbg(DEB_DSOBJECT,
        "CDsObject::CDsObject(%x) copying %#x name=%ws\n",
        this,
        &dso,
        dso.GetName());
    DBG_INDENTER;
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDsObject);
    this->operator=(dso);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::CDsObject
//
//  Synopsis:   ctor
//
//  Arguments:  [idOwningScope] - id of scope which contains (owns) this
//              [atvm]          - attributes to copy
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      [idOwningScope] value overrides any previous value in [atvm]
//
//---------------------------------------------------------------------------

CDsObject::CDsObject(
    ULONG idOwningScope,
    const AttrValueMap &atvm):
        m_AttrValueMap(atvm)
{
    Dbg(DEB_DSOBJECT,
        "CDsObject::CDsObject(%x) copying AttrValueMap, name=%ws\n",
        this,
        GetName());
    DBG_INDENTER;
    DEBUG_INCREMENT_INSTANCE_COUNTER(CDsObject);

    _SetOwningScopeId(idOwningScope);

    if (GetAttr(AK_USER_ACCT_CTRL).GetUI4() & UF_ACCOUNTDISABLE)
    {
        _SetFlag(DSO_FLAG_DISABLED);
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_SetOwningScopeId
//
//  Synopsis:   Store the id of the scope which contains (owns) this
//
//  Arguments:  [idOwningScope] - id of scope which contains (owns) this
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDsObject::_SetOwningScopeId(
    ULONG idOwningScope)
{
    ASSERT(idOwningScope);
    Variant &var = m_AttrValueMap[AK_FLAGS];

    if (var.Empty())
    {
        V_VT(&var) = VT_UI8;
        V_UI8(&var) = static_cast<ULONGLONG>(idOwningScope) << 32;
    }
    else
    {
        ASSERT(V_VT(&var) == VT_UI8);
        ULONGLONG ullNewFlagsVal = (V_UI8(&var) & ULONG_MAX);
        ullNewFlagsVal |= static_cast<ULONGLONG>(idOwningScope) << 32;
        V_UI8(&var) = ullNewFlagsVal;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::GetDisplayName
//
//  Synopsis:   Fill *[pstrDisplayName] with the string to display in the
//              listview's "Name" column.  May differ from object's RDN.
//
//  Arguments:  [pstrDisplayName]   - filled with name to display
//              [fForSelectionWell] - nonzero if name is being displayed in
//                                      the selection dialog (as opposed to
//                                      the browse dialog).
//
//  History:    11-24-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDsObject::GetDisplayName(
    String *pstrDisplayName,
    BOOL fForSelectionWell) const
{
    BSTR bstrNameForDisplay = GetLocalizedName();

    // If localized name available, use it in preference to RDN

    if (!*bstrNameForDisplay)
    {
        bstrNameForDisplay = GetName();
    }

    // use UPN if available

    if (*GetUpn())
    {
        *pstrDisplayName = String::format(g_wzColumn1Format,
                                          bstrNameForDisplay,
                                          GetUpn());
        return;
    }

    if (!fForSelectionWell)
    {
        *pstrDisplayName = bstrNameForDisplay;
        return;
    }

    do
    {
        //
        // for the selection well, and there's no upn.  if this
        // represents a downlevel object, display name is NT4 format,
        // i.e., DOMAIN\NAME, unless it's a downlevel object with
        // a path derived from its SID, e.g. we want ANONYMOUS to be
        // displayed as ANONYMOUS instead of NT AUTHORITY\ANONYMOUS.
        //

        if (_IsFlagSet(DSO_FLAG_HAS_DOWNLEVEL_SID_PATH))
        {
            break;
        }

        ULONG ulProvider = PROVIDER_UNKNOWN;

        if (!*GetADsPath())
        {
            break;
        }

        (void) ProviderFlagFromPath(GetADsPath(), &ulProvider);

        if (ulProvider != PROVIDER_WINNT)
        {
            break;
        }

        String strDisplayPath(GetADsPath());

        size_t idxSlash = strDisplayPath.rfind(L'/');

        if (!idxSlash || idxSlash == String::npos)
        {
            break;
        }

        *pstrDisplayName = strDisplayPath;

        pstrDisplayName->erase(idxSlash, 1);
        pstrDisplayName->insert(idxSlash, L"\\");

        idxSlash = pstrDisplayName->rfind(L'/', idxSlash - 1);

        if (idxSlash != String::npos)
        {
            pstrDisplayName->erase(0, idxSlash + 1);
        }
    } while (0);

    if (pstrDisplayName->empty())
    {
        *pstrDisplayName = bstrNameForDisplay;
    }
}





//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::operator ==
//
//  Synopsis:   Compare this against [dsoRhs], returning TRUE if the name,
//              class, provider, and DN of both match.
//
//  Arguments:  [sliRhs] - object to compare against this
//
//  History:    08-08-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CDsObject::operator ==(
    const CDsObject &dsoRhs) const
{
    BOOL fEqual = FALSE;
    Bstr bstrMyDN;
    Bstr bstrRhsDn;

    do
    {
        if (lstrcmpi(GetName(), dsoRhs.GetName()))
        {
            break;
        }

        //
        // If exactly one of lhs or rhs is an unprocessed entry, treat
        // them as different since the unprocessed entry may resolve to
        // anything.
        //

        if (IsUnprocessedUserEntry() && !dsoRhs.IsUnprocessedUserEntry() ||
            !IsUnprocessedUserEntry() && dsoRhs.IsUnprocessedUserEntry())
        {
            break;
        }

        //
        // If both are unprocessed entries, compare their text
        //

        if (IsUnprocessedUserEntry() && dsoRhs.IsUnprocessedUserEntry())
        {
            fEqual = !lstrcmpi(GetAttr(AK_USER_ENTERED_TEXT).GetBstr(),
                               dsoRhs.GetAttr(AK_USER_ENTERED_TEXT).GetBstr());
            break;
        }

        if (lstrcmpi(GetClass(), dsoRhs.GetClass()))
        {
            break;
        }

        //
        // Objects have same relative name and class.
        //

        //
        // If neither has a path, they're the same.  If one has a path
        // and one does not, they're different.
        //

        if (!*GetADsPath())
        {
            if (!*dsoRhs.GetADsPath())
            {
                fEqual = TRUE;
            }
            break;
        }
        else if (!*dsoRhs.GetADsPath())
        {
            break;
        }

        //
        // If both use the WinNT provider, compare paths directly.
        // If exactly one uses the WinNT provider, consider them
        // different.
        //

        BSTR bstrADsPath = GetADsPath();
        BSTR bstrRhsADsPath = dsoRhs.GetADsPath();
        BOOL fWinNT = wcsstr(bstrADsPath, c_wzWinNTPrefix) != NULL;
        BOOL fRhsWinNT = wcsstr(bstrRhsADsPath, c_wzWinNTPrefix) != NULL;

        if (fWinNT && fRhsWinNT)
        {
            fEqual = !lstrcmpi(bstrADsPath, bstrRhsADsPath);
            break;
        }
        else if (fWinNT || fRhsWinNT)
        {
            break;
        }

        //
        // Neither uses the WinNT provider, and the RDNs are the same.
        // compare the distinguished names.  A string compare
        // of the paths is insufficient, since they may use different
        // providers or servers but actually have the same DN.
        //

        HRESULT hr;

        hr = g_pADsPath->SetRetrieve(ADS_SETTYPE_FULL,
                                     bstrADsPath,
                                     ADS_FORMAT_X500_DN,
                                     &bstrMyDN);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = g_pADsPath->SetRetrieve(ADS_SETTYPE_FULL,
                                     bstrRhsADsPath,
                                     ADS_FORMAT_X500_DN,
                                     &bstrRhsDn);
        BREAK_ON_FAIL_HRESULT(hr);

        if (lstrcmpi(bstrMyDN.c_str(), bstrRhsDn.c_str()))
        {
            break;
        }

        fEqual = TRUE;
    } while (0);

    return fEqual;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::Process
//
//  Synopsis:   Perform whatever work is required on this to make it ready
//              to return in a data object.
//
//  Arguments:  [hwnd]         - parent for error or multimatch
//                                dialogs
//              [rop]          - containing object picker instance
//              [pdsolExtras]  - llist to which to add items
//                                generated by processing user
//                                entries, NULL if single select
//              [fMultiselect] - may differ from what [rop] reports if
//                                this object resides in a single-select
//                                richedit not in the base dialog (i.e.,
//                                in CDnDlg).
//
//  Returns:    NAME_PROCESS_RESULT
//
//  Modifies:   *[pdsolExtras]
//
//  History:    08-10-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

NAME_PROCESS_RESULT
CDsObject::Process(
    HWND           hwnd,
    const CObjectPicker &rop,
    CDsObjectList *pdsolExtras)
{
    TRACE_METHOD(CDsObject, Process);
    NAME_PROCESS_RESULT npr = NPR_SUCCESS;
    BOOL fDisplayedError = FALSE;
    HRESULT hr = S_OK;

    do
    {
        //
        // If this has a string the user typed in, convert it to an
        // object.
        //

        if (IsUnprocessedUserEntry())
        {
            ASSERT(!_IsFlagSet(DSO_FLAG_FETCHED_ATTRIBUTES));
            ASSERT(!_IsFlagSet(DSO_FLAG_CONVERTED_PROVIDER));

            _ProcessUserEntry(hwnd, rop, pdsolExtras, &npr);

            if (NAME_PROCESSING_FAILED(npr))
            {
                fDisplayedError = TRUE;
                break;
            }
        }

        //
        // If attribute fetch is required, do it
        //

        (void) _FetchAttributes(hwnd, rop);

        //
        // If provider conversion is required, do it
        //

        hr = _ConvertProvider(hwnd, rop, &npr);
        BREAK_ON_FAIL_PROCESS_RESULT(npr);

    } while (0);

    if (npr == NPR_STOP_PROCESSING && !fDisplayedError)
    {
        String strError = GetErrorMessage(hr);

        PopupMessage(hwnd,
                     IDS_CANNOT_PROCESS,
                     GetName(),
                     strError.c_str());
    }

    if (!NAME_PROCESSING_FAILED(npr))
    {
        _ClearFlag(DSO_FLAG_UNPROCESSED_USER_ENTRY);
    }
    return npr;
}

/*

Flags used when processing user entered text:

DSO_FLAG_MULTISELECT
    indicates that the multiple match dialog should allow multiselect.

DSO_FLAG_IS_COMPUTER
    The value for the AK_USER_ENTERED_TEXT attribute should be considered the
    name of a computer.

DSO_FLAG_MIGHT_BE_UPN
    The value for the AK_USER_ENTERED_TEXT attribute could represent a
    userPrincipalName attribute value.

*/

#define DSO_NAME_PROCESSING_FLAG_MULTISELECT                0x00000001
#define DSO_NAME_PROCESSING_FLAG_IS_COMPUTER                0x00000002
#define DSO_NAME_PROCESSING_FLAG_MIGHT_BE_UPN               0x00000004
#define DSO_NAME_PROCESSING_FLAG_EXACT_UPN					0x00000008


//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_ProcessUserEntry
//
//  Synopsis:   Convert the user-entered string to an actual
//              object (if doing so generates more than one object, the
//              second through last are put in [pdsolExtras]).
//
//  Arguments:  [hwnd]   - object picker frame window
//              [pdsolExtras] - NULL if single select
//
//  Returns:    S_OK    - all items processed successfully
//              S_FALSE - user cancelled a dialog, quit processing
//              E_*
//
//  Modifies:   *[pdsolExtras]
//
//  History:    08-12-1998   DavidMun   Created
//
//  Notes:      The name in AK_USER_ENTERED_TEXT is a single name (i.e.  not
//              multiple semicolon delimited names) and has already had
//              leading and trailing spaces removed.
//
//---------------------------------------------------------------------------

HRESULT
CDsObject::_ProcessUserEntry(
    HWND hwnd,
    const CObjectPicker &rop,
    CDsObjectList *pdsolExtras,
    NAME_PROCESS_RESULT *pnpr)
{
    TRACE_METHOD(CDsObject, _ProcessUserEntry);

    HRESULT             hr = S_OK;
    CWaitCursor         Hourglass;
    CDsObjectList       dsolMatches;
    BOOL                fMultiselect = rop.GetInitInfoOptions() &
                                       DSOP_FLAG_MULTISELECT;
    ASSERT(fMultiselect && pdsolExtras || !fMultiselect && !pdsolExtras);
    const CScopeManager &rsm = rop.GetScopeManager();
    const CFilterManager &rfm = rop.GetFilterManager();

    //
    // Loop on this entry until it has been sucessfully processed, an
    // error occurs, or user selects 'remove this object' from a dialog
    // asking for info about this name.
    //

    String strName = GetAttr(AK_USER_ENTERED_TEXT).GetBstr();
    ASSERT(strName.length());

#if (DBG == 1)
    _DumpProcessUserEntry(rop, strName);
#endif

    while (TRUE)
    {
        size_t idxFirstWhack = strName.find(L'\\');
        //
        //Find the rightmost @
        //
        size_t idxLastAt= strName.rfind(L'@');
        ULONG flProcess = 0;

        if (fMultiselect)
        {
            flProcess |= DSO_NAME_PROCESSING_FLAG_MULTISELECT;
        }

        if (idxLastAt != String::npos)
        {
            //
            //This means name is either a UPN or Name in name@dnsDomainName 
            //format. In the comments UPN is used to mean both name formats.
            //
            flProcess |= DSO_NAME_PROCESSING_FLAG_MIGHT_BE_UPN;
        }

        if (idxFirstWhack == 0 && strName[1] == L'\\')
        {
            flProcess |= DSO_NAME_PROCESSING_FLAG_IS_COMPUTER;
        }

        //
        // If the name has backslashes beyond the first two, it's an error.
        //

        if (flProcess & DSO_NAME_PROCESSING_FLAG_IS_COMPUTER)
        {
            size_t idxExtraWhack = strName.find(L'\\', 2);

            if (idxExtraWhack != String::npos)
            {
                if (fMultiselect)
                {
                    CNameNotFoundDlg Dlg(rop, IDS_BAD_NAME, &strName);

                    hr = Dlg.DoModalDialog(hwnd, pnpr);
                    BREAK_ON_FAIL_HRESULT(hr);

                    if (NAME_PROCESSING_FAILED(*pnpr))
                    {
                        break;
                    }

                    ASSERT(dsolMatches.empty());
                    continue;
                }
                else
                {
                    PopupMessage(hwnd, IDS_BAD_NAME, strName.c_str());
                    *pnpr = NPR_STOP_PROCESSING;
                    break;
                }
            }

            //
            // Name starts with exactly two backslashes.  Strip them off.
            //

            strName.erase(0, 2);
        }

        //
        // If the name is of the form 'foo\bar' then treat 'foo' as a domain
        // or computer name and try to find 'bar' within it.  Note checking
        // for !(flProcess & DSO_NAME_PROCESSING_FLAG_IS_COMPUTER) doesn't mean
        // object can't be a computer, it just means the name wasn't in the
        // form \\foo.
        //

        if (idxFirstWhack != String::npos &&
            !(flProcess & DSO_NAME_PROCESSING_FLAG_IS_COMPUTER))
        {
            //
            // Note _SearchDomain has the ds customizer do a prefix
            // search in the domain 'foo' and includes those items in
            // dsolMatches.
            //
            // If the domain search fails and the user edits the string,
            // loop around and retry.  Can't just retry inside _SearchDomain
            // because the name may no longer be in form foo\bar.
            //

            _SearchDomain(&strName,
                          hwnd,
                          rop,
                          idxFirstWhack,
                          flProcess,
                          pnpr,
                          &dsolMatches);

            if (NAME_PROCESSING_FAILED(*pnpr))
            {
                break;
            }

            if (*pnpr == NPR_EDITED)
            {
                ASSERT(dsolMatches.empty());
                continue;
            }
        }
        else
        {
            //
            //For UPN format name, there is no prefix search. So once the
            //object is found we set bFoundObject to true and we don't do
            //any further search.
            //
            BOOL bFoundObject = FALSE;
            //
            //For UPN names, if UserEnteredUpLevelScope is present, we assume
            //that name after @ is domain name and do the search in it
            //this flag keeps track if we have already done the search in
            //domain name after @
            //
            BOOL bDoneUserSearch = FALSE;


			//
			//This is set to true by crackname if nameafter@ is in trusted Xforest
			//bExtForest can be true even if the object is not found in Xforest,
			//that means name before @ was entered incorrectly
			//
            BOOL bExtForest = FALSE;
            
			const CScope *pUpnDerivedScope = NULL;
            const CScope *pCrackNameScope = NULL;
            const CScope *pGCScope = NULL;

            //
            // strName does not contain slash or backslash.  It is
            // either a computer name, a UPN, or an RDN.
            //

            if (flProcess & DSO_NAME_PROCESSING_FLAG_MIGHT_BE_UPN)
            {
                //
                // If name might be upn, try to find domain scope
                // with dns name of portion after @.  
                   
                String strNameAfterAt(strName);
                strNameAfterAt.erase(0, idxLastAt + 1);

                //
                //Lookfor a scope with name of strNameAfterAt
                //
                pUpnDerivedScope = &rsm.LookupScopeByDisplayName(strNameAfterAt);

                if (IsUplevel(pUpnDerivedScope))
                {
                    bDoneUserSearch = TRUE;

                    //
                    //When a Search in cross forest in done, a new scope of 
                    //type DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN is added.
                    //Check if its Cross Forest.
                    //
                    BOOL bXForest = FALSE;
                    if(const_cast<CScope *>(pUpnDerivedScope)->GetType() == DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN)
                    {
                       const CLdapDomainScope *pLdapScope = 
                            dynamic_cast<const CLdapDomainScope*>(pUpnDerivedScope);

                        bXForest = pLdapScope->IsXForest();
                    }

                    //
                    //Size before Query
                    //
                    size_t cItemsAtStart = dsolMatches.size();

                    _QueryForName(hwnd,
                                  rop,
                                  *pUpnDerivedScope,
                                  strName,
                                  strName,
                                  flProcess,
                                  &dsolMatches,
                                  bXForest); 

                    //
                    //we found a match in query. 
                    //                        
                    if(cItemsAtStart < dsolMatches.size())
                        bFoundObject = TRUE;
                }
                //
                //Now try dscrack. This may give a reference to another forest also.
                //We try dscrack name only for uplevel domain.
                //
                MACHINE_CONFIG mc = rop.GetTargetComputerConfig();
                const SScopeParameters *pspUserUplevel =
                    rsm.GetScopeParams(ST_USER_ENTERED_UPLEVEL_SCOPE);
                const SScopeParameters *pspExtUplevel =
                    rsm.GetScopeParams(ST_EXTERNAL_UPLEVEL_DOMAIN);


                //
                //Do DsCrackNames if following conditons are true
                //1) Object is not found yet
                //2) We do dscrack begining from GC in this forest. So machine must be
                //   joined to uplevel domain or mustbe uplevel DC
                //3) And one of the scopes which can contain UPN name, must be present
                //

                if (!bFoundObject &&                                    //1
                    (mc == MC_JOINED_NT5 || mc == MC_NT5_DC) &&         //2    
                    (rsm.GetScopeParams(ST_UPLEVEL_JOINED_DOMAIN) ||    //3
                    rsm.GetScopeParams(ST_ENTERPRISE_DOMAIN) ||
                    rsm.GetScopeParams(ST_GLOBAL_CATALOG) ||
                    pspExtUplevel ||
                    pspUserUplevel))                    
                {

                    //
                    //Try to crack in external forest only if ST_EXTERNAL_UPLEVEL_DOMAIN
                    //Scope is present.
                    //
                    BOOL bCrackInExtForest = FALSE;
                    if(pspExtUplevel) 
                        bCrackInExtForest = TRUE;

                    //
                    //Crack the name
                    //
                    LPWSTR pwzResultName = NULL;                
					BOOL bAddDollar = FALSE;

                    hr = CrackName(hwnd,
                                   (LPWSTR)strName.c_str(),                                
                                   DS_USER_PRINCIPAL_NAME,
                                   (LPWSTR)rop.GetTargetForest().c_str(),
                                   bCrackInExtForest,
                                   &pwzResultName,
                                   &bExtForest,
								   &bAddDollar);
                    if(SUCCEEDED(hr) && pwzResultName)
                    {   
                        bDoneUserSearch = TRUE;
                        size_t cItemsAtStart = dsolMatches.size();

                        String strDomainFromCrack= pwzResultName;
                        LocalFree(pwzResultName);
                        pwzResultName = NULL;
                    
                        //
                        //Object is in this forest only
                        //
                        if(!bExtForest)
                        {
                            pCrackNameScope = 
                                &rsm.LookupScopeByDisplayName(strDomainFromCrack);
                            pGCScope = 
                                &rsm.LookupScopeByType(ST_GLOBAL_CATALOG);

                            //
                            //1)if any of the enumerated domain match
                            //  strDomainFromCrack, Search there
                            //2)else if userEnteredUplevelScope is present
                            //  try to search in strDomainCrack
                            //3)else if wehave GC Scope
                            //  search there
                            //

                            if(pCrackNameScope &&                       //1
                               !IsInvalid(*pCrackNameScope) &&
                               (pCrackNameScope != pUpnDerivedScope))
                            {
                                _QueryForName(hwnd,
                                              rop,
                                              *pCrackNameScope,
                                              strName,
                                              strName,
                                              flProcess,
                                              &dsolMatches,
                                              FALSE);
                            }
                            else if(pspUserUplevel)                     //2
                            {                                                    
                                _SearchUplevelDomain(hwnd,
                                                     rop,
                                                     strDomainFromCrack,
                                                     pspUserUplevel,
                                                     strName,
                                                     strName,
                                                     flProcess,
                                                     FALSE,
                                                     FALSE,
                                                     &dsolMatches);
                            }
                            else if(pGCScope &&
                                    !IsInvalid(*pGCScope))
                            {
                                _QueryForName(hwnd,
                                              rop,
                                              *pGCScope,
                                              strName,
                                              strName,
                                              flProcess|DSO_NAME_PROCESSING_FLAG_EXACT_UPN,
                                              &dsolMatches,
                                              FALSE);
                            }                            
                        }
                        else
                        {
							//
							//Ok the Object in XForest. Check if this scope is in
							//our list already. This needs to be done because
							//strDomainFromCrack can be different from nameafter@
							//
							String strXForestName = strName;
							if(bAddDollar)
								AddDollarToNameToCrack(DS_USER_PRINCIPAL_NAME, strXForestName);

							pCrackNameScope = 
                                &rsm.LookupScopeByDisplayName(strDomainFromCrack);

							if(pCrackNameScope &&                       //1
                               !IsInvalid(*pCrackNameScope))
							{
								_QueryForName(hwnd,
                                              rop,
                                              *pCrackNameScope,
                                              strXForestName,
                                              strXForestName,
                                              flProcess,
                                              &dsolMatches,
                                              TRUE);
							}
							else
							{
								_SearchUplevelDomain(hwnd,
									                 rop,
										             strDomainFromCrack,
											         pspExtUplevel,
												     strXForestName,
													 strXForestName,
													 flProcess,
													 FALSE,
													 TRUE,
													 &dsolMatches);

							}
						}

                        //
                        //we found a match in query. 
                        //                        
                        if(cItemsAtStart < dsolMatches.size())
                            bFoundObject = TRUE;

                    }
					//
					// If CrackName tells that domain is in External Forest and 
					// And EXTERNAL_UPLEVEL scope is present, no need to do UserSearch
					//
					if(bExtForest && pspExtUplevel)
						bDoneUserSearch = TRUE;

                }
            }

            //
            // Search the current scope but only if we didn't just search it
            // as rUpnDerivedScope. 
            //
            if(!bFoundObject && !bExtForest)
            {
                //Size before Query
                size_t cItemsAtStart = dsolMatches.size();   

                if (IsUplevel(rsm.GetCurScope()))
                {
                    BOOL fSearchCurScope = TRUE;

                    //
                    // Search the current scope if:
                    //
                    // a. there is no UPN derived scope
                    // b. there is a UPN derived scope, but it is not the current
                    //    scope and, if the current scope is the GC, the UPN
                    //    derived scope is not an enterprise domain.
                    // c. the current scope is downlevel
                    //

                    if (!pUpnDerivedScope || ( pUpnDerivedScope && IsInvalid(*pUpnDerivedScope)) )
                    {
                        fSearchCurScope = TRUE;
                    }
                    else if (rsm.GetCurScope().Type() == ST_GLOBAL_CATALOG &&
                            (pUpnDerivedScope->Type() == ST_UPLEVEL_JOINED_DOMAIN ||
                             pUpnDerivedScope->Type() == ST_ENTERPRISE_DOMAIN))
                    {
                        fSearchCurScope = FALSE;
                    }
                    else if (&rsm.GetCurScope() == pUpnDerivedScope ||
                             &rsm.GetCurScope() == pCrackNameScope ||
                             &rsm.GetCurScope() == pGCScope)
                    {
                        fSearchCurScope = FALSE;
                    }
                    else
                    {
                        fSearchCurScope = TRUE;
                    }

                    if (fSearchCurScope)
                    {
                        _QueryForName(hwnd,
                                      rop,
                                      rsm.GetCurScope(),
                                      strName,
                                      strName,
                                      flProcess & DSO_NAME_PROCESSING_FLAG_MIGHT_BE_UPN ? 
									  flProcess|DSO_NAME_PROCESSING_FLAG_EXACT_UPN:
									  flProcess,
                                      &dsolMatches,
                                      FALSE);

                    }
                }
                else if (IsDownlevel(rsm.GetCurScope()))
                {
                    _BindForName(hwnd,
                                 rop,
                                 rsm.GetCurScope(),
                                 strName,
                                 &dsolMatches);
                }

                //
                //Did we find the object
                //        
                if(cItemsAtStart < dsolMatches.size())
                        bFoundObject = TRUE;
            }


            //
            //if nothing found, try to bind to the domain directly
            //
            if(!bFoundObject &&
               rsm.GetScopeParams(ST_USER_ENTERED_UPLEVEL_SCOPE) &&
               !bDoneUserSearch &&
               (flProcess & DSO_NAME_PROCESSING_FLAG_MIGHT_BE_UPN))
            {
                String strNameAfterAt(strName);
                strNameAfterAt.erase(0, idxLastAt + 1);
                String strNameBeforeAt(strName);
                strNameBeforeAt.erase(idxLastAt);

                const SScopeParameters *pspUserUplevel =
                    rsm.GetScopeParams(ST_USER_ENTERED_UPLEVEL_SCOPE);


                _SearchUplevelDomain(hwnd,
                                     rop,
                                     strNameAfterAt,
                                     pspUserUplevel,
                                     strNameBeforeAt,
                                     strName,
                                     flProcess,
                                     FALSE,
                                     FALSE,
                                     &dsolMatches);
            }


            //
            // If the caller allows computer objects in user entered domains
            // and we have not already discovered a computer object with an
            // exact matching name then try binding to name as a computer
            // object.
            //

            _BindForComputer(hwnd, rop, strName, &dsolMatches);

            //
            // Ask the dsbrowse customizer to do a prefix search for the
            // objects it would add to the current scope.
            //

            _CustomizerPrefixSearch(hwnd,
                                    rop,
                                    rsm.GetCurScope(),
                                    strName,
                                    &dsolMatches);
        }

        //
        // If disabled objects are considered illegal, remove from the list
        // all which are disabled.  If this results in an empty list, make
        // a note of it so the appropriate error can be displayed in the
        // invalid name dialog.
        //

        BOOL fEmptyBecauseDisabledItemsRemoved = FALSE;

        if (g_fExcludeDisabled && !dsolMatches.empty())
        {
            CDsObjectList::iterator itCur;
            CDsObjectList::iterator itNext;

            for (itCur = dsolMatches.begin(); itCur != dsolMatches.end(); )
            {
                if (itCur->GetDisabled())
                {
                    Dbg(DEB_TRACE,
                        "Removing disabled match %ws\n",
                        itCur->GetName());
                    itNext = itCur;
                    itNext++;
                    dsolMatches.erase(itCur, itNext);
                    itCur = itNext;
                }
                else
                {
                    itCur++;
                }
            }

            if (dsolMatches.empty())
            {
                fEmptyBecauseDisabledItemsRemoved = TRUE;
            }
        }

        //
        // Ask the customizer to approve the matches, if any were found.
        // Note because this only REMOVES objects from matches, this is
        // called regardless of whether the DSOP_FILTER_EXTERNAL_CUSTOMIZER
        // or DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER flags are set.
        //
        // Those flags are only provided to prevent the ADDITION of objects
        // from customizers.
        //

        ICustomizeDsBrowser *pCustomize = rop.GetExternalCustomizer();

        if (pCustomize && !dsolMatches.empty())
        {
            RefCountPointer<CDataObject> rpdo;
            rpdo.Acquire(new CDataObject(const_cast<CObjectPicker*>(&rop),
                                         dsolMatches));
            BOOL *afApproved = new BOOL[dsolMatches.size()];

            ZeroMemory(afApproved, sizeof(BOOL) * dsolMatches.size());

            IDsObjectPickerScope *pDsopScope =
                (IDsObjectPickerScope *)&rsm.GetCurScope();

            hr = pCustomize->ApproveObjects(pDsopScope,
                                            rpdo.get(),
                                            afApproved);

            if (FAILED(hr))
            {
                dsolMatches.clear();
            }
            else if (hr == S_FALSE)
            {
                ULONG i;
                CDsObjectList::iterator itCur;
                CDsObjectList::iterator itNext;

                for (i = 0, itCur = dsolMatches.begin();
                     itCur != dsolMatches.end();
                     i++)
                {
                    if (!afApproved[i])
                    {
                        Dbg(DEB_TRACE,
                            "Removing unapproved match %ws\n",
                            itCur->GetName());
                        itNext = itCur;
                        itNext++;
                        dsolMatches.erase(itCur, itNext);
                        itCur = itNext;
                    }
                    else
                    {
                        itCur++;
                    }
                }
            }
            delete [] afApproved;
            hr = S_OK;
        }

        //
        // If no matches were found anywhere, have the user edit the name
        // and try again.
        //

        if (dsolMatches.empty())
        {
            if (fMultiselect)
            {
                ULONG idsMsg;

                if (fEmptyBecauseDisabledItemsRemoved)
                {
                    idsMsg = IDS_DISABLED_WARNING_FMT;
                }
                else
                {
                    idsMsg = IDS_NAME_NOT_FOUND_FMT_MULTI;
                }

                CNameNotFoundDlg Dlg(rop, idsMsg, &strName);

                hr = Dlg.DoModalDialog(hwnd, pnpr);

                if (NAME_PROCESSING_FAILED(*pnpr))
                {
                    break;
                }

                //
                // strName has been updated.  Loop around and try again.
                //

                ASSERT(*pnpr == NPR_EDITED);
                continue;
            }
            else
            {
                ULONG idsMsg;

                if (fEmptyBecauseDisabledItemsRemoved)
                {
                    idsMsg = IDS_DISABLED_WARNING_FMT;
                }
                else
                {
                    idsMsg = IDS_NAME_NOT_FOUND_FMT_SINGLE;
                }

				//
				//Truncate the object name to MAX_OBJECTNAME_DISPLAY_LEN
				//
				String strObjectName = strName;
				if(!strObjectName.empty() && (strObjectName.size() > MAX_OBJECTNAME_DISPLAY_LEN))
				{
					strObjectName.erase(MAX_OBJECTNAME_DISPLAY_LEN,strObjectName.size());
					//
					//Add three dots to indicate that name is truncated
					//
					strObjectName.append(L"...");
				}

                PopupMessage(hwnd,
                             idsMsg,
                             strObjectName.c_str(),
                             rfm.GetFilterDescription(hwnd, FOR_LOOK_FOR).c_str());
                *pnpr = NPR_STOP_PROCESSING;
                break;
            }
        }
        else if (dsolMatches.size() > 1)
        {
            //
            // More than one match was found.  Ask the user to pick which
            // is (are) valid.
            //

            hr = _MultiMatchDialog(hwnd,
                                   rop,
                                   fMultiselect,
                                   strName,
                                   pnpr,
                                   &dsolMatches,
                                   pdsolExtras);
            BREAK_ON_FAIL_HRESULT(hr);

            if (*pnpr == NPR_EDITED)
            {
                ASSERT(dsolMatches.empty());
                continue;
            }
        }

        break;
    }

    //
    // Out of the processing loop for this entry.  If it was successful,
    // dsolMatches has exactly one object.
    //

    if (!NAME_PROCESSING_FAILED(*pnpr) && SUCCEEDED(hr) && hr != S_FALSE)
    {
        ASSERT(dsolMatches.size() == 1);
        *this = dsolMatches.front();
    }

    if (FAILED(hr))
    {
        if (!NAME_PROCESSING_FAILED(*pnpr))
        {
            *pnpr = NPR_STOP_PROCESSING;
        }
    }

    // Preserve any edits user made

    m_AttrValueMap[AK_USER_ENTERED_TEXT] = Variant(strName);

    return hr;
}




#if (DBG == 1)
void
CDsObject::_DumpProcessUserEntry(
    const CObjectPicker &rop,
    const String &strName)
{
    const CFilterManager &rfm = rop.GetFilterManager();
    const CScopeManager &rsm = rop.GetScopeManager();
    ULONG flCurFilterFlags = rfm.GetCurScopeSelectedFilterFlags();
    String strFilter = DbgGetFilterDescr(rop, flCurFilterFlags);

    Dbg(DEB_TRACE, "UA: Processing entry:    '%ws'\n", strName.c_str());
    Dbg(DEB_TRACE, "UA: Current scope is:    %ws\n",
        rsm.GetCurScope().GetDisplayName().c_str());
    Dbg(DEB_TRACE, "UA: Current classes are: %ws\n", strFilter.c_str());
}
#endif // (DBG == 1)




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_SearchDomain
//
//  Synopsis:   Search within the domain specified by the portion of the
//              user's string entry before the backslash at [idxFirstWhack].
//
//  Arguments:  [pstrName]      - name for which to search
//              [hwnd]          - for bind
//              [rop]           - containing object picker instance
//              [idxFirstWhack] - index of first '\' character in *[pstrName]
//              [flProcess]     - DSO_NAME_PROCESSING_FLAG_* bits
//              [pnpr]          - filled with result of processing
//              [pdsolMatches]  - any matching names are added to this list
//
//  History:    08-15-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDsObject::_SearchDomain(
    String *pstrName,
    HWND hwnd,
    const CObjectPicker &rop,
    size_t idxFirstWhack,
    ULONG flProcess,
    NAME_PROCESS_RESULT *pnpr,
    CDsObjectList *pdsolMatches)
{
    TRACE_METHOD(CDsObject, _SearchDomain);
    ASSERT(pdsolMatches->empty());

    *pnpr = NPR_SUCCESS;
    HRESULT hr = S_OK;
    String strScopeName(pstrName->substr(0, idxFirstWhack));
    String strRdn;
    const CFilterManager &rfm = rop.GetFilterManager();

    strRdn = pstrName->substr(idxFirstWhack + 1,
                              pstrName->length() - idxFirstWhack - 1);

    do
    {
        //
        // Complain if there's more than one backslash
        //

        if (pstrName->find(L'\\', idxFirstWhack + 1) != String::npos)
        {
            if (flProcess & DSO_NAME_PROCESSING_FLAG_MULTISELECT)
            {
                CNameNotFoundDlg Dlg(rop, IDS_BAD_NAME_EXTRA_SLASH, pstrName);

                hr = Dlg.DoModalDialog(hwnd, pnpr);
            }
            else
            {
                PopupMessage(hwnd,
                             IDS_BAD_NAME_EXTRA_SLASH,
                             pstrName->c_str());
                *pnpr = NPR_STOP_PROCESSING;
            }
            break;
        }

        //
        // Complain if there's nothing after the backslash (this would
        // generate a query that matches everything)
        //

        if (!(*pstrName)[idxFirstWhack + 1])
        {
            if (flProcess & DSO_NAME_PROCESSING_FLAG_MULTISELECT)
            {
                CNameNotFoundDlg Dlg(rop, IDS_BAD_NAME_SLASH_AT_END, pstrName);

                hr = Dlg.DoModalDialog(hwnd, pnpr);
            }
            else
            {
                PopupMessage(hwnd,
                             IDS_BAD_NAME_SLASH_AT_END,
                             pstrName->c_str());
                *pnpr = NPR_STOP_PROCESSING;
            }
            break;
        }


        // try the crack before any other scopes, to fix
        // NTRAID#NTBUG9-243391-2000/12/13-sburns
        // 
        // Well this is inefficient as it does crackname everytime
        // and also introduces the regression 
        // NTRAID#NTBUG9-282051-2001/01/17-hiteshr
        // i am moving it back to its original position.

        const CScopeManager &rsm = rop.GetScopeManager();

        //
        // Look for scope with display name matching portion of user's
        // string before the backslash.
        //

        Dbg(DEB_NAMEEDIT,
            "Looking for scope with flat name '%ws'\n",
            strScopeName.c_str());

        const CScope *pMatchingScope = &rsm.LookupScopeByFlatName(strScopeName);

        //
        // If a matching scope is found, query for or bind to the name
        // within that scope, and perform a prefix search of the custom
        // objects for that scope.
        //

        if (pMatchingScope && !IsInvalid(*pMatchingScope))
        {
            size_t cItemsAtStart = pdsolMatches->size();

            if (IsUplevel(*pMatchingScope))
            {

                BOOL bXForest = FALSE;
                if(const_cast<CScope*>(pMatchingScope)->GetType() == DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN)
                {
                    const CLdapDomainScope *pLdapScope = 
                        dynamic_cast<const CLdapDomainScope*>(pMatchingScope);

                    bXForest = pLdapScope->IsXForest();
                }

                _QueryForName(hwnd,
                              rop,
                              *pMatchingScope,
                              strRdn,
                              *pstrName,
                              flProcess,
                              pdsolMatches,
                              bXForest);
            }
            else
            {
                _BindForName(hwnd,
                             rop,
                             *pMatchingScope,
                             strRdn,
                             pdsolMatches);
            }

            _CustomizerPrefixSearch(hwnd,
                                    rop,
                                    *pMatchingScope,
                                    strRdn,
                                    pdsolMatches);

            if (cItemsAtStart == pdsolMatches->size())
            {
                if (flProcess & DSO_NAME_PROCESSING_FLAG_MULTISELECT)
                {
                    CNameNotFoundDlg Dlg(rop,
                                        IDS_NAME_NOT_FOUND_FMT_MULTI,
                                        pstrName);

                    hr = Dlg.DoModalDialog(hwnd, pnpr);
                }
                else
                {
                    PopupMessage(hwnd,
                                 IDS_NAME_NOT_FOUND_FMT_SINGLE,
                                 pstrName->c_str(),
                                 rfm.GetFilterDescription(hwnd, FOR_LOOK_FOR).c_str());
                    *pnpr = NPR_STOP_PROCESSING;
                }
            }
            break;
        }

         //
         //Now try dscrack. This may give a reference to another forest also.
         //We try dscrack name only for uplevel domain.
         //
         const SScopeParameters *pspExtUplevel =
                     rsm.GetScopeParams(ST_EXTERNAL_UPLEVEL_DOMAIN);
 
         MACHINE_CONFIG mc = rop.GetTargetComputerConfig();
         if ((mc == MC_JOINED_NT5 || mc == MC_NT5_DC) &&         
             pspExtUplevel)
         {
 
 
             //
             //Crack the name
             //
             LPWSTR pwzResultName = NULL;                
             BOOL bExtForest = FALSE;
			 BOOL bAddDollar = FALSE;
 
             hr = CrackName(hwnd,
                            (LPWSTR)pstrName->c_str(),                                
                            DS_NT4_ACCOUNT_NAME,
                            (LPWSTR)rop.GetTargetForest().c_str(),
                            TRUE,
                            &pwzResultName,
                            &bExtForest,
							&bAddDollar);
             if(SUCCEEDED(hr) && bExtForest)
             {   
				 size_t cItemsAtStart = pdsolMatches->size();
                 if(pwzResultName )
                 {
					 String strXForestRdn = strRdn;
					 String strXForestUserEnteredString = *pstrName;
					 if(bAddDollar)
					 {						
						strXForestRdn += L"$";
						AddDollarToNameToCrack(DS_NT4_ACCOUNT_NAME,strXForestUserEnteredString);
					 }

                     String strDomainFromCrack = pwzResultName;
                     LocalFree(pwzResultName);
                     pwzResultName = NULL;

					 pMatchingScope = &rsm.LookupScopeByFlatName(strDomainFromCrack);

					//
					// If a matching scope is found, query for or bind to the name
					// within that scope, and perform a prefix search of the custom
					// objects for that scope.
					//

					if (pMatchingScope && !IsInvalid(*pMatchingScope))
					{

						_QueryForName(hwnd,
									  rop,
									  *pMatchingScope,
									  strXForestRdn,
									  strXForestUserEnteredString,
									  flProcess,
									  pdsolMatches,
									  TRUE);
						if(cItemsAtStart == pdsolMatches->size())				 
						{
							_CustomizerPrefixSearch(hwnd,
										            rop,
													*pMatchingScope,
													strXForestRdn,
													pdsolMatches);
						}
					}
					else
					{
						_SearchUplevelDomain(hwnd,
							                 rop,
								             strDomainFromCrack,
									         pspExtUplevel,
										     strXForestRdn,
											 strXForestUserEnteredString,
											 flProcess,
											 TRUE,
											 TRUE,
											 pdsolMatches);
                     
					}
					break;
                 } 
				 //else
				 //{
					//We come here means in "a\b" "a" is in Xforest but 
					//there is no object named "b" in "a". We should quit
					//Here we need to show the NameNotFound message.
					//Below if statement will show that.
				//}					

				 if(cItemsAtStart == pdsolMatches->size())				 
				 {
					if (flProcess & DSO_NAME_PROCESSING_FLAG_MULTISELECT)
					{
						CNameNotFoundDlg Dlg(rop,
											IDS_NAME_NOT_FOUND_FMT_MULTI,
											pstrName);

						hr = Dlg.DoModalDialog(hwnd, pnpr);
					}
					else
					{
						PopupMessage(hwnd,
									 IDS_NAME_NOT_FOUND_FMT_SINGLE,
									 pstrName->c_str(),
									 rfm.GetFilterDescription(hwnd, FOR_LOOK_FOR).c_str());
						*pnpr = NPR_STOP_PROCESSING;
					}
					break;
				 }
             }                            
         }

        //
        // No matching scope. If the caller doesn't want us to search in
        // domains that didn't appear in the scope control, fail now.
        //
        // Note this code that requires the full list of domain scopes has
        // been populated before we get here, otherwise we could reject the
        // user's entry claiming that a scope which hasn't yet been added to
        // the scope list doesn't exist.
        //

        const SScopeParameters *pspUserUplevel =
            rsm.GetScopeParams(ST_USER_ENTERED_UPLEVEL_SCOPE);

        const SScopeParameters *pspUserDownlevel =
            rsm.GetScopeParams(ST_USER_ENTERED_DOWNLEVEL_SCOPE);

        if (!pspUserUplevel && !pspUserDownlevel)
        {
            //
            // See if the user entered the bogus form:
            //      dns-name\object-name
            // If so, present a message explaining that they should
            // either use netbios-name\object-name or object-name@dns-name.
            //

            const CLdapDomainScope *pMatchingDisplayScope =
                dynamic_cast<const CLdapDomainScope *>
                    (&rsm.LookupScopeByDisplayName(strScopeName));

            String strValidNB;
            String strValidUPN;

            if (pMatchingDisplayScope)
            {
                strValidNB = pMatchingDisplayScope->GetFlatName();
                strValidNB += L"\\";
                strValidNB += strRdn;

                strValidUPN = strRdn + L"@";
                strValidUPN += strScopeName;
            }

            if (flProcess & DSO_NAME_PROCESSING_FLAG_MULTISELECT)
            {
                if (pMatchingDisplayScope)
                {
                    //
                    // yep.  build up an error message that explains
                    // what they did wrong and how to fix it.
                    //

                    String strError = String::format(IDS_DNS_SLASH_NAME,
                                                     pstrName->c_str(),
                                                     strValidNB.c_str(),
                                                     strValidUPN.c_str());

                    CNameNotFoundDlg Dlg(rop, strError, pstrName);

                    hr = Dlg.DoModalDialog(hwnd, pnpr);
                }
                else
                {
                    //
                    // nope, they entered some random string which
                    // doesn't match the dns or the netbios name of
                    // anything in the lookin control.
                    //

                    CNameNotFoundDlg Dlg(rop, IDS_UNKNOWN_DOMAIN, pstrName);

                    hr = Dlg.DoModalDialog(hwnd, pnpr);
                }
            }
            else
            {
                if (pMatchingDisplayScope)
                {
                    PopupMessage(hwnd,
                                 IDS_UNKNOWN_DOMAIN,
                                 pstrName->c_str(),
                                 strValidNB.c_str(),
                                 strValidUPN.c_str());
                }
                else
                {
                    PopupMessage(hwnd,
                                 IDS_UNKNOWN_DOMAIN,
                                 pstrName->c_str());
                }
                *pnpr = NPR_STOP_PROCESSING;
            }
            break;
        }

        //
        // Try to find an uplevel domain with name matching what the
        // user typed before the backslash, then query within it for
        // items starting with the characters after the backslash.
        //

        size_t cBeforeUplevelSearch = pdsolMatches->size();

        if (pspUserUplevel)
        {
            _SearchUplevelDomain(hwnd,
                                 rop,
                                 strScopeName,
                                 pspUserUplevel,
                                 strRdn,
                                 *pstrName,
                                 flProcess,
                                 TRUE,
                                 FALSE,
                                 pdsolMatches);
        }

        //
        // If no objects found that way, try searching for the object
        // strRdn in a downlevel domain with name strScopeName.
        //

        if (pspUserDownlevel &&
            pdsolMatches->size() == cBeforeUplevelSearch)
        {
            _SearchDownlevelDomain(hwnd,
                                   rop,
                                   strScopeName,
                                   strRdn,
                                   pdsolMatches);

            if (pdsolMatches->size() == cBeforeUplevelSearch)
            {
                if (flProcess & DSO_NAME_PROCESSING_FLAG_MULTISELECT)
                {
                    CNameNotFoundDlg Dlg(rop,
                                        IDS_NAME_NOT_FOUND_FMT_MULTI,
                                        pstrName);

                    hr = Dlg.DoModalDialog(hwnd, pnpr);
                }
                else
                {
                    PopupMessage(hwnd,
                                 IDS_NAME_NOT_FOUND_FMT_SINGLE,
                                 pstrName->c_str(),
                                 rfm.GetFilterDescription(hwnd, FOR_LOOK_FOR).c_str());
                    *pnpr = NPR_STOP_PROCESSING;
                }
            }
        }
    }
    while (0);

    if (*pnpr == NPR_EDITED)
    {
        pdsolMatches->clear();
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_SearchUplevelDomain
//
//  Synopsis:   Attempt to bind to an uplevel domain with name [strScopeName]
//              and search for a name starting with [strRdn] there.
//
//  Arguments:  [hwnd]           - for bind
//              [rop]            - containing object picker instance
//              [strScopeName]   - name of scope to search in
//              [pspUserUplevel] - parameters for that scope
//              [strRdn]          [strNamePrefix] - Name to search for. 
//                                If user entered the name in domain\foo 
//                                format its foo
//                                If user entered the name in foo@domain 
//                                format its foo@domain
//                                If use entered the foo, its foo
//              [strUserEnteredString] The string user entered. Its used to 
//                                 get the sid in XForest case.
//              [bDoCustomizePrefix]    Call ExternalCustomizer. This is true
//                                  if user entered name in format
//                                  Domain\Foo and false if foo@domain
//              [bXForest]          Is name in XForest
//              [flProcess]      - DSO_NAME_PROCESSING_FLAG_* bits
//              [pdsolMatches]   - any matches are added to this list
//
//  History:    08-15-1998   DavidMun   Created
//
//  Notes:      If uplevel domain is found, creates a new scope object.
//
//---------------------------------------------------------------------------

void
CDsObject::_SearchUplevelDomain(
    HWND hwnd,
    const CObjectPicker &rop,
    const String &strScopeName,
    const SScopeParameters *pspUserUplevel,
    const String &strRdn,
    const String &strUserEnteredString,
    ULONG flProcess,
    BOOL bDoCustomizePrefix,
    BOOL bXForest,
    list<CDsObject> *pdsolMatches)
{
    TRACE_METHOD(CDsObject, _SearchUplevelDomain);
    HRESULT hr = S_OK;
    String strDomainPath(c_wzLDAPPrefix);
    RpIDirectorySearch rpDirSearch;

    do
    {
        strDomainPath += strScopeName;

        hr = g_pBinder->BindToObject(hwnd,
                                     strDomainPath.c_str(),
                                     IID_IDirectorySearch,
                                     (void**)&rpDirSearch);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Create a scope for this domain.  It will not be made
        // visible (added to the dropdown scope list) but will be
        // included in the list of those searched if another name
        // in the form foo\bar is processed.
        //

        ADD_SCOPE_INFO  asi;
        if(!bXForest)
            asi.flType = DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE;
        else
            asi.flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN;
        asi.FilterFlags = pspUserUplevel->FilterFlags;
        asi.Visibility = SCOPE_HIDDEN;
        asi.Domain.strScopeName = strScopeName;
        asi.Domain.strFlatName = strScopeName;
        asi.Domain.strADsPath = strDomainPath;

        const CScopeManager &rsm = rop.GetScopeManager();

        const CScope *pNewScope;
        if(!bXForest)
            pNewScope = &rsm.AddUserEnteredScope(asi);
        else
            pNewScope = &rsm.AddCrossForestDomainScope(asi);        



        //
        // Query on the new scope for the rdn, also look for whatever
        // custom objects would be added to that domain scope.
        //

         size_t cItemsAtStart = pdsolMatches->size();

        _QueryForName(hwnd,
                      rop,
                      *pNewScope,
                      strRdn,
                      strUserEnteredString,
                      flProcess,
                      pdsolMatches,
                      bXForest);

		//
		//In cross forest we don't do prefix search, so if we have already found some objects
		//don't do further search
		//
        if(bDoCustomizePrefix && !(bXForest && (cItemsAtStart != pdsolMatches->size())))
            _CustomizerPrefixSearch(hwnd, rop, *pNewScope, strRdn, pdsolMatches);

    } while (0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_SearchDownlevelDomain
//
//  Synopsis:   Attempt to bind to a downlevel domain with name
//              [strScopeName], then bind within that domain for a name
//              starting with [strRdn].
//
//  Arguments:  [hwnd]         - for bind
//              [rop]          - containing object picker instance
//              [strScopeName] - name of downlevel domain
//              [strRdn]       - name to search for
//              [pdsolMatches] - any matches are added to this list
//
//  History:    08-15-1998   DavidMun   Created
//
//  Notes:      If downlevel domain is found, creates a new scope object.
//
//---------------------------------------------------------------------------

void
CDsObject::_SearchDownlevelDomain(
    HWND hwnd,
    const CObjectPicker &rop,
    const String &strScopeName,
    const String &strRdn,
    CDsObjectList *pdsolMatches)
{
    TRACE_METHOD(CDsObject, _SearchDownlevelDomain);
    HRESULT hr = S_OK;
    String  strScopePath;
    String  strScopePathWithHint;
    RpIADs  rpADs;

    do
    {
        strScopePath += c_wzWinNTPrefix + strScopeName;

        //
        // Try strScopeName as a computer first.
        //

        strScopePathWithHint = strScopePath + L",Computer";

        hr = g_pBinder->BindToObject(hwnd,
                                     strScopePathWithHint.c_str(),
                                     IID_IADs,
                                     (void**)&rpADs);

        if (FAILED(hr))
        {
            // Nope.  Try as domain.

            strScopePathWithHint = strScopePath + L",Domain";

            hr = g_pBinder->BindToObject(hwnd,
                                         strScopePathWithHint.c_str(),
                                         IID_IADs,
                                         (void**)&rpADs);
        }

        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Bind succeeded, therefore computer or domain exists.  Add a scope
        // for it and look for the RDN within it.
        //

        ADD_SCOPE_INFO  asi;

        const CScopeManager &rsm = rop.GetScopeManager();
        const SScopeParameters *pspUserDownlevel =
            rsm.GetScopeParams(ST_USER_ENTERED_DOWNLEVEL_SCOPE);

        asi.flType = DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
        asi.FilterFlags = pspUserDownlevel->FilterFlags;
        asi.Visibility = SCOPE_HIDDEN;
        asi.Domain.strScopeName = strScopeName;
        asi.Domain.strFlatName = strScopeName;
        asi.Domain.strADsPath = strScopePathWithHint;

        const CScope &rNewScope = rsm.AddUserEnteredScope(asi);

        //
        //Size of query before search
        //

        size_t cItemsAtStart = pdsolMatches->size();

        _BindForName(hwnd, rop, rNewScope, strRdn, pdsolMatches);
        _CustomizerPrefixSearch(hwnd, rop, rNewScope, strRdn, pdsolMatches);

        //
        //We don't keep this scope in list if nothing is found in this scope.
        //NTRAID#NTBUG9-243391-2001/01/17-hiteshr
        //
        if(cItemsAtStart == pdsolMatches->size())
            rsm.DeleteLastScope();

    } while (0);
}

HRESULT
_tThread_Proc(
    CProgressDialog& dialog)
{
	CRow * pRow = dialog.m_pRow;
	ULONG flProcess = dialog.m_flProcess;
	ULONG   cHits = 0;
	BOOL bXForest = dialog.m_bXForest;
	const CObjectPicker &rop = dialog.m_rop;
	const CScope &Scope = dialog.m_Scope;
	const String &strUserEnteredString = dialog.m_strUserEnteredString;
	CDsObjectList *pdsolMatches = dialog.m_pdsolMatches;

	ASSERT(pRow && pdsolMatches);
	
	String strFormat = String::load((int)IDS_PROGRESS_MESSAGE, g_hinst);
	HRESULT hr = S_OK;
    while (SUCCEEDED(hr))
    {
		//
		//User pressed the stop button. Stop now.
		//
		if(dialog.HasUserCancelled())
			break;
		
		WCHAR buffer[34];
		_itow(cHits,buffer,10);
		String strMessage = String::format(strFormat, buffer);
		dialog.UpdateText(strMessage);

		hr = pRow->Next();

        if (hr == S_ADS_NOMORE_ROWS)
        {
            Dbg(DEB_TRACE,
                "_QueryForName: S_ADS_NOMORE_ROWS, got %u\n",
                cHits);

            ULONG ulADsLastError;
            WCHAR wzError[MAX_PATH];
            WCHAR wzProvider[MAX_PATH];

            HRESULT hr2 = ADsGetLastError(&ulADsLastError,
                                          wzError,
                                          ARRAYLEN(wzError),
                                          wzProvider,
                                          ARRAYLEN(wzProvider));

            if (SUCCEEDED(hr2) && ulADsLastError == ERROR_MORE_DATA)
            {
                Dbg(DEB_TRACE, "Got ERROR_MORE_DATA, trying again\n");
                continue;
            }
		
			break;
        }
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // If we know that the user is looking for a computer, discard
        // objects not of class computer.
        //

        if (flProcess & DSO_NAME_PROCESSING_FLAG_IS_COMPUTER)
        {
            PCWSTR pwzClass = pRow->GetColumnStr(AK_OBJECT_CLASS);

            if (!pwzClass)
            {
                continue;
            }

            if (lstrcmpi(pwzClass, c_wzComputerObjectClass))
            {
                continue;
            }
        }

        //
        // Create a new object and add it to the list
        //

        PCWSTR pwzName = pRow->GetColumnStr(AK_NAME);
        PCWSTR pwzClass = pRow->GetColumnStr(AK_OBJECT_CLASS);
        PCWSTR pwzPath = pRow->GetColumnStr(AK_ADSPATH);

        if (!pwzClass || !pwzName || !pwzPath)
        {
            Dbg(DEB_WARN,
                "Skipping item missing class ('%ws'), name ('%ws'), or path ('%ws')\n",
                pwzClass ? pwzClass : L"",
                pwzName ? pwzName : L"",
                pwzPath ? pwzPath : L"");
            continue;
        }


        //
        // Stop fetching items if we've exceeded the max for the multimatch
        // dialog.
        //

        if (++cHits > MAX_SEARCH_HITS)
        {
            PopupMessageEx(dialog.GetHwnd(),
                           IDI_WARNING,
                           IDS_MAX_HITS,
                           MAX_SEARCH_HITS_STR);
            break;
        }

        //
        //If object is from Xforest, there is possibility of SID spoofing
        //we must verify that SID if fetched is good
        //
        if(bXForest)
        {
            PSID pSid = pRow->GetObjectSid();
            if(pSid)
            {
                BOOL bGoodSid = FALSE;
                hr = IsSidGood(rop.GetTargetComputer().c_str(),
                               strUserEnteredString.c_str(),
                               pSid,
                               &bGoodSid);
    
                BREAK_ON_FAIL_HRESULT(hr);

                
                if(!bGoodSid)
                {
                    Dbg(DEB_WARN,
                    "Skipping item Bad Sid('%ws'), name ('%ws'), or path ('%ws')\n",
                     pwzClass ? pwzClass : L"",
                     pwzName ? pwzName : L"",
                     pwzPath ? pwzPath : L"");

                    continue;
                }
            }                
        }

        //
        // Add this new object if it isn't already in the list
        //

        CDsObject dsoNew(Scope.GetID(), pRow->GetAttributes());

        if (find(pdsolMatches->begin(), pdsolMatches->end(), dsoNew) ==
            pdsolMatches->end())
        {
            pdsolMatches->push_back(dsoNew);

        }
    }
	
	dialog.ThreadDone();
	return S_OK;
}

//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_QueryForName
//
//  Synopsis:   Perform a query in uplevel domain represented by [pDsScope]
//              for an object whose name starts with [strNamePrefix].
//
//  Arguments:  [hwnd]          - for bind
//              [rop]           - containing object picker instance
//              [Scope]         - scope in which to query
//              [strNamePrefix] - Name to search for. 
//                                If user entered the name in domain\foo 
//                                format its foo
//                                If user entered the name in foo@domain 
//                                format its foo@domain
//                                If use entered the foo, its foo
//              [strUserEnteredString] The string user entered. Its used to 
//                                get the sid from LSA in case of cross forest.                
//              [flProcess]     - DSO_NAME_PROCESSING_FLAG_* bits
//              [pdsolMatches]  - list to which to append matches
//              [bXForest]      - Is strNamePrefix in other forest. 
//                                If the name is another forest, we don't 
//                                support prefix search
//  History:    08-15-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDsObject::_QueryForName(
    HWND hwnd,
    const CObjectPicker &rop,
    const CScope &Scope,
    const String &strNamePrefix,
    const String &strUserEnteredString,
    ULONG flProcess,
    CDsObjectList *pdsolMatches,
    BOOL bXForest)
{
    TRACE_METHOD(CDsObject, _QueryForName);
    ASSERT(IsUplevel(Scope));

    HRESULT hr = S_OK;
    const CLdapContainerScope *pLdapScope =
        dynamic_cast<const CLdapContainerScope *>(&Scope);

    if (!pLdapScope)
    {
        Dbg(DEB_TRACE,
            "Scope '%ws' type %u cast to CLdapContainerScope failed\n",
            Scope.GetDisplayName().c_str(),
            Scope.Type());
        ASSERT(0 && "expected to recieve ldap scope");
        return;
    }

    //
    // If the scope to query in is not the same as the current scope, then
    // it might not allow the types of objects selected for the current
    // scope.
    //

    const CFilterManager &rfm = rop.GetFilterManager();
    String strLdapContainerFilter = rfm.GetLdapFilter(hwnd, Scope);

    if (strLdapContainerFilter.empty())
    {
        Dbg(DEB_TRACE,
            "Scope '%ws' has no ldap query, returning\n",
            Scope.GetDisplayName().c_str());
        return;
    }

    String strADsPath;
    hr = pLdapScope->GetADsPath(hwnd, &strADsPath);

    if (FAILED(hr))
    {
        Dbg(DEB_TRACE,
            "Scope '%ws' has no ldap path, returning\n",
            Scope.GetDisplayName().c_str());
        return;
    }

    RpIDirectorySearch rpDirSearch;

    hr = g_pBinder->BindToObject(hwnd,
                                 strADsPath.c_str(),
                                 IID_IDirectorySearch,
                                 (void**)&rpDirSearch);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return;
    }

    //
    // Make a copy of the standard preferences and modify time limit
    // so it will be longer.  Want more generous limit for finding a
    // name the user typed in than just browsing.
    //

    ADS_SEARCHPREF_INFO aSearchPrefs[NUM_SEARCH_PREF];

    CopyMemory(aSearchPrefs, g_aSearchPrefs, sizeof(aSearchPrefs));

    ULONG i;

    for (i = 0; i < NUM_SEARCH_PREF; i++)
    {
        if (aSearchPrefs[i].dwSearchPref == ADS_SEARCHPREF_PAGED_TIME_LIMIT)
        {
            aSearchPrefs[i].vValue.Integer = NAME_QUERY_PAGE_TIME_LIMIT;
            break;
        }
    }

    hr = rpDirSearch->SetSearchPreference(aSearchPrefs, NUM_SEARCH_PREF);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return;
    }

    //
    // Build the query clause, using an escaped version of the name.
    //

    String strEscaped(strNamePrefix);

    LdapEscape(&strEscaped);

    String strNameFilter;

	if(flProcess & DSO_NAME_PROCESSING_FLAG_EXACT_UPN)
	{
        strNameFilter = String::format(c_wzUpnQueryFormatExact,
                                       strEscaped.c_str());
	}
    else if (flProcess & DSO_NAME_PROCESSING_FLAG_MIGHT_BE_UPN)
    {
        String strNameBeforeAt(strNamePrefix);
        size_t idxLastAt = strNameBeforeAt.rfind(L'@');   
        if (idxLastAt != String::npos)
        {
            strNameBeforeAt.erase(idxLastAt);
        }
        LdapEscape(&strNameBeforeAt);        
        strNameFilter = String::format(c_wzUpnQueryFormatEx,
                                       strNameBeforeAt.c_str(),
                                       strEscaped.c_str());

    }
    else
    {
        if(bXForest)    
            strNameFilter = String::format(c_wzCnQueryFormatExact, strEscaped.c_str());
        else
            strNameFilter = String::format(c_wzCnQueryFormat, strEscaped.c_str());
    }

#if (DBG == 1)
    Dbg(DEB_TRACE,
        "Querying for name %ws in scope %ws\n",
        strEscaped.c_str(),
        Scope.GetDisplayName().c_str());
#endif

    String strQuery;

    strQuery = L"(&";
    strQuery += strLdapContainerFilter;
    strQuery += strNameFilter;
    strQuery += L")";

    //
    // Perform the query
    //

    AttrKeyVector vakAttrToFetch;

    vakAttrToFetch.push_back(AK_NAME);
    vakAttrToFetch.push_back(AK_OBJECT_CLASS);
    vakAttrToFetch.push_back(AK_ADSPATH);
    vakAttrToFetch.push_back(AK_USER_ACCT_CTRL);
    vakAttrToFetch.push_back(AK_USER_PRINCIPAL_NAME);
    vakAttrToFetch.push_back(AK_EMAIL_ADDRESSES);
    vakAttrToFetch.push_back(AK_SAMACCOUNTNAME);
    //
    //If object in cross forest, get the sid
    //
    if(bXForest)
        vakAttrToFetch.push_back(AK_OBJECT_SID);

    CRow Row(hwnd, rop, rpDirSearch.get(), strQuery, vakAttrToFetch);


	CProgressDialog ProgressDialog(_tThread_Proc,
								   IDA_SEARCH,
								   1000*3,
								   &Row,
								   flProcess,
								   bXForest,
								   rop,
								   Scope,
								   strUserEnteredString,
								   pdsolMatches);

	
	ProgressDialog.CreateProgressDialog(hwnd);

}




//+--------------------------------------------------------------------------
//
//  Class:      CStringCompare
//
//  Purpose:    Used as functor to search for string [rhs]
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

class CStringCompare
{
public:

    CStringCompare(
        const String &rhs):
            m_rhs(rhs)
    {
    }

    BOOL
    operator()(const String &lhs)
    {
        return !m_rhs.icompare(lhs);
    }

private:

    String m_rhs;
};

enum GROUP_TYPE
{
    GT_UNKNOWN,
    GT_LOCAL,
    GT_GLOBAL
};

#define NUM_SUB_AUTHORITES_FOR_BUILTIN_GROUPS   2


//+--------------------------------------------------------------------------
//
//  Function:   WantThisGroup
//
//  Synopsis:   Return TRUE if group object represented by [pADs] is valid in
//              scope [pDsScope].
//
//  Arguments:  [pDsScope]  - scope in which to check for acceptable groups
//              [pADs]      - points to group object to check
//              [ppwzClass] - filled with pointer to constant string
//
//  Returns:    TRUE if group object is acceptable in scope [pDsScope],
//              FALSE otherwise.
//
//  Modifies:   *[ppwzClass] points to "localGroup" or "globalGroup"
//
//  History:    7-01-1999   davidmun   Created
//
//---------------------------------------------------------------------------

BOOL
WantThisGroup(
    ULONG flDownlevel,
    IADs *pADs,
    PCWSTR *ppwzClass)
{
    ASSERT(flDownlevel & DOWNLEVEL_FILTER_BIT);
    ASSERT(pADs);

    HRESULT hr = S_OK;
    BOOL fWantGroup = FALSE;

    //
    // Get the downlevel filter flags for the current scope.  Also, before
    // entering the loop(s), determine whether it is necessary to check for the
    // group type of returned groups.
    //

    BOOL fWantLocal = (flDownlevel & DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS) ==
            DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS;

    BOOL fWantGlobal = (flDownlevel & DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS) ==
            DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS;

    BOOL fExcludeBuiltin = (flDownlevel &
                            DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS)
                    == DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS;

    GROUP_TYPE  eGroupType = GT_UNKNOWN;

    Variant     varGroupType;

    do
    {
        // Get group type

        hr = pADs->Get((PWSTR)c_wzGroupTypeAttr, &varGroupType);
        BREAK_ON_FAIL_HRESULT(hr);

        if (V_UI4(&varGroupType) & ADS_GROUP_TYPE_DOMAIN_LOCAL_GROUP)
        {
            eGroupType = GT_LOCAL;
        }
        else if (V_UI4(&varGroupType) & ADS_GROUP_TYPE_GLOBAL_GROUP)
        {
            eGroupType = GT_GLOBAL;
        }
        else
        {
            Dbg(DEB_ERROR,
                "Unknown group type value %#x\n",
                V_UI4(&varGroupType));
            break;
        }

        // if excluding builtin local groups, check for that

        if (fExcludeBuiltin && eGroupType == GT_LOCAL)
        {
            Variant varSid;

            hr = pADs->Get((BSTR)c_wzObjectSidAttr, &varSid);
            BREAK_ON_FAIL_HRESULT(hr);

            PSID psid = NULL;

            hr = varSid.SafeArrayAccessData((VOID**)&psid);
            BREAK_ON_FAIL_HRESULT(hr);

            ASSERT(IsValidSid(psid));

            PUCHAR  pcSubAuth = NULL;

            pcSubAuth = GetSidSubAuthorityCount(psid);

            ASSERT(pcSubAuth);

            if (*pcSubAuth == NUM_SUB_AUTHORITES_FOR_BUILTIN_GROUPS)
            {
                break;
            }
        }

        //
        // If we want one type of group but not another, check
        // that.
        //

        ASSERT(fWantLocal || fWantGlobal);

        if (!fWantLocal  && eGroupType == GT_LOCAL ||
            !fWantGlobal && eGroupType == GT_GLOBAL)
        {
            break;
        }

        //
        // Translate from the WinNT provider's group class/
        // type combo to an internal-use-only group class
        // of localgroup or globalgroup.
        //

        if (eGroupType == GT_LOCAL)
        {
            *ppwzClass = c_wzLocalGroupClass;
        }
        else
        {
            ASSERT(eGroupType == GT_GLOBAL);
            *ppwzClass = c_wzGlobalGroupClass;
        }

        fWantGroup = TRUE;
    } while (0);

    return fWantGroup;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_BindForName
//
//  Synopsis:   Attempt to bind to object [strName] in downlevel domain
//              represented by [pDsScope].
//
//  Arguments:  [hwnd]         - parent window, required for binding
//              [rop]          - containing object picker instance
//              [Scope]        - downlevel scope containing object
//              [strName]      - rdn of object
//              [pdsolMatches] - list to which to append new object
//
//  History:    08-16-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDsObject::_BindForName(
    HWND                    hwnd,
    const CObjectPicker    &rop,
    const CScope           &Scope,
    const String           &strName,
    CDsObjectList         *pdsolMatches)
{
    TRACE_METHOD(CDsObject, _BindForName);
    ASSERT(pdsolMatches);
    ASSERT(IsDownlevel(Scope));

    String  strObjectPath;
    Bstr    bstrName;
    Bstr    bstrClass;
    Bstr    bstrPath;
    RpIADsContainer  rpADsContainer;
    RpIDispatch     rpdisp;
    RpIADs  rpADs;
    HRESULT hr = S_OK;

    do
    {
        const CAdsiScope *pAdsiScope = dynamic_cast<const CAdsiScope *>(&Scope);

        if (!pAdsiScope)
        {
            Dbg(DEB_ERROR, "Expected scope to have CAdsiScope base\n");
            break;
        }

        hr = pAdsiScope->GetADsPath(hwnd, &strObjectPath);

        if (FAILED(hr))
        {
            Dbg(DEB_TRACE,
                "Scope '%ws' has no path, returning\n",
                pAdsiScope->GetDisplayName());
            break;
        }

        hr = g_pBinder->BindToObject(hwnd,
                                     strObjectPath.c_str(),
                                     IID_IADsContainer,
                                     (void**) &rpADsContainer);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = rpADsContainer->GetObject(NULL,
                                       (PWSTR) strName.c_str(),
                                       (IDispatch**)&rpdisp);

        if (FAILED(hr))
        {
            Dbg(DEB_ERROR,
                "GetObject(NULL,'%ws') error %#x\n",
                strName.c_str(),
                hr);
            break;
        }

        hr = rpADs.AcquireViaQueryInterface(*(IUnknown*)rpdisp.get(),
                                            IID_IADs);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Check the item's class against what the caller wants.
        //

        hr = rpADs->get_Class(&bstrClass);
        BREAK_ON_FAIL_HRESULT(hr);

        PCWSTR pwzClass = bstrClass.c_str();
        vector<String> vsWinNtFilter;

        const CFilterManager &rfm = rop.GetFilterManager();
        rfm.GetWinNtFilter(hwnd, Scope, &vsWinNtFilter);
        vector<String>::const_iterator itFilter;

        CStringCompare StringCompare(pwzClass);

        itFilter = find_if(vsWinNtFilter.begin(),
                           vsWinNtFilter.end(),
                           StringCompare);

        if (itFilter == vsWinNtFilter.end())
        {
            break;
        }

        ULONG flFilter;

        hr = rfm.GetSelectedFilterFlags(hwnd, Scope, &flFilter);
        BREAK_ON_FAIL_HRESULT(hr);

        if (!lstrcmpi(bstrClass.c_str(), c_wzGroupObjectClass) &&
            !WantThisGroup(flFilter, rpADs.get(), &pwzClass))
        {
            break;
        }

        //
        // Found item and it has allowed class.  Ask it for the rest of
        // the attributes we need.
        //

        hr = rpADs->get_Name(&bstrName);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(bstrName.c_str());

        hr = rpADs->get_ADsPath(&bstrPath);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(bstrPath.c_str());

        SDsObjectInit Init;

        Init.idOwningScope = Scope.GetID();
        Init.pwzName = bstrName.c_str();
        Init.pwzClass = pwzClass;
        Init.pwzADsPath = bstrPath.c_str();
        Init.fDisabled = IsDisabled(rpADs.get());

        pdsolMatches->push_back(CDsObject(Init));
    } while (0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_CustomizerPrefixSearch
//
//  Synopsis:   Ask the customizer to do a prefix
//              search for [strNamePrefix].
//
//  Arguments:  [hwnd]          - for bind
//              [rop]           - containing object picker instance
//              [Scope]         - scope in which to search
//              [strNamePrefix] - start of name to search for
//              [pdsolMatches]  - list to which to append matches
//
//  History:    08-16-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDsObject::_CustomizerPrefixSearch(
    HWND            hwnd,
    const CObjectPicker &rop,
    const CScope   &Scope,
    const String   &strNamePrefix,
    CDsObjectList  *pdsolMatches)
{
    TRACE_METHOD(CDsObject, _CustomizerPrefixSearch);

    IDataObject *pdoToAdd = NULL;
    const CFilterManager &rfm = rop.GetFilterManager();
    ULONG flCurFilterFlags = rfm.GetCurScopeSelectedFilterFlags();
    ICustomizeDsBrowser *pExternalCustomizer = rop.GetExternalCustomizer();

    do
    {
        //
        // First check to see if the selected filter flags include the ones
        // for the internal or external customizer.  If none are set, bail.
        //

        if (!(flCurFilterFlags & DSOP_FILTER_EXTERNAL_CUSTOMIZER) &&
            !(flCurFilterFlags & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS) &&
            !IsDownlevelFlagSet(flCurFilterFlags,
                                ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS))
        {
            break;
        }

        CDsObjectList dsol;

        //
        // If an external customizer is provided, use it
        //

        if (pExternalCustomizer &&
            (flCurFilterFlags & DSOP_FILTER_EXTERNAL_CUSTOMIZER))
        {
            HRESULT hr;
            IDsObjectPickerScope *pDsopScope =
                static_cast<IDsObjectPickerScope *>(const_cast<CScope*>(&Scope));

            hr = pExternalCustomizer->PrefixSearch(pDsopScope,
                                                   strNamePrefix.c_str(),
                                                   &pdoToAdd);

            if (SUCCEEDED(hr) && pdoToAdd)
            {
                const CScopeManager &rsm = rop.GetScopeManager();
                const CScope &rCurScope = rsm.GetCurScope();

                AddFromDataObject(rCurScope.GetID(), pdoToAdd, NULL, 0, &dsol);
            }
        }

        //
        // Assume if the caller set flags that the internal customizer knows
        // about that it should also be used.
        //

        if ((flCurFilterFlags & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS) ||
                 IsDownlevelFlagSet(flCurFilterFlags,
                                    ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS))
        {
            const CAdminCustomizer &ac = rop.GetDefaultCustomizer();

            ac.PrefixSearch(hwnd, Scope, strNamePrefix, &dsol);
        }

        //
        // Move any objects from pdsol which aren't already in pdsolMatches
        // into the latter.
        //

        CDsObjectList::iterator it;

        for (it = dsol.begin(); it != dsol.end(); it++)
        {
            if (find(pdsolMatches->begin(),
                     pdsolMatches->end(),
                     *it) == pdsolMatches->end())
            {
                pdsolMatches->push_back(*it);
            }
        }
    } while (0);

    SAFE_RELEASE(pdoToAdd);
}



//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_BindForComputer
//
//  Synopsis:   Attempt to bind to a computer with name [strName], if
//              successful, add an object representing it to [pdsolMatches]
//
//  Arguments:  [hwnd]         - for bind
//              [rop]          - containing object picker instance
//              [strName]      - name of computer
//              [pdsolMatches] - list to which to append matches
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDsObject::_BindForComputer(
    HWND hwnd,
    const CObjectPicker &rop,
    const String &strName,
    CDsObjectList *pdsolMatches)
{
    TRACE_METHOD(CDsObject, _BindForComputer);

    const CScopeManager &rsm = rop.GetScopeManager();
    const SScopeParameters *pspUserUplevel =
        rsm.GetScopeParams(ST_USER_ENTERED_UPLEVEL_SCOPE);
    const SScopeParameters *pspUserDownlevel =
        rsm.GetScopeParams(ST_USER_ENTERED_DOWNLEVEL_SCOPE);
    const CFilterManager &rfm = rop.GetFilterManager();
    ULONG flCurFilterFlags = rfm.GetCurScopeSelectedFilterFlags();

    do
    {
        // don't try to find computer if user hasn't checked the Computers
        // box

        if (flCurFilterFlags & DOWNLEVEL_FILTER_BIT)
        {
            if (!IsDownlevelFlagSet(flCurFilterFlags,
                                    DSOP_DOWNLEVEL_FILTER_COMPUTERS))
            {
                Dbg(DEB_TRACE, "Cur scope selected filter flags don't contain computer, exiting\n");
                break;
            }
        }
        else if (!(flCurFilterFlags & DSOP_FILTER_COMPUTERS))
        {
            Dbg(DEB_TRACE, "Cur scope selected filter flags don't contain computer, exiting\n");
            break;
        }

        ULONG flUplevel = 0;

        if (pspUserUplevel)
        {
            flUplevel = pspUserUplevel->FilterFlags.Uplevel.flBothModes
                | pspUserUplevel->FilterFlags.Uplevel.flNativeModeOnly
                | pspUserUplevel->FilterFlags.Uplevel.flMixedModeOnly;
        }

        ULONG flDownlevel = 0;

        if (pspUserDownlevel)
        {
            flDownlevel = pspUserDownlevel->FilterFlags.flDownlevel;
        }

        if (!(flUplevel & DSOP_FILTER_COMPUTERS) &&
            !((flDownlevel & DSOP_DOWNLEVEL_FILTER_COMPUTERS) ==
             DSOP_DOWNLEVEL_FILTER_COMPUTERS))
        {
            break;
        }

        BOOL fFound = FALSE;

        if (!pdsolMatches->empty())
        {
            CDsObjectList::iterator it = pdsolMatches->begin();

            do
            {
                it = find(it, pdsolMatches->end(), strName);

                if (it != pdsolMatches->end())
                {
                    //
                    // name matches.  if class is computer, we've found
                    // it already, so don't continue with attempt to bind.
                    //

                    if (!lstrcmpi(it->GetClass(), c_wzComputerObjectClass))
                    {
                        fFound = TRUE;
                        break;
                    }
                    it++;
                }
            } while (!fFound && it != pdsolMatches->end());

            if (fFound)
            {
                Dbg(DEB_TRACE,
                    "Found computer %ws in matches, no need to bind for it\n",
                    strName.c_str());
                break;
            }
        }

        //
        // No computer object with matching name in pdsolMatches.  If the
        // computer name looks legal, try to bind.
        //

        if (strName.find_first_of(String(c_wzIllegalComputerNameChars)) !=
            String::npos)
        {
            Dbg(DEB_TRACE,
                "Name contains illegal character(s), not attempting to bind\n");
            break;
        }

        String strADsPath = c_wzWinNTPrefix;
        strADsPath += strName;
        strADsPath += L",Computer";

        RpIADs rpADs;

        Dbg(DEB_TRACE, "Attempting to bind to computer object\n");

        HRESULT hr = g_pBinder->BindToObject(hwnd,
                                             strADsPath.c_str(),
                                             IID_IADs,
                                             (void **)&rpADs);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // OK, we bound to the computer, so it exists.  We'll take the
        // easy way out here and instead of figuring out all the info
        // about the domain or workgroup to which the computer belongs,
        // just create a hidden scope with no name or address.
        //
        // Note this means you can enter a computer name which is
        // in a domain in the forest (but not yet propagated to GC, or
        // GC unavailable), or in some external trusted domain, which is
        // not represented by the current scope at the time the name was
        // entered, but is nevertheless represented by some other scope,
        // and the computer object will be returned with a scope type
        // of DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE or
        // DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE instead of the
        // scope type of its "real" owner.
        //

        ADD_SCOPE_INFO  asi;

        if (flUplevel & DSOP_FILTER_COMPUTERS)
        {
            asi.flType = DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE;
            asi.FilterFlags = pspUserUplevel->FilterFlags;
        }
        else
        {
            asi.flType = DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
            asi.FilterFlags = pspUserDownlevel->FilterFlags;
        }

        asi.Visibility = SCOPE_HIDDEN;

        const CScope &rNewScope = rsm.AddUserEnteredScope(asi);

        CDsObject dsoComputer(rNewScope.GetID(), rpADs.get());
        pdsolMatches->push_back(dsoComputer);

    } while (0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_FetchAttributes
//
//  Synopsis:   Attempt to read for this object the attributes caller
//              requested be returned on all selected objects.
//
//  Arguments:  [hwnd] - for bind
//              [rop]  - containing object picker instance
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      Object Picker does not guarantee to its callers that it
//              will successfully fetch any attributes.
//
//---------------------------------------------------------------------------

HRESULT
CDsObject::_FetchAttributes(
    HWND hwnd,
    const CObjectPicker &rop)
{
    TRACE_METHOD(CDsObject, _FetchAttributes);

    HRESULT hr = S_OK;
    const BSTR wzName = GetName();
    const BSTR wzClass = GetClass();
    const BSTR wzADsPath = GetADsPath();

    do
    {
        //
        // If we've already been here, bail.
        //

        if (_IsFlagSet(DSO_FLAG_FETCHED_ATTRIBUTES))
        {
            Dbg(DEB_TRACE,
                "object %ws has already fetched attributes\n",
                wzName);
            break;
        }

        //
        // See if there are any attributes to fetch.  If not, bail.
        //

        const vector<String> &rvAttrToFetch = rop.GetAttrToFetchVector();

        if (rvAttrToFetch.empty())
        {
            break;
        }

        //
        // If this object has a path, bind to it for IADs and use that
        // to read the attributes.
        //

        if (*wzADsPath)
        {
            RpIADs rpADs;

            //
            // Iterate through the attribute names, fetching each.
            //

            Dbg(DEB_TRACE, "fetching attributes for object %ws\n", wzName);

            vector<String>::const_iterator itAttrName;

            for (itAttrName = rvAttrToFetch.begin(); itAttrName != rvAttrToFetch.end(); itAttrName++)
            {
                HRESULT hr2;

                BOOL fIsGroupTypeAttr = !itAttrName->icompare(c_wzGroupTypeAttr);
                Variant varFetched;

                if (fIsGroupTypeAttr &&
                    !lstrcmpi(wzClass, c_wzLocalGroupClass))
                {
                    varFetched.SetUI4(ADS_GROUP_TYPE_DOMAIN_LOCAL_GROUP);
                }
                else if (fIsGroupTypeAttr &&
                         !lstrcmpi(wzClass, c_wzGlobalGroupClass))
                {
                    varFetched.SetUI4(ADS_GROUP_TYPE_GLOBAL_GROUP);
                }
                else
                {
                    //
                    // If we haven't bound to the object yet, do so.  If this
                    // fails, exit the loop since we won't be able to get
                    // any attributes from ADSI without the interface.
                    //

                    if (!rpADs.get())
                    {
                        hr = g_pBinder->BindToObject(hwnd,
                                                     wzADsPath,
                                                     IID_IADs,
                                                     (void**) &rpADs);
                        BREAK_ON_FAIL_HRESULT(hr);
                    }

                    hr2 = rpADs->Get(const_cast<PWSTR>(itAttrName->c_str()),
                                     &varFetched);

                    if (FAILED(hr2))
                    {

                        // this is pretty noisy and not necessarily an error
                        Dbg(DEB_WARN,
                            "Err %#x fetching attribute '%ws' on '%ws'\n",
                            hr2,
                            itAttrName->c_str(),
                            wzName);

                        hr = hr2;
                        ASSERT(varFetched.Empty());
                    }
                }

                //
                // If we couldn't get this attribute, go on to the next one
                // to fetch.
                //

                if (varFetched.Empty())
                {
                    continue;
                }

                //
                // The attribute value is now in varFetched, put its value in
                // m_AttrValueMap.  To do this we have to get the ATTR_KEY that
                // corresponds to the attribute's ADSI name in itAttrName.
                //

                const CAttributeManager &ram = rop.GetAttributeManager();
                ATTR_KEY ak = ram.GetAttrKey(*itAttrName);
                m_AttrValueMap[ak] = varFetched;
            }
            break;
        }

        //
        // This object doesn't have a path.  It probably doesn't really
        // exist in the DS and was added by CustomizeDsBrowser interface.
        // If caller wants objectSid or groupType attribute, fabricate
        // a variant with the property.
        //

        const CAdminCustomizer &rac = rop.GetDefaultCustomizer();
        PSID psid = rac.LookupDownlevelName(wzName);
        vector<String>::const_iterator it;

        for (it = rvAttrToFetch.begin(); it != rvAttrToFetch.end(); it++)
        {
            if (!it->icompare(c_wzObjectSidAttr))
            {
                Variant varSid;

                hr = _CreateSidVariant(psid, &varSid);
                BREAK_ON_FAIL_HRESULT(hr);

                m_AttrValueMap[AK_OBJECT_SID] = varSid;
            }
            else if (!it->icompare(c_wzGroupTypeAttr))
            {
                Variant varGroupType;

                if (!lstrcmpi(wzClass, c_wzLocalGroupClass))
                {
                    varGroupType.SetUI4(ADS_GROUP_TYPE_DOMAIN_LOCAL_GROUP);
                }
                else if (!lstrcmpi(wzClass, c_wzGlobalGroupClass))
                {
                    varGroupType.SetUI4(ADS_GROUP_TYPE_GLOBAL_GROUP);
                }
                m_AttrValueMap[AK_GROUP_TYPE] = varGroupType;
            }
        }
    } while (0);

    _SetFlag(DSO_FLAG_FETCHED_ATTRIBUTES);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_CreateSidVariant
//
//  Synopsis:   Fill variant pointed to by [pvar] with the array of bytes
//              contained in the SID pointed to by [psid].
//
//  Arguments:  [psid] - points to SID to copy
//              [pvar] - points to variant to fill with copy
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDsObject::_CreateSidVariant(
    PSID psid,
    VARIANT *pvar)
{
    HRESULT hr = S_OK;
    PUCHAR pcSubAuth = NULL;
    ULONG cbSid = 0;
    SAFEARRAYBOUND sabound;
    SAFEARRAY *psa = NULL;
    ULONG i;
    PVOID pvData = NULL;
    PULONG pulSubAuth = NULL;

    ASSERT(psid);

    if (!psid)
    {
        return E_POINTER;
    }

    ASSERT(IsValidSid(psid));
    ASSERT(V_VT(pvar) == VT_EMPTY);

    do
    {
        pcSubAuth = GetSidSubAuthorityCount(psid);

        ASSERT(pcSubAuth);

        cbSid = GetSidLengthRequired(*pcSubAuth);

        ASSERT(cbSid == (*pcSubAuth - 1) * (sizeof(DWORD)) + sizeof(SID));

        sabound.cElements = cbSid;
        sabound.lLbound = 0;

        psa = SafeArrayCreate(VT_UI1, 1, &sabound);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = SafeArrayAccessData(psa, &pvData);
        BREAK_ON_FAIL_HRESULT(hr);

        pulSubAuth = (LPDWORD)pvData;

        SID sid;

        ZeroMemory(&sid, sizeof sid);

        sid.Revision = SID_REVISION;
        sid.SubAuthorityCount = *pcSubAuth;
        sid.IdentifierAuthority = *GetSidIdentifierAuthority(psid);

        CopyMemory(pvData, &sid, sizeof(SID));

        pulSubAuth = (PULONG)((PBYTE)pvData + sizeof(SID) - sizeof(ULONG));

        for (i = 0; i < *pcSubAuth; i++)
        {
            *pulSubAuth++ = *GetSidSubAuthority(psid, i);
        }

        ASSERT(IsValidSid((PSID)pvData));

        SafeArrayUnaccessData(psa);

        pvar->vt = VT_ARRAY | VT_UI1;
        pvar->parray = psa;
    } while (0);

    return hr;
}


#define DSOP_ACCEPTABLE_PROVIDER_SCOPE_FLAGS    \
    (DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT        \
    | DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP)

//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_ConvertProvider
//
//  Synopsis:   Convert the path of this object as necessary to make it
//              use one of the acceptable providers for its owning scope.
//
//  Arguments:  [hwnd] - for bind
//              [rop]  - containing object picker instance
//              [pnpr] - filled with result of processing
//
//  Returns:    HRESULT
//
//  History:    08-18-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDsObject::_ConvertProvider(
    HWND hwnd,
    const CObjectPicker &rop,
    NAME_PROCESS_RESULT *pnpr)
{
    TRACE_METHOD(CDsObject, _ConvertProvider);

    HRESULT hr = S_OK;

    do
    {
        if (_IsFlagSet(DSO_FLAG_CONVERTED_PROVIDER))
        {
            break;
        }

        //
        // Some special objects don't have paths.  If the scope flag
        // DSOP_SCOPE_FLAG_WANT_DOWNLEVEL_SID_PATH is set, create one based on
        // the object's sid, otherwise leave it empty.
        //

        const CScopeManager &sm = rop.GetScopeManager();
        const CScope &rOwningScope = sm.LookupScopeById(GetOwningScopeID());
        ASSERT(rOwningScope.Type() != ST_INVALID);

        if (!*GetADsPath())
        {
            //
            // see if the scope params for the scope in which this
            // object resides indicate we should generate a path
            //

            if (rOwningScope.GetScopeFlags() &
                DSOP_SCOPE_FLAG_WANT_DOWNLEVEL_BUILTIN_PATH)
            {
                hr = _CreateDownlevelSidPath(rop);
            }
            break;
        }

        //
        // Force conversion of this object to LDAP://<SID=x> format if
        // objects in the owning scope are to be converted and this
        // object has an objectSid attribute.
        //

        if (rOwningScope.GetScopeFlags() & DSOP_SCOPE_FLAG_WANT_SID_PATH)
        {
            hr = _CreateUplevelSidPath(hwnd);
            break;
        }

        //
        // Compare the provider used by this object against the ones
        // allowed by its owning scope.  If it's already in an acceptable
        // form, no conversion is required.
        //

        ULONG flThisProvider;

        hr = ProviderFlagFromPath(GetADsPath(), &flThisProvider);
        BREAK_ON_FAIL_HRESULT(hr);

        ULONG flAcceptableProviders =
            rOwningScope.GetScopeFlags() & DSOP_ACCEPTABLE_PROVIDER_SCOPE_FLAGS;

        if (!flAcceptableProviders ||
            (flThisProvider & flAcceptableProviders))
        {
            break;
        }

        //
        // Path is using unacceptable provider.
        //

        //
        // If the acceptable provider list includes LDAP and the
        // path is based on GC, use IADsPathname to make the change.
        //

        if ((flAcceptableProviders & DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP) &&
            (flThisProvider & PROVIDER_GC))
        {
            String strPath = GetADsPath();
            hr = g_pADsPath->ConvertProvider(&strPath, L"LDAP");

            if (SUCCEEDED(hr))
            {
                Variant varPath;

                hr = varPath.SetBstr(strPath);
                BREAK_ON_FAIL_HRESULT(hr);

                m_AttrValueMap[AK_PROCESSED_ADSPATH] = varPath;
            }
            break;
        }

        //
        // If the acceptable provider list includes WinNT, use
        // IADsNameTranslate to convert.
        //

        if (flAcceptableProviders & PROVIDER_WINNT)
        {
            ASSERT((flThisProvider & PROVIDER_GC) ||
                   (flThisProvider & DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP));
            ASSERT(IsUplevel(rOwningScope));

            RpIADsNameTranslate rpADsNameTranslate;
            Bstr bstrMyDN;

            if (rOwningScope.Type() == ST_INVALID)
            {
                hr = E_UNEXPECTED;
                DBG_OUT_HRESULT(hr);
                break;
            }

            const CLdapContainerScope *pOwningLdapScope =
                dynamic_cast<const CLdapContainerScope *>(&rOwningScope);

            ASSERT(pOwningLdapScope);
            if (!pOwningLdapScope)
            {
                hr = E_UNEXPECTED;
                DBG_OUT_HRESULT(hr);
                break;
            }

            String strADsPath;

            hr = pOwningLdapScope->GetADsPath(hwnd, &strADsPath);
            BREAK_ON_FAIL_HRESULT(hr);

            {
                IADsNameTranslate *pNameTranslate = NULL;
                hr = g_pBinder->GetNameTranslate(hwnd,
                                                 strADsPath.c_str(),
                                                 &pNameTranslate);
                BREAK_ON_FAIL_HRESULT(hr);
                rpADsNameTranslate.Acquire(pNameTranslate);
            }

            hr = g_pADsPath->SetRetrieve(ADS_SETTYPE_FULL,
                                         GetADsPath(),
                                         ADS_FORMAT_X500_DN,
                                         &bstrMyDN);

            hr = rpADsNameTranslate->Set(ADS_NAME_TYPE_1779, bstrMyDN.c_str());
            BREAK_ON_FAIL_HRESULT(hr);

            Bstr bstrNT4;

            hr = rpADsNameTranslate->Get(ADS_NAME_TYPE_NT4, &bstrNT4);
            BREAK_ON_FAIL_HRESULT(hr);

            PWSTR pwzWhack = wcschr(bstrNT4.c_str(), L'\\');

            if (pwzWhack)
            {
                *pwzWhack = L'/';
            }
            else
            {
                Dbg(DEB_WARN, "Expected backslash in nt4 name '%s'\n", bstrNT4);
            }

            String strProcessedADsPath = c_wzWinNTPrefix;
            strProcessedADsPath += bstrNT4.c_str();
            Variant var;

            hr = var.SetBstr(strProcessedADsPath);
            BREAK_ON_FAIL_HRESULT(hr);

            m_AttrValueMap[AK_PROCESSED_ADSPATH] = var;
            m_AttrValueMap.erase(AK_DISPLAY_PATH);
            break;
        }

        //
        // If we're still here then the conversion hasn't happened yet.
        // There's one last permutation: the acceptable provider list
        // includes LDAP, but the current object is using WINNT.  The
        // only way to convert is if the object has an objectSid attribute.
        //

        if ((flAcceptableProviders & DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP) &&
            (flThisProvider & PROVIDER_WINNT))
        {
            hr = _CreateUplevelSidPath(hwnd);
        }
        else
        {
            Dbg(DEB_ERROR,
                "Unexpected combination: flPathProvider 0x%x, flAcceptableProviders 0x%x\n",
                flThisProvider,
                flAcceptableProviders);
            hr = E_FAIL;
        }
    } while (0);

    if (FAILED(hr))
    {
        *pnpr = NPR_STOP_PROCESSING;
    }
    else
    {
        _SetFlag(DSO_FLAG_CONVERTED_PROVIDER);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_CreateUplevelSidPath
//
//  Synopsis:   Convert this object's path to the form LDAP://<sid=x> where
//              x is the string of hex digits (no spaces) that make up the
//              objectSid attribute value.
//
//  Arguments:  [hwnd] - for bind
//
//  Returns:    HRESULT
//
//  History:    08-18-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDsObject::_CreateUplevelSidPath(
    HWND hwnd)
{
    HRESULT hr = S_OK;
    RpIADs  rpADs;
    Variant varSid;
    PSID    psid = NULL;
    BOOL    fAccessedData = FALSE;

    do
    {
        if (!*GetADsPath())
        {
            break;
        }

        hr = g_pBinder->BindToObject(hwnd,
                                     GetADsPath(),
                                     IID_IADs,
                                     (void**)&rpADs);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = rpADs->Get((PWSTR)c_wzObjectSidAttr, &varSid);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(varSid.Type() == (VT_ARRAY | VT_UI1));

        hr = SafeArrayAccessData(V_ARRAY(&varSid), (VOID**)&psid);
        BREAK_ON_FAIL_HRESULT(hr);

        fAccessedData = TRUE;

        ASSERT(IsValidSid(psid));

        String strPath = c_wzLDAPPrefix;

        strPath += c_wzSidPathPrefix;

        //
        // Convert the bytes of the sid to hex chars.
        //

        PBYTE  pbSid = (PBYTE) psid;
        ULONG  i;
        PUCHAR  pcSubAuth = NULL;

        pcSubAuth = GetSidSubAuthorityCount(psid);

        ASSERT(pcSubAuth);

        ULONG   cbSid = GetSidLengthRequired(*pcSubAuth);

        ASSERT(cbSid);
        ASSERT(cbSid == (*pcSubAuth - 1) * (sizeof(DWORD)) + sizeof(SID));

        for (i = 0; i < cbSid; i++)
        {
            WCHAR wzCur[3];

            wsprintf(wzCur, L"%02x", *pbSid);
            pbSid++;

            strPath += wzCur;
        }

        strPath += c_wzSidPathSuffix;
        Variant var;

        hr = var.SetBstr(strPath);
        BREAK_ON_FAIL_HRESULT(hr);

        m_AttrValueMap[AK_PROCESSED_ADSPATH] = var;
    } while (0);

    if (fAccessedData)
    {
        SafeArrayUnaccessData(V_ARRAY(&varSid));
    }
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_CreateDownlevelSidPath
//
//  Synopsis:   Create a path in the form WinNT://NT AUTHORITY/Interactive
//
//  Arguments:  [rop] - containing object picker instance
//
//  Returns:    HRESULT
//
//  History:    07-21-1999   davidmun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDsObject::_CreateDownlevelSidPath(
    const CObjectPicker &rop)
{
    TRACE_METHOD(CDsObject, _CreateDownlevelSidPath);

    HRESULT hr = S_OK;

    do
    {
        const CAdminCustomizer &rac = rop.GetDefaultCustomizer();

        PCWSTR pwzPath = rac.LookupDownlevelPath(GetName());

        if (!pwzPath)
        {
            hr = E_FAIL;
            Dbg(DEB_WARN,
                "AdminCustomizer gave no path for %ws\n",
                GetName());
            break;
        }

        Variant var;

        hr = var.SetBstr(pwzPath);
        BREAK_ON_FAIL_HRESULT(hr);

        m_AttrValueMap[AK_PROCESSED_ADSPATH] = var;
        _SetFlag(DSO_FLAG_HAS_DOWNLEVEL_SID_PATH);
    } while (0);

    return hr;
}





//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_MultiMatchDialog
//
//  Synopsis:   Invoke the multi-match dialog so the user can select which
//              of the multiple hits from the prefix search of the name
//              they entered they want to keep.
//
//  Arguments:  [hwnd]         - parent window
//              [rop]          - containing object picker instance
//              [fMultiselect] - if FALSE user forced to pick only one match
//              [strName] -      string for which multiple matches were found.        
//              [pnpr]         - filled with result of processing
//              [pdsolMatches] - on input, contains all matches.  on output
//                                with hr==S_OK, contains exactly one.
//              [pdsolExtras]  - on output, matches 2..n have been appended.
//
//  Returns:    S_OK
//              E_*
//
//  Modifies:   *[pdsolMatches], *[pdsolExtras]
//
//  History:    08-18-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDsObject::_MultiMatchDialog(
    HWND hwnd,
    const CObjectPicker &rop,
    BOOL fMultiselect,
    const String & strName,
    NAME_PROCESS_RESULT *pnpr,
    CDsObjectList *pdsolMatches,
    CDsObjectList *pdsolExtras)
{
    TRACE_METHOD(CDsObject, _MultiMatchDialog);
    ASSERT(IsUnprocessedUserEntry());
    
    CMultiDlg   MultiMatchDlg(rop, strName);

    HRESULT hr;

    hr = MultiMatchDlg.DoModalDialog(hwnd,
                                     fMultiselect,
                                     pnpr,
                                     pdsolMatches);

    if (FAILED(hr) || *pnpr != NPR_SUCCESS)
    {
        return hr;
    }

    ASSERT(!pdsolMatches->empty());

    if (pdsolMatches->size() > 1)
    {
        CDsObjectList::iterator start = pdsolMatches->begin();
        start++;

        pdsolExtras->splice(pdsolExtras->end(),
                            *pdsolMatches,
                            start,
                            pdsolMatches->end());
    }
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_InitDisplayPath
//
//  Synopsis:   Return the canonical path to the container of this object.
//
//  Returns:    Pointer to display path string, L"" on failure.
//
//  History:    07-21-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDsObject::_InitDisplayPath() const
{
    HRESULT hr = S_OK;

    do
    {
        //
        // Certain custom objects may not have paths. Skip those.
        //

        if (GetAttr(AK_ADSPATH).Empty())
        {
            break;
        }

        //
        // Well-known security principals' display paths are blank, even
        // though they are real objects with valid ADsPaths.
        //

        if (!lstrcmpi(GetAttr(AK_OBJECT_CLASS).GetBstr(),
                      c_wzForeignPrincipalsClass))
        {
            break;
        }

        //
        // Need to construct a display path, start with the ads path.  Note
        // we don't want AK_PROCESSED_ADSPATH because that may be something
        // ugly like a SID path.
        //

        String strDisplayPath = GetAttr(AK_ADSPATH).GetBstr();

        BOOL fWinNTPath = !_wcsnicmp(strDisplayPath.c_str(),
                                    c_wzWinNTPrefix,
                                    ARRAYLEN(c_wzWinNTPrefix) - 1);

        //
        // If the path uses the WinNT provider, it is of the form
        // WinNT://domain/object or WinNT://domain/machine/object
        // which is displayed as "domain" or "machine".
        //

        if (fWinNTPath)
        {
            strDisplayPath.erase(0, ARRAYLEN(c_wzWinNTPrefix) - 1);

            // domain/object or domain/machine/object

            size_t idxSlash1 = strDisplayPath.find(L'/');

            ASSERT(idxSlash1 != String::npos);

            size_t idxSlash2 = strDisplayPath.find(L'/', idxSlash1 + 1);

            if (idxSlash2 == String::npos)
            {
                // domain/object

                strDisplayPath.erase(idxSlash1);

                // domain
            }
            else
            {
                // domain/machine/object

                strDisplayPath.erase(idxSlash2);

                // domain/machine

                strDisplayPath.erase(0, idxSlash1 + 1);

                // machine
            }
            m_AttrValueMap[AK_DISPLAY_PATH].SetBstr(strDisplayPath.c_str());
            break;
        }

        //
        // It's not a WinNT provider based path.  Convert container path
        // from 1779 to canonical, or a close approximation.  This is for
        // display only, it will never be passed to name translate.
        //

        CPathWrapLock   lock(g_pADsPath);

        hr = g_pADsPath->Set(strDisplayPath.c_str(), ADS_SETTYPE_FULL);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = g_pADsPath->RemoveLeafElement();
        BREAK_ON_FAIL_HRESULT(hr);

        long cElem;

        hr = g_pADsPath->GetNumElements(&cElem);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(cElem > 0);

        long i;
        strDisplayPath = L"";

        for (i = cElem - 1; i >= 0; i--)
        {
            Bstr bstrElem;

            hr = g_pADsPath->GetElement(i, &bstrElem);
            BREAK_ON_FAIL_HRESULT(hr);

            String strElem(bstrElem.c_str());
            strElem.replace(L"\\\\", L"\\");  // undo escaping

            size_t idxEqual = strElem.find(L'=', 0);

            ASSERT(idxEqual != String::npos);

            if (!lstrcmpi(strElem.substr(0, idxEqual).c_str(), L"DC"))
            {
                if (strDisplayPath.empty())
                {
                    strDisplayPath = strElem.substr(idxEqual + 1,
                                                    String::npos);
                }
                else
                {
                    strDisplayPath.insert(0, L".");
                    strDisplayPath.insert(0, strElem.substr(idxEqual + 1,
                                                            String::npos));
                }
            }
            else
            {
                ASSERT(!strDisplayPath.empty());

                strDisplayPath += L"/";
                strDisplayPath += strElem.substr(idxEqual + 1, String::npos);
            }
        }
        BREAK_ON_FAIL_HRESULT(hr);

        m_AttrValueMap[AK_DISPLAY_PATH].SetBstr(strDisplayPath.c_str());
    } while (0);

    if (FAILED(hr))
    {
        m_AttrValueMap[AK_DISPLAY_PATH].SetBstr(L"");
    }
}


//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::GetAttr
//
//  Synopsis:   Return attribute with name [strAdsiName].
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const Variant &
CDsObject::GetAttr(
    const String &strAdsiName,
    const CObjectPicker &rop) const
{
    return GetAttr(rop.GetAttributeManager().GetAttrKey(strAdsiName));
}



//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::GetAttr
//
//  Synopsis:   Return attribute having key [ak].
//
//  Arguments:  [ak] - ATTR_KEY value representing attribute
//
//  Returns:    Reference to variant containing attribute, or to empty
//              variant if this doesn't contain the requested attribute.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const Variant &
CDsObject::GetAttr(
    ATTR_KEY ak) const
{
    AttrValueMap::const_iterator it;

    if (ak == AK_DISPLAY_PATH)
    {
        _InitDisplayPath();
    }

    it = m_AttrValueMap.find(ak);

    if (it == m_AttrValueMap.end())
    {
        return s_varEmpty;
    }

    return it->second;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::GetMarshalSize
//
//  Synopsis:   Get the size required to put this into a block of data for
//              a data object which is to be returned to caller.
//
//  Returns:    Size in bytes needed to marshal this (not counting fetched
//              attributes, which are stored separately).
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CDsObject::GetMarshalSize() const
{
    ULONG cch;

    BSTR bstrName = GetName();
    BSTR bstrADsPath = GetAttr(AK_PROCESSED_ADSPATH).GetBstr();
    if (!*bstrADsPath)
    {
       bstrADsPath = GetADsPath();
    }
    BSTR bstrClass = GetClass();
    BSTR bstrUpn = GetUpn();

    if (!lstrcmpi(bstrClass, c_wzLocalGroupClass) ||
        !lstrcmpi(bstrClass, c_wzGlobalGroupClass))
    {
        cch = lstrlen(bstrName) + 1 +
              lstrlen(c_wzGroupObjectClass) + 1 +
              lstrlen(bstrADsPath) + 1 +
              lstrlen(bstrUpn) + 1;
    }
    else
    {
        cch = lstrlen(bstrName) + 1 +
              lstrlen(bstrClass) + 1 +
              lstrlen(bstrADsPath) + 1 +
              lstrlen(bstrUpn) + 1;
    }

    return cch * sizeof(WCHAR);
}

void AddDollarToNameToCrack(IN DS_NAME_FORMAT FormatOffered,
								  String &strNameToCrack)
{
	if(FormatOffered == DS_USER_PRINCIPAL_NAME)
	{
		//
		//Find the rightmost @
		//
		size_t idxLastAt = strNameToCrack.rfind(L'@');   
		if (idxLastAt != String::npos)
		{
			strNameToCrack.insert(idxLastAt,L"$");
		}
	}
	else if(FormatOffered == DS_NT4_ACCOUNT_NAME)
	{
		strNameToCrack.append(L"$");
	}
}


//+----------------------------------------------------------------------------
//
//  Function:   CrackName
//
//  Synopsis:   Given an object name, returns the DnsDomainName of the Domain in
//              which it resides. If bCrackInExtForest is true, tries to chase to
//              the "DS_NAME_ERROR_TRUST_REFERRAL" referral.
//  ARGUMENTS
//              [IN hwnd]       Handle to owning window
//              [IN pwzNameIn]  Name to crack           
//              [IN FormatOffered] Format of pwzNameIn. It can be DS_USER_PRINCIPAL_NAME,
//                                 DS_NT4_ACCOUNT_NAME, or DS_UNKNOWN_NAME
//              [IN pwzDomainName]  Domain Name from where to start crack
//              [IN bCrackInExtForest] If to follow the DS_NAME_ERROR_TRUST_REFERRAL
//              [in ppwzResultName]     Output dnsDomainName. This value can be Null
//                                      even if function returns S_OK if 
//                                      bCrackInExtForest is FALSE and object existin
//                                      other forest.
//              [pbExtForest]           True if object exist trusted forest
// Return Value:    S_OK if succeeds. Else DSCrackError or E_FAIL 
//-----------------------------------------------------------------------------
HRESULT
CrackName(IN HWND hwnd, 
          IN LPWSTR pwzNameIn,           
          IN DS_NAME_FORMAT FormatOffered,
          IN LPWSTR pwzDomainName,
          IN BOOL bCrackInExtForest,
          OUT LPWSTR * ppwzResultName, 
          OUT PBOOL pbExtForest,
		  OUT PBOOL pbAddDollar)
{
    TRACE_FUNCTION(Entering CrackName);

    if(!pwzNameIn || 
	   !pwzDomainName || 
	   !ppwzResultName || 
	   !pbExtForest || 
	   !pbAddDollar)
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    Dbg(DEB_TRACE,
        "Name to crack'%ws' Starting Domain '%ws' \n",
        pwzNameIn,
        pwzDomainName);

    HRESULT hr = S_OK;    
    HANDLE hDS = (HANDLE)-1;
    DWORD dwErr = 0;
    PDS_NAME_RESULTW pDsNameResult = NULL;
    BOOL fLoopAgain = FALSE; 
    DS_NAME_FORMAT FormatRequested = DS_CANONICAL_NAME;

	//
	//First Crack Name is at GC 
	//
	DWORD BindToDcFlag = OP_GC_SERVER_REQUIRED;

    //
    //Init strDomain. strDomain contains the domain name at which to try 
    //the next DsCrackName.
    //
    String strDomain = pwzDomainName;
    *pbExtForest = FALSE;

	String strNameToCrack = pwzNameIn;

	//
	//If CrackName at GC returns TRUST_REFERRAL and CrackName at referral returns
	//NO_MAPPING error try by adding a $ to the objectname.
	// NTRAID#NTBUG9-401249-2001/05/21-hiteshr
	//
	BOOL bTriedWithDollar = FALSE;
	*pbAddDollar = FALSE;
    
    do
    {
        //
        // Get a DC name for the domain and bind to it.
        //
        Dbg(DEB_TRACE,
            "Trying to do dsbind to '%ws' \n",
            strDomain.c_str());
        hr = g_pBinder->BindToDcInDomain(hwnd,
                                         strDomain.c_str(),
										 BindToDcFlag,
                                         &hDS
										 );
        BREAK_ON_FAIL_HRESULT(hr);

		//
		//We don't need GC for other calls
		//
		BindToDcFlag &= ~OP_GC_SERVER_REQUIRED;

        //
        // Convert the object name.
        //
        Dbg(DEB_TRACE,
            "Calling DsCrackNamesW \n");
		LPCWSTR pwzNameToCrack = strNameToCrack.c_str();
        dwErr = DsCrackNamesW(hDS, 
                              DS_NAME_FLAG_TRUST_REFERRAL, 
                              FormatOffered,
                              FormatRequested, 
                              1, 
                              &pwzNameToCrack, 
                              &pDsNameResult);

        if(dwErr != ERROR_SUCCESS)
		{
			hr = HRESULT_FROM_WIN32(dwErr);
            BREAK_ON_FAIL_HRESULT(hr);
		}

        ASSERT(pDsNameResult);
        ASSERT(pDsNameResult->cItems == 1);

        switch (pDsNameResult->rItems->status)
        {
            //
            // The object info is in another domain. But we only 
            // need the DNS domain name. So we don't need to loop again.
            //            
            case DS_NAME_ERROR_DOMAIN_ONLY:
            {
                Dbg(DEB_TRACE,
                    "DsCrackNamesW Status is DS_NAME_ERROR_DOMAIN_ONLY.\n DnsDomain name is '%ws'",
                    pDsNameResult->rItems->pDomain);
    
                hr = LocalAllocString(ppwzResultName,pDsNameResult->rItems->pDomain);
                DsFreeNameResultW(pDsNameResult);
                pDsNameResult = NULL;
                fLoopAgain = FALSE;  
            }          
            break;

            //
            // The object info is in another FOREST
            // Try dscrackname again
            //           
            case DS_NAME_ERROR_TRUST_REFERRAL:
            {
                Dbg(DEB_TRACE,
                    "DsCrackNamesW Status is DS_NAME_ERROR_TRUST_REFERRAL.\n DnsDomainname returned is '%ws'",
                    pDsNameResult->rItems->pDomain);

                if(bCrackInExtForest)
                {                
                    strDomain = pDsNameResult->rItems->pDomain;
                    fLoopAgain = TRUE;
                }
                else
                {
                //
                //if bCrackInExtForest is false, we don't try to crack and
                //*ppwzResultName is NULL. Return is S_OK.
                //
                    fLoopAgain = FALSE;
                }

                DsFreeNameResultW(pDsNameResult);
                pDsNameResult = NULL;                
                *pbExtForest = TRUE;
            }
            break;
            case DS_NAME_NO_ERROR:
            {
                //
                // Success!
                //
                Dbg(DEB_TRACE,
                "DsCrackNamesW Status is DS_NAME_NO_ERROR.\n DnsDomainname returned is '%ws'",
                pDsNameResult->rItems->pDomain);

                hr = LocalAllocString(ppwzResultName,pDsNameResult->rItems->pDomain);
                DsFreeNameResultW(pDsNameResult);
                pDsNameResult = NULL;
                fLoopAgain = FALSE;
				if(bTriedWithDollar)
					*pbAddDollar = TRUE;
            }
            break;

            case DS_NAME_ERROR_RESOLVING:
            case DS_NAME_ERROR_NOT_FOUND:
            case DS_NAME_ERROR_NO_MAPPING:
            {

				if(*pbExtForest && !bTriedWithDollar)
				{
					bTriedWithDollar = TRUE;
					AddDollarToNameToCrack(FormatOffered, strNameToCrack);
					Dbg(DEB_TRACE,"DsCrackNamesW Status is DS_NAME_ERROR_NO_MAPPING.\n Trying to crack with $ sign added\n");
					fLoopAgain = TRUE;
				}
				else
				{
					Dbg(DEB_TRACE,
					"DsCrackNamesW Status is DS_NAME_ERROR_NO_MAPPING.\n");
					if(!fLoopAgain)					
						hr = E_FAIL;
					fLoopAgain = FALSE;
				}
            }
            break;

            default:
            {
                fLoopAgain = FALSE;
                hr = E_FAIL;
            }
            break;
        }

    }while (fLoopAgain);


    if (pDsNameResult)
    {
        DsFreeNameResultW(pDsNameResult);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\edso.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       edso.cxx
//
//  Contents:   Implementation of class to support interfaces required to
//              embed a CDsObject in a rich edit control.
//
//  Classes:    CEmbeddedDsObject
//
//  History:    5-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

DEBUG_DECLARE_INSTANCE_COUNTER(CEmbeddedDsObject)

//+--------------------------------------------------------------------------
//
//  Member:     CEmbeddedDsObject::CEmbeddedDsObject
//
//  Synopsis:   ctor
//
//  History:    5-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CEmbeddedDsObject::CEmbeddedDsObject(
    const CDsObject &rdso,
    const CEdsoGdiProvider *pGdiProvider):
        CDsObject(rdso),
        m_cRefs(1),
        m_pGdiProvider(pGdiProvider)
{
    TRACE_CONSTRUCTOR(CEmbeddedDsObject);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CEmbeddedDsObject);
    ASSERT(pGdiProvider);
}



//+--------------------------------------------------------------------------
//
//  Member:     CEmbeddedDsObject::~CEmbeddedDsObject
//
//  Synopsis:   dtor
//
//  History:    5-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CEmbeddedDsObject::~CEmbeddedDsObject()
{
    TRACE_DESTRUCTOR(CEmbeddedDsObject);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CEmbeddedDsObject);
}




//============================================================================
//
// IUnknown implementation
//
//============================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CEmbeddedDsObject::QueryInterface
//
//  Synopsis:   Standard OLE
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbeddedDsObject::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    //TRACE_METHOD(CEmbeddedDsObject, QueryInterface);
    HRESULT hr = S_OK;

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppvObj = (IUnknown *)(IViewObject *)this;
        }
        else if (IsEqualIID(riid, IID_IOleObject))
        {
            *ppvObj = (IOleObject *)this;
        }
        else if (IsEqualIID(riid, IID_IViewObject))
        {
            *ppvObj = (IViewObject *)this;
        }
        else
        {
            hr = E_NOINTERFACE;
            DBG_OUT_NO_INTERFACE("CEmbeddedDsObject", riid);
            *ppvObj = NULL;
            break;
        }

        //
        // If we got this far we are handing out a new interface pointer on
        // this object, so addref it.
        //

        AddRef();
    } while (0);

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Member:     CEmbeddedDsObject::AddRef
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CEmbeddedDsObject::AddRef()
{
    //TRACE_METHOD(CEmbeddedDsObject, AddRef);

    return InterlockedIncrement((LONG *) &m_cRefs);
}




//+---------------------------------------------------------------------------
//
//  Member:     CEmbeddedDsObject::Release
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CEmbeddedDsObject::Release()
{
    //TRACE_METHOD(CEmbeddedDsObject, Release);

    ULONG cRefsTemp;

    cRefsTemp = InterlockedDecrement((LONG *)&m_cRefs);

    if (0 == cRefsTemp)
    {
        delete this;
    }

    return cRefsTemp;
}




//============================================================================
//
// IOleObject implementation
//
//============================================================================




HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::SetClientSite(
     IOleClientSite *pClientSite)
{
    TRACE_METHOD(CEmbeddedDsObject, SetClientSite);

    m_rpOleClientSite = pClientSite;
    return S_OK;
}




HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::GetClientSite(
     IOleClientSite **ppClientSite)
{
    TRACE_METHOD(CEmbeddedDsObject, GetClientSite);

    *ppClientSite = m_rpOleClientSite.get();
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::SetHostNames(
     LPCOLESTR szContainerApp,
     LPCOLESTR szContainerObj)
{
    TRACE_METHOD(CEmbeddedDsObject, SetHostNames);

    return S_OK;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::Close(
     DWORD dwSaveOption)
{
    TRACE_METHOD(CEmbeddedDsObject, Close);

    return S_OK;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::SetMoniker(
     DWORD dwWhichMoniker,
     IMoniker *pmk)
{
    TRACE_METHOD(CEmbeddedDsObject, SetMoniker);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::GetMoniker(
     DWORD dwAssign,
     DWORD dwWhichMoniker,
     IMoniker **ppmk)
{
    TRACE_METHOD(CEmbeddedDsObject, GetMoniker);

    return E_FAIL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::InitFromData(
     IDataObject *pDataObject,
     BOOL fCreation,
     DWORD dwReserved)
{
    TRACE_METHOD(CEmbeddedDsObject, InitFromData);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::GetClipboardData(
     DWORD dwReserved,
     IDataObject **ppDataObject)
{
    TRACE_METHOD(CEmbeddedDsObject, GetClipboardData);
    String strDisplayName;
    GetDisplayName(&strDisplayName, TRUE);

    *ppDataObject = new CEmbedDataObject(strDisplayName);
    return S_OK;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::DoVerb(
     LONG iVerb,
     LPMSG lpmsg,
     IOleClientSite *pActiveSite,
     LONG lindex,
     HWND hwndParent,
     LPCRECT lprcPosRect)
{
    TRACE_METHOD(CEmbeddedDsObject, DoVerb);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::EnumVerbs(
     IEnumOLEVERB **ppEnumOleVerb)
{
    TRACE_METHOD(CEmbeddedDsObject, EnumVerbs);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::Update()
{
    TRACE_METHOD(CEmbeddedDsObject, Update);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::IsUpToDate()
{
    TRACE_METHOD(CEmbeddedDsObject, IsUpToDate);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::GetUserClassID(
     CLSID *pClsid)
{
    //TRACE_METHOD(CEmbeddedDsObject, GetUserClassID);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::GetUserType(
     DWORD dwFormOfType,
     LPOLESTR *pszUserType)
{
    //TRACE_METHOD(CEmbeddedDsObject, GetUserType);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::SetExtent(
     DWORD dwDrawAspect,
     SIZEL *psizel)
{
    TRACE_METHOD(CEmbeddedDsObject, SetExtent);

    //
    // E_FAIL indicates the object is not resizeable
    //

    return E_FAIL;
}

#define HIMETRIC_PER_INCH   2540      // number HIMETRIC units per inch
#define MAP_PIX_TO_LOGHIM(x,ppli)   MulDiv(HIMETRIC_PER_INCH, (x), (ppli))

/*
 * XformSizeInPixelsToHimetric
 * XformSizeInHimetricToPixels
 *
 * Functions to convert a SIZEL structure (Size functions) or
 * an int (Width functions) between a device coordinate system and
 * logical HiMetric units.
 *
 * Parameters:
 *  hDC             HDC providing reference to the pixel mapping.  If
 *                  NULL, a screen DC is used.
 *
 *  Size Functions:
 *  lpSizeSrc       LPSIZEL providing the structure to convert.  This
 *                  contains pixels in XformSizeInPixelsToHimetric and
 *                  logical HiMetric units in the complement function.
 *  lpSizeDst       LPSIZEL providing the structure to receive converted
 *                  units.  This contains pixels in
 *                  XformSizeInPixelsToHimetric and logical HiMetric
 *                  units in the complement function.
 *
 *  Width Functions:
 *  iWidth          int containing the value to convert.
 *
 * Return Value:
 *  Size Functions:     None
 *  Width Functions:    Converted value of the input parameters.
 *
 * NOTE:
 *  When displaying on the screen, Window apps display everything enlarged
 *  from its actual size so that it is easier to read. For example, if an
 *  app wants to display a 1in. horizontal line, that when printed is
 *  actually a 1in. line on the printed page, then it will display the line
 *  on the screen physically larger than 1in. This is described as a line
 *  that is "logically" 1in. along the display width. Windows maintains as
 *  part of the device-specific information about a given display device:
 *      LOGPIXELSX -- no. of pixels per logical in along the display width
 *      LOGPIXELSY -- no. of pixels per logical in along the display height
 *
 *  The following formula converts a distance in pixels into its equivalent
 *  logical HIMETRIC units:
 *
 *      DistInHiMetric = (HIMETRIC_PER_INCH * DistInPix)
 *                       -------------------------------
 *                           PIXELS_PER_LOGICAL_IN
 *
 */

HRESULT
XformSizeInPixelsToHimetric(
    HDC hDC,
    LPSIZEL lpSizeInPix,
    LPSIZEL lpSizeInHiMetric)
{
    int     iXppli;     //Pixels per logical inch along width
    int     iYppli;     //Pixels per logical inch along height
    BOOL    fSystemDC=FALSE;

    if (NULL==hDC ||
        GetDeviceCaps(hDC, TECHNOLOGY) == DT_METAFILE ||
        GetDeviceCaps(hDC, LOGPIXELSX) == 0)
    {
        hDC=GetDC(NULL);

        if (!hDC)
        {
            DBG_OUT_HRESULT(E_OUTOFMEMORY);
            return E_OUTOFMEMORY;
        }
        fSystemDC=TRUE;
    }

    iXppli = GetDeviceCaps (hDC, LOGPIXELSX);
    iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

    //We got pixel units, convert them to logical HIMETRIC along the display
    lpSizeInHiMetric->cx = (long)MAP_PIX_TO_LOGHIM((int)lpSizeInPix->cx, iXppli);
    lpSizeInHiMetric->cy = (long)MAP_PIX_TO_LOGHIM((int)lpSizeInPix->cy, iYppli);

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::GetExtent(
     DWORD dwDrawAspect,
     SIZEL *psizel)
{
    TRACE_METHOD(CEmbeddedDsObject, GetExtent);

    HRESULT hr = S_OK;
    HWND    hwndRichEdit = NULL;
    HFONT   hEmbeddedDsObjectFont = NULL;

    do
    {
        hwndRichEdit = m_pGdiProvider->GetRichEditHwnd();
        hEmbeddedDsObjectFont = m_pGdiProvider->GetEdsoFont();

        HDC hdc = GetWindowDC(hwndRichEdit);

        if (!hdc)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        HGDIOBJ hOldFont = SelectObject(hdc, hEmbeddedDsObjectFont);

        String strDisplayName;

        GetDisplayName(&strDisplayName, TRUE);

        SIZE size;
        VERIFY(GetTextExtentPoint32(hdc,
                             strDisplayName.c_str(),
                             static_cast<int>(strDisplayName.length()),
                             &size));

        TEXTMETRIC      tm;
        VERIFY(GetTextMetrics(hdc, &tm));

        SIZEL           sizel;
        sizel.cx = size.cx + 1;
		// NTRAID#NTBUG9-346809-2001/05/22-hiteshr
        sizel.cy = size.cy;	// - tm.tmDescent;
        hr = XformSizeInPixelsToHimetric(hdc, &sizel, psizel);
        BREAK_ON_FAIL_HRESULT(hr);

        SelectObject(hdc, hOldFont);
        ReleaseDC(hwndRichEdit, hdc);
    } while (0);

    return hr;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::Advise(
     IAdviseSink *pAdvSink,
     DWORD *pdwConnection)
{
    TRACE_METHOD(CEmbeddedDsObject, Advise);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::Unadvise(
     DWORD dwConnection)
{
    TRACE_METHOD(CEmbeddedDsObject, Unadvise);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::EnumAdvise(
     IEnumSTATDATA **ppenumAdvise)
{
    TRACE_METHOD(CEmbeddedDsObject, EnumAdvise);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::GetMiscStatus(
     DWORD dwAspect,
     DWORD *pdwStatus)
{
    TRACE_METHOD(CEmbeddedDsObject, GetMiscStatus);

    return E_NOTIMPL;
}

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::SetColorScheme(
     LOGPALETTE *pLogpal)
{
    TRACE_METHOD(CEmbeddedDsObject, SetColorScheme);

    return E_NOTIMPL;
}




//============================================================================
//
// IViewObject implementation
//
//============================================================================




//+--------------------------------------------------------------------------
//
//  Function:   Draw
//
//  Synopsis:   Draw this object as a text string.
//
//  History:    3-18-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::Draw(
    DWORD dwDrawAspect,
    LONG lindex,
    void *pvAspect,
    DVTARGETDEVICE *ptd,
    HDC hdcTargetDev,
    HDC hdcDraw,
    LPCRECTL lprcBounds,
    LPCRECTL lprcWBounds,
    BOOL (STDMETHODCALLTYPE *pfnContinue)(ULONG_PTR dwContinue),
    ULONG_PTR dwContinue)
{
    //TRACE_METHOD(CEmbeddedDsObject, Draw);

    HFONT hfontOld = (HFONT)SelectObject(hdcDraw, m_pGdiProvider->GetEdsoFont());
    SetTextAlign(hdcDraw, TA_BOTTOM);
    String strDisplayName;
    GetDisplayName(&strDisplayName, TRUE);
    LPCWSTR pwzName = strDisplayName.c_str();
    TextOut(hdcDraw, lprcBounds->left, lprcBounds->bottom, pwzName, lstrlen(pwzName));

    TEXTMETRIC      tm;

    GetTextMetrics(hdcDraw, &tm);

    HPEN hpenUnderline = m_pGdiProvider->GetEdsoPen();

    if (hpenUnderline)
    {
        HPEN hpenOld = SelectPen(hdcDraw, hpenUnderline);
        MoveToEx(hdcDraw, lprcBounds->left, lprcBounds->bottom - tm.tmDescent + 1, NULL);
        LineTo(hdcDraw, lprcBounds->right, lprcBounds->bottom - tm.tmDescent + 1);
        SelectPen(hdcDraw, hpenOld);
    }

    SelectObject(hdcDraw, hfontOld);
    return S_OK;
}




HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::GetColorSet(
    DWORD dwDrawAspect,
    LONG lindex,
    void *pvAspect,
    DVTARGETDEVICE *ptd,
    HDC hicTargetDev,
    LOGPALETTE **ppColorSet)
{
    TRACE_METHOD(CEmbeddedDsObject, GetColorSet);

    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::Freeze(
    DWORD dwDrawAspect,
    LONG lindex,
    void *pvAspect,
    DWORD *pdwFreeze)
{
    TRACE_METHOD(CEmbeddedDsObject, Freeze);

    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::Unfreeze(
    DWORD dwFreeze)
{
    TRACE_METHOD(CEmbeddedDsObject, Unfreeze);

    return E_NOTIMPL;
}


HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::SetAdvise(
    DWORD aspects,
    DWORD advf,
    IAdviseSink *pAdvSink)
{
    TRACE_METHOD(CEmbeddedDsObject, SetAdvise);

    m_rpAdviseSink = pAdvSink;
    return S_OK;
}


HRESULT STDMETHODCALLTYPE
CEmbeddedDsObject::GetAdvise(
    DWORD *pAspects,
    DWORD *pAdvf,
    IAdviseSink **ppAdvSink)
{
    TRACE_METHOD(CEmbeddedDsObject, GetAdvise);

    return E_NOTIMPL;
}



DEBUG_DECLARE_INSTANCE_COUNTER(CEmbedDataObject)




//============================================================================
//
// IUnknown implementation
//
//============================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::QueryInterface
//
//  Synopsis:   Standard OLE
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbedDataObject::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppvObj = (IUnknown *)(IDataObject *)this;
        }
        else if (IsEqualIID(riid, IID_IDataObject))
        {
            *ppvObj = (IUnknown *)(IDataObject *)this;
        }
        else
        {
            DBG_OUT_NO_INTERFACE("CEmbedDataObject", riid);
            hr = E_NOINTERFACE;
            *ppvObj = NULL;
            break;
        }

        //
        // If we got this far we are handing out a new interface pointer on
        // this object, so addref it.
        //

        AddRef();
    } while (0);

    return hr;
}




//+---------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::AddRef
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CEmbedDataObject::AddRef()
{
    return InterlockedIncrement((LONG *) &m_cRefs);
}




//+---------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::Release
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CEmbedDataObject::Release()
{
    ULONG cRefsTemp;

    cRefsTemp = InterlockedDecrement((LONG *)&m_cRefs);

    if (0 == cRefsTemp)
    {
        delete this;
    }

    return cRefsTemp;
}




//============================================================================
//
// IDataObject implementation
//
//============================================================================



//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::GetData
//
//  Synopsis:   Return data in the requested format
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbedDataObject::GetData(
        FORMATETC *pFormatEtc,
        STGMEDIUM *pMedium)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, GetData);

    HRESULT hr = S_OK;

    //
    // Init default output medium.  If any of the individual _getdata*
    // methods use something else, they can override.
    //

    pMedium->pUnkForRelease = NULL;
    pMedium->tymed = TYMED_HGLOBAL;
    pMedium->hGlobal = NULL;

    if (m_strData.empty())
    {
        return S_FALSE;
    }

    try
    {
		if (pFormatEtc->cfFormat == CF_UNICODETEXT ||
            pFormatEtc->cfFormat == CF_TEXT)
        {
            hr = _GetDataText(pFormatEtc, pMedium, pFormatEtc->cfFormat);
        }
        else
        {
            hr = DV_E_FORMATETC;
    #if (DBG == 1)
            Dbg(DEB_WARN,
                "CEmbedDataObject::GetData: unrecognized cf %#x\n",
                pFormatEtc->cfFormat);
    #endif // (DBG == 1)
        }
    }
    catch (const exception &e)
    {
        Dbg(DEB_ERROR, "Caught exception %s\n", e.what());
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::_GetDataText
//
//  Synopsis:   Return data in text format
//
//  Arguments:  [pFormatEtc] -
//              [pMedium]    -
//              [cf]         - CF_TEXT or CF_UNICODETEXT
//
//  History:    5-21-1999   davidmun   Created
//
//  Notes:      Returns empty string unless this was constructed with
//              handle to rich edit control.
//
//---------------------------------------------------------------------------

HRESULT
CEmbedDataObject::_GetDataText(
        FORMATETC *pFormatEtc,
        STGMEDIUM *pMedium,
        ULONG      cf)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, _GetDataText);
    ASSERT(cf == CF_TEXT || cf == CF_UNICODETEXT);
    ASSERT(pFormatEtc->tymed & TYMED_HGLOBAL);

    HRESULT hr = S_OK;
    ULONG   cbChar = (ULONG)((cf == CF_UNICODETEXT) ? sizeof(WCHAR) : sizeof(CHAR));
    ULONG   cbMedium = cbChar * (static_cast<ULONG>(m_strData.length()) + 1);

    pMedium->hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD,
                                   cbMedium);

    if (!pMedium->hGlobal)
    {
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return STG_E_MEDIUMFULL;
    }

    PVOID pvMedium = GlobalLock(pMedium->hGlobal);

    if (cf == CF_UNICODETEXT)
    {
        lstrcpy((PWSTR)pvMedium, m_strData.c_str());
    }
    else
    {
        hr = UnicodeToAnsi((PSTR)pvMedium, m_strData.c_str(), cbMedium);
    }
    GlobalUnlock(pMedium->hGlobal);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::GetDataHere
//
//  Synopsis:   Fill the hGlobal in [pmedium] with the requested data
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbedDataObject::GetDataHere(
        FORMATETC *pFormatEtc,
        STGMEDIUM *pMedium)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, GetDataHere);

    return E_NOTIMPL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::QueryGetData
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbedDataObject::QueryGetData(
        FORMATETC *pformatetc)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, QueryGetData);
    return E_NOTIMPL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::GetCanonicalFormatEtc
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbedDataObject::GetCanonicalFormatEtc(
        FORMATETC *pformatectIn,
        FORMATETC *pformatetcOut)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, GetCanonicalFormatEtc);
    return E_NOTIMPL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::SetData
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbedDataObject::SetData(
    FORMATETC *pformatetc,
    STGMEDIUM *pmedium,
    BOOL fRelease)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, SetData);
    return E_NOTIMPL;
}



//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::EnumFormatEtc
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbedDataObject::EnumFormatEtc(
    DWORD dwDirection,
    IEnumFORMATETC **ppenumFormatEtc)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, EnumFormatEtc);
    return E_NOTIMPL;
}



//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::DAdvise
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbedDataObject::DAdvise(
    FORMATETC *pformatetc,
    DWORD advf,
    IAdviseSink *pAdvSink,
    DWORD *pdwConnection)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, DAdvise);
    return E_NOTIMPL;
}



//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::DUnadvise
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbedDataObject::DUnadvise(
    DWORD dwConnection)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, DUnadvise);
    return E_NOTIMPL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::EnumDAdvise
//
//  Synopsis:   Not implemented
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CEmbedDataObject::EnumDAdvise(
    IEnumSTATDATA **ppenumAdvise)
{
    TRACE_METHOD_EX(DEB_DATAOBJECT, CEmbedDataObject, EnumDAdvise);
    return E_NOTIMPL;
}




//============================================================================
//
// Non interface method implementation
//
//============================================================================


//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::CEmbedDataObject
//
//  Synopsis:   ctor
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CEmbedDataObject::CEmbedDataObject(const String& strDisplayName):
            m_cRefs(1)
{
    TRACE_CONSTRUCTOR_EX(DEB_DATAOBJECT, CEmbedDataObject);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CEmbedDataObject);

    m_strData = strDisplayName;
}




//+--------------------------------------------------------------------------
//
//  Member:     CEmbedDataObject::~CEmbedDataObject
//
//  Synopsis:   dtor
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CEmbedDataObject::~CEmbedDataObject()
{
    TRACE_DESTRUCTOR_EX(DEB_DATAOBJECT, CEmbedDataObject);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CEmbedDataObject);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\errordlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       password.cxx
//
//  Contents:   Implementation of class used to prompt user for credentials.
//
//  Classes:    CMessageDlg
//
//  History:    06-28-1998   DavidMun   Created
//
//---------------------------------------------------------------------------


#include "headers.hxx"
#pragma hdrstop


//+--------------------------------------------------------------------------
//
//  Function:   PopupMessage
//
//  Synopsis:   Invoke a modal dialog to display a formatted message string.
//
//  Arguments:  [hwndParent]  - parent window handle
//              [idsMessage]  - resource id of printf style format string
//              [...]         - arguments required for string
//
//  History:    07-06-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void __cdecl
PopupMessage(
    HWND  hwndParent,
    ULONG idsMessage,
    ...)
{
    va_list valArgs;
    va_start(valArgs, idsMessage);

    CMessageDlg MessageDlg;

    MessageDlg.DoModalDialog(hwndParent,
                          NULL,
                          IDI_ERROR,
                          NULL,
                          0,
                          0,
                          idsMessage,
                          valArgs);
    va_end(valArgs);
}




//+--------------------------------------------------------------------------
//
//  Function:   PopupMessageEx
//
//  Synopsis:   Invoke a modal dialog to display a formatted message string.
//
//  Arguments:  [hwndParent]  - parent window handle
//              [idIcon]      - resource identifier of system icon
//              [idsMessage]  - resource id of printf style format string
//              [...]         - arguments required for string
//
//  History:    07-06-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void __cdecl
PopupMessageEx(
    HWND    hwndParent,
    PCWSTR idIcon,
    ULONG   idsMessage,
    ...)
{
    va_list valArgs;
    va_start(valArgs, idsMessage);

    CMessageDlg MessageDlg;

    MessageDlg.DoModalDialog(hwndParent,
                          NULL,
                          idIcon,
                          NULL,
                          0,
                          0,
                          idsMessage,
                          valArgs);
    va_end(valArgs);
}




//+--------------------------------------------------------------------------
//
//  Function:   PopupMessageAndCode
//
//  Synopsis:   Invoke a modal dialog to display a formatted message string
//              and error code.
//
//  Arguments:  [hwndParent]  - parent window handle
//              [pwzFileName] - error code's file name
//              [ulLineNo]    - error code's line number
//              [hr]          - error code's HRESULT
//              [idsMessage]  - resource id of printf style format string
//              [...]         - arguments required for string
//
//  History:    07-06-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void __cdecl
PopupMessageAndCode(
    HWND    hwndParent,
    PCWSTR pwzFileName,
    ULONG   ulLineNo,
    HRESULT hr,
    ULONG   idsMessage,
    ...)
{
    va_list valArgs;
    va_start(valArgs, idsMessage);

    CMessageDlg MessageDlg;

    MessageDlg.DoModalDialog(hwndParent,
                          NULL,
                          IDI_ERROR,
                          pwzFileName,
                          ulLineNo,
                          hr,
                          idsMessage,
                          valArgs);
    va_end(valArgs);
}




//+--------------------------------------------------------------------------
//
//  Member:     CMessageDlg::DoModalDialog
//
//  Synopsis:   Invoke a modal dialog to display a message.
//
//  Arguments:  [hwndParent]  - parent window handle
//              [hinstIcon]   - NULL or module handle where icon lives
//              [idIcon]      - resource identifier of icon to display
//              [pwzFile]     - error code's file name
//              [ulLine]      - error code's line number
//              [ulErrorCode] - error code's error value
//              [idsMessage]  - resource id of printf style format string
//              [valArgs]     - arguments required for string
//
//  Returns:    HRESULT
//
//  History:    07-06-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CMessageDlg::DoModalDialog(
    HWND        hwndParent,
    HINSTANCE   hinstIcon,
    PCWSTR      idIcon,
    PCWSTR      pwzFile,
    ULONG       ulLine,
    ULONG       ulErrorCode,
    ULONG       idsMessage,
    va_list     valArgs)
{
    TRACE_METHOD(CMessageDlg, DoModalDialog);
    ASSERT(idsMessage);

    m_hinstIcon = hinstIcon;
    m_idIcon = idIcon;

    if (pwzFile)
    {
        wsprintf(m_wzErrorCode, L"%ws %u %x", pwzFile, ulLine, ulErrorCode);
    }

    String strMessageFmt(String::load(static_cast<unsigned>(idsMessage)));

    PWSTR pwzTemp = NULL;

    ULONG ulResult;

    ulResult = FormatMessageW(FORMAT_MESSAGE_FROM_STRING
                              | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                              strMessageFmt.c_str(),
                              0,
                              0,
                              (LPWSTR) &pwzTemp,
                              0,
                              &valArgs);

    if (ulResult)
    {
        m_strMessage = pwzTemp;
        LocalFree(pwzTemp);
    }
    else
    {
        DBG_OUT_LASTERROR;
    }

    _DoModalDlg(hwndParent, IDD_ERROR);
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CMessageDlg::_OnInit
//
//  Synopsis:   Initialize dialog controls
//
//  Arguments:  [pfSetFocus] - unused
//
//  Returns:    S_OK
//
//  History:    06-28-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CMessageDlg::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CMessageDlg, _OnInit);

    //
    // Make prefix shut up
    //

    if (!_hCtrl(IDC_ERRORMSG) ||
        !_hCtrl(IDC_ERROR_CODE_LBL) ||
        !_hCtrl(IDOK) ||
        !_hCtrl(IDC_ERROR_CODE_EDIT))
    {
        return E_FAIL;
    }

    //
    // The error dialog has these components:
    //
    // 1. caption
    // 2. icon
    // 3. error message
    // 4. error code
    //
    // The last is optional.
    //

    //
    // Set up the caption.  Take this from the parent window.
    //

    WCHAR   wzCaption[MAX_PATH];

    GetWindowText(GetParent(m_hwnd), wzCaption, ARRAYLEN(wzCaption));
    SetWindowText(m_hwnd, wzCaption);

    //
    // Set the icon.
    //

    HICON hIcon = LoadIcon(m_hinstIcon, m_idIcon);

    if (hIcon)
    {
        SendDlgItemMessage(m_hwnd,
                           IDC_POPUP_MSG_ICON,
                           STM_SETICON,
                           (WPARAM)hIcon,
                           0L);
    }

    //
    // Set the error message static
    //

    Static_SetText(_hCtrl(IDC_ERRORMSG), m_strMessage.c_str());

    //
    // If there is an error code string, set it, otherwise hide
    // the edit control and its label and resize the dialog to
    // eliminate the empty space.
    //

    if (*m_wzErrorCode)
    {
        Static_SetText(_hCtrl(IDC_ERROR_CODE_EDIT), m_wzErrorCode);
    }
    else
    {
        EnableWindow(_hCtrl(IDC_ERROR_CODE_LBL), FALSE);
        EnableWindow(_hCtrl(IDC_ERROR_CODE_EDIT), FALSE);
        ShowWindow(_hCtrl(IDC_ERROR_CODE_LBL), SW_HIDE);
        ShowWindow(_hCtrl(IDC_ERROR_CODE_EDIT), SW_HIDE);

        RECT rcClose;
        RECT rcEdit;

        _GetChildWindowRect(_hCtrl(IDOK), &rcClose);
        _GetChildWindowRect(_hCtrl(IDC_ERROR_CODE_EDIT), &rcEdit);

        //
        // Move the Close button up on top of the hidden edit control
        //

        SetWindowPos(_hCtrl(IDOK),
                     NULL,
                     rcClose.left,
                     rcEdit.top,
                     0,
                     0,
                     SWP_NOSIZE | SWP_NOZORDER);

        //
        // Shrink the dialog vertically by the amount the button was
        // moved up
        //

        LONG cyDelta = rcClose.top - rcEdit.top;
        ASSERT(cyDelta > 0);
        RECT rcDialog;

        GetWindowRect(m_hwnd, &rcDialog);

        SetWindowPos(m_hwnd,
                     NULL,
                     0,
                     0,
                     WindowRectWidth(rcDialog),
                     WindowRectHeight(rcDialog) - cyDelta,
                     SWP_NOMOVE | SWP_NOZORDER);
    }

    return S_OK;
}





//+--------------------------------------------------------------------------
//
//  Member:     CMessageDlg::_OnCommand
//
//  Synopsis:   Handle user input.
//
//  Arguments:  standard windows
//
//  Returns:    standard windows
//
//  History:    06-28-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CMessageDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fNotHandled = FALSE;

    switch (LOWORD(wParam))
    {
    case IDOK:
        EndDialog(m_hwnd, 0);
        break;
	case IDCANCEL:
        EndDialog(GetHwnd(), 0);
		break;

    default:
        fNotHandled = TRUE;
        break;
    }

    return fNotHandled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\filtermanager.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       FilterManager.cxx
//
//  Contents:   Definition of class to manage LDAP and WinNT filters
//
//  Classes:    CFilterManager
//
//  History:    02-24-2000   davidmun   Created
//
//---------------------------------------------------------------------------


#include "headers.hxx"
#pragma hdrstop


#define MAX_CLAUSES                 6
#define MAX_INSERT_STR              256


//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::CFilterManager
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - owning instance of object picker
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CFilterManager::CFilterManager(
    const CObjectPicker &rop):
        m_rop(rop),
        m_flCurFilterFlags(0),
		m_bLookForDirty(false)
{
    TRACE_CONSTRUCTOR(CFilterManager);

    //
    // CAUTION: do not reference scope manager here, it is not
    // initialized yet.
    //
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::~CFilterManager
//
//  Synopsis:   dtor
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CFilterManager::~CFilterManager()
{
    TRACE_DESTRUCTOR(CFilterManager);
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::HandleScopeChange
//
//  Synopsis:   Update the current filter flags as necessary to match the
//              new scope the user has just selected.
//
//  Arguments:  [hwnd] - for binding
//
//  History:    06-08-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CFilterManager::HandleScopeChange(
    HWND hwnd) const
{
    TRACE_METHOD(CFilterManager, HandleScopeChange);

    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rCurScope = rsm.GetCurScope();

    ASSERT(m_flCurFilterFlags);
    ULONG flNewFilterFlags = 0;
	HRESULT hr = S_OK;
	if(m_rop.GetFilterManager().IsLookForDirty())
	{

		//
		// If we are changing TO the global catalog, and there is a joined
		// domain scope, the set of filter flags is the bitwise OR of the two.
		//
		hr = _GetSelectedFilterFlags(hwnd, rCurScope, &flNewFilterFlags);
		ASSERT(SUCCEEDED(hr));

		if (rCurScope.Type() == ST_GLOBAL_CATALOG)
		{
			const CLdapDomainScope *pJoinedScope =
				dynamic_cast<const CLdapDomainScope *>
					(&rsm.LookupScopeByType(ST_UPLEVEL_JOINED_DOMAIN));

			ASSERT(!pJoinedScope || pJoinedScope->Type() == ST_UPLEVEL_JOINED_DOMAIN);

			if (pJoinedScope)
			{
				ULONG flJoined;

				hr = _GetSelectedFilterFlags(hwnd, *pJoinedScope, &flJoined);
				ASSERT(SUCCEEDED(hr));
				flNewFilterFlags |= flJoined;
			}
		}

		if (!(flNewFilterFlags & ~DSOP_FILTER_INCLUDE_ADVANCED_VIEW))
		{
			PopupMessageEx(hwnd,
						   IDI_INFORMATION,
						   IDS_NEW_SCOPE_CLASSES_0_INTERSECTION);

			//
			// Since scope change should only come about via Look In dialog,
			// and that will not allow selection of a scope for which the
			// flags cannot be obtained, and once obtained flags are always
			// successfully returned from a scope, this should work.
			//

			hr = rCurScope.GetResultantDefaultFilterFlags(hwnd, &flNewFilterFlags);
			ASSERT(SUCCEEDED(hr));
		}
	}
	else
		hr = rCurScope.GetResultantDefaultFilterFlags(hwnd, &flNewFilterFlags);

    m_flCurFilterFlags = flNewFilterFlags;

    ASSERT(m_flCurFilterFlags);
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::GetSelectedFilterFlags
//
//  Synopsis:   Wrapper which returns the flags the user has selected that
//              apply to [Scope], or if none apply, the default filter
//              flags for [Scope].
//
//  Arguments:  [hwnd]     - for bind
//              [Scope]    - scope for which to return flags that user has
//                            selected via Look For dialog
//              [pulFlags] - filled with selected flags
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CFilterManager::GetSelectedFilterFlags(
    HWND hwnd,
    const CScope &Scope,
    ULONG *pulFlags) const
{
    TRACE_METHOD(CFilterManager, GetSelectedFilterFlags);
    ASSERT(pulFlags);
    if (!pulFlags)
    {
        return E_POINTER;
    }

    HRESULT hr = S_OK;

    hr = _GetSelectedFilterFlags(hwnd, Scope, pulFlags);



    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    if (!*pulFlags)
    {
        hr = Scope.GetResultantDefaultFilterFlags(hwnd, pulFlags);
        CHECK_HRESULT(hr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::_GetSelectedFilterFlags
//
//  Synopsis:   Fill *[pulFlags] with the subset of the DSOP_* filter flags
//              that the caller indicated apply to scopes of the type of
//              [Scope] has which the user has selected in the Look For
//              dialog.
//
//  Arguments:  [hwnd]     - for bind
//              [Scope]    - scope for which to return flags that user has
//                            selected via Look For dialog
//              [pulFlags] - filled with selected flags
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      This routine is complex because [Scope] is not necessarily
//              the current scope, and therefore the selections the user
//              has made in the look for dialog must be mapped from the
//              current scope to [Scope].
//
//---------------------------------------------------------------------------

HRESULT
CFilterManager::_GetSelectedFilterFlags(
    HWND hwnd,
    const CScope &Scope,
    ULONG *pulFlags) const
{
    TRACE_METHOD(CFilterManager, GetSelectedFilterFlags);
    ASSERT(pulFlags);

    if (!pulFlags)
    {
        return E_POINTER;
    }

    ULONG ulNewResultantFilter;

    HRESULT hr = Scope.GetResultantFilterFlags(hwnd, &ulNewResultantFilter);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    ULONG ulOldSelectedFilter = m_flCurFilterFlags;

    //
    // Are we switching between uplevel and downlevel?
    //

    if ((ulOldSelectedFilter & DOWNLEVEL_FILTER_BIT) &&
        !(ulNewResultantFilter & DOWNLEVEL_FILTER_BIT))
    {
        //
        // Yes, previous scope was downlevel, new scope is uplevel.  Compose
        // an uplevel filter flag set which corresponds to the downlevel
        // filters selected for previous scope.
        //

        ULONG flNewFilterFlags = 0;

        if (IsDownlevelFlagSet(ulOldSelectedFilter, DSOP_DOWNLEVEL_FILTER_USERS))
        {
            flNewFilterFlags |= (ulNewResultantFilter & DSOP_FILTER_USERS);
        }

        if (IsDownlevelFlagSet(ulOldSelectedFilter, ALL_DOWNLEVEL_GROUP_FILTERS))
        {
            flNewFilterFlags |= (ulNewResultantFilter & ALL_UPLEVEL_GROUP_FILTERS);
        }

        if (IsDownlevelFlagSet(ulOldSelectedFilter, DSOP_DOWNLEVEL_FILTER_COMPUTERS))
        {
            flNewFilterFlags |= (ulNewResultantFilter & DSOP_FILTER_COMPUTERS);
        }

        if (IsDownlevelFlagSet(ulOldSelectedFilter, ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS))
        {
            flNewFilterFlags |= (ulNewResultantFilter & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS);
        }

        if (IsDownlevelFlagSet(ulOldSelectedFilter, DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER))
        {
            flNewFilterFlags |= (ulNewResultantFilter & DSOP_FILTER_EXTERNAL_CUSTOMIZER);
        }

        //
        // If that leaves us with some intersection, use it.  Otherwise notify
        // user that we're switching to default for new scope.
        //

        if (flNewFilterFlags)
        {
            ulOldSelectedFilter = flNewFilterFlags;

            if (ulNewResultantFilter & DSOP_FILTER_INCLUDE_ADVANCED_VIEW)
            {
                ulOldSelectedFilter |= DSOP_FILTER_INCLUDE_ADVANCED_VIEW;
            }
        }
        else
        {
            ulOldSelectedFilter = 0;
        }
    }
    else if (!(ulOldSelectedFilter & DOWNLEVEL_FILTER_BIT) &&
             (ulNewResultantFilter & DOWNLEVEL_FILTER_BIT))
    {
        //
        // Yes, previous scope was uplevel, new scope is downlevel
        //

        ULONG flNewFilterFlags = 0;

        if (ulOldSelectedFilter & DSOP_FILTER_USERS)
        {
            flNewFilterFlags |= ulNewResultantFilter & DSOP_DOWNLEVEL_FILTER_USERS;
        }

        if (ulOldSelectedFilter & ALL_UPLEVEL_GROUP_FILTERS)
        {
            flNewFilterFlags |= ulNewResultantFilter & ALL_DOWNLEVEL_GROUP_FILTERS;

            if (IsDownlevelFlagSet(ulNewResultantFilter,
                                   DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS))
            {
                flNewFilterFlags |=
                    DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS;
            }
        }

        if (ulOldSelectedFilter & DSOP_FILTER_COMPUTERS)
        {
            flNewFilterFlags |= ulNewResultantFilter & DSOP_DOWNLEVEL_FILTER_COMPUTERS;
        }

        if (ulOldSelectedFilter & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS)
        {
            flNewFilterFlags |= ulNewResultantFilter & ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS;
        }

        if (ulOldSelectedFilter & DSOP_FILTER_EXTERNAL_CUSTOMIZER)
        {
            flNewFilterFlags |= ulNewResultantFilter & DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER;
        }

        //
        // If that leaves us with some intersection of flags that generate
        // objects, use it.  Otherwise notify user that we're switching to
        // default for new scope.
        //
        // We mask off DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS because
        // the exclusion of downlevel groups doesn't generate objects.  Note
        // also that doing this masks off the DOWNLEVEL_FILTER_BIT, which we
        // want.
        //

        if (flNewFilterFlags & ~DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS)
        {
            ulOldSelectedFilter = flNewFilterFlags;
        }
        else
        {
            ulOldSelectedFilter = 0;
        }
    }
    else if (ulOldSelectedFilter & DOWNLEVEL_FILTER_BIT)
    {
        //
        // Nope, both previous and new scopes are downlevel.  If
        // any of the classes the user selected for the previous scope
        // are not available in the current scope, remove the unavailable
        // ones from the selection in ulOldSelectedFilter.
        //

        if (!IsDownlevelFlagSet(ulNewResultantFilter, DSOP_DOWNLEVEL_FILTER_USERS))
        {
            ulOldSelectedFilter &= ~DSOP_DOWNLEVEL_FILTER_USERS;
        }

        if (!IsDownlevelFlagSet(ulNewResultantFilter, ALL_DOWNLEVEL_GROUP_FILTERS))
        {
            ulOldSelectedFilter &= ~ALL_DOWNLEVEL_GROUP_FILTERS;
        }

        if (!IsDownlevelFlagSet(ulNewResultantFilter, DSOP_DOWNLEVEL_FILTER_COMPUTERS))
        {
            ulOldSelectedFilter &= ~DSOP_DOWNLEVEL_FILTER_COMPUTERS;
        }

        if (!IsDownlevelFlagSet(ulNewResultantFilter, ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS))
        {
            ulOldSelectedFilter &= ~ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS;
        }

        if (!IsDownlevelFlagSet(ulNewResultantFilter, DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER))
        {
            ulOldSelectedFilter &= ~DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER;
        }

        //
        // At this point if the bitflags for any classes of objects were turned
        // off in ulOldSelectedFilter, the downlevel filter bit has also been
        // turned off.  So if ulOldSelectedFilter has any flags in it that
        // will generate objects (DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS
        // doesn't) then we need to turn the DOWNLEVEL_FILTER_BIT back on.
        //

        if (ulOldSelectedFilter & ~DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS)
        {
            ulOldSelectedFilter |= DOWNLEVEL_FILTER_BIT;
        }
        else
        {
            ulOldSelectedFilter = 0;
        }
    }
    else
    {
        //
        // Both previous and new scopes are uplevel.
        //

        if (!(ulNewResultantFilter & DSOP_FILTER_USERS))
        {
            ulOldSelectedFilter &= ~DSOP_FILTER_USERS;
        }
        //
        //If New doesn't have any of ALL_UPLEVEL_GROUP_FILTERS
        //remove them from old
        //If new has any of ALL_UPLEVEL_GROUP_FILTERS and 
        //if old also has any of ALL_UPLEVEL_GROUP_FILTERS then
        //old should only have those which are present in new
        //BUG 202699
        if (!(ulNewResultantFilter & ALL_UPLEVEL_GROUP_FILTERS))
        {
            ulOldSelectedFilter &= ~ALL_UPLEVEL_GROUP_FILTERS;
        }
        else
        {
            if(ulOldSelectedFilter & ALL_UPLEVEL_GROUP_FILTERS)
            {
                ulOldSelectedFilter &= ~ALL_UPLEVEL_GROUP_FILTERS;
                ulOldSelectedFilter |= ulNewResultantFilter & ALL_UPLEVEL_GROUP_FILTERS;
            }
        }

        if (!(ulNewResultantFilter & DSOP_FILTER_COMPUTERS))
        {
            ulOldSelectedFilter &= ~DSOP_FILTER_COMPUTERS;
        }

        if (!(ulNewResultantFilter & DSOP_FILTER_CONTACTS))
        {
            ulOldSelectedFilter &= ~DSOP_FILTER_CONTACTS;
        }

        if (!(ulNewResultantFilter & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS))
        {
            ulOldSelectedFilter &= ~ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS;
        }

        if (!(ulNewResultantFilter & DSOP_FILTER_EXTERNAL_CUSTOMIZER))
        {
            ulOldSelectedFilter &= ~DSOP_FILTER_EXTERNAL_CUSTOMIZER;
        }

        if (!(ulOldSelectedFilter & ~DSOP_FILTER_INCLUDE_ADVANCED_VIEW))
        {
            ulOldSelectedFilter = 0;
        }
    }

#if (DBG == 1)
    if (Scope.Type() == ST_TARGET_COMPUTER)
    {
        ASSERT(!IsDownlevelFlagSet(ulOldSelectedFilter,
                                   DSOP_DOWNLEVEL_FILTER_COMPUTERS));
    }

    if (Scope.Type() == ST_WORKGROUP)
    {
        ASSERT(!ulOldSelectedFilter ||
               ulOldSelectedFilter == DSOP_DOWNLEVEL_FILTER_COMPUTERS);
    }
#endif // (DBG == 1)

    *pulFlags = ulOldSelectedFilter;
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::GetFilterDescription
//
//  Synopsis:   Return a string describing the filter for the current scope
//
//  Arguments:  [hwnd]   - for BindToObject
//              [Target] - FOR_LOOK_FOR or FOR_CAPTION
//
//  Returns:    String describing the filter
//
//  History:    05-10-2000   DavidMun   Created
//
//  Notes:      The version for the caption starts with "Select ".  It lists
//              all valid object types for the current scope, regardless of
//              which ones are checked in the Look For dialog, except that
//              it will not include "other objects" or "builtin security
//              principals" unless those are the only things valid for the
//              scope.
//
//              The version for the look for readonly edit control always
//              lists exactly what is checked in the Look For dialog,
//              including "other objects" and "builtin security principals".
//
//---------------------------------------------------------------------------

String
CFilterManager::GetFilterDescription(
    HWND hwnd,
    DESCR_FOR Target) const
{
    TRACE_METHOD(CFilterManager, GetFilterDescription);

    HRESULT hr = S_OK;
    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rCurScope = rsm.GetCurScope();
    ULONG   cInserts = 0;
    WCHAR   atszInserts[MAX_CLAUSES][MAX_INSERT_STR];
    ULONG   ulPlural = 0;

    if (!m_flCurFilterFlags)
    {
        hr = rCurScope.GetResultantDefaultFilterFlags(hwnd, &m_flCurFilterFlags);
        CHECK_HRESULT(hr);
    }

    ULONG flFilter;

    if (Target == FOR_LOOK_FOR)
    {
        flFilter = m_flCurFilterFlags;
    }
    else
    {
        hr = rCurScope.GetResultantFilterFlags(hwnd, &flFilter);
        CHECK_HRESULT(hr);

        if (SUCCEEDED(hr) && rCurScope.Type() == ST_GLOBAL_CATALOG)
        {
            const CScope &rJoinedDomainScope =
                m_rop.GetScopeManager().LookupScopeByType(ST_UPLEVEL_JOINED_DOMAIN);

            if (!IsInvalid(rJoinedDomainScope))
            {
                ULONG flJoined;
                hr = rJoinedDomainScope.GetResultantFilterFlags(hwnd, &flJoined);
                CHECK_HRESULT(hr);
                flFilter |= flJoined;
            }
        }
    }

    if (!flFilter)
    {
        return L"";
    }

    ZeroMemory(atszInserts, sizeof(atszInserts));

    if (m_rop.GetInitInfoOptions() & DSOP_FLAG_MULTISELECT)
    {
        ulPlural = 1;
    }

    if (IsUplevel(rCurScope))
    {
        if (flFilter & DSOP_FILTER_USERS)
        {
            LoadStr(IDS_USER + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
            cInserts++;
        }

        if (flFilter & DSOP_FILTER_CONTACTS)
        {
            LoadStr(IDS_CONTACT + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
            cInserts++;
        }

        if (flFilter & DSOP_FILTER_COMPUTERS)
        {
            LoadStr(IDS_COMPUTER + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
            cInserts++;
        }

        if (flFilter & ALL_UPLEVEL_GROUP_FILTERS)
        {
            LoadStr(IDS_GROUP + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
            cInserts++;
        }

        if (Target == FOR_LOOK_FOR || !cInserts)
        {
            if (flFilter & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS)
            {
                LoadStr(IDS_BUILTIN_WKSP + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
                cInserts++;
            }

            if (m_rop.GetExternalCustomizer() &&
                (flFilter & DSOP_FILTER_EXTERNAL_CUSTOMIZER))
            {
                LoadStr(IDS_OTHER_OBJECT + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
                cInserts++;
            }
        }
    }
    else
    {
        if (IsDownlevelFlagSet(flFilter, DSOP_DOWNLEVEL_FILTER_USERS))
        {
            LoadStr(IDS_USER + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
            cInserts++;
        }

        if (IsDownlevelFlagSet(flFilter, DSOP_DOWNLEVEL_FILTER_COMPUTERS))
        {
            LoadStr(IDS_COMPUTER + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
            cInserts++;
        }

        if (IsDownlevelFlagSet(flFilter, ALL_DOWNLEVEL_GROUP_FILTERS))
        {
            LoadStr(IDS_GROUP + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
            cInserts++;
        }

        if (Target == FOR_LOOK_FOR || !cInserts)
        {
            if (IsDownlevelFlagSet(flFilter, ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS))
            {
                LoadStr(IDS_BUILTIN_WKSP + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
                cInserts++;
            }

            if (m_rop.GetExternalCustomizer() &&
                IsDownlevelFlagSet(flFilter, DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER))
            {
                LoadStr(IDS_OTHER_OBJECT + ulPlural, atszInserts[cInserts], MAX_INSERT_STR);
                cInserts++;
            }
        }
    }

    ASSERT(cInserts <= MAX_CLAUSES);

    String strDescription;

    if (cInserts)
    {
        int iBase;

        if (Target == FOR_LOOK_FOR)
        {
            iBase = IDS_FILTER_ONE;
        }
        else
        {
            iBase = IDS_SELECT_ONE;
        }

        int idsCaptionFmt = iBase + (cInserts - 1);
        strDescription = String::format(idsCaptionFmt,
                                        atszInserts[0],
                                        atszInserts[1],
                                        atszInserts[2],
                                        atszInserts[3],
                                        atszInserts[4],
                                        atszInserts[5]);
    }

    return strDescription;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::GetLdapFilter
//
//  Synopsis:   Return the LDAP filter which should be used to find objects
//              in scope [Scope].
//
//  Arguments:  [hwnd]  - for bind
//              [Scope] - scope for which to retrieve filter
//
//  Returns:    LDAP filter, or empty string on failure
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

String
CFilterManager::GetLdapFilter(
    HWND hwnd,
    const CScope &Scope) const
{
    TRACE_METHOD(CFilterManager, GetLdapFilter);
    ASSERT(IsUplevel(Scope));

    //
    // If external customizer supplies a filter, use that
    //

    ICustomizeDsBrowser *pExtCustomizer = m_rop.GetExternalCustomizer();

    if (pExtCustomizer)
    {
        IDsObjectPickerScope *pDsScope =
            const_cast<IDsObjectPickerScope *>
                (static_cast<const IDsObjectPickerScope *>(&Scope));
        PDSQUERYINFO pdsqi = NULL;
        HRESULT hr = pExtCustomizer->GetQueryInfoByScope(pDsScope, &pdsqi);

        String strFilter;

        if (SUCCEEDED(hr) && pdsqi)
        {
            if (pdsqi->pwzLdapQuery)
            {
                strFilter = pdsqi->pwzLdapQuery;
            }
            FreeQueryInfo(pdsqi);
        }

        if (!strFilter.empty())
        {
            return strFilter;
        }
    }

    //
    // External customizer couldn't supply filter; possibly not implemented.
    // Try to generate one ourselves.
    //

    if (Scope.Type() == ST_GLOBAL_CATALOG)
    {
        const CGcScope *pGcScope = dynamic_cast<const CGcScope *>(&Scope);

        if (pGcScope)
        {
            return _GenerateGcFilter(hwnd, *pGcScope);
        }
        return L"";
    }

    ULONG ulFlags;

    HRESULT hr = GetSelectedFilterFlags(hwnd, Scope, &ulFlags);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return L"";
    }

    return _GenerateUplevelFilter(ulFlags);
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::_GenerateGcFilter
//
//  Synopsis:   Create the LDAP filter which should be used against the
//              Global Catalog.
//
//  Arguments:  [hwnd]    - for bind
//              [GcScope] - scope object representing the GC
//
//  Returns:    LDAP filter, empty string on error.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

String
CFilterManager::_GenerateGcFilter(
    HWND hwnd,
    const CGcScope &GcScope) const
{
    TRACE_METHOD(CFilterManager, _GenerateGcFilter);
    ASSERT(GcScope.Type() == ST_GLOBAL_CATALOG);

    const CScopeManager &sm = m_rop.GetScopeManager();
    const CLdapDomainScope *pJoinedScope = dynamic_cast<const CLdapDomainScope *>
        (&sm.LookupScopeByType(ST_UPLEVEL_JOINED_DOMAIN));

    ASSERT(!pJoinedScope || pJoinedScope->Type() == ST_UPLEVEL_JOINED_DOMAIN);

    ULONG flSelectedGcFlags = 0;

    HRESULT hr = GetSelectedFilterFlags(hwnd, GcScope, &flSelectedGcFlags);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return L"";
    }

    ASSERT(flSelectedGcFlags);

    flSelectedGcFlags |= DSOP_FILTER_INCLUDE_ADVANCED_VIEW;

    //
    // If caller did not ask for joined domain, or if caller did but it
    // isn't in the scope list for some reason, just treat GC as any other
    // uplevel scope.
    //

    if (!pJoinedScope)
    {
        return _GenerateUplevelFilter(flSelectedGcFlags);
    }

    //
    // If joined domain and GC query are identical, then again the
    // GC scope is no different from any other uplevel scope.
    //
    // N.B.: using private version _GetSelectedFilterFlags here.  The
    // private version fills flSelectedJoinedFlags with the intersection
    // of the classes of objects the user checked in the Look For dialog and
    // the allowed classes in the joined domain scope.
    //
    // This intersection may be 0.  The public version of the API would then
    // set flSelectedJoinedFlags to the default flags for the scope.
    //
    // We don't want the public api's behavior here.  Assume the GC scope
    // allows computers and groups, and the joined domain allows groups. If
    // the only selected class in Look For is computers, we don't want to
    // get back the default of groups for the joined domain, since that would
    // cause us to generate a combined filter for computers and groups.
    //
    // Instead we get back a 0 for the joined domain and ignore it, simply
    // generating a filter for computers.
    //

    ULONG flSelectedJoinedFlags;

    hr = _GetSelectedFilterFlags(hwnd, *pJoinedScope, &flSelectedJoinedFlags);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return L"";
    }

    flSelectedJoinedFlags |= DSOP_FILTER_INCLUDE_ADVANCED_VIEW;

    //
    // The builtin group and well known principal flags don't have any
    // affect on the LDAP filters, since they represent objects which are
    // added in by AddObjects.  So strip those flags out before comparing
    // joined and GC flags.
    //

    ULONG flSelectedJoinedLessAddons = flSelectedJoinedFlags &
        ~(DSOP_FILTER_BUILTIN_GROUPS | DSOP_FILTER_WELL_KNOWN_PRINCIPALS);

    ULONG flSelectedGcLessAddons = flSelectedGcFlags &
        ~(DSOP_FILTER_BUILTIN_GROUPS | DSOP_FILTER_WELL_KNOWN_PRINCIPALS);

    //
    // If the joined domain now has nothing to contribute to the GC query,
    // ignore it.
    //

    if (!(flSelectedJoinedLessAddons & ~DSOP_FILTER_INCLUDE_ADVANCED_VIEW))
    {
        return _GenerateUplevelFilter(flSelectedGcFlags);
    }

    //
    // If the flags remaining for the GC and joined domain are the same,
    // then we can generate just the GC filter.
    //

    if (flSelectedJoinedLessAddons == flSelectedGcLessAddons)
    {
        return _GenerateUplevelFilter(flSelectedGcFlags);
    }

    //
    // The GC and Joined Domain flags are different, but if the contacts
    // clause is filtered out, they still might amount to the same thing.
    //

    String strJoinedFilter;
    String strGcFilter;

    BOOL fFactorContact = FALSE;

    if (flSelectedJoinedFlags & DSOP_FILTER_CONTACTS)
    {
        ASSERT(flSelectedGcFlags & DSOP_FILTER_CONTACTS);
        fFactorContact = TRUE;
    }
    else
    {
        ASSERT(!(flSelectedGcFlags & DSOP_FILTER_CONTACTS));
    }

    if (fFactorContact)
    {
        ULONG flFactoredJoined;
        ULONG flFactoredGc;

        flFactoredJoined = flSelectedJoinedFlags & ~DSOP_FILTER_CONTACTS;
        flFactoredGc = flSelectedGcFlags & ~DSOP_FILTER_CONTACTS;

        strJoinedFilter = _GenerateUplevelFilter(flFactoredJoined);

        //
        // If, because of factoring, the joined domain filter is empty,
        // just use GC filter
        //

        if (strJoinedFilter.empty())
        {
            return _GenerateUplevelFilter(flSelectedGcFlags);
        }

        //
        // The factored joined filter is NOT empty.  Generated the
        // factored GC filter.  This may be empty; if it is the caller is
        // forcing us to do a search on the GC for joined domain only objects.
        //
        // If so, emit a warning, because it would be much more efficient for
        // the caller to simply not include the GC scope, and have the user
        // go to the joined domain to query the joined domain.
        //

        strGcFilter = _GenerateUplevelFilter(flFactoredGc);

        if (strGcFilter.empty())
        {
            Dbg(DEB_WARN,
                "Warning: caller forcing joined domain only query of GC, this is inefficient\n");
        }
    }
    else
    {
        //
        // Don't have to factor out contact clause, so just use the stock
        // queries.
        //

        strJoinedFilter = _GenerateUplevelFilter(flSelectedJoinedFlags);
        strGcFilter = _GenerateUplevelFilter(flSelectedGcFlags);
    }


    //
    // At this point strJoinedFilter and strGcFilter differ.  The joined
    // filter is nonempty and must be anded with a clause that restricts it
    // to objects in the GC that have a SID associated with the joined domain.
    //
    // The GC filter may or may not be empty.
    //

    String strCombinedFilter;

    do
    {
        //
        // Now combine the two to create a single ldap filter which returns
        // only the correct objects from the joined domain and the both+
        // native mode objects from all other domains in the enterprise.
        //
        // They're combined using the domain sid of the joined domain.
        //

        RpIADs rpADs;
        Variant varSid;
        String strADsPath;

        hr = pJoinedScope->GetADsPath(hwnd, &strADsPath);

        if (FAILED(hr))
        {
            Dbg(DEB_TRACE,
                "Scope '%ws' has no path, returning\n",
                pJoinedScope->GetDisplayName());
            break;
        }

        hr = g_pBinder->BindToObject(hwnd,
                                     strADsPath.c_str(),
                                     IID_IADs,
                                     (void**)&rpADs);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = rpADs->Get((PWSTR)c_wzObjectSidAttr, &varSid);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // _GenerateCombinedGcFilter handles the case where strGcFilter is
        // empty.
        //

        strCombinedFilter = _GenerateCombinedGcFilter(&varSid,
                                                      strJoinedFilter,
                                                      strGcFilter);

        //
        // If there are no factored clauses to wrap the query with,
        // we're done.
        //

        if (!fFactorContact)
        {
            break;
        }

        String strFactoringPrefix;

        if (fFactorContact)
        {
            strFactoringPrefix += L"(|";
            strFactoringPrefix += c_wzContactQuery;
        }

        strCombinedFilter.insert(0, strFactoringPrefix);

        if (fFactorContact)
        {
            strCombinedFilter += L")";
        }
    } while (0);

    return strCombinedFilter;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::_GenerateCombinedGcFilter
//
//  Synopsis:   Generate an LDAP filter which combines the filters of the
//              Global Catalog and the joined domain scopes.
//
//  Arguments:  [pvarDomainSid]   - SID of joined domain
//              [strJoinedFilter] - LDAP filter of joined domain
//              [strGcFilter]     - LDAP filter of GC
//
//  Returns:    Combined LDAP filter
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

String
CFilterManager::_GenerateCombinedGcFilter(
    VARIANT *pvarDomainSid,
    const String &strJoinedFilter,
    const String &strGcFilter) const
{
    TRACE_METHOD(CFilterManager, _GenerateCombinedGcFilter);

    String strResultFilter;

    do
    {
        CSid    sidDomain(pvarDomainSid);

        const String strFirstRid(L"\\00\\00\\00\\00");
        const String strLastRid(L"\\ff\\ff\\ff\\ff");

        String strFirstDomainSid =
                    sidDomain.GetSidAndRidAsByteStr(strFirstRid);

        String strLastDomainSid =
                    sidDomain.GetSidAndRidAsByteStr(strLastRid);

        String strSidInRange =
                    L"(&"
                     L"(objectSid>=" + strFirstDomainSid + L")" +
                     L"(objectSid<=" + strLastDomainSid  + L")" +
                    L")";

        if (!strGcFilter.empty())
        {
            //
            // (|
            //  (&
            //   (joined domain query)
            //   (objectSid in joined domain sid range)
            //  )
            //  (&
            //   (GC query)
            //   (objectSid below joined domain sid range)
            //  )
            //  (&
            //   (GC query)
            //   (objectSid above joined domain sid range)
            //  )
            // )
            //

            CSid sidBelow = sidDomain;

            sidBelow.Decrement();

            String strLastDomainSidBelow =
                        sidBelow.GetSidAndRidAsByteStr(strLastRid);

            String strSidBelowRange =
                        L"(objectSid<=" + strLastDomainSidBelow + L")";

            CSid sidAbove = sidDomain;

            sidAbove.Increment();

            String strFirstDomainSidAbove =
                        sidAbove.GetSidAndRidAsByteStr(strFirstRid);

            String strSidAboveRange =
                        L"(objectSid>=" + strFirstDomainSidAbove + L")";

            strResultFilter = L"(|"
                               L"(&" +
                                  strJoinedFilter +
                                  strSidInRange +
                               L")"
                               L"(&" +
                                  strGcFilter +
                                  strSidBelowRange +
                               L")"
                               L"(&" +
                                  strGcFilter +
                                  strSidAboveRange +
                               L")"
                              L")";
        }
        else
        {
            //
            // (&
            //  (joined domain query)
            //  (objectSid in joined domain sid range)
            // )
            //


            strResultFilter = L"(&" +
                                 strJoinedFilter +
                                 strSidInRange +
                              L")";
        }
    }
    while (0);

    return strResultFilter;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::_GenerateUplevelFilter
//
//  Synopsis:   Return an LDAP filter for the DSOP_FILTER_* bits set in
//              [flFilter].
//
//  Arguments:  [flFilter] - DSOP_FILTER_* bits
//
//  Returns:    LDAP filter
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

String
CFilterManager::_GenerateUplevelFilter(
    ULONG flFilter) const
{
    TRACE_METHOD(CFilterManager, _GenerateUplevelFilter);

    String  strQuery;
    ULONG   cOuterTerms = 0;

    strQuery = _GenerateUplevelGroupFilter(flFilter);


    if (!strQuery.empty())
    {
        cOuterTerms++;
    }

    if (flFilter & DSOP_FILTER_USERS)
    {
        strQuery += c_wzUserQuery;
        cOuterTerms++;

        if (cOuterTerms > 1)
        {
            strQuery.insert(0, L"(|");
            strQuery += L")";
            cOuterTerms = 1;
        }
    }

    if (flFilter & DSOP_FILTER_CONTACTS)
    {
        strQuery += c_wzContactQuery;
        cOuterTerms++;

        if (cOuterTerms > 1)
        {
            strQuery.insert(0, L"(|");
            strQuery += L")";
            cOuterTerms = 1;
        }
    }

    if (flFilter & DSOP_FILTER_COMPUTERS)
    {
        strQuery += c_wzComputerQuery;
        cOuterTerms++;

        if (cOuterTerms > 1)
        {
            strQuery.insert(0, L"(|");
            strQuery += L")";
            cOuterTerms = 1;
        }
    }

    ASSERT(cOuterTerms == 0 || cOuterTerms == 1);

    if (cOuterTerms && !(flFilter & DSOP_FILTER_INCLUDE_ADVANCED_VIEW))
    {
        strQuery.insert(0, c_wzNotShowInAdvancedViewOnly);
        strQuery.insert(0, L"(&");
        strQuery += L")";
    }

    return strQuery;
}




//+--------------------------------------------------------------------------
//
//  Function:   _GenerateUplevelGroupFilter
//
//  Synopsis:   Fill *[ppwzGroupQuery] with a new allocated string containing
//              a query representing the flags in [ulFlags].
//
//  Arguments:  [ulFlags]   - UGOP_*_GROUPS and UGOP_*_GROUPS_SE
//              [pstrQuery] - filled with group query
//
//  Modifies:   *[pstrQuery]
//
//  History:    05-29-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

String
CFilterManager::_GenerateUplevelGroupFilter(
    ULONG ulFlags) const
{
    TRACE_METHOD(CFilterManager, _GenerateUplevelGroupFilter);

    ULONG flSecurityGroups = ulFlags & DSOP_ALL_UPLEVEL_SECURITY_GROUPS;
    ULONG flDistributionGroups = ulFlags & DSOP_ALL_UPLEVEL_DISTRIBUTION_GROUPS;

    ULONG flGroupType1 = 0;
    ULONG flGroupType2 = 0;
    PCWSTR pwzClauseFmt1 = NULL;
    PCWSTR pwzClauseFmt2 = NULL;
    String strQuery;

    do
    {
        if (!flSecurityGroups && !flDistributionGroups)
        {
            break;
        }

        if (flDistributionGroups == flSecurityGroups >> 1)
        {
            flGroupType1 = _FlagsToGroupTypeBits(flDistributionGroups);
            pwzClauseFmt1 = c_wzGroupBoth;
        }
        else if (!flDistributionGroups)
        {
            flGroupType1 = _FlagsToGroupTypeBits(flSecurityGroups);
            pwzClauseFmt1 = c_wzGroupSE;
        }
        else if (!flSecurityGroups)
        {
            flGroupType1 = _FlagsToGroupTypeBits(flDistributionGroups);
            pwzClauseFmt1 = c_wzGroupNonSE;
        }
        else
        {
            flGroupType1 = _FlagsToGroupTypeBits(flDistributionGroups);
            pwzClauseFmt1 = c_wzGroupNonSE;

            flGroupType2 = _FlagsToGroupTypeBits(flSecurityGroups);
            pwzClauseFmt2 = c_wzGroupSE;
        }

        ASSERT(pwzClauseFmt1);

        WCHAR wzGroupType1Bits[20];
        wsprintf(wzGroupType1Bits, L"%u", flGroupType1);

        String strInsert1(String::format(pwzClauseFmt1, wzGroupType1Bits));

        if (pwzClauseFmt2)
        {
            WCHAR wzGroupType2Bits[20];
            wsprintf(wzGroupType2Bits, L"%u", flGroupType2);

            String strInsert2(String::format(pwzClauseFmt2, wzGroupType2Bits));

            strQuery = L"(|";
            strQuery += strInsert1;
            strQuery += strInsert2;
            strQuery += L")";
        }
        else
        {
            strQuery = strInsert1;
        }
    } while (0);

    return strQuery;
}




//+--------------------------------------------------------------------------
//
//  Function:   _FlagsToGroupTypeBits
//
//  Synopsis:   Convert object picker bitflags for the six flavors of uplevel
//              group to ntsam flags for the corresponding groups, thus
//              folding security enabled and non security enabled together.
//
//  Arguments:  [ulGroups] - UGOP_GROUPS*
//
//  Returns:    GROUP_TYPE_*_GROUP bitflags
//
//  History:    05-29-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CFilterManager::_FlagsToGroupTypeBits(
    ULONG ulGroups) const
{
    ULONG   flGroupBits = 0;

    if (ulGroups & (DSOP_FILTER_UNIVERSAL_GROUPS_DL | DSOP_FILTER_UNIVERSAL_GROUPS_SE))
    {
        flGroupBits |= GROUP_TYPE_UNIVERSAL_GROUP;
    }

    if (ulGroups & (DSOP_FILTER_GLOBAL_GROUPS_DL | DSOP_FILTER_GLOBAL_GROUPS_SE))
    {
        flGroupBits |= GROUP_TYPE_ACCOUNT_GROUP;
    }

    if (ulGroups & (DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE))
    {
        flGroupBits |= GROUP_TYPE_RESOURCE_GROUP;
    }

    ASSERT(flGroupBits);

    return flGroupBits;
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::GetWinNtFilter
//
//  Synopsis:   Fill vector pointed to by [pvs] with the class strings to
//              pass to ADsBuildVarArrayStr (see CQueryEngine).
//
//  Arguments:  [hwnd]  - for bind
//              [Scope] - downlevel scope for which to return classes to
//                          enumerate
//              [pvs]   - points to vector which is cleared and filled
//                          with class names.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CFilterManager::GetWinNtFilter(
    HWND hwnd,
    const CScope &Scope,
    vector<String> *pvs) const
{
    TRACE_METHOD(CFilterManager, GetWinNtFilter);
    ASSERT(pvs);

    pvs->clear();

    if (!IsDownlevel(Scope))
    {
        return;
    }

    ULONG flFilter;
    HRESULT hr = GetSelectedFilterFlags(hwnd, Scope, &flFilter);
    CHECK_HRESULT(hr);

    if (FAILED(hr) || !flFilter)
    {
        return;
    }

    ASSERT(flFilter & DOWNLEVEL_FILTER_BIT);

    if ((flFilter & DSOP_DOWNLEVEL_FILTER_USERS) ==
        DSOP_DOWNLEVEL_FILTER_USERS)
    {
        pvs->push_back(c_wzUserObjectClass);
    }

    if ((flFilter & DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS) ==
        DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS ||
        (flFilter & DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS) ==
        DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS)
    {
        pvs->push_back(c_wzGroupObjectClass);
    }

    if ((flFilter & DSOP_DOWNLEVEL_FILTER_COMPUTERS) ==
        DSOP_DOWNLEVEL_FILTER_COMPUTERS)
    {
        pvs->push_back(c_wzComputerObjectClass);
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::DoLookForDialog
//
//  Synopsis:   Invoke the modal Look For dialog
//
//  Arguments:  [hwndParent] - parent of modal dialog
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CFilterManager::DoLookForDialog(
    HWND hwndParent) const
{
    TRACE_METHOD(CFilterManager, DoLookForDialog);

    CLookForDlg  LookForDlg(m_rop);

    ASSERT(m_flCurFilterFlags);
    LookForDlg.DoModalDlg(hwndParent, m_flCurFilterFlags);

    m_flCurFilterFlags = LookForDlg.GetSelectedFlags();
}




//+--------------------------------------------------------------------------
//
//  Member:     CFilterManager::Clear
//
//  Synopsis:   Reset internal state.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CFilterManager::Clear()
{
    TRACE_METHOD(CFilterManager, Clear);
    m_flCurFilterFlags = 0;
	m_bLookForDirty = false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\helpids.h ===
//Object Selection dialog box

#define IDH_LOOK_FOR_LV                         322
#define IDH_LOOK_IN_TV                          323
#define IDH_ADD_BTN                             324
#define IDH_ADVANCED_PB                         325
#define IDH_CHECK_NAMES_PB                      326
#define IDH_CLAUSE_LIST                         327
#define IDH_COLUMNS_PB                          328
#define IDH_DESCRIPTION_COMBO                   329
#define IDH_DESCRIPTION_EDIT                    330
#define IDH_DISABLED_CKBOX                      331
#define IDH_EDIT_BTN                            332
#define IDH_FIND_NOW_PB                         333
#define IDH_INSTRUCTION_LBL                     334
#define IDH_LASTLOGON_COMBO                     335
#define IDH_LOOK_FOR_EDIT                       336
#define IDH_LOOK_FOR_PB                         337
#define IDH_LOOK_IN_EDIT                        338
#define IDH_LOOK_IN_PB                          339
#define IDH_NAME_COMBO                          340
#define IDH_NAME_EDIT                           341
#define IDH_NAME_LBL                            342
#define IDH_NON_EXPIRING_CKBOX                  343
#define IDH_QUERY_LISTVIEW                      344
#define IDH_REMOVE_BTN                          345
#define IDH_RICHEDIT                            346
#define IDH_STOP_PB                             347
#define IDH_AVAILABLE_LIST                      348
#define IDH_ADD_COL_BTN                         349
#define IDH_REMOVE_COL_BTN                      350
#define IDH_SHOWN_LIST                          351
#define IDH_LASTLOGON_LBL                       352
#define IDH_DESCRIPTION_LBL                     353    
#define IDH_NAME_LBL1                            354
#define IDH_MATCHING_LIST                       1180
#define IDH_CORRECT_RADIO                       1150
#define IDH_CORRECT_EDIT                        1160
#define IDH_REMOVE_RADIO                        1170
#define IDH_NETPASS_CONNECTAS                   1110  // edit control and connect as static
#define IDH_NETPASS_PASSWORD                    1120
#define IDH_NETPASS_OK                          1130
#define IDH_NETPASS_CANCEL                      1140
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\imperson.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       imperson.cxx
//
//  Contents:   Class to make current thread impersonate Anonymous.
//
//  Classes:    CImpersonateAnon
//
//  History:    09-03-1999   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop




//+--------------------------------------------------------------------------
//
//  Member:     CImpersonateAnon::CImpersonateAnon
//
//  Synopsis:   Start impersonating Anonymous on the current thread.
//
//  History:    09-03-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CImpersonateAnon::CImpersonateAnon()
{
    TRACE_CONSTRUCTOR(CImpersonateAnon);

    m_fImpersonatingAnonymous = FALSE;
    m_hCurrentToken = NULL;
    NTSTATUS ntstatus;

    do
    {
        //
        // Check to see if we're already impersonating
        //

        ntstatus = NtOpenThreadToken(NtCurrentThread(),
                                    TOKEN_IMPERSONATE,
                                    TRUE,       // as self to ensure we never fail
                                    &m_hCurrentToken);

        if (ntstatus == STATUS_NO_TOKEN)
        {
            // We're not already impersonating

            m_hCurrentToken = NULL;
        }
        else if (!NT_SUCCESS(ntstatus))
        {
            DBG_OUT_LRESULT(ntstatus);
            break;
        }

        //
        // Impersonate the anonymous token
        //
        ntstatus = NtImpersonateAnonymousToken(NtCurrentThread());

        if (!NT_SUCCESS(ntstatus))
        {
            DBG_OUT_LRESULT(ntstatus);
            break;
        }

        m_fImpersonatingAnonymous = TRUE;
    } while (0);
}



//+--------------------------------------------------------------------------
//
//  Member:     CImpersonateAnon::~CImpersonateAnon
//
//  Synopsis:   Stop impersonating Anonymous on the current thread.
//
//  History:    09-03-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CImpersonateAnon::~CImpersonateAnon()
{
    TRACE_DESTRUCTOR(CImpersonateAnon);

    if (m_fImpersonatingAnonymous)
    {
        NTSTATUS ntstatus;

        ntstatus = NtSetInformationThread(NtCurrentThread(),
                                         ThreadImpersonationToken,
                                         &m_hCurrentToken,
                                         sizeof(HANDLE));

        if (!NT_SUCCESS(ntstatus))
        {
            DBG_OUT_LRESULT(ntstatus);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\globals.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       globals.cxx
//
//  Contents:   Globals used by multiple modules
//
//  History:    06-26-1997  MarkBl  Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

ULONG CDll::s_cObjs;
ULONG CDll::s_cLocks;

#if (DBG == 1)
ULONG CDbg::s_idxTls;
#endif // (DBG == 1)


HINSTANCE               g_hinst = 0;
CBinder                *g_pBinder = NULL;
CADsPathWrapper        *g_pADsPath = NULL;
CRITICAL_SECTION        g_csGlobalVarsCreation;
WCHAR                   g_wzColumn1Format[40];
ADS_SEARCHPREF_INFO     g_aSearchPrefs[NUM_SEARCH_PREF];
ULONG                   g_cQueryLimit;
BOOL                    g_fExcludeDisabled;
HINSTANCE               g_hinstRichEdit;

// Globals required by burnslib
HINSTANCE hResourceModuleHandle;
const wchar_t* RUNTIME_NAME = L"ObjectPicker";
DWORD DEFAULT_LOGGING_OPTIONS = OUTPUT_TYPICAL;

DEBUG_DECLARE_INSTANCE_COUNTER(RefCountPointer)

#include <initguid.h>
#include <cmnquery.h>
#include <dsquery.h>
#include <dsclient.h>

#include "objselp.h"
#include <objsel.h>





//+--------------------------------------------------------------------------
//
//  Function:   InitGlobals
//
//  Synopsis:   Initialize global variables during DLL initialization
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
InitGlobals()
{
    // DllMain already set g_hinst
    hResourceModuleHandle = g_hinst;

    LoadStr(IDS_COL1FORMAT,
            g_wzColumn1Format,
            ARRAYLEN(g_wzColumn1Format),
            L"%1 (%2)");

    GetPolicySettings(&g_cQueryLimit, &g_fExcludeDisabled);

    //
    // Set a page size so we'll get all objects even if there are
    // more than 1000.
    //

    g_aSearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
    g_aSearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
    g_aSearchPrefs[0].vValue.Integer = DIR_SEARCH_PAGE_SIZE;

    //
    // Always follow aliases
    //

    g_aSearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_DEREF_ALIASES;
    g_aSearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
    g_aSearchPrefs[1].vValue.Integer = ADS_DEREF_ALWAYS;

    //
    // Search down the subtree
    //

    g_aSearchPrefs[2].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
    g_aSearchPrefs[2].vValue.dwType = ADSTYPE_INTEGER;
    g_aSearchPrefs[2].vValue.Integer = ADS_SCOPE_SUBTREE;

    //
    // Turn off client side caching of results, since we do that for the
    // virtual listview anyway.
    //

    g_aSearchPrefs[3].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
    g_aSearchPrefs[3].vValue.dwType = ADSTYPE_BOOLEAN;
    g_aSearchPrefs[3].vValue.Integer = 0;

    //
    // Limit time spent on each page so that call (hopefully) doesn't
    // block for too long.
    //

    g_aSearchPrefs[4].dwSearchPref = ADS_SEARCHPREF_PAGED_TIME_LIMIT;
    g_aSearchPrefs[4].vValue.dwType = ADSTYPE_INTEGER;
    g_aSearchPrefs[4].vValue.Integer = DIR_SEARCH_PAGE_TIME_LIMIT;

    ASSERT(!g_hinstRichEdit);
    g_hinstRichEdit = LoadLibrary(L"riched32.dll");
}



//+--------------------------------------------------------------------------
//
//  Function:   FreeGlobals
//
//  Synopsis:   Free resources held in global variables during DLL shutdown.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
FreeGlobals()
{
    TRACE_FUNCTION(FreeGlobals);

    if (g_hinstRichEdit)
    {
        VERIFY(FreeLibrary(g_hinstRichEdit));
        g_hinstRichEdit = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\lookfordlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       LookForDlg.cxx
//
//  Contents:   CLookForDlg implementation
//
//  Classes:    CLookForDlg
//
//  History:    01-28-2000   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

static ULONG
s_aulHelpIds[] =
{
    IDC_LOOK_FOR_LV,            IDH_LOOK_FOR_LV,
    0,0
};


//+--------------------------------------------------------------------------
//
//  Member:     CLookForDlg::CLookForDlg
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - owning object picker instance
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CLookForDlg::CLookForDlg(
    const CObjectPicker &rop):
        m_rop(rop),
        m_flSelected(0),
        m_rsm(rop.GetScopeManager())
{
    TRACE_CONSTRUCTOR(CLookForDlg);
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookForDlg::~CLookForDlg
//
//  Synopsis:   dtor
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CLookForDlg::~CLookForDlg()
{
    TRACE_DESTRUCTOR(CLookForDlg);
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookForDlg::_OnInit
//
//  Synopsis:   Initialize the dialog
//
//  Arguments:  [pfSetFocus] - unused
//
//  Returns:    S_OK
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CLookForDlg::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CLookForDlg, _OnInit);

    //
    // Check to see if the advanced dialog is open, and if so whether the
    // query builder tab contains any clauses.  If it does, present a
    // dialog that gives the user the choice of aborting the LookFor
    // dialog, or clearing the clause list in the query builder tab and
    // proceeding with the LookFor dialog invocation.
    //
    // This is required because the query builder code assumes that the
    // look for selections will not change once the user has started building
    // a query.
    //

#ifdef QUERY_BUILDER
    if (m_rop.IsQueryBuilderTabNonEmpty())
    {
        String strText = String::load(IDS_CLEAR_QB_TEXT);
        String strCaption = String::load(IDS_CLEAR_QB_CAPTION);

        int iRet = MessageBox(m_hwnd,
                              strText.c_str(),
                              strCaption.c_str(),
                              MB_YESNO | MB_ICONWARNING);

        if (iRet == IDYES)
        {
            m_rop.ClearQueryBuilderTab();
        }
        else
        {
            EndDialog(GetHwnd(), FALSE);
            return S_OK;
        }
    }
#endif

    //
    // put listview in checkbox style
    //

    ListView_SetExtendedListViewStyleEx(_hCtrl(IDC_LOOK_FOR_LV),
                                        LVS_EX_CHECKBOXES,
                                        LVS_EX_CHECKBOXES);

    //
    // Get current scope and ask for the filter flags which apply to it.
    // Global catalog objects actually include the ones caller specified for
    // the GC plus the ones specified for the joined domain.
    //

    const CScope &rsCurScope = m_rsm.GetCurScope();
    ULONG flResultantFilterFlags;
    HRESULT hr = rsCurScope.GetResultantFilterFlags(m_hwnd,
                                                    &flResultantFilterFlags);
    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    if (rsCurScope.Type() == ST_GLOBAL_CATALOG)
    {
        const CScope &rJoinedDomainScope =
            m_rsm.LookupScopeByType(ST_UPLEVEL_JOINED_DOMAIN);

        if (!IsInvalid(rJoinedDomainScope))
        {
            ULONG flJoined;

            hr = rJoinedDomainScope.GetResultantFilterFlags(m_hwnd, &flJoined);

                if (FAILED(hr))
            {
                DBG_OUT_HRESULT(hr);
                return hr;
            }
            flResultantFilterFlags |= flJoined;
        }
    }


    //
    // Create a copy of the Attribute Manager's image list and add the icon
    // for "other" (customizer supplied) objects to it.
    //

    HWND hwndLv = _hCtrl(IDC_LOOK_FOR_LV);
    HIMAGELIST hImageList = NULL;
    HIMAGELIST himlAttrMgr = NULL;

    const CAttributeManager &ram = m_rop.GetAttributeManager();
    hr = ram.GetImageList(&himlAttrMgr);

    int iUser = -1;
    int iGroup = -1;
    int iComputer = -1;
    int iContact = -1;
    int iOther = -1;
    ULONG ulGetIconFlags = 0;

    if (IsDownlevel(rsCurScope))
    {
        ulGetIconFlags |= DSOP_GETICON_FLAG_DOWNLEVEL;
    }

    if (SUCCEEDED(hr))
    {
        hr = ram.GetIconIndexFromClass(m_hwnd,
                                       c_wzUserObjectClass,
                                       ulGetIconFlags,
                                       &iUser);
        if(SUCCEEDED(hr) || !IsCredError(hr))
        {
            hr = ram.GetIconIndexFromClass(m_hwnd,
                                           c_wzGroupObjectClass,
                                           ulGetIconFlags,
                                           &iGroup);
        }
        if(SUCCEEDED(hr) || !IsCredError(hr))
        {
            hr = ram.GetIconIndexFromClass(m_hwnd,
                                           c_wzComputerObjectClass,
                                           ulGetIconFlags,
                                           &iComputer);
        }

        if ((SUCCEEDED(hr) || !IsCredError(hr)) && 
            !IsDownlevel(rsCurScope) &&
            ConfigSupportsDs(m_rop.GetTargetComputerConfig()))
        {
            ram.GetIconIndexFromClass(m_hwnd, c_wzContactObjectClass, 0, &iContact);
        }

        hImageList = ImageList_Duplicate(himlAttrMgr);

        if (hImageList)
        {
            ListView_SetImageList(hwndLv, hImageList, LVSIL_SMALL);

            // Use the directory icon for "other" (customizer supplied) objects

            HICON hicoOther = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SCOPE_DIRECTORY));

            if (hicoOther)
            {
                iOther = ImageList_AddIcon(hImageList, hicoOther);
            }
        }
        else
        {
            DBG_OUT_LASTERROR;
        }
    }
    else
    {
        DBG_OUT_HRESULT(hr);
        hr = S_OK;  // not having icons isn't a fatal error
    }

    //
    // Add a single column to the listview
    //

    LV_COLUMN   lvc;
    RECT        rcLv;

    VERIFY(GetClientRect(hwndLv, &rcLv));
    ZeroMemory(&lvc, sizeof lvc);
    lvc.mask = LVCF_FMT | LVCF_WIDTH;
    lvc.fmt  = LVCFMT_LEFT;
    lvc.cx = rcLv.right;
    ListView_InsertColumn(hwndLv, 0, &lvc);

    //
    // Add items to listview for each class represented by a nonzero filter bit
    //

    if (IsUplevel(rsCurScope))
    {
        _AddClassToLv(flResultantFilterFlags, DSOP_FILTER_USERS,              IDS_USERS, iUser);
        _AddClassToLv(flResultantFilterFlags, ALL_UPLEVEL_GROUP_FILTERS,      IDS_GROUPS, iGroup);
        _AddClassToLv(flResultantFilterFlags, DSOP_FILTER_COMPUTERS,          IDS_COMPUTERS, iComputer);
        _AddClassToLv(flResultantFilterFlags, DSOP_FILTER_CONTACTS,           IDS_CONTACTS, iContact);
        _AddClassToLv(flResultantFilterFlags, ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS, IDS_BUILTIN_WKSPS, iGroup);
        _AddClassToLv(flResultantFilterFlags, DSOP_FILTER_EXTERNAL_CUSTOMIZER, IDS_OTHER_OBJECTS, iOther);
    }
    else
    {
        _AddClassToLv(flResultantFilterFlags, DSOP_DOWNLEVEL_FILTER_USERS,     IDS_USERS, iUser);
        _AddClassToLv(flResultantFilterFlags, ALL_DOWNLEVEL_GROUP_FILTERS,     IDS_GROUPS, iGroup);
        _AddClassToLv(flResultantFilterFlags, DSOP_DOWNLEVEL_FILTER_COMPUTERS, IDS_COMPUTERS, iComputer);
        _AddClassToLv(flResultantFilterFlags, ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS,IDS_BUILTIN_WKSPS, iGroup);
        _AddClassToLv(flResultantFilterFlags, DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER, IDS_OTHER_OBJECTS, iOther);
    }

    //
    // Make the first item in the listview have the focus
    //

    ListView_SetItemState(hwndLv,
                          0,
                          LVIS_FOCUSED | LVIS_SELECTED,
                          LVIS_FOCUSED | LVIS_SELECTED);
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookForDlg::_AddClassToLv
//
//  Synopsis:
//
//  Arguments:  [flResultantFilterFlags] - all legal filter flags for the
//                                          current scope
//              [flMustBeSet]            - flag which must be set in
//                                          [flResultantFilterFlags] for
//                                          [ids] to be added to LV.
//              [ids]                    - id of class name
//
//  History:    02-28-2000   davidmun   Created
//
//---------------------------------------------------------------------------

void
CLookForDlg::_AddClassToLv(
    ULONG flResultantFilterFlags,
    ULONG flMustBeSet,
    ULONG ids,
    int iImage)
{
    //
    // If working with downlevel filter flags then msb is set, so bitwise and
    // of flResultantFilterFlags and flMustBeSet will always be nonzero;
    // there must be some bit other than the DOWNLEVEL_FILTER_BIT set for
    // this item to qualify.
    //
    // If working with uplevel flags then DOWNLEVEL_FILTER_BIT is already 0
    // so masking it off doesn't affect anything.
    //

    if (!((flResultantFilterFlags & flMustBeSet) & ~DOWNLEVEL_FILTER_BIT))
    {
        return;
    }

    LVITEM  lvi;

    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
    String str = String::load(static_cast<unsigned>(ids), g_hinst);
    lvi.pszText = const_cast<PWSTR>(str.c_str());
    lvi.lParam = (LPARAM) (flResultantFilterFlags & flMustBeSet);
    lvi.iImage = iImage;

    HWND hwndLv = _hCtrl(IDC_LOOK_FOR_LV);
    int iItem = ListView_InsertItem(hwndLv, &lvi);

    if (iItem == -1)
    {
        DBG_OUT_LASTERROR;
        return;
    }

    //
    // If this class is one that was selected on entry, turn on the check
    // mark next to it.
    //

    if (flMustBeSet & m_flSelected & ~DOWNLEVEL_FILTER_BIT)
    {
        ListView_SetCheckState(hwndLv, iItem, TRUE);
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CLookForDlg::_OnNotify
//
//  Synopsis:   Handle listview item changed notifications
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CLookForDlg::_OnNotify(
    WPARAM wParam,
    LPARAM lParam)
{
    //TRACE_METHOD(CLookForDlg, _OnNotify);

    LPNMLISTVIEW pnmlv = reinterpret_cast<LPNMLISTVIEW> (lParam);
    BOOL         fReturn = FALSE;

    switch (pnmlv->hdr.code)
    {
    case LVN_ITEMCHANGED:
        EnableWindow(_hCtrl(IDOK), _IsSomethingSelected());
        break;
    }

    return fReturn;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookForDlg::_IsSomethingSelected
//
//  Synopsis:   Return TRUE if the checkbox is checked for any of the
//              items in the listview.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CLookForDlg::_IsSomethingSelected() const
{
    HWND hwndLv = _hCtrl(IDC_LOOK_FOR_LV);
    int cItems = ListView_GetItemCount(hwndLv);
    ASSERT(cItems > 0);
    int i;

    for (i = 0; i < cItems; i++)
    {
        if (ListView_GetCheckState(hwndLv, static_cast<UINT>(i)))
        {
            return TRUE;
        }
    }
    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookForDlg::_OnCommand
//
//  Synopsis:   Handle WM_COMMAND messages
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CLookForDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fHandled = TRUE;

    switch (LOWORD(wParam))
    {
    case IDOK:
        _UpdateSelectedFlags();
#if (DBG == 1)
        Dbg(DEB_TRACE,
            "UA: (LookForDlg) hit OK, selected classes are %ws\n",
             DbgGetFilterDescr(m_rop, m_flSelected).c_str());
#endif // (DBG == 1)
		m_rop.GetFilterManager().SetLookForDirty(true);
        EndDialog(GetHwnd(), FALSE);
        break;

    case IDCANCEL:
        Dbg(DEB_TRACE, "UA: (LookForDlg) hit Cancel\n");
        EndDialog(GetHwnd(), FALSE);
        break;

    default:
        fHandled = FALSE;
        Dbg(DEB_WARN,
            "CLookForDlg WM_COMMAND code=%#x, id=%#x, hwnd=%#x\n",
            HIWORD(wParam),
            LOWORD(wParam),
            lParam);
        break;
    }

    return fHandled;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookForDlg::_UpdateSelectedFlags
//
//  Synopsis:   Read the selected flags from the listview
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CLookForDlg::_UpdateSelectedFlags()
{
    TRACE_METHOD(CLookForDlg, _UpdateSelectedFlags);

    HWND hwndLv = _hCtrl(IDC_LOOK_FOR_LV);
    int cItems = ListView_GetItemCount(hwndLv);
    ASSERT(cItems > 0);
    int i;

    //
    // Reset the selected flags.  Some flags that apply to the current
    // scope's filters are not stored in the listview, namely
    // DSOP_FILTER_INCLUDE_ADVANCED_VIEW for uplevel and
    // DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS for downlevel.  If those
    // are set for the current scope, make sure to preserve them.
    //

    if (IsDownlevel(m_rsm.GetCurScope()))
    {
        if (IsDownlevelFlagSet(m_flSelected,
                               DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS))
        {
            m_flSelected = DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS;
        }
        else
        {
            m_flSelected = 0;
        }
    }
    else
    {
        m_flSelected &= DSOP_FILTER_INCLUDE_ADVANCED_VIEW;
    }

    //
    // Now add in the flags stored with all the checked classes
    //

    for (i = 0; i < cItems; i++)
    {
        if (ListView_GetCheckState(hwndLv, static_cast<UINT>(i)))
        {
            LVITEM lvi;

            ZeroMemory(&lvi, sizeof lvi);
            lvi.iItem = i;
            lvi.mask = LVIF_PARAM;
            VERIFY(ListView_GetItem(hwndLv, &lvi));
            m_flSelected |= lvi.lParam;
            Dbg(DEB_TRACE, "item %d selected, adding flag %#x\n", i, lvi.lParam);
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookForDlg::_OnHelp
//
//  Synopsis:   Display context sensitive help for requested item
//
//  Arguments:  [message] -
//              [wParam]  -
//              [lParam]  -
//
//  History:    10-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CLookForDlg::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CLookForDlg, _OnHelp);

    InvokeWinHelp(message, wParam, lParam, c_wzHelpFilename, s_aulHelpIds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\lookindlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       LookInDlg.cxx
//
//  Contents:   CLookInDlg implementation
//
//  Classes:    CLookInDlg
//
//  History:    01-28-2000   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


static ULONG
s_aulHelpIds[] =
{
    IDC_LOOK_IN_TV,            IDH_LOOK_IN_TV,
    0,0
};

#pragma warning(disable: 4701)  // local variable might not be init

//+--------------------------------------------------------------------------
//
//  Member:     CLookInDlg::_OnInit
//
//  Synopsis:   Handle WM_INITDIALOG
//
//  Arguments:  [pfSetFocus] - unused
//
//  Returns:    S_OK
//
//  History:    05-12-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CLookInDlg::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CLookInDlg, _OnInit);

    //
    // Init data needed for resizing.
    //
    // First translate the separation distance between controls from
    // dialog units to pixels.
    //

    RECT rc;

    rc.left = rc.top = 1;
    rc.right = DIALOG_SEPARATION_X;
    rc.bottom = DIALOG_SEPARATION_Y;
    VERIFY(MapDialogRect(m_hwnd, &rc));
    m_cxSeparation = rc.right;
    m_cySeparation = rc.bottom;

    GetClientRect(m_hwnd, &rc);

    m_cxFrameLast = rc.right;
    m_cyFrameLast = rc.bottom;

    GetWindowRect(m_hwnd, &rc);
    m_cxMin = rc.right - rc.left + 1;
    m_cyMin = rc.bottom - rc.top + 1;

    //
    // Create a copy of the Attribute Manager's image list and manually
    // add the icons for scopes which don't use the icon of some class.
    //

    HIMAGELIST himlAttrMgr = NULL;
    const CAttributeManager &ram = m_rop.GetAttributeManager();

    HRESULT hr = ram.GetImageList(&himlAttrMgr);

    if (SUCCEEDED(hr))
    {
        m_hImageList = ImageList_Create(16, 16, ILC_COLOR16 | ILC_MASK, 1, 1);

        if (m_hImageList)
        {
            //
            // copy icons from master list that came from DS--but use downlevel
            // flag for Computer, since that comes from a LoadIcon and
            // won't fail
            //

            ram.CopyIconToImageList(m_hwnd,
                                    c_wzComputerObjectClass,
                                    DSOP_GETICON_FLAG_DOWNLEVEL,
                                    &m_hImageList);

            HICON hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SCOPE_WORKGROUP));
            ImageList_AddIcon(m_hImageList, hIcon);
            hIcon = NULL;

            if (ConfigSupportsDs(m_rop.GetTargetComputerConfig()))
            {
                hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_SCOPE_DIRECTORY));
                ImageList_AddIcon(m_hImageList, hIcon);
                hIcon = NULL;
                HRESULT hr1 = S_OK;
                hr1 = ram.CopyIconToImageList(m_hwnd, c_wzDomainDnsClass, 0, &m_hImageList);
                //
                //If above failed with a cred error means, user pressed cancel for 
                //credential. No need to ask for the same credentials again.
                //Bug 188668
                //
                if(SUCCEEDED(hr1) || !IsCredError(hr1)) 
                    ram.CopyIconToImageList(m_hwnd, c_wzOuClass, 0, &m_hImageList);
            }

            //
            // associate the image list with the treeview.  note treeview does
            // not destroy the imagelist.
            //

            TreeView_SetImageList(_hCtrl(IDC_LOOK_IN_TV),
                                  m_hImageList,
                                  TVSIL_NORMAL);
        }
        else
        {
            DBG_OUT_LASTERROR;
        }
    }
    else
    {
        DBG_OUT_HRESULT(hr);
        hr = S_OK;  // not having icons isn't a fatal error
    }

    //
    // Populate the treeview with the root scopes and whatever child scopes
    // they already have.
    //

    vector<RpScope>::const_iterator it;
    vector<RpScope>::const_iterator itEnd;

    m_rop.GetScopeManager().GetRootScopeIterators(&it, &itEnd);
    _AddScopes(NULL, it, itEnd);

    //
    // If a starting scope has been specified, select it in the treeview.
    // This will automatically scroll/expand the treeview as necessary
    // to bring the selected item into view.
    //

    if (m_htiStartingScope)
    {
        TreeView_SelectItem(_hCtrl(IDC_LOOK_IN_TV), m_htiStartingScope);
    }
    return S_OK;
}
#pragma warning(default: 4701)




//+--------------------------------------------------------------------------
//
//  Member:     CLookInDlg::_AddScopes
//
//  Synopsis:   Recursively add the scopes in the container specified by
//              [itBegin] and [itEnd] to the treeview as children of node
//              specified by [hRoot].
//
//  Arguments:  [hRoot]   - treeview node under which to add scopes, or
//                           NULL to add nodes as root items
//              [itBegin] - iterator at first item to add
//              [itEnd]   - iterator just past last item to add
//
//  History:    05-12-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CLookInDlg::_AddScopes(
    HTREEITEM hRoot,
    vector<RpScope>::const_iterator itBegin,
    vector<RpScope>::const_iterator itEnd)
{
    TRACE_METHOD(CLookInDlg, _AddScopes);

    HWND hwndTv = GetDlgItem(m_hwnd, IDC_LOOK_IN_TV);
    ASSERT(IsWindow(hwndTv));
    vector<RpScope>::const_iterator it;

    for (it = itBegin; it != itEnd; it++)
    {
        //
        // Scopes generated as the result of name resolution are never
        // displayed in the UI
        //

        if (it->get()->Type() == ST_USER_ENTERED_UPLEVEL_SCOPE ||
            it->get()->Type() == ST_USER_ENTERED_DOWNLEVEL_SCOPE)
        {
            continue;
        }

		//
		//Cross Forest Scopes are generated as a result of name resolution
		//and should never be shown in the UI
		//
		if(it->get()->Type() == DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN)
		{
			const CLdapDomainScope *pLdapScope = 
					dynamic_cast<const CLdapDomainScope*>(it->get());
			if(pLdapScope->IsXForest())
				continue;
		}

        TVINSERTSTRUCT tvis;

        if (hRoot == NULL)
        {
            tvis.hParent = TVI_ROOT;
        }
        else
        {
            tvis.hParent = hRoot;
        }
        tvis.hInsertAfter = TVI_LAST;
        tvis.itemex.mask = TVIF_PARAM | TVIF_TEXT | TVIF_CHILDREN;
        tvis.itemex.lParam = reinterpret_cast<ULONG_PTR> (it->get());
        ASSERT(m_rop.GetScopeManager().IsValidScope(
            reinterpret_cast<CScope*>(tvis.itemex.lParam)));
        tvis.itemex.pszText = const_cast<PWSTR>
                                (it->get()->GetDisplayName().c_str());

        if (it->get()->MightHaveChildScopes())
        {
            tvis.itemex.cChildren = 1;
        }
        else
        {
            tvis.itemex.cChildren = 0;
        }

        if (m_hImageList)
        {
            ULONG idxScopeIcon = ULONG_MAX;

            switch (it->get()->Type())
            {
            case ST_TARGET_COMPUTER:
                idxScopeIcon = 0;
                break;

            case ST_WORKGROUP:
                idxScopeIcon = 1;
                break;

            case ST_GLOBAL_CATALOG:
                idxScopeIcon = 2;
                break;

            case ST_DOWNLEVEL_JOINED_DOMAIN:
            case ST_EXTERNAL_DOWNLEVEL_DOMAIN:
            case ST_UPLEVEL_JOINED_DOMAIN:
            case ST_ENTERPRISE_DOMAIN:
            case ST_EXTERNAL_UPLEVEL_DOMAIN:
                idxScopeIcon = 3;
                break;

            case ST_LDAP_CONTAINER:
                idxScopeIcon = 4;
                break;

            case ST_USER_ENTERED_DOWNLEVEL_SCOPE:
            case ST_USER_ENTERED_UPLEVEL_SCOPE:
                ASSERT(0 && "CLookInDlg::_AddScopes: not expecting user entered scope types to be displayed");
                break;

            default:
                break;
            }

            if (idxScopeIcon < ULONG_MAX)
            {
                tvis.itemex.mask |= (TVIF_IMAGE | TVIF_SELECTEDIMAGE);
                tvis.itemex.iImage = idxScopeIcon;
                tvis.itemex.iSelectedImage = tvis.itemex.iImage;
            }
        }

        //
        // Insert current scope in treeview
        //

        HTREEITEM hti = TreeView_InsertItem(hwndTv, &tvis);

        //
        // If we haven't already, check to see if current scope is the
        // starting scope, and if so, have the treeview expand and scroll
        // so that it is visible and select it.
        //

        if (!m_htiStartingScope)
        {
            if (m_rpSelectedScope.get())
            {
                // Caller gave us a non-NULL starting scope, use that

                if (it->get() == m_rpSelectedScope.get())
                {
                    // cur scope matches caller's starting scope
                    m_htiStartingScope = hti;
                }
            }
            else if (it->get() == &m_rop.GetScopeManager().GetStartingScope())
            {
                // cur scope matches starting scope specified by initinfo
                m_htiStartingScope = hti;
            }
        }

        //
        // If current scope already has children, recurse to add them
        //

        vector<RpScope>::const_iterator itChildBegin;
        vector<RpScope>::const_iterator itChildEnd;

        it->get()->GetChildScopeIterators(&itChildBegin, &itChildEnd);

        _AddScopes(hti, itChildBegin, itChildEnd);
    }

    //
    // Ask treeview to sort the children of the parent node to which we
    // just added some children (but don't sort stuff under the root)
    //

    if (hRoot && itBegin != itEnd)
    {
        VERIFY(TreeView_SortChildren(hwndTv, hRoot, RESERVED_MUST_BE_ZERO));
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookInDlg::_OnCommand
//
//  Synopsis:   Handle OK and Cancel
//
//  Arguments:  [wParam] - from WM_COMMAND
//              [lParam] - from WM_COMMAND
//
//  Returns:    TRUE if command handled (i.e. if it was from OK or Cancel),
//              FALSE otherwise
//
//  History:    05-12-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CLookInDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fHandled = TRUE;

    switch (LOWORD(wParam))
    {
    case IDOK:
    {
        HWND hwndTv = _hCtrl(IDC_LOOK_IN_TV);
        HTREEITEM hItem = TreeView_GetSelection(hwndTv);

        if (hItem)
        {
            BOOL fAllowClose = TRUE;

            TVITEMEX tvi;
            tvi.mask = TVIF_PARAM;
            tvi.hItem = hItem;
            tvi.lParam = 0;

            if (TreeView_GetItem(hwndTv, &tvi))
            {
                ASSERT(tvi.lParam);
                CScope *pScope = reinterpret_cast<CScope *>((ULONG_PTR)tvi.lParam);

                ASSERT(m_rop.GetScopeManager().IsValidScope(pScope));
                Dbg(DEB_TRACE,
                    "UA: (LookInDlg) hit OK, selected scope is %ws\n",
                    pScope->GetDisplayName().c_str());

                //
                // Test access to the selected scope.  If it fails, notify
                // user and do not allow changing to it.
                //

                ULONG ulFlags;
                HRESULT hr = pScope->GetResultantFilterFlags(m_hwnd,
                                                             &ulFlags);

                if (SUCCEEDED(hr))
                {
                    m_rpSelectedScope = pScope;
                }
                else
                {
                    String strError = GetErrorMessage(hr);
                    PopupMessage(m_hwnd,
                                 IDS_SCOPE_ERROR,
                                 pScope->GetDisplayName().c_str(),
                                 strError.c_str());
                    fAllowClose = FALSE;
                }
            }

            if (fAllowClose)
            {
                EndDialog(GetHwnd(), TRUE);
            }
        }
        else
        {
            Dbg(DEB_TRACE, "UA: (LookInDlg) hit OK, no selected scope\n");
            DBG_OUT_LASTERROR;
            EndDialog(GetHwnd(), FALSE);
        }
        break;
    }

    case IDCANCEL:
        Dbg(DEB_TRACE, "UA: (LookInDlg) hit Cancel\n");
        EndDialog(GetHwnd(), FALSE);
        break;

    default:
        fHandled = FALSE;
        Dbg(DEB_WARN,
            "CLookInDlg WM_COMMAND code=%#x, id=%#x, hwnd=%#x\n",
            HIWORD(wParam),
            LOWORD(wParam),
            lParam);
        break;
    }

    return fHandled;
}



//+--------------------------------------------------------------------------
//
//  Member:     CLookInDlg::_OnNotify
//
//  Synopsis:   Handle notification of changes in the dialog
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CLookInDlg::_OnNotify(
    WPARAM wParam,
    LPARAM lParam)
{
    //TRACE_METHOD(CLookInDlg, _OnNotify);

    LPNMTREEVIEW pnmtv = reinterpret_cast<LPNMTREEVIEW> (lParam);
    BOOL         fReturn = FALSE;

#if (DBG == 1)
    switch (pnmtv->hdr.code)
    {
    case TVN_ITEMEXPANDING:
    {
        PWSTR pwzAction;

        switch (pnmtv->action)
        {
        case TVE_COLLAPSE:
            pwzAction = L"collapse";
            break;

        case TVE_EXPAND:
            pwzAction = L"expand";
            break;

        case TVE_TOGGLE:
            pwzAction = L"toggle";
            break;

        case TVE_EXPANDPARTIAL:
            pwzAction = L"expand partial";
            break;

        case TVE_COLLAPSERESET:
            pwzAction = L"collapse reset";
            break;

        default:
            pwzAction = L"<undefined action code>";
            break;
        }

        String strItemName = DbgTvTextFromHandle(pnmtv->hdr.hwndFrom,
                                                 pnmtv->itemNew.hItem);

        Dbg(DEB_TRACE,
            "UA: %ws node %ws\n",
            pwzAction,
            strItemName.c_str());
        break;
    }

    case TVN_SELCHANGED:
    {
        PWSTR pwzMethod;

        switch (pnmtv->action)
        {
        case TVC_BYKEYBOARD:
            pwzMethod = L"keyboard";
            break;

        case TVC_BYMOUSE:
            pwzMethod = L"mouse";
            break;

        case TVC_UNKNOWN:
            pwzMethod = L"unknown method";
            break;

        default:
            pwzMethod = L"<undefined action code>";
            break;
        }

        String strItemName = DbgTvTextFromHandle(pnmtv->hdr.hwndFrom,
                                                 pnmtv->itemNew.hItem);

        Dbg(DEB_TRACE,
            L"UA: selected item %ws by %ws\n",
            strItemName.c_str(),
            pwzMethod);
        break;
    }
    }
#endif // (DBG == 1)


    switch (pnmtv->hdr.code)
    {
    case TVN_ITEMEXPANDING:
        if (pnmtv->action == TVE_EXPAND)
        {
            CScope *pScope = reinterpret_cast<CScope*>(pnmtv->itemNew.lParam);

            ASSERT(m_rop.GetScopeManager().IsValidScope(pScope));
            CWaitCursor Hourglass;

            vector<RpScope>::const_iterator itCur;
            vector<RpScope>::const_iterator itEnd;

            // note this means cdlg itself should dispatch to password prompt
            pScope->Expand(m_hwnd, &itCur, &itEnd);

            // now add the scope's children to the tv underneath the scope.

            if (itCur != itEnd)
            {
                _AddScopes(pnmtv->itemNew.hItem, itCur, itEnd);

                // set the expanded once flag so we know not to expand again

                TVITEMEX tvi;

                tvi.mask = TVIF_HANDLE | TVIF_STATE;
                tvi.hItem = pnmtv->itemNew.hItem;
                tvi.state = tvi.stateMask = TVIS_EXPANDEDONCE;
                TreeView_SetItem(pnmtv->hdr.hwndFrom, &tvi);
            }
            else if (!pScope->MightHaveAdditionalChildScopes()
                     && !pScope->GetCurrentImmediateChildCount())
            {
                // no children, get rid of plus sign for this item

                TVITEMEX tvi;

                tvi.mask = TVIF_HANDLE | TVIF_CHILDREN;
                tvi.cChildren = 0;
                tvi.hItem = pnmtv->itemNew.hItem;
                TreeView_SetItem(pnmtv->hdr.hwndFrom, &tvi);
				RedrawWindow(pnmtv->hdr.hwndFrom, NULL, NULL, RDW_ERASE | RDW_INVALIDATE);
            }
        }
        break;
    }

    return fReturn;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookInDlg::_OnSysColorChange
//
//  Synopsis:   Forward the system color change notification message to the
//              treeview.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CLookInDlg::_OnSysColorChange()
{
    TRACE_METHOD(CLookInDlg, _OnSysColorChange);

    SendMessage(_hCtrl(IDC_LOOK_IN_TV), WM_SYSCOLORCHANGE, 0, 0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookInDlg::DoModal
//
//  Synopsis:   Invoke the Loook In dialog as a modal dialog with respect
//              to [hwndParent] and block until it is closed.
//
//  Arguments:  [hwndParent] - parent window
//              [pCurScope]  - current scope
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CLookInDlg::DoModal(
    HWND hwndParent,
    CScope *pCurScope) const
{
    TRACE_METHOD(CLookInDlg, DoModal);

    m_rpSelectedScope = pCurScope;
    _DoModalDlg(hwndParent, IDD_LOOK_IN);
}



//+--------------------------------------------------------------------------
//
//  Member:     CLookInDlg::_OnMinMaxInfo
//
//  Synopsis:   Fill [lpmmi] with the minimum allowed size of this dialog
//
//  Arguments:  [lpmmi] - from WM_GETMINMAXINFO
//
//  Returns:    FALSE (message processed)
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CLookInDlg::_OnMinMaxInfo(
    LPMINMAXINFO lpmmi)
{
    lpmmi->ptMinTrackSize.x = m_cxMin;
    lpmmi->ptMinTrackSize.y = m_cyMin;
    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLookInDlg::_OnSize
//
//  Synopsis:   Handle a WM_SIZE message by resizing this dialog
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CLookInDlg::_OnSize(
    WPARAM wParam,
    LPARAM lParam)
{
    WORD nWidth = LOWORD(lParam);  // width of client area
    WORD nHeight = HIWORD(lParam); // height of client area

    //
    // Move the OK/Cancel buttons so they're always at lower right
    // corner of dialog.
    //

    RECT rcDlg;
    GetClientRect(m_hwnd, &rcDlg);

    if (!m_cxFrameLast || !m_cyFrameLast)
    {
        Dbg(DEB_TRACE, "FrameLast not set yet, returning\n");
        m_cxFrameLast = rcDlg.right;
        m_cyFrameLast = rcDlg.bottom;
        return TRUE;
    }

    RECT rcCancel;
    GetWindowRect(_hCtrl(IDCANCEL), &rcCancel);

    SetWindowPos(_hCtrl(IDCANCEL),
                 NULL,
                 rcDlg.right - WindowRectWidth(rcCancel) - m_cxSeparation,
                 rcDlg.bottom - WindowRectHeight(rcCancel) - m_cySeparation,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOOWNERZORDER
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    RECT rcOK;
    GetWindowRect(_hCtrl(IDOK), &rcOK);
    _GetChildWindowRect(_hCtrl(IDCANCEL), &rcCancel);

    SetWindowPos(_hCtrl(IDOK),
                 NULL,
                 rcCancel.left - WindowRectWidth(rcOK) - m_cxSeparation,
                 rcDlg.bottom - WindowRectHeight(rcOK) - m_cySeparation,
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOCOPYBITS
                 | SWP_NOZORDER);

    //
    // Calculate the new width of the treeview
    // control by adding the delta (which may be negative) of this size
    // operation to the current width of the control.
    //

    HWND hwndTv = _hCtrl(IDC_LOOK_IN_TV);

    if (hwndTv)
    {
        RECT rcTv;

        VERIFY(GetWindowRect(hwndTv, &rcTv));

        LONG cxNew = WindowRectWidth(rcTv) + rcDlg.right - m_cxFrameLast;
        ASSERT(cxNew > 0);

        LONG cyDelta = rcDlg.bottom - m_cyFrameLast;

        SetWindowPos(hwndTv,
                     NULL,
                     0,
                     0,
                     cxNew,
                     WindowRectHeight(rcTv) + cyDelta,
                     SWP_NOMOVE
                     | SWP_NOOWNERZORDER
                     | SWP_NOZORDER);
    }
    else
    {
        DBG_OUT_HRESULT(E_FAIL);
    }

    //
    // Size gripper goes in bottom right corner
    //

    RECT rc;

    _GetChildWindowRect(_hCtrl(IDC_SIZEGRIP), &rc);

    SetWindowPos(_hCtrl(IDC_SIZEGRIP),
                 NULL,
                 nWidth - (rc.right - rc.left),
                 nHeight - (rc.bottom - rc.top),
                 0,
                 0,
                 SWP_NOSIZE
                 | SWP_NOOWNERZORDER
                 | SWP_NOZORDER);

    m_cxFrameLast = rcDlg.right;
    m_cyFrameLast = rcDlg.bottom;
    return FALSE;
}



//+--------------------------------------------------------------------------
//
//  Member:     CLookInDlg::_OnHelp
//
//  Synopsis:   Display context sensitive help for requested item
//
//  Arguments:  [message] -
//              [wParam]  -
//              [lParam]  -
//
//  History:    10-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CLookInDlg::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CLookInDlg, _OnHelp);

    InvokeWinHelp(message, wParam, lParam, c_wzHelpFilename, s_aulHelpIds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\multi.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       multi.cxx
//
//  Contents:   Implements a dialog allowing the user to choose between
//              multiple items which partially match the string in the name
//              edit control.
//
//  Classes:    CMultiDlg
//
//  History:    03-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

DEBUG_DECLARE_INSTANCE_COUNTER(CMultiDlg)

static ULONG
s_aulHelpIds[] =
{
    IDC_MATCHING_LIST,          IDH_MATCHING_LIST,
    IDC_SELECT_MATCHING_LBL,    static_cast<ULONG>(-1L),
    0,0
};

//
//This is a static variable used to pass column info to 
//callback sorting routine
//
static AttrKeyVector *g_vakListviewColumns = NULL;

//+--------------------------------------------------------------------------
//
//  Member:     CDsObject::_MultiMatchDialog
//
//  Synopsis:   Present a dialog allowing user to choose between the multiple
//              items which matched the user's typed entry.
//
//  Arguments:  [hwndFrame]    - parent window
//              [fMultiSelect] - controls selection mode
//              [pnpr]         - filled with NPR_DELETE, NPR_EDIT, or
//                                NPR_SUCCESS
//              [pdsol]        - on input, contains more than one object.
//                                on successful return, objects which the
//                                user didn't select have been deleted.
//
//  Returns:    S_OK    - [pdsol] has selected items
//              S_FALSE - user hit Cancel
//              E_*     - any error
//
//  Modifies:   *[pdsol]
//
//  History:    08-17-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CMultiDlg::DoModalDialog(
    HWND  hwndParent,
    BOOL  fMultiSelect,
    NAME_PROCESS_RESULT *pnpr,
    CDsObjectList *pdsol)
{
    TRACE_METHOD(CMultiDlg, DoModalDlg);

    m_fSingleSelect = !fMultiSelect;
    m_pdsol = pdsol;
    m_pnpr = pnpr;

    _DoModalDlg(hwndParent, IDD_MULTI);
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CMultiDlg::_OnInit
//
//  Synopsis:   Handle dialog initialization.
//
//  Arguments:  [pfSetFocus] - set to TRUE on exit if focus changed
//
//  Returns:    S_OK
//
//  History:    03-30-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CMultiDlg::_OnInit(
    BOOL *pfSetFocus)
{
    HRESULT hr = S_OK;
    HWND hwndLV = _hCtrl(IDC_MATCHING_LIST);
    const CAttributeManager &ram = m_rop.GetAttributeManager();

	g_vakListviewColumns = NULL;

    SetDefaultColumns(m_hwnd, m_rop, &m_vakListviewColumns);

    //
    // Set extended styles: full row select and labeltip
    //

    ListView_SetExtendedListViewStyleEx(hwndLV,
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT,
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT);
    //
    // Put the columns in the listview
    //

    WCHAR       wszBuffer[MAX_PATH + 1];
    LV_COLUMN   lvc;
    RECT        rcLV;
    VERIFY(GetClientRect(hwndLV, &rcLV));
    rcLV.right -= GetSystemMetrics(SM_CXVSCROLL);

    ZeroMemory(&lvc, sizeof lvc);
    lvc.mask = LVCF_FMT | LVCF_TEXT | LVCF_WIDTH;
    lvc.fmt  = LVCFMT_LEFT;
    lvc.cx = rcLV.right / static_cast<LONG>(m_vakListviewColumns.size());
    lvc.pszText = wszBuffer;
    lvc.cchTextMax = ARRAYLEN(wszBuffer);

    size_t i;
    for (i = 0; i < m_vakListviewColumns.size(); i++)
    {
        ATTR_KEY ak = m_vakListviewColumns[i];
        const String &strAttrDisplayName = ram.GetAttrDisplayName(ak);
        lvc.pszText = const_cast<PWSTR>(strAttrDisplayName.c_str());

        int iResult = ListView_InsertColumn(_hCtrl(IDC_MATCHING_LIST),
                                            i,
                                            &lvc);
        if (iResult == -1)
        {
            DBG_OUT_LASTERROR;
            hr = E_FAIL;
            break;
        }
    }

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // If we're not in single select mode, allow multiple selections in
    // listview.
    //

    String strLabelFmt;
    String strLabel;

    if (!m_fSingleSelect)
    {
        LONG lStyle = GetWindowLong(hwndLV, GWL_STYLE);
        lStyle &= ~LVS_SINGLESEL;
        SetWindowLong(hwndLV, GWL_STYLE, lStyle);
        strLabelFmt = String::load((int)IDS_MULTI_PICK_ONE_OR_MORE);
    }
    else
    {
        strLabelFmt = String::load((int)IDS_MULTI_PICK_ONE);
    }

    strLabel = String::format(strLabelFmt.c_str(), m_strUserEnteredText.c_str());
    Static_SetText(_hCtrl(IDC_SELECT_MATCHING_LBL), strLabel.c_str());

    //
    // Set the attribute/class display info manager's imagelist into the
    // listview
    //

    HIMAGELIST himl = NULL;
    hr = ram.GetImageList(&himl);

    if (SUCCEEDED(hr))
    {
        ListView_SetImageList(hwndLV, himl, LVSIL_SMALL);
    }
    else
    {
        DBG_OUT_HRESULT(hr);
        hr = S_OK;  // nonfatal
    }

    //
    // Fill the listview
    //

    LVITEM lvi;

    ZeroMemory(&lvi, sizeof lvi);

    CDsObjectList::iterator it;
    LPARAM InitialSelectionLParam = 0;

    for (i = 0, it = m_pdsol->begin(); it != m_pdsol->end(); i++, it++)
    {
        lvi.mask = LVIF_TEXT | LVIF_PARAM;

        //
        // Get an icon for this class
        //

        if (himl)
        {
            hr = ram.GetIconIndexFromObject(m_hwnd, *it, &lvi.iImage);
        }

        if (himl && SUCCEEDED(hr))
        {
            //
            // our class/icon cache has entry for this icon for this class.
            // the entry will be -1 if the icon couldn't be retrieved.
            //

            if (lvi.iImage != -1)
            {
                lvi.mask |= LVIF_IMAGE;
            }
        }


        lvi.pszText = it->GetAttr(m_vakListviewColumns[0]).GetBstr();
        lvi.lParam = reinterpret_cast<LPARAM>(&*it);

        //
        // Insert the item
        //

        LONG lResult = ListView_InsertItem(hwndLV, &lvi);

        if (lResult == -1)
        {
            Dbg(DEB_ERROR,
                "Error %u inserting '%ws' in multimatch listview\n",
                GetLastError(),
                lvi.pszText);
            continue;
        }

        //
        // If the user-entered text exactly matches the RDN, samAccountName,
        // or UPN attribute, remember this item as the one to select
        // initially.
        //

        const Variant &varSamAccountName = it->GetAttr(AK_SAMACCOUNTNAME);

        if (!InitialSelectionLParam &&
            (!m_strUserEnteredText.icompare(it->GetName()) ||
             !m_strUserEnteredText.icompare(it->GetLocalizedName()) ||
             !m_strUserEnteredText.icompare(it->GetUpn()) ||
             !m_strUserEnteredText.icompare(varSamAccountName.GetBstr())))
        {
            InitialSelectionLParam = lvi.lParam;
        }

        //
        // Column 0 added, now add the rest
        //

        size_t j;

        for (j = 1; j < m_vakListviewColumns.size(); j++)
        {
            ListView_SetItemText(hwndLV,
                                 lResult,
                                 static_cast<int>(j),
                                 const_cast<PWSTR>(it->GetAttr(m_vakListviewColumns[j]).GetBstr()));
        }
    }

    if (!InitialSelectionLParam)
    {
        ListView_SetItemState(hwndLV,
                              0,
                              LVIS_FOCUSED,
                              LVIS_FOCUSED);
    }
    else
    {
        LVFINDINFO lvfi;
        ZeroMemory(&lvfi, sizeof lvfi);
        lvfi.flags = LVFI_PARAM;
        lvfi.lParam = InitialSelectionLParam;
        int iItem = ListView_FindItem(hwndLV, -1, &lvfi);

        // darn well better find it, we just added it!
        ASSERT(iItem != -1);

        if (iItem != -1)
        {
            SetListViewSelection(hwndLV, iItem);
        }
    }
    DisableSystemMenuClose(m_hwnd);
    SetFocus(hwndLV);
    *pfSetFocus = FALSE;
	
	if(SUCCEEDED(hr))
		g_vakListviewColumns = &m_vakListviewColumns;

    return S_OK;
}



//+--------------------------------------------------------------------------
//
//  Member:     CMultiDlg::_OnCommand
//
//  Synopsis:   Handle user input.
//
//  Arguments:  standard windows
//
//  Returns:    standard windows
//
//  History:    02-20-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CMultiDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fNotHandled = FALSE;

    switch (LOWORD(wParam))
    {
    case IDOK:
        _OnOk();
        break;

    case IDCANCEL:
        Dbg(DEB_TRACE, "UA: (MultiDlg) hit Cancel\n");
        *m_pnpr = NPR_STOP_PROCESSING;
        EndDialog(m_hwnd, E_FAIL);
        break;

    default:
        fNotHandled = TRUE;
        break;
    }
    return fNotHandled;
}



//+--------------------------------------------------------------------------
//
//  Member:     CMultiDlg::_OnOk
//
//  Synopsis:   Remember the user's selection(s) in the listview and close
//              the dialog
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CMultiDlg::_OnOk()
{
    HWND hwndLV = _hCtrl(IDC_MATCHING_LIST);

    //
    // Move each of the ds objects whose item in the listview is
    // selected from the passed-in list to a temporary list.
    //

    LVITEM lvi;
    int iItem = -1;
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_PARAM;

    CDsObjectList dsolTemp;

    while ((iItem = ListView_GetNextItem(hwndLV,
                                         iItem,
                                         LVNI_SELECTED)) != -1)
    {
        lvi.iItem = iItem;

        if (ListView_GetItem(hwndLV, &lvi))
        {
            CDsObjectList::iterator it;

            for (it = m_pdsol->begin(); it != m_pdsol->end(); it++)
            {
                if ((LPARAM)(&*it) == lvi.lParam)
                {
                    dsolTemp.splice(dsolTemp.end(), *m_pdsol, it);
                    break;
                }
            }
        }
        else
        {
            DBG_OUT_LASTERROR;
        }
    }

    ASSERT(!dsolTemp.empty());

    //
    // Now dsolTemp contains all selected items.
    // Move the items in the temporary list back to the passed-in list
    //

    Dbg(DEB_TRACE,
        "UA: (MultiDlg) hit OK, %u items are selected, first is %ws\n",
        dsolTemp.size(),
        dsolTemp.front().GetName());

    m_pdsol->assign(dsolTemp.begin(), dsolTemp.end());
    *m_pnpr = NPR_SUCCESS;
    EndDialog(m_hwnd, S_OK);
}

//
//Callback function called by ListView for sorting the column
//Ported from ACLUI
//
int CALLBACK
ListCompareProc(LPARAM lParam1,
                LPARAM lParam2,
                LPARAM lParamSort)
{
    int iResult = 0;

	if(!g_vakListviewColumns)
		return 0;

    CDsObject * p1 = (CDsObject *)lParam1;
    CDsObject * p2 = (CDsObject *)lParam2;
    
	short iColumn = LOWORD(lParamSort);
    short iSortDirection = HIWORD(lParamSort);

    
	LPTSTR psz1 = NULL;
    LPTSTR psz2 = NULL;

    if (iSortDirection == 0)
        iSortDirection = 1;

    if (p1 && p2)
    {
		psz1 = p1->GetAttr((*g_vakListviewColumns)[iColumn]).GetBstr();
		psz2 = p2->GetAttr((*g_vakListviewColumns)[iColumn]).GetBstr();
	}

    if (iResult == 0 && psz1 && psz2)
    {
		iResult = CompareString(LOCALE_USER_DEFAULT, 0, psz1, -1, psz2, -1) - 2;
	}

    iResult *= iSortDirection;

    return iResult;
}

//+--------------------------------------------------------------------------
//
//  Member:     CMultiDlg::_OnNotify
//
//  Synopsis:   Handle WM_NOTIFY
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CMultiDlg::_OnNotify(
    WPARAM wParam,
    LPARAM lParam)
{
    //TRACE_METHOD(CDsSelectDlg, _OnNotify);
    LPNMHDR pnmh = (LPNMHDR) lParam;

    //
    // Ignore notifications from controls other than the listview
    //

    if (pnmh->idFrom != IDC_MATCHING_LIST)
    {
        return TRUE;
    }

    //
    // Since it's from listview, the notification header is
    // listview type.
    //

    LPNM_LISTVIEW pnmlv = (LPNM_LISTVIEW) lParam;

    INT iItem = -1;

    switch (pnmlv->hdr.code)
    {
    case NM_DBLCLK:
        iItem = ListView_GetNextItem(pnmlv->hdr.hwndFrom,
                                     -1,
                                     LVNI_SELECTED);

        if (iItem != -1)
        {
            _OnOk();
        }
        break;

    case LVN_KEYDOWN:
        switch (((LPNMLVKEYDOWN)lParam)->wVKey)
        {
        case 'A':
            if (!m_fSingleSelect && GetKeyState(VK_CONTROL) < 0)
            {
                ListView_SetItemState(pnmh->hwndFrom,
                                      -1,
                                      LVIS_SELECTED,
                                      LVIS_SELECTED);
            }
            break;
        }
        break;

    case LVN_ITEMCHANGED:
        iItem = ListView_GetNextItem(pnmlv->hdr.hwndFrom,
                                     -1,
                                     LVNI_SELECTED);

        EnableWindow(_hCtrl(IDOK), (iItem != -1));
        break;

	case LVN_COLUMNCLICK:
		if (m_iLastColumnClick == pnmlv->iSubItem)
			m_iSortDirection = -m_iSortDirection;
		else
			m_iSortDirection = 1;
        
		m_iLastColumnClick = pnmlv->iSubItem;
        
		ListView_SortItems(pnmh->hwndFrom,
                           ListCompareProc,
                           MAKELPARAM(m_iLastColumnClick, m_iSortDirection));
		

		break;
    default:
        break;
    }

    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CMultiDlg::_OnHelp
//
//  Synopsis:   Invoke context sensitive help
//
//  History:    04-21-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CMultiDlg::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CDsSelectDlg, _OnHelp);

    InvokeWinHelp(message, wParam, lParam, c_wzHelpFilename, s_aulHelpIds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\ldapdisplaycache.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       LdapDisplayCache.cxx
//
//  Contents:   Implementation of class to cache class and attribute
//              strings and class icons used to display LDAP classes and
//              attributes.
//
//  Classes:    CDisplayCache
//
//  History:    05-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


const vector<ATTRIBUTE_INFO> CDisplayCache::s_AttrEmpty;

//+--------------------------------------------------------------------------
//
//  Member:     CDisplayCache::CDisplayCache
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - containing instance of Object Picker
//
//  History:    05-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CDisplayCache::CDisplayCache(
    const CObjectPicker &rop):
        m_rop(rop)
{
    TRACE_CONSTRUCTOR(CDisplayCache);

    m_himlClassIcons = ImageList_Create(16, 16, ILC_COLOR | ILC_MASK, 1, 1);

    if (!m_himlClassIcons)
    {
        DBG_OUT_LASTERROR;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CDisplayCache::CDisplayCache
//
//  Synopsis:   copy ctor
//
//  History:    06-01-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CDisplayCache::CDisplayCache(
    const CDisplayCache &rdc):
        m_rop(rdc.m_rop)
{
    TRACE_CONSTRUCTOR(CDisplayCache);

    if (rdc.m_himlClassIcons)
    {
        m_himlClassIcons = ImageList_Duplicate(rdc.m_himlClassIcons);

        if (!m_himlClassIcons)
        {
            DBG_OUT_LASTERROR;
        }
    }

    m_vClasses = rdc.m_vClasses;
    m_rpDispSpec = rdc.m_rpDispSpec;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDisplayCache::~CDisplayCache
//
//  Synopsis:   dtor
//
//  History:    05-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CDisplayCache::~CDisplayCache()
{
    TRACE_DESTRUCTOR(CDisplayCache);

    if (m_himlClassIcons)
    {
        VERIFY(ImageList_Destroy(m_himlClassIcons));
        m_himlClassIcons = NULL;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CDisplayCache::Clear
//
//  Synopsis:   Discard the cache
//
//  History:    05-25-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDisplayCache::Clear()
{
    TRACE_METHOD(CDisplayCache, Clear);

    if (m_himlClassIcons)
    {
        ImageList_RemoveAll(m_himlClassIcons);
    }
    m_vClasses.clear();
    m_rpDispSpec.Relinquish();
}




HRESULT
CDisplayCache::GetImageList(
    HIMAGELIST *phiml) const
{
    HRESULT hr = S_OK;
    ASSERT(phiml);

    *phiml = m_himlClassIcons;

    if (!m_himlClassIcons)
    {
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        hr = E_OUTOFMEMORY;
    }

    return hr;
}




class CFindClass
{
public:

    CFindClass(
        const String &strClass):
            m_strClass(strClass)
    {
    }

    BOOL
    operator()(const CLASS_INFO &rcd)
    {
        return !m_strClass.icompare(rcd.strAdsiName);
    }

private:

    const String &m_strClass;
};




HRESULT
CDisplayCache::GetIconIndexFromClass(
    HWND hwnd,
    const String &strClass,
    BOOL fDisabled,
    INT *pintIndex) const
{
    ASSERT(pintIndex);

    HRESULT hr = S_OK;

    do
    {
        // init out param for failure
        *pintIndex = -1;

        // find the entry in m_vClasses for class with ldap name strClass
        ClassInfoVector::iterator it;

        hr = _ReadClassInfo(hwnd, strClass, &it);
        BREAK_ON_FAIL_HRESULT(hr);

        if (fDisabled)
        {
            *pintIndex = it->iDisabledIcon;
        }
        else
        {
            *pintIndex = it->iIcon;
        }
    } while (0);

    return hr;
}




String
CDisplayCache::GetClassDisplayName(
    HWND hwnd,
    const String &strClass) const
{
    ClassInfoVector::iterator it;
    HRESULT hr = _ReadClassInfo(hwnd, strClass, &it);

    if (FAILED(hr))
    {
        return L"";
    }
    return it->strDisplayName;
}


const vector<ATTRIBUTE_INFO> &
CDisplayCache::GetClassAttributes(
    HWND hwnd,
    const String &strClass) const
{
    TRACE_METHOD(CDisplayCache, GetClassAttributes);
    Dbg(DEB_TRACE, "Class is %ws\n", strClass.c_str());

    ClassInfoVector::iterator itClass;
    HRESULT hr = _ReadClassInfo(hwnd, strClass, &itClass);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return s_AttrEmpty;
    }

    if (!itClass->vAttributes.empty())
    {
        return itClass->vAttributes;
    }

    m_rpDispSpec->EnumClassAttributes(strClass.c_str(),
                                      _AttrEnumCallback,
                                      reinterpret_cast<LPARAM>(&itClass->vAttributes));

    AttributeInfoVector::iterator itAttr;

    for (itAttr = itClass->vAttributes.begin();
         itAttr != itClass->vAttributes.end();
         itAttr++)
    {
        itAttr->Type = m_rpDispSpec->GetAttributeADsType(itAttr->strLdapName.c_str());
        Dbg(DEB_TRACE,
            "%ws, %ws, %#x\n",
            itAttr->strLdapName.c_str(),
            itAttr->strDisplayName.c_str(),
            itAttr->Type);
    }

    return itClass->vAttributes;
}




HRESULT CALLBACK
CDisplayCache::_AttrEnumCallback(
    LPARAM lParam,
    LPCWSTR pszAttributeName,
    LPCWSTR pszDisplayName,
    DWORD dwFlags)
{
    AttributeInfoVector *pvAttributes =
        reinterpret_cast<AttributeInfoVector *>(lParam);

    ATTRIBUTE_INFO ad;

    if (pszAttributeName)
    {
        ad.strLdapName = pszAttributeName;
    }

    if (pszDisplayName)
    {
        ad.strDisplayName = pszDisplayName;
    }

    ad.Type = ADSTYPE_INVALID;

    pvAttributes->push_back(ad);
    return S_OK;
}





//+--------------------------------------------------------------------------
//
//  Member:     CDisplayCache::_ReadClassInfo
//
//  Synopsis:   Read and cache display specifier information for [strClass].
//
//  Arguments:  [hwnd]     - for binding
//              [strClass] - ldap name of class to read info for
//              [pit]      - filled with iterator at relevant CLASS_INFO
//
//  Returns:    HRESULT
//
//  History:    05-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDisplayCache::_ReadClassInfo(
    HWND hwnd,
    const String &strClass,
    ClassInfoVector::iterator *pit) const
{
    TRACE_METHOD(CDisplayCache, _ReadClassInfo);
    Dbg(DEB_TRACE, "Class is %ws\n", strClass.c_str());

    HRESULT hr = S_OK;
    CLASS_INFO cd;
    PWSTR pwzBuf = NULL;

    cd.strAdsiName = strClass;

    do
    {
        hr = _DemandInit(hwnd);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // See if we've already got info on this class
        //

        CFindClass predicate(strClass);

        *pit = find_if(m_vClasses.begin(), m_vClasses.end(), predicate);

        if (*pit != m_vClasses.end())
        {
            // success, return iterator pointing to cached info
            break;
        }

        //
        //!!! handle no-net, joined nt4, etc.
        // Don't have cached info for this class.
        // Read display info from the specifier for this class
        //

        //
        // Special-case downlevel classes, as they won't appear in the
        // DS.
        //

        BOOL fIsLocalGroup = !strClass.icompare(c_wzLocalGroupClass);
        BOOL fIsGlobalGroup = !strClass.icompare(c_wzGlobalGroupClass);

        if (fIsLocalGroup || fIsGlobalGroup)
        {
            HICON hIcon;
            ULONG idiGroup = fIsLocalGroup ? IDI_LOCAL_GROUP : IDI_GROUP;
            int   idsGroup = fIsLocalGroup ? IDS_LOCAL_GROUP : IDS_GLOBAL_GROUP;

            hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(idiGroup));

            cd.iIcon = ImageList_AddIcon(m_himlClassIcons, hIcon);
            cd.strDisplayName = String::load(idsGroup);
        }
        else
        {
            HICON hIcon;

            hIcon = m_rpDispSpec->GetIcon(strClass.c_str(),
                                          DSGIF_ISNORMAL
                                          | DSGIF_GETDEFAULTICON,
                                          16,
                                          16);
            cd.iIcon = ImageList_AddIcon(m_himlClassIcons, hIcon);

            hIcon = m_rpDispSpec->GetIcon(strClass.c_str(),
                                        DSGIF_ISDISABLED
                                        | DSGIF_GETDEFAULTICON,
                                        16,
                                        16);
            cd.iDisabledIcon = ImageList_AddIcon(m_himlClassIcons, hIcon);

            pwzBuf = new WCHAR [MAX_PATH + 1];

            hr = m_rpDispSpec->GetFriendlyClassName(strClass.c_str(),
                                                  pwzBuf,
                                                  MAX_PATH);
            if (SUCCEEDED(hr))
            {
                cd.strDisplayName = pwzBuf;
            }
            else
            {
                cd.strDisplayName = strClass;
            }
        }

        //
        // Add new info to class vector
        //

        m_vClasses.push_back(cd);
        *pit = m_vClasses.end() - 1;
    } while (0);

    delete [] pwzBuf;
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDisplayCache::_DemandInit
//
//  Synopsis:   Bind to the display specifier container if we haven't already
//
//  Returns:    Result of attempting bind.
//
//  History:    05-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CDisplayCache::_DemandInit(
    HWND hwnd) const
{
    HRESULT hr = S_OK;

    if (!m_rpDispSpec.get())
    {
        hr = m_rpDispSpec.AcquireViaCreateInstance(CLSID_DsDisplaySpecifier,
                                                 NULL,
                                                 CLSCTX_INPROC,
                                                 IID_IDsDisplaySpecifier);
    }

#if 0
    do
    {
        //
        // Bind to display specifier container if necessary
        //

        if (!m_rpDispSpecContainer.get())
        {
            VOID *pv = NULL;
            hr = m_rop.GetRootDSE().BindToDisplaySpecifiersContainer(hwnd,
                                                                     IID_IADsContainer,
                                                                     &pv);
            BREAK_ON_FAIL_HRESULT(hr);

            m_rpDispSpecContainer.Acquire(
                static_cast<IADsContainer *>(pv));
        }

        ASSERT(m_rpDispSpecContainer.get());

    } while (0);
#endif
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\oleglue.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       oleglue.cxx
//
//  Contents:   Miscellaneous functions required for implementing an ole
//              in-proc server
//
//  History:    12-04-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


//+--------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Create registry keys and values for the DS Object Picker.
//
//  Returns:    SELFREG_E_TYPELIB - couldn't register typelib
//              SELFREG_E_CLASS   - couldn't register class
//
//  History:    09-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

STDAPI
DllRegisterServer()
{
    TRACE_FUNCTION(DllRegisterServer);

    HRESULT     hr = SELFREG_E_CLASS;   // ASSUME FAILURE
    LONG        lr;
    CSafeReg    shk;    // reused several times
    CSafeReg    shkCLSID;
    CSafeReg    shkNodeTypes;

    do
    {
        //
        // Create the CLSID entries
        //

        hr = shkCLSID.Open(HKEY_CLASSES_ROOT, L"CLSID", KEY_WRITE);
        BREAK_ON_FAIL_HRESULT(hr);

        WCHAR wszModuleFilename[MAX_PATH];

        {
            CSafeReg    shkServer;

            hr = shkCLSID.Create(c_wzCLSID, &shk);
            BREAK_ON_FAIL_HRESULT(hr);

            (void) shk.SetValue(NULL,
                                REG_SZ,
                                (CONST BYTE *)c_wzClsidComment,
                                sizeof(c_wzClsidComment));

            hr = shk.Create(L"InprocServer32", &shkServer);
            BREAK_ON_FAIL_HRESULT(hr);

            shk.Close();

            lr = GetModuleFileName(g_hinst, wszModuleFilename, MAX_PATH);

            if (!lr)
            {
                DBG_OUT_LASTERROR;
                break;
            }

            hr = shkServer.SetValue(NULL,
                                    REG_SZ,
                                    (CONST BYTE *) wszModuleFilename,
                                    sizeof(WCHAR) * (lstrlen(wszModuleFilename) + 1));
            BREAK_ON_FAIL_HRESULT(hr);


            hr = shkServer.SetValue(L"ThreadingModel",
                                    REG_SZ,
                                    (CONST BYTE *) c_wzThreadingModel,
                                    sizeof(c_wzThreadingModel));
            BREAK_ON_FAIL_HRESULT(hr);
        }

    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Delete all registry entries made by DllRegisterServer.
//
//  Returns:    HRESULT
//
//  History:    08-06-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDAPI
DllUnregisterServer()
{
    TRACE_FUNCTION(DllUnregisterServer);

    HRESULT     hr = S_OK;
    CSafeReg    shkCLSID;

    //
    // Delete the CLSID entries
    //

    do
    {
        hr = shkCLSID.Open(HKEY_CLASSES_ROOT, L"CLSID", KEY_WRITE | KEY_ENUMERATE_SUB_KEYS);
        BREAK_ON_FAIL_HRESULT(hr);

        // clsid for event viewer snapin

        hr = shkCLSID.DeleteTree(c_wzCLSID);
        CHECK_HRESULT(hr);
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Return S_OK if refcount for dll is 0.
//
//  Returns:    S_OK or S_FALSE
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDAPI
DllCanUnloadNow()
{
    TRACE_FUNCTION(DllCanUnloadNow);
    return CDll::CanUnloadNow();
}



//+--------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Return the requested class factory.
//
//  Arguments:  [rclsid] - class desired
//              [riid]   - interface on class factory desired
//              [ppv]    - filled with itf pointer to class factory
//
//  Returns:    S_OK, E_OUTOFMEMORY, CLASS_E_CLASSNOTAVAILABLE
//
//  Modifies:   *[ppv]
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    TRACE_FUNCTION(DllGetClassObject);
    IUnknown *punk = NULL;
    HRESULT hr = S_OK;

    *ppv = NULL;

    if (IsEqualCLSID(rclsid, CLSID_DsObjectPicker))
    {
        punk = new CDsObjectPickerCF;

        if (punk)
        {
            hr = punk->QueryInterface(riid, ppv);
            punk->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
        }
    }
    else
    {
        hr = CLASS_E_CLASSNOTAVAILABLE;
        DBG_OUT_HRESULT(hr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\password.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       password.cxx
//
//  Contents:   Implementation of class used to prompt user for credentials.
//
//  Classes:    CPasswordDialog
//
//  History:    02-09-1998   DavidMun   Created
//
//---------------------------------------------------------------------------


#include "headers.hxx"
#include <wincred.h>
#include <wincrui.h>
#pragma hdrstop

//+--------------------------------------------------------------------------
//
//  Member:     CPasswordDialog::DoModalDialog
//
//  Synopsis:   Invoke the name and password dialog as a modal dialog.
//
//  Arguments:  [hwndParent] - dialog parent.
//
//  Returns:    S_OK    - user entered name & password and hit OK
//              S_FALSE - user hit cancel
//
//  History:    02-09-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CPasswordDialog::DoModalDialog(
    HWND hwndParent)
{
    TRACE_METHOD(CPasswordDialog, DoModalDialog);
	HRESULT hr = S_OK;

    //
    // If the target is being accessed via WinNT provider, show the example
    // with just the nt4 style user name, otherwise show
    // the example with both UPN and NT4 style user names.
    //

    String strExample;

    if (m_flProvider != PROVIDER_WINNT)
	{
        strExample = String::load(IDS_EXAMPLE_UPN_NT4, g_hinst);
	}
    else
	{
        strExample = String::load(IDS_EXAMPLE_NT4, g_hinst);
	}

	//
	//Form the credui message
	//
	String strFormat = String::load((int)IDS_CREDUI_MESSAGE, g_hinst);
	String strMessage = String::format(strFormat, m_wzTarget, strExample.c_str());

	String strTitle = String::load(IDS_CREDUI_TITLE, g_hinst);

	//
	//Init uiInfo
	// 
	CREDUI_INFO uiInfo;
	::ZeroMemory( &uiInfo, sizeof(CREDUI_INFO) );

	uiInfo.cbSize = sizeof(uiInfo);
	uiInfo.hwndParent = hwndParent;
	uiInfo.pszMessageText = strMessage.c_str();
	uiInfo.pszCaptionText = strTitle.c_str();

	TCHAR achUserName[MAX_PATH];
	TCHAR achPassword[PWLEN + 1];
	::ZeroMemory(&achUserName,sizeof(achUserName));
	::ZeroMemory(&achPassword,sizeof(achPassword));

	do
	{
		//
		//Show the password dialog box
		//
		DWORD dwErr = CredUIPromptForCredentials(&uiInfo,
												 NULL,
												 NULL,
												 NO_ERROR,
												 achUserName,
												 MAX_PATH,
												 achPassword,
												 PWLEN + 1,
												 NULL,
 												 CREDUI_FLAGS_DO_NOT_PERSIST | CREDUI_FLAGS_GENERIC_CREDENTIALS);
		if (NO_ERROR != dwErr) // e.g. S_FALSE
		{
			if(dwErr == ERROR_CANCELLED)
				hr = S_FALSE;
			else
			{
				hr = HRESULT_FROM_WIN32(dwErr);
				Dbg(DEB_ERROR,
                    "CredUIPromptForCredentials Failed\n");
				DBG_OUT_HRESULT(hr);
			}                    
			break;
		}			

	}while(!_ValidateName(hwndParent, achUserName));

	if(hr == S_OK)
	{
		wcscpy(m_pwzUserName,achUserName);
		wcscpy(m_pwzPassword,achPassword);
	}
	::ZeroMemory(&achUserName,sizeof(achUserName));
	::ZeroMemory(&achPassword,sizeof(achPassword));
	
	return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CPasswordDialog::_ValidateName
//
//  Synopsis:   Ensure that the form of the name the user entered is valid
//              for the provider being used to access the resource.
//
//  Returns:    TRUE if name valid
//              FALSE if name not valid
//
//  History:    01-11-2000   davidmun   Created
//
//  Notes:      Displays error if name not valid
//
//---------------------------------------------------------------------------

BOOL
CPasswordDialog::_ValidateName(HWND hwnd, LPWSTR pwzUserName)
{
    if (pwzUserName && !*pwzUserName)
    {
        return FALSE; // bug if we get here
    }

    //
    // If provider is not WinNT, any nonempty name is valid
    //

    if (m_flProvider != PROVIDER_WINNT)
    {
        return TRUE;
    }

    //
    // UPN format names are not valid for WinNT provider
    //

    if (wcschr(pwzUserName, L'@'))
    {
        PopupMessage(hwnd, IDS_UPN_FORM_NOT_ALLOWED);
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\op.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       op.cxx
//
//  Contents:   object picker entry point
//
//  Classes:    CObjectPicker
//
//  History:    01-20-2000   davidmun   Created
//
//---------------------------------------------------------------------------


#include "headers.hxx"
#pragma hdrstop

DEBUG_DECLARE_INSTANCE_COUNTER(CObjectPicker)
#define __THIS_FILE__   L"op"


ULONG
GetMachineNtVer(
    PCWSTR pwzMachine);

//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::CObjectPicker
//
//  Synopsis:   ctor
//
//  History:    01-20-2000   davidmun   Created
//
//---------------------------------------------------------------------------

CObjectPicker::CObjectPicker():
    m_cRefs(1),
    m_hwndParent(NULL),
    m_pExternalCustomizer(NULL),
    m_mcTargetComputer(MC_UNKNOWN),
    m_fTargetComputerIsLocal(FALSE),
    m_mcPreviousTargetComputer(MC_UNKNOWN),
    m_fPreviousTargetComputerIsLocal(FALSE),
    m_flInitInfoOptions(0),
    m_pScopeManager(NULL),
    m_pQueryEngine(NULL),
    m_pFilterManager(NULL),
    m_pAttributeManager(NULL),
    m_pAdminCustomizer(NULL),
    m_pBaseDlg(NULL)
{
    TRACE_CONSTRUCTOR(CObjectPicker);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CObjectPicker);

    InitializeCriticalSection(&m_csOleFreeThreading);

    //
    // Initialize globals in a thread-safe way.  Even though this DLL is
    // apartment model only, that only means one thread can access each
    // interface instance.  It doesn't preclude the creation of multiple
    // objects in different threads, each of which will try to init the
    // globals.
    //

    CAutoCritSec Lock(&g_csGlobalVarsCreation);

    if (g_pBinder)
    {
        ASSERT(g_pADsPath); // all globals created at once

        g_pBinder->AddRef();
        g_pADsPath->AddRef();
    }
    else
    {
        g_pBinder = new CBinder;
        g_pADsPath = new CADsPathWrapper;
    }
}



#if defined QUERY_BUILDER
#if 0

//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::CloneForDnPicker
//
//  Synopsis:   Initialize by copying members of [rop], but modify this
//              so it is configured for use as if it had been initialized
//              to pick users, groups, computers, and contacts (plus
//              custom objects) from any enterprise domain, the GC, or
//              (if allowed by [rop]) from uplevel external domains.
//
//  Arguments:  [rop]              - initialized object picker instance
//              [hwndEmbeddingDlg] - dialog containing richedit
//
//  Returns:    HRESULT
//
//  History:    06-01-2000   DavidMun   Created
//
//  Notes:      Initialize must have been called successfully on [rop].
//
//---------------------------------------------------------------------------

HRESULT
CObjectPicker::CloneForDnPicker(
    const CObjectPicker &rop,
    HWND hwndEmbeddingDlg)
{
    TRACE_METHOD(CObjectPicker, CloneForDnPicker);

    HRESULT hr = S_OK;

    do
    {
        //
        // Initialize method should not have been called on this
        //

        ASSERT(!_IsFlagSet(CDSOP_INIT_SUCCEEDED));

        //
        // Cannot initialize this from rop if rop wasn't initialized
        //

        if (!rop._IsFlagSet(CDSOP_INIT_SUCCEEDED))
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        //
        // This is an embedded OP, so richedit will be supplied by some
        // other dialog.  Therefore m_hwndParent should be that dialog.
        //

        m_hwndParent = hwndEmbeddingDlg;

        // Use the external customizer

        m_pExternalCustomizer = rop.m_pExternalCustomizer;

        //
        // Do not fetch any attributes, so leave m_vstrAttributesToFetch empty
        //

        ASSERT(m_vstrAttributesToFetch.empty());

        //
        // Use the same options as rop, but force single select mode
        //

        m_flInitInfoOptions = rop.m_flInitInfoOptions & ~DSOP_FLAG_MULTISELECT;

        //
        // All target computer/enterprise info is the same
        //

        m_strTargetComputer = rop.m_strTargetComputer;
        m_fTargetComputerIsLocal = rop.m_fTargetComputerIsLocal;
        m_strTargetDomainDns = rop.m_strTargetDomainDns;
        m_strTargetDomainDc = rop.m_strTargetDomainDc;
        m_strTargetDomainFlat = rop.m_strTargetDomainFlat;
        m_strTargetForest = rop.m_strTargetForest;
        m_mcTargetComputer = rop.m_mcTargetComputer;
        m_strPreviousTargetComputer = rop.m_strPreviousTargetComputer;
        m_fPreviousTargetComputerIsLocal = rop.m_fPreviousTargetComputerIsLocal;
        m_mcPreviousTargetComputer = rop.m_mcPreviousTargetComputer;

        //
        // Copy attribute type info map
        //

        m_AttrInfoMap = rop.m_AttrInfoMap;
        m_ulNextNewAttrIndex = rop.m_ulNextNewAttrIndex;

        //
        // Each of the below have assignment operators or copy ctors
        //

        m_RootDSE = rop.m_RootDSE;
        ASSERT(!m_pAttributeManager);
        m_pAttributeManager = new CAttributeManager(*rop.m_pAttributeManager);

        //
        // Make a fresh query engine instance, no cloning necessary
        //

        m_pQueryEngine = new CQueryEngine(*this);
        hr = m_pQueryEngine->Initialize();
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // The scope and filter managers must be cloned and modified
        //

        m_pScopeManager = new CScopeManager(*this);
        m_pScopeManager->CloneForDnPicker(*rop.m_pScopeManager);

        m_pFilterManager = new CFilterManager(*this);
        m_pFilterManager->CloneForDnPicker(*rop.m_pFilterManager);
    } while (0);

    return hr;
}
#endif // 0
#endif // defined QUERY_BUILDER


//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::~CObjectPicker
//
//  Synopsis:   dtor
//
//  History:    01-20-2000   davidmun   Created
//
//---------------------------------------------------------------------------

CObjectPicker::~CObjectPicker()
{
    TRACE_DESTRUCTOR(CObjectPicker);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CObjectPicker);
    ASSERT(!m_pExternalCustomizer);

    delete m_pScopeManager;
    m_pScopeManager = NULL;

    delete m_pQueryEngine;
    m_pQueryEngine = NULL;

    delete m_pFilterManager;
    m_pFilterManager = NULL;

    delete m_pAttributeManager;
    m_pAttributeManager = NULL;

    delete m_pAdminCustomizer;
    m_pAdminCustomizer = NULL;

    delete m_pBaseDlg;
    m_pBaseDlg = NULL;

    CAutoCritSec Lock(&g_csGlobalVarsCreation);

    if (g_pBinder)
    {
        ASSERT(g_pADsPath); // all globals created at once

        if (!g_pBinder->Release())
        {
            g_pBinder = NULL;
        }

        if (!g_pADsPath->Release())
        {
            g_pADsPath = NULL;
        }
    }

    DeleteCriticalSection(&m_csOleFreeThreading);
}





//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::Initialize
//
//  Synopsis:   Validate and copy the passed-in structure.
//
//  Arguments:  [pInitInfo] - initialization information
//
//  Returns:    S_OK, E_INVALIDARG, or E_OUTOFMEMORY
//
//  History:    08-29-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CObjectPicker::Initialize(
    PDSOP_INIT_INFO pInitInfo)
{
    TRACE_METHOD(CObjectPicker, Initialize);
    HRESULT hr = S_OK;
    ULONG   i;

    CAutoCritSec Lock(&m_csOleFreeThreading);

    try
    {
        do
        {
            //
            // Create objects that manage various duties; if they already
            // exist clear them of data from any previous initialization
            // or use.
            //

            if (!m_pScopeManager)
            {
                m_pScopeManager = new CScopeManager(*this);
            }
            else
            {
                m_pScopeManager->Clear();
            }

            if (!m_pQueryEngine)
            {
                m_pQueryEngine = new CQueryEngine(*this);
                m_pQueryEngine->Initialize();
            }
            else
            {
                m_pQueryEngine->Clear();
            }

            if (!m_pFilterManager)
            {
                m_pFilterManager = new CFilterManager(*this);
            }
            else
            {
                m_pFilterManager->Clear();
            }

            // note attribute manager is only cleared if target machine changes
            if (!m_pAttributeManager)
            {
                m_pAttributeManager = new CAttributeManager(*this);
            }

            if (!m_pAdminCustomizer)
            {
                m_pAdminCustomizer = new CAdminCustomizer(*this);
            }
            else
            {
                m_pAdminCustomizer->Clear();
            }

            if (!m_pBaseDlg)
            {
                m_pBaseDlg = new CBaseDlg(*this);
            }
            else
            {
                m_pBaseDlg->Clear();
            }

            m_vstrAttributesToFetch.clear();

            _ClearFlag(CDSOP_INIT_SUCCEEDED);

#if (DBG == 1)
            _DumpInitInfo(pInitInfo);
#endif // (DBG == 1)

            for (i = 0; i < pInitInfo->cAttributesToFetch; i++)
            {
                PCWSTR pwzAttrName = pInitInfo->apwzAttributeNames[i];
                m_vstrAttributesToFetch.push_back(pwzAttrName);
            }

            m_flInitInfoOptions = pInitInfo->flOptions;

            //
            // If target machine is not the same as the previous call, or if
            // this is the first call, determine the configuration
            //


            BOOL fLastTargetIsLocalMachine = m_fTargetComputerIsLocal;
            m_fTargetComputerIsLocal =
                IsLocalComputername(pInitInfo->pwzTargetComputer);

            if ((m_mcTargetComputer == MC_UNKNOWN) ||
                (m_fTargetComputerIsLocal && !fLastTargetIsLocalMachine) ||
                (!m_fTargetComputerIsLocal && fLastTargetIsLocalMachine) ||
                (!m_fTargetComputerIsLocal &&
                 !fLastTargetIsLocalMachine &&
                 m_strTargetComputer.icompare(pInitInfo->pwzTargetComputer)))
            {
                if (pInitInfo->pwzTargetComputer && *pInitInfo->pwzTargetComputer)
                {
                    m_strPreviousTargetComputer = m_strTargetComputer;
                    m_strTargetComputer = pInitInfo->pwzTargetComputer;
                    m_strTargetComputer.strip(String::LEADING, L'\\');
                    Dbg(DEB_TRACE,
                        "Target computer is %s\n",
                        m_strTargetComputer.c_str());
                }
                else
                {
                    WCHAR wzLocalComputer[MAX_COMPUTERNAME_LENGTH + 1];
                    DWORD cchSize = ARRAYLEN(wzLocalComputer);

                    VERIFY(GetComputerName(wzLocalComputer, &cchSize));
                    m_fPreviousTargetComputerIsLocal = m_fTargetComputerIsLocal;
                    m_fTargetComputerIsLocal = TRUE;
                    m_strPreviousTargetComputer = m_strTargetComputer;
                    m_strTargetComputer = wzLocalComputer;

                    Dbg(DEB_TRACE,
                        "Target computer NULL, using '%s'\n",
                        m_strTargetComputer.c_str());
                }

                m_pAttributeManager->Clear();

                hr = _InitializeMachineConfig();

                if (FAILED(hr))
                {
                    DBG_OUT_HRESULT(hr);

                    if (m_strTargetComputer.length())
                    {
                        PopupMessage(GetForegroundWindow(),
                                     IDS_INIT_FAILED_MACHINE_CONFIG,
                                     m_strTargetComputer.c_str());
                    }
                    else
                    {
                        PopupMessage(GetForegroundWindow(),
                                     IDS_INIT_FAILED_LOCAL_MACHINE_CONFIG);
                    }
                    break;
                }

                if (m_mcTargetComputer == MC_JOINED_NT5 ||
                    m_mcTargetComputer == MC_NT5_DC)
                {
                     m_RootDSE.Init(m_strTargetDomainDns.c_str(),
                                         m_strTargetForest.c_str());
                }
            }

            hr = m_pScopeManager->Initialize(pInitInfo);
            BREAK_ON_FAIL_HRESULT(hr);

            _SetFlag(CDSOP_INIT_SUCCEEDED);
        } while (0);
    }
    catch (const exception &e)
    {
        hr = E_OUTOFMEMORY;
        Dbg(DEB_ERROR, "Caught %s\n", e.what());
    }

    return hr;
}



#if (DBG == 1)

//+--------------------------------------------------------------------------
//
//  Function:   _DumpInOptForm
//
//  Synopsis:   Dump to the debugger the scope flags in a form that can be
//              copied and pasted into a text file that the unit test can
//              read.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
_DumpInOptForm(
    PDSOP_SCOPE_INIT_INFO pCur,
    ULONG flScope)
{
    if (pCur->flType & flScope)
    {
        Dbg(DEB_TRACE | DEB_NOCOMPNAME, "%#x\n", flScope);
        Dbg(DEB_TRACE | DEB_NOCOMPNAME, "%#x\n", pCur->flScope);
        Dbg(DEB_TRACE | DEB_NOCOMPNAME, L"%#x\n", pCur->FilterFlags.Uplevel.flBothModes);
        Dbg(DEB_TRACE | DEB_NOCOMPNAME, L"%#x\n", pCur->FilterFlags.Uplevel.flMixedModeOnly);
        Dbg(DEB_TRACE | DEB_NOCOMPNAME, L"%#x\n", pCur->FilterFlags.Uplevel.flNativeModeOnly);
        Dbg(DEB_TRACE | DEB_NOCOMPNAME, L"%#x\n", pCur->FilterFlags.flDownlevel);
        Dbg(DEB_TRACE | DEB_NOCOMPNAME, "\"%ws\"\n", pCur->pwzDcName);
        Dbg(DEB_TRACE | DEB_NOCOMPNAME, "\"%ws\"\n", pCur->pwzADsPath);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::_DumpInitInfo
//
//  Synopsis:   Dump initialization structure caller supplied to the debugger
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CObjectPicker::_DumpInitInfo(
    PCDSOP_INIT_INFO pInitInfo)
{
    Dbg(DEB_TRACE, "\n");

    String strDateTime;
    WCHAR  wzDateTime[12];

    int iRet = GetDateFormat(NULL,
                             0,
                             NULL,
                             L"MM'/'dd'/'yyyy",
                             wzDateTime,
                             ARRAYLEN(wzDateTime));

    if (iRet)
    {
        strDateTime = wzDateTime;
    }

    iRet = GetTimeFormat(NULL,
                         0,
                         NULL,
                         L"HH':'mm':'ss",
                         wzDateTime,
                         ARRAYLEN(wzDateTime));

    if (iRet)
    {
        if (!strDateTime.empty())
        {
            strDateTime += L" ";
        }
        strDateTime += wzDateTime;
    }

    Dbg(DEB_TRACE, "  %ws\n", strDateTime.c_str());

    WCHAR wzLocalComputerNB[LM20_CNLEN + 1] = L"";
    ULONG cchLocalComputerNB = ARRAYLEN(wzLocalComputerNB);
    BOOL fOk = GetComputerName(wzLocalComputerNB, &cchLocalComputerNB);

    if (fOk)
    {
        Dbg(DEB_TRACE, "  Local Computer '%ws'\n", wzLocalComputerNB);
    }
    else
    {
        DBG_OUT_LASTERROR;
    }

    OSVERSIONINFOEX VerInfo;
    ZeroMemory(&VerInfo, sizeof VerInfo);
    VerInfo.dwOSVersionInfoSize = sizeof VerInfo;

    fOk = GetVersionEx(reinterpret_cast<OSVERSIONINFO *>(&VerInfo));

    if (fOk)
    {
        PCWSTR pwzProductType;

        switch (VerInfo.wProductType)
        {
        case VER_NT_WORKSTATION:
            pwzProductType = L"Workstation";
            break;

        case VER_NT_DOMAIN_CONTROLLER:
            pwzProductType = L"Domain Controller";
            break;

        case VER_NT_SERVER:
            pwzProductType = L"Server";
            break;

        default:
            pwzProductType = L"(unknown product type)";
            break;
        }

        if (VerInfo.szCSDVersion && *VerInfo.szCSDVersion)
        {
            Dbg(DEB_TRACE,
                "  Windows %ws %u.%u build %u %ws SP version %u.%u\n",
                pwzProductType,
                VerInfo.dwMajorVersion,
                VerInfo.dwMinorVersion,
                VerInfo.dwBuildNumber,
                VerInfo.szCSDVersion,
                VerInfo.wServicePackMajor,
                VerInfo.wServicePackMinor);
        }
        else
        {
            Dbg(DEB_TRACE, "  Windows %ws version %u.%u build %u\n",
                pwzProductType,
                VerInfo.dwMajorVersion,
                VerInfo.dwMinorVersion,
                VerInfo.dwBuildNumber);
        }
    }
    else
    {
        DBG_OUT_LASTERROR;
    }

    WCHAR wzUserName[LM20_DNLEN + 1 + LM20_UNLEN + 1] = L""; // +1 for \ +1 for NUL
    ULONG cchUserName = ARRAYLEN(wzUserName);
    fOk = GetUserNameEx(NameSamCompatible, wzUserName, &cchUserName);

    if (fOk)
    {
        Dbg(DEB_TRACE, "  Logged on as '%ws'\n", wzUserName);
    }
    else
    {
        DBG_OUT_LASTERROR;
    }

    Dbg(DEB_TRACE,
        "  Target Computer '%ws'\n",
        CHECK_NULL(pInitInfo->pwzTargetComputer));

    DumpOptionFlags(pInitInfo->flOptions);

    ULONG i;
    for (i = 0; i < pInitInfo->cDsScopeInfos; i++)
    {
        PDSOP_SCOPE_INIT_INFO pCur = &pInitInfo->aDsScopeInfos[i];
        Dbg(DEB_TRACE, "\n");
        DumpScopeType(pCur->flType);
        DumpScopeFlags(pCur->flScope);
        DumpFilterFlags(pCur->FilterFlags);

        if (pCur->pwzDcName)
        {
            Dbg(DEB_TRACE, "  DC Name '%ws'\n", pCur->pwzDcName);
        }
        if (pCur->pwzADsPath)
        {
            Dbg(DEB_TRACE, "  ADsPath '%ws'\n", pCur->pwzADsPath);
        }
    }

    // dump in format opt.exe can read
    Dbg(DEB_TRACE | DEB_NOCOMPNAME, "\"%ws\"\n", pInitInfo->pwzTargetComputer);
    Dbg(DEB_TRACE | DEB_NOCOMPNAME, "%#x\n", pInitInfo->flOptions);

    String strAttr(L"\"");

    for (i = 0; i < pInitInfo->cAttributesToFetch; i++)
    {
        strAttr += pInitInfo->apwzAttributeNames[i];

        if (i < pInitInfo->cAttributesToFetch - 1)
        {
            strAttr += L"; ";
        }
    }
    strAttr += L"\"";
    Dbg(DEB_TRACE | DEB_NOCOMPNAME, "%ws\n", strAttr.c_str());
    ULONG cIndividualScopes = 0;

    for (i = 0; i < pInitInfo->cDsScopeInfos; i++)
    {
        PDSOP_SCOPE_INIT_INFO pCur = &pInitInfo->aDsScopeInfos[i];

        if (pCur->flType & ST_TARGET_COMPUTER)
        {
            cIndividualScopes++;
        }
        if (pCur->flType & ST_UPLEVEL_JOINED_DOMAIN)
        {
            cIndividualScopes++;
        }
        if (pCur->flType & ST_DOWNLEVEL_JOINED_DOMAIN)
        {
            cIndividualScopes++;
        }
        if (pCur->flType & ST_ENTERPRISE_DOMAIN)
        {
            cIndividualScopes++;
        }
        if (pCur->flType & ST_GLOBAL_CATALOG)
        {
            cIndividualScopes++;
        }
        if (pCur->flType & ST_EXTERNAL_UPLEVEL_DOMAIN)
        {
            cIndividualScopes++;
        }
        if (pCur->flType & ST_EXTERNAL_DOWNLEVEL_DOMAIN)
        {
            cIndividualScopes++;
        }
        if (pCur->flType & ST_WORKGROUP)
        {
            cIndividualScopes++;
        }
        if (pCur->flType & ST_USER_ENTERED_UPLEVEL_SCOPE)
        {
            cIndividualScopes++;
        }
        if (pCur->flType & ST_USER_ENTERED_DOWNLEVEL_SCOPE)
        {
            cIndividualScopes++;
        }
    }
    Dbg(DEB_TRACE | DEB_NOCOMPNAME, "%u\n", cIndividualScopes);

    for (i = 0; i < pInitInfo->cDsScopeInfos; i++)
    {
        PDSOP_SCOPE_INIT_INFO pCur = &pInitInfo->aDsScopeInfos[i];

        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_TARGET_COMPUTER             );
        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN       );
        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN     );
        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN           );
        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_GLOBAL_CATALOG              );
        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN     );
        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN   );
        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_WORKGROUP                   );
        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE  );
        _DumpInOptForm(pCur, DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE);
    }
}
#endif // (DBG == 1)





//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::_InitializeMachineConfig
//
//  Synopsis:   Determine the configuration of the target computer.
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      Configuration in this sense means whether the target
//              computer is joined to an NT4 domain, an NT5 domain, in a
//              workgroup, etc.
//
//---------------------------------------------------------------------------

HRESULT
CObjectPicker::_InitializeMachineConfig()
{
    TRACE_METHOD(CObjectPicker, _InitializeMachineConfig);

    HRESULT                             hr = S_OK;
    ULONG                               ulResult;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDsRole = NULL;
    PDOMAIN_CONTROLLER_INFO             pdci = NULL;
    RpIADs                              rpADs;

    do
    {
        m_mcPreviousTargetComputer = m_mcTargetComputer;
        m_mcTargetComputer = MC_UNKNOWN;
        PCWSTR pwzMachine;

        if (m_fTargetComputerIsLocal)
        {
            pwzMachine = NULL;
        }
        else
        {
            pwzMachine = m_strTargetComputer.c_str();
            ASSERT(*pwzMachine);
        }

        {
            TIMER("DsRoleGetPrimaryDomainInformation(%ws)",
                  CHECK_NULL(pwzMachine));

            ulResult = DsRoleGetPrimaryDomainInformation(pwzMachine,
                                                         DsRolePrimaryDomainInfoBasic,
                                                         (PBYTE *)&pDsRole);
        }

        if (pwzMachine && ulResult == ERROR_ACCESS_DENIED)
        {
            Dbg(DEB_TRACE,
                "DsRoleGetPrimaryDomainInformation returned ERROR_ACCESS_DENIED, establishing connection\n");

            //
            // Establish a connection with remote machine using WinNT provider,
            // and try again.
            //

            WCHAR wzComputerAdsPath[MAX_PATH];

            wsprintf(wzComputerAdsPath, L"WinNT://%ws,Computer", pwzMachine);

            hr = g_pBinder->BindToObject(GetForegroundWindow(),
                                         wzComputerAdsPath,
                                         IID_IADs,
                                         (void **) &rpADs);
            BREAK_ON_FAIL_HRESULT(hr);

            TIMER("DsRoleGetPrimaryDomainInformation2");

            ulResult =
                DsRoleGetPrimaryDomainInformation(pwzMachine,
                                                  DsRolePrimaryDomainInfoBasic,
                                                  (PBYTE *)&pDsRole);
        }

        if (ulResult != NO_ERROR)
        {
            DBG_OUT_LRESULT(ulResult);
            hr = HRESULT_FROM_WIN32(ulResult);
            break;
        }

        ASSERT(pDsRole);

        Dbg(DEB_TRACE, "DsRoleGetPrimaryDomainInformation returned:\n");
        Dbg(DEB_TRACE, "  DomainNameFlat: %ws\n", CHECK_NULL(pDsRole->DomainNameFlat));
        Dbg(DEB_TRACE, "  DomainNameDns: %ws\n", CHECK_NULL(pDsRole->DomainNameDns));
        Dbg(DEB_TRACE, "  DomainForestName: %ws\n", CHECK_NULL(pDsRole->DomainForestName));

        //
        // If machine is in a workgroup, we're done.
        //

        if (pDsRole->MachineRole == DsRole_RoleStandaloneWorkstation ||
            pDsRole->MachineRole == DsRole_RoleStandaloneServer)
        {
            Dbg(DEB_TRACE, "Target machine is not joined to a domain\n");

            m_mcTargetComputer = MC_IN_WORKGROUP;
            break;
        }

        if (pDsRole->DomainNameFlat)
        {
            m_strTargetDomainFlat = pDsRole->DomainNameFlat;
        }

        //
        // Target machine is joined to a domain.  Find out if it's joined
        // to an NT4 or an NT5 domain by getting the name of a DC, and
        // requesting that we get one which supports DS.
        //

        PWSTR pwzDomainNameForDsGetDc;
        ULONG flDsGetDc = DS_DIRECTORY_SERVICE_PREFERRED;

        if (pDsRole->DomainNameDns)
        {
            pwzDomainNameForDsGetDc = pDsRole->DomainNameDns;
            flDsGetDc |= DS_IS_DNS_NAME;
            Dbg(DEB_TRACE,
                "DsGetDcName(Domain=%ws, flags=DS_IS_DNS_NAME | DS_DIRECTORY_SERVICE_PREFERRED)\n",
                CHECK_NULL(pwzDomainNameForDsGetDc));
        }
        else
        {
            pwzDomainNameForDsGetDc = pDsRole->DomainNameFlat;
            flDsGetDc |= DS_IS_FLAT_NAME;
            Dbg(DEB_TRACE,
                "DsGetDcName(Domain=%ws, flags=DS_IS_FLAT_NAME | DS_DIRECTORY_SERVICE_PREFERRED)\n",
                CHECK_NULL(pwzDomainNameForDsGetDc));
        }

        ulResult = DsGetDcName(NULL,  // per CliffV this should ALWAYS be NULL
                               pwzDomainNameForDsGetDc,
                               NULL,
                               NULL,
                               flDsGetDc,
                               &pdci);

        if (ulResult != NO_ERROR)
        {
            m_mcTargetComputer = MC_NO_NETWORK;
            Dbg(DEB_ERROR,
                "DsGetDcName for domain %ws returned %#x, treating target machine as no-net\n",
                pwzDomainNameForDsGetDc,
                ulResult);
            break;
        }

        if (pdci->Flags & DS_DS_FLAG)
        {
            Dbg(DEB_TRACE,
                "DsGetDcName returned DS DC for domain %ws, asking for DNS name\n",
                pwzDomainNameForDsGetDc);

            PDOMAIN_CONTROLLER_INFO pdci2 = NULL;

            ulResult = DsGetDcName(NULL,
                                   pwzDomainNameForDsGetDc,
                                   NULL,
                                   NULL,
                                   flDsGetDc | DS_RETURN_DNS_NAME,
                                   &pdci2);


            if (ulResult == NO_ERROR)
            {
                NetApiBufferFree(pdci);
                pdci = pdci2;
            }
            else
            {
                ASSERT(!pdci2);
            }
        }

        //
        // If TCP/IP is not installed on local machine then DsGetDcName for
        // DNS name will fail.  Also, no LDAP or GC scopes may be used.
        // Pretend we're joined to an NT4 domain so WinNT provider will be
        // used for domain scopes.
        //

        if (ulResult == ERROR_NO_SUCH_DOMAIN)
        {
            Dbg(DEB_TRACE,
                "Attempting to get DNS name for DS DC %ws failed, treating target machine as joined to NT4 domain\n",
                pwzDomainNameForDsGetDc);

            m_mcTargetComputer = MC_JOINED_NT4;
            break;
        }

        if (ulResult != NO_ERROR)
        {
            Dbg(DEB_ERROR,
                "DsGetDcName for domain %ws (call for DNS name) returned %uL\n",
                pwzDomainNameForDsGetDc,
                ulResult);
            hr = HRESULT_FROM_WIN32(ulResult);
            break;
        }

        //
        // If the target machine is an NT4 BDC in an NT5 mixed-mode domain,
        // treat it as an NT4 DC.
        //

        if (pDsRole->MachineRole == DsRole_RoleBackupDomainController
            && GetMachineNtVer(pwzMachine) < 5)
        {
            Dbg(DEB_TRACE,
                "Target machine is an NT4 DC in NT5 mixed mode domain %ws\n",
                m_strTargetDomainDns.empty()
                    ? m_strTargetDomainFlat.c_str()
                    : m_strTargetDomainDns.c_str());

            m_mcTargetComputer = MC_NT4_DC;
            ASSERT(pwzMachine);  // we can't be running on NT4
            m_strTargetDomainDc = pwzMachine;
            break;
        }

        m_strTargetDomainDc = pdci->DomainControllerName;

        if (pDsRole->DomainNameDns)
        {
            m_strTargetDomainDns = pDsRole->DomainNameDns;
        }
        else if (pdci->DomainName)
        {
            m_strTargetDomainDns = pdci->DomainName;
        }

        m_strTargetDomainDns.strip(String::TRAILING, L'.');

        if (pdci->Flags & DS_DS_FLAG)
        {
            m_strTargetForest = pdci->DnsForestName;
            m_strTargetForest.strip(String::TRAILING, L'.');

            if (pDsRole->MachineRole == DsRole_RolePrimaryDomainController ||
                pDsRole->MachineRole == DsRole_RoleBackupDomainController)
            {
                Dbg(DEB_TRACE,
                    "Target machine is an NT5 DC for NT5 domain %ws in forest %ws\n",
                    m_strTargetDomainDns.empty()
                        ? m_strTargetDomainFlat.c_str()
                        : m_strTargetDomainDns.c_str(),
                    m_strTargetForest.c_str());

                m_mcTargetComputer = MC_NT5_DC;
            }
            else
            {
                Dbg(DEB_TRACE,
                    "Target machine is joined to NT5 domain %ws (DC is %ws) in forest %ws\n",
                    m_strTargetDomainDns.empty()
                        ? m_strTargetDomainFlat.c_str()
                        : m_strTargetDomainDns.c_str(),
                    m_strTargetDomainDc.c_str(),
                    m_strTargetForest.c_str());

                m_mcTargetComputer = MC_JOINED_NT5;
            }
        }
        else
        {
            if (pDsRole->MachineRole == DsRole_RolePrimaryDomainController ||
                pDsRole->MachineRole == DsRole_RoleBackupDomainController)
            {
                Dbg(DEB_TRACE,
                    "Target machine is an NT4 DC for domain %ws\n",
                    m_strTargetDomainFlat.c_str());
                m_mcTargetComputer = MC_NT4_DC;
            }
            else
            {
                Dbg(DEB_TRACE,
                    "Target machine is joined to NT4 domain %ws\n",
                    m_strTargetDomainFlat.c_str());

                m_mcTargetComputer = MC_JOINED_NT4;
            }
        }

    } while (0);

    if (pdci)
    {
        NetApiBufferFree(pdci);
    }

    if (pDsRole)
    {
        DsRoleFreeMemory(pDsRole);
    }
    return hr;
}




#define NT_VERSION_KEY      L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"
#define NT_VERSION_VALUE    L"CurrentVersion"

//+--------------------------------------------------------------------------
//
//  Function:   GetMachineNtVer
//
//  Synopsis:   Return the major NT version number on machine [pwzMachine]
//              as an unsigned integer, or 0 on error.
//
//  Arguments:  [pwzMachine] - machine from which to read version; NULL
//                              for local machine
//
//  History:    09-01-1999   davidmun   Created
//
//---------------------------------------------------------------------------

ULONG
GetMachineNtVer(
    PCWSTR pwzMachine)
{
    TRACE_FUNCTION(GetMachineNtVer);

    ULONG           ulVer = 0;
    HRESULT         hr = S_OK;
    CSafeReg        reg;
    WCHAR           wzBuf[20] = L"";
    NET_API_STATUS  Status = NERR_Success;
    WKSTA_INFO_100  *pinfo100 = NULL;

    do
    {
        //
        // Try to get the nt version using NetWkstaGetInfo first
        //

        String strServer;

        if (pwzMachine)
        {
            ASSERT(*pwzMachine);
            strServer = String(L"\\\\") + pwzMachine;

            Status = NetWkstaGetInfo(const_cast<PWSTR>(strServer.c_str()),
                                     100,
                                     reinterpret_cast<LPBYTE *>(&pinfo100));
        }
        else
        {
            Status = NetWkstaGetInfo(NULL,
                                     100,
                                     reinterpret_cast<LPBYTE *>(&pinfo100));
        }

        if (Status == NERR_Success)
        {
            ulVer = pinfo100->wki100_ver_major;
            Dbg(DEB_TRACE,
                "NetWkstaGetInfo returns %u.%u\n",
                pinfo100->wki100_ver_major,
                pinfo100->wki100_ver_minor);
            break;
        }

        Dbg(DEB_ERROR, "NetWkstaGetInfo error %u\n", Status);

        //
        // NetWkstaGetInfo failed.  Try to get the version number from
        // the registry.
        //

        if (pwzMachine)
        {
            CSafeReg    regRemote;

            hr = regRemote.Connect(pwzMachine, HKEY_LOCAL_MACHINE);
            BREAK_ON_FAIL_HRESULT(hr);

            hr = reg.Open(regRemote,
                          NT_VERSION_KEY,
                          STANDARD_RIGHTS_READ | KEY_QUERY_VALUE);
            BREAK_ON_FAIL_HRESULT(hr);
        }
        else
        {
            hr = reg.Open(HKEY_LOCAL_MACHINE,
                          NT_VERSION_KEY,
                          STANDARD_RIGHTS_READ | KEY_QUERY_VALUE);
            BREAK_ON_FAIL_HRESULT(hr);
        }

        hr = reg.QueryStr(NT_VERSION_VALUE, wzBuf, ARRAYLEN(wzBuf));
        BREAK_ON_FAIL_HRESULT(hr);

        ulVer = wcstoul(wzBuf, NULL, 10);
    } while (0);

    if (pinfo100)
    {
        NetApiBufferFree(pinfo100);
    }

    Dbg(DEB_TRACE,
        "%ws NT version is %ws (%u)\n",
        pwzMachine ? pwzMachine : L"Local machine",
        wzBuf,
        ulVer);

    return ulVer;
}




//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::InvokeDialog
//
//  Synopsis:   Once Initialize has been called successfully, this method
//              may be called to invoke the modal object picker dialog.
//
//  Arguments:  [hwndParent]     - parent window
//              [ppdoSelections] - filled with selected objects
//
//  Returns:    HRESULT
//
//  History:    01-20-2000   davidmun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CObjectPicker::InvokeDialog(
     HWND               hwndParent,
     IDataObject      **ppdoSelections)
{
    return InvokeDialogEx(hwndParent, NULL, ppdoSelections);
}



//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::InvokeDialogEx
//
//  Synopsis:   Invoke the modal object picker dialog.
//
//  Arguments:  [hwndParent]     - parent window of dialog
//              [pCustomizer]    - callback methods
//              [ppdoSelections] - filled with data object containing user's
//                                  selections on success
//
//  Returns:    S_FALSE - user cancelled dialog, *ppdoSelections == NULL
//              E_* - error occurred, *ppdoSelections == NULL
//              S_OK - *ppdoSelections is valid
//
//  Modifies:   *[ppdoSelections]
//
//  History:    10-07-1998   DavidMun   Created
//              01-20-2000   davidmun   rewritten
//
//---------------------------------------------------------------------------

STDMETHODIMP
CObjectPicker::InvokeDialogEx(
     HWND               hwndParent,
     ICustomizeDsBrowser *pCustomizer,
     IDataObject      **ppdoSelections)
{
    TRACE_METHOD(CObjectPicker, InvokeDialogEx);
    HRESULT hr = S_OK;

    CAutoCritSec Lock(&m_csOleFreeThreading);

    try
    {
        *ppdoSelections = NULL;

        do
        {
            if (!_IsFlagSet(CDSOP_INIT_SUCCEEDED))
            {
                PopupMessage(hwndParent, IDS_CANNOT_INVOKE);
                hr = E_UNEXPECTED;
                DBG_OUT_HRESULT(hr);
                break;
            }

            m_hwndParent = hwndParent;
            m_pExternalCustomizer = pCustomizer;

            //
            // If init succeeded we should know what the machine config is
            //

            ASSERT(m_mcTargetComputer != MC_UNKNOWN);

            //
            // Put up the dialog
            //
			LinkWindow_RegisterClass();
            hr = m_pBaseDlg->DoModal(ppdoSelections);
			LinkWindow_UnregisterClass(g_hinst);

            BREAK_ON_FAIL_HRESULT(hr);
        } while (0);

        m_hwndParent = NULL;
        m_pExternalCustomizer = NULL;
    }
    STANDARD_CATCH_BLOCK;

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::ProcessNames
//
//  Synopsis:   Process the user-entered text and any objects in the
//              rich edit control.
//
//  Arguments:  [hwndRichEdit]       - edit control containing text and
//                                      objects to process
//              [pEdsoGdiProvider]   - points to instance of object which
//                                      will provide GDI objects needed
//                                      to draw in the richedit.
//              [fForceSingleSelect] - if TRUE then the contents of the
//                                      rich edit are treated as a single
//                                      name, even if the
//                                      DSOP_FLAG_MULTISELECT flag was set
//                                      by the caller.
//
//  Returns:    TRUE if all text and every object processed successfully
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      When user-entered text is processed it is removed and
//              replaced with zero or more CEmbeddedDsObjects.  Each of these
//              objects is processed by requesting it to perform the
//              caller-specified name translation and attribute fetches, if
//              any.
//
//---------------------------------------------------------------------------

BOOL
CObjectPicker::ProcessNames(
    HWND hwndRichEdit,
    const CEdsoGdiProvider *pEdsoGdiProvider,
    BOOL fForceSingleSelect) const
{
    TRACE_METHOD(CObjectPicker, ProcessNames);

    enum PARSE_STATE
    {
        EAT_LEADING,
        EAT_TRAILING,
        EAT_DELIM
    };

    CWaitCursor                 Hourglass;
    PARSE_STATE                 ParseState = EAT_LEADING;
    NAME_PROCESS_RESULT         npr = NPR_SUCCESS;
    ULONG                       idxNextObjectToProcess = 0;
    IRichEditOle               *pRichEditOle = NULL;

    LRESULT lResult = SendMessage(hwndRichEdit,
                                 EM_GETOLEINTERFACE,
                                 0,
                                 (LPARAM) &pRichEditOle);
    if (!lResult)
    {
        DBG_OUT_LASTERROR;
        PopupMessage(hwndRichEdit,
                     IDS_CANNOT_READ_RICHEDIT,
                     lResult);
        return FALSE;
    }

    CRichEditHelper re(*this,
                       hwndRichEdit,
                       pEdsoGdiProvider,
                       pRichEditOle,
                       fForceSingleSelect);
    CRichEditHelper::iterator itCur = re.begin();

    while (!NAME_PROCESSING_FAILED(npr) && itCur != re.end())
    {
        switch (ParseState)
        {
        case EAT_LEADING:
            re.Consume(itCur, L" \r\t;");

            if (itCur == re.end())
            {
                break;
            }

            // if itCur is an object, advance past and eat trailing

            if (re.IsObject(itCur))
            {
                npr = re.ProcessObject(itCur, idxNextObjectToProcess);

                if (!NAME_PROCESSING_FAILED(npr))
                {
                    itCur++;
                    idxNextObjectToProcess++;
                    ParseState = EAT_TRAILING;
                }
                break;
            }

            //
            // itCur is at start of some text. convert it to object(s) or
            // delete it.
            //

            npr = re.MakeObject(itCur);
            break;

        case EAT_TRAILING:
            re.Consume(itCur, L" \t");

            // exit switch if nothing to the right of itCur

            if (itCur == re.end())
            {
                break;
            }

            if (re.ReadChar(itCur) == L'\r')
            {
                re.ReplaceChar(itCur, L';');
            }

            if (re.ReadChar(itCur) == L';')
            {
                itCur++;
                ParseState = EAT_DELIM;
                break;
            }

            //
            // itCur is at text or object. since we're eating trailing spaces
            // that means there's an object to the left of itCur.  insert
            // a delimiter, move past it, and switch to eating leading spaces.
            //

            re.Insert(itCur, L"; ");
            itCur += 2;
            ParseState = EAT_LEADING;
            break;

        case EAT_DELIM:
            re.Consume(itCur, L";\r");

            if (itCur == re.end())
            {
                break;
            }

            if (iswspace(re.ReadChar(itCur)))
            {
                itCur++;
                ParseState = EAT_LEADING;
                break;
            }

            //
            // itCur is at non-whitespace text or object which is folloinwg
            // directly after a semicolon.  add a space and move past it, then
            // switch to eating leading.
            //

            re.Insert(itCur, L" ");
            itCur++;
            ParseState = EAT_LEADING;
            break;
        }
    }

    SAFE_RELEASE(pRichEditOle);

    if (NAME_PROCESSING_FAILED(npr))
    {
        return FALSE;
    }

    re.TrimTrailing(L"; \t");
    return re.begin() != re.end();
}




//+---------------------------------------------------------------------------
//
//  Member:     CObjectPicker::AddRef
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CObjectPicker::AddRef()
{
    ULONG ul = InterlockedIncrement((LONG *) &m_cRefs);
    //Dbg(DEB_TRACE, "AddRef new refcount is %d\n", ul);
    return ul;
}




//+---------------------------------------------------------------------------
//
//  Member:     CObjectPicker::Release
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CObjectPicker::Release()
{
    ULONG cRefsTemp = InterlockedDecrement((LONG *)&m_cRefs);

    //Dbg(DEB_TRACE, "Release new refcount is %d\n", cRefsTemp);

    if (0 == cRefsTemp)
    {
        delete this;
    }

    return cRefsTemp;
}




//+--------------------------------------------------------------------------
//
//  Member:     CObjectPicker::QueryInterface
//
//  Synopsis:   Standard OLE
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CObjectPicker::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    HRESULT hr = S_OK;

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppvObj = (IUnknown *)this;
        }
        else if (IsEqualIID(riid, IID_IDsObjectPicker))
        {
            *ppvObj = (IUnknown *)this;
        }
        else if (IsEqualIID(riid, IID_IDsObjectPickerEx))
        {
            *ppvObj = (IUnknown *)this;
        }
        else
        {
            DBG_OUT_NO_INTERFACE("CObjectPicker", riid);
            hr = E_NOINTERFACE;
            *ppvObj = NULL;
            break;
        }

        //
        // If we got this far we are handing out a new interface pointer on
        // this object, so addref it.
        //

        AddRef();
    } while (0);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\qclass.h ===
#undef QUERY_CLASS_ENTRY
#define QUERY_CLASS_ENTRY(ClassEnum, ClassStr)

#if defined(QUERY_CLASS_ENUM)
#undef QUERY_CLASS_ENTRY
#define QUERY_CLASS_ENTRY(ClassEnum, ClassStr)  ClassEnum
#elif defined(QUERY_CLASS_ARRAY)
#undef QUERY_CLASS_ENTRY
#define QUERY_CLASS_ENTRY(ClassEnum, ClassStr)  ClassStr
#endif

QUERY_CLASS_ENTRY(QUERY_CLASS_USER,       L"CN=user"),
QUERY_CLASS_ENTRY(QUERY_CLASS_CONTACT,    L"CN=contact"),
QUERY_CLASS_ENTRY(QUERY_CLASS_COMPUTER,   L"CN=computer"),
QUERY_CLASS_ENTRY(QUERY_CLASS_GROUP,      L"CN=group")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\pathwrap.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       pathwrap.cxx
//
//  Contents:   Utility class for thread safe set/retrieve operations on
//              an IADsPathname interface.
//
//  Classes:    CADsPathWrapper
//
//  History:    08-08-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


DEBUG_DECLARE_INSTANCE_COUNTER(CADsPathWrapper)


//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::CADsPathWrapper
//
//  Synopsis:   ctor
//
//  History:    08-08-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CADsPathWrapper::CADsPathWrapper():
        m_cRefs(1),
        m_cLocks(0)
{
    TRACE_CONSTRUCTOR(CADsPathWrapper);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CADsPathWrapper);

    HRESULT hr;

    InitializeCriticalSection(&m_cs);

    do
    {
        hr = m_rpADsPath.AcquireViaCreateInstance(
                              CLSID_Pathname,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IADsPathname);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = m_rpADsPath->put_EscapedMode(ADS_ESCAPEDMODE_OFF);
        ASSERT(SUCCEEDED(hr));
    } while (0);
}




//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::~CADsPathWrapper
//
//  Synopsis:   dtor
//
//  History:    08-08-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CADsPathWrapper::~CADsPathWrapper()
{
    TRACE_DESTRUCTOR(CADsPathWrapper);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CADsPathWrapper);

    ASSERT(!m_cLocks);
    DeleteCriticalSection(&m_cs);
}



//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::SetRetrieve
//
//  Synopsis:   Perform an atomic set and retrieve
//
//  Arguments:  [ulFmtIn]  - ADS_SETTYPE_*
//              [pwzIn]    - ADs path to set
//              [ulFmtOut] - ADS_FORMAT_*
//              [pbstrOut] - filled with BSTR containing new format
//
//  Returns:    HRESULT
//
//  Modifies:   *[pbstrOut]
//
//  History:    08-08-1998   DavidMun   Created
//
//  Notes:      Caller must SysFreeString(*[pbstrOut])
//
//---------------------------------------------------------------------------

HRESULT
CADsPathWrapper::SetRetrieve(
    ULONG   ulFmtIn,
    PCWSTR  pwzIn,
    ULONG   ulFmtOut,
    BSTR   *pbstrOut)
{
    ASSERT(pwzIn);
    ASSERT(pbstrOut);

    if (!m_rpADsPath.get())
    {
        return E_FAIL;
    }

    HRESULT hr = S_OK;

    do
    {
        CAutoCritSec Lock(&m_cs);

        *pbstrOut = NULL;

        hr = m_rpADsPath->Set((PWSTR)pwzIn, ulFmtIn);

        if (FAILED(hr))
        {
            Dbg(DEB_TRACE,
                "IADsPathName::Set(%ws,%#x) hr=%#x\n",
                pwzIn,
                ulFmtIn,
                hr);
            break;
        }

        hr = m_rpADsPath->Retrieve(ulFmtOut, pbstrOut);

        if (FAILED(hr))
        {
            Dbg(DEB_TRACE,
                "IADsPathName::Retrieve(%#x) hr=%#x\n",
                ulFmtOut,
                hr);
            break;
        }

    } while (0);

    return hr;
}




HRESULT
CADsPathWrapper::SetRetrieveContainer(
    ULONG   ulFmtIn,
    PCWSTR  pwzIn,
    ULONG   ulFmtOut,
    BSTR   *pbstrOut)
{
    if (!m_rpADsPath.get())
    {
        return E_FAIL;
    }

    HRESULT hr = S_OK;

    do
    {
        CAutoCritSec Lock(&m_cs);

        *pbstrOut = NULL;

        hr = m_rpADsPath->Set((PWSTR)pwzIn, ulFmtIn);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = m_rpADsPath->RemoveLeafElement();
        BREAK_ON_FAIL_HRESULT(hr);

        hr = m_rpADsPath->Retrieve(ulFmtOut, pbstrOut);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}


#define LDAP_GC_PORT_STR    L":3268"


//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::ConvertProvider
//
//  Synopsis:   Substitute provider string [pwzNewProvider] for the
//              provider in ADsPath [pstrPath].
//
//  Arguments:  [pstrPath]       - points to path to modify
//              [pwzNewProvider] - new provider
//
//  Returns:    S_OK or E_INVALIDARG (if [pstrPath] is ill-formed)
//
//  Modifies:   *[pstrPath]
//
//  History:    02-11-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CADsPathWrapper::ConvertProvider(
    String *pstrPath,
    PCWSTR pwzNewProvider)
{
    size_t idxDelim = pstrPath->find(L"://");

    if (idxDelim == String::npos || idxDelim == 0)
    {
        DBG_OUT_HRESULT(E_INVALIDARG);
        return E_INVALIDARG;
    }

    pstrPath->StringBase::replace(0, idxDelim, pwzNewProvider);

    //
    // If there's a GC port number, remove it.
    //

    idxDelim = pstrPath->find(LDAP_GC_PORT_STR);

    if (idxDelim != String::npos)
    {
        pstrPath->erase(idxDelim, lstrlen(LDAP_GC_PORT_STR));
    }

    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::GetMostSignificantElement
//
//  Synopsis:   Return the path element closest to the provider type.
//
//  Arguments:  [pwzIn]    - ADS path to set
//              [pbstrOut] - most significant element
//
//  Returns:    HRESULT
//
//  Modifies:   *[pbstrOut]
//
//  History:    01-22-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CADsPathWrapper::GetMostSignificantElement(
    PCWSTR  pwzIn,
    BSTR   *pbstrOut)
{
    if (!m_rpADsPath.get())
    {
        return E_FAIL;
    }

    HRESULT hr = S_OK;

    do
    {
        CAutoCritSec Lock(&m_cs);

        *pbstrOut = NULL;

        hr = m_rpADsPath->Set((PWSTR)pwzIn, ADS_SETTYPE_FULL);
        BREAK_ON_FAIL_HRESULT(hr);

        long cElements;

        hr = m_rpADsPath->GetNumElements(&cElements);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(cElements > 0);

        hr = m_rpADsPath->GetElement(cElements - 1, pbstrOut);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    return hr;
}



HRESULT
CADsPathWrapper::GetWinntPathServerName(
    PCWSTR  pwzIn,
    BSTR   *pbstrOut)
{
    if (!m_rpADsPath.get())
    {
        return E_FAIL;
    }

    HRESULT hr = S_OK;

    do
    {
        CAutoCritSec Lock(&m_cs);

        *pbstrOut = NULL;

        hr = m_rpADsPath->Set((PWSTR)pwzIn, ADS_SETTYPE_FULL);
        BREAK_ON_FAIL_HRESULT(hr);

        long cElements;

        hr = m_rpADsPath->GetNumElements(&cElements);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(cElements > 0);

        // the server name is the most significant element in some
        // cases, like WinNT://server/user (form 1), but not always, as in
        // WinNT://workgroup/server/user or WinNT://domain/server/user (form 2)

        // Not astonishingly, given the all-around badness of
        // IADsPathname, the server format returns the domain name for form
        // (2) paths, and the server name for form (1) paths.  And the 1st
        // element of the path after the provider name is unreachable
        // except with Retrieve!  

        if (cElements >= 2)
        {
            // form 2 name, so get the next-to-last element

            hr = m_rpADsPath->GetElement(1, pbstrOut);
            BREAK_ON_FAIL_HRESULT(hr);
        }
        else
        {
            // form 1 name

            hr = m_rpADsPath->Retrieve(ADS_FORMAT_SERVER, pbstrOut);
            BREAK_ON_FAIL_HRESULT(hr);
        }

    } while (0);

    return hr;
}

HRESULT
CADsPathWrapper::GetWinntPathRDN(
		PCWSTR pwzIn,
		String *pstrRDN)
{
	if(!pwzIn || !pstrRDN)
		return E_POINTER;

    if (!m_rpADsPath.get())
    {
        return E_FAIL;
    }

    HRESULT hr = S_OK;

    do
    {
        CAutoCritSec Lock(&m_cs);
		pstrRDN->erase();

        hr = m_rpADsPath->Set((PWSTR)pwzIn, ADS_SETTYPE_FULL);
        BREAK_ON_FAIL_HRESULT(hr);

        long cElements;

        hr = m_rpADsPath->GetNumElements(&cElements);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(cElements > 0);

		// path can have following format. (form1) WinNT://servername
		// (form2) WinNT://server/user,
		// (form3) WinNT://workgroup/server/user or WinNT://domain/server/user 
		// In form1 there is no rdn while in 2 and 3 least significant element is 
		// RDN


        if (cElements >= 2)
        {
            // form 2 or 3 name, so get the last element

			BSTR bstr;
            hr = m_rpADsPath->GetElement(0, &bstr);
            BREAK_ON_FAIL_HRESULT(hr);
			
			*pstrRDN = bstr;
			SysFreeString(bstr);
        }

    } while (0);

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::Set
//
//  Synopsis:   Wrap IADsPathname::Set.
//
//  History:    3-12-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CADsPathWrapper::Set(
    PCWSTR pwzPath,
    long lSetType)
{
    //TRACE_METHOD(CADsPathWrapper, Set);
    ASSERT(m_cLocks);

    if (!m_rpADsPath.get())
    {
        return E_FAIL;
    }

    return m_rpADsPath->Set((PWSTR) pwzPath, lSetType);
}




//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::GetNumElements
//
//  Synopsis:   Wrap IADsPathname::GetNumElements.
//
//  History:    3-12-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CADsPathWrapper::GetNumElements(
    long *pcElem)
{
    //TRACE_METHOD(CADsPathWrapper, GetNumElements);
    ASSERT(m_cLocks);

    if (!m_rpADsPath.get())
    {
        return E_FAIL;
    }

    return m_rpADsPath->GetNumElements(pcElem);
}




//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::Escape
//
//  Synopsis:   Escape name element [pwzIn].
//
//  Arguments:  [pwzIn]    - element to escape
//              [pbstrOut] - filled with BSTR containing escaped element
//
//  Returns:    HRESULT
//
//  Modifies:   *[pbstrOut]
//
//  History:    5-04-1999   davidmun   Created
//
//  Notes:      Caller must call SysFreeString on returned BSTR.
//
//---------------------------------------------------------------------------

HRESULT
CADsPathWrapper::Escape(
    PCWSTR pwzIn,
    BSTR *pbstrOut)
{
    HRESULT hr = S_OK;

    do
    {
        if (!m_rpADsPath.get())
        {
            hr = E_FAIL;
            DBG_OUT_HRESULT(hr);
            break;
        }

        CAutoCritSec Lock(&m_cs);

        hr = m_rpADsPath->Set(L"LDAP", ADS_SETTYPE_PROVIDER);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = m_rpADsPath->GetEscapedElement(0, (PWSTR)pwzIn, pbstrOut);
        CHECK_HRESULT(hr);
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::GetElement
//
//  Synopsis:   Wrap IADsPathname::GetElement.
//
//  History:    3-12-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CADsPathWrapper::GetElement(
    long idxElem,
    BSTR *pbstrElem)
{
    //TRACE_METHOD(CADsPathWrapper, GetElement);
    ASSERT(m_cLocks);

    if (!m_rpADsPath.get())
    {
        return E_FAIL;
    }

    return m_rpADsPath->GetElement(idxElem, pbstrElem);
}




//+--------------------------------------------------------------------------
//
//  Member:     CADsPathWrapper::RemoveLeafElement
//
//  Synopsis:   Wrap IADsPathname::RemoveLeafElement.
//
//  History:    3-12-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CADsPathWrapper::RemoveLeafElement()
{
    //TRACE_METHOD(CADsPathWrapper, RemoveLeafElement);
    ASSERT(m_cLocks);

    if (!m_rpADsPath.get())
    {
        return E_FAIL;
    }

    return m_rpADsPath->RemoveLeafElement();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\namenotfounddlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       NameNotFoundDlg.cxx
//
//  Contents:   Name not found dialog class
//
//  Classes:    CNameNotFoundDlg
//
//  History:    03-28-2000   DavidMun   Created from reenter.cxx
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

static ULONG
s_aulHelpIds[] =
{
    IDC_LOOK_FOR_PB,            IDH_LOOK_FOR_PB,
    IDC_LOOK_FOR_EDIT,          IDH_LOOK_FOR_EDIT,
    IDC_LOOK_IN_PB,             IDH_LOOK_IN_PB,
    IDC_LOOK_IN_EDIT,           IDH_LOOK_IN_EDIT,
    IDC_CORRECT_RADIO,          IDH_CORRECT_RADIO,
    IDC_CORRECT_EDIT,           IDH_CORRECT_EDIT,
    IDC_REMOVE_RADIO,           IDH_REMOVE_RADIO,
    IDC_NOT_FOUND_MESSAGE,      ULONG_MAX,
    0,0
};




//+--------------------------------------------------------------------------
//
//  Member:     CNameNotFoundDlg::DoModalDialog
//
//  Synopsis:   Invoke the name not found dialog as a modal dialog.
//
//  Arguments:  [hwndParent] - dialog parent.
//
//  Returns:    S_OK    - user corrected name and hit OK
//              S_FALSE - user hit cancel
//
//  History:    08-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CNameNotFoundDlg::DoModalDialog(
    HWND hwndParent,
    NAME_PROCESS_RESULT *pnpr)
{
    TRACE_METHOD(CNameNotFoundDlg, DoModalDialog);

    m_pnpr = pnpr;
    _DoModalDlg(hwndParent, IDD_NAMENOTFOUND);
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CNameNotFoundDlg::_OnInit
//
//  Synopsis:   Initialize dialog controls
//
//  Arguments:  [pfSetFocus] - set to FALSE
//
//  Returns:    S_OK
//
//  History:    08-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CNameNotFoundDlg::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CNameNotFoundDlg, _OnInit);



    const CFilterManager &rfm = m_rop.GetFilterManager();
    const CScopeManager &rsm = m_rop.GetScopeManager();
    String strLookFor = rfm.GetFilterDescription(m_hwnd, FOR_LOOK_FOR);

    //
    // Init the Look For and Look In r/o edit controls
    //

    Edit_SetText(GetDlgItem(m_hwnd, IDC_LOOK_IN_EDIT),
                 rsm.GetCurScope().GetDisplayName().c_str());
    Edit_SetText(GetDlgItem(m_hwnd, IDC_LOOK_FOR_EDIT),
                 strLookFor.c_str());

	//
	//Truncate the object name to MAX_OBJECTNAME_DISPLAY_LEN
	//
	String strObjectName = *m_pstrName;
	if(!strObjectName.empty() && (strObjectName.size() > MAX_OBJECTNAME_DISPLAY_LEN))
	{
		strObjectName.erase(MAX_OBJECTNAME_DISPLAY_LEN,strObjectName.size());
		//
		//Add three dots to indicate that name is truncated
		//
		strObjectName.append(L"...");
	}

	//
	// Change the IDC_REMOVE_RADIO string to reflect object name
	//
	if(!strObjectName.empty())
	{
		String strRadio = String::format(IDS_REMOVE_FROM_SEL,
                                         strObjectName.c_str());

		SetWindowText(GetDlgItem(m_hwnd, IDC_REMOVE_RADIO), 
					  strRadio.c_str());

	}
    //
    // Init the error message
    //	
    if (!m_strError.empty())
    {
        Edit_SetText(_hCtrl(IDC_NOT_FOUND_MESSAGE), m_strError.c_str());
    }
    else
    {
        String strLabel = String::format(static_cast<unsigned>(m_idsError),
                                         strObjectName.c_str());

        Edit_SetText(_hCtrl(IDC_NOT_FOUND_MESSAGE), strLabel.c_str());
    }
    Button_SetCheck(_hCtrl(IDC_CORRECT_RADIO), BST_CHECKED);
    Edit_SetText(_hCtrl(IDC_CORRECT_EDIT), m_pstrName->c_str());
    SetFocus(_hCtrl(IDC_CORRECT_EDIT));
    *pfSetFocus = FALSE;
    DisableSystemMenuClose(m_hwnd);

    return S_OK;
}





//+--------------------------------------------------------------------------
//
//  Member:     CNameNotFoundDlg::_OnCommand
//
//  Synopsis:   Handle user input.
//
//  Arguments:  standard windows
//
//  Returns:    standard windows
//
//  History:    08-14-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CNameNotFoundDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fNotHandled = FALSE;

    switch (LOWORD(wParam))
    {
    case IDC_LOOK_IN_PB:
    {
        Dbg(DEB_TRACE, "UA: (NameNotFoundDlg) hit Look In button\n");
        const CFilterManager &rfm = m_rop.GetFilterManager();
        const CScopeManager &rsm = m_rop.GetScopeManager();

        rsm.DoLookInDialog(m_hwnd);
        rfm.HandleScopeChange(m_hwnd);

        Edit_SetText(GetDlgItem(m_hwnd, IDC_LOOK_IN_EDIT),
                     rsm.GetCurScope().GetDisplayName().c_str());
        Edit_SetText(GetDlgItem(m_hwnd, IDC_LOOK_FOR_EDIT),
                     rfm.GetFilterDescription(m_hwnd, FOR_LOOK_FOR).c_str());
        break;
    }

    case IDC_LOOK_FOR_PB:
    {
        Dbg(DEB_TRACE, "UA: (NameNotFoundDlg) hit Look For button\n");

        const CFilterManager &rfm = m_rop.GetFilterManager();
        rfm.DoLookForDialog(m_hwnd);
        Edit_SetText(GetDlgItem(m_hwnd, IDC_LOOK_FOR_EDIT),
                     rfm.GetFilterDescription(m_hwnd, FOR_LOOK_FOR).c_str());
        break;
    }

    case IDOK:
    {
        if (BST_CHECKED == Button_GetCheck(_hCtrl(IDC_REMOVE_RADIO)))
        {
            Dbg(DEB_TRACE, "UA: (NameNotFoundDlg) hit OK, remove radio is selected\n");
            *m_pnpr = NPR_DELETE;
        }
        else
        {
            *m_pnpr = NPR_EDITED;

            WCHAR wzName[MAX_PATH] = L"";

            Edit_GetText(_hCtrl(IDC_CORRECT_EDIT), wzName, ARRAYLEN(wzName));
            *m_pstrName = wzName;
            m_pstrName->strip(String::BOTH);
            Dbg(DEB_TRACE,
                "UA: (NameNotFoundDlg) hit OK, edited name is '%ws'\n",
                m_pstrName->c_str());
        }
        EndDialog(m_hwnd, S_OK);
    }
    break;

    case IDCANCEL:
        Dbg(DEB_TRACE, "UA: (NameNotFoundDlg) hit Cancel\n");
        *m_pnpr = NPR_STOP_PROCESSING;
        EndDialog(m_hwnd, E_FAIL);
        break;

    case IDC_CORRECT_RADIO:
        Dbg(DEB_TRACE, "UA: (NameNotFoundDlg) hit Correct radio button\n");
        _EnableCorrectionCtrls(TRUE);
        wParam = MAKEWPARAM(0, EN_UPDATE);
        // FALL THROUGH

    case IDC_CORRECT_EDIT:
    if (HIWORD(wParam) == EN_UPDATE)
    {
        WCHAR wzName[MAX_PATH] = L"";

        Edit_GetText(_hCtrl(IDC_CORRECT_EDIT), wzName, ARRAYLEN(wzName));
        StripLeadTrailSpace(wzName);

        if (!*wzName)
        {
            EnableWindow(_hCtrl(IDOK), FALSE);
        }
        else
        {
            EnableWindow(_hCtrl(IDOK), TRUE);
        }
    }
    break;

    case IDC_REMOVE_RADIO:
        Dbg(DEB_TRACE, "UA: (NameNotFoundDlg) hit Remove radio button\n");
        _EnableCorrectionCtrls(FALSE);
        EnableWindow(_hCtrl(IDOK), TRUE);
        break;

    default:
        fNotHandled = TRUE;
        break;
    }

    return fNotHandled;
}




//+--------------------------------------------------------------------------
//
//  Member:     CNameNotFoundDlg::_EnableCorrectionCtrls
//
//  Synopsis:   Enable or disable child controls according to [fEnable]
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CNameNotFoundDlg::_EnableCorrectionCtrls(
    BOOL fEnable)
{
    EnableWindow(_hCtrl(IDC_LOOK_FOR_EDIT), fEnable);
    EnableWindow(_hCtrl(IDC_LOOK_FOR_PB), fEnable);
    EnableWindow(_hCtrl(IDC_LOOK_IN_EDIT), fEnable);
    EnableWindow(_hCtrl(IDC_LOOK_IN_PB), fEnable);
    EnableWindow(_hCtrl(IDC_CORRECT_EDIT), fEnable);
    EnableWindow(_hCtrl(IDC_LOOK_FOR_LBL), fEnable);
    EnableWindow(_hCtrl(IDC_LOOK_IN_LBL), fEnable);
    EnableWindow(_hCtrl(IDC_NAME_LBL), fEnable);
}




//+--------------------------------------------------------------------------
//
//  Member:     CNameNotFoundDlg::_OnHelp
//
//  Synopsis:   Display context sensitive help for requested item
//
//  Arguments:  [message] -
//              [wParam]  -
//              [lParam]  -
//
//  History:    10-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CNameNotFoundDlg::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CObjectSelect, _OnHelp);

    InvokeWinHelp(message, wParam, lParam, c_wzHelpFilename, s_aulHelpIds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\qclause.h ===
#undef QUERY_CLAUSE_ENTRY
#define QUERY_CLAUSE_ENTRY(QC, Class, Format)

#if defined(QUERY_CLAUSE_ENUM)
#undef QUERY_CLAUSE_ENTRY
#define QUERY_CLAUSE_ENTRY(QC, Class, Format)  QC
#elif defined(QUERY_CLAUSE_ARRAY)
#undef QUERY_CLAUSE_ENTRY
#define QUERY_CLAUSE_ENTRY(QC, Class, Format)  { Class, Format }
#endif


QUERY_CLAUSE_ENTRY(QUERY_CLAUSE_USER,               QUERY_CLASS_USER,     c_tzUserQueryFmt),
QUERY_CLAUSE_ENTRY(QUERY_CLAUSE_CONTACT,            QUERY_CLASS_CONTACT,  c_tzContactQueryFmt),
QUERY_CLAUSE_ENTRY(QUERY_CLAUSE_COMPUTER,           QUERY_CLASS_COMPUTER, c_tzComputerQueryFmt),
QUERY_CLAUSE_ENTRY(QUERY_CLAUSE_GROUP_NON_SE,       QUERY_CLASS_GROUP,    c_tzGroupNonSE),
QUERY_CLAUSE_ENTRY(QUERY_CLAUSE_GROUP_SE,           QUERY_CLASS_GROUP,    c_tzGroupSE),
QUERY_CLAUSE_ENTRY(QUERY_CLAUSE_GROUP_BOTH,         QUERY_CLASS_GROUP,    c_tzGroupBoth)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\progress.cpp ===
// Copyright (C) 2001 Microsoft Corporation
//
// Dialog to display Query progress
//
// Author hiteshr, ported from sburns DCPromo implementation



#include "headers.hxx"


struct Wrapper_ThreadProcParams
{
   CProgressDialog*             dialog;
   CProgressDialog::ThreadProc  realProc;
};


DWORD WINAPI
wrapper_ThreadProc(void* p)
{
   ASSERT(p);

   Wrapper_ThreadProcParams* params =
      reinterpret_cast<Wrapper_ThreadProcParams*>(p);
   ASSERT(params->dialog);
   ASSERT(params->realProc);

   return params->realProc(*(params->dialog));

}
   


CProgressDialog::CProgressDialog(ThreadProc ThreadProc,
								 int	iAnimationResId,
								 DWORD dwWaitTime,
								 CRow * pRow,
								 ULONG flProcess,
								 BOOL bXForest,
								 const CObjectPicker &rop,
								 const CScope &Scope,
								 const String &strUserEnteredString,
								 CDsObjectList *pdsolMatches):
	m_hThread(NULL),
	m_ThreadProc(ThreadProc),
	m_pThreadParams(NULL),
	m_iAnimationResId(iAnimationResId),
	m_dwWaitTime(dwWaitTime),
	m_bStop(FALSE),
	m_hWorkerThreadEvent(NULL),
	m_hSemaphore(NULL),
	m_pRow(pRow), 
	m_flProcess(flProcess), 
	m_bXForest(bXForest),
	m_rop(rop),
	m_Scope(Scope),
	m_strUserEnteredString(strUserEnteredString),
	m_pdsolMatches(pdsolMatches)
{
	ASSERT(m_ThreadProc);
	ASSERT(m_iAnimationResId > 0);

	m_hWorkerThreadEvent = CreateEvent(NULL, FALSE,FALSE,NULL);
	ASSERT(m_hWorkerThreadEvent);
	m_hSemaphore = CreateSemaphore(NULL,1,1,NULL); 
	ASSERT(m_hSemaphore);
}



CProgressDialog::~CProgressDialog()
{
	if(m_pThreadParams)
		LocalFree(m_pThreadParams);
	if(m_hWorkerThreadEvent)
		CloseHandle(m_hWorkerThreadEvent);
	if(m_hSemaphore)
		CloseHandle(m_hSemaphore);
	if(m_hThread)
		CloseHandle(m_hThread);
}

HRESULT
CProgressDialog::CreateProgressDialog(HWND hwndParent)
{
	HRESULT hr = S_OK;
	hr = CreateThread();
	if(FAILED(hr))
	{
		return hr;
	}		

	//
	//Wait for m_dwWaitTime milliseconds for Worker thread to finish.
	//Worker thread will signal m_hThreadDone event once it's done.
	//
	DWORD dwWaitResult = WaitForSingleObject(m_hWorkerThreadEvent, m_dwWaitTime);	//Step1	
	if(dwWaitResult == WAIT_TIMEOUT)
	{
		//
		//Wait for the Semaphore
		//
		dwWaitResult= WaitForSingleObject(m_hSemaphore,INFINITE);	//Step2
		if(dwWaitResult == WAIT_OBJECT_0)
		{
			//
			//Check if the WorkerThread is done between Step1 and Step2
			//
			dwWaitResult = WaitForSingleObject(m_hWorkerThreadEvent,0);		
			if(dwWaitResult == WAIT_TIMEOUT)
			{
				//
				//Worker thread is not done. Show the dialog box.
				//Now worker thread cannot finish until we release the 
				//semaphore in WM_INIT. 
				//
				DoModalDlg(hwndParent);			
			}
			else
			{
				ULONG lUnused = 0;
				ReleaseSemaphore(m_hSemaphore, 1, (LPLONG)&lUnused);
				ASSERT(lUnused == 0);
			}
		}
	}
	
	//
	//Wait for worker thread to finish
	//
	WaitForSingleObject(m_hThread, INFINITE);

	return hr;
}	

HRESULT
CProgressDialog::ThreadDone()
{
	DWORD dwWaitResult = 0;
	//
	//Wait for the semaphore
	//
	dwWaitResult = WaitForSingleObject(m_hSemaphore,INFINITE);
	if(dwWaitResult == WAIT_OBJECT_0)
	{	
		//
		//If the dialog box is created, send a message to it.
		//
		if(GetHwnd())
		{
			PostMessage(GetHwnd(),THREAD_SUCCEEDED,0,0);
		}
		SetEvent(m_hWorkerThreadEvent);
		
		ULONG lUnused = 0;
		ReleaseSemaphore(m_hSemaphore, 1, (LPLONG)&lUnused);
		ASSERT(lUnused == 0);
	}
	return S_OK;
}

void
CProgressDialog::UpdateText(const String& message)
{
   SetDlgItemText(GetHwnd(), IDC_PRO_STATIC,message.c_str());
}




HRESULT
CProgressDialog::_OnInit(BOOL * /*pfSetFocus*/)
{
	Animate_Open(GetDlgItem(GetHwnd(), IDC_ANIMATION),
				 MAKEINTRESOURCE(m_iAnimationResId));
	//
	//Release the semaphore. This semaphore is acquired
	//before creating the dialogbox window by calling 
	//DoModal
	//
	ULONG lUnused = 0;
	ReleaseSemaphore(m_hSemaphore, 1, (LPLONG)&lUnused);
	ASSERT(lUnused == 0);
	return S_OK;
}

HRESULT
CProgressDialog::CreateThread()
{

	m_pThreadParams	= (Wrapper_ThreadProcParams*)
		LocalAlloc(LPTR,sizeof Wrapper_ThreadProcParams);
	
	if(!m_pThreadParams)
		return E_OUTOFMEMORY;
   
	m_pThreadParams->dialog   = this;      
	m_pThreadParams->realProc = m_ThreadProc;

	//
	//Start worker thread
	//
	ULONG idThread = 0;
	m_hThread = ::CreateThread(NULL,
							   0,
							   wrapper_ThreadProc,
							   m_pThreadParams,
							   0,
							   &idThread);
	if(!m_hThread)
	{
		return HRESULT_FROM_WIN32(GetLastError());			
	}

	return S_OK;
}




BOOL
CProgressDialog::_OnCommand(WPARAM wParam, LPARAM /*lParam*/)
{

	BOOL fHandled = TRUE;
    switch (LOWORD(wParam))
    {
		case IDCANCEL:
			EnableWindow(GetDlgItem(GetHwnd(),IDCANCEL),false);
			m_bStop = TRUE;
			break;

		default:
			fHandled = FALSE;
			break;
    }

    return fHandled;

}



BOOL
CProgressDialog::OnProgressMessage(
   UINT     message,
   WPARAM    /*wparam*/  ,
   LPARAM    /*lparam*/  )
{

   switch (message)
   {
      case THREAD_SUCCEEDED:
      {
         Animate_Stop(GetDlgItem(GetHwnd(), IDC_ANIMATION));
         HRESULT hr = EndDialog(GetHwnd(), THREAD_SUCCEEDED);
         ASSERT(SUCCEEDED(hr));
         return true;
      }
      case THREAD_FAILED:
      {
         Animate_Stop(GetDlgItem(GetHwnd(), IDC_ANIMATION));         
         HRESULT hr = EndDialog(GetHwnd(), THREAD_FAILED);
         ASSERT(SUCCEEDED(hr));
         return true;
      }	
      default:
      {
         // do nothing
         break;
      }
   }
   return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\querybuildertab.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       QueryBuilder.hxx
//
//  Contents:   Implementation of dialog that produces an LDAP filter from
//              attributes, conditions, and values selected by the user.
//
//  Classes:    CQueryBuilderTab
//
//  History:    04-03-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


static ULONG
s_aulHelpIds[] =
{
    IDC_CLAUSE_LIST,        IDH_CLAUSE_LIST,
    IDC_ADD_BTN,            IDH_ADD_BTN,
    IDC_EDIT_BTN,           IDH_EDIT_BTN,
    IDC_REMOVE_BTN,         IDH_REMOVE_BTN,
    0,0
};


//
// A pointer to an instance of this structure is stored as the lParam
// value for each item in the clause listview.
//

struct SQueryClause
{
    SQueryClause():
        pvSavedAddClauseState(NULL),
        akReferenced(AK_INVALID)
    {
    }

    String      strLdapFilter;
    ATTR_KEY    akReferenced;
    PVOID       pvSavedAddClauseState;

private:

    SQueryClause(const SQueryClause &);

    SQueryClause &
    operator= (const SQueryClause &);
};




//+--------------------------------------------------------------------------
//
//  Member:     CQueryBuilderTab::CQueryBuilderTab
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - containing instance of object picker
//
//  History:    05-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CQueryBuilderTab::CQueryBuilderTab(
    const CObjectPicker &rop):
        CAdvancedDlgTab(rop),
        m_pfnFindValidCallback(NULL),
        m_CallbackLparam(0),
        m_fNonEmpty(FALSE)
{
    TRACE_CONSTRUCTOR(CQueryBuilderTab);
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryBuilderTab::~CQueryBuilderTab
//
//  Synopsis:   dtor
//
//  History:    05-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CQueryBuilderTab::~CQueryBuilderTab()
{
    TRACE_DESTRUCTOR(CQueryBuilderTab);

    m_pfnFindValidCallback = NULL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryBuilderTab::DoModelessDlg
//
//  Synopsis:   Create the modeless dialog contained within tab control
//              which has window handle [hwndTab].
//
//  Arguments:  [hwndTab] - handle to tab control window
//
//  History:    05-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CQueryBuilderTab::DoModelessDlg(
    HWND hwndTab)
{
    TRACE_METHOD(CQueryBuilderTab, DoModelessDlg);

    HWND hwndDlg = _DoModelessDlg(hwndTab, IDD_QUERY_BUILDER);

    if (!hwndDlg)
    {
        DBG_OUT_LASTERROR;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryBuilderTab::Show
//
//  Synopsis:   Make the dialog window visible and enabled.
//
//  History:    05-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CQueryBuilderTab::Show() const
{
    TRACE_METHOD(CQueryBuilderTab, Show);

    ShowWindow(m_hwnd, SW_SHOW);
    EnableWindow(m_hwnd, TRUE);
    Refresh();
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryBuilderTab::Hide
//
//  Synopsis:   Make the dialog window hidden and disabled
//
//  History:    05-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CQueryBuilderTab::Hide() const
{
    TRACE_METHOD(CQueryBuilderTab, Hide);

    ShowWindow(m_hwnd, SW_HIDE);
    EnableWindow(m_hwnd, FALSE);
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryBuilderTab::Refresh
//
//  Synopsis:   Refresh the enabled/disabled state of the child controls and
//              the Find Now button.
//
//  History:    05-30-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CQueryBuilderTab::Refresh() const
{
    TRACE_METHOD(CQueryBuilderTab, Refresh);

    _EnableChildControls(TRUE);

    //
    // Disable Find Now if the listview is empty
    //

    if (!ListView_GetItemCount(_hCtrl(IDC_CLAUSE_LIST)))
    {
        if (m_pfnFindValidCallback)
        {
            m_pfnFindValidCallback(FALSE, m_CallbackLparam);
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryBuilderTab::_EnableChildControls
//
//  Synopsis:   Enable or disable the child controls according to the
//              caller's request AND the current scope type AND the type
//              of filters selected for that scope.
//
//  Arguments:  [fEnable] - TRUE enable controls if applicable
//                          FALSE disable all controls
//
//  History:    05-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CQueryBuilderTab::_EnableChildControls(
    BOOL fEnable) const
{
    TRACE_METHOD(CQueryBuilderTab, _EnableChildControls);

    const CFilterManager &rfm = m_rop.GetFilterManager();
    ULONG flCur = rfm.GetCurScopeSelectedFilterFlags();

    // no queries on downlevel scopes

    if (flCur & DOWNLEVEL_FILTER_BIT)
    {
        fEnable = FALSE;
    }

    // no queries if only selected type is customizer

    if (!(flCur & ~(DSOP_FILTER_EXTERNAL_CUSTOMIZER |
                    ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS |
                    DSOP_FILTER_INCLUDE_ADVANCED_VIEW)))
    {
        fEnable = FALSE;
    }

    EnableWindow(_hCtrl(IDC_LBL1       ), fEnable);
    EnableWindow(_hCtrl(IDC_LBL2       ), fEnable);
    EnableWindow(_hCtrl(IDC_CLAUSE_LIST), fEnable);
    EnableWindow(_hCtrl(IDC_ADD_BTN    ), fEnable);

    //
    // Edit and remove are only enabled if there is a selection
    //

    if (ListView_GetSelectedCount(_hCtrl(IDC_CLAUSE_LIST)))
    {
        EnableWindow(_hCtrl(IDC_EDIT_BTN   ), fEnable);
        EnableWindow(_hCtrl(IDC_REMOVE_BTN ), fEnable);
    }
    else
    {
        EnableWindow(_hCtrl(IDC_EDIT_BTN   ), FALSE);
        EnableWindow(_hCtrl(IDC_REMOVE_BTN ), FALSE);
    }
}




void
CQueryBuilderTab::Save(IPersistStream *pstm) const
{
}




void
CQueryBuilderTab::Load(IPersistStream *pstm)
{
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryBuilderTab::GetLdapFilter
//
//  Synopsis:   Return the LDAP filter specified by the settings of the
//              child controls
//
//  Returns:    LDAP filter
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      Filter returned contains the filter specified by current
//              Look For and Look In settings, concatenated with a more
//              specific filter based on child controls.
//
//---------------------------------------------------------------------------

String
CQueryBuilderTab::GetLdapFilter() const
{
    //
    // Get the LDAP filter associated with the current scope.  If it's
    // empty, return.
    //

    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rCurScope = rsm.GetCurScope();
    const CFilterManager &rfm = m_rop.GetFilterManager();
    String strScopeFilter = rfm.GetLdapFilter(m_hwnd, rCurScope);

    if (strScopeFilter.empty())
    {
        return strScopeFilter;
    }

    //
    // AND the scope filter with all the clauses in the query clause listview.
    //

    HWND hwndLV = _hCtrl(IDC_CLAUSE_LIST);
    int cItems = ListView_GetItemCount(hwndLV);
    String strQuery;

    LVITEM lvi;
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_PARAM;

    for (lvi.iItem = 0; lvi.iItem < cItems; lvi.iItem++)
    {
        if (ListView_GetItem(hwndLV, &lvi))
        {
            SQueryClause *pqc = reinterpret_cast<SQueryClause *>(lvi.lParam);
            strQuery += pqc->strLdapFilter;
        }
    }

    ASSERT(strQuery.length());

    return L"(&" + strScopeFilter + strQuery + L")";
}



//+--------------------------------------------------------------------------
//
//  Member:     CQueryBuilderTab::GetDefaultColumns
//
//  Synopsis:   Fill vector pointed to [pvakColumns] with the set of columns
//              that should be displayed in the Advanced dialog's query
//              results listview.
//
//  Arguments:  [pvakColumns] -
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      The attribute keys returned are those representing the
//              attributes the user chose to query on.
//
//---------------------------------------------------------------------------

void
CQueryBuilderTab::GetDefaultColumns(
    AttrKeyVector *pvakColumns) const
{
    TRACE_METHOD(CQueryBuilderTab, GetDefaultColumns);

    HWND hwndLV = _hCtrl(IDC_CLAUSE_LIST);
    int cItems = ListView_GetItemCount(hwndLV);
    String strQuery;

    LVITEM lvi;
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_PARAM;

    for (lvi.iItem = 0; lvi.iItem < cItems; lvi.iItem++)
    {
        if (ListView_GetItem(hwndLV, &lvi))
        {
            SQueryClause *pqc = reinterpret_cast<SQueryClause *>(lvi.lParam);

            if (pqc->akReferenced != AK_INVALID)
            {
                AddIfNotPresent(pvakColumns, pqc->akReferenced);
            }
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryBuilderTab::SetFindValidCallback
//
//  Synopsis:   Store the enable-the-find-now-button callback function
//              pointer and its LPARAM argument.
//
//  Arguments:  [pfnFindValidCallback] - pointer to function which enables
//                                        or disables the Find Now btn.
//              [lParam]               - argument to function
//
//  History:    05-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CQueryBuilderTab::SetFindValidCallback(
    PFN_FIND_VALID pfnFindValidCallback,
    LPARAM lParam)
{
    m_pfnFindValidCallback = pfnFindValidCallback;
    m_CallbackLparam = lParam;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryBuilderTab::_OnInit
//
//  Synopsis:   Handle WM_INITDIALOG
//
//  Arguments:  [pfSetFocus] - points to BOOL which is set to TRUE
//
//  Returns:    S_OK
//
//  History:    05-30-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CQueryBuilderTab::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CQueryBuilderTab, _OnInit);
    ASSERT(pfSetFocus);

    HWND hwndLV = _hCtrl(IDC_CLAUSE_LIST);
    ListView_SetExtendedListViewStyleEx(hwndLV,
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT,
                                        LVS_EX_LABELTIP | LVS_EX_FULLROWSELECT);

    //
    // Add a single column
    //

    RECT rcLV;
    VERIFY(GetClientRect(hwndLV, &rcLV));
    rcLV.right -= GetSystemMetrics(SM_CXVSCROLL);

    LVCOLUMN col;
    ZeroMemory(&col, sizeof col);

    col.mask = LVCF_WIDTH;
    col.cx = rcLV.right;

    int iCol = ListView_InsertColumn(hwndLV, 0, &col);
    if (iCol == -1)
    {
        DBG_OUT_LASTERROR;
    }

    //
    // Disable Edit and Remove buttons
    //

    EnableWindow(_hCtrl(IDC_EDIT_BTN), FALSE);
    EnableWindow(_hCtrl(IDC_REMOVE_BTN), FALSE);

    //
    // Disable Find Now
    //

    if (m_pfnFindValidCallback)
    {
        m_pfnFindValidCallback(FALSE, m_CallbackLparam);
    }

    //
    // Put focus on Add button
    //

    SetFocus(_hCtrl(IDC_ADD_BTN));
    *pfSetFocus = TRUE;
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryBuilderTab::_OnCommand
//
//  Synopsis:   Handle WM_COMMAND messages
//
//  Arguments:  [wParam] - standard Windows
//              [lParam] - standard Windows
//
//  Returns:    TRUE - command handled,
//              FALSE - not handled
//
//  History:    05-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CQueryBuilderTab::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fHandled = TRUE;

    switch (LOWORD(wParam))
    {
    case IDC_ADD_BTN:
        _OnAdd();
        break;

    case IDC_EDIT_BTN:
        _OnEdit();
        break;

    case IDC_REMOVE_BTN:
        _OnRemove();
        break;

    default:
        fHandled = FALSE;
        Dbg(DEB_WARN,
            "CQueryBuilderTab WM_COMMAND code=%#x, id=%#x, hwnd=%#x\n",
            HIWORD(wParam),
            LOWORD(wParam),
            lParam);
        break;
    }

    return fHandled;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryBuilderTab::_OnNotify
//
//  Synopsis:   Handle WM_NOTIFY messages
//
//  Arguments:  Standard Windows.
//
//  Returns:    Standard Windows.
//
//  History:    05-30-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CQueryBuilderTab::_OnNotify(
    WPARAM wParam,
    LPARAM lParam)
{
    LPNMHDR pnmh = reinterpret_cast<LPNMHDR> (lParam);
    BOOL    fReturn = FALSE;

    switch (pnmh->code)
    {
    case LVN_ITEMCHANGED:
        if (pnmh->idFrom == IDC_CLAUSE_LIST)
        {
            _OnClauseListSelChange(
                reinterpret_cast<LPNMLISTVIEW>(lParam));
        }
        break;
    }

    return fReturn;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryBuilderTab::_OnClauseListSelChange
//
//  Synopsis:   Handle notification from the clause listview that one of the
//              items in it has been changed.
//
//  Arguments:  [pnmlv] - points to notification details from listview
//
//  History:    05-30-2000   DavidMun   Created
//
//  Notes:      This is used to enable/disable pushbuttons whose state is
//              linked to the selection state in the listview.
//
//---------------------------------------------------------------------------

void
CQueryBuilderTab::_OnClauseListSelChange(
    LPNMLISTVIEW pnmlv)
{
    if (pnmlv->uNewState & LVIS_SELECTED)
    {
        Dbg(DEB_TRACE,
            "UA: (QueryBuilderTab) clause %d selected\n",
            pnmlv->iItem);
        EnableWindow(_hCtrl(IDC_EDIT_BTN), TRUE);
        EnableWindow(_hCtrl(IDC_REMOVE_BTN), TRUE);
    }
    else
    {
        Dbg(DEB_TRACE, "UA: (QueryBuilderTab) no clause selected\n");
        EnableWindow(_hCtrl(IDC_EDIT_BTN), FALSE);
        if (GetFocus() == _hCtrl(IDC_REMOVE_BTN))
        {
            SetFocus(_hCtrl(IDC_ADD_BTN));
        }
        EnableWindow(_hCtrl(IDC_REMOVE_BTN), FALSE);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryBuilderTab::_OnAdd
//
//  Synopsis:   Pop up a modal add-query-clause dialog and put the result
//              (if any) into the query clause listview.
//
//  History:    05-30-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CQueryBuilderTab::_OnAdd()
{
    TRACE_METHOD(CQueryBuilderTab, _OnAdd);

    CAddClauseDlg ac(m_rop);
    HRESULT hr;
    SQueryClause *pqc = NULL;

    do
    {
        hr = ac.DoModal(m_hwnd);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // No-op if user cancelled dialog
        //

        if (hr == S_FALSE)
        {
            break;
        }

        pqc = new SQueryClause;

        pqc->strLdapFilter = ac.GetLdapFilter();
        pqc->akReferenced = ac.GetAttrKey();
        ac.Save(&pqc->pvSavedAddClauseState);

        String strDescription = ac.GetDescription();

        LVITEM lvi;
        ZeroMemory(&lvi, sizeof lvi);
        lvi.mask = LVIF_TEXT | LVIF_PARAM;
        lvi.iItem = INT_MAX; // insert at end
        lvi.pszText = const_cast<PWSTR>(strDescription.c_str());
        lvi.lParam = reinterpret_cast<LPARAM>(pqc);

        LONG lResult = ListView_InsertItem(_hCtrl(IDC_CLAUSE_LIST), &lvi);
        if (lResult == -1)
        {
            Dbg(DEB_ERROR,
                "Error %u inserting item '%ws'\n",
                GetLastError(),
                lvi.pszText);
        }
        else
        {
            Dbg(DEB_TRACE,
                "UA: (QueryBuilderTab) Added item %d: %ws\n",
                lResult,
                lvi.pszText);
            Dbg(DEB_TRACE, "clause is %ws\n", pqc->strLdapFilter.c_str());
            pqc = NULL; // transfer ownership to listview

            // ensure Find Now button is enabled

            if (m_pfnFindValidCallback)
            {
                m_pfnFindValidCallback(TRUE, m_CallbackLparam);
            }

            // remember that we have at least one clause in the listview

            m_fNonEmpty = TRUE;
        }
    } while (0);

    if (pqc)
    {
        ac.Free(pqc->pvSavedAddClauseState);
        delete pqc;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryBuilderTab::_OnEdit
//
//  Synopsis:   Invoke the Add dialog initialized with the current selection,
//              then change the selection to match what the user entered in
//              the Add dialog.
//
//  History:    05-30-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CQueryBuilderTab::_OnEdit()
{
    TRACE_METHOD(CQueryBuilderTab, _OnEdit);

    CAddClauseDlg ac(m_rop);

    do
    {
        HWND hwndLV = _hCtrl(IDC_CLAUSE_LIST);
        int iItem = ListView_GetNextItem(hwndLV, -1, LVNI_SELECTED);

        ASSERT(iItem != -1);
        if (iItem == -1)
        {
            break;
        }

        LVITEM lvi;
        ZeroMemory(&lvi, sizeof lvi);
        lvi.mask = LVIF_PARAM | LVIF_TEXT;
        lvi.iItem = iItem;

        if (!ListView_GetItem(hwndLV, &lvi))
        {
            DBG_OUT_LASTERROR;
            break;
        }

        Dbg(DEB_TRACE,
            "UA: (QueryBuilderTab) Editing item %d: %ws\n",
            lvi.iItem,
            lvi.pszText);

        SQueryClause *pqc = reinterpret_cast<SQueryClause *>(lvi.lParam);

        ac.Load(pqc->pvSavedAddClauseState);

        HRESULT hr = ac.DoModal(m_hwnd);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // No-op if user cancelled dialog
        //

        if (hr == S_FALSE)
        {
            break;
        }

        //
        // Now update the struct stored with the item
        //

        pqc->strLdapFilter = ac.GetLdapFilter();
        ac.Free(pqc->pvSavedAddClauseState);
        pqc->pvSavedAddClauseState = NULL;
        ac.Save(&pqc->pvSavedAddClauseState);

        //
        // Change the item text
        //

        lvi.mask = LVIF_TEXT;
        lvi.pszText = const_cast<PWSTR>(ac.GetDescription().c_str());
        LONG lResult = ListView_SetItem(hwndLV, &lvi);

        if (lResult == -1)
        {
            Dbg(DEB_ERROR,
                "Error %u updating item %d: %ws\n",
                GetLastError(),
                lvi.iItem,
                lvi.pszText);
        }

    } while (0);

}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryBuilderTab::_OnRemove
//
//  Synopsis:   Delete the currently selected clause in the listview
//
//  History:    05-30-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CQueryBuilderTab::_OnRemove()
{
    TRACE_METHOD(CQueryBuilderTab, _OnRemove);

    HWND hwndLV = _hCtrl(IDC_CLAUSE_LIST);
    int iItem = ListView_GetNextItem(hwndLV, -1, LVNI_SELECTED);

    ASSERT(iItem != -1);
    if (iItem == -1)
    {
        return;
    }

    LVITEM lvi;
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_PARAM | LVIF_TEXT;
    lvi.iItem = iItem;

    if (ListView_GetItem(hwndLV, &lvi))
    {
        Dbg(DEB_TRACE,
            "UA: (QueryBuilderTab) Removing item %d: %ws\n",
            lvi.iItem,
            lvi.pszText);
        CAddClauseDlg ac(m_rop);

        SQueryClause *pqc = reinterpret_cast<SQueryClause *>(lvi.lParam);
        ac.Free(pqc->pvSavedAddClauseState);
        delete pqc;
    }
    else
    {
        DBG_OUT_LASTERROR;
    }

    //
    // Remove the item from the listview
    //

    ListView_DeleteItem(hwndLV, iItem);

    //
    // Disable Find Now if the listview is empty
    //

    if (!ListView_GetItemCount(hwndLV))
    {
        if (m_pfnFindValidCallback)
        {
            m_pfnFindValidCallback(FALSE, m_CallbackLparam);
        }

        //
        // Also remember that the listview is now empty
        //

        m_fNonEmpty = FALSE;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryBuilderTab::_OnDestroy
//
//  Synopsis:   Free memory held in listview items
//
//  History:    05-30-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CQueryBuilderTab::_OnDestroy()
{
    TRACE_METHOD(CQueryBuilderTab, _OnDestroy);

    DeleteAllClauses();

    //
    // Remember that the listview is empty
    //

    m_fNonEmpty = FALSE;
    m_hwnd = NULL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryBuilderTab::DeleteAllClauses
//
//  Synopsis:   Delete the contents of the query clause listview.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CQueryBuilderTab::DeleteAllClauses() const
{
    TRACE_METHOD(CQueryBuilderTab, DeleteAllClauses);
    ASSERT(IsWindow(m_hwnd));

    LVITEM lvi;
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_PARAM;

    CAddClauseDlg ac(m_rop);
    HWND hwndLV = _hCtrl(IDC_CLAUSE_LIST);
    int cItems = ListView_GetItemCount(hwndLV);

    for (lvi.iItem = 0; lvi.iItem < cItems; lvi.iItem++)
    {
        lvi.lParam = 0;
        VERIFY(ListView_GetItem(hwndLV, &lvi));

        if (!lvi.lParam)
        {
            continue;
        }

        SQueryClause *pqc = reinterpret_cast<SQueryClause *>(lvi.lParam);

        ac.Free(pqc->pvSavedAddClauseState);
        delete pqc;
    }

    ListView_DeleteAllItems(hwndLV);
}



void
CQueryBuilderTab::_OnHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TRACE_METHOD(CQueryBuilderTab, _OnHelp);

    InvokeWinHelp(message, wParam, lParam, c_wzHelpFilename, s_aulHelpIds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\richeditcallback.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       RichEditCallback.cxx
//
//  Contents:   Implementation of rich edit callback interface
//
//  Classes:    CRichEditOleCallback
//
//  History:    03-23-2000   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


//+--------------------------------------------------------------------------
//
//  Member:     CRichEditOleCallback::CRichEditOleCallback
//
//  Synopsis:   ctor
//
//  History:    5-21-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CRichEditOleCallback::CRichEditOleCallback(
    HWND hwndRichEdit):
        m_cRefs(1),
        m_hwndRichEdit(hwndRichEdit)
{
    TRACE_CONSTRUCTOR(CRichEditOleCallback);
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditOleCallback::~CRichEditOleCallback
//
//  Synopsis:   dtor
//
//  History:    5-21-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CRichEditOleCallback::~CRichEditOleCallback()
{
    TRACE_DESTRUCTOR(CRichEditOleCallback);
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditOleCallback::QueryInterface
//
//  Synopsis:   Standard OLE
//
//  History:    12-05-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CRichEditOleCallback::QueryInterface(
    REFIID  riid,
    LPVOID *ppvObj)
{
    //TRACE_METHOD(CRichEditOleCallback, QueryInterface);
    HRESULT hr = S_OK;

    do
    {
        if (NULL == ppvObj)
        {
            hr = E_INVALIDARG;
            DBG_OUT_HRESULT(hr);
            break;
        }

        if (IsEqualIID(riid, IID_IUnknown))
        {
            *ppvObj = (IUnknown *)this;
        }
        else if (IsEqualIID(riid, IID_IRichEditOleCallback))
        {
            *ppvObj = (IRichEditOleCallback *)this;
        }
        else
        {
            hr = E_NOINTERFACE;
            DBG_OUT_NO_INTERFACE("CRichEditOleCallback", riid);
            *ppvObj = NULL;
            break;
        }

        //
        // If we got this far we are handing out a new interface pointer on
        // this object, so addref it.
        //

        AddRef();
    } while (0);

    return hr;
}


LPSTORAGE StgCreateOnHglobal(VOID)
{
    LPLOCKBYTES plb = NULL;
    LPSTORAGE pstg = NULL;

    // Create lockbytes on hglobal
    if (CreateILockBytesOnHGlobal(NULL, TRUE, &plb))
        return NULL;

    // Create storage on lockbytes
    StgCreateDocfileOnILockBytes(plb, STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE |
            STGM_CREATE | STGM_READWRITE, 0, &pstg);

    // Release our reference on the lockbytes and return the storage
    plb->Release();
    return pstg;
}

STDMETHODIMP
CRichEditOleCallback::GetNewStorage(
    LPSTORAGE *ppstg)
{
    TRACE_METHOD(CRichEditOleCallback, GetNewStorage);

    *ppstg = StgCreateOnHglobal();

    if (!*ppstg)
    {
        return E_OUTOFMEMORY;
    }
    return S_OK;
}


STDMETHODIMP
CRichEditOleCallback::GetInPlaceContext(
    LPOLEINPLACEFRAME *ppFrame,
    LPOLEINPLACEUIWINDOW *ppDoc,
    LPOLEINPLACEFRAMEINFO pFrameInfo)
{
    TRACE_METHOD(CRichEditOleCallback, GetInPlaceContext);

    return E_NOTIMPL;
}


STDMETHODIMP
CRichEditOleCallback::ShowContainerUI(
    BOOL fShow)
{
    TRACE_METHOD(CRichEditOleCallback, ShowContainerUI);

    return E_NOTIMPL;
}


STDMETHODIMP
CRichEditOleCallback::QueryInsertObject(
    LPCLSID pclsid,
    LPSTORAGE pstg,
    LONG cp)
{
    //TRACE_METHOD(CRichEditOleCallback, QueryInsertObject);

    if (IsEqualCLSID(*pclsid, CLSID_DsOpObject))
    {
        //Dbg(DEB_TRACE, "allowing insert of CLSID_DsOpObject object\n");
        return S_OK;
    }

    return E_FAIL;
}


STDMETHODIMP
CRichEditOleCallback::DeleteObject(
    LPOLEOBJECT poleobj)
{
    TRACE_METHOD(CRichEditOleCallback, DeleteObject);

    return S_OK;
}


STDMETHODIMP
CRichEditOleCallback::QueryAcceptData(
    LPDATAOBJECT pdataobj,
    CLIPFORMAT *pcfFormat,
    DWORD reco,
    BOOL fReally,
    HGLOBAL hMetaPict)
{
    TRACE_METHOD(CRichEditOleCallback, QueryAcceptData);

    *pcfFormat = CF_TEXT;
    return S_OK;
}

STDMETHODIMP
CRichEditOleCallback::ContextSensitiveHelp(
    BOOL fEnterMode)
{
    TRACE_METHOD(CRichEditOleCallback, ContextSensitiveHelp);

    return E_NOTIMPL;
}


//+--------------------------------------------------------------------------
//
//  Member:     CRichEditOleCallback::GetClipboardData
//
//  Synopsis:   Return a data object which can give out the contents of the
//              rich edit as a text string (which requires asking the
//              embedded objects to return their textual representation).
//
//  Arguments:  [pchrg]     - range of text to copy
//              [reco]      - RECO_*, ignored
//              [ppdataobj] - filled with new data object
//
//  Returns:    HRESULT
//
//  History:    5-21-1999   davidmun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CRichEditOleCallback::GetClipboardData(
    CHARRANGE *pchrg,
    DWORD reco,
    LPDATAOBJECT *ppdataobj)
{
    TRACE_METHOD(CRichEditOleCallback, GetClipboardData);

    //
    // Create a data object which contains a textual representation of the
    // contents of the rich edit control specified by [pchrg].
    //

    *ppdataobj = new CDataObject(m_hwndRichEdit, pchrg);
    return S_OK;
}


STDMETHODIMP
CRichEditOleCallback::GetDragDropEffect(
    BOOL fDrag,
    DWORD grfKeyState,
    LPDWORD pdwEffect)
{
    TRACE_METHOD(CRichEditOleCallback, GetDragDropEffect);
    ASSERT(!IsBadWritePtr(pdwEffect, sizeof(pdwEffect)));

    *pdwEffect = DROPEFFECT_NONE;
    return S_OK;
}


STDMETHODIMP
CRichEditOleCallback::GetContextMenu(
    WORD seltype,
    LPOLEOBJECT poleobj,
    CHARRANGE *pchrg,
    HMENU *phmenu)
{
    TRACE_METHOD(CRichEditOleCallback, GetContextMenu);
    ASSERT(phmenu);

    HMENU hmenuBar = NULL;

    do
    {
        hmenuBar = LoadMenu(g_hinst, MAKEINTRESOURCE(IDM_RICHEDIT));

        if (!hmenuBar)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        *phmenu = CreatePopupMenu();

        if (!*phmenu)
        {
            DBG_OUT_LASTERROR;
            break;
        }

        //
        // Copy the menu items loaded from the resources to the new popup
        //

        HMENU hmenuContext = GetSubMenu(hmenuBar, 0);

        ASSERT(IsMenu(hmenuContext));

        ULONG cItems = GetMenuItemCount(hmenuContext);
        ULONG i;

        ASSERT(cItems);

        const ULONG flMenu = MF_STRING | MF_ENABLED;
        for (i = 0; i < cItems; i++)
        {
            MENUITEMINFO mii;
            WCHAR wzMenuItem[MAX_PATH];

            ZeroMemory(&mii, sizeof mii);

            mii.cbSize = sizeof(mii);
            mii.fMask = MIIM_ID | MIIM_STRING;
            mii.fType = MIIM_STRING;
            mii.dwTypeData = wzMenuItem;
            mii.cch = ARRAYLEN(wzMenuItem);

            VERIFY(GetMenuItemInfo(hmenuContext, i, TRUE, &mii));
            VERIFY(AppendMenu(*phmenu, flMenu, mii.wID, (PWSTR)mii.dwTypeData));
        }

        // Disable paste if can't paste
        if (!SendMessage(GetFocus(), EM_CANPASTE, 0, 0))
        {
            EnableMenuItem(*phmenu, IDM_PASTE, MF_DISABLED | MF_GRAYED);
        }

        //
        // Disable cut and copy if no current selection.
        //

        if (pchrg->cpMin == pchrg->cpMax)
        {
            EnableMenuItem(*phmenu, IDM_CUT, MF_DISABLED | MF_GRAYED);
            EnableMenuItem(*phmenu, IDM_COPY, MF_DISABLED | MF_GRAYED);
        }
    } while (0);

    if (hmenuBar)
    {
        VERIFY(DestroyMenu(hmenuBar));
    }
    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     CRichEditOleCallback::AddRef
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CRichEditOleCallback::AddRef()
{
    return InterlockedIncrement((LONG *) &m_cRefs);
}




//+---------------------------------------------------------------------------
//
//  Member:     CRichEditOleCallback::Release
//
//  Synopsis:   Standard OLE
//
//  History:    12-04-96   DavidMun   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG)
CRichEditOleCallback::Release()
{
    ULONG cRefsTemp;

    cRefsTemp = InterlockedDecrement((LONG *)&m_cRefs);

    if (0 == cRefsTemp)
    {
        delete this;
    }

    return cRefsTemp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\richedithelper.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       RichEditHelper.cxx
//
//  Contents:   Implementation of class which helps turn text in a
//              rich edit control into CEmbeddedDsObjects.
//
//  Classes:    CRichEditHelper
//
//  History:    03-06-2000   davidmun   Created from dsselect.cxx code
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#define DEFINE_GUIDXXX(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
        EXTERN_C const GUID CDECL name \
                = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }

DEFINE_GUIDXXX(IID_ITextDocument,0x8CC497C0,0xA1DF,0x11CE,0x80,0x98,
                0x00,0xAA,0x00,0x47,0xBE,0x5D);


//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::CRichEditHelper
//
//  Synopsis:   ctor
//
//  Arguments:  [pContainer]   - container which owns rich edit
//              [hwndRichEdit] - window handle
//              [pCurScope]    - current selection in look in control
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

CRichEditHelper::CRichEditHelper(
    const CObjectPicker &rop,
    HWND hwndRichEdit,
    const CEdsoGdiProvider *pEdsoGdiProvider,
    IRichEditOle *pRichEditOle,
    BOOL fForceSingleSelect):
        m_rop(rop),
        m_hwndRichEdit(hwndRichEdit),
        m_pRichEditOle(pRichEditOle),
        m_pGdiProvider(pEdsoGdiProvider),
        m_itWindowLeft(0),
        m_itWindowRight(0)
{
    TRACE_CONSTRUCTOR(CRichEditHelper);
    ASSERT(m_hwndRichEdit);
    ASSERT(m_pRichEditOle);

	m_fMultiselect = !fForceSingleSelect &&
		m_rop.GetInitInfoOptions() & DSOP_FLAG_MULTISELECT;


    m_pRichEditOle->AddRef();
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::~CRichEditHelper
//
//  Synopsis:   dtor
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

CRichEditHelper::~CRichEditHelper()
{
    TRACE_DESTRUCTOR(CRichEditHelper);

    m_hwndRichEdit = NULL;
    m_pRichEditOle->Release();
    m_pRichEditOle = NULL;
    m_pGdiProvider = NULL;
}





//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::Consume
//
//  Synopsis:   Delete all characters in rich edit starting at position
//              [itLeft] that appear in the string [pwzToDelete]
//
//  Arguments:  [itLeft]      - starting point for deletion
//              [pwzToDelete] - characters to delete
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

void
CRichEditHelper::Consume(
    CRichEditHelper::iterator itLeft,
    PCWSTR pwzToDelete)
{
    ASSERT(pwzToDelete);

    while (itLeft != end() && wcschr(pwzToDelete, ReadChar(itLeft)))
    {
        Erase(itLeft, itLeft + 1);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::TrimTrailing
//
//  Synopsis:   Delete from the end of the contents of the rich edit control
//              all instances of [pwzCharsToTrim]
//
//  Arguments:  [pwzCharsToTrim] - chars to delete
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

void
CRichEditHelper::TrimTrailing(
    PCWSTR pwzCharsToTrim)
{
    ASSERT(pwzCharsToTrim);

    iterator itCur;
    iterator itLastDeleteable = begin();

    for (itCur = begin(); itCur != end(); itCur++)
    {
        if (!wcschr(pwzCharsToTrim, ReadChar(itCur)))
        {
            itLastDeleteable = itCur + 1;
        }
    }

    Erase(itLastDeleteable, end());
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::Erase
//
//  Synopsis:   Delete from rich edit control all characters in the range
//              [itFirst] to [itLast]
//
//  Arguments:  [itFirst] - pos of first character to delete
//              [itLast]  - pos just past last char to delete
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

void
CRichEditHelper::Erase(
    iterator itFirst,
    iterator itLast)
{
    ASSERT(itFirst <= itLast);

    if (itFirst == itLast)
    {
        return; // handle NOP
    }

    ASSERT(itFirst <= end());
    ASSERT(itLast <= end());

    // since this deletion is the result of processing the text in the
    // control and not a user edit, disallow undoing it
    Edit_SetSel(m_hwndRichEdit, itFirst, itLast);
    SendMessage(m_hwndRichEdit, EM_REPLACESEL, CANNOT_UNDO, (LPARAM)L"");

    //
    // If the window is empty, or all of the characters deleted are to its
    // right, no adjustments need be made.
    //

    if (m_strWindow.empty() || itFirst >= m_itWindowRight)
    {
        return;
    }

    //
    // if all of the characters deleted were to the left of the start of the
    // window, its contents are unaffected but its iterators must be 'moved'
    // left.
    //

    if (itLast <= m_itWindowLeft)
    {
        ULONG cchDeleted = itLast - itFirst;

        m_itWindowLeft -= cchDeleted;
        m_itWindowRight -= cchDeleted;
        return;
    }

    //
    // The range deleted overlaps or covers the window.
    //

    ASSERT(itFirst < m_itWindowRight && itLast > m_itWindowLeft);

    iterator itWindowDeleteLeft;
    iterator itWindowDeleteRight;
    ULONG cchDeletedBeforeWindow;

    if (itFirst < m_itWindowLeft)
    {
        itWindowDeleteLeft = m_itWindowLeft;
        cchDeletedBeforeWindow = m_itWindowLeft - itFirst;
    }
    else
    {
        itWindowDeleteLeft = itFirst;
        cchDeletedBeforeWindow = 0;
    }

    if (itLast > m_itWindowRight)
    {
        itWindowDeleteRight = m_itWindowRight;
    }
    else
    {
        itWindowDeleteRight = itLast;
    }

    ULONG cchDeletedInWindow = itWindowDeleteRight - itWindowDeleteLeft;

    m_strWindow.erase(itWindowDeleteLeft - m_itWindowLeft, cchDeletedInWindow);

    m_itWindowLeft -= cchDeletedBeforeWindow;
    m_itWindowRight -= (cchDeletedBeforeWindow + cchDeletedInWindow);

    ASSERT(m_itWindowRight >= m_itWindowLeft);
    ASSERT(m_strWindow.length() == m_itWindowRight - m_itWindowLeft);
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::Insert
//
//  Synopsis:   Insert string [pwzToInsert] at position [itInsertPos]
//
//  Arguments:  [itInsertPos] - position at which to insert string
//              [pwzToInsert] - string to insert
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

void
CRichEditHelper::Insert(
    iterator itInsertPos,
    PCWSTR pwzToInsert)
{
    ASSERT(!IsBadReadPtr(pwzToInsert, sizeof(WCHAR)));
    ASSERT(itInsertPos <= end());

    if (!pwzToInsert || !*pwzToInsert)
    {
        return; // handle NOP
    }

    //
    // Insert the text at the indicated position in the rich edit
    //

    Edit_SetSel(m_hwndRichEdit, itInsertPos, itInsertPos);
    Edit_ReplaceSel(m_hwndRichEdit, pwzToInsert);

    //
    // Update the window
    //

    _InsertionUpdateWindow(itInsertPos, pwzToInsert);
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::_InsertionUpdateWindow
//
//  Synopsis:   Add [pwzToInsert] to the window if the window covers the
//              insertion position [itInsertPos]
//
//  Arguments:  [itInsertPos] - position in rich edit where string was
//                              inserted
//              [pwzToInsert] - string that was inserted in rich edit
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

void
CRichEditHelper::_InsertionUpdateWindow(
    iterator itInsertPos,
    PCWSTR pwzToInsert)
{
    ASSERT(!IsBadReadPtr(pwzToInsert, sizeof(WCHAR)));
    ASSERT(itInsertPos <= end());

    //
    // If window is empty, or insertion was to right of window, we're done
    //

    if (m_strWindow.empty() || itInsertPos >= m_itWindowRight)
    {
        return;
    }

    //
    // If insertion was to left of window, just move its position right
    //

    if (itInsertPos < m_itWindowLeft)
    {
        ULONG cchInserted = lstrlen(pwzToInsert);
        m_itWindowLeft += cchInserted;
        m_itWindowRight += cchInserted;
        return;
    }

    //
    // Insertion occurred within window, add to window and expand it
    //

    m_strWindow.insert(itInsertPos - m_itWindowLeft, pwzToInsert);
    m_itWindowRight += lstrlen(pwzToInsert);

    // Note: window may now be larger than RE_WINDOW_READ_SIZE
}





//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::MakeObject
//
//  Synopsis:   Transform the text starting at [itStart] into an object or
//              objects, or delete it entirely.
//
//  Arguments:  [itStart] - start of text to convert to object
//
//  Returns:    Result of attempting translation.  Note success does not
//              necessarily mean that an object was inserted.
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

NAME_PROCESS_RESULT
CRichEditHelper::MakeObject(
    iterator itStart)
{
    TRACE_METHOD(CRichEditHelper, MakeObject);
    ASSERT(itStart < end());

    NAME_PROCESS_RESULT npr = NPR_SUCCESS;
    iterator itEnd;
    String strTerm;

    for (itEnd = itStart; itEnd != end(); itEnd++)
    {
        WCHAR wch = ReadChar(itEnd);

		//Semicolon is not valid character in a name.
        if(!m_fMultiselect && (wch == L';' || wch == L'\r'))
        {
            PopupMessage(m_hwndRichEdit,
                             IDS_SEMICOLON_IN_NAME);
            
            return NPR_STOP_PROCESSING;
        }
        if (m_fMultiselect &&
            (wch == L';' ||
             wch == L'\r' ||
             wch == OBJECT_REPLACEMENT_CHARACTER))
        {
            break;
        }
        strTerm += wch;
    }

    //
    // now itStart..itEnd is text to cut and replace with zero or more
    // objects.
    //

    strTerm.strip(String::BOTH);

    if (strTerm.empty())
    {
        Erase(itStart, itEnd);
        return npr;
    }

    //
    // strTerm is a nonempty string.  Replace it in the edit control with
    // a new object or objects.
    //


    CDsObject dsoNew(m_rop.GetScopeManager().GetCurScope().GetID(),
                     strTerm.c_str());

    return _ProcessObject(itStart, itEnd, &dsoNew);
}



//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::ReplaceSelOrAppend
//
//  Synopsis:   If the rich edit control has a selection, replace it
//              with the object [dso], otherwise append [dso] to the
//              rich edit's contents.
//
//  Arguments:  [dso] - object to insert
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

void
CRichEditHelper::ReplaceSelOrAppend(
    const CDsObject &dso)
{
    //
    // See if the richedit has a selection.  If not, set the selection
    // to the end of the edit control.
    //

    ULONG cpStart = 0;
    ULONG cpEnd = 0;

    SendMessage(m_hwndRichEdit,
                EM_GETSEL,
                (WPARAM) &cpStart,
                (LPARAM) &cpEnd);

    iterator itInsertPos;

    if (cpStart == cpEnd)
    {
        // there is no selection

        ULONG cchRichEdit = GetWindowTextLength(m_hwndRichEdit);

        // append the object

        itInsertPos = cchRichEdit;

        if (cchRichEdit)
        {
            // there is something in the control already

            Insert(itInsertPos, L"; ");
            itInsertPos += 2;
        }
    }
    else
    {
        // there is a selection. delete it.
        SendMessage(m_hwndRichEdit, EM_REPLACESEL, (WPARAM)FALSE, (LPARAM)L"");

        // insert the object where the selection was
        itInsertPos = cpStart;
    }

    InsertObject(itInsertPos, dso);
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::InsertObject
//
//  Synopsis:   Add a copy of [dso] to the selection dialog well.
//
//  History:    08-07-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CRichEditHelper::InsertObject(
    iterator itPos,
    const CDsObject &dso)
{
    TRACE_METHOD(CRichEditHelper, InsertObject);
    ASSERT(itPos <= end());

    HRESULT         hr = S_OK;
    REOBJECT        reobj;
    CEmbeddedDsObject *pedso = new CEmbeddedDsObject(dso, m_pGdiProvider);

    do
    {
        //
        // Initialize the object information structure
        //

        ZeroMemory(&reobj, sizeof reobj);

        reobj.cbStruct  = sizeof(REOBJECT);
        reobj.cp        = REO_CP_SELECTION;
        reobj.clsid     = CLSID_DsOpObject;
        reobj.dwFlags   = REO_BELOWBASELINE
                          | REO_INVERTEDSELECT
                          | REO_DYNAMICSIZE
                          | REO_DONTNEEDPALETTE;
        reobj.dvaspect  = DVASPECT_CONTENT;
        reobj.poleobj   = (IOleObject *) pedso;

        hr = m_pRichEditOle->GetClientSite(&reobj.polesite);
        BREAK_ON_FAIL_HRESULT(hr);

        SendMessage(m_hwndRichEdit, EM_SETSEL, itPos, itPos);

        hr = m_pRichEditOle->InsertObject(&reobj);
        BREAK_ON_FAIL_HRESULT(hr);

        _InsertionUpdateWindow(itPos, OBJECT_REPLACEMENT_CHARACTER_STR);
    } while (0);

    //
    // If the embedded ds object was successfully added to the richedit, the
    // control is keeping a refcount on it.
    //
    // Otherwise there was an error, and this release will drive its refcount
    // to zero, preventing it from being leaked.
    //

    pedso->Release();
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::AlreadyInRichEdit
//
//  Synopsis:   Return TRUE if [dso] matches an object already in the rich
//              edit control, FALSE otherwise.
//
//  Arguments:  [dso] - object for which to look for duplicate
//
//  History:    4-16-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CRichEditHelper::AlreadyInRichEdit(
    const CDsObject &dso)
{
    LONG cObjects = m_pRichEditOle->GetObjectCount();
    ASSERT(cObjects >= 0);
    LONG i;
    HRESULT hr = S_OK;

    for (i = 0; i < cObjects; i++)
    {
        REOBJECT reobj;

        reobj.cbStruct = sizeof(reobj);

        hr = m_pRichEditOle->GetObject(i, &reobj, REO_GETOBJ_POLEOBJ);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            continue;
        }

        ASSERT(reobj.poleobj);
        CDsObject *pdso = (CDsObject *)(CEmbeddedDsObject*)reobj.poleobj;
        reobj.poleobj->Release();

        if (*pdso == dso)
        {
            return TRUE;
        }
    }

    return FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::ReadChar
//
//  Synopsis:   Return the character in the rich edit control at position
//              [it].
//
//  Arguments:  [it] - position of character to read.
//
//  Returns:    Character read
//
//  History:    01-19-2000   davidmun   Created
//
//  Notes:      throws out_of_range exception if [it] is beyond the end of
//              the rich edit control
//
//---------------------------------------------------------------------------

WCHAR
CRichEditHelper::ReadChar(
    iterator it)
{
    if (it >= end())
    {
        ASSERT(it < end());
        return L'\0';
    }

    //
    // if char to read is within the nonempty window, read it from
    // window
    //

    if (m_itWindowLeft < m_itWindowRight &&
        it >= m_itWindowLeft &&
        it < m_itWindowRight)
    {
        return m_strWindow[it - m_itWindowLeft];
    }

    //
    // Rich edit contains requested character, fill the window starting
    // at that char.
    //
	//
	// NTRAID#NTBUG9-372779-2001/05/02-hiteshr
	// Office shipped with Richedit version4, Windows is using version3.
	// If we use EM_GETTEXTRANGE version4 which returns 0x0020 
	// for Embeddedchar while version 3 returns 0xfffc for Embeddedchar.
	// Since both version of Richedit control are shipped, we need to
	// change way we read text from richedit control.
	// Text Object Model interface returns 0xfffc for embeddedchar in 
	// both version3 and version4.
	ITextDocument * pTextDocument = NULL;
	if(SUCCEEDED(m_pRichEditOle->QueryInterface(IID_ITextDocument , (LPVOID*)&pTextDocument)))
	{
		ASSERT(pTextDocument);
		ITextRange *pTextRange = NULL;
		HRESULT hr = S_OK;
		if(SUCCEEDED(pTextDocument->Range(it, it + RE_WINDOW_READ_SIZE,&pTextRange)))
		{
			ASSERT(pTextRange);
			Bstr bstrText;
			hr = pTextRange->GetText(&bstrText);
			
			if(!bstrText.Empty())
				m_strWindow = bstrText.c_str();
			else
				m_strWindow = "";

			m_itWindowLeft = it;
			m_itWindowRight = static_cast<CRichEditHelper::iterator>(it + m_strWindow.length());
			pTextRange->Release();
		}
		else
		{
			pTextDocument->Release();
			return L'\0';
		}
		
		pTextDocument->Release();
	}
	else
	{
		TEXTRANGE TextRange;
		WCHAR wzBuf[RE_WINDOW_READ_SIZE + 1];

		TextRange.chrg.cpMin = it;
		TextRange.chrg.cpMax = TextRange.chrg.cpMin + ARRAYLEN(wzBuf) - 1;
		TextRange.lpstrText = wzBuf;

		SetLastError(0);
		LRESULT cchCopied = SendMessage(m_hwndRichEdit,
										EM_GETTEXTRANGE,
										0,
										(LPARAM) &TextRange);

		//
		// A read failure is probably out of memory
		//

		if (!cchCopied)
		{
			DBG_OUT_LASTERROR;
			return L'\0';
		}
	
		//
		// Fill window with the characters read
		//

		m_strWindow = wzBuf;
		m_itWindowLeft = it;
		m_itWindowRight = static_cast<CRichEditHelper::iterator>(it + cchCopied);
	}
    //
    // Return requested character
    //

    return !m_strWindow.empty() ? m_strWindow[it - m_itWindowLeft] : L'\0';
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::ProcessObject
//
//  Synopsis:   Ask the nth object [idxObject] which lies at position
//              [itPos] to process itself, which may result in its deletion
//              or in the insertion of additional objects.
//
//  Arguments:  [itPos]     - character position of object
//              [idxObject] - zero-based object number
//
//  Returns:    Result of processing
//
//  History:    01-19-2000   davidmun   Created
//
//---------------------------------------------------------------------------

NAME_PROCESS_RESULT
CRichEditHelper::ProcessObject(
    iterator itPos,
    ULONG idxObject)
{
    ASSERT(itPos < end());
    ASSERT(idxObject < m_pRichEditOle->GetObjectCount());

    NAME_PROCESS_RESULT npr = NPR_SUCCESS;
    REOBJECT reobj;

    ZeroMemory(&reobj, sizeof reobj);
    reobj.cbStruct = sizeof(reobj);

    do
    {
        HRESULT hr = m_pRichEditOle->GetObject(idxObject,
                                               &reobj,
                                               REO_GETOBJ_POLEOBJ);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            npr = NPR_STOP_PROCESSING;
            break;
        }

        ASSERT(reobj.poleobj);

        CDsObject *pdso = (CDsObject *)(CEmbeddedDsObject*)reobj.poleobj;

        npr = _ProcessObject(itPos, itPos, pdso);
        reobj.poleobj->Release();
    } while (0);

    return npr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRichEditHelper::_ProcessObject
//
//  Synopsis:   Replace the range from [itStart] to [itEnd] with zero or
//              more objects that result from processing *[pdso].
//
//  Arguments:  [itStart] - start of range of text to replace
//              [itEnd]   - end of range of text to replace.  Equals
//                          [itStart] if the object is already in the
//                          control.
//              [pdso]    - object to process
//
//  Returns:    Result of processing object
//
//  History:    01-19-2000   davidmun   Created
//
//  Notes:      This private method does the work of the public methods
//              MakeObject and ProcessObject.
//
//---------------------------------------------------------------------------

NAME_PROCESS_RESULT
CRichEditHelper::_ProcessObject(
    iterator itStart,
    iterator itEnd,
    CDsObject *pdso)
{
    ASSERT(itStart < end());
    ASSERT(itEnd <= end());
    ASSERT(pdso);

    NAME_PROCESS_RESULT npr = NPR_SUCCESS;
    CDsObjectList dsolAdditions;

    if (m_fMultiselect)
    {
        npr = pdso->Process(GetParent(m_hwndRichEdit),
                            m_rop,
                            &dsolAdditions);
    }
    else
    {
        npr = pdso->Process(GetParent(m_hwndRichEdit),
                            m_rop,
                            NULL);
    }

    if (npr != NPR_STOP_PROCESSING)
    {
        Erase(itStart, itEnd);
    }

    if (NAME_PROCESSING_FAILED(npr))
    {
        return npr; 
    }

    BOOL     fDuplicate = AlreadyInRichEdit(*pdso);
    iterator itPos = itStart;
    BOOL     fInsertedAnObject = FALSE;

    if (!fDuplicate)
    {
        fInsertedAnObject = TRUE;
        InsertObject(itPos, *pdso);
        itPos++;
    }

    CDsObjectList::iterator itDsol;

    for (itDsol = dsolAdditions.begin();
         itDsol != dsolAdditions.end();
         itDsol++)
    {
        if (AlreadyInRichEdit(*itDsol))
        {
            continue;
        }

        if (fInsertedAnObject)
        {
            Insert(itPos, L"; ");
            itPos += 2;
        }

        InsertObject(itPos, *itDsol);
        fInsertedAnObject = TRUE;
        itPos++;
    }

    return npr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\rootdse.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       rootdse.cxx
//
//  Contents:   Implementation of class to retrieve interfaces from
//              objects accessed via the RootDSE container.
//
//  Classes:    CRootDSE
//
//  History:    02-25-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

DEBUG_DECLARE_INSTANCE_COUNTER(CRootDSE)

#define DSE_ATTEMPTED_INIT      0x0001
#define DSE_INIT_FAILED         0x0002


//+--------------------------------------------------------------------------
//
//  Member:     CRootDSE::CRootDSE
//
//  Synopsis:   ctor
//
//  History:    02-25-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CRootDSE::CRootDSE():
        m_pADsRootDSE(NULL),
		m_hrInitFailed(0)
{
    TRACE_CONSTRUCTOR(CRootDSE);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CRootDSE);

    m_wzTargetDomain[0] = L'\0';
    m_wzTargetForest[0] = L'\0';
}




//+--------------------------------------------------------------------------
//
//  Member:     CRootDSE::CRootDSE
//
//  Synopsis:   Copy ctor
//
//  History:    06-01-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CRootDSE::CRootDSE(
    const CRootDSE &rdse)
{
    this->operator=(rdse);
}

//+--------------------------------------------------------------------------
//
//  Member:     CRootDSE::operator=
//
//  Synopsis:   Assignment operator
//
//  Arguments:  [rdse] - right hand side
//
//  History:    06-01-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CRootDSE &
CRootDSE::operator=(
    const CRootDSE &rdse)
{
    TRACE_CONSTRUCTOR(CRootDSE);

    m_pADsRootDSE = rdse.m_pADsRootDSE;

    if (m_pADsRootDSE)
    {
        m_pADsRootDSE->AddRef();
    }

    m_bstrConfigNamingContext = rdse.m_bstrConfigNamingContext;
    lstrcpy(m_wzTargetDomain, rdse.m_wzTargetDomain);
    lstrcpy(m_wzTargetForest, rdse.m_wzTargetForest);

    return *this;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRootDSE::Init
//
//  Synopsis:   Complete initialization.
//
//  Arguments:
//
//  Returns:    HRESULT
//
//  History:    05-27-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CRootDSE::Init(
    PCWSTR pwzTargetDomain,
    PCWSTR pwzTargetForest)
{
    TRACE_METHOD(CRootDSE, Init);

    HRESULT hr = S_OK;

    do
    {
        if (pwzTargetDomain && *pwzTargetDomain)
        {
            lstrcpyn(m_wzTargetDomain,
                     pwzTargetDomain,
                     ARRAYLEN(m_wzTargetDomain));
        }
        else
        {
            hr = E_INVALIDARG;
            Dbg(DEB_ERROR,
                "CRootDSE::Init: target machine not joined to domain\n");
            break;
        }

        lstrcpyn(m_wzTargetForest,
                 pwzTargetForest,
                 ARRAYLEN(m_wzTargetForest));
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRootDSE::~CRootDSE
//
//  Synopsis:   dtor
//
//  History:    02-25-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CRootDSE::~CRootDSE()
{
    TRACE_DESTRUCTOR(CRootDSE);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CRootDSE);

    SAFE_RELEASE(m_pADsRootDSE);
}




//+--------------------------------------------------------------------------
//
//  Member:     CRootDSE::BindToWellKnownPrincipalsContainer
//
//  Synopsis:   Bind to the wkp container for interface [riid] and return
//              a pointer to that interface in *[ppvInterface].
//
//  Arguments:  [riid]         - interface for which to bind
//              [ppvInterface] - filled with interface instance
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppvInterface]
//
//  History:    07-21-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CRootDSE::BindToWellKnownPrincipalsContainer(
    HWND        hwnd,
    REFIID      riid,
    void      **ppvInterface) const
{
    TRACE_METHOD(CRootDSE, BindToWellKnownPrincipalsContainer);

    HRESULT hr = S_OK;
    String  strWellKnown;

    do
    {
        if (_IsFlagSet(DSE_INIT_FAILED))
        {
            hr = m_hrInitFailed;
            break;
        }

        //
        // Demand-initialize
        //

        if (!_IsFlagSet(DSE_ATTEMPTED_INIT))
        {
            hr = _Init(hwnd);
            BREAK_ON_FAIL_HRESULT(hr);
        }

        //
        // Create path to well-known security principals container
        //

        strWellKnown = String(c_wzLDAPPrefix) +
                       String(m_wzTargetDomain) +
                       String(L"/") +
                       String(c_wzWellKnown) +
                       String(m_bstrConfigNamingContext.c_str());

        //
        // Tell BindToObject that the config path may have a server portion
        // different than the DN.
        //
        // In other words, while the DN specifies a path to the root domain for
        // the WKSP container, the server portion will specify the joined
        // domain.
        //
        // This is possible because all domains replicate the contents of the
        // configuration container, which includes the WKSP container.  This is
        // a performance optimization because, in a large enterprise, the joined
        // domain DCs are more likely to be physically close to the target
        // machine than the root domain DCs.
        //

        hr = g_pBinder->BindToObject(hwnd,
                                     strWellKnown.c_str(),
                                     riid,
                                     ppvInterface,
                                     DSOP_BIND_FLAG_SERVER_NEQ_DN);
        BREAK_ON_FAIL_HRESULT(hr);
    } while (0);

    ASSERT(SUCCEEDED(hr) && *ppvInterface ||
           FAILED(hr) && !*ppvInterface);
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRootDSE::BindToDisplaySpecifiersContainer
//
//  Synopsis:   Bind to the container beneath DisplaySpecifiers which
//              represents the user's default LANGID.
//
//  Arguments:  [hwnd]         - for bind
//              [riid]         - desired interface
//              [ppvInterface] - filled with desired interface on success
//
//  Returns:    HRESULT
//
//  History:    05-15-2000   DavidMun   Created
//
//  Notes:      If unable to get user's default lang id, uses system's.  If
//              Unable to get system's, uses US English.
//
//---------------------------------------------------------------------------

HRESULT
CRootDSE::BindToDisplaySpecifiersContainer(
    HWND        hwnd,
    REFIID      riid,
    void      **ppvInterface) const
{
    TRACE_METHOD(CRootDSE, BindToWellKnownPrincipalsContainer);

    HRESULT hr = S_OK;

    do
    {
        if (_IsFlagSet(DSE_INIT_FAILED))
        {
            hr = m_hrInitFailed;
            break;
        }

        //
        // Demand-initialize
        //

        if (!_IsFlagSet(DSE_ATTEMPTED_INIT))
        {
            hr = _Init(hwnd);
            BREAK_ON_FAIL_HRESULT(hr);
        }

        //
        // Create path to well-known security principals
        //

        String strContainerPath;

        LANGID langid = GetUserDefaultUILanguage();

        if (!langid)
        {
            DBG_OUT_LASTERROR;
            langid = GetSystemDefaultUILanguage();
        }

        if (!langid)
        {
            DBG_OUT_LASTERROR;

            //
            // can't get user or system langid... try US English.
            // a fancier strategy would be to enumerate containers beneath
            // DisplaySpecifiers and pick one.
            //

            langid = 0x409;
        }

        strContainerPath = String(c_wzLDAPPrefix) +
                           String(m_wzTargetDomain )+
                           String(L"/") +
                           String::format(c_wzDisplaySpecifierContainerFmt,
                                          langid) +
                           String(m_bstrConfigNamingContext.c_str());

        hr = g_pBinder->BindToObject(hwnd,
                                     strContainerPath.c_str(),
                                     riid,
                                     ppvInterface,
                                     DSOP_BIND_FLAG_SERVER_NEQ_DN);
        if(hr == HRESULT_FROM_WIN32(ERROR_DS_NO_SUCH_OBJECT))
        {
            //
            //if langid is not 0x409, try with 0x409
            //
            if( langid != 0x409)
            {
                    langid = 0x409;
                    strContainerPath = String(c_wzLDAPPrefix) +
                           String(m_wzTargetDomain )+
                           String(L"/") +
                           String::format(c_wzDisplaySpecifierContainerFmt,
                                          langid) +
                           String(m_bstrConfigNamingContext.c_str());

                    hr = g_pBinder->BindToObject(hwnd,
                                                 strContainerPath.c_str(),
                                                 riid,
                                                 ppvInterface,
                                                 DSOP_BIND_FLAG_SERVER_NEQ_DN);
            }
        }
        
        BREAK_ON_FAIL_HRESULT(hr);

    } while (0);

    ASSERT(SUCCEEDED(hr) && *ppvInterface ||
           FAILED(hr) && !*ppvInterface);
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRootDSE::GetSchemaNc
//
//  Synopsis:   Return the schema naming context (the DN of the schema
//              container).
//
//  Returns:    Schema NC or empty string on error
//
//  History:    06-28-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

String
CRootDSE::GetSchemaNc(
    HWND hwnd) const
{
    TRACE_METHOD(CRootDSE, GetSchemaNc);

    String strSchemaNc;

    do
    {
        if (_IsFlagSet(DSE_INIT_FAILED))
        {
            Dbg(DEB_ERROR, "DSE_INIT_FAILED set, returning empty string\n");
            break;
        }

        //
        // Demand-initialize
        //

        if (!_IsFlagSet(DSE_ATTEMPTED_INIT))
        {
            HRESULT hr = _Init(hwnd);
            BREAK_ON_FAIL_HRESULT(hr);
        }

        strSchemaNc = m_bstrSchemaNamingContext.c_str();
    } while (0);

    return strSchemaNc;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRootDSE::_Init
//
//  Synopsis:   Obtain an interface to the RootDSE object.
//
//  Returns:    HRESULT
//
//  History:    02-25-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CRootDSE::_Init(
    HWND hwnd) const
{
    TRACE_METHOD(CRootDSE, _Init);

    HRESULT hr = S_OK;
    Variant varConfig;

	m_hrInitFailed = S_OK;
    _SetFlag(DSE_ATTEMPTED_INIT);

    do
    {
        hr = g_pBinder->GetDomainRootDSE(hwnd,
                                         m_wzTargetDomain,
                                         &m_pADsRootDSE);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Get the configuration naming context, used to build up
        // paths to configuration container, partitions container, etc.
        //

        hr = m_pADsRootDSE->Get((PWSTR)c_wzConfigNamingContext, &varConfig);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(varConfig.GetBstr());

        m_bstrConfigNamingContext = varConfig.GetBstr();
        Dbg(DEB_TRACE,
            "m_bstrConfigNamingContext = '%ws'\n",
            m_bstrConfigNamingContext);

        //
        // Get the schema naming context
        //

        varConfig.Clear();

        hr = m_pADsRootDSE->Get((PWSTR)c_wzSchemaNamingContext, &varConfig);
        BREAK_ON_FAIL_HRESULT(hr);

        ASSERT(varConfig.GetBstr());
        m_bstrSchemaNamingContext = varConfig.GetBstr();
    } while (0);

    //
    // If initialization failed because of a credential error, assume this
    // means that the user hit Cancel in a credential prompt dialog, and
    // clear the DSE_ATTEMPTED_INIT flag so that we will try again later
    // and give the user a second chance to enter creds.
    //
    // If the initialization failed for any other reason, set the
    // DSE_INIT_FAILED flag so we don't try to use the object.
    //

    if (FAILED(hr))
    {
        if (IsCredError(hr))
        {
            _ClearFlag(DSE_ATTEMPTED_INIT);
        }
        else
        {
            _SetFlag(DSE_INIT_FAILED);
			m_hrInitFailed = hr;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\queryengine.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       QueryEngine.cxx
//
//  Contents:   Implementation of class used to perform queries and store
//              the results.
//
//  Classes:    CQueryEngine
//
//  History:    04-13-2000   DavidMun   Created
//
//  Notes:      Methods whose names begin with a lowercase 't' (e.g.
//              _tAddCustomObjects) run in the worker thread.
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


#define NOTIFY_BLOCK_SIZE   64
#define BREAK_IF_NEW_WORK_ITEM if (m_usnNextWorkItem > m_usnCurWorkItem) break

//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::CQueryEngine
//
//  Synopsis:   ctor
//
//  History:    04-13-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CQueryEngine::CQueryEngine(
    const CObjectPicker &rop):
        m_rop(rop),
        m_hThread(NULL),
        m_CurrentThreadState(WTS_WAIT),
        m_DesiredThreadState(WTS_WAIT),
        m_hThreadEvent(NULL),
        m_usnCurWorkItem(0),
        m_usnNextWorkItem(0),
        m_hrLastQueryResult(S_OK)
{
    TRACE_CONSTRUCTOR(CQueryEngine);
    InitializeCriticalSection(&m_cs);
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::~CQueryEngine
//
//  Synopsis:   dtor
//
//  History:    04-13-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CQueryEngine::~CQueryEngine()
{
    TRACE_DESTRUCTOR(CQueryEngine);

    if (m_hThread)
    {
        ASSERT(m_hThreadEvent);

        {
            CAutoCritSec Lock(&m_cs);

            m_DesiredThreadState = WTS_EXIT;
            m_usnNextWorkItem++;
            VERIFY(SetEvent(m_hThreadEvent));
        }

        MessageWait(1, &m_hThread, INFINITE);
		CloseHandle(m_hThread);
		CloseHandle(m_hThreadEvent);
    }
    else
    {
        ASSERT(!m_hThreadEvent);
    }
    DeleteCriticalSection(&m_cs);
    m_hThread = 0;
    m_hThreadEvent = 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::Initialize
//
//  Synopsis:   Second phase of initialization; if this fails queries
//              cannot be performed.
//
//  Returns:    HRESULT
//
//  History:    04-13-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CQueryEngine::Initialize()
{
    TRACE_METHOD(CQueryEngine, Initialize);

    HRESULT hr = S_OK;

    do
    {
        m_hThreadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        if (!m_hThreadEvent)
        {
            DBG_OUT_LASTERROR;
            hr = HRESULT_FROM_LASTERROR;
            break;
        }

        ULONG idThread;

        m_hThread = CreateThread(NULL,
                                 0,
                                 CQueryEngine::_tThread_Proc,
                                 (PVOID) this,
                                 0,
                                 &idThread);

        if (!m_hThread)
        {
            DBG_OUT_LASTERROR;
            hr = HRESULT_FROM_LASTERROR;
            break;
        }

        Dbg(DEB_TRACE, "Created thread, id=0x%x\n", idThread);
    } while (0);

    if (FAILED(hr) && m_hThreadEvent)
    {
        VERIFY(CloseHandle(m_hThreadEvent));
        m_hThreadEvent = NULL;
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::AsyncDirSearch
//
//  Synopsis:   Tell the worker thread to start a query.
//
//  Arguments:  [qp] - particulars of the query to perform
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  History:    04-13-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CQueryEngine::AsyncDirSearch(
    const SQueryParams &qp,
    ULONG *pusnThisWorkItem) const
{
    TRACE_METHOD(CQueryEngine, AsyncDirSearch);

    if (!m_hThread)
    {
        return E_OUTOFMEMORY;
    }
    ASSERT(m_hThreadEvent);

    {
        CAutoCritSec Lock(&m_cs);

        ++m_usnNextWorkItem;
        if (pusnThisWorkItem)
        {
            *pusnThisWorkItem = m_usnNextWorkItem;
        }
        m_NextQueryParams = qp;
        m_DesiredThreadState = WTS_QUERY;
        m_hrLastQueryResult = S_OK;
    }
    VERIFY(SetEvent(m_hThreadEvent));
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::StopWorkItem
//
//  Synopsis:   Abort whatever work is in progress.
//
//  History:    04-27-2000   DavidMun   Created
//
//  Notes:      Safe to call if no work is in progress.
//
//---------------------------------------------------------------------------

void
CQueryEngine::StopWorkItem() const
{
    TRACE_METHOD(CQueryEngine, StopWorkItem);

    CAutoCritSec Lock(&m_cs);
    ++m_usnNextWorkItem;
    m_DesiredThreadState = WTS_WAIT;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::SyncDirSearch
//
//  Synopsis:   Perform the search specified by [qp] and block until it
//              is complete.
//
//  Arguments:  [qp] - indicates what to search for and where.
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CQueryEngine::SyncDirSearch(
    const SQueryParams &qp) const
{
    TRACE_METHOD(CQueryEngine, SyncDirSearch);

    HRESULT hr = AsyncDirSearch(qp);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    if (qp.hQueryCompleteEvent == INVALID_HANDLE_VALUE)
    {
        Dbg(DEB_ERROR,
            "error: Caller did not supply hQueryCompleteEvent value\n");
        return E_INVALIDARG;
    }

    MessageWait(1, &qp.hQueryCompleteEvent, INFINITE);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::_tThread_Proc, static
//
//  Synopsis:   Entry point and main loop for the query thread.
//
//  Arguments:  [pvThis] - pointer to CWorkerThread instance
//
//  Returns:    0
//
//  History:    10-14-1997   DavidMun   Created
//              02-02-2000   davidmun   taken from CWorkerThread, modified
//
//---------------------------------------------------------------------------

DWORD WINAPI
CQueryEngine::_tThread_Proc(
    LPVOID pvThis)
{
    TRACE_FUNCTION(CWorkerThread::_tThread_Proc);
    HRESULT hr;

    hr = CoInitialize(NULL);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return 0;
    }

    CQueryEngine *pThis = reinterpret_cast<CQueryEngine *> (pvThis);


    while (pThis->m_CurrentThreadState != WTS_EXIT)
    {
        ULONG ulWaitResult;

        //
        // Wait for the main thread to signal that there's something to do.
        //

        Dbg(DEB_TRACE, "_tThread_Proc: waiting for event\n");

        ulWaitResult = WaitForSingleObject(pThis->m_hThreadEvent, INFINITE);

        if (ulWaitResult != WAIT_OBJECT_0)
        {
            Dbg(DEB_ERROR,
                "_tThread_Proc: wait result %u, LastError = %uL\n",
                ulWaitResult,
                GetLastError());
            pThis->m_CurrentThreadState = WTS_EXIT;
            continue;
        }

        {
            CAutoCritSec Lock(&pThis->m_cs);

            pThis->m_CurrentThreadState = pThis->m_DesiredThreadState;
            pThis->m_usnCurWorkItem     = pThis->m_usnNextWorkItem;
            pThis->m_CurQueryParams     = pThis->m_NextQueryParams;
        }

        switch (pThis->m_CurrentThreadState)
        {
        case WTS_QUERY:
            if (IsUplevel(pThis->m_CurQueryParams.rpScope.get()))
            {
                pThis->_tPerformLdapQuery();
            }
            else
            {
                pThis->_tPerformWinNtEnum();
            }
            break;

        case WTS_WAIT:
        case WTS_EXIT:
            break;
        }
    }

    CoUninitialize();
    Dbg(DEB_TRACE, "_tThread_Proc: exiting\n");
    return 0;
}

//  NTRAID#406082-2001/06/01-lucios - Begin
//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::addApprovedObjects
//
//  Synopsis:   Add to m_vObjects the approved objects of dsolToAdd. 
//  auxiliar in _tPerformLdapQuery
//
//  History:    06-01-2001   lucios   Created
//
//  Notes:      Runs in worker thread.
//
//---------------------------------------------------------------------------


HRESULT
CQueryEngine::_tAddApprovedObjects
(
   CDsObjectList &dsolToAdd
)
{
   TRACE_METHOD(CQueryEngine, _tAddApprovedObjects);
   
   ASSERT(dsolToAdd.size() <= NOTIFY_BLOCK_SIZE);

   HRESULT hr=S_OK;

   do
   {
      // this can happen only for the final call to _tAddApprovedObjects
      if(dsolToAdd.size()==0)
      {
         break; // we return S_OK
      }

      ICustomizeDsBrowser *pExternalCustomizer =  m_rop.GetExternalCustomizer();
      BOOL afApproved[NOTIFY_BLOCK_SIZE];

      if (pExternalCustomizer)
      {
         // let's check for approval
         ZeroMemory(afApproved, sizeof afApproved);

         // Add the list to a CDataObject to pass to ApproveObjects
         CDataObject DataObject
         (
            const_cast<CObjectPicker*>(&m_rop), 
            dsolToAdd
         );

         // The main and only approval call...
         hr = pExternalCustomizer->ApproveObjects
         (
           m_CurQueryParams.rpScope.get(),
           &DataObject,
           afApproved
         );

         //
         // Failure hresult means no objects approved.
         //

         if (FAILED(hr))
         {
           Dbg(DEB_TRACE, "Skipping block of unapproved objects\n");
           // we propagate our hr
           break;
         }
      }
      else
      {
         hr=S_OK;
      }

      //
      // Now add all approved items to buffer.  S_FALSE means only some
      // were approved.  Any other success code means all were approved.
      //

      BOOL fApprovedAll = (hr != S_FALSE);
      CDsObjectList::iterator it;
      ULONG i;
      for (i = 0, it = dsolToAdd.begin(); it != dsolToAdd.end(); it++, i++)
      {
          if (fApprovedAll || afApproved[i])
          {
              CAutoCritSec Lock(&m_cs);
              m_vObjects.push_back(*it);
          }
          else
          {
              Dbg(DEB_TRACE, "Object '%ws' was not approved\n", it->GetName());
          }
      }

   } while(0);

   // let's clear the list for the next round
   dsolToAdd.clear();

   return hr;
}
//  NTRAID#406082-2001/06/01-lucios - End


//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::_tPerformLdapQuery
//
//  Synopsis:   Performs an LDAP directory search parameterized by
//              m_CurQueryParams.
//
//  History:    04-13-2000   DavidMun   Created
//
//  Notes:      Runs in worker thread.
//
//---------------------------------------------------------------------------

void
CQueryEngine::_tPerformLdapQuery()
{
    TRACE_METHOD(CQueryEngine, _tPerformLdapQuery);

    HRESULT hr = S_OK;
    RpIDirectorySearch rpDirSearch;
    ULONG cRows = 0;

#ifdef FORCE_ERROR_FOR_TESTING_ERROR_DISPLAY
static int icalls;
#endif // FORCE_ERROR_FOR_TESTING_ERROR_DISPLAY


    //list to accumulate objects to be added
    CDsObjectList dsolToAdd;


    do
    {
#ifdef FORCE_ERROR_FOR_TESTING_ERROR_DISPLAY
        if (!icalls++)
        {
            hr = HRESULT_FROM_WIN32(ERROR_DS_NONSAFE_SCHEMA_CHANGE);
            break;
        }
#endif // FORCE_ERROR_FOR_TESTING_ERROR_DISPLAY

        Clear();

        _tAddCustomObjects();

        //
        // Notify main thread of any custom objects added
        //

        if (m_vObjects.size())
        {
            PostMessage(m_CurQueryParams.hwndNotify,
                        OPM_NEW_QUERY_RESULTS,
                        m_vObjects.size(),
                        m_usnCurWorkItem);
        }

        //
        // If there is no ldap filter then there's nothing other than the
        // custom objects to add.
        //

        if (m_CurQueryParams.strLdapFilter.empty())
        {
            break;
        }

        //
        // Set up for performing an ldap query
        //

        hr = g_pBinder->BindToObject(m_CurQueryParams.hwndCredPromptParentDlg,
                                     m_CurQueryParams.strADsPath.c_str(),
                                     IID_IDirectorySearch,
                                     (void**)&rpDirSearch,
                                     m_CurQueryParams.ulBindFlags);
        BREAK_ON_FAIL_HRESULT(hr);

        ADS_SEARCHPREF_INFO aSearchPrefs[4];

        aSearchPrefs[0].dwSearchPref = ADS_SEARCHPREF_PAGESIZE;
        aSearchPrefs[0].vValue.dwType = ADSTYPE_INTEGER;
        aSearchPrefs[0].vValue.Integer = DEFAULT_PAGE_SIZE;

        aSearchPrefs[1].dwSearchPref = ADS_SEARCHPREF_DEREF_ALIASES;
        aSearchPrefs[1].vValue.dwType = ADSTYPE_INTEGER;
        aSearchPrefs[1].vValue.Integer = ADS_DEREF_NEVER;

        aSearchPrefs[2].dwSearchPref = ADS_SEARCHPREF_SEARCH_SCOPE;
        aSearchPrefs[2].vValue.dwType = ADSTYPE_INTEGER;
        aSearchPrefs[2].vValue.Integer = m_CurQueryParams.ADsScope;

        aSearchPrefs[3].dwSearchPref = ADS_SEARCHPREF_CACHE_RESULTS;
        aSearchPrefs[3].vValue.dwType = ADSTYPE_BOOLEAN;
        aSearchPrefs[3].vValue.Integer = FALSE;

        hr = rpDirSearch->SetSearchPreference(aSearchPrefs,
                                              ARRAYLEN(aSearchPrefs));
        BREAK_ON_FAIL_HRESULT(hr);

        CRow Row(m_CurQueryParams.hwndCredPromptParentDlg,
                 m_rop,
                 rpDirSearch.get(),
                 m_CurQueryParams.strLdapFilter,
                 m_CurQueryParams.vakAttributesToRead);

        while (1)
        {
            if (m_usnNextWorkItem > m_usnCurWorkItem)
            {
                Dbg(DEB_TRACE,
                    "Next work item usn is %u, current is %u, abandoning dir search\n",
                    m_usnNextWorkItem,
                    m_usnCurWorkItem);
                break;
            }

            hr = Row.Next();

            if (hr == S_ADS_NOMORE_ROWS)
            {
                Dbg(DEB_TRACE, "S_ADS_NOMORE_ROWS (got %u)\n", cRows);

                ULONG ulADsLastError;
                WCHAR wzError[MAX_PATH];
                WCHAR wzProvider[MAX_PATH];

                HRESULT hr2 = ADsGetLastError(&ulADsLastError,
                                              wzError,
                                              ARRAYLEN(wzError),
                                              wzProvider,
                                              ARRAYLEN(wzProvider));

                if (SUCCEEDED(hr2) && ulADsLastError == ERROR_MORE_DATA)
                {
                    Dbg(DEB_TRACE, "Got ERROR_MORE_DATA, trying again\n");
                    continue;
                }
                break;
            }

            BREAK_ON_FAIL_HRESULT(hr);

            // NTRAID#406082-2001/06/01-lucios - Begin
            // Add object to a temporary list of objects pending approval
            dsolToAdd.push_back
            (
               CDsObject
               (
                   m_CurQueryParams.rpScope.get()->GetID(),
                   Row.GetAttributes()
               )
            );
            // NTRAID#406082-2001/06/01-lucios - End
                

            cRows++;

            if (m_CurQueryParams.Limit == QL_USE_REGISTRY_LIMIT &&
                cRows >= g_cQueryLimit)
            {
                Dbg(DEB_TRACE,
                    "Got %u rows, query limit is %u, stopping query\n",
                    cRows,
                    g_cQueryLimit);

                //
                // Post a message indicating query cut short so that
                // main dialog can pop up notice
                //

                if (m_CurQueryParams.hwndNotify)
                {
                    PostMessage(m_CurQueryParams.hwndNotify,
                                OPM_HIT_QUERY_LIMIT,
                                0,
                                0);
                }
                break;
            }

            //
            // If we've accumulated an even multiple of NOTIFY_BLOCK_SIZE rows,
            // post a notification that there's more stuff to show.
            //

            if (m_CurQueryParams.hwndNotify && !(cRows % NOTIFY_BLOCK_SIZE))
            {
               // NTRAID#406082-2001/06/01-lucios - Begin
               // add to m_vObjects the approved objects
               HRESULT hrApproved=_tAddApprovedObjects(dsolToAdd);

               // a failed hr means there are no objects in
               // m_vObjects
               if (FAILED(hrApproved))
               {
                  Dbg(DEB_TRACE, "Skipping block of unapproved objects\n");
                  // This is not a fatal error but there is no need to notify
                  // the UI for 0 objects. 
                  // That is why the PostMessage is in the else clause.
               }
               else
               {
                  PostMessage(m_CurQueryParams.hwndNotify,
                               OPM_NEW_QUERY_RESULTS,
                               m_vObjects.size(),
                               m_usnCurWorkItem);
               }
               // NTRAID#406082-2001/06/01-lucios - End
            }
        }
    } while (0);

    //
    // Remember status of query
    //

    m_hrLastQueryResult = hr;

    //
    // Post notification that query is complete
    //

    // NTRAID#406082-2001/06/01-lucios - Begin
    // add to m_vObjects the approved objects
    hr=_tAddApprovedObjects(dsolToAdd);
 
    // a failed hr means there are no objects in
    // m_vObjects
    if (FAILED(hr))
    {
       Dbg(DEB_TRACE, "Skipping block of unapproved objects\n");
       hr=S_OK; 
       // This is not a fatal error and we might 
       // notify even with the m_vObjects.size 0
    }
    // NTRAID#406082-2001/06/01-lucios - End

    if (m_CurQueryParams.hwndNotify)
    {
        PostMessage(m_CurQueryParams.hwndNotify,
                    OPM_QUERY_COMPLETE,
                    m_vObjects.size(),
                    m_usnCurWorkItem);
    }

    if (m_CurQueryParams.hQueryCompleteEvent != INVALID_HANDLE_VALUE)
    {
        SetEvent(m_CurQueryParams.hQueryCompleteEvent);
    }

    //
    // Return to waiting state
    //

    m_CurrentThreadState = WTS_WAIT;
}



#define ENUM_NEXT_REQUESTED_ELEMENTS    25

//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::_tPerformWinNtEnum
//
//  Synopsis:   Performs a WinNT enumeration parameterized by
//              m_CurQueryParams.
//
//  History:    04-26-2000   DavidMun   Created
//
//  Notes:      Runs in worker thread
//
//---------------------------------------------------------------------------

void
CQueryEngine::_tPerformWinNtEnum()
{
    TRACE_METHOD(CQueryEngine, _tPerformWinNtEnum);

    HRESULT         hr = S_OK;
    IADsContainer  *pContainer = NULL;
    IEnumVARIANT   *pEnum = NULL;
    Variant         varFilter;
    ULONG           i;

    do
    {
        Clear();

        _tAddCustomObjects();

        if (m_usnNextWorkItem > m_usnCurWorkItem)
        {
            break;
        }

        //
        // If there aren't any class filters to use for an enumeration,
        // go to cleanup section, which will post a query-finished msg.
        //

        if (m_CurQueryParams.vstrWinNtFilter.empty())
        {
            Dbg(DEB_TRACE, "No filters, returning\n");
            break;
        }

        //
        // Notify main thread of any custom objects added
        //

        if (m_vObjects.size())
        {
            PostMessage(m_CurQueryParams.hwndNotify,
                        OPM_NEW_QUERY_RESULTS,
                        m_vObjects.size(),
                        m_usnCurWorkItem);
        }

        //
        // Set up to perform the enumeration
        //

        hr = g_pBinder->BindToObject(m_CurQueryParams.hwndCredPromptParentDlg,
                                     m_CurQueryParams.strADsPath.c_str(),
                                     IID_IADsContainer,
                                     (void **) &pContainer);
        BREAK_ON_FAIL_HRESULT(hr);

        PWSTR *apwzFilter = new PWSTR[m_CurQueryParams.vstrWinNtFilter.size()];

        for (i = 0; i < m_CurQueryParams.vstrWinNtFilter.size(); i++)
        {
            apwzFilter[i] = const_cast<PWSTR>(m_CurQueryParams.vstrWinNtFilter[i].c_str());
        }

        hr = ADsBuildVarArrayStr(apwzFilter,
                                 static_cast<ULONG>
                                   (m_CurQueryParams.vstrWinNtFilter.size()),
                                 &varFilter);
        delete [] apwzFilter;
        apwzFilter = NULL;
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pContainer->put_Filter(*&varFilter);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = ADsBuildEnumerator(pContainer, &pEnum);
        BREAK_ON_FAIL_HRESULT(hr);

        VARIANT avarEnum[ENUM_NEXT_REQUESTED_ELEMENTS];
        ULONG   cFetched;
        ULONG cRows = 0;

        for (i = 0; i < ENUM_NEXT_REQUESTED_ELEMENTS; i++)
        {
            VariantInit(&avarEnum[i]);
        }

        //
        // Loop while the work item hasn't changed and the enumeration returns
        // objects
        //

        while (m_usnNextWorkItem == m_usnCurWorkItem)
        {
            hr = ADsEnumerateNext(pEnum,
                                  ENUM_NEXT_REQUESTED_ELEMENTS,
                                  avarEnum,
                                  &cFetched);
            BREAK_ON_FAIL_HRESULT(hr);

            ASSERT(cFetched <= ENUM_NEXT_REQUESTED_ELEMENTS);

            //
            // If nothing fetched enumeration is done
            //

            if (!cFetched)
            {
                Dbg(DEB_TRACE, "Enumeration complete, got %u\n", cRows);
                break;
            }

            //
            // varEnum contains an array with cFetched items.
            //

            CDsObjectList dsolToAdd;
            ULONG flDownlevelFilter;

            hr = m_CurQueryParams.rpScope.get()->GetResultantFilterFlags(
                    m_CurQueryParams.hwndCredPromptParentDlg,
                    &flDownlevelFilter);
            BREAK_ON_FAIL_HRESULT(hr);

            for (i = 0; i < cFetched; i++)
            {
                ASSERT(V_VT(&avarEnum[i]) == VT_DISPATCH);

                IDispatch *pdisp = V_DISPATCH(&avarEnum[i]);
                IADs *pADs = NULL;
                BSTR bstrClass = NULL;

                do
                {
                    hr = pdisp->QueryInterface(IID_IADs, (void**)&pADs);
                    BREAK_ON_FAIL_HRESULT(hr);

                    BOOL fIsDisabled = IsDisabled(pADs);

                    if (g_fExcludeDisabled && fIsDisabled)
                    {
                        break;
                    }

                    hr = pADs->get_Class(&bstrClass);
                    BREAK_ON_FAIL_HRESULT(hr);

                    //
                    // Group objects have an actual class of "group" but an
                    // internal representation as localgroup or globalgroup.
                    // If this is a group object, pwzClass will be reassigned
                    // to point to c_wzLocalGroupClass or c_wzGlobalGroupClass.
                    //

                    PCWSTR pwzClass = bstrClass;

                    if (!lstrcmpi(bstrClass, c_wzGroupObjectClass) &&
                        !WantThisGroup(flDownlevelFilter, pADs, &pwzClass))
                    {
                        break;
                    }

                    //
                    // Add the new item to the buffer.
                    //

                    dsolToAdd.push_back(
                        CDsObject(m_CurQueryParams.rpScope.get()->GetID(), pADs));
                } while (0);

                if (bstrClass!=NULL) SysFreeString(bstrClass);

                SAFE_RELEASE(pADs);
                VariantClear(&avarEnum[i]); // releases dispatch

                BREAK_IF_NEW_WORK_ITEM;
            }
            BREAK_IF_NEW_WORK_ITEM;

            BOOL afApproved[ENUM_NEXT_REQUESTED_ELEMENTS];

            ICustomizeDsBrowser *pExternalCustomizer =
                m_rop.GetExternalCustomizer();

            if (pExternalCustomizer)
            {
                //
                // Ask the customizer to approve this block of objects
                //

                CDataObject DataObject(const_cast<CObjectPicker*>(&m_rop), dsolToAdd);
                ZeroMemory(afApproved, sizeof afApproved);

                hr = pExternalCustomizer->ApproveObjects(m_CurQueryParams.rpScope.get(),
                                                         &DataObject,
                                                         afApproved);
                //
                // Failure hresult means no objects approved.
                //

                if (FAILED(hr))
                {
                    Dbg(DEB_TRACE, "Skipping block of unapproved objects\n");
                    continue;
                }
            }
            else
            {
                hr = S_OK;
            }

            //
            // Now add all approved items to buffer.  S_FALSE means only some
            // were approved.  Any other success code means all were approved.
            //

            BOOL fApprovedAll = (hr != S_FALSE);
            CDsObjectList::iterator it;

            for (i = 0, it = dsolToAdd.begin(); it != dsolToAdd.end(); it++, i++)
            {
                if (fApprovedAll || afApproved[i])
                {
                    CAutoCritSec Lock(&m_cs);
                    m_vObjects.push_back(*it);
                }
                else
                {
                    Dbg(DEB_TRACE, "Object '%ws' was not approved\n", it->GetName());
                }
                BREAK_IF_NEW_WORK_ITEM;
            }

            if (m_CurQueryParams.hwndNotify && !(m_vObjects.size() % 8))
            {
                PostMessage(m_CurQueryParams.hwndNotify,
                            OPM_NEW_QUERY_RESULTS,
                            m_vObjects.size(),
                            m_usnCurWorkItem);
            }

            // ignore errors getting data

            hr = S_OK;
            cRows += cFetched;
        }
    }
    while (0);

    //
    // Clean up
    //

    if (pEnum)
    {
        ADsFreeEnumerator(pEnum);
    }

    SAFE_RELEASE(pContainer);

    m_hrLastQueryResult = hr;

    //
    // Post notification that query is complete
    //

    if (m_CurQueryParams.hwndNotify)
    {
        PostMessage(m_CurQueryParams.hwndNotify,
                    OPM_QUERY_COMPLETE,
                    m_vObjects.size(),
                    m_usnCurWorkItem);
    }

    if (m_CurQueryParams.hQueryCompleteEvent != INVALID_HANDLE_VALUE)
    {
        SetEvent(m_CurQueryParams.hQueryCompleteEvent);
    }

    //
    // Return to waiting state
    //

    m_CurrentThreadState = WTS_WAIT;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::_tAddCustomObjects
//
//  Synopsis:   Add any objects supplied by the browse customizer to the
//              query results.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CQueryEngine::_tAddCustomObjects()
{
    TRACE_METHOD(CQueryEngine, _tAddCustomObjects);

	const CFilterManager &rfm = m_rop.GetFilterManager();
    ULONG flCurFilterFlags = rfm.GetCurScopeSelectedFilterFlags();
    

    //
    // If this query should ignore the custom objects, do nothing.
    //

    if (m_CurQueryParams.CustomizerInteraction == CUSTINT_IGNORE_CUSTOM_OBJECTS)
    {
        Dbg(DEB_TRACE,
            "CustomizerInteraction == CUSTINT_IGNORE_CUSTOM_OBJECTS, returning\n");
        return;
    }

    //
    // If an external customizer is provided, use it, otherwise use the
    // default internal customizer.
    //

    ICustomizeDsBrowser *pExternalCustomizer = m_rop.GetExternalCustomizer();

    if (pExternalCustomizer)
    {
        IDataObject *pdoToAdd = NULL;
        HRESULT hr;

        if (m_CurQueryParams.CustomizerInteraction ==
              CUSTINT_PREFIX_SEARCH_CUSTOM_OBJECTS ||
            m_CurQueryParams.CustomizerInteraction ==
              CUSTINT_EXACT_SEARCH_CUSTOM_OBJECTS)
        {
            hr = pExternalCustomizer->PrefixSearch(m_CurQueryParams.rpScope.get(),
                                                   m_CurQueryParams.strCustomizerArg.c_str(),
                                                   &pdoToAdd);
        }
        else
        {
            hr = pExternalCustomizer->AddObjects(m_CurQueryParams.rpScope.get(),
                                                 &pdoToAdd);
        }

        if (SUCCEEDED(hr) && pdoToAdd)
        {
            _tAddFromDataObject(pdoToAdd);
            pdoToAdd->Release();
        }
        else
        {
            CHECK_HRESULT(hr);
            ASSERT(!pdoToAdd);
        }
    }
    
	
	//
    // Assume if the caller set flags that the internal customizer knows
    // about that it should also be used.
    //
	//// NTRAID#NTBUG9-340227-2001/03/12-hiteshr

    if ((flCurFilterFlags & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS) ||
		 IsDownlevelFlagSet(flCurFilterFlags,
                            ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS))
    {
        const CAdminCustomizer &rDefaultCustomizer =
            m_rop.GetDefaultCustomizer();
        CDsObjectList dsolToAdd;

        if (m_CurQueryParams.CustomizerInteraction ==
              CUSTINT_PREFIX_SEARCH_CUSTOM_OBJECTS ||
            m_CurQueryParams.CustomizerInteraction ==
              CUSTINT_EXACT_SEARCH_CUSTOM_OBJECTS)
        {
            rDefaultCustomizer.PrefixSearch(m_CurQueryParams.hwndCredPromptParentDlg,
                                            *m_CurQueryParams.rpScope.get(),
                                            m_CurQueryParams.strCustomizerArg.c_str(),
                                            &dsolToAdd);
        }
        else
        {
            ASSERT(m_CurQueryParams.CustomizerInteraction ==
                   CUSTINT_INCLUDE_ALL_CUSTOM_OBJECTS);

            rDefaultCustomizer.AddObjects(m_CurQueryParams.hwndCredPromptParentDlg,
                                          *m_CurQueryParams.rpScope.get(),
                                          &dsolToAdd);
        }

        CDsObjectList::iterator it;
        CAutoCritSec Lock(&m_cs);

        if (m_CurQueryParams.CustomizerInteraction ==
              CUSTINT_PREFIX_SEARCH_CUSTOM_OBJECTS ||
            m_CurQueryParams.CustomizerInteraction ==
              CUSTINT_INCLUDE_ALL_CUSTOM_OBJECTS)
        {
            for (it = dsolToAdd.begin(); it != dsolToAdd.end(); it++)
            {
                m_vObjects.push_back(*it);
            }
        }
        else
        {
            for (it = dsolToAdd.begin(); it != dsolToAdd.end(); it++)
            {
                if (!m_CurQueryParams.strCustomizerArg.icompare(it->GetName()))
                {
                    m_vObjects.push_back(*it);
                }
            }
        }
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   TestObject
//
//  Synopsis:   Callback used to eliminate objects which don't have a name
//              matching the one pointed to by [lParam].
//
//  Arguments:  [dss]    -
//              [lParam] -
//
//  Returns:
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      This is used to get rid of the names returned by the
//              customizer's prefix match which are not exact matches of
//              the given string.  We do this when the user has chosen
//              "exact match" for a string search because unfortunately there
//              is no "ExactSearch" method for the customizer.
//
//---------------------------------------------------------------------------

BOOL
TestObject(
    const DS_SELECTION &dss,
    LPARAM lParam)
{
    const String *pstrCustomizerArg = reinterpret_cast<const String *>(lParam);

    if (!dss.pwzName || pstrCustomizerArg->icompare(dss.pwzName))
    {
        return FALSE;
    }
    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::_tAddFromDataObject
//
//  Synopsis:   Add copies of all objects in the Data Object pointed to by
//              [pdo] to the internal vector of objects.
//
//  Arguments:  [pdo] - points to data object from which to add objects
//
//  History:    06-22-2000   DavidMun   Created
//
//  Notes:      Used with data object returned from
//              ICustomizeDsBrowser::AddObjects.
//
//---------------------------------------------------------------------------

void
CQueryEngine::_tAddFromDataObject(
    IDataObject *pdo)
{
    CDsObjectList dsol;
    const CScopeManager &rsm = m_rop.GetScopeManager();
    const CScope &rCurScope = rsm.GetCurScope();
    PFNOBJECTTEST pfnTest = NULL;

    if (m_CurQueryParams.CustomizerInteraction ==
        CUSTINT_EXACT_SEARCH_CUSTOM_OBJECTS)
    {
        pfnTest = TestObject;
    }

    AddFromDataObject(
        rCurScope.GetID(),
        pdo,
        pfnTest,
        reinterpret_cast<LPARAM>(&m_CurQueryParams.strCustomizerArg),
        &dsol);

    CDsObjectList::iterator it;

    CAutoCritSec    Lock(&m_cs);

    for (it = dsol.begin(); it != dsol.end(); it++)
    {
        m_vObjects.push_back(*it);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CQueryEngine::GetObjectAttr
//
//  Synopsis:   Return the attribute with key [ak] from the [idxRow]th
//              object in internal buffer.
//
//  Arguments:  [idxRow] - zero based index indicating which object from
//                          which to retrieve an attribute
//              [ak]     - identifies attribute to return
//
//  Returns:    Variant containing copy of attribute.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

Variant
CQueryEngine::GetObjectAttr(
    size_t      idxRow,
    ATTR_KEY   ak) const
{
    CAutoCritSec Lock(&m_cs);

    //
    // In case of a bug causing caller to specify a row that doesn't exist,
    // avoid the STL array boundary exception by returning an empty variant.
    //

    ASSERT(idxRow < m_vObjects.size());
    static Variant s_varEmpty;

    if (idxRow >= m_vObjects.size())
    {
        return s_varEmpty;
    }

    //
    // take cs for read because if vector::push_back increments count
    // before it adds object, and read is attempted between increment
    // and add, an out of range exception would occur.
    //

    return m_vObjects[idxRow].GetAttr(ak);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Select.rc
//
#define IDD_FRAME                               101
#define IDD_SELECTION                           102
#define IDD_PASSWORD                            103
#define IDD_BROWSE_MULTI                        104
#define IDD_BROWSE_SINGLE                       106
#define IDD_MULTI                               107

#define IDC_ENUMWINDOW                          1002
#define IDC_SELECTWINDOW                        1003
#define IDC_SEARCH                              1004
#define IDC_SCOPE                               1005
#define IDC_LOOKIN                              1006
#define IDC_TOOLBAR                             1007


#define IDB_TOOLBAR                             101
#define IDC_ADD                                 101
#define IDC_NAME                                103
#define IDS_LVCOLUMN_0                          105
#define IDS_LVCOLUMN_1                          106
#define IDC_BROWSER                             108
#define IDS_DIRECTORY                           112
#define IDS_OTHER_TRUSTED                       113
#define IDC_EMPTY                               115
#define IDS_NO_SELECTION                        120
#define IDS_NO_SELECTIONS                       121
#define IDS_OUT_OF_MEMORY                       122
#define IDC_NAME_LBL                            126
#define IDS_SELECT_COMPUTERS                    127
#define IDS_WORKING                             128
#define IDS_NO_OBJECTS                          129
#define IDS_SELECT_COMPUTER                     133
#define IDC_USER_NAME_LBL                       134
#define IDC_USER_NAME                           135
#define IDC_PASSWORD_LBL                        136
#define IDC_PASSWORD                            137
#define IDS_USER                                138 // caution these must remain
#define IDS_USERS                               139 // consecutive
#define IDS_CONTACT                             140
#define IDS_CONTACTS                            141
#define IDS_GROUP                               142
#define IDS_GROUPS                              143
#define IDS_COMPUTER                            144
#define IDS_COMPUTERS                           145 // end consecutive
#define IDC_BROWSER_STATIC_OVERLAY              150
#define IDS_COL1FORMAT                          151
#define IDC_SELECTIONLIST_LBL                   152
#define IDC_SELECT_MATCHING_LBL                 153
#define IDC_MATCHING_LIST                       154
#define IDS_BAD_NAME_EXTRA_SLASH                155
#define IDS_NAME_NOT_FOUND_FMT_MULTI            156
#define IDS_NAME_BAD_CLASS_FMT                  157
#define IDS_NAME_QUERY_FAILED                   158
#define IDS_MAX_HITS                            159
#define IDS_MULTI_PICK_ONE                      161
#define IDS_HIT_QUERY_LIMIT                     164
#define IDS_BAD_NAME_SLASH_AT_END               165
#define IDC_PASSWORD_EXPLANATION                166
#define IDC_TARGET                              168
#define IDS_UNKNOWN_DOMAIN                      169
#define IDC_PASSWORD_EXPLANATION2               170
#define IDC_PASSWORD_EXPLANATION3               171
#define IDC_EXAMPLE_LBL                         172
#define IDS_EXAMPLE_UPN_NT4                     173
#define IDS_EXAMPLE_NT4                         174
#define IDS_NO_SCOPES                           175
#define IDS_BAD_NAME_EXTRA_START_SLASH          176
#define IDS_COMP_IN_UNKNOWN_DOMAIN              179
#define IDS_COMP_IN_INVALID_DOMAIN              180
#define IDD_ERROR                               181
#define IDC_POPUP_MSG_ICON                      182
#define IDC_ERRORMSG                            183
#define IDC_ERROR_CODE_LBL                      185
#define IDC_ERROR_CODE_EDIT                     186
#define IDS_NO_SELECTION2                       187
#define IDS_INIT_FAILED_MEMORY                  189
#define IDS_BAD_NAME                            190
#define IDS_COMPUTER_NOT_FOUND                  192
#define IDS_INTERNAL_ERROR_COMPUTER             193
#define IDS_GET_ITEM_FAILED                     194
#define IDD_NAMENOTFOUND                        195
#define IDC_NOT_FOUND_ICON                      196
#define IDC_NOT_FOUND_MESSAGE                   197
#define IDC_CORRECT_RADIO                       198
#define IDC_CORRECT_EDIT                        199
#define IDC_REMOVE_RADIO                        200
#define IDS_NAME_NOT_FOUND_FMT_SINGLE           201
//used by burnslib                              202
#define IDS_CANNOT_INVOKE                       203
#define IDS_CANNOT_PROCESS                      204
#define IDC_SIZEGRIP                            207
#define IDA_SEARCH                              208
#define IDC_ANIMATION                           209
#define IDS_INIT_FAILED_NO_SCOPES               210
#define IDS_BIND_ERROR                          211
#define IDC_RICHEDIT                            214
#define IDC_REPLACE_RADIO                       216
#define IDS_REPLACE_SINGLE                      217
#define IDM_CUT                                 218
#define IDM_COPY                                219
#define IDM_PASTE                               220
#define IDM_RICHEDIT                            221
#define IDC_WHAT                                222
#define IDS_DNS_SLASH_NAME                      223
#define IDC_SELECTION_LBL                       224
//used by burnslib                              225
//used by burnslib                              226
//used by burnslib                              227
#define IDS_DISABLED_WARNING_FMT                228
#define IDS_UPN_FORM_NOT_ALLOWED                229
#define IDC_LOOK_FOR_PB                         230
#define IDC_LOOK_FOR_EDIT                       231
#define IDC_LOOK_IN_PB                          232
#define IDC_LOOK_IN_EDIT                        233
#define IDC_CHECK_NAMES_PB                      235
#define IDC_ADVANCED_PB                         236
#define IDD_STANDALONE_TEXT                     237
#define IDD_LOOK_FOR                            238
#define IDC_LOOK_FOR_LV                         239
#define IDD_LOOK_IN                             240
#define IDC_LOOK_IN_TV                          241
#define IDS_BROWSE_ERROR_FMT                    242
#define IDS_INIT_FAILED_MACHINE_CONFIG          246
#define IDS_INIT_FAILED_LOCAL_MACHINE_CONFIG    247
#define IDS_INIT_FAILED_BAD_ARGS                248
#define IDS_NEW_SCOPE_CLASSES_0_INTERSECTION    249
#define IDS_CANNOT_CONTACT_GC                   250
#define IDS_EXPAND_FAILED                       251
#define IDC_LOOK_FOR_LBL                        256
#define IDC_LOOK_IN_LBL                         257
#define IDC_TAB                                 258
#define IDC_FIND_NOW_PB                         259
#define IDC_STOP_PB                             260
#define IDD_ADVANCED                            261
#define IDS_COMMON_QUERIES                      262
#define IDS_QUERY_BUILDER                       263
#define IDD_COMMON_QUERIES                      264
#define IDD_QUERY_BUILDER                       265
#define IDC_NAME_COMBO                          266
#define IDC_NAME_EDIT                           267
#define IDC_DESCRIPTION_COMBO                   268
#define IDC_DESCRIPTION_EDIT                    269
#define IDC_DISABLED_CKBOX                      270
#define IDC_NON_EXPIRING_CKBOX                  271
#define IDC_LAST_LOGON_COMBO                    272
#define IDC_EXPIRED_EDIT                        273
#define IDC_CLAUSE_LIST                         274
#define IDC_ADD_BTN                             275
#define IDC_EDIT_BTN                            276
#define IDC_REMOVE_BTN                          277
#define IDS_STARTS_WITH                         278
#define IDS_IS_EXACTLY                          279
#define IDC_LBL1                                280
#define IDC_LBL2                                281
#define IDC_QUERY_LISTVIEW                      282
#define IDS_SINGLE_SELECT_INSTRUCTIONS          283
#define IDS_BUILTIN_WKSP                        284
#define IDS_BUILTIN_WKSPS                       285
#define IDI_GROUP                               286
#define IDI_USER                                287
#define IDI_COMPUTER                            288
#define IDS_OTHER_OBJECT                        289
#define IDS_OTHER_OBJECTS                       290
#define IDC_DESCRIPTION_LBL                     291
#define IDC_ATTR_LIST                           292
#define IDD_ADDCLAUSE                           293
#define IDS_UNIQUE_ATTR_FMT                     294
#define IDD_STRING_ATTR                         295
#define IDC_CONDITION_COMBO                     296
#define IDC_VALUE_EDIT                          297
#define IDS_STR_FILTER_EXACT_DESCRIPTION_FMT    298
#define IDS_STR_FILTER_PREFIX_DESCRIPTION_FMT   299
#define IDD_DN_ATTR                             300
#define IDD_CLEAR_QB                            301
#define IDS_CLEAR_QB_CAPTION                    302
#define IDS_CLEAR_QB_TEXT                       303
#define IDC_LASTLOGON_COMBO                     304
#define IDC_LASTLOGON_LBL                       305
#define IDS_SCOPE_ERROR                         306
#define IDS_NOTHINGFOUND                        307
#define IDS_QUERY_ERROR                         308
#define IDS_SEARCHING                           309
#define IDS_STOPPING_QUERY                      310
#define IDS_LOCAL_GROUP                         311
#define IDS_GLOBAL_GROUP                        312
#define IDC_AVAILABLE_LIST                      313
#define IDC_SHOWN_LIST                          314
#define IDS_CHOOSE_COLUMNS                      315
#define IDD_COLUMN_PICKER                       316
#define IDS_CANNOT_READ_RICHEDIT                317
#define IDS_MULTI_PICK_ONE_OR_MORE              318
#define IDC_COLUMNS_PB                          319
#define IDC_ADD_COL_BTN                         320
#define IDC_REMOVE_COL_BTN                      321
#define IDS_SEMICOLON_IN_NAME                   322
#define IDC_OBJECT_TYPE_LBL                     323
#define IDC_LOCATION_LBL                        324
#define IDS_REMOVE_FROM_SEL                     325
#define IDS_SINGLE_SEL_MSG                      326
#define IDS_PROGRESS_MESSAGE                    328 
#define IDS_CREDUI_MESSAGE                      330
#define IDS_CREDUI_TITLE                        331
#define IDS_CANNOT_INVOKE_ADV                   332
#define IDS_CANNOT_INVOKE_ADV_NOERROR           333
#define IDD_PROGRESS                            334
#define IDC_PRO_STATIC                          335


//
// BEGIN: Blocks of IDs which must remain consecutive
//

#define IDS_FILTER_ONE                          500
#define IDS_FILTER_TWO                          501
#define IDS_FILTER_THREE                        502
#define IDS_FILTER_FOUR                         503
#define IDS_FILTER_FIVE                         504
#define IDS_FILTER_SIX                          505

#define IDS_SELECT_ONE                          600
#define IDS_SELECT_TWO                          601
#define IDS_SELECT_THREE                        602
#define IDS_SELECT_FOUR                         603
#define IDS_SELECT_FIVE                         604
#define IDS_SELECT_SIX                          605

//
// END: Blocks of IDs which must remain consecutive
//

//
// Icons
//

#define IDI_LOCAL_GROUP                 100
#define IDI_SCOPE_WORKGROUP             105
#define IDI_SCOPE_DIRECTORY             106
#define IDI_SCOPE_DOMAIN                107

#define IDI_DISABLED_USER               200
#define IDI_DISABLED_COMPUTER           201

//
// Timers
//

#define ID_CRED_PROMPT_TIMER            100


//
// Sizing values
//

#define CX_PLUGIN_DIALOG    355
#define CX_MAIN_CONTROL     353

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\row.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       row.cxx
//
//  Contents:   Implementation of class to fetch rows from an adsi query
//
//  Classes:    CRow
//
//  History:    03-30-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

DEBUG_DECLARE_INSTANCE_COUNTER(CRow)


//+--------------------------------------------------------------------------
//
//  Member:     CRow::CRow
//
//  Synopsis:   ctor
//
//  History:    03-26-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CRow::CRow(
    HWND                       hwndParent,
    const CObjectPicker       &rop,
    IDirectorySearch          *pDirSearch,
    const String              &strQuery,
    const AttrKeyVector       &rvakAttrToRead):
#if (DBG == 1)
        m_fFirstRow(TRUE),
#endif
        m_rop(rop),
        m_hwndParent(hwndParent),
        m_hSearch(NULL),
        m_pDirSearch(pDirSearch),
        m_strQuery(strQuery),
        m_vakAttrToRead(rvakAttrToRead)
{
    TRACE_CONSTRUCTOR(CRow);
    DEBUG_INCREMENT_INSTANCE_COUNTER(CRow);
    ASSERT(pDirSearch);
    ASSERT(!strQuery.empty());
    ASSERT(!rvakAttrToRead.empty());
    ASSERT(rvakAttrToRead.end() ==
           find(rvakAttrToRead.begin(), rvakAttrToRead.end(), AK_INVALID));

    pDirSearch->AddRef();
}




//+--------------------------------------------------------------------------
//
//  Member:     CRow::~CRow
//
//  Synopsis:   dtor
//
//  History:    03-26-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CRow::~CRow()
{
    TRACE_DESTRUCTOR(CRow);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CRow);

    if (m_pDirSearch)
    {
        if (m_hSearch)
        {
            TIMER("Abandoning search and closing search handle");
            m_pDirSearch->AbandonSearch(m_hSearch);
            m_pDirSearch->CloseSearchHandle(m_hSearch);
            m_hSearch = NULL;
        }
        m_pDirSearch->Release();
        m_pDirSearch = NULL;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CRow::Next
//
//  Synopsis:   Read the next row returned by the query.
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CRow::Next()
{
    DBG_INDENTER;

    HRESULT hr = S_OK;
    const CAttributeManager &ram = m_rop.GetAttributeManager();
    ULONG i;

    do
    {
        //
        // Should have the search interface from Init
        //

        if (!m_pDirSearch)
        {
            hr = E_UNEXPECTED;
            Dbg(DEB_ERROR, "CRow::Next called but m_pDirSearch NULL\n");
            BREAK_ON_FAIL_HRESULT(hr);
        }

        //
        // If the search hasn't been started, do so
        //

        if (!m_hSearch)
        {
            ASSERT(m_pDirSearch);
            ASSERT(m_strQuery.length());

            DBG_DUMP_QUERY("Executing Search:", m_strQuery.c_str());

            //
            // ExecuteSearch wants an array of pointers to strings, where
            // each string is the name of an attribute to fetch.  Each of these
            // forms a column of the returned row.
            //

            PWSTR *apwzAttrs = new PWSTR[m_vakAttrToRead.size()];

            for (i = 0; i < m_vakAttrToRead.size(); i++)
            {
                apwzAttrs[i] =
                    const_cast<PWSTR>(ram.GetAttrAdsiName(m_vakAttrToRead[i]).c_str());
            }

            hr = m_pDirSearch->ExecuteSearch(const_cast<PWSTR>(m_strQuery.c_str()),
                                             apwzAttrs,
                                             static_cast<DWORD>(m_vakAttrToRead.size()),
                                             &m_hSearch);
            delete [] apwzAttrs;
            BREAK_ON_FAIL_HRESULT(hr);
            ASSERT(m_hSearch);
        }

        //
        // Get the next row
        //

        m_AttrValueMap.clear();

#if (DBG == 1)
        CTimer  *pTimer = NULL;

        if (m_fFirstRow)
        {
            pTimer = new CTimer;
            pTimer->Init("First call to GetNextRow");
        }
#endif
		hr = m_pDirSearch->GetNextRow(m_hSearch);

#if (DBG == 1)
        if (m_fFirstRow)
        {
            delete pTimer;
            pTimer = NULL;
            m_fFirstRow = FALSE;
        }
#endif

        BREAK_ON_FAIL_HRESULT(hr);

        if (hr == S_ADS_NOMORE_ROWS)
        {
            break;
        }

        //
        // Now put all the columns of the row into our variant vector
        //

        AttrKeyVector::const_iterator it;

        for (it = m_vakAttrToRead.begin();
             it != m_vakAttrToRead.end();
             it++)
        {
            ADS_SEARCH_COLUMN Col;
            ZeroMemory(&Col, sizeof Col);

            hr = m_pDirSearch->GetColumn(m_hSearch,
                                         const_cast<PWSTR>(ram.GetAttrAdsiName(*it).c_str()),
                                         &Col);

            if (SUCCEEDED(hr))
            {
                Variant varFromCol = Col;

                m_AttrValueMap[*it] = varFromCol;
                hr = m_pDirSearch->FreeColumn(&Col);
                CHECK_HRESULT(hr);
            }
            else
            {
                hr = S_OK; // failure to get a particular column is not fatal
            }
        }
    }
    while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CRow::GetColumnStr
//
//  Synopsis:   Return the string type attribute identified by [ak] from
//              the current row
//
//  Arguments:  [ak] - identifies attribute to fetch
//
//  Returns:    String attribute value, NULL if not found
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

PCWSTR
CRow::GetColumnStr(
    ATTR_KEY ak) const
{
    AttrValueMap::const_iterator it;

    it = m_AttrValueMap.find(ak);

    if (it == m_AttrValueMap.end())
    {
        return NULL;
    }

    const Variant &rvar = it->second;

    if (rvar.Type() != VT_BSTR)
    {
        ASSERT(rvar.Empty());

        if (!rvar.Empty())
        {
            Dbg(DEB_ERROR,
                "CRow::GetColumnStr: error vt=%uL, expected VT_BSTR or VT_EMPTY\n",
                rvar.Type());
        }
        return NULL;
    }

    return rvar.GetBstr();
}


PSID
CRow::GetObjectSid() 
{
    AttrValueMap::iterator it;

    it = m_AttrValueMap.find(AK_OBJECT_SID);

    if (it == m_AttrValueMap.end())
    {
        return NULL;
    }

    Variant &rvar = it->second;

    if (rvar.Type() != (VT_ARRAY | VT_UI1))
    {
        ASSERT(rvar.Empty());

        if (!rvar.Empty())
        {
            Dbg(DEB_ERROR,
                "CRow::GetObjectSid: error vt=%uL, expected (VT_ARRAY | VT_UI1) or VT_EMPTY\n",
                rvar.Type());
        }
        return NULL;
    }
    PSID pSid = NULL;
    rvar.SafeArrayAccessData(&pSid);
    return pSid;
}

//+--------------------------------------------------------------------------
//
//  Member:     CRow::GetColumnInt
//
//  Synopsis:   Return the integer type attribute identified by [ak] from
//              the current row.
//
//  Arguments:  [ak] - identifies the attribute to fetch
//
//  Returns:    Integer attribute value, or 0 if not found
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CRow::GetColumnInt(
    ATTR_KEY ak) const
{
    AttrValueMap::const_iterator it;

    it = m_AttrValueMap.find(ak);

    if (it == m_AttrValueMap.end())
    {
        return NULL;
    }

    const Variant &rvar = it->second;

    if (rvar.Empty())
    {
        return 0;
    }

    ASSERT(rvar.Type() == VT_UI4);
    return V_UI4(&rvar);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\safereg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1997.
//
//  File:       safereg.cxx
//
//  Contents:   Implementation of Win32 registry API C++ wrapper
//
//  Classes:    CSafeReg
//
//  History:    1-02-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop



//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Close
//
//  Synopsis:   Close the key if it is open.
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
CSafeReg::Close()
{
    // TRACE_METHOD(CSafeReg, Close);

        if (_hKey)
        {
        LONG lr = RegCloseKey(_hKey);
        ASSERT(lr == ERROR_SUCCESS);
                _hKey = NULL;
        }
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Create
//
//  Synopsis:   Creates a new key with write access.
//
//  Arguments:  [wszSubKey] - name of new key
//              [pshkNew]   - given new key; must not already have a key
//
//  Returns:    HRESULT
//
//  Modifies:   *[pshkNew]
//
//  History:    3-31-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Create(
    LPCWSTR wszSubKey,
    CSafeReg *pshkNew)
{
    Dbg(DEB_TRACE, "CSafeReg::Create(%x) '%s'\n", this, wszSubKey);
    ASSERT(_hKey);
    ASSERT(!pshkNew->_hKey);

    HRESULT hr = S_OK;
    LONG lr;
    DWORD dwDisposition;

    lr = RegCreateKeyEx(_hKey,
                        wszSubKey,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_WRITE,
                        NULL,
                        &pshkNew->_hKey,
                        &dwDisposition);

    if (lr != ERROR_SUCCESS)
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Connect
//
//  Synopsis:   Open a connection to HKLM or HKEY_USERS on
//              [ptszMachineName].
//
//  Arguments:  [ptszMachineName] - remote machine name.
//              [hkeyPredefined]  - HKEY_LOCAL_MACHINE or HKEY_USERS.
//
//  Returns:    HRESULT
//
//  History:    2-07-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Connect(
    LPCWSTR pwszMachineName,
    HKEY hkeyPredefined)
{
    TRACE_METHOD(CSafeReg, Connect);
    ASSERT(!_hKey);
    ASSERT(pwszMachineName);
    ASSERT(hkeyPredefined == HKEY_LOCAL_MACHINE ||
           hkeyPredefined == HKEY_USERS);

    HRESULT hr = S_OK;
    LONG lr;
    CWaitCursor Hourglass;

    lr = RegConnectRegistry((LPWSTR)pwszMachineName,
                            hkeyPredefined,
                            &_hKey);

    if (lr != ERROR_SUCCESS)
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::DeleteTree
//
//  Synopsis:   Delete the subkey [wszSubKey] and all keys beneath it.
//
//  Arguments:  [wszSubKey] - name of root key of tree to delete
//
//  Returns:    HRESULT
//
//  History:    08-06-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::DeleteTree(
    LPCWSTR wszSubKey)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;

    do
    {
        CSafeReg shkSubKey;

        hr = shkSubKey.Open(_hKey,
                            wszSubKey,
                            KEY_WRITE | KEY_ENUMERATE_SUB_KEYS);
        BREAK_ON_FAIL_HRESULT(hr);

        WCHAR wszEnumeratedKeyName[MAX_PATH];

        hr = shkSubKey.Enum(0,
                            wszEnumeratedKeyName,
                            ARRAYLEN(wszEnumeratedKeyName));
        CHECK_HRESULT(hr);

        if (hr != S_OK)
        {
            break;
        }

        //
        // Recursively delete keys below wszSubKey
        //

        hr = shkSubKey.DeleteTree(wszEnumeratedKeyName);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Since we've made a change to the key, the current enumeration
        // context is invalid.  We have to close the key and re-enumerate.
        //

        shkSubKey.Close();
    }
    while (TRUE);


    Dbg(DEB_TRACE, "CSafeReg::DeleteTree '%ws'\n", wszSubKey);
    LONG lr = RegDeleteKey(_hKey, wszSubKey);

    if (lr != ERROR_SUCCESS)
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::DeleteValue
//
//  Synopsis:   Delete the value [wszValueName] from the key
//
//  Arguments:  [wszValueName] - name of value to delete
//
//  Returns:    HRESULT
//
//  History:    08-06-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::DeleteValue(
    LPCWSTR wszValueName)
{
    Dbg(DEB_TRACE, "CSafeReg::DeleteValue '%ws'\n", wszValueName);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    LONG lr = RegDeleteValue(_hKey, wszValueName);

    if (lr != ERROR_SUCCESS)
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Enum
//
//  Synopsis:   Wraps the RegEnumKeyEx API.
//
//  Arguments:  [ulSubKey]       - 0-based subkey index
//              [pwszSubkeyName] - buffer to hold subkey
//              [cchSubkeyName]  - size of buffer
//
//  Returns:    S_OK    - success
//              S_FALSE - no more items
//              E_*     - enum api failed
//
//  Modifies:   *[pwszSubkeyName]
//
//  History:    2-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Enum(
    ULONG ulSubKey,
    LPWSTR pwszSubkeyName,
    ULONG cchSubkeyName)
{
    // TRACE_METHOD(CSafeReg, Enum);
    ASSERT(_hKey);

    HRESULT     hr = S_OK;
    LONG        lr;
    FILETIME    ftLastWrite;

    lr = RegEnumKeyEx(_hKey,
                      ulSubKey,
                      pwszSubkeyName,
                      &cchSubkeyName,
                      NULL,
                      NULL,
                      NULL,
                      &ftLastWrite);

    if (lr != ERROR_SUCCESS)
    {
        if (lr == ERROR_NO_MORE_ITEMS)
        {
            hr = S_FALSE;
        }
        else
        {
            DBG_OUT_LRESULT(lr);
            hr = E_FAIL;
        }
    }

    if (FAILED(hr))
    {
        *pwszSubkeyName = L'\0';
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::Open
//
//  Synopsis:   Wraps the RegOpenKeyEx function.
//
//  Arguments:  [hKeyParent]  - open parent key
//              [lpszKeyName] - name of key to open
//              [samDesired]  - desired access level
//
//  Returns:    HRESULT representing result of RegOpenKeyEx.
//
//  History:    1-13-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::Open(
    HKEY hKeyParent,
    LPCTSTR lpszKeyName,
    REGSAM samDesired)
{
    // TRACE_METHOD(CSafeReg, Open);
        ASSERT(hKeyParent);
    ASSERT(!_hKey);

    HRESULT hr = S_OK;
        HKEY    hKey = NULL;
        LONG    lr = RegOpenKeyEx(hKeyParent, lpszKeyName, 0, samDesired, &hKey);

        if (lr == ERROR_SUCCESS)
        {
            _hKey = hKey;
        }
    else
    {
        Dbg(DEB_WARN, "CSafeReg::Open: RegOpenKeyEx returned %uL\n", lr);
        hr = HRESULT_FROM_WIN32(lr);
    }
        return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryBufSize
//
//  Synopsis:   Fill *[pcb] with the number bytes required to hold the
//              value specified by [wszValueName].
//
//  Arguments:  [wszValueName] - name of registry value on this key
//              [pcb]          - filled with required buffer size, in bytes
//
//  Returns:    HRESULT
//
//  Modifies:   *[pcb]
//
//  History:    2-24-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryBufSize(
    LPWSTR wszValueName,
    ULONG  *pcb)
{
    HRESULT hr = S_OK;
    LONG lr;

    lr = RegQueryValueEx(_hKey, wszValueName, NULL, NULL, NULL, pcb);

    if (lr != ERROR_SUCCESS)
    {
        Dbg(DEB_ERROR,
            "CSafeReg::QueryBufSize: error %uL for value '%s'\n",
            lr,
            wszValueName);
        hr = E_FAIL;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryDword
//
//  Synopsis:   Fill *[pdw] with the reg dword for value [wszValueName] on
//              this key.
//
//  Arguments:  [wszValueName] - name of dword value
//              [pdw]          - filled with dword
//
//  Returns:    HRESULT from Registry call.
//
//  Modifies:   *[pdw]
//
//  History:    1-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryDword(
    LPWSTR wszValueName,
    LPDWORD pdw)
{
    // TRACE_METHOD(CSafeReg, QueryDword);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    ULONG   cbData = sizeof(*pdw);
    ULONG   ulType;

    LONG lr = RegQueryValueEx(_hKey,
                              wszValueName,
                              NULL,
                              &ulType,
                              (LPBYTE) pdw,
                              &cbData);
    if (lr != ERROR_SUCCESS)
    {
        Dbg(DEB_ERROR,
            "CSafeReg::QueryDword: error %uL for value '%s'\n",
            lr,
            wszValueName);
        hr = E_FAIL;
    }
    else
    {
        ASSERT(REG_DWORD == ulType);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryPath
//
//  Synopsis:   Query this key for a value named [pwszValueName], which is
//              expected to be of type REG_SZ or REG_EXPAND_SZ, and put
//              the result in [pwszPathBuf].
//
//  Arguments:  [pwszValueName] - value to query for
//              [pwszPathBuf]   - buffer for string
//              [cchPathBuf]    - size, in wchars, of [pwszPathBuf]
//              [fExpand]       - TRUE=>expand a REG_EXPAND_SZ string,
//                                  FALSE=>just copy it
//
//  Returns:    S_OK - [pwszPathBuf] valid
//              E_*  - [pwszPathBuf] is an empty string
//
//  Modifies:   *[pwszPathBuf]
//
//  History:    2-10-1997   DavidMun   Created
//
//  Notes:      Strings are expanded using environment variables for the
//              current process, i.e., on the local machine, even if this
//              contains a key to a remote machine's registry.
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryPath(
    LPWSTR pwszValueName,
    LPWSTR pwszPathBuf,
    ULONG  cchPathBuf,
    BOOL   fExpand)
{
    // TRACE_METHOD(CSafeReg, QueryPath);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    DWORD   dwType;

    LONG lr;
    ULONG cbPath = cchPathBuf * sizeof(WCHAR);
    lr = RegQueryValueEx(_hKey,
                         pwszValueName,
                         NULL,
                         &dwType,
                         (LPBYTE) pwszPathBuf,
                         &cbPath);

    if (lr == ERROR_SUCCESS && dwType == REG_EXPAND_SZ)
    {
        if (fExpand)
        {
            LPWSTR pwszExpandedPath = new WCHAR[cchPathBuf];

            if (pwszExpandedPath)
            {
                lr = ExpandEnvironmentStrings(pwszPathBuf,
                                              pwszExpandedPath,
                                              cchPathBuf);

                if (!lr || (ULONG) lr > cchPathBuf)
                {
                    if (!lr)
                    {
                        DBG_OUT_LASTERROR;
                        hr = HRESULT_FROM_LASTERROR;
                    }
                    else
                    {
                        hr = E_FAIL;
                        Dbg(DEB_ERROR,
                            "CSafeReg::QueryPath: expanded string needs %u char buffer\n",
                            lr);
                    }
                }
                else
                {
                    lstrcpy(pwszPathBuf, pwszExpandedPath);
                }
                delete [] pwszExpandedPath;
            }
            else
            {
                hr = E_OUTOFMEMORY;
                DBG_OUT_HRESULT(hr);
            }
        }
    }
    else if (lr == ERROR_SUCCESS && dwType != REG_SZ)
    {
        hr = E_FAIL;
        Dbg(DEB_ERROR,
            "CSafeReg::QueryPath: value '%s' has unexpected type %uL\n",
            pwszValueName,
            dwType);
    }
    else
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }

    if (FAILED(hr))
    {
        *pwszPathBuf = L'\0';
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::QueryStr
//
//  Synopsis:   Query for a value named [pwszValueName] and put its string
//              value (REG_SZ, MULTI_SZ, or EXPAND_SZ) into [pwszBuf].
//
//  Arguments:  [pwszValueName] - name to query for
//              [pwszBuf]       - destination buffer
//              [cchBuf]        - size, in chars, of [pwszBuf]
//
//  Returns:    HRESULT
//
//  Modifies:   *[pwszBuf]; on failure it is set to an empty string.
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::QueryStr(
    LPWSTR pwszValueName,
    LPWSTR pwszBuf,
    ULONG  cchBuf)
{
    // TRACE_METHOD(CSafeReg, QueryStr);
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    DWORD   dwType;

    LONG lr;
    ULONG cbBuf = cchBuf * sizeof(WCHAR);

    lr = RegQueryValueEx(_hKey,
                         pwszValueName,
                         NULL,
                         &dwType,
                         (LPBYTE) pwszBuf,
                         &cbBuf);

    if (lr == ERROR_SUCCESS    &&
        dwType != REG_SZ       &&
        dwType != REG_MULTI_SZ &&
        dwType != REG_EXPAND_SZ)
    {
        hr = E_FAIL;
        Dbg(DEB_ERROR,
            "CSafeReg::QueryStr: value '%s' has unexpected type %uL\n",
            pwszValueName,
            dwType);
    }
    else if (lr != ERROR_SUCCESS)
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }

    if (FAILED(hr))
    {
        *pwszBuf = L'\0';
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::SetDword
//
//  Synopsis:   Set a value with name [wszValueName] and type REG_DWORD on
//              the currently open key.
//
//  Arguments:  [wszValueName] - name of value to create or set
//              [dw]           - dword to set
//
//  Returns:    Result of RegSetValueEx call.
//
//  History:    1-20-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::SetDword(
    LPWSTR wszValueName,
    DWORD dw)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;

    LONG lr = RegSetValueEx(_hKey,
                            wszValueName,
                            0,
                            REG_DWORD,
                            (PBYTE) &dw,
                            sizeof dw);

    if (lr != ERROR_SUCCESS)
    {
        Dbg(DEB_ERROR,
            "CSafeReg::WriteDword: error %uL for value '%s'\n",
            lr,
            wszValueName);
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSafeReg::SetValue
//
//  Synopsis:   Set the specified value
//
//  Arguments:  [wszValueName] - name of value, can be NULL if [ulType] is
//                                  REG_SZ
//              [ulType]       - REG_* type
//              [pbValue]      - points to value data
//              [cbValue]      - size, in bytes, of value data
//
//  Returns:    HRESULT
//
//  History:    4-25-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CSafeReg::SetValue(
    LPCWSTR wszValueName,
    ULONG   ulType,
    const BYTE *pbValue,
    ULONG   cbValue)
{
    ASSERT(_hKey);

    HRESULT hr = S_OK;
    LONG lr = RegSetValueEx(_hKey,
                            wszValueName,
                            0,
                            ulType,
                            pbValue,
                            cbValue);

    if (lr != ERROR_SUCCESS)
    {
        DBG_OUT_LRESULT(lr);
        hr = HRESULT_FROM_WIN32(lr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\sid.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999.
//
//  File:       sid.cxx
//
//  Contents:   Class that encapsulates certain distasteful operations on
//              SIDs.
//
//  Classes:    CSid
//
//  History:    10-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+--------------------------------------------------------------------------
//
//  Member:     CSid::CSid
//
//  Synopsis:   Initialize by copying sid stored in safearray of [pvarSid].
//
//  Arguments:  [pvarSid] - sid stored as safearray of bytes
//
//  History:    10-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CSid::CSid(
    VARIANT *pvarSid):
        m_psid(NULL)
{
    TRACE_CONSTRUCTOR(CSid);
    ASSERT(pvarSid);
    ASSERT(V_VT(pvarSid) == (VT_ARRAY | VT_UI1));

    HRESULT hr = S_OK;
    PSID    psid;
    ULONG   cbSid = 0;
    VOID   *pvData = NULL;
    PUCHAR  pcSubAuth = NULL;

    do
    {
        hr = SafeArrayAccessData(V_ARRAY(pvarSid), &pvData);
        BREAK_ON_FAIL_HRESULT(hr);

        psid = (PSID) pvData;

        ASSERT(IsValidSid(psid));

        pcSubAuth = GetSidSubAuthorityCount(psid);

        ASSERT(pcSubAuth);

        cbSid = GetSidLengthRequired(*pcSubAuth);

        ASSERT(cbSid);
        ASSERT(cbSid == (*pcSubAuth - 1) * (sizeof(DWORD)) + sizeof(SID));

        m_psid = new BYTE [cbSid];

        VERIFY(CopySid(cbSid, m_psid, psid));
        ASSERT(IsValidSid(m_psid));
    } while (0);

    if (pvData)
    {
        SafeArrayUnaccessData(V_ARRAY(pvarSid));
    }
}



//+--------------------------------------------------------------------------
//
//  Member:     CSid::CSid
//
//  Synopsis:   copy ctor
//
//  History:    10-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CSid::CSid(
    const CSid &sidToCopy):
        m_psid(NULL)
{
    TRACE_CONSTRUCTOR(CSid);

    if (!sidToCopy.m_psid)
    {
        Dbg(DEB_WARN, "Warning: copying NULL sid\n");
        return;
    }

    ASSERT(IsValidSid(sidToCopy.m_psid));

    PUCHAR pcSubAuth =
                GetSidSubAuthorityCount(const_cast<PSID>(sidToCopy.m_psid));
    ULONG cbSid = GetSidLengthRequired(*pcSubAuth);

    m_psid = new BYTE [cbSid];
    VERIFY(CopySid(cbSid, m_psid, sidToCopy.m_psid));
    ASSERT(IsValidSid(m_psid));
}




//+--------------------------------------------------------------------------
//
//  Member:     CSid::~CSid
//
//  Synopsis:   dtor
//
//  History:    10-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

CSid::~CSid()
{
    TRACE_DESTRUCTOR(CSid);

    delete [] m_psid;
    m_psid = NULL;
}



//+--------------------------------------------------------------------------
//
//  Member:     CSid::Decrement
//
//  Synopsis:   Consider the sid's subauthority array as a single unsigned
//              number and increment it.
//
//  History:    10-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

void
CSid::Decrement()
{
    if (!m_psid)
    {
        return;
    }

    PBYTE pbMSB = NULL;
    PBYTE pbCur = NULL;

    _GetSubAuthorityRange(&pbMSB, &pbCur);

    //
    // Treat the subauthorities as a single unsigned binary number.
    // Subtract one from the least significant byte; if this causes a
    // borrow, move on to the next most significant byte, and so on,
    // stopping if we reach the most significant byte.
    //

    for (; pbCur >= pbMSB; --pbCur)
    {
        if (--*pbCur != 0xFF)
        {
            break;
        }
    }

    //
    // We shouldn't have gone past the most significant byte, because that
    // means the subauthority values were all 0, which isn't a valid
    // SID.  Assert that there was no underflow.
    //

    ASSERT(pbCur >= pbMSB);

    // nothing we did should make the SID invalid, so test it again
    ASSERT(IsValidSid(m_psid));
}



//+--------------------------------------------------------------------------
//
//  Member:     CSid::Increment
//
//  Synopsis:   Consider the sid's subauthority array as a single unsigned
//              number and increment it.
//
//  History:    10-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

void
CSid::Increment()
{
    if (!m_psid)
    {
        return;
    }

    PBYTE pbMSB = NULL;
    PBYTE pbCur = NULL;

    _GetSubAuthorityRange(&pbMSB, &pbCur);

    for (; pbCur >= pbMSB; --pbCur)
    {
        if (++*pbCur != 0x00)
        {
            break;
        }
    }

    //
    // We shouldn't have gone past the most significant byte, because that
    // means the subauthority values were all 0xFF, which isn't a valid
    // SID.  Assert that there was no overflow.
    //

    ASSERT(pbCur >= pbMSB);

    // nothing we did should make the SID invalid, so test it again
    ASSERT(IsValidSid(m_psid));
}



//+--------------------------------------------------------------------------
//
//  Member:     CSid::GetSidAndRidAsByteStr
//
//  Synopsis:   Return a string representation of the sid with an appended
//              RID.
//
//  Arguments:  [strRid] - RID to append
//
//  Returns:    SID in byte string format:
//              \01\05\00\00...
//
//  History:    10-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

String
CSid::GetSidAndRidAsByteStr(
    const String &strRid) const
{
    if (!m_psid)
    {
        return String();
    }

    ULONG   cbSid = 0;
    PUCHAR  pcSubAuth = NULL;
    String strResult;

    pcSubAuth = GetSidSubAuthorityCount(m_psid);
    ASSERT(pcSubAuth);

    cbSid = GetSidLengthRequired(*pcSubAuth);

    //
    // Convert the bytes of the sid to hex chars in the
    // form \xx
    //

    PBYTE  pbSid = (PBYTE) m_psid;
    ULONG  i;

    for (i = 0; i < cbSid; i++)
    {
        WCHAR wzCurByte[4]; // 4 == slash + 2 digits + NUL

        if (pbSid == pcSubAuth)
        {
            // bump the subauthority count in the copy to allow for the
            // RID which we'll concatenate

            wsprintf(wzCurByte, L"\\%02x", 1 + *pbSid);
        }
        else
        {
            wsprintf(wzCurByte, L"\\%02x", *pbSid);
        }
        strResult += wzCurByte;
        pbSid++;
    }

    return strResult + strRid;
}




//+--------------------------------------------------------------------------
//
//  Member:     CSid::_GetSubAuthorityRange
//
//  Synopsis:   Return pointers to the most and least significant bytes of
//              the array of subauthorities in the sid.
//
//  Arguments:  [ppbMSB] - receives pointer to most significant byte
//              [ppbLSB] - receives pointer to least significant byte
//
//  History:    10-06-1999   davidmun   Created
//
//---------------------------------------------------------------------------

void
CSid::_GetSubAuthorityRange(
    PBYTE *ppbMSB,
    PBYTE *ppbLSB) const
{
    ASSERT(ppbMSB);
    ASSERT(ppbLSB);
    ASSERT(m_psid && IsValidSid(m_psid));

    PUCHAR pcSubAuth = GetSidSubAuthorityCount(m_psid);
    ASSERT(*pcSubAuth);

    *ppbMSB = (PBYTE) GetSidSubAuthority(m_psid, 0);
    *ppbLSB = *ppbMSB + *pcSubAuth * sizeof(ULONG) - 1;

    ASSERT(*ppbMSB < *ppbLSB);
    ASSERT(*ppbMSB > (PBYTE) m_psid);
    ASSERT(*ppbLSB == ((PBYTE) m_psid) + GetSidLengthRequired(*pcSubAuth) - 1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\scope.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       scope.cxx
//
//  Contents:   Implementations of the base and derived scope classes
//
//  Classes:    CScope
//              CLdapDomainScope
//              CLdapContainerScope
//              CTargetComputerScope
//              CWorkgroupScope
//              CGcScope
//              CWinNtDomainScope
//              CWinNtScope
//
//  History:    01-22-2000   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


// declare storage for static member variable
ULONG CScope::s_ulNextID;

//
// Forward references
//

HRESULT
_DetermineDomainMode(
    HWND hwndDlg,
    const String &strDisplayName,
    DOMAIN_MODE *pDomainMode);



//+--------------------------------------------------------------------------
//
//  Member:     CScope::GetScopeFlags
//
//  Synopsis:   Return the DSOP_SCOPE_FLAG_* bits the caller set for scopes
//              of this type.
//
//  Returns:    DSOP_SCOPE_FLAG_* bits
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

ULONG
CScope::GetScopeFlags() const
{
    ASSERT(m_Type != ST_INVALID);

    if (m_Type == ST_LDAP_CONTAINER)
    {
        if (m_pParent)
        {
            return m_pParent->GetScopeFlags();
        }
    }

    const CScopeManager &rsm = m_rop.GetScopeManager();
    const SScopeParameters *psp = rsm.GetScopeParams(m_Type);
    ASSERT(psp);

    if (psp)
    {
        return psp->flScope;
    }
    return 0;
}




//+--------------------------------------------------------------------------
//
//  Member:     CScope::GetResultantDefaultFilterFlags
//
//  Synopsis:   Fill *[pulFlags] with the DSOP_FILTER_* or
//              DSOP_DOWNLEVEL_FILTER_* flags that apply to scopes of this
//              type--and this specific scope considering its domain mode.
//
//  Arguments:  [hwndDlg]  - for bind
//              [pulFlags] - filled with flags that apply to this scope
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CScope::GetResultantDefaultFilterFlags(
    HWND hwndDlg,
    ULONG *pulFlags) const
{
    TRACE_METHOD(CScope, GetResultantDefaultFilterFlags);

    ULONG flResultantFlags;

    HRESULT hr = GetResultantFilterFlags(hwndDlg, &flResultantFlags);

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    ULONG flScope = GetScopeFlags();
    ULONG flResultantDefaultFilterFlags = 0;

    if (::IsUplevel(m_Type))
    {
        if ((flScope & DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS) &&
            (flResultantFlags & DSOP_FILTER_USERS))
        {
            flResultantDefaultFilterFlags |= DSOP_FILTER_USERS;
        }

        if ((flScope & DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS) &&
            (flResultantFlags & DSOP_FILTER_COMPUTERS))
        {
            flResultantDefaultFilterFlags |= DSOP_FILTER_COMPUTERS;
        }

        if ((flScope & DSOP_SCOPE_FLAG_DEFAULT_FILTER_CONTACTS) &&
            (flResultantFlags & DSOP_FILTER_CONTACTS))
        {
            flResultantDefaultFilterFlags |= DSOP_FILTER_CONTACTS;
        }

        if ((flScope & DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS) &&
            (flResultantFlags & ALL_UPLEVEL_GROUP_FILTERS))
        {
            flResultantDefaultFilterFlags |=
                (flResultantFlags & ALL_UPLEVEL_GROUP_FILTERS);
        }

        if (!flResultantDefaultFilterFlags)
        {
            if (flResultantFlags & DSOP_FILTER_USERS)
            {
                flResultantDefaultFilterFlags |= DSOP_FILTER_USERS;
            }
            else if (flResultantFlags & ALL_UPLEVEL_GROUP_FILTERS)
            {
                flResultantDefaultFilterFlags |=
                    (flResultantFlags & ALL_UPLEVEL_GROUP_FILTERS);
            }
            else if (flResultantFlags & DSOP_FILTER_COMPUTERS)
            {
                flResultantDefaultFilterFlags |= DSOP_FILTER_COMPUTERS;
            }
            else if (flResultantFlags & DSOP_FILTER_CONTACTS)
            {
                flResultantDefaultFilterFlags |= DSOP_FILTER_CONTACTS;
            }
        }

        if (m_rop.GetExternalCustomizer() &&
            !(flScope & DSOP_SCOPE_FLAG_UNCHECK_EXTERNAL_CUSTOMIZER))
        {
            flResultantDefaultFilterFlags |=
                (flResultantFlags & DSOP_FILTER_EXTERNAL_CUSTOMIZER);
        }

        flResultantDefaultFilterFlags |=
            (flResultantFlags & ALL_UPLEVEL_INTERNAL_CUSTOMIZER_FILTERS);

        // something should be turned on at this point
        ASSERT(flResultantDefaultFilterFlags);

        if (flResultantFlags & DSOP_FILTER_INCLUDE_ADVANCED_VIEW)
        {
            flResultantDefaultFilterFlags |= DSOP_FILTER_INCLUDE_ADVANCED_VIEW;
        }
    }
    else
    {
        if (m_Type != ST_WORKGROUP)
        {
            if ((flScope & DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS) &&
                IsDownlevelFlagSet(flResultantFlags, DSOP_DOWNLEVEL_FILTER_USERS))
            {
                flResultantDefaultFilterFlags |= DSOP_DOWNLEVEL_FILTER_USERS;
            }

            if ((flScope & DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS) &&
                IsDownlevelFlagSet(flResultantFlags, DSOP_DOWNLEVEL_FILTER_COMPUTERS))
            {
                flResultantDefaultFilterFlags |= DSOP_DOWNLEVEL_FILTER_COMPUTERS;
            }

            if ((flScope & DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS) &&
                IsDownlevelFlagSet(flResultantFlags, ALL_DOWNLEVEL_GROUP_FILTERS))
            {
                flResultantDefaultFilterFlags |=
                    (flResultantFlags & ALL_DOWNLEVEL_GROUP_FILTERS);

                //
                // Since we're setting some group filter bits, make sure to
                // carry along the exclude_builtin_groups flag if it is set.
                //

                if (IsDownlevelFlagSet(flResultantFlags,
                                       DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS))
                {
                    flResultantDefaultFilterFlags |=
                        DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS;
                }
            }
        }

        if (!flResultantDefaultFilterFlags)
        {
            if (m_Type == ST_WORKGROUP)
            {
                ASSERT(IsDownlevelFlagSet(flResultantFlags,
                                          DSOP_DOWNLEVEL_FILTER_COMPUTERS |
                                          DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER));

                //
                // These are the only two legal flags for a workgroup:
                // computers and external customizer.  if
                // DSOP_SCOPE_FLAG_UNCHECK_EXTERNAL_CUSTOMIZER is not set,
                // check the customizer.  If
                // DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS is set, check the
                // computer.
                //

                if (!(flScope & DSOP_SCOPE_FLAG_UNCHECK_EXTERNAL_CUSTOMIZER) &&
                    IsDownlevelFlagSet(flResultantFlags,
                                       DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER))
                {
                    flResultantDefaultFilterFlags |=
                        DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER;
                }

                if (flScope & DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS)
                {
                    flResultantDefaultFilterFlags |=
                        DSOP_DOWNLEVEL_FILTER_COMPUTERS;
                }

                if (!flResultantDefaultFilterFlags)
                {
                    flResultantDefaultFilterFlags =
                        DSOP_DOWNLEVEL_FILTER_COMPUTERS;
                }
            }
            else if (IsDownlevelFlagSet(flResultantFlags,
                                   DSOP_DOWNLEVEL_FILTER_USERS))
            {
                flResultantDefaultFilterFlags |= DSOP_DOWNLEVEL_FILTER_USERS;
            }
            else if (IsDownlevelFlagSet(flResultantFlags,
                                        ALL_DOWNLEVEL_GROUP_FILTERS))
            {
                flResultantDefaultFilterFlags |=
                    (flResultantFlags & ALL_DOWNLEVEL_GROUP_FILTERS);

                if (IsDownlevelFlagSet(flResultantFlags,
                                       DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS))
                {
                    flResultantDefaultFilterFlags |=
                        DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS;
                }
            }
            else if (IsDownlevelFlagSet(flResultantFlags,
                                        DSOP_DOWNLEVEL_FILTER_COMPUTERS))
            {
                ASSERT(m_Type != ST_TARGET_COMPUTER);
                flResultantDefaultFilterFlags |= DSOP_DOWNLEVEL_FILTER_COMPUTERS;
            }
        }

        if (m_rop.GetExternalCustomizer() &&
            !(flScope & DSOP_SCOPE_FLAG_UNCHECK_EXTERNAL_CUSTOMIZER))
        {
            flResultantDefaultFilterFlags |=
                (flResultantFlags & DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER);
        }

        if (IsDownlevelFlagSet(flResultantFlags,
                               ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS))
        {
            flResultantDefaultFilterFlags |=
                (flResultantFlags & ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS);
        }
    }

    *pulFlags = flResultantDefaultFilterFlags;
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLdapDomainScope::GetResultantFilterFlags
//
//  Synopsis:   Return the filter flags that are valid for this scope that
//              result from considering the domain mode.
//
//  Arguments:  [hwndBaseDlg] - for binding
//              [pulFlags]    - set to DSOP_FILTER_* flags
//
//  Returns:    HRESULT
//
//  History:    05-10-2000   DavidMun   Created
//
//  Notes:      Failure can result from user cancelling credentials dialog
//
//---------------------------------------------------------------------------

HRESULT
CLdapDomainScope::GetResultantFilterFlags(
    HWND hwndBaseDlg,
    ULONG *pulFlags) const
{
    TRACE_METHOD(CLdapDomainScope, GetResultantFilterFlags);

    HRESULT hr = S_OK;
    const CScopeManager &rsm = m_rop.GetScopeManager();
    const SScopeParameters *psp = rsm.GetScopeParams(m_Type);

    ASSERT(psp);
    ASSERT(pulFlags);

    do
    {
        if (!psp || !pulFlags)
        {
            hr = E_UNEXPECTED;  // if we get here it's a bug
            break;              // break to avoid AV on dereference
        }

        *pulFlags = 0;

        if (psp->FilterFlags.Uplevel.flMixedModeOnly !=
            psp->FilterFlags.Uplevel.flNativeModeOnly)
        {
            if (m_DomainMode == DM_UNDETERMINED)
            {
                hr = _DetermineDomainMode(hwndBaseDlg,
                                          m_strDisplayName,
                                          &m_DomainMode);
                BREAK_ON_FAIL_HRESULT(hr);
            }

            if (m_DomainMode == DM_NATIVE)
            {
                *pulFlags = psp->FilterFlags.Uplevel.flNativeModeOnly |
                            psp->FilterFlags.Uplevel.flBothModes;
            }
            else if (m_DomainMode == DM_MIXED)
            {
                *pulFlags = psp->FilterFlags.Uplevel.flMixedModeOnly |
                            psp->FilterFlags.Uplevel.flBothModes;
            }
            break;
        }

        *pulFlags = psp->FilterFlags.Uplevel.flNativeModeOnly |
                    psp->FilterFlags.Uplevel.flBothModes;
    } while (0);

    if (m_rop.GetExternalCustomizer())
    {
        *pulFlags |= DSOP_FILTER_EXTERNAL_CUSTOMIZER;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   _DetermineDomainMode
//
//  Synopsis:   Return the mode for domain with display name of
//              [strDisplayName].
//
//  Arguments:  [hwndBaseDlg] - for bind
//
//  Returns:    DM_MIXED or DM_NATIVE
//
//  History:    05-10-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
_DetermineDomainMode(
    HWND hwndBaseDlg,
    const String &strDisplayName,
    DOMAIN_MODE *pDomainMode)
{
    TRACE_FUNCTION(_DetermineDomainMode);

    HRESULT                             hr = S_OK;
    Variant                             varProcessor;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDsRole = NULL;
    PDOMAIN_CONTROLLER_INFO             pdci = NULL;
    DOMAIN_MODE                         DomainMode = DM_UNDETERMINED;

    do
    {

        ULONG  ulResult;
        RpIADs rpADs;

        //
        // DsRoleGetPrimaryDomainInformation will tell us the domain's
        // mode, but it requires the name of a computer in the domain.
        // Since all we have is the name of the domain, use that with
        // DsGetDcName to get the name of a DC for the domain.
        //

        {
            TIMER("DsGetDcName");

            ulResult = DsGetDcName(NULL,
                                   strDisplayName.c_str(),
                                   NULL,
                                   NULL,
                                   DS_IS_DNS_NAME
                                   |DS_RETURN_FLAT_NAME
                                   | DS_DIRECTORY_SERVICE_PREFERRED,
                                   &pdci);
        }

        if (ulResult != NO_ERROR)
        {
            Dbg(DEB_ERROR,
                "DsGetDcName for domain %ws returned %uL, treating as native\n",
                strDisplayName.c_str(),
                ulResult);
            DomainMode = DM_NATIVE;
            break;
        }

        ULONG ulRetry;

        for (ulRetry = 0; ulRetry < 2; ulRetry++)
        {
            ASSERT(pdci->DomainControllerName && *pdci->DomainControllerName);

            {
                TIMER("DsRoleGetPrimaryDomainInformation");

                ulResult = DsRoleGetPrimaryDomainInformation(
                                pdci->DomainControllerName,
                                DsRolePrimaryDomainInfoBasic,
                                (PBYTE *)&pDsRole);
            }

            if (ulResult == ERROR_ACCESS_DENIED)
            {
                String strADsPath;

                strADsPath = pdci->DomainControllerName;
                strADsPath.strip(String::LEADING, L'\\');
                strADsPath.insert(0, c_wzWinNTPrefix);
                strADsPath += L",Computer";

                hr = g_pBinder->BindToObject(hwndBaseDlg,
                                             strADsPath.c_str(),
                                             IID_IADs,
                                             (void**)&rpADs);
                BREAK_ON_FAIL_HRESULT(hr);
            }
            else if (ulResult == RPC_S_SERVER_UNAVAILABLE)
            {
                Dbg(DEB_ERROR,
                    "DsRoleGetPrimaryDomainInformation for DC %ws in domain %ws returned RPC_S_SERVER_UNAVAILABLE, trying to find another DC\n",
                    pdci->DomainControllerName,
                    strDisplayName.c_str());

                String strPreviousDc(pdci->DomainControllerName);

                NetApiBufferFree(pdci);
                pdci = NULL;

                ULONG ulResult2;

                {
                    TIMER("DsGetDcName (forcing rediscovery)");

                    ulResult2 = DsGetDcName(NULL,
                                           strDisplayName.c_str(),
                                           NULL,
                                           NULL,
                                           DS_IS_DNS_NAME
                                           |DS_RETURN_FLAT_NAME
                                           | DS_FORCE_REDISCOVERY
                                           | DS_DIRECTORY_SERVICE_PREFERRED,
                                           &pdci);
                }

                if (ulResult2 != NO_ERROR)
                {
                    DBG_OUT_LRESULT(ulResult2);
                    break;
                }

                if (!strPreviousDc.icompare(pdci->DomainControllerName))
                {
                    Dbg(DEB_ERROR,
                        "DsGetDcName with DS_FORCE_REDISCOVERY returned same DC\n");
                    break;
                }

                rpADs = NULL;
            }
            else
            {
                break;
            }
        }
        BREAK_ON_FAIL_HRESULT(hr);

        if (ulResult != NO_ERROR)
        {
            Dbg(DEB_ERROR,
                "DsRoleGetPrimaryDomainInformation for DC %ws in domain %ws returned %uL, treating as native\n",
                pdci->DomainControllerName,
                strDisplayName.c_str(),
                ulResult);
            DomainMode = DM_NATIVE;
            break;
        }

        if (pDsRole->Flags & DSROLE_PRIMARY_DS_MIXED_MODE)
        {
            Dbg(DEB_TRACE,
                "Domain %ws is in mixed mode\n",
                strDisplayName.c_str());
            DomainMode = DM_MIXED;
        }
        else
        {
            Dbg(DEB_TRACE,
                "Domain %ws is in native mode\n",
                strDisplayName.c_str());
            DomainMode = DM_NATIVE;
        }
    } while (0);

    if (pdci)
    {
        NetApiBufferFree(pdci);
    }

    if (pDsRole)
    {
        DsRoleFreeMemory(pDsRole);
    }

    ASSERT(SUCCEEDED(hr) && DomainMode != DM_UNDETERMINED ||
           FAILED(hr) && DomainMode == DM_UNDETERMINED);
    *pDomainMode = DomainMode;
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLdapDomainScope::CLdapDomainScope
//
//  Synopsis:   ctor
//
//  Arguments:  [rop]     - containing object picker instance
//              [asi]     - has initialization information
//              [pParent] - pointer to parent scope, or NULL if this is a
//                           root scope
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CLdapDomainScope::CLdapDomainScope(
    const CObjectPicker &rop,
    const ADD_SCOPE_INFO &asi,
    const CScope *pParent):
        CLdapContainerScope((SCOPE_TYPE)asi.flType, rop, pParent)
{
    TRACE_CONSTRUCTOR(CLdapDomainScope);

    m_strDisplayName = asi.Domain.strScopeName;
    m_strFlatName = asi.Domain.strFlatName;
    m_strADsPath = asi.Domain.strADsPath;
    m_DomainMode = asi.Domain.Mode;
    m_fPathIsDc = asi.Domain.fPathIsDc;
    m_bXForest = FALSE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CLdapContainerScope::Expand
//
//  Synopsis:   Fill *[pitBeginNew] and *[pitEndNew] with iterators at the
//              beginning and end of the child scopes of this.
//
//  Arguments:  [hwndDlg]     - for bind
//              [pitBeginNew] - filled with iterator at first child
//              [pitEndNew]   - filled with iterator at last child
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CLdapContainerScope::Expand(
    HWND hwndDlg,
    vector<RpScope>::const_iterator *pitBeginNew,
    vector<RpScope>::const_iterator *pitEndNew) const
{
    TRACE_METHOD(CLdapContainerScope, Expand);
    ASSERT(!m_strADsPath.empty());

    // init for failure case: no scopes added
    *pitBeginNew = m_vrpChildren.begin();
    *pitEndNew = m_vrpChildren.begin();

    if (m_fExpanded)
    {
        return;
    }

    const CScopeManager &rsm = m_rop.GetScopeManager();

    HRESULT hr = S_OK;
    SQueryParams qp;

    qp.rpScope                 = const_cast<CScope*>(static_cast<const CScope *>(this));
    qp.hwndCredPromptParentDlg = hwndDlg;
    qp.hwndNotify              = NULL;
    qp.strADsPath              = m_strADsPath;
    qp.strLdapFilter           = rsm.GetContainerFilter(hwndDlg);
    qp.ADsScope                = ADS_SCOPE_ONELEVEL;
    qp.Limit                   = QL_NO_LIMIT;
    qp.hQueryCompleteEvent     = CreateEvent(NULL, FALSE, FALSE, NULL);
    qp.vakAttributesToRead.push_back(AK_NAME);
    qp.vakAttributesToRead.push_back(AK_ADSPATH);
    // CustomizerInteraction initialized by ctor to IGNORE, which is correct

    //
    // If this is actually a CLdapDomainScope instance then it has a flag
    // indicating whether the path contains a server name.  If it does,
    // set a flag so we'll call ADsOpenObject with the ADS_SERVER_BIND bit.
    //

    const CLdapDomainScope *pThisAsDomain =
        dynamic_cast<const CLdapDomainScope *>(this);

    if (pThisAsDomain && pThisAsDomain->PathIsDc())
    {
        qp.ulBindFlags = DSOP_BIND_FLAG_PATH_IS_DC;
    }

    if (!qp.hQueryCompleteEvent)
    {
        DBG_OUT_LASTERROR;
        PopupMessage(hwndDlg, IDS_OUT_OF_MEMORY);
        return;
    }

	CQueryEngine qe(m_rop);
	hr = qe.Initialize();

	if(SUCCEEDED(hr))
		hr = qe.SyncDirSearch(qp);

    VERIFY(CloseHandle(qp.hQueryCompleteEvent));

    if (FAILED(hr))
    {
        DBG_OUT_HRESULT(hr);

        String strError(GetErrorMessage(hr));

        PopupMessage(hwndDlg,
                     IDS_EXPAND_FAILED,
                     GetDisplayName().c_str(),
                     strError.c_str());
        return;
    }

    if (IsCredError(qe.GetLastQueryResult()))
    {
        Dbg(DEB_TRACE,
            "Query failed for lack of creds, not marking this as expanded\n");
        ASSERT(!qe.GetItemCount());
        return;
    }

    size_t i;
    size_t cChildrenBeforeAdding = m_vrpChildren.size();

    for (i = 0; i < qe.GetItemCount(); i++)
    {
        Variant varName    = qe.GetObjectAttr(i, AK_NAME);
        Variant varADsPath = qe.GetObjectAttr(i, AK_ADSPATH);

        if (varName.Type() != VT_BSTR || varADsPath.Type() != VT_BSTR)
        {
            continue;
        }

        RpScope rpScope;

        rpScope.Acquire(new CLdapContainerScope(ST_LDAP_CONTAINER,
                                                varName.GetBstr(),
                                                varADsPath.GetBstr(),
                                                m_rop,
                                                this));

        CLdapContainerScope *pNonConstThis = const_cast<CLdapContainerScope *>(this);

        pNonConstThis->AddChild(rpScope);
    }

    qe.Clear();
    m_fExpanded = TRUE;

    //
    // If we added any children, give caller iterators over them
    //

    if (cChildrenBeforeAdding < m_vrpChildren.size())
    {
        *pitBeginNew = m_vrpChildren.begin() + cChildrenBeforeAdding;
        *pitEndNew = m_vrpChildren.end();
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CLdapContainerScope::GetResultantFilterFlags
//
//  Synopsis:   Return the filter flags that are valid for this scope that
//              result from considering the domain mode.
//
//  Arguments:  [hwndBaseDlg] - for bind
//              [pulFlags]    - points to variable filled with uplevel
//                              filter flags or 0 on error
//
//  Returns:    HRESULT
//
//  History:    02-25-2000   davidmun   Created
//
//---------------------------------------------------------------------------

HRESULT
CLdapContainerScope::GetResultantFilterFlags(
    HWND hwndBaseDlg,
    ULONG *pulFlags) const
{
    TRACE_METHOD(CLdapContainerScope, GetResultantFilterFlags);

    HRESULT hr = S_OK;
    const CScopeManager &rsm = m_rop.GetScopeManager();
    const SScopeParameters *psp = rsm.GetScopeParams(m_Type);

    ASSERT(m_Type == ST_LDAP_CONTAINER ||
           m_Type == ST_USER_ENTERED_UPLEVEL_SCOPE);
    ASSERT(m_Type == ST_LDAP_CONTAINER && !psp ||
           m_Type == ST_USER_ENTERED_UPLEVEL_SCOPE && psp);
    ASSERT(m_Type == ST_LDAP_CONTAINER && m_pParent ||
           m_Type == ST_USER_ENTERED_UPLEVEL_SCOPE && !m_pParent);
    ASSERT(pulFlags);

    //
    // This scope should either be an OU or a ST_USER_ENTERED_UPLEVEL_SCOPE.
    //
    // If it is an OU, recursively delegate to its parent until an
    // ldap domain scope is reached, which knows how to return flags for
    // itself.
    //
    // If it is a ST_USER_ENTERED_UPLEVEL_SCOPE, return the flags contained
    // in the scope parameters.
    //

    do
    {
        if (m_Type == ST_LDAP_CONTAINER)
        {
            if (!m_pParent)
            {
                break;
            }

            const CAdsiScope *pAdsiParent = dynamic_cast<const CAdsiScope *>(m_pParent);
            ASSERT(pAdsiParent);

            if (!pAdsiParent)
            {
                break;
            }

            hr = pAdsiParent->GetResultantFilterFlags(hwndBaseDlg, pulFlags);
            CHECK_HRESULT(hr);
            break;
        }

        // m_Type == ST_USER_ENTERED_UPLEVEL_SCOPE

        if (m_DomainMode == DM_UNDETERMINED)
        {
            hr = _DetermineDomainMode(hwndBaseDlg,
                                      m_strDisplayName,
                                      &m_DomainMode);
            BREAK_ON_FAIL_HRESULT(hr);
        }

        *pulFlags = psp->FilterFlags.Uplevel.flBothModes;

        if (m_DomainMode == DM_NATIVE)
        {
            *pulFlags |= psp->FilterFlags.Uplevel.flNativeModeOnly;
        }
        else
        {
            *pulFlags |= psp->FilterFlags.Uplevel.flMixedModeOnly;
        }
    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CTargetComputerScope::CTargetComputerScope
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - containing object picker instance
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CTargetComputerScope::CTargetComputerScope(
    const CObjectPicker &rop):
        CWinNtScope(ST_TARGET_COMPUTER, rop)
{
    TRACE_CONSTRUCTOR(CTargetComputerScope);

    m_strDisplayName = rop.GetTargetComputer();
    m_strADsPath = c_wzWinNTPrefix + m_strDisplayName + L",Computer";
}




//+--------------------------------------------------------------------------
//
//  Member:     CWorkgroupScope::GetADsPath
//
//  Synopsis:   Fill *[pstrPath] with the ADsPath of the workgroup
//
//  Arguments:  [hwnd]     - unused
//              [pstrPath] - filled with path of workgroup
//
//  Returns:    S_OK   - path valid
//              E_FAIL - path empty
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CWorkgroupScope::GetADsPath(
    HWND hwnd,
    String *pstrPath) const
{
    TRACE_METHOD(CWorkgroupScope, GetADsPath);

    if (!m_fInitialized)
    {
        CWorkgroupScope *pNonConstThis = const_cast<CWorkgroupScope *>(this);
        pNonConstThis->_Initialize();
    }
    *pstrPath = m_strADsPath;
    return m_strADsPath.empty() ? E_FAIL : S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWorkgroupScope::GetDisplayName
//
//  Synopsis:   Return the display name of this workgroup
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const String&
CWorkgroupScope::GetDisplayName() const
{
    TRACE_METHOD(CWorkgroupScope, GetDisplayName);

    if (!m_fInitialized)
    {
        CWorkgroupScope *pNonConstThis = const_cast<CWorkgroupScope *>(this);
        pNonConstThis->_Initialize();
    }
    return m_strDisplayName;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWorkgroupScope::_Initialize
//
//  Synopsis:   Initialize the workgroup scope by determining which
//              workgroup the target machine is in
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CWorkgroupScope::_Initialize()
{
    TRACE_METHOD(CWorkgroupScope, _Initialize);
    ASSERT(m_rop.GetTargetComputerConfig() == MC_IN_WORKGROUP);
    ASSERT(!m_fInitialized);

    HRESULT                     hr = S_OK;
    NTSTATUS                    nts = STATUS_SUCCESS;
    LSA_HANDLE                  hlsaServer = NULL;
    POLICY_ACCOUNT_DOMAIN_INFO *pAccountDomainInfo = NULL;
    POLICY_PRIMARY_DOMAIN_INFO *pPrimaryDomainInfo = NULL;

    do
    {
        hr = GetLsaAccountDomainInfo(m_rop.GetTargetComputer().c_str(),
                                     &hlsaServer,
                                     &pAccountDomainInfo);

        if (!hlsaServer)
        {
            DBG_OUT_HRESULT(hr);
            ASSERT(FAILED(hr));
            break;
        }

        //
        // Get the server's primary domain (or workgroup) and add it to the
        // scope
        //

        nts = LsaQueryInformationPolicy(hlsaServer,
                                        PolicyPrimaryDomainInformation,
                                        (LPVOID *)&pPrimaryDomainInfo);
        BREAK_ON_FAIL_NTSTATUS(nts);

        WCHAR wzPrimaryDomain[MAX_PATH];

        UnicodeStringToWsz(pPrimaryDomainInfo->Name,
                           wzPrimaryDomain,
                           ARRAYLEN(wzPrimaryDomain));

        m_strDisplayName = wzPrimaryDomain;
        m_strADsPath = c_wzWinNTPrefix;
        m_strADsPath += wzPrimaryDomain;
        //This is Just a hint in the path. This hint will not be
        //used in the path to bind.
        m_strADsPath += L",Workgroup";

        Dbg(DEB_TRACE, "Target machine is in workgroup '%ws'\n", wzPrimaryDomain);
        ASSERT(!pPrimaryDomainInfo->Sid);
    }
    while (0);

    if (pAccountDomainInfo)
    {
        LsaFreeMemory(pAccountDomainInfo);
    }

    if (pPrimaryDomainInfo)
    {
        LsaFreeMemory(pPrimaryDomainInfo);
    }

    if (hlsaServer)
    {
        LsaClose(hlsaServer);
    }

    m_fInitialized = TRUE;
}



//+--------------------------------------------------------------------------
//
//  Member:     CGcScope::CGcScope
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - containing instance of object picker
//
//  History:    06-01-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

CGcScope::CGcScope(
    const CObjectPicker &rop):
        CLdapContainerScope(ST_GLOBAL_CATALOG, rop, NULL)
{
    TRACE_CONSTRUCTOR(CGcScope);

    m_strDisplayName = String::load(IDS_DIRECTORY);
    m_strADsPath = c_wzGC;
    m_strADsPath += L"//";
    m_strADsPath += m_rop.GetTargetForest();
    WCHAR wzPort[20];
    wsprintf(wzPort, L":%u", LDAP_GC_PORT);
    m_strADsPath += wzPort;
}




//+--------------------------------------------------------------------------
//
//  Member:     CGcScope::Clone
//
//  Synopsis:   Copy all but m_rop from [rgc].
//
//  Arguments:  [rgc] - instance to copy
//
//  History:    06-01-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CGcScope::Clone(
    const CGcScope &rgc)
{
#if 0
    TRACE_METHOD(CGcScope, Clone);

    m_DomainMode = rgc.m_DomainMode;
    m_strADsPath = rgc.m_strADsPath;
    // leave m_pParent NULL, GC scopes are always root scopes

    vector<RpScope>::const_iterator itChildBegin;
    vector<RpScope>::const_iterator itChildEnd;

    GetChildScopeIterators(&itChildBegin, &itChildEnd);

    vector<RpScope>::const_iterator itChild;

    for (itChild = itChildBegin;
         itChild != itChildEnd;
         itChild++)
    {
        CopyScopeTree(m_rop, itChild->get(), this, NULL);
    }
#endif
}




//+--------------------------------------------------------------------------
//
//  Member:     CGcScope::GetResultantFilterFlags
//
//  Synopsis:   Return the filter flags that apply to the GC scope.
//
//  Arguments:  [hwndBaseDlg] - unused
//              [pulFlags]    - points to variable filled with uplevel
//                              filter flags
//
//  Returns:    S_OK
//
//  History:    05-10-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CGcScope::GetResultantFilterFlags(
    HWND hwndBaseDlg,
    ULONG *pulFlags) const
{
    TRACE_METHOD(CGcScope, GetResultantFilterFlags);
    ASSERT(m_Type == ST_GLOBAL_CATALOG);

    const CScopeManager &rsm = m_rop.GetScopeManager();
    const SScopeParameters *psp = rsm.GetScopeParams(m_Type);

    ASSERT(psp);
    ASSERT(pulFlags);

    if (!pulFlags)
    {
        DBG_OUT_HRESULT(E_POINTER);
        return E_POINTER;
    }

    *pulFlags = 0;

    if (psp)
    {
        *pulFlags = psp->FilterFlags.Uplevel.flBothModes |
                    psp->FilterFlags.Uplevel.flNativeModeOnly;
    }

    if (m_rop.GetExternalCustomizer())
    {
        *pulFlags |= DSOP_FILTER_EXTERNAL_CUSTOMIZER;
    }
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CGcScope::Expand
//
//  Synopsis:   Fill *[pitBeginNew] and *[pitEndNew] with iterators at the
//              beginning and end of the child scopes of this.
//
//  Arguments:  [hwndDlg]     - for bind
//              [pitBeginNew] - filled with iterator at first child
//              [pitEndNew]   - filled with iterator at last child
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CGcScope::Expand(
    HWND hwndDlg,
    vector<RpScope>::const_iterator *pitBeginNew,
    vector<RpScope>::const_iterator *pitEndNew) const
{
    TRACE_METHOD(CGcScope, Expand);

    //
    // This operation never results in new children; the only children
    // allowed under the GC scope are enterprise domains, which have already
    // been added.
    //

    *pitBeginNew = m_vrpChildren.begin();
    *pitEndNew = m_vrpChildren.begin();
    m_fExpanded = TRUE;
}




//+--------------------------------------------------------------------------
//
//  Member:     CGcScope::GetADsPath
//
//  Synopsis:   Fill *[pstrPath] with the ADsPath of the Global Catalog
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CGcScope::GetADsPath(
    HWND hwnd,
    String *pstrPath) const
{
    *pstrPath = m_strADsPath;
    return S_OK;
}




//+--------------------------------------------------------------------------
//
//  Member:     CGcScope::GetADsPath
//
//  Synopsis:   Fill *[pstrPath] with the ADsPath of the Global Catalog
//
//  Arguments:  [ppwzADsPath] - filled with GC path
//
//  Returns:    HRESULT
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

STDMETHODIMP
CGcScope::GetADsPath(
    PWSTR *ppwzADsPath)
{
    ASSERT(ppwzADsPath);
    HRESULT hr = S_OK;

    if (!m_strADsPath.empty())
    {
        hr = m_strADsPath.as_OLESTR(*ppwzADsPath);
    }
    else
    {
        *ppwzADsPath = NULL;
        hr = E_FAIL;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWinNtScope::CWinNtScope
//
//  Synopsis:   ctor
//
//  Arguments:  [rop] - owning object picker instance
//              [asi] - intialization information
//
//  History:    03-15-2000   davidmun   Created
//
//  Notes:      This class is used for both NT4 domains discovered via
//              domain enumeration and for scopes created during name
//              resolution that have the type
//              DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE.
//
//---------------------------------------------------------------------------

CWinNtDomainScope::CWinNtDomainScope(
    const CObjectPicker &rop,
    const ADD_SCOPE_INFO &asi):
        CWinNtScope((SCOPE_TYPE)asi.flType, rop)
{
    TRACE_CONSTRUCTOR(CWinNtDomainScope);

    m_strDisplayName = asi.Domain.strScopeName;
    m_strADsPath = asi.Domain.strADsPath;
}




//+--------------------------------------------------------------------------
//
//  Member:     CWinNtScope::GetResultantFilterFlags
//
//  Synopsis:   Return the filter flags which are valid for this scope
//
//  Arguments:  [hwndBaseDlg] - unused
//              [pulFlags]    - points to variable to be filled with flags
//
//  Returns:    S_OK
//
//  History:    05-10-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CWinNtScope::GetResultantFilterFlags(
    HWND hwndBaseDlg,
    ULONG *pulFlags) const
{
    TRACE_METHOD(CWinNtScope, GetResultantFilterFlags);

    const CScopeManager &rsm = m_rop.GetScopeManager();
    const SScopeParameters *psp = rsm.GetScopeParams(m_Type);

    //
    // If target computer is joined to an NT4 domain, and this scope
    // represents that domain, then the type of this scope is
    // DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN.
    //
    // However, if no scope initializer with that scope type was specified
    // by caller, and caller did supply the scope initializer for
    // ST_ENTERPRISE_DOMAIN, use that.  This parallels the logic in
    // CScopeManager::_InitScopesJoinedNt4().
    //

    if (!psp)
    {
        psp = rsm.GetScopeParams(ST_ENTERPRISE_DOMAIN);
    }

    ASSERT(psp);
    ASSERT(pulFlags);

    if (!pulFlags)
    {
        DBG_OUT_HRESULT(E_POINTER);
        return E_POINTER;
    }

    *pulFlags = 0;

    if (psp)
    {
        *pulFlags = psp->FilterFlags.flDownlevel;

        if (m_Type == ST_TARGET_COMPUTER)
        {
            ULONG flComputerBit = DSOP_DOWNLEVEL_FILTER_COMPUTERS &
                                    ~DOWNLEVEL_FILTER_BIT;
            *pulFlags &= ~flComputerBit;
            ASSERT(*pulFlags & ~DOWNLEVEL_FILTER_BIT);
        }
        else if (m_Type == ST_WORKGROUP)
        {
            *pulFlags &= DSOP_DOWNLEVEL_FILTER_COMPUTERS;
            ASSERT(*pulFlags);
        }
    }

    if (m_rop.GetExternalCustomizer())
    {
        *pulFlags |= DSOP_DOWNLEVEL_FILTER_EXTERNAL_CUSTOMIZER;
    }

    return S_OK;
}



//+--------------------------------------------------------------------------
//
//  Function:   IsUplevel
//
//  Synopsis:   Return TRUE if [Type] is an uplevel scope type, FALSE
//              otherwise.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
IsUplevel(
    SCOPE_TYPE Type)
{
    switch (Type)
    {
    case ST_ENTERPRISE_DOMAIN:
    case ST_GLOBAL_CATALOG:
    case ST_UPLEVEL_JOINED_DOMAIN:
    case ST_EXTERNAL_UPLEVEL_DOMAIN:
    case ST_USER_ENTERED_UPLEVEL_SCOPE:
    case ST_LDAP_CONTAINER:
        return TRUE;

    default:
        return FALSE;
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   IsDownlevel
//
//  Synopsis:   Return TRUE if [Type] is a downlevel scope type, FALSE
//              otherwise.
//
//  History:    06-22-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
IsDownlevel(
    SCOPE_TYPE Type)
{
    switch (Type)
    {
    case ST_TARGET_COMPUTER:
    case ST_DOWNLEVEL_JOINED_DOMAIN:
    case ST_EXTERNAL_DOWNLEVEL_DOMAIN:
    case ST_WORKGROUP:
    case ST_USER_ENTERED_DOWNLEVEL_SCOPE:
        return TRUE;

    default:
        return FALSE;
    }
}



//
// Legacy methods (addref and release are used by both legacy and current
// implementation).
//

STDMETHODIMP_(HWND)
CScope::GetHwnd()
{
    TRACE_METHOD(CScope, GetHwnd);
    Dbg(DEB_WARN, "Warning: using legacy method\n");
    return NULL;
}

STDMETHODIMP
CScope::SetHwnd(
    HWND hwndScopeDialog)
{
    TRACE_METHOD(CScope, SetHwnd);
    Dbg(DEB_WARN, "Warning: using legacy method\n");
    return E_NOTIMPL;
}

STDMETHODIMP_(ULONG)
CScope::GetType()
{
    TRACE_METHOD(CScope, GetType);
    return static_cast<ULONG>(Type());
}

STDMETHODIMP
CScope::GetQueryInfo(
    PDSQUERYINFO *ppqi)
{
    TRACE_METHOD(CScope, GetQueryInfo);
    Dbg(DEB_WARN, "Warning: using legacy method\n");
    return E_NOTIMPL;
}

STDMETHODIMP_(BOOL)
CScope::IsUplevel()
{
    TRACE_METHOD(CScope, IsUplevel);
    return ::IsUplevel(m_Type);
}

STDMETHODIMP_(BOOL)
CScope::IsDownlevel()
{
    TRACE_METHOD(CScope, IsDownlevel);
    return ::IsDownlevel(m_Type);
}

STDMETHODIMP_(BOOL)
CScope::IsExternalDomain()
{
    TRACE_METHOD(CScope, IsExternalDomain);
    return m_Type == ST_EXTERNAL_DOWNLEVEL_DOMAIN ||
           m_Type == ST_EXTERNAL_UPLEVEL_DOMAIN;
}

STDMETHODIMP
CScope::GetADsPath(
    PWSTR *ppwzADsPath)
{
    TRACE_METHOD(CScope, GetADsPath(legacy));

    if (!ppwzADsPath)
    {
        return E_POINTER;
    }

    CAdsiScope *pAdsi = dynamic_cast<CAdsiScope *>(this);

    if (pAdsi)
    {
        String strPath;
        pAdsi->GetADsPath(NULL, &strPath);
        return strPath.as_OLESTR(*ppwzADsPath);
    }
    return E_UNEXPECTED;
}

STDMETHODIMP_(ULONG)
CScope::AddRef()
{
    return InterlockedIncrement((LONG*)&m_cRefs);
}

STDMETHODIMP_(ULONG)
CScope::Release()
{
    ULONG cRefs = InterlockedDecrement((LONG*)&m_cRefs);

    if (!cRefs)
    {
        delete this;
    }
    return cRefs;
}


STDMETHODIMP
CScope::QueryInterface(
    REFIID riid,
    LPVOID * ppv)
{
    TRACE_METHOD(CScope, QueryInterface);
    Dbg(DEB_WARN, "Warning: using legacy method\n");

    *ppv = NULL;
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\scopemanager.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       scopemgr.cxx
//
//  Contents:   Implementation of scope manager and related classes
//
//  Classes:    CScopeManager
//              SScopeParameters
//
//  History:    01-25-2000   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


//+--------------------------------------------------------------------------
//
//  Class:      CDomainInfo (di)
//
//  Purpose:    Used to represent data elements returned by
//              DsEnumerateDomainTrusts.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

class CDomainInfo
{
public:

    CDomainInfo(): fAddedToParentsChildList(FALSE) {}

    list<CDomainInfo *> lpdiChildren;
    BOOL                fAddedToParentsChildList;
};

typedef list<CDomainInfo *> DomainInfoList;

//
// Forward references
//

inline BOOL
IsNonRootDomainInForest(
    PDS_DOMAIN_TRUSTS ptd);


void
GetContactAndAdvancedFilterSettings(
    DSOP_UPLEVEL_FILTER_FLAGS   Uplevel,
    BOOL fIsGc,
    BOOL *pfContactsYes,
    BOOL *pfContactsNo,
    BOOL *pfAdvancedYes,
    BOOL *pfAdvancedNo);




//+--------------------------------------------------------------------------
//
//  Member:     SScopeParameters::SScopeParameters
//
//  Synopsis:   ctor
//
//  Arguments:  [sii]           - caller's original parameter
//              [flLegalScopes] - mask indicating which of the scopes the
//                                 caller lists in [sii.flType] are valid
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

SScopeParameters::SScopeParameters(
    const DSOP_SCOPE_INIT_INFO &sii,
    ULONG flLegalScopes)
{
    flType = sii.flType & flLegalScopes;
    flScope = sii.flScope;
    FilterFlags = sii.FilterFlags;

    //
    // If the caller's init info structure contains the
    // DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS flag, it
    // represents all the downlevel group flags, so change it
    // into those flags in the private copy.
    //

    if ((FilterFlags.flDownlevel &
         DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS) ==
        DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS)
    {
        //
        // Turn off the DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS
        // flag in the private copy.  Note this momentarily
        // breaks flDownlevel by turning off the
        // DSOP_DOWNLEVEL_FILTER_BIT, but we're about to add
        // that back in.
        //

        FilterFlags.flDownlevel &= ~DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS;

        //
        // Add in all the builtin group flags.
        //

        FilterFlags.flDownlevel |= ALL_DOWNLEVEL_INTERNAL_CUSTOMIZER_FILTERS;
    }

    if (sii.pwzDcName)
    {
        strDcName = sii.pwzDcName;
        strDcName.strip(String::LEADING, L'\\');
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   IsInitInfoForStartingScope
//
//  Synopsis:   Returns TRUE if [ScopeInfo] contains the
//              DSOP_SCOPE_FLAG_STARTING_SCOPE flag.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

inline BOOL
IsInitInfoForStartingScope(const DSOP_SCOPE_INIT_INFO &ScopeInfo)
{
    return 0 != (ScopeInfo.flScope & DSOP_SCOPE_FLAG_STARTING_SCOPE);
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::Clear
//
//  Synopsis:   Reset internal state.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CScopeManager::Clear()
{
    TRACE_METHOD(CScopeManager, Clear);

    if (m_hScopeImageList)
    {
        ImageList_RemoveAll(m_hScopeImageList);
    }
    m_vrpRootScopes.clear();
    m_vScopeParameters.clear();
    m_StartingScopeType = ST_INVALID;
    m_rpStartingScope.Relinquish();
    m_rpCurScope.Relinquish();
    m_strContainerFilter.erase();
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::Initialize
//
//  Synopsis:   Process all the scope flags and related information in
//              [pInitInfo].
//
//  Arguments:  [pInitInfo] - points to scope initialization info
//
//  Returns:    HRESULT
//
//  History:    06-23-2000   DavidMun   Created
//
//  Notes:      If this routine returns a failure the OP dialog will not
//              open.
//
//---------------------------------------------------------------------------

HRESULT
CScopeManager::Initialize(
    PCDSOP_INIT_INFO pInitInfo)
{
    TRACE_METHOD(CScopeManager, Initialize);
    ASSERT(pInitInfo);

    HRESULT         hr = S_OK;
    MACHINE_CONFIG  mc = MC_UNKNOWN;

    do
    {
        //
        // Clear any data from previous initialization/use
        //

        if (!m_hScopeImageList)
        {
            m_hScopeImageList =
                ImageList_Create(16, 16, ILC_COLOR16 | ILC_MASK, 1, 1);
        }

        //
        // Caller must request at least one type of scope
        //

        if (!pInitInfo->cDsScopeInfos)
        {
            hr = E_INVALIDARG;
            Dbg(DEB_ERROR, "Error: scope count is 0\n");
            PopupMessage(GetForegroundWindow(), IDS_INIT_FAILED_BAD_ARGS);
            break;
        }

        //
        // Determine the target computer's configuration: no-net, standalone,
        // domain member, etc.
        //

        mc = m_rop.GetTargetComputerConfig();

        //
        // Make a mask of the scope types that are valid for the target
        // computer's configuration.
        //

        ULONG flLegalScopes = 0;

        switch (mc)
        {
        case MC_NO_NETWORK:
            flLegalScopes = DSOP_SCOPE_TYPE_TARGET_COMPUTER;
            break;

        case MC_IN_WORKGROUP:
            flLegalScopes = DSOP_SCOPE_TYPE_TARGET_COMPUTER
                                 | DSOP_SCOPE_TYPE_WORKGROUP
                                 | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                                 | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
            break;

        case MC_NT4_DC:
            if (!(m_rop.GetInitInfoOptions() &
                  DSOP_FLAG_SKIP_TARGET_COMPUTER_DC_CHECK))
            {
                flLegalScopes = DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN
                                     | DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                                     | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                                     | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                                     | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                                     | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
                break;
            }
            // else FALL THROUGH

        case MC_JOINED_NT4:
            flLegalScopes = DSOP_SCOPE_TYPE_TARGET_COMPUTER
                                 | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN
                                 | DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                                 | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                                 | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                                 | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                                 | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
            break;

        case MC_NT5_DC:
            if (!(m_rop.GetInitInfoOptions() &
                  DSOP_FLAG_SKIP_TARGET_COMPUTER_DC_CHECK))
            {
                flLegalScopes = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                                     | DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                                     | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                                     | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                                     | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                                     | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                                     | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
                break;
            }
            // else FALL THROUGH

        case MC_JOINED_NT5:
            flLegalScopes = DSOP_SCOPE_TYPE_TARGET_COMPUTER
                                 | DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                                 | DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                                 | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                                 | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
                                 | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
                                 | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                                 | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;
            break;

        default:
            Dbg(DEB_ERROR,
                "Invalid target computer configuration const %uL\n",
                mc);
            ASSERT(0 && "invalid target computer configuration const");
            break;
        }

        //
        // Loop through the caller's scope initializers and make a private
        // copy of those which are meaningful for the target computer
        // configuration.
        //
        // At the same time, set pointers to the private copies of scope
        // initializers.  These will be passed to the individual scope
        // objects; they'll use them to determine what their settings are.
        //

        m_vScopeParameters.reserve(pInitInfo->cDsScopeInfos);

        PDSOP_SCOPE_INIT_INFO psiiCur = NULL;
        PDSOP_SCOPE_INIT_INFO psiiGc = NULL;
        PDSOP_SCOPE_INIT_INFO psiiUplevelJoinedDomain = NULL;
        ULONG i;

        for (i = 0; i < pInitInfo->cDsScopeInfos; i++)
        {
            psiiCur = &pInitInfo->aDsScopeInfos[i];
            psiiCur->hr = S_OK;

            //
            // Skip this scope init struct if none of the scope types it
            // specifies apply given the target machine configuration.
            //

            if (!(psiiCur->flType & flLegalScopes))
            {
                psiiCur->hr = S_FALSE;
                continue;
            }

            //
            // Check the filter flags specified for the scope.  If they're
            // invalid, skip it.
            //

            psiiCur->hr = _ValidateFilterFlags(psiiCur,
                                               psiiCur->flType &
                                               flLegalScopes);

            if (FAILED(psiiCur->hr))
            {
                continue;
            }

            //
            // The scope initializer applies to the target computer's
            // configuration and has valid filter flags.  Make a copy.
            //

            SScopeParameters sp(*psiiCur, flLegalScopes);
            m_vScopeParameters.push_back(sp);

            if (sp.flType & DSOP_SCOPE_TYPE_GLOBAL_CATALOG)
            {
                psiiGc = psiiCur;
            }

            if (sp.flType & DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN)
            {
                psiiUplevelJoinedDomain = psiiCur;
            }

            //
            // Remember the type of the scope initializer marked as the
            // starting scope.
            //

            if (IsInitInfoForStartingScope(*psiiCur))
            {
                m_StartingScopeType = static_cast<SCOPE_TYPE>(psiiCur->flType & flLegalScopes);
            }

        }
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // If no scope initializer was marked valid, we have no
        // scopes and cannot open.
        //

        if (m_vScopeParameters.empty())
        {
            PopupMessage(GetForegroundWindow(), IDS_INIT_FAILED_NO_SCOPES);
            hr = E_INVALIDARG;
            break;
        }

        //
        // One last check: if the GC and uplevel joined domain scopes
        // are both supplied, they must have the same settings for
        // contacts and advanced view.
        //

        if (psiiGc && psiiUplevelJoinedDomain)
        {
            BOOL fJoinedContactsYes = FALSE;
            BOOL fJoinedContactsNo  = FALSE;
            BOOL fJoinedAdvancedYes = FALSE;
            BOOL fJoinedAdvancedNo  = FALSE;

            BOOL fGcContactsYes = FALSE;
            BOOL fGcContactsNo  = FALSE;
            BOOL fGcAdvancedYes = FALSE;
            BOOL fGcAdvancedNo  = FALSE;

            GetContactAndAdvancedFilterSettings(
                psiiUplevelJoinedDomain->FilterFlags.Uplevel,
                FALSE,
                &fJoinedContactsYes,
                &fJoinedContactsNo,
                &fJoinedAdvancedYes,
                &fJoinedAdvancedNo);

            GetContactAndAdvancedFilterSettings(
                psiiGc->FilterFlags.Uplevel,
                TRUE,
                &fGcContactsYes,
                &fGcContactsNo,
                &fGcAdvancedYes,
                &fGcAdvancedNo);

            if (fJoinedContactsYes && fGcContactsNo  ||
                fJoinedContactsNo  && fGcContactsYes ||
                fJoinedAdvancedYes && fGcAdvancedNo  ||
                fJoinedAdvancedNo  && fGcAdvancedYes)
            {
                hr = E_INVALIDARG;
                psiiGc->hr = hr;
                psiiUplevelJoinedDomain->hr = hr;
                DBG_OUT_HRESULT(hr);
                PopupMessage(GetForegroundWindow(),
                             IDS_INIT_FAILED_BAD_ARGS);
                break;
            }
        }

        //
        // There is at least one usable scope initializer.
        //
        // Scope objects are hierarchical and should be added in a particular
        // order.
        //

        if (GetScopeParams(ST_TARGET_COMPUTER))
        {
            RpScope rps;

            rps.Acquire(new CTargetComputerScope(m_rop));
            m_vrpRootScopes.push_back(rps);

            if (m_StartingScopeType == ST_TARGET_COMPUTER &&
                !m_rpStartingScope.get())
            {
                m_rpStartingScope = rps;
            }
        }

        if (GetScopeParams(ST_WORKGROUP))
        {
            RpScope rps;
            rps.Acquire(new CWorkgroupScope(m_rop));
            m_vrpRootScopes.push_back(rps);

            if (m_StartingScopeType == ST_WORKGROUP &&
                !m_rpStartingScope.get())
            {
                m_rpStartingScope = rps;
            }
        }

        RpScope rpScopeGc;

        if (GetScopeParams(ST_GLOBAL_CATALOG))
        {
            rpScopeGc.Acquire(new CGcScope(m_rop));

            m_vrpRootScopes.push_back(rpScopeGc);

            if (m_StartingScopeType == ST_GLOBAL_CATALOG &&
                !m_rpStartingScope.get())
            {
                m_rpStartingScope = rpScopeGc;
            }
        }

        if (mc == MC_JOINED_NT5 || mc == MC_NT5_DC)
        {
            if (GetScopeParams(ST_UPLEVEL_JOINED_DOMAIN)
                || GetScopeParams(ST_ENTERPRISE_DOMAIN)
                || GetScopeParams(ST_EXTERNAL_UPLEVEL_DOMAIN)
                || GetScopeParams(ST_EXTERNAL_DOWNLEVEL_DOMAIN))
            {
                _InitDomainScopesJoinedNt5((CGcScope*)rpScopeGc.get());
            }
        }
        else if (mc == MC_JOINED_NT4 || mc == MC_NT4_DC)
        {
            _InitScopesJoinedNt4();
        }

        //
        // At this point if there are no root scopes, then none of the
        // legal scopes specified by the caller could be added, and we
        // must fail.
        //

        if (m_vrpRootScopes.empty())
        {
            PopupMessage(GetForegroundWindow(), IDS_INIT_FAILED_NO_SCOPES);
            hr = E_INVALIDARG;
            break;
        }

        if (m_rpStartingScope.get())
        {
            m_rpCurScope = m_rpStartingScope;
        }
        else
        {
            m_rpCurScope = m_vrpRootScopes[0];
        }
    }
    while (0);
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::_InitContainerFilter
//
//  Synopsis:   Construct the LDAP filter to use when searching for
//              containers beneath domainDns objects.
//
//  Arguments:  [hwnd] - for bind
//
//  History:    06-19-2000   DavidMun   Created
//
//  Notes:      See CScope::Expand().
//
//---------------------------------------------------------------------------

void
CScopeManager::_InitContainerFilter(
    HWND hwnd) const
{
    TRACE_METHOD(CScopeManager, _InitContainerFilter);
    ASSERT(m_strContainerFilter.empty());
    ASSERT(IsWindow(hwnd));

    HRESULT hr = S_OK;

    do
    {
        RpIADsContainer rpContainer;
        const CRootDSE &dse = m_rop.GetRootDSE();

        hr = dse.BindToDisplaySpecifiersContainer(hwnd,
                                                  IID_IADsContainer,
                                                  reinterpret_cast<void**>(&rpContainer));
        BREAK_ON_FAIL_HRESULT(hr);

        RpIDispatch rpDispatch;

        hr = rpContainer->GetObject(const_cast<PWSTR>(c_wzSettingsObjectClass),
                                    const_cast<PWSTR>(c_wzSettingsObject),
                                    &rpDispatch);
        BREAK_ON_FAIL_HRESULT(hr);

        RpIADs rpADs;

        hr = rpDispatch->QueryInterface(IID_IADs, reinterpret_cast<void**>(&rpADs));
        BREAK_ON_FAIL_HRESULT(hr);

        Variant var;

        hr = rpADs->Get(const_cast<PWSTR>(c_wzFilterContainers), &var);
        BREAK_ON_FAIL_HRESULT(hr);

        if (var.Type() == VT_BSTR)
        {
            m_strContainerFilter = L"(objectCategory=" +
                                        String(var.GetBstr()) +
                                   L")";
            break;
        }

        ASSERT(var.Type() == (VT_ARRAY | VT_VARIANT));

        if (var.Type() != (VT_ARRAY | VT_VARIANT))
        {
            break;
        }

        SAFEARRAY *saAttributes = V_ARRAY(&var);

        //
        // Figure out the dimensions of the array.
        //

        LONG lStart;
        LONG lEnd;

        hr = SafeArrayGetLBound(saAttributes, 1, &lStart);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = SafeArrayGetUBound(saAttributes, 1, &lEnd);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Process the array elements.
        //

        LONG lCurrent;
        ULONG cAdded = 0;
        String strSchemaNc = m_rop.GetRootDSE().GetSchemaNc(hwnd);

        for (lCurrent = lStart; lCurrent <= lEnd; lCurrent++)
        {
            Variant varElement;

            hr = SafeArrayGetElement( saAttributes, &lCurrent, &varElement);

            if (FAILED(hr))
            {
                DBG_OUT_HRESULT(hr);
                continue;
            }

            ASSERT(varElement.Type() == VT_BSTR);

            if (varElement.Type() != VT_BSTR)
            {
                continue;
            }

            m_strContainerFilter += L"(objectCategory=CN=" +
                                         String(varElement.GetBstr()) +
                                         L"," +
                                         strSchemaNc +
                                    L")";
            cAdded++;
        }

        if (cAdded > 1)
        {
            m_strContainerFilter.insert(0, L"(|");
            m_strContainerFilter += L")";
        }
    } while (0);

    if (m_strContainerFilter.empty())
    {
        m_strContainerFilter = c_wzDefaultContainerFilter;
    }
}



const ULONG
c_ulDnPickerScopeFlagsTurnedOff =
    DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT
    | DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP
    | DSOP_SCOPE_FLAG_WANT_PROVIDER_GC
    | DSOP_SCOPE_FLAG_WANT_SID_PATH
    | DSOP_SCOPE_FLAG_WANT_DOWNLEVEL_BUILTIN_PATH;

const ULONG
c_ulDnPickerFilterFlagsTurnedOn =
    DSOP_FILTER_INCLUDE_ADVANCED_VIEW
    | DSOP_FILTER_USERS
    | DSOP_FILTER_BUILTIN_GROUPS
    | DSOP_FILTER_WELL_KNOWN_PRINCIPALS
    | DSOP_FILTER_UNIVERSAL_GROUPS_DL
    | DSOP_FILTER_UNIVERSAL_GROUPS_SE
    | DSOP_FILTER_GLOBAL_GROUPS_DL
    | DSOP_FILTER_GLOBAL_GROUPS_SE
    | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL
    | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE
    | DSOP_FILTER_CONTACTS
    | DSOP_FILTER_COMPUTERS;

//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::CloneForDnPicker
//
//  Synopsis:   Initialize this from the already initialized instance [rsm],
//              modifying this so that it contains scopes, flags, and types
//              suitable for use as the DN picker.
//
//  Arguments:  [rsm] - reference to initialized scope manager
//
//  History:    06-01-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CScopeManager::CloneForDnPicker(
    const CScopeManager &rsm)
{
    TRACE_METHOD(CScopeManager, CloneForDnPicker);

    //
    // Copy all uplevel scope trees from rsm
    //

    vector<RpScope>::iterator itScope;

    for (itScope = rsm.m_vrpRootScopes.begin();
         itScope != rsm.m_vrpRootScopes.end();
         itScope++)
    {
#if 0
        if (IsUplevel(itScope->get()))
        {
            CopyScopeTree(m_rop, itScope->get(), NULL, );
        }
#endif
    }

    //
    // Copy the scope parameters, modifying as appropriate for the
    // Dn picker.
    //

    m_vScopeParameters = rsm.m_vScopeParameters;
    vector<SScopeParameters>::iterator itParams;

    for (itParams = m_vScopeParameters.begin();
         itParams != m_vScopeParameters.end();
         itParams++)
    {
        //
        // Turn off scope flags that don't apply to DN picker
        // (e.g. provider conversion)
        //

        itParams->flScope &= ~c_ulDnPickerScopeFlagsTurnedOff;

        //
        // Ensure that the uplevel filter flags include all the standard
        // object picker types.
        //

        itParams->FilterFlags.Uplevel.flBothModes |=
            c_ulDnPickerFilterFlagsTurnedOn;
    }

    //
    // Ensure that this instance has Entire Directory and Enterprise
    // Domain scopes.
    //


}




//+--------------------------------------------------------------------------
//
//  Function:   GetContactAndAdvancedFilterSettings
//
//  Synopsis:
//
//  Arguments:  [Uplevel]       - the flags to examine when setting the out
//                                  parameters
//              [fIsGc]         - TRUE if [Uplevel] flags are for GC
//              [pfContactsYes] - set to TRUE if filter flag for contact
//                                 objects is set in any part of [Uplevel]
//              [pfContactsNo]  - set to TRUE if filter flag for contact
//                                 objects is NOT set in any part of
//                                 [Uplevel]
//              [pfAdvancedYes] - set to TRUE if filter flag for including
//                                 objects marked as advanced view only is
//                                 set in any part of [Uplevel].
//              [pfAdvancedNo]  - set to TRUE if filter flag for including
//                                 objects marked as advanced view only is
//                                 NOT set in any part of [Uplevel].
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
GetContactAndAdvancedFilterSettings(
    DSOP_UPLEVEL_FILTER_FLAGS   Uplevel,
    BOOL fIsGc,
    BOOL *pfContactsYes,
    BOOL *pfContactsNo,
    BOOL *pfAdvancedYes,
    BOOL *pfAdvancedNo)
{
    ULONG flAllModes = Uplevel.flBothModes
        | Uplevel.flNativeModeOnly
        | Uplevel.flMixedModeOnly;

    if (flAllModes & DSOP_FILTER_CONTACTS)
    {
        *pfContactsYes = TRUE;

        if (Uplevel.flBothModes & DSOP_FILTER_CONTACTS)
        {
            *pfContactsNo = FALSE;
        }
        else if (!(Uplevel.flNativeModeOnly & DSOP_FILTER_CONTACTS))
        {
            *pfContactsNo = TRUE;
        }
        else if (!(Uplevel.flMixedModeOnly & DSOP_FILTER_CONTACTS))
        {
            // the GC ignores the mixed mode flags

            if (!fIsGc)
            {
                *pfContactsNo = TRUE;
            }
        }
        else
        {
            *pfContactsNo = FALSE;
        }
    }
    else
    {
        *pfContactsYes = FALSE;
        *pfContactsNo = TRUE;
    }


    if (flAllModes & DSOP_FILTER_INCLUDE_ADVANCED_VIEW)
    {
        *pfAdvancedYes = TRUE;

        if (Uplevel.flBothModes & DSOP_FILTER_INCLUDE_ADVANCED_VIEW)
        {
            *pfAdvancedNo = FALSE;
        }
        else if (!(Uplevel.flNativeModeOnly & DSOP_FILTER_INCLUDE_ADVANCED_VIEW))
        {
            *pfAdvancedNo = TRUE;
        }
        else if (!(Uplevel.flMixedModeOnly & DSOP_FILTER_INCLUDE_ADVANCED_VIEW))
        {
            // the GC ignores the mixed mode flags

            if (!fIsGc)
            {
                *pfAdvancedNo = TRUE;
            }
        }
        else
        {
            *pfAdvancedNo = FALSE;
        }
    }
    else
    {
        *pfAdvancedYes = FALSE;
        *pfAdvancedNo = TRUE;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::GetScopeParams
//
//  Synopsis:   Return a pointer to the scope parameter structure which
//              governs operation of scopes of type [Type], or NULL if none
//              is found.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const SScopeParameters *
CScopeManager::GetScopeParams(
    SCOPE_TYPE Type) const
{
    vector<SScopeParameters>::const_iterator it;

    for (it = m_vScopeParameters.begin(); it != m_vScopeParameters.end(); it++)
    {
        if (it->flType & Type)
        {
            return &*it;
        }
    }
    return NULL;
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::LookupScopeByDisplayName
//
//  Synopsis:   Return a reference to the scope which has name
//              [strDisplayName] in the UI.
//
//  Arguments:  [strDisplayName] - name to search for
//
//  Returns:    Reference to found scope, or to a scope with type ST_INVALID
//              if not found.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const CScope &
CScopeManager::LookupScopeByDisplayName(
    const String &strDisplayName) const
{
    return _LookupScopeByName(strDisplayName,
                              NAME_IS_DISPLAY_NAME,
                              m_vrpRootScopes.begin(),
                              m_vrpRootScopes.end());
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::LookupScopeByFlatName
//
//  Synopsis:   Return a reference to the scope which has netbios name
//              [strFlatName].
//
//  Arguments:  [strFlatName] - name to search for
//
//  Returns:    Reference to found scope, or to a scope with type ST_INVALID
//              if not found.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const CScope &
CScopeManager::LookupScopeByFlatName(
    const String &strFlatName) const
{
    return _LookupScopeByName(strFlatName,
                              NAME_IS_FLAT_NAME,
                              m_vrpRootScopes.begin(),
                              m_vrpRootScopes.end());
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::_LookupScopeByName
//
//  Synopsis:   Return a reference to the scope which has netbios or display
//              name  [strName].
//
//  Arguments:  [strName] - name to search for
//              [NameIs]  - NAME_IS_DISPLAY_NAME or NAME_IS_FLAT_NAME
//              [itBegin] - scope to start search
//              [itEnd]   - just past scope to end search
//
//  Returns:    Reference to found scope, or to a scope with type ST_INVALID
//              if not found.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const CScope &
CScopeManager::_LookupScopeByName(
    const String &strName,
    SCOPE_NAME_TYPE NameIs,
    vector<RpScope>::const_iterator itBegin,
    vector<RpScope>::const_iterator itEnd) const
{
    vector<RpScope>::const_iterator it;

    for (it = itBegin; it != itEnd; it++)
    {
        // disregard scopes which are not domains or computers

        if (it->get()->Type() == ST_WORKGROUP ||
            it->get()->Type() == ST_LDAP_CONTAINER)
        {
            continue;
        }

        if (it->get()->Type() == ST_GLOBAL_CATALOG)
        {
            // don't compare against GC itself, but do look at its children
        }
        else if (NameIs == NAME_IS_DISPLAY_NAME || IsDownlevel(it->get()->Type()))
        {
            if (!strName.icompare(it->get()->GetDisplayName()))
            {
                return *it->get();
            }
        }
        else if (it->get()->Type() == ST_USER_ENTERED_UPLEVEL_SCOPE)
        {
            CScope *pScope = it->get();
            const String &rstrDisplayName = pScope->GetDisplayName();

            if (!strName.icompare(rstrDisplayName))
            {
                return *it->get();
            }
        }
        else
        {
            ASSERT(it->get()->Type() == ST_EXTERNAL_UPLEVEL_DOMAIN ||
                it->get()->Type() == ST_UPLEVEL_JOINED_DOMAIN ||
                it->get()->Type() == ST_ENTERPRISE_DOMAIN);

            CScope *pScope = it->get();
            CLdapDomainScope *pDomainScope =
                dynamic_cast<CLdapDomainScope *>(pScope);

            ASSERT(pDomainScope);
            if (!pDomainScope)
            {
                continue;
            }

            if (!strName.icompare(pDomainScope->GetFlatName()))
            {
                return *it->get();
            }
        }


        if (it->get()->GetCurrentImmediateChildCount())
        {
            vector<RpScope>::const_iterator itChildBegin;
            vector<RpScope>::const_iterator itChildEnd;

            it->get()->GetChildScopeIterators(&itChildBegin, &itChildEnd);

            const CScope &rMatching = _LookupScopeByName(strName,
                                                         NameIs,
                                                         itChildBegin,
                                                         itChildEnd);

            if (rMatching.Type() != ST_INVALID)
            {
                return rMatching;
            }
        }
    }
    return *m_rpInvalidScope.get();
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::_LookupScopeByType
//
//  Synopsis:   Return a reference to the first scope found that has
//              scope type [Type].
//
//  Arguments:  [Type]    - type to search for
//              [itBegin] - scope to start search
//              [itEnd]   - just past scope to end search
//
//  Returns:    Reference to found scope, or to a scope with type ST_INVALID
//              if not found.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const CScope &
CScopeManager::_LookupScopeByType(
    SCOPE_TYPE Type,
    vector<RpScope>::const_iterator itBegin,
    vector<RpScope>::const_iterator itEnd) const
{
    vector<RpScope>::const_iterator it;

    for (it = itBegin; it != itEnd; it++)
    {
        if (it->get()->Type() == Type)
        {
            return *it->get();
        }

        if (it->get()->GetCurrentImmediateChildCount())
        {
            vector<RpScope>::const_iterator itChildBegin;
            vector<RpScope>::const_iterator itChildEnd;

            it->get()->GetChildScopeIterators(&itChildBegin, &itChildEnd);

            const CScope &rMatching = _LookupScopeByType(Type,
                                                         itChildBegin,
                                                         itChildEnd);

            if (rMatching.Type() != ST_INVALID)
            {
                return rMatching;
            }
        }
    }
    return *m_rpInvalidScope.get();
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::_LookupScopeById
//
//  Synopsis:   Return a reference to scope having id [id].
//
//  Arguments:  [id]      - id to search for
//              [itBegin] - scope to start search
//              [itEnd]   - just past scope to end search
//
//  Returns:    Reference to found scope, or to a scope with type ST_INVALID
//              if not found.
//
//  History:    06-23-2000   DavidMun   Created
//
//  Notes:      Every scope is given a unique id upon creation.
//
//---------------------------------------------------------------------------

const CScope &
CScopeManager::_LookupScopeById(
    ULONG id,
    vector<RpScope>::const_iterator itBegin,
    vector<RpScope>::const_iterator itEnd) const
{
    vector<RpScope>::const_iterator it;

    for (it = itBegin; it != itEnd; it++)
    {
        if (it->get()->GetID() == id)
        {
            return *it->get();
        }

        if (it->get()->GetCurrentImmediateChildCount())
        {
            vector<RpScope>::const_iterator itChildBegin;
            vector<RpScope>::const_iterator itChildEnd;

            it->get()->GetChildScopeIterators(&itChildBegin, &itChildEnd);

            const CScope &rMatching = _LookupScopeById(id,
                                                       itChildBegin,
                                                       itChildEnd);

            if (rMatching.Type() != ST_INVALID)
            {
                return rMatching;
            }
        }
    }
    return *m_rpInvalidScope.get();
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::_ValidateFilterFlags
//
//  Synopsis:   Return E_INVALIDARG if any of the flags in [pScopeInit]
//              violate object picker's rules, or S_OK otherwise.
//
//  Arguments:  [pScopeInit]   - points to structure containing flags to
//                                 inspect
//              [flScopeTypes] - scope types to which these flags apply
//
//  Returns:    S_OK or E_INVALIDARG
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CScopeManager::_ValidateFilterFlags(
    PCDSOP_SCOPE_INIT_INFO pScopeInit,
    ULONG flScopeTypes)
{
    //TRACE_METHOD(CDsObjectPicker, _ValidateFilterFlags);

    HRESULT hr = E_INVALIDARG; // init for failure
    BOOL fWantUplevelFlags = FALSE;
    BOOL fWantDownlevelFlags = FALSE;
    MACHINE_CONFIG mc = m_rop.GetTargetComputerConfig();

    do
    {
        //
        // If the scope types contain uplevel scopes, require that some
        // uplevel filter flags are set.
        //

        if (flScopeTypes &
            (DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
             | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
             | DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
             | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE))
        {
            fWantUplevelFlags = TRUE;
        }
        else if ((flScopeTypes & DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN) &&
                 (mc == MC_JOINED_NT5 || mc == MC_NT5_DC))
        {
            fWantUplevelFlags = TRUE;
        }

        if (fWantUplevelFlags)
        {
            //
            // Error if no uplevel filter flags are set
            //

            if (!(pScopeInit->FilterFlags.Uplevel.flBothModes
                  | pScopeInit->FilterFlags.Uplevel.flMixedModeOnly
                  | pScopeInit->FilterFlags.Uplevel.flNativeModeOnly))
            {
                Dbg(DEB_ERROR,
                    "Error: uplevel scope type but no uplevel filter flags\n");
                break;
            }

            //
            // Error if only native mode or only mixed mode flags are set.
            // Exception: ok for GC to have only native, since that's what
            // we'll use for it.
            //

            if (pScopeInit->flType != DSOP_SCOPE_TYPE_GLOBAL_CATALOG &&
                !pScopeInit->FilterFlags.Uplevel.flBothModes &&
                (!pScopeInit->FilterFlags.Uplevel.flMixedModeOnly ||
                 !pScopeInit->FilterFlags.Uplevel.flNativeModeOnly))
            {
                Dbg(DEB_ERROR,
                    "Error: uplevel scope type, !flBothModes and either !flMixedModeOnly or !flNativeModeOnly\n");
                break;
            }

            //
            // Make sure there are no downlevel filter bits set in the
            // uplevel flags.
            //

            const DSOP_UPLEVEL_FILTER_FLAGS *pUF =
                &pScopeInit->FilterFlags.Uplevel;

            if ((pUF->flBothModes & DSOP_DOWNLEVEL_FILTER_BIT) ||
                (pUF->flMixedModeOnly & DSOP_DOWNLEVEL_FILTER_BIT) ||
                (pUF->flNativeModeOnly & DSOP_DOWNLEVEL_FILTER_BIT))
            {
                Dbg(DEB_ERROR,
                    "Error: downlevel bit set in uplevel filter\n");
                break;
            }

            //
            // If scope type GC is included, then either both
            // or native must have at least one filter flag, because
            // mixed mode is ignored.
            //

            if (flScopeTypes & DSOP_SCOPE_TYPE_GLOBAL_CATALOG)
            {
                if (!(pScopeInit->FilterFlags.Uplevel.flNativeModeOnly
                      | pScopeInit->FilterFlags.Uplevel.flBothModes))
                {
                    Dbg(DEB_ERROR,
                        "Error: DSOP_SCOPE_TYPE_GLOBAL_CATALOG requires native mode or both mode filter flags\n");
                    break;
                }
            }
        }

        //
        // If the scope types contain downlevel scopes, require that some
        // downlevel filter flags are set.
        //

        if (flScopeTypes &
            (DSOP_SCOPE_TYPE_TARGET_COMPUTER
             | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN
             | DSOP_SCOPE_TYPE_WORKGROUP
             | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE))
        {
            fWantDownlevelFlags = TRUE;
        }
        else if ((flScopeTypes & DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN) &&
                 (mc == MC_JOINED_NT4 || mc == MC_NT4_DC))
        {
            fWantDownlevelFlags = TRUE;
        }

        if (fWantDownlevelFlags)
        {
            if (!pScopeInit->FilterFlags.flDownlevel)
            {
                Dbg(DEB_ERROR,
                    "Error: downlevel scope type but no downlevel filter flags\n");
                break;
            }

            //
            // If Workgroup scope is specified, computer
            // object is required, since that's the only thing a
            // workgroup can contain.
            //

            if (flScopeTypes & DSOP_SCOPE_TYPE_WORKGROUP)
            {
                if ((pScopeInit->FilterFlags.flDownlevel
                      & DSOP_DOWNLEVEL_FILTER_COMPUTERS) != DSOP_DOWNLEVEL_FILTER_COMPUTERS )
                {
                    Dbg(DEB_ERROR,
                        "Error: DSOP_SCOPE_TYPE_WORKGROUP requires DSOP_DOWNLEVEL_FILTER_COMPUTERS\n");
                    break;
                }
            }
        }

        //
        // Miscellaneous checks
        //

        // only uplevel joined domain scope is allowed to specify dc name

        if (pScopeInit->pwzDcName && *pScopeInit->pwzDcName)
        {
            if (!(flScopeTypes & DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN))
            {
                Dbg(DEB_ERROR,
                    "Error: pwzDcName only supported for DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN\n");
                break;
            }
        }

        // computer scope must have downlevel filters other than computers,
        // since that flag will be ignored

        if (flScopeTypes & DSOP_SCOPE_TYPE_TARGET_COMPUTER)
        {
            if (!(pScopeInit->FilterFlags.flDownlevel &
                  ~DSOP_DOWNLEVEL_FILTER_COMPUTERS))
            {
                Dbg(DEB_ERROR,
                    "Error: computer scope must have downlevel filters other than DSOP_DOWNLEVEL_FILTER_COMPUTERS\n");
                break;
            }
        }

        //
        // Made it through the gauntlet--return success.
        //

        hr = S_OK;
    } while (0);

    return hr;
}


#define ENUMERATE_DOMAIN_TRUST_FLAGS    (DS_DOMAIN_PRIMARY              \
                                         | DS_DOMAIN_IN_FOREST          \
                                         | DS_DOMAIN_DIRECT_OUTBOUND)


//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::_InitDomainScopesJoinedNt5
//
//  Synopsis:   Discover the domains in the enterprise to which the target
//              computer belongs and create scope objects for each of them.
//
//  Arguments:  [pGcScope] - pointer to GC scope, which is parent to all
//                            the trees in the enterprise, or NULL if
//                            there is no GC scope.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CScopeManager::_InitDomainScopesJoinedNt5(
    CGcScope *pGcScope)
{
    TRACE_METHOD(CScopeManager, _InitDomainScopesJoinedNt5);

    ULONG cDomains;
    NET_API_STATUS Status;
    PDS_DOMAIN_TRUSTS Domains;
    MACHINE_CONFIG mc = m_rop.GetTargetComputerConfig();

    //
    // Get the trust link information
    //

    PWSTR pwzTarget;

    if (m_rop.TargetComputerIsLocalComputer())
    {
        pwzTarget = NULL;
    }
    else if (mc == MC_JOINED_NT5)
    {
        pwzTarget = (PWSTR) m_rop.GetTargetDomainDc().c_str();
    }
    else
    {
        pwzTarget = (PWSTR) m_rop.GetTargetComputer().c_str();
    }

    {
        TIMER("DsEnumerateDomainTrusts(%ws)\n", pwzTarget ? pwzTarget : L"NULL");

        Status = DsEnumerateDomainTrusts(pwzTarget,
                                         ENUMERATE_DOMAIN_TRUST_FLAGS,
                                         &Domains,
                                         &cDomains);
    }

    //
    // Might need to establish connection to remote machine to get this
    // info.
    //

    if (Status == ERROR_ACCESS_DENIED && pwzTarget)
    {
        Dbg(DEB_TRACE,
            "DsEnumerateDomainTrusts(%ws) returned ERROR_ACCESS_DENIED\n",
            pwzTarget);

        CImpersonateAnon AnonymousImpersonation;

        Status = DsEnumerateDomainTrusts(pwzTarget,
                                         ENUMERATE_DOMAIN_TRUST_FLAGS,
                                         &Domains,
                                         &cDomains);
    }

    if (Status)
    {
        Dbg(DEB_ERROR,
            "DsEnumerateDomainTrusts error<%uL>\n",
            Status);
        return;
    }

    //
    // It comes back as an array with each element having an index to
    // its parent (if any).  Build up a parallel array that has, for
    // each element, a list of child elements.  This allows us to traverse
    // the tree(s) from the root(s) down, which is what we need to do to
    // add the domains to the scope control with proper indenting to
    // show parent/child relationship.
    //

    CDomainInfo *adi = new CDomainInfo[cDomains];
    ULONG        i;

    for (i = 0; i < cDomains; i++)
    {
        PDS_DOMAIN_TRUSTS ptdCur = &Domains[i];

        Dbg(DEB_TRACE, "Domains[%u]:\n", i);
        Dbg(DEB_TRACE, "  NetbiosDomainName %ws\n", ptdCur->NetbiosDomainName);
        Dbg(DEB_TRACE, "  DnsDomainName %ws\n", ptdCur->DnsDomainName);
        Dbg(DEB_TRACE, "  Flags %#x\n", ptdCur->Flags);
        Dbg(DEB_TRACE, "  ParentIndex %u\n", ptdCur->ParentIndex);
        Dbg(DEB_TRACE, "  TrustType %#x\n", ptdCur->TrustType);
        Dbg(DEB_TRACE, "  TrustAttributes %#x\n", ptdCur->TrustAttributes);

        while (ptdCur->TrustType != TRUST_TYPE_MIT &&
               IsNonRootDomainInForest(ptdCur) &&
               !adi[i].fAddedToParentsChildList)
        {
            ASSERT(ptdCur->ParentIndex < cDomains);
            PDS_DOMAIN_TRUSTS ptdParent = &Domains[ptdCur->ParentIndex];

            adi[ptdCur->ParentIndex].lpdiChildren.push_back(&adi[i]);
            adi[i].fAddedToParentsChildList = TRUE;
            ptdCur = ptdParent;
        }
    }

    //
    // Now traverse all the trees in the enterprise depth first, from the
    // root down.
    //

    for (i = 0; i < cDomains; i++)
    {
        if (Domains[i].Flags & DS_DOMAIN_TREE_ROOT)
        {
            _AddTreeJoinedNt5(pGcScope, i, adi, Domains);
        }
    }

    //
    // If caller wants external domains added, do them now.
    //

    const SScopeParameters *pspExternalUplevel =
        GetScopeParams(ST_EXTERNAL_UPLEVEL_DOMAIN);

    const SScopeParameters *pspExternalDownlevel =
        GetScopeParams(ST_EXTERNAL_DOWNLEVEL_DOMAIN);

    if (pspExternalUplevel || pspExternalDownlevel)
    {
        vector<ADD_SCOPE_INFO> asiv;

        for (i = 0; i < cDomains; i++)
        {
            PDS_DOMAIN_TRUSTS ptdCur = &Domains[i];

            if (!(ptdCur->Flags & DS_DOMAIN_IN_FOREST) &&
                ptdCur->TrustType != TRUST_TYPE_MIT &&
                !(ptdCur->TrustAttributes & TRUST_ATTRIBUTE_FOREST_TRANSITIVE))
            {
                ADD_SCOPE_INFO asi;

                asi.Domain.strFlatName = ptdCur->NetbiosDomainName;

                if (pspExternalUplevel && ptdCur->DnsDomainName)
                {
                    asi.flType = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN;
                    asi.Domain.strScopeName = ptdCur->DnsDomainName;
                    asi.flScope = pspExternalUplevel->flScope;
                    asi.FilterFlags = pspExternalUplevel->FilterFlags;
                    asi.Domain.strADsPath = c_wzLDAPPrefix;
                    asi.Domain.strADsPath += ptdCur->DnsDomainName;
                    asi.Domain.Mode = DM_UNDETERMINED;
                }
                else if (pspExternalDownlevel
                         && ptdCur->NetbiosDomainName
                         && !ptdCur->DnsDomainName)
                {
                    asi.flType = DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;
                    asi.Domain.strScopeName = ptdCur->NetbiosDomainName;
                    asi.flScope = pspExternalDownlevel->flScope;
                    asi.FilterFlags = pspExternalDownlevel->FilterFlags;
                    asi.Domain.strADsPath = c_wzWinNTPrefix;
                    asi.Domain.strADsPath += ptdCur->NetbiosDomainName;
                    asi.Domain.strADsPath += L",Domain";
                }

                if (asi.flType != DSOP_SCOPE_TYPE_INVALID)
                {
                    asiv.push_back(asi);
                }
            }
        }

        sort(asiv.begin(), asiv.end());

        vector<ADD_SCOPE_INFO>::iterator it;

        for (it = asiv.begin(); it != asiv.end(); it++)
        {
            RpScope rpScope;

            if (it->flType == DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN)
            {
                rpScope.Acquire(new CLdapDomainScope(m_rop, *it, NULL));
            }
            else
            {
                rpScope.Acquire(new CWinNtDomainScope(m_rop, *it));
            }

            m_vrpRootScopes.push_back(rpScope);

            if (m_StartingScopeType == rpScope->Type() &&
                !m_rpStartingScope.get())
            {
                m_rpStartingScope = rpScope;
            }
        }
    }

    NetApiBufferFree((void *)Domains);
    delete [] adi;
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::_AddTreeJoinedNt5
//
//  Synopsis:   Recursively add the domain Domains[idxCur] and all its
//              children to the scope control.
//
//  Arguments:  [pParent] - parent scope (NULL if none)
//              [idxCur]  - current element of [Domains]
//              [adi]     - array used to process [Domains]
//              [Domains] - returned by
//                          DsEnumerateDomainTrusts
//
//  History:    11-17-1998   DavidMun   Created
//              01-25-2000   davidmun   move from querythd.cxx, change for
//                                       multiple hierarchical scopes
//
//---------------------------------------------------------------------------

void
CScopeManager::_AddTreeJoinedNt5(
    CLdapContainerScope *pParent,
    ULONG idxCur,
    CDomainInfo *adi,
    PDS_DOMAIN_TRUSTS Domains)
{
    TRACE_METHOD(CScopeManager, _AddTreeJoinedNt5);

    ADD_SCOPE_INFO asi;

    asi.Domain.strScopeName = Domains[idxCur].DnsDomainName ?
        Domains[idxCur].DnsDomainName :
        Domains[idxCur].NetbiosDomainName;
    asi.Domain.strFlatName = Domains[idxCur].NetbiosDomainName ?
        Domains[idxCur].NetbiosDomainName :
        L"";

    //
    // Add domain represented by Domains[idxCur]
    //

    const SScopeParameters *pspUplevelJoinedDomain =
        GetScopeParams(ST_UPLEVEL_JOINED_DOMAIN);

    const SScopeParameters *pspEnterpriseDomains =
        GetScopeParams(ST_ENTERPRISE_DOMAIN);

    if (pspUplevelJoinedDomain && (Domains[idxCur].Flags & DS_DOMAIN_PRIMARY))
    {
        asi.flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN;
        asi.flScope = pspUplevelJoinedDomain->flScope;
        asi.FilterFlags = pspUplevelJoinedDomain->FilterFlags;
        asi.Domain.strADsPath = c_wzLDAPPrefix;
        asi.Domain.Mode = (Domains[idxCur].Flags & DS_DOMAIN_NATIVE_MODE)
                    ? DM_NATIVE
                    : DM_MIXED;

        if (!pspUplevelJoinedDomain->strDcName.empty())
        {
            asi.Domain.strADsPath += pspUplevelJoinedDomain->strDcName;
            asi.Domain.fPathIsDc = TRUE;
        }
        else
        {
            asi.Domain.strADsPath += Domains[idxCur].DnsDomainName ?
                                        Domains[idxCur].DnsDomainName :
                                        Domains[idxCur].NetbiosDomainName;
        }
    }
    else if (pspEnterpriseDomains)
    {
        asi.flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
        asi.flScope = pspEnterpriseDomains->flScope;
        asi.FilterFlags = pspEnterpriseDomains->FilterFlags;
        asi.Domain.strADsPath = c_wzLDAPPrefix;
        asi.Domain.strADsPath += Domains[idxCur].DnsDomainName ?
                                    Domains[idxCur].DnsDomainName :
                                    Domains[idxCur].NetbiosDomainName;
        asi.Domain.Mode = DM_UNDETERMINED;
    }

    CLdapContainerScope *pNextParent = pParent;

    if (asi.flType != DSOP_SCOPE_TYPE_INVALID)
    {
        RpScope rpScope;

        rpScope.Acquire(new CLdapDomainScope(m_rop, asi, pParent));

        if (!pParent)
        {
            m_vrpRootScopes.push_back(rpScope);
            pNextParent = (CLdapContainerScope*)m_vrpRootScopes.back().get();
        }
        else
        {
            pParent->AddChild(rpScope);
            pNextParent = (CLdapContainerScope*)pParent->back().get(); // implemented as { return m_vrpRootScopes.back(); }
        }

        if (m_StartingScopeType == rpScope->Type() &&
            !m_rpStartingScope.get())
        {
            m_rpStartingScope = rpScope;
        }
    }

    //
    // Add all its children
    //

    DomainInfoList::iterator it;

    for (it = adi[idxCur].lpdiChildren.begin();
         it != adi[idxCur].lpdiChildren.end();
         it++)
    {
        ULONG idxChild = static_cast<ULONG>(*it - adi);

        _AddTreeJoinedNt5(pNextParent, idxChild, adi, Domains);
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   IsNonRootDomainInForest
//
//  Synopsis:   Return TRUE if [ptd] represents an enterprise domain that
//              is not the root of a domain tree.
//
//  History:    11-17-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

inline BOOL
IsNonRootDomainInForest(
    PDS_DOMAIN_TRUSTS ptd)
{
    return (ptd->Flags & DS_DOMAIN_IN_FOREST) &&
           !(ptd->Flags & DS_DOMAIN_TREE_ROOT);
}


#define ENUMERATE_REQUEST_BYTES 1024


//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::_InitScopesJoinedNt4
//
//  Synopsis:   Add joined and external domains to scope control using
//              only downlevel domains.
//
//  History:    11-17-1998   DavidMun   Created
//              01-26-2000   davidmun   moved from querythd and changed for
//                                       new scope hierarchy
//
//---------------------------------------------------------------------------

void
CScopeManager::_InitScopesJoinedNt4()
{
    TRACE_METHOD(CScopeManager, _InitScopesJoinedNt4);

    const SScopeParameters *pspDownlevelJoinedDomain =
                        GetScopeParams(ST_DOWNLEVEL_JOINED_DOMAIN);
    const SScopeParameters *pspEnterpriseDomains =
                        GetScopeParams(ST_ENTERPRISE_DOMAIN);
    const SScopeParameters *pspExternalDownlevel =
                        GetScopeParams(ST_EXTERNAL_DOWNLEVEL_DOMAIN);
    const SScopeParameters *pspJoined = NULL;

    if (pspDownlevelJoinedDomain)
    {
        pspJoined = pspDownlevelJoinedDomain;
    }
    else if (pspEnterpriseDomains &&
             pspEnterpriseDomains->FilterFlags.flDownlevel)
    {
        pspJoined = pspEnterpriseDomains;
    }

    if (!pspJoined && !pspExternalDownlevel)
    {
        return;
    }

    HRESULT                     hr = S_OK;
    NTSTATUS                    nts;
    LSA_OBJECT_ATTRIBUTES       oa;
    SECURITY_QUALITY_OF_SERVICE sqos;
    LSA_HANDLE                  hlsaServer = NULL;
    LSA_HANDLE                  hlsaPDC = NULL;
    POLICY_PRIMARY_DOMAIN_INFO *pPrimaryDomainInfo = NULL;
    BOOL                        fOk;
    ADD_SCOPE_INFO              asi;
    vector<ADD_SCOPE_INFO>      asiv;
    WCHAR                       wzPrimaryDomain[MAX_PATH] = L"";
    PDOMAIN_CONTROLLER_INFO     pdci = NULL;

    //
    // To get accurate and completely up-to-date trusted domains enumeration,
    // call LsaQueryInformationPolicy to get the machine's domain, then call
    // DsGetDcName to find a DC, then call LsaEnumerateTrustedDomains on
    // that DC.
    //

    do
    {
        POLICY_ACCOUNT_DOMAIN_INFO *pAccountDomainInfo = NULL;

        hr = GetLsaAccountDomainInfo(m_rop.GetTargetComputer().c_str(),
                                     &hlsaServer,
                                     &pAccountDomainInfo);

        if (pAccountDomainInfo)
        {
            LsaFreeMemory(pAccountDomainInfo);
        }

        if (!hlsaServer)
        {
            ASSERT(FAILED(hr));
            break;
        }

        //
        // Get the server's primary domain (or workgroup) and add it to the
        // scope
        //

        nts = LsaQueryInformationPolicy(hlsaServer,
                                        PolicyPrimaryDomainInformation,
                                        (LPVOID *)&pPrimaryDomainInfo);
        BREAK_ON_FAIL_NTSTATUS(nts);

        UnicodeStringToWsz(pPrimaryDomainInfo->Name,
                           wzPrimaryDomain,
                           ARRAYLEN(wzPrimaryDomain));

        if (pspJoined)
        {
            asi.flType = DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
            asi.flScope = pspJoined->flScope;
            asi.FilterFlags = pspJoined->FilterFlags;
            asi.Domain.strScopeName = wzPrimaryDomain;
            asi.Domain.strFlatName = wzPrimaryDomain;
            asi.Domain.strADsPath = c_wzWinNTPrefix;
            asi.Domain.strADsPath += wzPrimaryDomain;
            asi.Domain.strADsPath += L",Domain";

            ASSERT(pPrimaryDomainInfo->Sid);
            Dbg(DEB_TRACE,
                "target machine joined to NT4 domain '%ws'\n",
                wzPrimaryDomain);

            asiv.push_back(asi);
        }

        if (!pspExternalDownlevel)
        {
            break;
        }

        //
        // Now add each of the trusted domains listed from the PDC to the
        // scope.  We establish an API session (null session w/ IPC$) so we
        // don't have account conflicts (i.e., Admin w/ diff passwords)
        //

        // first get the name of a DC in the domain of the server

        ULONG ulResult;

        ulResult = DsGetDcName(NULL,
                               wzPrimaryDomain,
                               NULL,
                               NULL,
                               0,
                               &pdci);

        if (ulResult != ERROR_SUCCESS)
        {
            DBG_OUT_LRESULT(ulResult);
            break;
        }

        Dbg(DEB_TRACE, "  PDC '%ws'\n", pdci->DomainControllerName);

        CImpersonateAnon    Anonymous;

        UNICODE_STRING uszPDC;

        fOk = RtlCreateUnicodeString(&uszPDC, pdci->DomainControllerName);

        if (!fOk)
        {
            hr = E_OUTOFMEMORY;
            DBG_OUT_HRESULT(hr);
            break;
        }

        ZeroMemory(&sqos, sizeof sqos);
        sqos.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
        sqos.ImpersonationLevel = SecurityImpersonation;
        sqos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
        sqos.EffectiveOnly = FALSE;

        ZeroMemory(&oa, sizeof oa);
        oa.Length = sizeof oa;
        oa.SecurityQualityOfService = &sqos;

        {
            TIMER("LsaOpenPolicy");

            nts = LsaOpenPolicy(&uszPDC,
                                &oa,
                                POLICY_VIEW_LOCAL_INFORMATION,
                                &hlsaPDC);
        }
        RtlFreeUnicodeString(&uszPDC);

        BREAK_ON_FAIL_NTSTATUS(nts);

        ULONG cItems;
        LSA_ENUMERATION_HANDLE hEnum = NULL;
        PLSA_TRUST_INFORMATION pTrustInfo = NULL;

        while (1)
        {
            {
                TIMER("LsaEnumerateTrustedDomains");

                nts = LsaEnumerateTrustedDomains(hlsaPDC,
                                                 &hEnum,
                                                 (PVOID *)&pTrustInfo,
                                                 ENUMERATE_REQUEST_BYTES,
                                                 &cItems);
            }

            if (nts == STATUS_NO_MORE_ENTRIES)
            {
                ASSERT(!cItems);
                break;
            }

            BREAK_ON_FAIL_NTSTATUS(nts);

            ASSERT(cItems);

            if (!cItems)
            {
                break;
            }

            ULONG i;
            PLSA_TRUST_INFORMATION pCurTrust;

            for (i = 0, pCurTrust = pTrustInfo; i < cItems; i++, pCurTrust++)
            {
                WCHAR wzTrustedDomain[MAX_PATH];

                UnicodeStringToWsz(pCurTrust->Name,
                                   wzTrustedDomain,
                                   ARRAYLEN(wzTrustedDomain));

                Dbg(DEB_TRACE, "  %ws\n", wzTrustedDomain);

                asi.flType = DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;
                asi.flScope = pspExternalDownlevel->flScope;
                asi.FilterFlags = pspExternalDownlevel->FilterFlags;
                asi.Domain.strScopeName = wzTrustedDomain;
                asi.Domain.strFlatName = wzTrustedDomain;
                asi.Domain.strADsPath = c_wzWinNTPrefix;
                asi.Domain.strADsPath += wzTrustedDomain;
                asi.Domain.strADsPath += L",Domain";

                asiv.push_back(asi);
            }

            LsaFreeMemory(pTrustInfo);
            pTrustInfo = NULL;
            hr = S_OK; // ignore failures
        }

        ASSERT(!pTrustInfo);
    } while (0);

    if (pdci)
    {
        NetApiBufferFree(pdci);
        pdci = NULL;
    }

    //
    // asiv now contains 0 or more scopes to add.  Sort them by name and
    // add them.
    //

    sort(asiv.begin(), asiv.end());

    vector<ADD_SCOPE_INFO>::iterator it;

    for (it = asiv.begin(); it != asiv.end(); it++)
    {
        RpScope rps;

        rps.Acquire(new CWinNtDomainScope(m_rop, *it));
        m_vrpRootScopes.push_back(rps);

        if (m_StartingScopeType == rps->Type() &&
            !m_rpStartingScope.get())
        {
            m_rpStartingScope = rps;
        }
    }

    //
    // Release resources
    //

    if (pPrimaryDomainInfo)
    {
        LsaFreeMemory(pPrimaryDomainInfo);
    }

    if (hlsaServer)
    {
        LsaClose(hlsaServer);
    }

    if (hlsaPDC)
    {
        LsaClose(hlsaPDC);
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::DoLookInDialog
//
//  Synopsis:   Invoke the modal "Look In" dialog and block until it returns
//
//  Arguments:  [hwndParent] - parent of modal dialog
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CScopeManager::DoLookInDialog(
    HWND hwndParent) const
{
    TRACE_METHOD(CScopeManager, DoLookInDialog);

    CLookInDlg  LookInDlg(m_rop);

    LookInDlg.DoModal(hwndParent, m_rpCurScope.get());

    m_rpCurScope = LookInDlg.GetSelectedScope();
}




//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::AddUserEnteredScope
//
//  Synopsis:   Add to the list of root scopes a scope created when
//              resolving a name the user typed of the form dom\obj or
//              obj@dom.
//
//  Arguments:  [asi] - describes the scope to add
//
//  Returns:    Reference to newly added scope.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const CScope &
CScopeManager::AddUserEnteredScope(
    const ADD_SCOPE_INFO &asi) const
{
    TRACE_METHOD(CScopeManager, AddUserEnteredScope);
    ASSERT(asi.flType == DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE ||
           asi.flType == DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE);

    if (asi.flType == DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE)
    {
        RpScope rps;

        rps.Acquire(new CLdapContainerScope(static_cast<SCOPE_TYPE>(asi.flType),
                                            asi.Domain.strScopeName,
                                            asi.Domain.strADsPath,
                                            m_rop,
                                            NULL));
        m_vrpRootScopes.push_back(rps);
        return *m_vrpRootScopes.back().get();
    }

    RpScope rps;

    rps.Acquire(new CWinNtDomainScope(m_rop, asi));
    m_vrpRootScopes.push_back(rps);
    return *m_vrpRootScopes.back().get();
}
//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::AddCrossForestDomainScope
//
//  Synopsis:   Add to the list of root scopes a scope created when
//              resolving a name the user typed of the form dom\obj or
//              obj@dom and name is resolved in a domain in a trusted cross
//              forest
//
//  Arguments:  [asi] - describes the scope to add
//
//  Returns:    Reference to newly added scope.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const CScope &
CScopeManager::AddCrossForestDomainScope(
    const ADD_SCOPE_INFO &asi) const
{
    TRACE_METHOD(CScopeManager, AddCrossForestDomainScope);
    ASSERT(asi.flType == DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN);

    RpScope rps;

    rps.Acquire(new CLdapDomainScope(m_rop,
                                    asi,
                                    NULL));        
    CLdapDomainScope * pLdapScope = dynamic_cast<CLdapDomainScope *>(rps.get());
    pLdapScope->SetXForest();
    m_vrpRootScopes.push_back(rps);
    return *m_vrpRootScopes.back().get();
}





//+--------------------------------------------------------------------------
//
//  Member:     CScopeManager::GetParent
//
//  Synopsis:   Return the parent of scope [Child], or an invalid scope if
//              [Child] doesn't have a parent scope.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

const CScope &
CScopeManager::GetParent(
    const CScope &Child) const
{
    if (Child.GetParent())
    {
        return *Child.GetParent();
    }
    return *m_rpInvalidScope.get();
}




//+--------------------------------------------------------------------------
//
//  Function:   CopyScopeTree
//
//  Synopsis:   Copy the tree of scope objects starting at [pCurToCopy]
//
//  History:    06-23-2000   DavidMun   Created
//
//  Notes:      Not yet fully implemented; part of code for cloning OP to
//              use in the DN picker of the Add Query Clause dialog of the
//              Query Builder tab of the Advanced dialog.
//
//---------------------------------------------------------------------------

void
CopyScopeTree(
    const CObjectPicker &rop,
    const CScope *pCurToCopy,
    CScope *pDestParent)
{
    TRACE_FUNCTION(CopyScopeTree);

    CScope *pNewScope = NULL;

    switch (pCurToCopy->Type())
    {
    case ST_GLOBAL_CATALOG:
    {
        ASSERT(!pDestParent);
        const CGcScope *pGcScopeToCopy =
            dynamic_cast<const CGcScope *>(pCurToCopy);

        if (pGcScopeToCopy)
        {
            pNewScope = new CGcScope(rop);
            CGcScope *pNewGcScope = dynamic_cast<CGcScope *>(pNewScope);

            pNewGcScope->Clone(*pGcScopeToCopy);
        }
        break;
    }

    case ST_UPLEVEL_JOINED_DOMAIN:
    case ST_ENTERPRISE_DOMAIN:
    case ST_EXTERNAL_UPLEVEL_DOMAIN:
    {
        //CLdapDomainScope *pNewScope = new CLdapDomainScope(rop, asi
        break;
    }

    case ST_USER_ENTERED_UPLEVEL_SCOPE:
    case ST_LDAP_CONTAINER:
        break;

    default:
        Dbg(DEB_ERROR, "unexpected scope type %#x\n", pCurToCopy->Type());
        ASSERT(0 && "unexpected scope type");
        break;
    }

    // in error case of unrecognized type, nothing was created

    if (!pNewScope)
    {
        return;
    }
}




#if (DBG == 1)

BOOL
CScopeManager::IsValidScope(
    CScope *pScope) const
{
    vector<RpScope>::const_iterator itCur;

    for (itCur = m_vrpRootScopes.begin();
         itCur != m_vrpRootScopes.end();
         itCur++)
    {
        if (itCur->get() == pScope)
        {
            return TRUE;
        }

        if (_IsChildScope(itCur->get(), pScope))
        {
            return TRUE;
        }
    }
    return FALSE;
}


BOOL
CScopeManager::_IsChildScope(
    CScope *pParent,
    CScope *pMaybeChild) const
{
    vector<RpScope>::const_iterator itCur;
    vector<RpScope>::const_iterator itChildEnd;

    pParent->GetChildScopeIterators(&itCur, &itChildEnd);

    for (; itCur != itChildEnd; itCur++)
    {
        if (itCur->get() == pMaybeChild)
        {
            return TRUE;
        }

        if (_IsChildScope(itCur->get(), pMaybeChild))
        {
            return TRUE;
        }
    }
    return FALSE;
}

#endif // (DBG == 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\stringdlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       StringDlg.cxx
//
//  Contents:   Implementation of child dialog for entering string attribute
//              condition and value
//
//  Classes:    CStringDlg
//
//  History:    05-26-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop


//
// SStringDlgSavedState - self-initializing structure used to persist the
// state of the string dialog.
//

struct SStringDlgSavedState
{
    SStringDlgSavedState():
        iComboSelection(0)
    {
        wzValue[0] = L'\0';
    }

    int     iComboSelection;
    WCHAR   wzValue[ANYSIZE_ARRAY];

private:

    SStringDlgSavedState(const SStringDlgSavedState &);

    SStringDlgSavedState &
    operator= (const SStringDlgSavedState &);
};




//+--------------------------------------------------------------------------
//
//  Member:     CStringDlg::GetLdapFilter
//
//  Synopsis:   Return an LDAP filter string corresponding to the user's
//              entry.
//
//  Arguments:  [ak] - key of currently selected string attribute
//
//  Returns:    LDAP filter
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

String
CStringDlg::GetLdapFilter(
    ATTR_KEY ak) const
{
    TRACE_METHOD(CStringDlg, GetLdapFilter);

    const CAttributeManager &ram = m_rop.GetAttributeManager();
    const String &strLdapName = ram.GetAttrAdsiName(ak);

    String strFilter = L"(" + strLdapName + L"=" + m_strValue;

    if (m_iCondition)
    {
        strFilter += L")";
    }
    else
    {
        strFilter += L"*)";
    }
    return strFilter;
}



//+--------------------------------------------------------------------------
//
//  Member:     CStringDlg::GetDescription
//
//  Synopsis:   Return a human-readable string describing the LDAP filter
//
//  Arguments:  [ak] - key of currently selected string attribute
//
//  Returns:    Description of filter that GetLdapFilter would return for
//              the same value of [ak].
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

String
CStringDlg::GetDescription(
    ATTR_KEY ak) const
{
    TRACE_METHOD(CStringDlg, GetDescription);

    String strFormat;

    if (m_iCondition)
    {
        strFormat = String::load(IDS_STR_FILTER_EXACT_DESCRIPTION_FMT);
    }
    else
    {
        strFormat = String::load(IDS_STR_FILTER_PREFIX_DESCRIPTION_FMT);
    }

    const CAttributeManager &ram = m_rop.GetAttributeManager();
    const String &strDisplayName = ram.GetAttrDisplayName(ak);

    return String::format(strFormat.c_str(),
                          strDisplayName.c_str(),
                          m_strValue.c_str());
}




//+--------------------------------------------------------------------------
//
//  Member:     CStringDlg::Show
//
//  Synopsis:   Make the dialog visible and enable its child controls
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CStringDlg::Show() const
{
    ShowWindow(m_hwnd, SW_SHOW);
    EnableWindow(_hCtrl(IDC_CONDITION_COMBO), TRUE);
    EnableWindow(_hCtrl(IDC_VALUE_EDIT), TRUE);
}




//+--------------------------------------------------------------------------
//
//  Member:     CStringDlg::Hide
//
//  Synopsis:   Make the dialog invisible and disable its child controls
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CStringDlg::Hide() const
{
    ShowWindow(m_hwnd, SW_HIDE);
    EnableWindow(_hCtrl(IDC_CONDITION_COMBO), FALSE);
    EnableWindow(_hCtrl(IDC_VALUE_EDIT), FALSE);
}




//+--------------------------------------------------------------------------
//
//  Member:     CStringDlg::Save
//
//  Synopsis:   Persist the dialog's state in a chunk of memory and put
//              a pointer to that chunk in *[ppv].
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CStringDlg::Save(
    PVOID *ppv) const
{
    TRACE_METHOD(CStringDlg, Save);

    *ppv = new BYTE [sizeof(SStringDlgSavedState) +
                     m_strValue.length() * sizeof(WCHAR)];
    SStringDlgSavedState *pssd = static_cast<SStringDlgSavedState *>(*ppv);

    pssd->iComboSelection = m_iCondition;
    lstrcpy(pssd->wzValue, m_strValue.c_str());
}




//+--------------------------------------------------------------------------
//
//  Member:     CStringDlg::Load
//
//  Synopsis:   Restore the dialog's state from a SStringDlgSavedState
//              structure pointed to by [pv].
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CStringDlg::Load(
    PVOID pv)
{
    TRACE_METHOD(CStringDlg, Load);

    SStringDlgSavedState *pssd = static_cast<SStringDlgSavedState *>(pv);
    m_iCondition = pssd->iComboSelection;
    m_strValue = pssd->wzValue;
}




//+--------------------------------------------------------------------------
//
//  Member:     CStringDlg::Free
//
//  Synopsis:   Free the data stored in [pv] by Save.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CStringDlg::Free(
    VOID *pv) const
{
    TRACE_METHOD(CStringDlg, Free);

    if (pv)
    {
        BYTE *pb = static_cast<BYTE *>(pv);
        delete [] pb;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CStringDlg::_OnCommand
//
//  Synopsis:   Handle a WM_COMMAND message
//
//  Arguments:  [wParam] - standard windows
//              [lParam] - standard windows
//
//  Returns:    standard windows
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CStringDlg::_OnCommand(
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fNotHandled = FALSE;

    switch (LOWORD(wParam))
    {
    case IDC_VALUE_EDIT:
        if (HIWORD(wParam) == EN_UPDATE &&
            IsWindowEnabled(reinterpret_cast<HWND>(lParam)))
        {
            _ReadEditCtrl(IDC_VALUE_EDIT, &m_strValue);
            m_strValue.strip(String::BOTH);

            EnableWindow(GetDlgItem(GetParent(m_hwnd), IDOK),
                         !m_strValue.empty());
        }
        break;

    case IDC_CONDITION_COMBO:
        if (HIWORD(wParam) == CBN_SELCHANGE)
        {
            m_iCondition = ComboBox_GetCurSel(reinterpret_cast<HWND>(lParam));
            ASSERT(m_iCondition != CB_ERR);
            if (m_iCondition == CB_ERR)
            {
                DBG_OUT_LASTERROR;
                m_iCondition = 0;
            }
            Dbg(DEB_TRACE, "UA: (StringDlg) selected %ws\n",
                (m_iCondition ? L"is exactly" : L"starts with"));
        }
        break;

    default:
        fNotHandled = TRUE;
        break;
    }
    return fNotHandled;
}




//+--------------------------------------------------------------------------
//
//  Member:     CStringDlg::_OnInit
//
//  Synopsis:   Initialize the dialog
//
//  Arguments:  [pfSetFocus] - unused
//
//  Returns:    HRESULT
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
CStringDlg::_OnInit(
    BOOL *pfSetFocus)
{
    TRACE_METHOD(CStringDlg, _OnInit);
    HRESULT hr = S_OK;

    do
    {
        Edit_SetText(_hCtrl(IDC_VALUE_EDIT), m_strValue.c_str());

        hr = AddStringToCombo(_hCtrl(IDC_CONDITION_COMBO), IDS_STARTS_WITH);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = AddStringToCombo(_hCtrl(IDC_CONDITION_COMBO), IDS_IS_EXACTLY);
        BREAK_ON_FAIL_HRESULT(hr);

        ComboBox_SetCurSel(_hCtrl(IDC_CONDITION_COMBO), m_iCondition);

        EnableWindow(GetDlgItem(GetParent(m_hwnd), IDOK),
                     !m_strValue.empty());
    } while (0);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\srvinfo.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       srvinfo.cxx
//
//  Contents:   Classes for managing per-server credentials.
//
//  Classes:    CServerInfo
//
//  History:    04-24-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

DEBUG_DECLARE_INSTANCE_COUNTER(CServerInfo)

//
// The ADS_READONLY_SERVER flag was removed because it breaks some NT4 interop scenarios
//
#define OPEN_OBJECT_FLAGS           (ADS_SECURE_AUTHENTICATION | ADS_READONLY_SERVER)

//===========================================================================
//
// CServerInfo
//
//===========================================================================




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::CServerInfo
//
//  Synopsis:   ctor
//
//  Arguments:  [pBinder]   - backpointer to parent
//              [pwzServer] - server portion of ads path
//              [flags]     - flags describing [pwzServer]
//
//  History:    04-26-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CServerInfo::CServerInfo(
    CBinder *pBinder,
    PCWSTR pwzServer,
    USHORT flags):
        m_pBinder(pBinder),
        m_pADsNameTranslate(NULL),
        m_pADsRootDSE(NULL),
        m_hrLastCredError(S_OK),
        m_pNext(NULL),
        m_pADsContainer(NULL),
        m_flProvider(0),
        m_pwzDN(NULL)
{
    //TRACE_CONSTRUCTOR(CServerInfo);
    Dbg(DEB_BIND, "CServerInfo::CServerInfo(%x) '%ws'\n", this, pwzServer);
    DBG_INDENTER;
    ASSERT(!(flags & ~SRVINF_VALID_FLAG_MASK));
    DEBUG_INCREMENT_INSTANCE_COUNTER(CServerInfo);

    _SetFlag(flags);
    lstrcpyn(m_wzServer, pwzServer, ARRAYLEN(m_wzServer));

    //
    // Truncate at a trailing dot because sometimes we'll get it as
    // part of the server and sometimes we won't, and we don't want the
    // string comparison of server names to fail to match because of it.
    //

    PWSTR pwzLastDot = wcsrchr(m_wzServer, L'.');

    if (pwzLastDot && !pwzLastDot[1])
    {
        *pwzLastDot = L'\0';
    }

    InitializeCriticalSection(&m_cs);
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::IsForServer
//
//  Synopsis:   Return TRUE if this has a container interface for server
//              [pwzServer].
//
//  Arguments:  [flProvider] - PROVIDER_*
//              [pwzServer]  - server name
//
//  History:    08-16-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
CServerInfo::IsForServer(
    ULONG flProvider,
    PCWSTR pwzServer)
{
    return m_flProvider == flProvider && !lstrcmpi(pwzServer, m_wzServer);
}



//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::Init
//
//  Synopsis:   Perform the first part of the initialization of this which
//              can fail and is therefore done outside the ctor
//
//  Arguments:  [hwnd]    - for binding
//              [pwzPath] - NULL or path to bind to
//              [riid]    - identifies desired interface
//              [ppv]     - optional; on success filled with requested
//                           interface
//
//  Returns:    HRESULT
//
//  History:    07-14-1998   DavidMun   Created
//
//  Notes:      This method is only called once for each instance of this
//              class.  The _RepeatableInit() method may be called multiple
//              times.
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::Init(
    HWND    hwnd,
    PCWSTR pwzPath,
    REFIID riid,
    VOID **ppv)
{
    TRACE_METHOD(CServerInfo, Init);
    ASSERT(pwzPath);

    HRESULT hr = S_OK;
    IADs   *pADs = NULL;
    BSTR    bstrProvider = NULL;
    BOOL    fUserIsLocal = IsCurrentUserLocalUser();

    do
    {
        if (pwzPath)
        {
            m_strOriginalPath = pwzPath;
        }
        else
        {
            hr = E_POINTER;
            DBG_OUT_HRESULT(hr);
            break;
        }

        hr = ProviderFlagFromPath(m_strOriginalPath, &m_flProvider);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // Bind to the server for the container interface.  First try
        // binding without credentials.  If this fails because different
        // credentials are needed, prompt the user for them and retry,
        // until success, a non credential error occurs, or the user
        // cancels the prompt.
        //

        hr = g_pADsPath->SetRetrieve(ADS_SETTYPE_FULL,
                                     m_strOriginalPath.c_str(),
                                     ADS_FORMAT_PROVIDER,
                                     &bstrProvider);
        BREAK_ON_FAIL_HRESULT(hr);

        m_strOriginalContainerPath = String::format(L"%1://%2",
                                                    bstrProvider,
                                                    m_wzServer);

        if (m_flProvider == PROVIDER_WINNT)
        {
            //
            // Append winnt binding hint from pwzPath
            //

            PWSTR pwzComma = wcschr(pwzPath, L',');

            if (pwzComma)
            {
                m_strOriginalContainerPath += pwzComma;
            }
        }
       if (fUserIsLocal && !_IsFlagSet(SRVINF_WINNT_WORKGROUP_OBJECT) && !IsLocalComputername(m_wzServer))
        {
            //
            // Don't attempt to bind if the user is logged on locally but the
            // thing we need to bind to is not on the local machine.  Two
            // reasons: first, it is going to fail; second, if the user is
            // logged on as local admin the attempt will be logged as a
            // failed logon as DOMAIN admin, which can cause the domain admin
            // account to be locked out.
            //
            // Set a flag to remember that we didn't attempt a bind here so
            // we can suppress any non-credential error later.
            //
            //More comments by hiteshr
            //One more case in which binding will succeed is when server name is
            //name of local workgroup. However we always try to bind if machine 
            //name is workgroup. Reason being this is a very rare scenario( you are
            //logged in as local user and you are trying to browse a remote workgroup)
            //and litte delay caused by failed binding is acceptable.

            _SetFlag(SRVINF_USER_LOCAL_SERVER_REMOTE);

            Dbg(DEB_TRACE,
                "Current user is local and binding off-computer, skipping NULL/NULL bind\n");
            hr = E_ACCESSDENIED;
        }
        else
        {
            TIMER("CServerInfo::Init: ADsOpenObject(%ws,NULL,NULL) for IADsContainer",
                  m_strOriginalContainerPath.c_str());

            ASSERT(!m_pADsContainer);
            hr = _MyADsOpenObject(const_cast<PWSTR>(m_strOriginalContainerPath.c_str()),
                                NULL,
                                NULL,
                                IID_IADsContainer,
                                (void**)&m_pADsContainer);
        }

        //
        // If it worked, we're done.
        //
                  
        if (SUCCEEDED(hr))
        {
            if (_IsFlagSet(SRVINF_WINNT_DOMAIN_OBJECT) ||
                _IsFlagSet(SRVINF_WINNT_COMPUTER_OBJECT))
            {
                //
                // Well, almost.  binding to WinNT for domain object
                // can succeed, however actually trying to get attributes from
                // it can fail with ERROR_LOGON_FAILURE.
                //
                // Binding using winnt provider to a computer object can
                // succeed, but reading attributes can fail with
                // E_ACCESSDENIED.  This is because ADSI caches some items
                // and doesn't actually attempt to connect until forced to.
                //

                // jeffjon 12/19/2000, (sburns didn't propogate the fix here as well)
                // that's well and good, but if you
                // don't read some properties, you have the problem
                // with adsi delaying the connect, and you therefore
                // cause regression bug 245866.

                hr = m_pADsContainer->QueryInterface(IID_IADs, (void**)&pADs);

                if (SUCCEEDED(hr))
                {
                    Variant var;

                    // NTRAID#NTBUG9-245866-2000/12/11-sburns

                    // Evidently, administrators can read the
                    // Processor attribute, but not plain users.

                    // workaround for the adsi workaround is to
                    // therefore ignore the result of the Get.
                    // How's that for elegant?
                    
                    if (_IsFlagSet(SRVINF_WINNT_DOMAIN_OBJECT))
                    {
                        hr = pADs->Get(L"MinPasswordLength", &var);
                    }
                    else
                    {
                        hr = pADs->Get(L"Processor", &var);
                    }

                    // The Get call could fail for a number of
                    // reasons.  The remote machine might not be
                    // running the remote registry service, the
                    // creds supplied by the user might be bad, the
                    // creds supplied might be good, but
                    // insufficient to read the processor type from
                    // the remote reg, etc.
                    // 
                    // The error condition we're interested in is
                    // bad creds. In that case, the error returned
                    // is logon failure.  All other failures don't
                    // matter here, since all we interested
                    // in is making sure adsi opens a connection to
                    // the remote machine.
                    //                                     
                    // CODEWORK: the way to fix this is 1) pound on
                    // ADSI dev for a flag to ADsOpenObject that
                    // means "skip your connection optimization", or
                    // 2) do the connection management ourselves
                    // (thus admiting that yet again the ADSI WinNT
                    // provider offers very little value).
                    // NTRAID#NTBUG9-255397-2000/12/12-sburns
                                                                                   
                    if (hr != HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE))
                    {
                       // squeltch the error result

                       DBG_OUT_HRESULT(hr);                                 
                       hr = S_OK;
                    }

                    pADs->Release();
                    pADs = NULL;
                }

                if (FAILED(hr))
                {
                    m_pADsContainer->Release();
                    m_pADsContainer = NULL;
                }
            }
        }

        //
        // ADsOpenObject of the container path using NULL credentials
        // failed.  If the failure cannot be cured by binding with
        // different credentials, give up.
        //

        if (FAILED(hr))
        {
            if (IsCredError(hr))
            {
                Dbg(DEB_BIND,
                    "NULL credentials returned credential hr %#x\n",
                    hr);
                _SetFlag(SRVINF_REQUIRES_CREDENTIALS);

                //
                // Save off the credential related error; this will be returned
                // as the result of attempting to bind if the user cancels the
                // credential dialog.
                //

                m_hrLastCredError = hr;
            }
            else
            {
                Dbg(DEB_ERROR,
                    "CServerInfo::Init ADsOpenObject(%ws,NULL,NULL) hr=0x%x\n",
                    m_strOriginalContainerPath.c_str(),
                    hr);
                ULONG ulADsLastError;
                WCHAR wzError[MAX_PATH];
                WCHAR wzProvider[MAX_PATH];

                HRESULT hr2 = ADsGetLastError(&ulADsLastError,
                                              wzError,
                                              ARRAYLEN(wzError),
                                              wzProvider,
                                              ARRAYLEN(wzProvider));

                if (SUCCEEDED(hr2))
                {
                    Dbg(DEB_ERROR, "ADsGetLastError returns:\n");
                    Dbg(DEB_ERROR, "  Error Code    %#x\n", ulADsLastError);
                    Dbg(DEB_ERROR, "  Error Message %ws\n", wzError);
                    Dbg(DEB_ERROR, "  Provider      %ws\n", wzProvider);

                    if (ulADsLastError)
                    {
                        hr = ulADsLastError;
                    }
                }
                else
                {
                    DBG_OUT_HRESULT(hr2);
                }
                break;
            }
        }

        hr = _RepeatableInit(hwnd, riid, ppv);
    } while (0);

    if (FAILED(hr) && m_pADsContainer)
    {
        m_pADsContainer->Release();
        m_pADsContainer = NULL;
    }

    SysFreeString(bstrProvider);
    SAFE_RELEASE(pADs);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::_RepeatableInit
//
//  Synopsis:   Attempt to complete the initialization of this begun by the
//              Init() method.
//
//  Arguments:  [hwnd] - for binding
//              [riid] - identifies desired interface
//              [ppv]  - on success filled with requested interface
//
//  Returns:    HRESULT
//
//  History:    06-06-2000   DavidMun   Created
//
//  Notes:      Initializing this requires binding; if the bind requires
//              the user to enter credentials, and the user hits the Cancel
//              button in the credential prompt, this method will exit with
//              a failure code.
//
//              If the user then repeats the action which requires
//              initializing this, _RepeatableInit() will be called again,
//              giving the user another chance to enter credentials.
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::_RepeatableInit(
    HWND hwnd,
    REFIID riid,
    VOID **ppv)
{
    TRACE_METHOD(CServerInfo, _RepeatableInit);

    HRESULT hr = S_OK;
    WCHAR   wzUserName[MAX_PATH];
    WCHAR   wzPassword[MAX_PATH];
    Bstr    bstrContainerPath;
    IADs   *pADs = NULL;
    BSTR    bstrDN = NULL;

    do
    {
        BOOL fUsedDefaultCreds = FALSE;
        BOOL fBinderHadDefaultCreds = FALSE;
        BOOL fPromptedForCreds = FALSE;

        if (_IsFlagSet(SRVINF_REQUIRES_CREDENTIALS))
        {
            ASSERT(IsCredError(m_hrLastCredError));

            if (_IsFlagSet(SRVINF_REQUIRES_NON_DEFAULT_CREDENTIALS))
            {
                Dbg(DEB_BIND, "Previous call tried default creds\n");
                fBinderHadDefaultCreds = TRUE;
                fPromptedForCreds = TRUE;

                hr = _AskForCreds(hwnd, wzUserName, wzPassword);
                BREAK_ON_FAIL_HRESULT(hr);
            }
            else
            {
                //
                // Obtaining the container interface requires credentials.  If
                // there are default credentials available from the binder, try
                // using those first.  If they aren't available or result in a
                // credential error, go into a loop prompting for and using
                // credentials from user.
                //

                g_pBinder->GetDefaultCreds(m_flProvider,
										   wzUserName, 
										   wzPassword);

                if (*wzUserName)
                {
                    Dbg(DEB_BIND, "Using default credentials (%ws)\n", wzUserName);
                    fBinderHadDefaultCreds = TRUE;
                    fUsedDefaultCreds = TRUE; // will use on entry to while(TRUE) loop
                }
                else
                {
                    Dbg(DEB_BIND, "No default credentials, prompting\n", hr);
                    fPromptedForCreds = TRUE;
                    hr = _AskForCreds(hwnd, wzUserName, wzPassword);
                    BREAK_ON_FAIL_HRESULT(hr);
                }
            }

            ASSERT(!m_strOriginalContainerPath.empty());

            while (TRUE)
            {
                //
                // Since we're in this loop only because credentials are
                // required, we must have some for the bind we're about to
                // attempt.
                //
                // Creds are supplied by the user in response to a prompt
                // from this method.  The first set ever entered is stored
                // as the default set.
                //
                // If a default set is available it will be used first, or
                // else we should have just prompted for creds during this
                // execution of this method.
                //
                // Assert that we used one of these two methods.  Note that
                // only on the first pass of this loop could we assert that
                // exactly one method had been used.
                //

                ASSERT(fPromptedForCreds || fUsedDefaultCreds);

                {
                    TIMER("ADsOpenObject(%ws,%ws)",
                          m_strOriginalContainerPath.c_str(),
                          wzUserName);

                    ASSERT(!m_pADsContainer);
                    hr = _MyADsOpenObject((PWSTR)m_strOriginalContainerPath.c_str(),
                                       wzUserName,
                                       wzPassword,
                                       IID_IADsContainer,
                                       (void**)&m_pADsContainer);
                }

                
                if (SUCCEEDED(hr))
                {
                    if (_IsFlagSet(SRVINF_WINNT_DOMAIN_OBJECT) ||
                        _IsFlagSet(SRVINF_WINNT_COMPUTER_OBJECT))
                    {
                        //
                        // Well, almost.  binding to WinNT for domain object
                        // can succeed, however actually trying to get attributes from
                        // it can fail with ERROR_LOGON_FAILURE.
                        //
                        // Binding using winnt provider to a computer object can
                        // succeed, but reading attributes can fail with
                        // E_ACCESSDENIED.  This is because ADSI caches some items
                        // and doesn't actually attempt to connect until forced to.
                        //

                        //Well we cannot assume that we will have access to processor
                        //or MinPasswordLength properties. I have seen intances, most
                        //notably when binding to redmond or ntdev dcs that reading Processor
                        //fails with ACCESS_DENIED error, but if i ignore that error
                        //Everything goes sucessfully. This check is not correct.

                        // sburns 12/7/2000, that's well and good, but if you
                        // don't read some properties, you have the problem
                        // with adsi delaying the connect, and you therefore
                        // cause regression bug 245866.

                        hr = m_pADsContainer->QueryInterface(IID_IADs, (void**)&pADs);

                        if (SUCCEEDED(hr))
                        {
                            Variant var;

                            if (_IsFlagSet(SRVINF_WINNT_DOMAIN_OBJECT))
                            {
                                hr = pADs->Get(L"MinPasswordLength", &var);
                            }
                            else
                            {
                               // NTRAID#NTBUG9-245866-2000/12/11-sburns

                              // Evidently, administrators can read the
                              // Processor attribute, but not plain users.

                              // workaround for the adsi workaround is to
                              // therefore ignore the result of the Get.
                              // How's that for elegant?
                              
                              hr = pADs->Get(L"Processor", &var);

                              // The Get call could fail for a number of
                              // reasons.  The remote machine might not be
                              // running the remote registry service, the
                              // creds supplied by the user might be bad, the
                              // creds supplied might be good, but
                              // insufficient to read the processor type from
                              // the remote reg, etc.
                              // 
                              // The error condition we're interested in is
                              // bad creds. In that case, the error returned
                              // is logon failure.  All other failures don't
                              // matter here, since all we interested
                              // in is making sure adsi opens a connection to
                              // the remote machine.
                              //                                     
                              // CODEWORK: the way to fix this is 1) pound on
                              // ADSI dev for a flag to ADsOpenObject that
                              // means "skip your connection optimization", or
                              // 2) do the connection management ourselves
                              // (thus admiting that yet again the ADSI WinNT
                              // provider offers very little value).
                              // NTRAID#NTBUG9-255397-2000/12/12-sburns
                                                                                             
                              if (hr != HRESULT_FROM_WIN32(ERROR_LOGON_FAILURE))
                              {
                                 // squeltch the error result

                                 DBG_OUT_HRESULT(hr);                                 
                                 hr = S_OK;
                              }
                            }
                            pADs->Release();
                            pADs = NULL;
                        }

                        if (FAILED(hr))
                        {
                            m_pADsContainer->Release();
                            m_pADsContainer = NULL;
                        }
                    }
                }
                
                //
                // If the three clauses in the following if statement are
                // true then tell the user the bind failed.  The three
                // clauses are:
                //
                // 1. the bind failed.
                //
                // 2. the bind attempt was not with the default credentials or
                // the error was not credential related.  In other words,
                // don't notify the user that there was a credential error
                // using the default credentials.
                //
                // 3. it is NOT the case that we got a non-credential related
                // error on the very first attempt to bind.  This can happen
                // if the Init method didn't attempt a bind because the user
                // is logged on locally and the server is remote.
                //

                if (FAILED(hr) && // clause 1
                    (fPromptedForCreds || !IsCredError(hr)) && // clause 2
                    !(!IsCredError(hr) && _IsFlagSet(SRVINF_USER_LOCAL_SERVER_REMOTE))) // clause 3
                {
                    DBG_OUT_HRESULT(hr);

                    ULONG ulADsLastError;
                    WCHAR wzError[MAX_PATH];
                    WCHAR wzProvider[MAX_PATH];

                    HRESULT hr2 = ADsGetLastError(&ulADsLastError,
                                                  wzError,
                                                  ARRAYLEN(wzError),
                                                  wzProvider,
                                                  ARRAYLEN(wzProvider));

                    if (SUCCEEDED(hr2))
                    {
                        Dbg(DEB_ERROR, "ADsGetLastError returns:\n");
                        Dbg(DEB_ERROR, "  Error Code    %#x\n", ulADsLastError);
                        Dbg(DEB_ERROR, "  Error Message %ws\n", wzError);
                        Dbg(DEB_ERROR, "  Provider      %ws\n", wzProvider);
                    }
                    else
                    {
                        DBG_OUT_HRESULT(hr2);
                    }

                    String strError(GetErrorMessage(hr));

                    _PopupCredErr(hwnd,
                                  IDS_BIND_ERROR,
                                  wzUserName,
                                  strError.c_str());
                }

                //
                // If the bind succeeded, or failed but not because of a
                // problem with the credentials, get out of this bind/prompt
                // loop.
                //

                if (SUCCEEDED(hr) || !IsCredError(hr))
                {
                    if (!fBinderHadDefaultCreds)
                    {
                        ASSERT(fPromptedForCreds);

                        m_pBinder->SetDefaultCreds(wzUserName, 
												   wzPassword);
                    }
                    break;
                }

                if (fUsedDefaultCreds && IsCredError(hr))
                {
                    //
                    // The binder had default credentials, and using them
                    // resulted in a credential error.  Therefore, completing
                    // this bind requires the use of non-default credentials.
                    //

                    _SetFlag(SRVINF_REQUIRES_NON_DEFAULT_CREDENTIALS);
                }

                Dbg(DEB_ERROR,
                    "ADsOpenObject(%ws) 0x%x\n",
                    m_strOriginalContainerPath.c_str(),
                    hr);

                fPromptedForCreds = TRUE;
                hr = _AskForCreds(hwnd, wzUserName, wzPassword);
                BREAK_ON_FAIL_HRESULT(hr);
            }
            BREAK_ON_FAIL_HRESULT(hr);
        }

        //
        // Binding to container path without creds or with those in
        // wzUserName and wzPassword succeeded.  If caller wants also
        // a direct bind (i.e., cannot be done by GetObject on container)
        // do that now.
        //

        if (_IsFlagSet(SRVINF_SERVER_NEQ_DN))
        {
            ASSERT(ppv);

            if (_IsFlagSet(SRVINF_REQUIRES_CREDENTIALS))
            {
                TIMER("ADsOpenObject(%ws,%ws)",
                      m_strOriginalPath.c_str(),
                      wzUserName);

                hr = _MyADsOpenObject(const_cast<PWSTR>(m_strOriginalPath.c_str()),
                                   wzUserName,
                                   wzPassword,
                                   riid,
                                   ppv);
            }
            else
            {
                TIMER("ADsOpenObject(%ws,NULL,NULL)", m_strOriginalPath.c_str());

                hr = _MyADsOpenObject(const_cast<PWSTR>(m_strOriginalPath.c_str()),
                                   NULL,
                                   NULL,
                                   riid,
                                   ppv);
            }
        }

        //
        // Get proper path from container and store its DN
        //

        hr = m_pADsContainer->QueryInterface(IID_IADs, (void**)&pADs);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = pADs->get_ADsPath(&bstrContainerPath);
        BREAK_ON_FAIL_HRESULT(hr);

        Dbg(DEB_BIND, "Container path is '%ws'\n", bstrContainerPath.c_str());

        if (m_flProvider == PROVIDER_WINNT)
        {
            //
            // For a WinNT path, the DN is every element past the first.
            //
            // WinNT://FOO/BAR/BAZ  =>  "BAR/BAZ"
            // WinNT://FOO/BAR      =>  "BAR"
            // WinNT://FOO          =>  <no DN>
            //

            PWSTR pwzDnStart = bstrContainerPath.c_str() + lstrlen(c_wzWinNTPrefix);
            pwzDnStart = wcschr(pwzDnStart, L'/');

            if (pwzDnStart)
            {
                NewDupStr(&m_pwzDN, pwzDnStart + 1);
            }
        }
        else
        {
            hr = g_pADsPath->SetRetrieve(ADS_SETTYPE_FULL,
                                         bstrContainerPath.c_str(),
                                         ADS_FORMAT_X500_DN,
                                         &bstrDN);
            BREAK_ON_FAIL_HRESULT(hr);

            if (!bstrDN || !*bstrDN)
            {
                Dbg(DEB_BIND, "Container path has no DN\n");
            }
            else
            {
                NewDupStr(&m_pwzDN, bstrDN);
                Dbg(DEB_BIND, "container path X500 DN is '%ws'\n", m_pwzDN);
            }
        }

        //
        // We got a container.  If the path is a WinNT provider
        // then there is no name translate interface or root dse to
        // get, so we're done.
        //
        // Get a name translate interface and RootDSE object too if
        // credentials are required but default credentials were NOT used.
        //
        // We need to do this now because the name translate interface has
        // to be initialized with credentials, which, since they aren't the
        // default credentials, won't be available on exit from this
        // routine.
        //

        if (m_flProvider == PROVIDER_WINNT)
        {
            break;
        }

        if (_IsFlagSet(SRVINF_REQUIRES_NON_DEFAULT_CREDENTIALS))
        {
            hr = _InitNameTranslate(wzUserName, wzPassword);
            BREAK_ON_FAIL_HRESULT(hr);

            (void) _InitRootDSE(wzUserName, wzPassword);
        }
    } while (0);

    ZeroMemory(wzPassword, sizeof(wzPassword));

    if (FAILED(hr) && m_pADsContainer)
    {
        m_pADsContainer->Release();
        m_pADsContainer = NULL;
    }

    if (FAILED(hr) && m_pADsNameTranslate)
    {
        m_pADsNameTranslate->Release();
        m_pADsNameTranslate = NULL;
    }

    SysFreeString(bstrDN);
    SAFE_RELEASE(pADs);
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::_InitNameTranslate
//
//  Synopsis:   Create and initialize an instance of the IADsNameTranslate
//              interface focused on the domain represented by this.
//
//  Arguments:  [wzUserName] - NULL or non-default credentials
//              [wzPassword] - NULL or non-default credentials
//
//  Returns:    HRESULT
//
//  History:    5-11-1999   davidmun   Created
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::_InitNameTranslate(
    PWSTR wzUserName,
    PWSTR wzPassword)
{
    TRACE_METHOD(CServerInfo, _InitNameTranslate);

    HRESULT hr = S_OK;
    WCHAR   wzDefaultUserName[MAX_PATH];
    WCHAR   wzDefaultPassword[MAX_PATH];
    PDOMAIN_CONTROLLER_INFO pdci = NULL;
    PDOMAIN_CONTROLLER_INFO pdci2 = NULL;
    PWSTR pwzWhack = NULL;

    do
    {
        ASSERT(!m_pADsNameTranslate);
        hr = CoCreateInstance(CLSID_NameTranslate,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IADsNameTranslate,
                              (PVOID *)&m_pADsNameTranslate);
        BREAK_ON_FAIL_HRESULT(hr);

        //
        // The domain with which to initialize the name translate interface
        // is the same as the server, except that a port number must be
        // stripped off if present.
        //

        WCHAR wzServerNoPort[MAX_PATH];

        lstrcpy(wzServerNoPort, m_wzServer);
        PWSTR pwzColon = wcschr(wzServerNoPort, L':');

        if (pwzColon)
        {
            *pwzColon = L'\0';
        }

        PWSTR pwzUserName = NULL;
        PWSTR pwzPassword = NULL;
        PWSTR pwzLogonDomain = NULL;

        if (_IsFlagSet(SRVINF_REQUIRES_CREDENTIALS))
        {
            //
            // Credentials are required.  If non-default creds are required,
            // they've been passed in, otherwise the arguments are NULL and
            // we need to ask the binder for the creds.
            //

            if (!wzUserName)
            {
                g_pBinder->GetDefaultCreds(m_flProvider,
										   wzDefaultUserName, 
										   wzDefaultPassword);
                pwzWhack = wcschr(wzDefaultUserName, L'\\');
                pwzUserName = wzDefaultUserName;
                pwzPassword = wzDefaultPassword;
            }
            else
            {
                pwzWhack = wcschr(wzUserName, L'\\');
                pwzUserName = wzUserName;
                pwzPassword = wzPassword;
            }

            if (pwzWhack)
            {
                *pwzWhack = L'\0';
                pwzLogonDomain = pwzUserName;
                pwzUserName = pwzWhack + 1;
            }
            else
            {
                pwzLogonDomain = NULL;
            }
        }

        if (_IsFlagSet(SRVINF_SERVER_COMPONENT_IS_COMPUTER))
        {
            //
            // Caller specified a DC name, initialize with that
            // specific DC so name translate is sure to find objects which
            // have just been added there.
            //

            if (_IsFlagSet(SRVINF_REQUIRES_CREDENTIALS))
            {
                TIMER("IADsNameTranslate::InitEx(ADS_NAME_INITTYPE_SERVER, %ws, %ws, %ws)",
                      wzServerNoPort,
                      CHECK_NULL(pwzUserName),
                      CHECK_NULL(pwzLogonDomain));

                hr = m_pADsNameTranslate->InitEx(ADS_NAME_INITTYPE_SERVER,
                                                  wzServerNoPort,
                                                  pwzUserName,
                                                  pwzLogonDomain,
                                                  pwzPassword);
                CHECK_HRESULT(hr);
            }
            else
            {
                TIMER("IADsNameTranslate::Init(ADS_NAME_INITTYPE_SERVER, %ws)",
                      wzServerNoPort);

                hr = m_pADsNameTranslate->Init(ADS_NAME_INITTYPE_SERVER,
                                                  wzServerNoPort);
                CHECK_HRESULT(hr);
            }
            break;
        }

        ULONG ulResult;

        //
        // Need to init name translate to domain with name in
        // wzServerNoPort.  First see what DsGetDcName has in its
        // cache.  (If nothing is cached yet, this just means DsBind's
        // call will be fast).
        //

        ulResult = DsGetDcName(NULL,
                               wzServerNoPort,
                               NULL,
                               NULL,
                               0,
                               &pdci);

        if (ulResult != NO_ERROR)
        {
            ASSERT(!pdci);
            Dbg(DEB_WARN,
                "first DsGetDcName for domain %ws returned %uL\n",
                wzServerNoPort,
                ulResult);
        }

        //
        // Now attempt the name translate init.
        //

        if (_IsFlagSet(SRVINF_REQUIRES_CREDENTIALS))
        {
            TIMER("IADsNameTranslate::InitEx(ADS_NAME_INITTYPE_DOMAIN, %ws, %ws, %ws)",
                  wzServerNoPort,
                  CHECK_NULL(pwzUserName),
                  CHECK_NULL(pwzLogonDomain));

            hr = m_pADsNameTranslate->InitEx(ADS_NAME_INITTYPE_DOMAIN,
                                             wzServerNoPort,
                                             pwzUserName,
                                             pwzLogonDomain,
                                             pwzPassword);
            CHECK_HRESULT(hr);
        }
        else
        {
            TIMER("IADsNameTranslate::Init(ADS_NAME_INITTYPE_DOMAIN, %ws)",
                  wzServerNoPort);

            hr = m_pADsNameTranslate->Init(ADS_NAME_INITTYPE_DOMAIN,
                                           wzServerNoPort);
            CHECK_HRESULT(hr);
        }

        if (FAILED(hr))
        {
            //
            // Name translate init(ex) failed.  It may have been because
            // the cached DC name for domain wzServerNoPort is for a DC
            // that's down.  Try forcing rediscovery of a DC, and if that
            // gives a DC different than the original one, try the name
            // translate init again.
            //

            ulResult = DsGetDcName(NULL,
                                   wzServerNoPort,
                                   NULL,
                                   NULL,
                                   DS_FORCE_REDISCOVERY,
                                   &pdci2);

            if (ulResult != NO_ERROR)
            {
                Dbg(DEB_ERROR,
                    "DsGetDcName (2) for domain %ws returned %uL\n",
                    wzServerNoPort,
                    ulResult);
                hr = HRESULT_FROM_WIN32(ulResult);
                break;
            }

            if (!pdci ||
                lstrcmp(pdci->DomainControllerName,
                        pdci2->DomainControllerName))
            {
                if (pdci)
                {
                    Dbg(DEB_TRACE,
                        "DC changed from %ws to %ws, retrying\n",
                        pdci->DomainControllerName,
                        pdci2->DomainControllerName);
                }
                else
                {
                    Dbg(DEB_TRACE,
                        "second DsGetDcName (force) found DC %ws\n",
                        pdci2->DomainControllerName);
                }

                if (_IsFlagSet(SRVINF_REQUIRES_CREDENTIALS))
                {
                    TIMER("IADsNameTranslate::InitEx(ADS_NAME_INITTYPE_DOMAIN, %ws, %ws, %ws)",
                          wzServerNoPort,
                          CHECK_NULL(pwzUserName),
                          CHECK_NULL(pwzLogonDomain));

                    hr = m_pADsNameTranslate->InitEx(ADS_NAME_INITTYPE_DOMAIN,
                                                     wzServerNoPort,
                                                     pwzUserName,
                                                     pwzLogonDomain,
                                                     pwzPassword);
                    CHECK_HRESULT(hr);
                }
                else
                {
                    TIMER("IADsNameTranslate::Init(ADS_NAME_INITTYPE_DOMAIN, %ws)",
                          wzServerNoPort);

                    hr = m_pADsNameTranslate->Init(ADS_NAME_INITTYPE_DOMAIN,
                                                   wzServerNoPort);
                    CHECK_HRESULT(hr);
                }
            }
            else
            {
                Dbg(DEB_TRACE,
                    "Not retrying since only DC reported is %ws\n",
                    pdci->DomainControllerName);
            }
        }
    }
    while (0);

    if (pwzWhack)
    {
        *pwzWhack = L'\\';
    }

    if (pdci)
    {
        NetApiBufferFree(pdci);
    }

    if (pdci2)
    {
        NetApiBufferFree(pdci2);
    }

    ZeroMemory(wzDefaultPassword, sizeof wzDefaultPassword);
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::_InitRootDSE
//
//  Synopsis:   Bind to the RootDSE object and hold onto an interface in
//              m_pADsRootDSE.
//
//  Arguments:  [wzUserName] - NULL or non-default credentials
//              [wzPassword] - NULL or non-default credentials
//
//  Returns:    HRESULT
//
//  History:    5-11-1999   davidmun   Created
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::_InitRootDSE(
    PWSTR wzUserName,
    PWSTR wzPassword)
{
    TRACE_METHOD(CServerInfo, _InitRootDSE);

    HRESULT hr = S_OK;
    WCHAR wzRootDSEPath[MAX_PATH];

    wsprintf(wzRootDSEPath, L"LDAP://%ws/RootDSE", m_wzServer);

    do
    {
        if (!_IsFlagSet(SRVINF_REQUIRES_CREDENTIALS))
        {
            {
                TIMER("CServerInfo-ADsOpenObject(%ws,NULL,NULL)", wzRootDSEPath);

                hr = _MyADsOpenObject(wzRootDSEPath,
                                   NULL,
                                   NULL,
                                   IID_IADs,
                                   (void**)&m_pADsRootDSE);
            }
            CHECK_HRESULT(hr);
            break;
        }

        //
        // Credentials are required.  Either they were passed in or
        // we can use the default.
        //

        if (wzUserName)
        {
            TIMER("CServerInfo-ADsOpenObject(%ws,%ws)",
                  wzRootDSEPath,
                  wzUserName);

            hr = _MyADsOpenObject(wzRootDSEPath,
                               wzUserName,
                               wzPassword,
                               IID_IADs,
                               (void**)&m_pADsRootDSE);
            CHECK_HRESULT(hr);
        }
        else
        {
            WCHAR   wzDefaultUserName[MAX_PATH];
            WCHAR   wzDefaultPassword[MAX_PATH];

            g_pBinder->GetDefaultCreds(PROVIDER_LDAP,
									   wzDefaultUserName, 
									   wzDefaultPassword);

            {
                TIMER("CServerInfo-ADsOpenObject(%ws,%ws)",
                      wzRootDSEPath,
                      wzDefaultUserName);

                hr = _MyADsOpenObject(wzRootDSEPath,
                                   wzDefaultUserName,
                                   wzDefaultPassword,
                                   IID_IADs,
                                   (void**)&m_pADsRootDSE);
            }
            CHECK_HRESULT(hr);
        }


    } while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::~CServerInfo
//
//  Synopsis:   dtor
//
//  History:    04-26-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

CServerInfo::~CServerInfo()
{
    TRACE_DESTRUCTOR(CServerInfo);
    DEBUG_DECREMENT_INSTANCE_COUNTER(CServerInfo);

    SAFE_RELEASE(m_pADsContainer);
    SAFE_RELEASE(m_pADsNameTranslate);
    SAFE_RELEASE(m_pADsRootDSE);

    delete [] m_pwzDN;
    DeleteCriticalSection(&m_cs);
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::_AskForCreds
//
//  Synopsis:   Dispatch based on whether we're running in the thread that
//              created [hwndParent].
//
//  Arguments:  [hwndParent] - parent for modal password dialog
//              [wzUserName] - buffer to fill with name entered by user
//              [wzPassword] - buffer to fill with password entered by user
//
//  Returns:    S_OK if user enters credentials.
//              E_* if password dialog couldn't be opened.
//              Last credential error if user cancels password dialog.
//
//  Modifies:   *[wzUserName], *[wzPassword]
//
//  History:    04-29-1998   DavidMun   Created
//
//  Notes:      Called by CServerInfo::OpenObject when it gets a credential
//              error.
//
//              This method blocks until password dialog is closed.
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::_AskForCreds(
    HWND hwndParent,
    PWSTR wzUserName,
    PWSTR wzPassword)
{
    TRACE_METHOD(CServerInfo, _AskForCreds);

    HRESULT hr;

    //
    // This method is called via g_pBinder->BindToObject which itself may
    // be called from either thread.
    //
    // If we're running in the primary thread, use SendMessage to call
    // the routine that invokes the password dialog.
    //
    // If in non-primary thread post message to main thread to
    // pop up password dialog, then wait on event for it to complete.
    //

    ASSERT(!hwndParent || IsWindow(hwndParent));

    if (!hwndParent
        || GetWindowLongPtr(hwndParent, DWLP_DLGPROC) != (LONG_PTR) CDlg::_DlgProc)
    {
        Dbg(DEB_TRACE, "hwndParent = %#x, invoking password dialog directly\n", hwndParent);
        CPasswordDialog PasswordDlg(m_flProvider,
                                    m_wzServer,
                                    wzUserName,
                                    wzPassword);

        hr = PasswordDlg.DoModalDialog(hwndParent);
    }
    else if (GetWindowThreadProcessId(hwndParent, NULL) == GetCurrentThreadId())
    {
        hr = _AskForCredsViaSendMessage(hwndParent, wzUserName, wzPassword);
    }
    else
    {
        hr = _AskForCredsViaPostMessage(hwndParent, wzUserName, wzPassword);
    }

    if (hr == S_FALSE)
    {
        hr = m_hrLastCredError;
    }
    else if (SUCCEEDED(hr))
    {
        //
        // If the username is neither in NT4 (domain\user) or UPN
        // (user@domain) format, then the bind will definitely fail.
        // If that's the case, change the name to domain\user, where
        // domain is the name of the thing we're trying to get access
        // to.
        //

        if (!wcschr(wzUserName, L'\\') && !wcschr(wzUserName, L'@'))
        {
            String strNewName(m_wzServer);

            //
            // Strip port number, if any
            //

            if (strNewName.find(L':') != String::npos)
            {
                strNewName.erase(strNewName.find(L':'),
                                 String::npos);
            }

            //
            // If the server looks like a DNS name (contains at least one
            // '.' and one alpha character), use UPN format.
            // Otherwise assume it is a netbios or ip address and use NT4
            // format.
            //

            if (strNewName.find(L'.') != String::npos &&
                find_if(strNewName.begin(), strNewName.end(), IsCharAlpha) !=
                strNewName.end())
            {
                strNewName.insert(0, L"@");
                strNewName.insert(0, wzUserName);

                Dbg(DEB_TRACE,
                    "Replacing user name %ws with %ws\n",
                    wzUserName,
                    strNewName.c_str());

                lstrcpyn(wzUserName, strNewName.c_str(), MAX_PATH);
            }
            else
            {
                strNewName += L"\\";
                strNewName += wzUserName;

                Dbg(DEB_TRACE,
                    "Replacing user name %ws with %ws\n",
                    wzUserName,
                    strNewName.c_str());

                lstrcpyn(wzUserName, strNewName.c_str(), MAX_PATH);
            }
        }
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::_AskForCredsViaSendMessage
//
//  Synopsis:   Use SendMessage to call the CDsBrowseMgr routine that invokes
//              the password dialog.
//
//  Arguments:  See _AskForCreds.
//
//  Returns:    HRESULT from password dialog.
//
//  History:    04-29-1998   DavidMun   Created
//
//  Notes:      Called only from main thread.  Blocks until password dialog
//              closes.
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::_AskForCredsViaSendMessage(
    HWND hwndParent,
    PWSTR wzUserName,
    PWSTR wzPassword)
{
    TRACE_METHOD(CServerInfo, _AskForCredsViaSendMessage);
    CRED_MSG_INFO cmi = {
                            m_flProvider,
                            m_wzServer,
                            wzUserName,
                            wzPassword,
                            NULL,
                            S_OK
                        };

    SendMessage(hwndParent, OPM_PROMPT_FOR_CREDS, 0, (LPARAM)&cmi);
    return cmi.hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::_AskForCredsViaPostMessage
//
//  Synopsis:   Request that the main thread put up the password dialog.
//
//  Arguments:  See _AskForCreds.
//
//  Returns:    HRESULT from password dialog.
//
//  History:    04-29-1998   DavidMun   Created
//
//  Notes:      Called only from worker thread.  Blocks until main thread
//              sets event after password dialog closes.
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::_AskForCredsViaPostMessage(
    HWND hwndParent,
    PWSTR wzUserName,
    PWSTR wzPassword)
{
    TRACE_METHOD(CServerInfo, _AskForCredsViaPostMessage);
    ASSERT(hwndParent && IsWindow(hwndParent));

    CRED_MSG_INFO cmi = {
                            m_flProvider,
                            m_wzServer,
                            wzUserName,
                            wzPassword,
                            NULL,
                            S_OK
                        };

    cmi.hPrompt = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (!cmi.hPrompt)
    {
        DBG_OUT_LASTERROR;
        cmi.hr = HRESULT_FROM_LASTERROR;
        return cmi.hr;
    }

    PostMessage(hwndParent, OPM_PROMPT_FOR_CREDS, 0, (LPARAM)&cmi);

    WaitForSingleObject(cmi.hPrompt, INFINITE);
    CloseHandle(cmi.hPrompt);
    return cmi.hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::_PopupCredErr
//
//  Synopsis:   Pop up a dialog indicating a failure with the credentials
//              the user entered and block until the dialog is dismissed
//
//  Arguments:  [hwnd]        - parent wiindow
//              [ids]         - resource id of dialog message
//              [pwzUserName] - name used in creds
//              [pwzError]    - error received when using them
//
//  History:    06-23-2000   DavidMun   Created
//
//  Notes:      This method may safely be called from the worker thread
//
//---------------------------------------------------------------------------

void
CServerInfo::_PopupCredErr(
    HWND hwnd,
    ULONG ids,
    PCWSTR pwzUserName,
    PCWSTR pwzError)
{
    TRACE_METHOD(CServerInfo, _PopupCredErr);

    //
    // If we're in same thread that created [hwnd], just pop up the message
    //

    if (!hwnd || GetWindowThreadProcessId(hwnd, NULL) == GetCurrentThreadId())
    {
        PopupMessage(hwnd, ids, pwzUserName, pwzError);
        return;
    }

    //
    // We're not running in the thread that created [hwnd], so post a message
    // to it and ask it to display message.
    //

    POPUP_MSG_INFO mi = {
                            hwnd,
                            ids,
                            pwzUserName,
                            pwzError,
                            NULL
                        };

    mi.hPrompt = CreateEvent(NULL, FALSE, FALSE, NULL);

    if (mi.hPrompt)
    {
        PostMessage(hwnd,
                    OPM_POPUP_CRED_ERROR,
                    0,
                    reinterpret_cast<LPARAM>(&mi));
        WaitForSingleObject(mi.hPrompt, INFINITE);
        CloseHandle(mi.hPrompt);
    }
    else
    {
        DBG_OUT_LASTERROR;
    }
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::OpenObject
//
//  Synopsis:   Return the requested interface on the object with ADsPath
//              [pwzPath].
//
//  Arguments:  [hwnd]         - used as parent for modal password dialog.
//              [pwzPath]      - ads path of object to open; must have
//                                server portion of m_wzServer.
//              [riid]         - requested interface
//              [ppv]          - out pointer for interface instance
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppv]
//
//  History:    04-29-1998   DavidMun   Created
//
//  Notes:      Called only by CBinder::BindToObject.
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::OpenObject(
    HWND    hwnd,
    PCWSTR pwzPath,
    REFIID riid,
    LPVOID *ppv)
{
    Dbg(DEB_BIND, "CServerInfo::OpenObject(%x) '%ws'\n", this, pwzPath);
    //ASSERT(hwnd);

    HRESULT hr = S_OK;
    CWaitCursor Hourglass;

    //
    // Init out pointer for failure
    //

    *ppv = NULL;


    do
    {
        //
        // If we don't have container interface, we can't get the object.
        //

        if (!m_pADsContainer)
        {
            if (SUCCEEDED(m_hrLastCredError))
            {
                hr = E_FAIL;
                break;
            }
            ASSERT(_IsFlagSet(SRVINF_REQUIRES_CREDENTIALS));

            //
            // The reason we don't have the container interface is because
            // the user was prompted for credentials but hit cancel.
            //

            hr = _RepeatableInit(hwnd, riid, ppv);
            BREAK_ON_FAIL_HRESULT(hr);
        }

        ASSERT(m_pADsContainer);

        //
        // We already have a container interface on the domain
        // for this path, so use it to bind to the object.
        //
        // To do that, we'll have to obtain the RDN of the object; it
        // must be relative to the path to the container.
        //
        // To obtain the RDN for pwzPath being a WinNT path, find the
        // server inside the path, and delete everything from the start
        // to the slash just past the server.  Also, if there is a
        // binding hint (",Domain" or ",Computer"), truncate that.
        //
        // To obtain the RDN for pwzPath being an LDAP path, use the
        // path cracker interface.
        //

        String strRDN;

        if (m_flProvider == PROVIDER_WINNT)
        {	
			//
			// NTRAID#NTBUG9-348828-2001/03/20-hiteshr
			// For a XWRK/X/USER, rdn was coming as
			// WRK/X/USER. 
			//
			hr = g_pADsPath->GetWinntPathRDN(pwzPath, 
											 &strRDN);
            BREAK_ON_FAIL_HRESULT(hr);            
			
			size_t idxComma = strRDN.find(L',');

            if (idxComma != String::npos)
            {
				strRDN.erase(idxComma);
			}

            Dbg(DEB_BIND, "WinNT RDN is '%ws'\n", strRDN.c_str());
        }
        else
        {
            Bstr bstrDN;

            hr = g_pADsPath->SetRetrieve(ADS_SETTYPE_FULL,
                                         pwzPath,
                                         ADS_FORMAT_X500_DN,
                                         &bstrDN);
            BREAK_ON_FAIL_HRESULT(hr);

            if (bstrDN.c_str() && *bstrDN.c_str())
            {
                if (m_pwzDN)
                {
                    PWSTR pwzMatchingDN = wcsistr(bstrDN.c_str(), m_pwzDN);

                    //
                    // Convert the DN of the object we're trying to bind to into
                    // an RDN which is relative to the container.  Do this by
                    // truncating at the substring of the object path which
                    // matches the container's DN.
                    //

                    if (!pwzMatchingDN)
                    {
                        Dbg(DEB_ERROR,
                            "no match for container DN '%ws' in object RDN '%ws', attempting direct bind\n",
                            m_pwzDN,
                            bstrDN.c_str());
                        hr = BindDirect(hwnd, pwzPath, riid, ppv);
                        break;
                    }

                    Dbg(DEB_BIND, "ldap matching DN is '%ws'\n", pwzMatchingDN);

                    strRDN = bstrDN.c_str();
                    strRDN.erase(pwzMatchingDN - bstrDN.c_str());

                    //
                    // this may leave a trailing comma, if so, zap it.
                    //

                    size_t idxLastComma = strRDN.rfind(L',');

                    if (idxLastComma != String::npos &&
                        idxLastComma == strRDN.length() - 1)
                    {
                        strRDN.erase(idxLastComma);
                    }
                }
                else
                {
                    strRDN = bstrDN.c_str();
                }
            }
            else
            {
                strRDN.erase();
            }
            Dbg(DEB_BIND, "ldap RDN is '%ws'\n", strRDN.c_str());
        }

        //
        // If there is no RDN, caller actually wants interface on
        // container.
        //

        if (strRDN.empty())
        {
            Dbg(DEB_BIND, "Empty RDN, doing QI on container\n");

            hr = m_pADsContainer->QueryInterface(riid, ppv);
            CHECK_HRESULT(hr);
            break;
        }

        IDispatch *pdisp = NULL;
        {
            TIMER("GetObject(%ws)", strRDN.c_str());
            hr = m_pADsContainer->GetObject(NULL,
                                            (PWSTR)strRDN.c_str(),
                                            &pdisp);
        }

        if (SUCCEEDED(hr))
        {
            hr = pdisp->QueryInterface(riid, ppv);
            pdisp->Release();
            break;
        }
        else
        {
            DBG_OUT_HRESULT(hr);
        }
    }
    while (0);

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::BindDirect
//
//  Synopsis:   Bind directly to [pwzPath] instead of taking the path apart
//              and retrieving the object it refers to via
//              IADsContainer::GetObject.
//
//  Arguments:  [hwnd]    - parent for modal password dialog
//              [pwzPath] - full ADsPath to bind to
//              [riid]    - interface to bind for
//              [ppv]     - filled with interface instance
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppv]
//
//  History:    5-11-1999   davidmun   Created
//
//  Notes:      This method should only be called when it is impossible to
//              use IADsContainer::GetObject, i.e., when
//              CServerInfo::OpenObject is guaranteed to fail.  See code
//              for initializing the list of WKSP objects.
//
//              Caller must Release returned interface.
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::BindDirect(
    HWND hwnd,
    PCWSTR pwzPath,
    REFIID riid,
    PVOID *ppv)
{
    TRACE_METHOD(CServerInfo, BindDirect);
    ASSERT(ppv);

    HRESULT hr = S_OK;

    if (!_IsFlagSet(SRVINF_REQUIRES_CREDENTIALS))
    {
        TIMER("ADsOpenObject(%ws,NULL,NULL)", pwzPath);

        hr = _MyADsOpenObject((PWSTR)pwzPath,
                           NULL,
                           NULL,
                           riid,
                           ppv);
        CHECK_HRESULT(hr);
        return hr;
    }

    //
    // Credentials required for bind.
    //

    WCHAR   wzUserName[MAX_PATH];
    WCHAR   wzPassword[MAX_PATH];

    if (_IsFlagSet(SRVINF_REQUIRES_NON_DEFAULT_CREDENTIALS))
    {
        hr = _AskForCreds(hwnd, wzUserName, wzPassword);

        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
            return hr;
        }
    }
    else
    {
        g_pBinder->GetDefaultCreds(m_flProvider,
								   wzUserName, 
								   wzPassword);

        //
        // The fact that SRVINF_REQUIRES_CREDENTIALS is set implies that
        // CServerInfo::Init has already been called, however _RepeatableInit
        // may not have been called, or may not have gotten creds.  If there
        // are no default creds, ask for some.
        //

        if (!*wzUserName)
        {
            Dbg(DEB_WARN, "No default credentials, prompting\n");

            hr = _AskForCreds(hwnd, wzUserName, wzPassword);

            if (SUCCEEDED(hr))
            {
                g_pBinder->SetDefaultCreds(wzUserName, 
										   wzPassword);
            }
            else
            {
                DBG_OUT_HRESULT(hr);
                return hr;
            }
        }
    }

    BOOL fFirstPass = TRUE;

    while (TRUE)
    {
        {
            TIMER("ADsOpenObject(%ws,%ws)", pwzPath, wzUserName);

            hr = _MyADsOpenObject((PWSTR)pwzPath,
                               wzUserName,
                               wzPassword,
                               riid,
                               ppv);
        }

        //
        // If the bind failed, tell the user, unless the bind
        // attempt was with the default credentials.
        //

        if (FAILED(hr) &&
            !(fFirstPass && !_IsFlagSet(SRVINF_REQUIRES_NON_DEFAULT_CREDENTIALS)))
        {
            DBG_OUT_HRESULT(hr);
            String strError(GetErrorMessage(hr));

            _PopupCredErr(hwnd,
                          IDS_BIND_ERROR,
                          wzUserName,
                          strError.c_str());
        }

        if (SUCCEEDED(hr) || !IsCredError(hr))
        {
            break;
        }

        fFirstPass = FALSE;

        Dbg(DEB_ERROR,
            "ADsOpenObject(%ws) 0x%x\n",
            pwzPath,
            hr);

        hr = _AskForCreds(hwnd, wzUserName, wzPassword);
        BREAK_ON_FAIL_HRESULT(hr);
    }

    ZeroMemory(wzPassword, sizeof(wzPassword));
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::GetNameTranslate
//
//  Synopsis:   Return the name translate interface for use with this
//              server, or NULL if one couldn't be created or initialized.
//
//  Arguments:  [ppNameTranslate] - out pointer for interface.
//
//  Returns:    S_OK or E_FAIL.
//
//  Modifies:   *[ppNameTranslate]
//
//  History:    04-29-1998   DavidMun   Created
//
//  Notes:      Caller must Release returned interface.
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::GetNameTranslate(
    IADsNameTranslate **ppNameTranslate)
{
    TRACE_METHOD(CServerInfo, GetNameTranslate);

    HRESULT hr = S_OK;

    if (!m_pADsNameTranslate)
    {
        hr = _InitNameTranslate(NULL, NULL);
    }

    if (m_pADsNameTranslate)
    {
        m_pADsNameTranslate->AddRef();
        *ppNameTranslate = m_pADsNameTranslate;
    }
    else
    {
        *ppNameTranslate = NULL;
    }

    return hr;
}



//+--------------------------------------------------------------------------
//
//  Member:     CServerInfo::GetRootDSE
//
//  Synopsis:   Fill *[ppADsRootDSE] with an AddRef'd instance of the
//              RootDSE object.
//
//  Arguments:  [ppADsRootDSE] - filled with pointer to interface on RootDSE
//
//  Returns:    HRESULT
//
//  Modifies:   *[ppADsRootDSE]
//
//  History:    5-11-1999   davidmun   Created
//
//  Notes:      Caller must call Release on returned interface.
//
//---------------------------------------------------------------------------

HRESULT
CServerInfo::GetRootDSE(
    IADs **ppADsRootDSE)
{
    TRACE_METHOD(CServerInfo, GetRootDSE);

    HRESULT hr = S_OK;

    if (!m_pADsRootDSE)
    {
        hr = _InitRootDSE(NULL, NULL);
    }

    if (m_pADsRootDSE)
    {
        m_pADsRootDSE->AddRef();
        *ppADsRootDSE = m_pADsRootDSE;
    }
    else
    {
        *ppADsRootDSE = NULL;
    }

    return hr;
}



// Wrapper used to ensure consistent flags used.
// NTRAID#NTBUG9-107524-2000/11/13-sburns

HRESULT
CServerInfo::_MyADsOpenObject(
   PCWSTR path,
   PCWSTR username,
   PCWSTR password,
   REFIID riid,
   void** ppObject)
{
   TRACE_METHOD(CServerInfo, _MyADsOpenObject);

   HRESULT hr = S_OK;

   DWORD flags = OPEN_OBJECT_FLAGS;

   if (
      
      // we're using the LDAP provider
      
         (m_flProvider == PROVIDER_LDAP)

      // and the path contains a server component
      
      && (_IsFlagSet(SRVINF_SERVER_COMPONENT_IS_COMPUTER)) )
   {
      // we need to specify ADS_SERVER_BIND, to satisfy
      // NTRAID#NTBUG9-372285-2000/11/09-sburns

      flags |= ADS_SERVER_BIND;
   }
   
   Dbg(
      DEB_BIND,
      "CServerInfo::_MyADsOpenObject(%x) '%ws' '%ws' %x\n",
       this,
       path ? path : L"(null)",
       username ? username : L"(null)",
       flags);
                 
   hr =
      ::ADsOpenObject(
         path,
         username,
         password,
         flags,
         riid,
         ppObject);
         
   Dbg(DEB_BIND, "hr = %x\n", hr);

   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\variant.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       variant.cxx
//
//  Contents:   Implementation of Variant safe wrapper class
//
//  Classes:    Variant
//
//  History:    02-14-2000   davidmun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

//+--------------------------------------------------------------------------
//
//  Member:     Variant::operator =
//
//  Synopsis:   copy ctor
//
//  History:    03-21-2000   davidmun   Created
//
//---------------------------------------------------------------------------

Variant &
Variant::operator =(
    const Variant &rhs)
{
    do
    {
        if (&rhs.m_var == &m_var)
        {
            ASSERT(0 && "assigning to self");
            break;
        }

        VariantClear(&m_var);

        if (rhs.Type() == VT_UI8)
        {
            SetUI8(rhs.GetUI8());
            break;
        }

        HRESULT hr = VariantCopy(&m_var, (VARIANT*)&rhs.m_var);

        if (FAILED(hr))
        {
            Dbg(DEB_ERROR,
                "Error %#x copying source type %#x to dest type %#x\n",
                hr,
                V_VT((VARIANT*)&rhs.m_var),
                V_VT(&m_var));
            ASSERT(Empty());
        }
    } while (0);

    m_cArrayAccess = 0;

    return *this;
}




//+--------------------------------------------------------------------------
//
//  Member:     Variant::operator =
//
//  Synopsis:   Convert an ADS_SEARCH_COLUMN into a VARIANT
//
//  Arguments:  [ADsCol] - value to convert
//
//  History:    02-14-2000   davidmun   Created
//
//---------------------------------------------------------------------------

Variant &
Variant::operator =(
    const ADS_SEARCH_COLUMN &ADsCol)
{
    ASSERT(ADsCol.dwNumValues);

    SAFEARRAYBOUND sab = { 0, 0 };
    SAFEARRAY *psa = NULL;

    VariantClear(&m_var);
    m_cArrayAccess = 0;

    switch (ADsCol.dwADsType)
    {
    case ADSTYPE_INVALID:
        // leave variant empty
        break;

    case ADSTYPE_DN_STRING:
        V_VT(&m_var) = VT_BSTR;
        V_BSTR(&m_var) = SysAllocString(
            ADsCol.pADsValues[ADsCol.dwNumValues - 1].DNString);
        break;

    case ADSTYPE_CASE_EXACT_STRING:
        V_VT(&m_var) = VT_BSTR;
        V_BSTR(&m_var) = SysAllocString(
            ADsCol.pADsValues[ADsCol.dwNumValues - 1].CaseExactString);
        break;

    case ADSTYPE_CASE_IGNORE_STRING:
        V_VT(&m_var) = VT_BSTR;
        V_BSTR(&m_var) = SysAllocString(
            ADsCol.pADsValues[ADsCol.dwNumValues - 1].CaseIgnoreString);
        break;

    case ADSTYPE_PRINTABLE_STRING:
        V_VT(&m_var) = VT_BSTR;
        V_BSTR(&m_var) = SysAllocString(
            ADsCol.pADsValues[ADsCol.dwNumValues - 1].PrintableString);
        break;

    case ADSTYPE_NUMERIC_STRING:
        V_VT(&m_var) = VT_BSTR;
        V_BSTR(&m_var) = SysAllocString(
            ADsCol.pADsValues[ADsCol.dwNumValues - 1].NumericString);
        break;

    case ADSTYPE_OBJECT_CLASS:
        V_VT(&m_var) = VT_BSTR;
        V_BSTR(&m_var) = SysAllocString(
            ADsCol.pADsValues[ADsCol.dwNumValues - 1].ClassName);
        break;

    case ADSTYPE_BOOLEAN:
        V_VT(&m_var) = VT_BOOL;
        V_BOOL(&m_var) = static_cast<VARIANT_BOOL>(ADsCol.pADsValues[ADsCol.dwNumValues - 1].Boolean);
        break;

    case ADSTYPE_INTEGER:
        V_VT(&m_var) = VT_UI4;
        V_UI4(&m_var) = ADsCol.pADsValues[ADsCol.dwNumValues - 1].Integer;
        break;

    case ADSTYPE_OCTET_STRING:
        V_VT(&m_var) = VT_ARRAY | VT_UI1;
        sab.cElements =
            ADsCol.pADsValues[ADsCol.dwNumValues - 1].OctetString.dwLength;
        psa = SafeArrayCreate(VT_UI1, 1, &sab);
        if (psa)
        {
            CopyMemory(psa->pvData,
                       ADsCol.pADsValues[ADsCol.dwNumValues - 1].OctetString.lpValue,
                       sab.cElements);
        }
        break;

    case ADSTYPE_PROV_SPECIFIC:
        V_VT(&m_var) = VT_ARRAY | VT_UI1;
        sab.cElements =
            ADsCol.pADsValues[ADsCol.dwNumValues - 1].ProviderSpecific.dwLength;
        psa = SafeArrayCreate(VT_UI1, 1, &sab);
        if (psa)
        {
            CopyMemory(psa->pvData,
                       ADsCol.pADsValues[ADsCol.dwNumValues - 1].ProviderSpecific.lpValue,
                       sab.cElements);
        }
        break;

    case ADSTYPE_NT_SECURITY_DESCRIPTOR:
        V_VT(&m_var) = VT_ARRAY | VT_UI1;
        sab.cElements =
            ADsCol.pADsValues[ADsCol.dwNumValues - 1].SecurityDescriptor.dwLength;
        psa = SafeArrayCreate(VT_UI1, 1, &sab);
        if (psa)
        {
            CopyMemory(psa->pvData,
                       ADsCol.pADsValues[ADsCol.dwNumValues - 1].SecurityDescriptor.lpValue,
                       sab.cElements);
        }
        break;

    case ADSTYPE_UTC_TIME:
        // systemtime
        V_VT(&m_var) = VT_DATE;
        VERIFY(SystemTimeToVariantTime(
                const_cast<LPSYSTEMTIME>(&ADsCol.pADsValues[ADsCol.dwNumValues - 1].UTCTime),
                &V_DATE(&m_var)));
        break;

    case ADSTYPE_LARGE_INTEGER:
        V_VT(&m_var) = VT_I8;
        V_I8(&m_var) = ADsCol.pADsValues[ADsCol.dwNumValues - 1].LargeInteger.QuadPart;
        break;


    case ADSTYPE_CASEIGNORE_LIST:
    case ADSTYPE_OCTET_LIST:
    case ADSTYPE_POSTALADDRESS:
    case ADSTYPE_PATH:
    case ADSTYPE_TIMESTAMP:
    case ADSTYPE_BACKLINK:
    case ADSTYPE_TYPEDNAME:
    case ADSTYPE_HOLD:
    case ADSTYPE_NETADDRESS:
    case ADSTYPE_REPLICAPOINTER:
    case ADSTYPE_FAXNUMBER:
    case ADSTYPE_EMAIL:
        // according to SDK these are "mainly used for the NDS provider",
        // which object picker does not support.
        Dbg(DEB_WARN, "Ignoring NDS type value %uL\n", ADsCol.dwADsType);
        break;

    case ADSTYPE_UNKNOWN:
        // apparently this is a private internal type, we shouldn't see it
        Dbg(DEB_WARN, "Ignoring type value ADSTYPE_UNKNOWN\n");
        break;

    case ADSTYPE_DN_WITH_BINARY:
    case ADSTYPE_DN_WITH_STRING:
        // don't expect these to be exposed for querying
        Dbg(DEB_WARN, "Ignoring type value %uL\n", ADsCol.dwADsType);
        break;

    default:
        ASSERT(0 && "Variant::Variant: Unexpected ADsType");
        Dbg(DEB_WARN, "Ignoring unexpected type value %uL\n", ADsCol.dwADsType);
        break;
    }


    if (V_VT(&m_var) == VT_BSTR && !V_BSTR(&m_var) ||
        (V_VT(&m_var) & VT_ARRAY) && !psa)
    {
        V_VT(&m_var) = VT_EMPTY;
        Dbg(DEB_ERROR, "Variant::Variant: out of memory for string, throwing bad_alloc\n");
        throw bad_alloc();
    }

    if (V_VT(&m_var) & VT_ARRAY)
    {
        if (!psa)
        {
            V_VT(&m_var) = VT_EMPTY;
            Dbg(DEB_ERROR, "Variant::Variant: out of memory for array, throwing bad_alloc\n");
            throw bad_alloc();
        }

        V_ARRAY(&m_var) = psa;
        psa = NULL;
    }
    return *this;
}


void
Variant::Clear()
{
    ULONG i;

    for (i = 0; i < m_cArrayAccess; i++)
    {
        ::SafeArrayUnaccessData(V_ARRAY(&m_var));
    }
    VariantClear(&m_var);
}



HRESULT
Variant::SetBstr(
    const String &strNew)
{
    if (!Empty())
    {
        Clear();
    }

    V_VT(&m_var) = VT_BSTR;
    V_BSTR(&m_var) = SysAllocString(strNew.c_str());

    if (!V_BSTR(&m_var))
    {
        DBG_OUT_HRESULT(E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\stddbg.h ===
//____________________________________________________________________________
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 1996.
//
//  File:       StdDbg.h
//
//  Contents:   Common debug definitions.
//
//  History:    5/20/1996   RaviR   Created
//
//____________________________________________________________________________


#include "admindbg.h"
#include <tchar.h>

//
//  EXAMPLE: A debug file for component SAMPLE, with the debugging tag
//  name "Samp" is defined as shown below:
//
//
//      //
//      //  File:   SampDbg.h
//      //
//
//      #ifndef _SAMPDBG_H_
//      #define _SAMPDBG_H_
//
//      #include "stddbg.h"
//
//      #if DBG==1
//          DECLARE_DEBUG(Samp)
//          #define DBG_COMP    SampInfoLevel
//      #endif // DBG==1
//
//      #endif // _SAMPDBG_H_
//


//
//  A corresponding DECLARE_INFOLEVEL(Samp) should be implemented in a .cpp
//  file. This creates a global instance of an CDbg -> SampInfoLevel.
//  SampInfoLevel can be initialized by setting the "Samp" value under reg key
//
//    HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\AdminDebug
//
//  By defalut it is set to (DEB_ERROR | DEB_WARN)
//


//
//  ------------------------------------------------------------------------
//  Method:     CDbg::DebugOut(debug_level, lpstrfmt, ...);
//
//      Where debug_level is a combination of one or more of the DEB_XXX
//      values defined in admindbg.h. If ((SampInfoLevel & debug_level) != 0)
//      The string lpstrfmt will be printed out to the debugger.
//
//  ------------------------------------------------------------------------
//  Method:     CDbg::Trace(lpstrfmt, ...);
//
//      Same as CDbg::DebugOut, except that debug_level is internally
//      set to DEB_TRACE.
//
//  ------------------------------------------------------------------------
//  Method:     DebugMsg(file, line, message)
//
//      Force output the <file, line, message>.
//
//  ------------------------------------------------------------------------
//


#ifndef __STDDBG_HXX__
#define __STDDBG_HXX__

#undef ASSERT
#undef ASSERTMSG

//
//  C++ files redefine THIS_FILE by adding the following two lines:
//
//      #undef THIS_FILE
//      static char THIS_FILE[] = __FILE__;
//

#define THIS_FILE       __FILE__

#undef  TRACE
#undef  ASSERT
#undef  VERIFY


#if DBG==1

    #define Dbg                         DBG_COMP.DebugOut
    #define TRACE                       DBG_COMP.Trace

    // Heap checking
    extern  DWORD dwHeapChecking;
    #define DECLARE_HEAPCHECKING    DWORD dwHeapChecking = 0

    #define DEBUGCHECK \
        if ( (dwHeapChecking & 0x1) == 0x1 ) \
        { \
            HeapValidate(GetProcessHeap(),0,NULL); \
        } else 1

    #define DBG_INDENTER    \
            CIndenter Indent(&DBG_COMP)

    // Debug messages
    #define TRACE_CONSTRUCTOR(cls) \
        DEBUGCHECK; \
        Dbg(DEB_RESOURCE, _T(#cls) _T("::") _T(#cls) _T("<%x>\n"), this); \
        DBG_INDENTER;

    #define TRACE_DESTRUCTOR(cls) \
        DEBUGCHECK; \
        Dbg(DEB_RESOURCE, _T(#cls) _T("::~") _T(#cls) _T("<%x>\n"), this); \
        DBG_INDENTER;

    #define TRACE_METHOD(Class, Method) \
        DEBUGCHECK; \
        Dbg(DEB_METHOD, _T(#Class) _T("::") _T(#Method) _T("(%x)\n"), this); \
        DBG_INDENTER;

    #define TRACE_FUNCTION(Function) \
        DEBUGCHECK; \
        Dbg(DEB_FUNCTION, _T(#Function) _T("\n")); \
        DBG_INDENTER;

    #define TRACE_CONSTRUCTOR_EX(Infolevel, cls) \
        DEBUGCHECK; \
        Dbg(Infolevel, _T(#cls) _T("::") _T(#cls) _T("<%x>\n"), this); \
        DBG_INDENTER;

    #define TRACE_DESTRUCTOR_EX(Infolevel, cls) \
        DEBUGCHECK; \
        Dbg(Infolevel, _T(#cls) _T("::~") _T(#cls) _T("<%x>\n"), this); \
        DBG_INDENTER;

    #define TRACE_METHOD_EX(Infolevel, Class, Method) \
        DEBUGCHECK; \
        Dbg(Infolevel, _T(#Class) _T("::") _T(#Method) _T("(%x)\n"), this); \
        DBG_INDENTER;

    #define TRACE_FUNCTION_EX(Infolevel, Function) \
        DEBUGCHECK; \
        Dbg(Infolevel, _T(#Function) _T("\n")); \
        DBG_INDENTER;

    #define CHECK_HRESULT(hr) \
        if ( FAILED(hr) ) \
        { \
            DBG_COMP.DebugErrorX(THIS_FILE, __LINE__, hr); \
        } else 1

    #define CHECK_LASTERROR(lr) \
        if ( lr != ERROR_SUCCESS ) \
        { \
            DBG_COMP.DebugErrorL(THIS_FILE, __LINE__, lr); \
        } else 1

    #define DBG_OUT_LASTERROR \
        DBG_COMP.DebugErrorL(THIS_FILE, __LINE__, GetLastError());

    #define ASSERTMSG(x)   \
        (void)((x) || (DBG_COMP.DebugMsg(THIS_FILE, __LINE__, _T(#x)),0))

    #define VERIFYMSG(e)   ASSERTMSG(e)

    #define ASSERT(x)   Win4Assert(x)
    #define VERIFY(x)   Win4Assert(x)

#else

    inline void __cdecl __DummyDbg(ULONG, PCWSTR, ...) { }
    inline void __cdecl __DummyDbg(ULONG, LPCSTR, ...) { }
    #define Dbg             1 ? (void)0 : ::__DummyDbg

    inline void __cdecl __DummyTrace(PCWSTR, ...) { }
    inline void __cdecl __DummyTrace(LPCSTR, ...) { }
    #define TRACE           1 ? (void)0 : ::__DummyTrace

    #define TRACE_SCOPE(x)

    #define DECLARE_HEAPCHECKING
    #define DEBUGCHECK
    #define DBG_INDENTER

    #define TRACE_CONSTRUCTOR(cls)
    #define TRACE_DESTRUCTOR(cls)
    #define TRACE_METHOD(ClassName,MethodName)
    #define TRACE_FUNCTION(FunctionName)
    #define TRACE_CONSTRUCTOR_EX(Infolevel, cls)
    #define TRACE_DESTRUCTOR_EX(Infolevel, cls)
    #define TRACE_METHOD_EX(Infolevel, ClassName, MethodName)
    #define TRACE_FUNCTION_EX(Infolevel, FunctionName)

    #define CHECK_HRESULT(hr)
    #define CHECK_LASTERROR(lr)

    #define DBG_OUT_LASTERROR

    #define ASSERTMSG(e)
    #define VERIFYMSG(e)   e

    #define ASSERT(e)
    #define VERIFY(e)   e

#endif // DBG==1



#ifdef UNICODE
#define DBGSTRING %ls
#else
#define DBGSTRING %s
#endif


#define SAFEDBGBSTR(x) ((x==NULL)?L"<NULL>":x)
#define SAFEDBGTCHAR(x) ((x==NULL)?_T("<NULL>"):x)


#define ASSERT_OBJECTPTR(x) ASSERT( NULL == (x) || !::IsBadWritePtr(x,sizeof(x)) );
#define ASSERT_STRINGPTR(x) ASSERT( NULL == (x) || AfxIsValidStringPtr(x) );
#define FREE_OBJECTPTR(x) { ASSERT_OBJECTPTR(x); delete x; x = NULL; }

#endif // __STDDBG_HXX__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\src\util.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1998.
//
//  File:       util.cxx
//
//  Contents:   Miscellaneous utility functions
//
//  History:    09-18-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop

#define __THIS_FILE__   L"util"


//+--------------------------------------------------------------------------
//
//  Function:   LoadStr
//
//  Synopsis:   Load string with resource id [ids] into buffer [wszBuf],
//              which is of size [cchBuf] characters.
//
//  Arguments:  [ids]        - string to load
//              [wszBuf]     - buffer for string
//              [cchBuf]     - size of buffer
//              [wszDefault] - NULL or string to use if load fails
//
//  Returns:    S_OK or error from LoadString
//
//  Modifies:   *[wszBuf]
//
//  History:    12-11-1996   DavidMun   Created
//
//  Notes:      If the load fails and no default is supplied, [wszBuf] is
//              set to an empty string.
//
//---------------------------------------------------------------------------

HRESULT
LoadStr(
    ULONG ids,
    PWSTR wszBuf,
    ULONG cchBuf,
    PCWSTR wszDefault)
{
    HRESULT hr = S_OK;
    ULONG cchLoaded;

    cchLoaded = LoadString(g_hinst, ids, wszBuf, cchBuf);

    if (!cchLoaded)
    {
        DBG_OUT_LASTERROR;
        hr = HRESULT_FROM_WIN32(GetLastError());

        if (wszDefault)
        {
            lstrcpyn(wszBuf, wszDefault, cchBuf);
        }
        else
        {
            *wszBuf = L'\0';
        }
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   NewDupStr
//
//  Synopsis:   Allocate a copy of [wszSrc] using operator new.
//
//  Arguments:  [ppwzDup] - filled with pointer to copy of [wszSrc].
//              [wszSrc]  - string to copy
//
//  Modifies:   *[ppwzDup]
//
//  History:    10-15-1997   DavidMun   Created
//
//  Notes:      Caller must delete string
//
//---------------------------------------------------------------------------

void
NewDupStr(
    PWSTR *ppwzDup,
    PCWSTR wszSrc)
{
    if (wszSrc)
    {
        *ppwzDup = new WCHAR[lstrlen(wszSrc) + 1];
        lstrcpy(*ppwzDup, wszSrc);
    }
    else
    {
        *ppwzDup = NULL;
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   CoTaskDupStr
//
//  Synopsis:   Allocate a copy of [wzSrc] using CoTaskMemAlloc.
//
//  Arguments:  [ppwzDup] - filled with pointer to copy of [wszSrc].
//              [wszSrc]  - string to copy
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  Modifies:   *[ppwzDup]
//
//  History:    06-03-1998   DavidMun   Created
//
//  Notes:      Caller must CoTaskMemFree string
//
//---------------------------------------------------------------------------

HRESULT
CoTaskDupStr(
    PWSTR *ppwzDup,
    PCWSTR wzSrc)
{
    HRESULT hr = S_OK;

    *ppwzDup = (PWSTR) CoTaskMemAlloc(sizeof(WCHAR) *
                                            (lstrlen(wzSrc) + 1));

    if (*ppwzDup)
    {
        lstrcpy(*ppwzDup, wzSrc);
    }
    else
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(hr);
    }

    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   UnicodeStringToWsz
//
//  Synopsis:   Copy the string in [refustr] to the buffer [wszBuf],
//              truncating if necessary and ensuring null termination.
//
//  Arguments:  [refustr] - string to copy
//              [wszBuf]  - destination buffer
//              [cchBuf]  - size, in characters, of destination buffer.
//
//  Modifies:   *[wszBuf]
//
//  History:    10-15-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
UnicodeStringToWsz(
    const UNICODE_STRING &refustr,
    PWSTR wszBuf,
    ULONG cchBuf)
{
    if (!refustr.Length)
    {
        wszBuf[0] = L'\0';
    }
    else if (refustr.Length < cchBuf * sizeof(WCHAR))
    {
        CopyMemory(wszBuf, refustr.Buffer, refustr.Length);
        wszBuf[refustr.Length / sizeof(WCHAR)] = L'\0';
    }
    else
    {
        lstrcpyn(wszBuf, refustr.Buffer, cchBuf);
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   StripLeadTrailSpace
//
//  Synopsis:   Delete leading and trailing spaces from [pwz].
//
//  History:    11-22-1996   DavidMun   Created
//
//---------------------------------------------------------------------------

void
StripLeadTrailSpace(
    PWSTR pwz)
{
    size_t cchLeadingSpace = _tcsspn(pwz, TEXT(" \t"));
    size_t cch = lstrlen(pwz);

    //
    // If there are any leading spaces or tabs, move the string
    // (including its nul terminator) left to delete them.
    //

    if (cchLeadingSpace)
    {
        MoveMemory(pwz,
                   pwz + cchLeadingSpace,
                   (cch - cchLeadingSpace + 1) * sizeof(TCHAR));
        cch -= cchLeadingSpace;
    }

    //
    // Concatenate at the first trailing space
    //

    LPTSTR pwzTrailingSpace = NULL;
    LPTSTR pwzCur;

    for (pwzCur = pwz; *pwzCur; pwzCur++)
    {
        if (*pwzCur == L' ' || *pwzCur == L'\t')
        {
            if (!pwzTrailingSpace)
            {
                pwzTrailingSpace = pwzCur;
            }
        }
        else if (pwzTrailingSpace)
        {
            pwzTrailingSpace = NULL;
        }
    }

    if (pwzTrailingSpace)
    {
        *pwzTrailingSpace = TEXT('\0');
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   InvokeWinHelp
//
//  Synopsis:   Helper (ahem) function to invoke winhelp.
//
//  Arguments:  [message]                 - WM_CONTEXTMENU or WM_HELP
//              [wParam]                  - depends on [message]
//              [wszHelpFileName]         - filename with or without path
//              [aulControlIdToHelpIdMap] - see WinHelp API
//
//  History:    06-10-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

void
InvokeWinHelp(
    UINT message,
    WPARAM wParam,
    LPARAM lParam,
    PCWSTR wszHelpFileName,
    ULONG aulControlIdToHelpIdMap[])
{
    TRACE_FUNCTION(InvokeWinHelp);

    ASSERT(wszHelpFileName);
    ASSERT(aulControlIdToHelpIdMap);

    switch (message)
    {
    case WM_CONTEXTMENU:                // Right mouse click - "What's This" context menu
                WinHelp((HWND) wParam,
                wszHelpFileName,
                HELP_CONTEXTMENU,
                (DWORD_PTR) aulControlIdToHelpIdMap);
        break;

        case WM_HELP:                           // Help from the "?" dialog
    {
        const LPHELPINFO pHelpInfo = (LPHELPINFO) lParam;

        if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
        {
            WinHelp((HWND) pHelpInfo->hItemHandle,
                    wszHelpFileName,
                    HELP_WM_HELP,
                    (DWORD_PTR) aulControlIdToHelpIdMap);
        }
        break;
    }

    default:
        Dbg(DEB_ERROR, "Unexpected message %uL\n", message);
        break;
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   SetDefaultColumns
//
//  Synopsis:   Add the default ATTR_KEY values to [pvakListviewColumns]
//              for all the classes selected in look for.
//
//  Arguments:  [hwnd]                - for bind
//              [rop]                 - object picker
//              [pvakListviewColumns] - attributes added to this
//
//  History:    06-13-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
SetDefaultColumns(
    HWND hwnd,
    const CObjectPicker &rop,
    AttrKeyVector *pvakListviewColumns)
{
    const CAttributeManager &ram = rop.GetAttributeManager();
    const CFilterManager &rfm = rop.GetFilterManager();
    ULONG ulSelectedFilters = rfm.GetCurScopeSelectedFilterFlags();
    ASSERT(ulSelectedFilters);

    AddIfNotPresent(pvakListviewColumns, AK_NAME);

    if (ulSelectedFilters & DSOP_FILTER_USERS)
    {
        ram.EnsureAttributesLoaded(hwnd, FALSE, c_wzUserObjectClass);
        if(ram.IsAttributeLoaded(AK_SAMACCOUNTNAME))
            AddIfNotPresent(pvakListviewColumns, AK_SAMACCOUNTNAME);
        if(ram.IsAttributeLoaded(AK_EMAIL_ADDRESSES))
            AddIfNotPresent(pvakListviewColumns, AK_EMAIL_ADDRESSES);
    }

    if (ulSelectedFilters & ALL_UPLEVEL_GROUP_FILTERS)
    {
        ram.EnsureAttributesLoaded(hwnd, FALSE, c_wzGroupObjectClass);
        if(ram.IsAttributeLoaded(AK_DESCRIPTION))
            AddIfNotPresent(pvakListviewColumns, AK_DESCRIPTION);
    }

    if (ulSelectedFilters & DSOP_FILTER_COMPUTERS)
    {
        ram.EnsureAttributesLoaded(hwnd, FALSE, c_wzComputerObjectClass);
        if(ram.IsAttributeLoaded(AK_DESCRIPTION))
            AddIfNotPresent(pvakListviewColumns, AK_DESCRIPTION);
    }

    if (ulSelectedFilters & DSOP_FILTER_CONTACTS)
    {
        ram.EnsureAttributesLoaded(hwnd, FALSE, c_wzContactObjectClass);
        if(ram.IsAttributeLoaded(AK_EMAIL_ADDRESSES))
            AddIfNotPresent(pvakListviewColumns, AK_EMAIL_ADDRESSES);
        if(ram.IsAttributeLoaded(AK_COMPANY))
            AddIfNotPresent(pvakListviewColumns, AK_COMPANY);
    }

    AddIfNotPresent(pvakListviewColumns, AK_DISPLAY_PATH);
}

//>>
String
GetClassName(const CObjectPicker &rop)
{
    const CFilterManager &rfm = rop.GetFilterManager();
    ULONG ulSelectedFilters = rfm.GetCurScopeSelectedFilterFlags();
    ASSERT(ulSelectedFilters);


    if (ulSelectedFilters & DSOP_FILTER_USERS)
    {
        return c_wzUserObjectClass;
    }

    if (ulSelectedFilters & ALL_UPLEVEL_GROUP_FILTERS)
    {
        return c_wzGroupObjectClass;
    }

    if (ulSelectedFilters & DSOP_FILTER_COMPUTERS)
    {
        return c_wzComputerObjectClass;
    }

    if (ulSelectedFilters & DSOP_FILTER_CONTACTS)
    {
        return c_wzContactObjectClass;
    }

	return L"*";
}
//+--------------------------------------------------------------------------
//
//  Function:   wcsistr
//
//  Synopsis:   Wide character case insensitive substring search.
//
//  Arguments:  [pwzSearchIn]  - string to look in
//              [pwzSearchFor] - substring to look for
//
//  Returns:    Pointer to first occurence of [pwzSearchFor] within
//              [pwzSearchIn], or NULL if none found.
//
//  History:    3-12-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

PWSTR
wcsistr(
    PCWSTR pwzSearchIn,
    PCWSTR pwzSearchFor)
{
    PCWSTR pwzSearchInCur;
    PCWSTR pwzSearchForCur = pwzSearchFor;

    //
    // Handle special case of search for string empty by returning
    // pointer to end of search in string.
    //

    if (!*pwzSearchFor)
    {
        return (PWSTR) (pwzSearchIn + lstrlen(pwzSearchIn));
    }

    //
    // pwzSearchFor is at least one character long.
    //

    for (pwzSearchInCur = pwzSearchIn; *pwzSearchInCur; pwzSearchInCur++)
    {
        //
        // If current char of both strings matches, advance in search
        // for string.
        //

        if (towlower(*pwzSearchInCur) == towlower(*pwzSearchForCur))
        {
            pwzSearchForCur++;

            //
            // If we just hit the end of the substring we're searching
            // for, then we've found a match.  The start of the match
            // is at the current location of the search in pointer less
            // the length of the substring we just matched, plus 1 since
            // we haven't advanced pwzSearchInCur past the last matching
            // character yet.
            //

            if (!*pwzSearchForCur)
            {
                return (PWSTR)(pwzSearchInCur - lstrlen(pwzSearchFor) + 1);
            }
        }
        else
        {
            //
            // Mismatch, start searching from the beginning of
            // the search for string again.
            //

            pwzSearchForCur = pwzSearchFor;
        }
    }

    return NULL;
}




//+--------------------------------------------------------------------------
//
//  Function:   AllocateQueryInfo
//
//  Synopsis:   Create a new empty query info, and put a pointer to it in
//              *[ppdsqi].
//
//  Arguments:  [ppdsqi] - receives pointer to new query info.
//
//  Returns:    S_OK or E_OUTOFMEMORY.
//
//  Modifies:   *[ppdsqi]
//
//  History:    3-12-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
AllocateQueryInfo(
    PDSQUERYINFO *ppdsqi)
{
    HRESULT hr = S_OK;

    *ppdsqi = (PDSQUERYINFO) CoTaskMemAlloc(sizeof DSQUERYINFO);

    if (!*ppdsqi)
    {
        hr = E_OUTOFMEMORY;
        DBG_OUT_HRESULT(hr);
        return hr;
    }

    ZeroMemory(*ppdsqi, sizeof DSQUERYINFO);

    (*ppdsqi)->cbSize = sizeof(DSQUERYINFO);
    return hr;
}




//+---------------------------------------------------------------------------
//
//  Function:   UnicodeToAnsi
//
//  Synopsis:   Convert unicode string [pwsz] to multibyte in buffer [sz].
//
//  Arguments:  [szTo]     - destination buffer
//              [pwszFrom] - source string
//              [cbTo]     - size of destination buffer, in bytes
//
//  Returns:    S_OK               - conversion succeeded
//              HRESULT_FROM_WIN32 - WideCharToMultiByte failed
//
//  Modifies:   *[szTo]
//
//  History:    10-29-96   DavidMun   Created
//
//  Notes:      The string in [szTo] will be NULL terminated even on
//              failure.
//
//----------------------------------------------------------------------------

HRESULT
UnicodeToAnsi(
    LPSTR   szTo,
    LPCWSTR pwszFrom,
    ULONG   cbTo)
{
    HRESULT hr = S_OK;
    ULONG   cbWritten;

    cbWritten = WideCharToMultiByte(CP_ACP,
                                    0,
                                    pwszFrom,
                                    -1,
                                    szTo,
                                    cbTo,
                                    NULL,
                                    NULL);

    if (!cbWritten)
    {
        szTo[cbTo - 1] = '\0'; // ensure NULL termination

        hr = HRESULT_FROM_WIN32(GetLastError());
        Dbg(DEB_ERROR, "UnicodeToAnsi: WideCharToMultiByte hr=0x%x\n", hr);
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   FreeQueryInfo
//
//  Synopsis:   Free all resources associated with [pdsqi].
//
//  Arguments:  [pdsqi] - NULL or pointer to query info.
//
//  History:    3-12-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

void
FreeQueryInfo(
    PDSQUERYINFO pdsqi)
{
    if (!pdsqi)
    {
        return;
    }

    ASSERT((ULONG_PTR)pdsqi->pwzLdapQuery != 1);

    CoTaskMemFree((void *)pdsqi->pwzLdapQuery);
    CoTaskMemFree((void *)pdsqi->apwzFilter);
    CoTaskMemFree((void *)pdsqi->pwzCaption);
    CoTaskMemFree((void *)pdsqi);
}




//+--------------------------------------------------------------------------
//
//  Function:   ProviderFlagFromPath
//
//  Synopsis:   Return a PROVIDER_* flag describing the ADSI provider used
//              by [strADsPath].
//
//  History:    09-14-1998   davidmun   Created
//
//---------------------------------------------------------------------------

HRESULT
ProviderFlagFromPath(
    const String &strADsPath,
    ULONG *pulProvider)
{
    HRESULT hr = S_OK;

    String strProvider = strADsPath;
    size_t idxColon = strProvider.find(L':');
        ASSERT(idxColon != String::npos);
        strProvider.erase(idxColon);
    ULONG flPathProvider = PROVIDER_UNKNOWN;

    if (!lstrcmpi(strProvider.c_str(), L"LDAP"))
    {
        flPathProvider = PROVIDER_LDAP;
    }
    else if (!lstrcmpi(strProvider.c_str(), L"WinNT"))
    {
        flPathProvider = PROVIDER_WINNT;
    }
    else if (!lstrcmpi(strProvider.c_str(), L"GC"))
    {
        flPathProvider = PROVIDER_GC;
    }
    else
    {
        hr = E_UNEXPECTED;
        Dbg(DEB_ERROR,
            "ProviderFlagFromPath: Unknown provider '%ws'",
            strProvider.c_str());
        ASSERT(!"Unknown provider");
    }

    *pulProvider = flPathProvider;
    return hr;
}



//+--------------------------------------------------------------------------
//
//  Function:   MessageWait
//
//  Synopsis:   Wait on the [cObjects] handles in [aObjects] for a maximum
//              of [ulTimeout] ms, processing paint, posted, and sent messages
//              during the wait.
//
//  Arguments:  [cObjects]  - number of handles in [aObjects]
//              [aObjects]  - array of handles to wait on
//              [ulTimeout] - max time to wait (can be INFINITE)
//
//  History:    3-12-1999   DavidMun   Created
//
//---------------------------------------------------------------------------

void
MessageWait(
    ULONG cObjects,
    const HANDLE *aObjects,
    ULONG ulTimeout)
{
    TRACE_FUNCTION(MessageWait);
    ULONG ulWaitResult;

    while (TRUE)
    {
        //
        // CAUTION: the allowable messages (QS_* flags) MUST MATCH the
        // message filter passed to PeekMessage (PM_QS_*), else an infinite
        // loop will occur!
        //

        ulWaitResult = MsgWaitForMultipleObjects(cObjects,
                                                 aObjects,
                                                 FALSE,
                                                 ulTimeout,
                                                 QS_POSTMESSAGE
                                                 | QS_PAINT
                                                 | QS_SENDMESSAGE);


        if (ulWaitResult == WAIT_OBJECT_0)
        {
            Dbg(DEB_TRACE, "MessageWait: object signaled\n");
            break;
        }

        if (ulWaitResult == WAIT_OBJECT_0 + cObjects)
        {
            MSG msg;

            BOOL fMsgAvail = PeekMessage(&msg,
                                         NULL,
                                         0,
                                         0,
                                         PM_REMOVE
                                         | PM_QS_POSTMESSAGE
                                         | PM_QS_PAINT
                                         | PM_QS_SENDMESSAGE);

            if (fMsgAvail)
            {
                Dbg(DEB_TRACE, "MessageWait: Translate/dispatch\n");
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            else
            {
                //Dbg(DEB_TRACE, "MessageWait: Ignoring new message\n");
            }
        }
        else
        {
            Dbg(DEB_ERROR,
                "MsgWaitForMultipleObjects <%uL>\n",
                ulWaitResult);
            break;
        }
    }
}


//+--------------------------------------------------------------------------
//
//  Function:   GetPolicySettings
//
//  Synopsis:   Fill *[pcMaxHits] with the maximum number of objects that
//              should appear in the browse listview, and *[pfExcludeDisabled]
//              with a flag indicating whether disabled objects are illegal.
//
//  Arguments:  [pcMaxHits] - filled with query limit
//              [pfExcludeDisabled] - filled with flag indicating whether
//                                      disabled objects should be treated
//                                      as illegal
//
//  Modifies:   *[pcMaxHits], *[pfExcludeDisabled]
//
//  History:    03-12-1999   DavidMun   Created
//              11-23-1999   DavidMun   Add ExcludeDisabledObjects
//
//  Notes:      Key:   HKCU\Software\Policies\Microsoft\Windows\Directory UI
//              Value: QueryLimit (DWORD)
//              Value: ExcludeDisabledObjects (DWORD)
//
//              Key:   HKLM\Software\Policies\Microsoft\Windows\Directory UI
//              Value: ExcludeDisabledObjects (DWORD)
//
//---------------------------------------------------------------------------

void
GetPolicySettings(
    ULONG *pcMaxHits,
    BOOL  *pfExcludeDisabled)
{
    TRACE_FUNCTION(GetPolicySettings);
    ASSERT(!IsBadWritePtr(pcMaxHits, sizeof(*pcMaxHits)));
    ASSERT(!IsBadWritePtr(pfExcludeDisabled, sizeof(*pfExcludeDisabled)));

    HRESULT     hr = S_OK;
    CSafeReg    shkPolicy;

    hr = shkPolicy.Open(HKEY_CURRENT_USER,
                        c_wzPolicyKeyPath,
                        STANDARD_RIGHTS_READ | KEY_QUERY_VALUE);

    if (SUCCEEDED(hr))
    {
        hr = shkPolicy.QueryDword((PWSTR)c_wzQueryLimitValueName, pcMaxHits);

        if (FAILED(hr))
        {
            *pcMaxHits = MAX_QUERY_HITS_DEFAULT;
        }

        hr = shkPolicy.QueryDword((PWSTR)c_wzExcludeDisabled,
                                  (PULONG)pfExcludeDisabled);

        if (FAILED(hr))
        {
            *pfExcludeDisabled = EXCLUDE_DISABLED_DEFAULT;
        }
    }
    else
    {
        *pcMaxHits = MAX_QUERY_HITS_DEFAULT;
        *pfExcludeDisabled = EXCLUDE_DISABLED_DEFAULT;
    }

    shkPolicy.Close();


    //
    //  If HKCU ExcludeDisabledObjects is still default,
    //  then check if HKLM ExcludeDisabledObjects is set.
    //
    if (*pfExcludeDisabled == EXCLUDE_DISABLED_DEFAULT)
    {
        hr = shkPolicy.Open(HKEY_LOCAL_MACHINE,
                            c_wzPolicyKeyPath,
                            STANDARD_RIGHTS_READ | KEY_QUERY_VALUE);
        if (SUCCEEDED(hr))
        {
            hr = shkPolicy.QueryDword((PWSTR)c_wzExcludeDisabled,
                                      (PULONG)pfExcludeDisabled);
            if (FAILED(hr))
            {
               *pfExcludeDisabled = EXCLUDE_DISABLED_DEFAULT;
            }
        }

        shkPolicy.Close();
    }
}



//+--------------------------------------------------------------------------
//
//  Function:   IsDisabled
//
//  Synopsis:   Return TRUE if the object with interface [pADs] has the
//              UF_ACCOUNTDISABLE flag set in either its userAccountControl
//              (LDAP) or UserFlags (WinNT) attribute.
//
//  Arguments:  [pADs] - object to check
//
//  Returns:    TRUE or FALSE.  Returns FALSE if attributes not found.
//
//  History:    09-24-1999   davidmun   Created
//
//---------------------------------------------------------------------------

BOOL
IsDisabled(
    IADs *pADs)
{
    Variant varUAC;
    BOOL    fDisabled = FALSE;
    HRESULT hr = S_OK;

    hr = pADs->Get((PWSTR)c_wzUserAcctCtrlAttr, &varUAC);

    if (SUCCEEDED(hr))
    {
        fDisabled = V_I4(&varUAC) & UF_ACCOUNTDISABLE;
    }
    else
    {
        hr = pADs->Get((PWSTR)c_wzUserFlagsAttr, &varUAC);

        if (SUCCEEDED(hr))
        {
            fDisabled = V_I4(&varUAC) & UF_ACCOUNTDISABLE;
        }
    }
    return fDisabled;
}




//+--------------------------------------------------------------------------
//
//  Function:   IsLocalComputername
//
//  Synopsis:   Return TRUE if [pwzComputerName] represents the local
//              machine
//
//  Arguments:  [pwzComputerName] - name to check or NULL
//
//  Returns:    TRUE if [pwzComputerName] is NULL, an empty string, or
//              the name of the local computer.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
IsLocalComputername(
    PCWSTR pwzComputerName)
{
    TRACE_FUNCTION(IsLocalComputername);

    static WCHAR s_wzComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    static WCHAR s_wzDnsComputerName[DNS_MAX_NAME_BUFFER_LENGTH];

    if (!pwzComputerName || !*pwzComputerName)
    {
        return TRUE;
    }

    if (L'\\' == pwzComputerName[0] && L'\\' == pwzComputerName[1])
    {
        pwzComputerName += 2;
    }

    // compare with the local computer name
    if (!*s_wzComputerName)
    {
        DWORD dwSize = ARRAYLEN(s_wzComputerName);

        VERIFY(GetComputerName(s_wzComputerName, &dwSize));
    }

    if (!lstrcmpi(pwzComputerName, s_wzComputerName))
    {
        return TRUE;
    }

    // compare with the local DNS name
    // SKwan confirms that ComputerNameDnsFullyQualified is the right name to use
    // when clustering is taken into account

    if (!*s_wzDnsComputerName)
    {
        DWORD dwSize = ARRAYLEN(s_wzDnsComputerName);

        VERIFY(GetComputerNameEx(ComputerNameDnsFullyQualified,
                                 s_wzDnsComputerName,
                                 &dwSize));
    }

    if (!lstrcmpi(pwzComputerName, s_wzDnsComputerName))
    {
        Dbg(DEB_TRACE, "returning TRUE\n");
        return TRUE;
    }

    Dbg(DEB_TRACE, "returning FALSE\n");
    return FALSE;
}


/*******************************************************************

    NAME:       LocalAllocSid

    SYNOPSIS:   Copies a SID

    ENTRY:      pOriginal - pointer to SID to copy

    EXIT:

    RETURNS:    Pointer to SID if successful, NULL otherwise

    NOTES:      Caller must free the returned SID with LocalFree

    HISTORY:
        JeffreyS    12-Apr-1999     Created
        Copied by hiteshr from ACLUI code base

********************************************************************/

PSID
LocalAllocSid(PSID pOriginal)
{
    PSID pCopy = NULL;
    if (pOriginal && IsValidSid(pOriginal))
    {
        DWORD dwLength = GetLengthSid(pOriginal);
        pCopy = (PSID)LocalAlloc(LMEM_FIXED, dwLength);
        if (NULL != pCopy)
            CopyMemory(pCopy, pOriginal, dwLength);
    }
    return pCopy;
}

/*-----------------------------------------------------------------------------
/ LocalAllocString
/ ------------------
/   Allocate a string, and initialize it with the specified contents.
/
/ In:
/   ppResult -> recieves pointer to the new string
/   pString -> string to initialize with
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT LocalAllocString(LPTSTR* ppResult, LPCTSTR pString)
{
    if ( !ppResult || !pString )
        return E_INVALIDARG;

    *ppResult = (LPTSTR)LocalAlloc(LPTR, (wcslen(pString) + 1)*sizeof(WCHAR));

    if ( !*ppResult )
        return E_OUTOFMEMORY;

    lstrcpy(*ppResult, pString);
    return S_OK;                          //  success

}

/*******************************************************************

    NAME:       GetAuthenticationID

    SYNOPSIS:   Retrieves the UserName associated with the credentials
                currently being used for network access.
                (runas /netonly credentials)

    
    HISTORY:
        JeffreyS    05-Aug-1999     Created
        Modified by hiteshr to return credentials

********************************************************************/
NTSTATUS
GetAuthenticationID(LPWSTR *ppszResult)
{        
    HANDLE hLsa;
    NTSTATUS Status = 0;
    *ppszResult = NULL;
    //
    // These LSA calls are delay-loaded from secur32.dll using the linker's
    // delay-load mechanism.  Therefore, wrap with an exception handler.
    //
    __try
    {
        Status = LsaConnectUntrusted(&hLsa);

        if (Status == 0)
        {
            NEGOTIATE_CALLER_NAME_REQUEST Req = {0};
            PNEGOTIATE_CALLER_NAME_RESPONSE pResp;
            ULONG cbSize =0;
            NTSTATUS SubStatus =0;

            Req.MessageType = NegGetCallerName;

            Status = LsaCallAuthenticationPackage(
                            hLsa,
                            0,
                            &Req,
                            sizeof(Req),
                            (void**)&pResp,
                            &cbSize,
                            &SubStatus);

            if ((Status == 0) && (SubStatus == 0))
            {
                LocalAllocString(ppszResult,pResp->CallerName);
                LsaFreeReturnBuffer(pResp);
            }

            LsaDeregisterLogonProcess(hLsa);
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
    }

    return Status;
    
}




//+--------------------------------------------------------------------------
//
//  Function:   IsCurrentUserLocalUser
//
//  Synopsis:   Return TRUE if the current user is a local machine user.
//
//  History:    08-15-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

BOOL
IsCurrentUserLocalUser()
{
    TRACE_FUNCTION(IsCurrentUserLocalUser);

    BOOL  fUserIsLocal = FALSE;
    ULONG cchName;
    WCHAR wzComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    BOOL  fOk;
    LPWSTR pszUserName = NULL;    
    NTSTATUS Status = 0;
    do
    {
        Status = GetAuthenticationID(&pszUserName);
        if (!NT_SUCCESS(Status) || !pszUserName)
        {
            DBG_OUT_LRESULT(Status);
            break;
        }
        
        String strUserName(pszUserName);
        LocalFree(pszUserName);

        Dbg(DEB_TRACE, "NameSamCompatible of User is= %ws\n", strUserName.c_str());

        cchName = ARRAYLEN(wzComputerName);
        fOk = GetComputerName(wzComputerName, &cchName);

        if (!fOk)
        {
            DBG_OUT_LASTERROR;
            break;
        }


        strUserName.strip(String::BOTH, L'\\');

        size_t idxWhack = strUserName.find(L'\\');

        if (idxWhack != String::npos)
        {
            strUserName.erase(idxWhack);
        }

        String strComputerName(wzComputerName);
        strComputerName.strip(String::BOTH, L'\\');

        if (!strUserName.icompare(strComputerName))
        {
            fUserIsLocal = TRUE;
        }
    } while (0);

    Dbg(DEB_TRACE, "fUserIsLocal = %ws\n", fUserIsLocal ? L"TRUE" : L"FALSE");
    return fUserIsLocal;
}




//+--------------------------------------------------------------------------
//
//  Function:   DisableSystemMenuClose
//
//  Synopsis:   Disable the "Close" option on the system menu of window
//              [hwnd].
//
//  Arguments:  [hwnd] - window owning system menu
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
DisableSystemMenuClose(
    HWND hwnd)
{
    HMENU hmenuSystem = GetSystemMenu(hwnd, FALSE);
    ASSERT(IsMenu(hmenuSystem));

    MENUITEMINFO mii;

    ZeroMemory(&mii, sizeof mii);
    mii.cbSize = sizeof mii;
    mii.fMask = MIIM_STATE;
    mii.fState = MFS_DISABLED;

    SetMenuItemInfo(hmenuSystem, SC_CLOSE, FALSE, &mii);
}




//+--------------------------------------------------------------------------
//
//  Function:   AddStringToCombo
//
//  Synopsis:   Add the resource string with id [ids] to the combobox with
//              window handle [hwndCombo].
//
//  Arguments:  [hwndCombo] - window handle of combobox
//              [ids]       - resource id of string to add
//
//  Returns:    HRESULT
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

HRESULT
AddStringToCombo(
    HWND hwndCombo,
    ULONG ids)
{
    HRESULT hr = S_OK;

    String strRes = String::load((int)ids, g_hinst);
    int iRet = ComboBox_AddString(hwndCombo, strRes.c_str());

    if (iRet == CB_ERR)
    {
        DBG_OUT_LASTERROR;
        hr = HRESULT_FROM_LASTERROR;
    }
    return hr;
}




//+--------------------------------------------------------------------------
//
//  Function:   LdapEscape
//
//  Synopsis:   Escape the characters in *[pstrEscaped] as required by
//              RFC 2254.
//
//  Arguments:  [pstrEscaped] - string to escape
//
//  History:    06-23-2000   DavidMun   Created
//
//  Notes:      RFC 2254
//
//              If a value should contain any of the following characters
//
//                     Character       ASCII value
//                     ---------------------------
//                     *               0x2a
//                     (               0x28
//                     )               0x29
//                     \               0x5c
//                     NUL             0x00
//
//              the character must be encoded as the backslash '\'
//              character (ASCII 0x5c) followed by the two hexadecimal
//              digits representing the ASCII value of the encoded
//              character.  The case of the two hexadecimal digits is not
//              significant.
//
//---------------------------------------------------------------------------

void
LdapEscape(
    String *pstrEscaped)
{
    size_t i = 0;

    while (1)
    {
        i = pstrEscaped->find_first_of(L"*()\\", i);

        if (i == String::npos)
        {
            break;
        }

        PCWSTR pwzReplacement;

        switch ((*pstrEscaped)[i])
        {
        case L'*':
            pwzReplacement = L"\\2a";
            break;

        case L'(':
            pwzReplacement = L"\\28";
            break;

        case L')':
            pwzReplacement = L"\\29";
            break;

        case L'\\':
            pwzReplacement = L"\\5c";
            break;

        default:
            Dbg(DEB_ERROR, "find_first_of stopped at '%c'\n", (*pstrEscaped)[i]);
            ASSERT(0 && "find_first_of stopped at unexpected character");
            return;
        }

        //
        // replace the 1 character at position i with the first 3 characters
        // of pwzReplacement
        //

        pstrEscaped->erase(i);
        pstrEscaped->insert(i, String(pwzReplacement));
        i += 3; // move past string just inserted
    }
}




//+--------------------------------------------------------------------------
//
//  Function:   UpdateLookForInText
//
//  Synopsis:   Update the text in the look for and look in r/o edit
//              controls as well as the window caption.
//
//  Arguments:  [hwndDlg] - handle to dialog owning the controls to update
//              [rop]     - instance of object picker associated with the
//                            dialog.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
UpdateLookForInText(
    HWND hwndDlg,
    const CObjectPicker &rop)
{
    TRACE_FUNCTION(UpdateLookForInText);

    const CFilterManager &rfm = rop.GetFilterManager();
    const CScopeManager &rsm = rop.GetScopeManager();

    Edit_SetText(GetDlgItem(hwndDlg, IDC_LOOK_IN_EDIT),
                 rsm.GetCurScope().GetDisplayName().c_str());
    Edit_SetText(GetDlgItem(hwndDlg, IDC_LOOK_FOR_EDIT),
                 rfm.GetFilterDescription(hwndDlg, FOR_LOOK_FOR).c_str());
    SetWindowText(hwndDlg,
                  rfm.GetFilterDescription(hwndDlg, FOR_CAPTION).c_str());
}




//+--------------------------------------------------------------------------
//
//  Function:   AddFromDataObject
//
//  Synopsis:   Add the objects in [pdo] to the list in [pdsol].
//
//  Arguments:  [idScope]       - id of scope to own the objects added
//              [pdo]           - points to data object containing objects
//                                 to add
//              [pfnTestObject] - NULL or a pointer to a function which
//                                 is used to indicate whether each object
//                                 should be added to [pdsol]
//              [lParam]        - parameter for [pfnTestObject]
//              [pdsol]         - points to list to add objects to
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

void
AddFromDataObject(
    ULONG idScope,
    IDataObject *pdo,
    PFNOBJECTTEST pfnTestObject,
    LPARAM lParam,
    CDsObjectList *pdsol)
{
    HRESULT hr = S_OK;

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL,
        NULL
    };

    FORMATETC formatetc =
    {
        (CLIPFORMAT)CDataObject::s_cfDsSelectionList,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    hr = pdo->GetData(&formatetc, &stgmedium);

    if (FAILED(hr) || hr == S_FALSE)
    {
        CHECK_HRESULT(hr);
        return;
    }

    PDS_SELECTION_LIST pdssl =
        static_cast<PDS_SELECTION_LIST>(GlobalLock(stgmedium.hGlobal));

    ULONG i;

    for (i = 0; i < pdssl->cItems; i++)
    {
        if (pfnTestObject && !pfnTestObject(pdssl->aDsSelection[i], lParam))
        {
            continue;
        }

        SDsObjectInit sdi;

        sdi.idOwningScope       = idScope;
        sdi.pwzName             = pdssl->aDsSelection[i].pwzName;
        sdi.pwzClass            = pdssl->aDsSelection[i].pwzClass;
        sdi.pwzADsPath          = pdssl->aDsSelection[i].pwzADsPath;
        sdi.pwzUpn              = pdssl->aDsSelection[i].pwzUPN;

        pdsol->push_back(CDsObject(sdi));
    }

    GlobalUnlock(stgmedium.hGlobal);
    ReleaseStgMedium(&stgmedium);
}




//+--------------------------------------------------------------------------
//
//  Function:   UliToStr
//
//  Synopsis:   Convert the unsigned long integer [uli] to a string.
//
//  History:    06-23-2000   DavidMun   Created
//
//---------------------------------------------------------------------------

String
UliToStr(
    const ULARGE_INTEGER &uli)
{
    String strResult;
    ULARGE_INTEGER uliCopy = uli;

    while (uliCopy.QuadPart)
    {
        WCHAR wzDigit[] = L"0";

        wzDigit[0] = wzDigit[0] + static_cast<WCHAR>(uliCopy.QuadPart % 10);
        strResult += wzDigit;
        uliCopy.QuadPart /= 10;
    }

    reverse(strResult.begin(), strResult.end());
    return strResult;
}




/*
This Function verifies if the SID is good. This is done when 
the sid is from crossforest. IDirectorySearch doesn't do any Sid 
Filtering. So we get some spoofed sid. To check we get the sid
through LSA also and match the two sids. If sids match then its good
all other cases it considered as spoofed
*/

HRESULT
IsSidGood( IN LPCWSTR pszTargetMachineName,  //Name of the Target Machine
           IN LPCWSTR pszAccountName,        //Name of the account
           IN PSID pInputSid,
           OUT PBOOL pbGood)                        //Sid to verify
{
    if(!pszAccountName || !pInputSid || !pbGood)
    {
        ASSERT(FALSE);
        return E_INVALIDARG;
    }

    WCHAR wzDomainName[1024];
    BYTE Sid[1024];
    PSID pSid = NULL;
    LPWSTR pszDomainName = NULL;        
    DWORD cbSid = 1024;
    DWORD cbDomainName = 1023;
    SID_NAME_USE Use ;
    
    DWORD dwErr = ERROR_SUCCESS;
    
    *pbGood = FALSE;

    pSid = (PSID)Sid;
    pszDomainName = (LPWSTR)wzDomainName;


    //
    //Lookup the names
    //
    if(LookupAccountName(pszTargetMachineName,  // name of local or remote computer
                         pszAccountName,              // security identifier
                         pSid,           // account name buffer
                         &cbSid,
                         pszDomainName,
                         &cbDomainName ,
                         &Use ) == FALSE)
    {
        dwErr = GetLastError();
        
        //
        //Function succeeded. But since we can't verify the sid
        //pbGood is false
        //            
        if(dwErr != ERROR_INSUFFICIENT_BUFFER)
            return S_OK;

        pSid = (PSID)LocalAlloc(LPTR, cbSid);
        if(!pSid)
            return E_OUTOFMEMORY;


        pszDomainName = (LPWSTR)LocalAlloc(LPTR, (cbDomainName + 1)* sizeof(WCHAR));
        if(!pszDomainName)
        {
            LocalFree(pSid);
            return E_OUTOFMEMORY;
        }        
        if(LookupAccountName(pszTargetMachineName,  // name of local or remote computer
                             pszAccountName,        // security identifier
                             pSid,                  // account name buffer
                             &cbSid,
                             pszDomainName ,
                             &cbDomainName ,
                             &Use ) == FALSE )
        {
            LocalFree(pSid);
            LocalFree(pszDomainName);
            return S_OK;
        }
    }

    if(IsValidSid(pSid))
        *pbGood = EqualSid(pSid,pInputSid);

    if(pSid != Sid)
        LocalFree(pSid);
    if(wzDomainName != pszDomainName)
        LocalFree(pszDomainName);

    return S_OK;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\test\main.cxx ===
#include "headers.hxx"
#pragma hdrstop
#include <compobj.h>
#include <initguid.h>

//
// Helpful debug macros
//

#define DBG_OUT_HRESULT(hr) printf("error 0x%x at line %u\n", hr, __LINE__)


#define BREAK_ON_FAIL_HRESULT(hr)   \
        if (FAILED(hr))             \
        {                           \
            DBG_OUT_HRESULT(hr);    \
            break;                  \
        }

//
// Forward references
//

VOID
DumpDsSelectedItemList(
    PDSSELECTIONLIST pDsSelList,
    ULONG cRequestedAttributes,
    LPCTSTR *aptzRequestedAttributes);

VOID
Usage();

HRESULT
AnsiToUnicode(
    LPWSTR pwszTo,
    LPCSTR szFrom,
    LONG   cchTo);

BOOL
ParseFetchSwitch(
    char *pzFetchSwitch,
    PULONG pcRequestedAttributes,
    LPCTSTR **paptzRequestedAttributes);

BOOL
ParseGroupSwitch(
    char *pzGroupSwitch,
    ULONG *pulFlags);

BOOL
ParseUserSwitch(
    char *pzUserSwitch,
    ULONG *pulFlags);

BOOL
ParseInitialScope(
    char *pzScopeSwitch,
    ULONG *pulFlags);

BOOL
ParseScope(
    char *pzScopeSwitch,
    ULONG *pulFlags,
    PWSTR wzComputer,
    PWSTR wzDomain);

BOOL
ParseProviders(
    char *pzProviderSwitch,
    PULONG cAcceptableProviders,
    LPCWSTR **paptzAcceptableProviders);

BOOL
ParseRunCount(
    char *pzRunCountSwitch,
    PULONG pcRunCount);

LPWSTR
VariantString(
    VARIANT *pvar);

void
VarArrayToStr(
    VARIANT *pvar,
    LPWSTR wzBuf,
    ULONG cchbuf);

//
// Entry point
//

enum API_TO_CALL
{
    NONE,
    COMPUTER,
    USER_GROUP
};

void _cdecl
main(int argc, char * argv[])
{
    HRESULT     hr;
    BOOL        fBadArg = FALSE;
    API_TO_CALL api = NONE;

    ULONG       flObjectPicker = 0;
    ULONG       flDsObjectPicker = 0;
    ULONG       flUserGroupObjectPickerSpecifiedDomain = 0;
    ULONG       flUserGroupObjectPickerOtherDomains = 0;
    ULONG      *pflUserGroup = &flUserGroupObjectPickerOtherDomains;
    ULONG       flComputerObjectPicker = 0;
    ULONG       flInitialScope = 0;

    WCHAR       wzComputer[MAX_PATH] = L"";
    WCHAR       wzDomain[MAX_PATH] = L"";

    ULONG       cAcceptableProviders = 0;
    LPCWSTR     *aptzAcceptableProviders = NULL;

    ULONG       cInvocations = 1;
    ULONG       cRequestedAttributes = 0;
    LPCTSTR     *aptzRequestedAttributes = NULL;

    for (int idxArg = 1; idxArg < argc && !fBadArg; idxArg++)
    {
        switch (argv[idxArg][1])
        {
        case 'c':
        case 'C':
            if (argv[idxArg][2] == ':' &&
                tolower(argv[idxArg][3]) == 'a')
            {
                if (api == USER_GROUP)
                {
                    fBadArg = TRUE;
                    printf("Can't specify /C:Api with user/group switches\n");
                }
                api = COMPUTER;
            }
            else
            {
                if (api == COMPUTER)
                {
                    fBadArg = TRUE;
                    printf("Can't specify both /C and /C:Api\n");
                }
                api = USER_GROUP;
                *pflUserGroup |= UGOP_COMPUTERS;
            }
            break;

        case 'd':
        case 'D':
            if (argv[idxArg][2] != ':')
            {
                printf("Expected ':' after /D\n");
                fBadArg = TRUE;
                break;
            }

            switch (argv[idxArg][3])
            {
            case 's':
            case 'S':
                pflUserGroup = &flUserGroupObjectPickerSpecifiedDomain;
                break;

            case 'o':
            case 'O':
            case '0': // allow a typo
                pflUserGroup = &flUserGroupObjectPickerOtherDomains;
                break;

            default:
                fBadArg = TRUE;
                printf("Expected S or O after /D:\n");
                break;
            }
            break;

        case 'f':
        case 'F':
            fBadArg = !ParseFetchSwitch(argv[idxArg], &cRequestedAttributes, &aptzRequestedAttributes);
            break;

        case 'g':
        case 'G':
            if (api != NONE && api != USER_GROUP)
            {
                fBadArg = TRUE;
                break;
            }
            api = USER_GROUP;
            fBadArg = !ParseGroupSwitch(argv[idxArg], pflUserGroup);
            break;

        case 'h':
        case 'H':
            if (api != NONE && api != USER_GROUP)
            {
                fBadArg = TRUE;
                break;
            }
            api = USER_GROUP;
            *pflUserGroup |= UGOP_INCLUDE_HIDDEN;
            break;

        case 'i':
        case 'I':
            fBadArg = !ParseInitialScope(argv[idxArg], &flInitialScope);
            break;

        case 'm':
        case 'M':
            flObjectPicker |= OP_MULTISELECT;
            break;

        case 'n':
        case 'N':
            flDsObjectPicker |= DSOP_RESTRICT_NAMES_TO_KNOWN_DOMAINS;
            break;

        case 'p':
        case 'P':
            fBadArg = !ParseProviders(argv[idxArg],
                                      &cAcceptableProviders,
                                      &aptzAcceptableProviders);
            break;

        case 'r':
        case 'R':
            fBadArg = !ParseRunCount(argv[idxArg], &cInvocations);
            break;

        case 's':
        case 'S':
            fBadArg = !ParseScope(argv[idxArg],
                                  &flDsObjectPicker,
                                  wzComputer,
                                  wzDomain);
            break;

        case 'u':
        case 'U':
            if (api == COMPUTER)
            {
                fBadArg = TRUE;
                break;
            }
            api = USER_GROUP;
            fBadArg = !ParseUserSwitch(argv[idxArg], pflUserGroup);
            break;

        case 'x':
        case 'X':
            flDsObjectPicker |= DSOP_CONVERT_EXTERNAL_PATHS_TO_SID;
            break;

        default:
            fBadArg = TRUE;
            break;
        }
    }

    if (fBadArg || api == NONE)
    {
        Usage();
        return;
    }

    hr = CoInitialize(NULL);

    if (FAILED(hr))
    {
        printf("CoInitializeEx - 0x%x\n", hr);
        return;
    }

    //
    // Call the API
    //

    PDSSELECTIONLIST    pDsSelList = NULL;

    if (api == USER_GROUP)
    {
        GETUSERGROUPSELECTIONINFO ugsi;

        ZeroMemory(&ugsi, sizeof ugsi);
        ugsi.cbSize = sizeof(ugsi);
        ugsi.ptzComputerName = *wzComputer ? wzComputer : NULL;
        ugsi.ptzDomainName = *wzDomain ? wzDomain : NULL;
        ugsi.flObjectPicker = flObjectPicker;
        ugsi.flDsObjectPicker = flDsObjectPicker;
        ugsi.flStartingScope = flInitialScope;
        ugsi.flUserGroupObjectPickerSpecifiedDomain =
            flUserGroupObjectPickerSpecifiedDomain;
        ugsi.flUserGroupObjectPickerOtherDomains =
            flUserGroupObjectPickerOtherDomains;
        ugsi.ppDsSelList = &pDsSelList;
        ugsi.cAcceptableProviders = cAcceptableProviders;
        ugsi.aptzAcceptableProviders = aptzAcceptableProviders;
        ugsi.cRequestedAttributes = cRequestedAttributes;
        ugsi.aptzRequestedAttributes = aptzRequestedAttributes;

        for (ULONG i = 0; i < cInvocations; i++)
        {
            hr = GetUserGroupSelection(&ugsi);

            if (hr == S_FALSE)
            {
                printf("Invocation %u: User/Group picker dialog cancelled\n", i);
            }
            else if (SUCCEEDED(hr))
            {
                DumpDsSelectedItemList(pDsSelList,
                                       cRequestedAttributes,
                                       aptzRequestedAttributes);
            }
            else
            {
                printf("Invocation %u: User/Group picker dialog failed 0x%x\n", i, hr);
            }

            FreeDsSelectionList(pDsSelList);
            pDsSelList = NULL;
        }
    }
    else if (api == COMPUTER)
    {
        GETCOMPUTERSELECTIONINFO csi;

        ZeroMemory(&csi, sizeof csi);
        csi.cbSize = sizeof(csi);
        csi.ptzComputerName = *wzComputer ? wzComputer : NULL;
        csi.ptzDomainName = *wzDomain ? wzDomain : NULL;
        csi.flObjectPicker = flObjectPicker;
        csi.flDsObjectPicker = flDsObjectPicker;
        csi.flStartingScope = flInitialScope;
        csi.flComputerObjectPicker = flComputerObjectPicker;
        csi.ppDsSelList = &pDsSelList;
        csi.cAcceptableProviders = cAcceptableProviders;
        csi.aptzAcceptableProviders = aptzAcceptableProviders;
        csi.cRequestedAttributes = cRequestedAttributes;
        csi.aptzRequestedAttributes = aptzRequestedAttributes;

        for (ULONG i = 0; i < cInvocations; i++)
        {
            hr = GetComputerSelection(&csi);

            if (hr == S_FALSE)
            {
                printf("Invocation %u: Computer picker dialog cancelled\n", i);
            }
            else if (SUCCEEDED(hr))
            {
                DumpDsSelectedItemList(pDsSelList,
                                       cRequestedAttributes,
                                       aptzRequestedAttributes);
            }
            else
            {
                printf("Invocation %u: Computer picker dialog failed 0x%x\n", i, hr);
            }

            FreeDsSelectionList(pDsSelList);
            pDsSelList = NULL;
        }
    }
    else
    {
        printf("unexpected api setting\n");
    }

    CoUninitialize();
}


LPWSTR apwzAttr[100];

BOOL
ParseFetchSwitch(
    char *pzFetchSwitch,
    PULONG pcRequestedAttributes,
    LPCTSTR **paptzRequestedAttributes)
{
    BOOL fOk = TRUE;

    pzFetchSwitch += 2; // advance past '/' (or '-') and 'G'

    if (*pzFetchSwitch != ':')
    {
        printf("expected : after /Fetch\n");
        return FALSE;
    }

    *pcRequestedAttributes = 0;
    *paptzRequestedAttributes = NULL;

    ULONG cRequestedAttributes = 0;

    for (pzFetchSwitch++; *pzFetchSwitch && fOk; pzFetchSwitch++)
    {
        if (*pzFetchSwitch == ',')
        {
            continue;
        }

        PSTR pzComma = strchr(pzFetchSwitch, ',');

        if (pzComma)
        {
            *pzComma = '\0';
        }

        ULONG cchFetchSwitch = strlen(pzFetchSwitch) + 1;

        // BUGBUG this is leaked.  (who cares?)
        apwzAttr[cRequestedAttributes] = new WCHAR[cchFetchSwitch];
        if (!apwzAttr[cRequestedAttributes])
        {
            printf("out of memory\n");
            return FALSE;
        }
        AnsiToUnicode(apwzAttr[cRequestedAttributes],
                      pzFetchSwitch,
                      cchFetchSwitch);
        cRequestedAttributes++;

        if (pzComma)
        {
            *pzComma = ',';
            pzFetchSwitch = pzComma;
        }
        else
        {
            pzFetchSwitch += strlen(pzFetchSwitch) - 1;
        }
    }

    if (cRequestedAttributes && fOk)
    {
        *pcRequestedAttributes = cRequestedAttributes;
        *paptzRequestedAttributes = (LPCTSTR *)apwzAttr;
    }

    return fOk;
}




BOOL
ParseGroupSwitch(
    char *pzGroupSwitch,
    ULONG *pulFlags)
{
    BOOL fOk = TRUE;

    pzGroupSwitch += 2; // advance past '/' (or '-') and 'G'

    if (*pzGroupSwitch != ':')
    {
        printf("expected : after /Groups\n");
        return FALSE;
    }

    for (pzGroupSwitch++; *pzGroupSwitch && fOk; pzGroupSwitch++)
    {
        if (*pzGroupSwitch == ',')
        {
            continue;
        }

        PSTR pzComma = strchr(pzGroupSwitch, ',');

        if (pzComma)
        {
            *pzComma = '\0';
        }

        BOOL fMatch = FALSE;

        if (!lstrcmpiA(pzGroupSwitch, "all"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_ALL_GROUPS;
        }

        if (pzComma)
        {
            *pzComma = ',';
        }

        if (fMatch)
        {
            if (pzComma)
            {
                pzGroupSwitch = pzComma;
            }
            else
            {
                pzGroupSwitch += strlen(pzGroupSwitch) - 1;
            }
            continue;
        }

        switch (tolower(*pzGroupSwitch))
        {
        case 'u':
            if (tolower(pzGroupSwitch[1]) == 's')
            {
                *pulFlags |= UGOP_UNIVERSAL_GROUPS_SE;
                pzGroupSwitch++;
            }
            else
            {
                *pulFlags |= UGOP_UNIVERSAL_GROUPS;
            }
            break;

        case 'a':
            if (tolower(pzGroupSwitch[1]) == 's')
            {
                *pulFlags |= UGOP_ACCOUNT_GROUPS_SE;
                pzGroupSwitch++;
            }
            else
            {
                *pulFlags |= UGOP_ACCOUNT_GROUPS;
            }
            break;

        case 'r':
            if (tolower(pzGroupSwitch[1]) == 's')
            {
                *pulFlags |= UGOP_RESOURCE_GROUPS_SE;
                pzGroupSwitch++;
            }
            else
            {
                *pulFlags |= UGOP_RESOURCE_GROUPS;
            }
            break;

        case 'l':
            *pulFlags |= UGOP_LOCAL_GROUPS;
            break;

        case 'g':
            *pulFlags |= UGOP_GLOBAL_GROUPS;
            break;

        case 'b':
            *pulFlags |= UGOP_BUILTIN_GROUPS;
            break;

        case 'w':
            *pulFlags |= UGOP_WELL_KNOWN_PRINCIPALS_USERS;
            break;

        default:
            fOk = FALSE;
            printf("unexpected character '%c' in group type switch\n",
                   *pzGroupSwitch);
            break;
        }
    }
    printf("flags = 0x%x\n", *pulFlags);
    return fOk;
}




BOOL
ParseUserSwitch(
    char *pzUserSwitch,
    ULONG *pulFlags)
{
    BOOL fOk = TRUE;

    pzUserSwitch += 2; // advance past '/' (or '-') and 'U'

    if (*pzUserSwitch != ':')
    {
        printf("expected : after /Users\n");
        return FALSE;
    }

    for (pzUserSwitch++; *pzUserSwitch && fOk; pzUserSwitch++)
    {
        if (*pzUserSwitch == ',')
        {
            continue;
        }

        PSTR pzComma = strchr(pzUserSwitch, ',');

        if (pzComma)
        {
            *pzComma = '\0';
        }

        BOOL fMatch = FALSE;

        if (!lstrcmpiA(pzUserSwitch, "all"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_ALL_USERS;
        }
        else if (!lstrcmpiA(pzUserSwitch, "world"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_USER_WORLD;
        }
        else if (!lstrcmpiA(pzUserSwitch, "authenticated"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_USER_AUTHENTICATED_USER;
        }
        else if (!lstrcmpiA(pzUserSwitch, "anonymous"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_USER_ANONYMOUS;
        }
        else if (!lstrcmpiA(pzUserSwitch, "dialup"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_USER_DIALUP;
        }
        else if (!lstrcmpiA(pzUserSwitch, "network"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_USER_NETWORK;
        }
        else if (!lstrcmpiA(pzUserSwitch, "Batch"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_USER_BATCH;
        }
        else if (!lstrcmpiA(pzUserSwitch, "Interactive"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_USER_INTERACTIVE;
        }
        else if (!lstrcmpiA(pzUserSwitch, "Service"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_USER_SERVICE;
        }
        else if (!lstrcmpiA(pzUserSwitch, "System"))
        {
            fMatch = TRUE;
            *pulFlags |= UGOP_USER_SYSTEM;
        }

        if (pzComma)
        {
            *pzComma = ',';
        }

        if (fMatch)
        {
            if (pzComma)
            {
                pzUserSwitch = pzComma;
            }
            else
            {
                pzUserSwitch += strlen(pzUserSwitch) - 1;
            }
            continue;
        }

        switch (tolower(*pzUserSwitch))
        {
        case 'u':
            *pulFlags |= UGOP_USERS;
            break;

        case 'c':
            *pulFlags |= UGOP_CONTACTS;
            break;

        default:
            fOk = FALSE;
            printf("unexpected character '%c' in user type switch\n",
                   *pzUserSwitch);
            break;
        }

        if (pzComma)
        {
            pzUserSwitch = pzComma;
        }
    }
    return fOk;
}




BOOL
ParseInitialScope(
    char *pzScopeSwitch,
    ULONG *pulFlags)
{
    PSTR pzCur = strchr(pzScopeSwitch, ':');

    if (!pzCur)
    {
        printf("expected : after /InitialScope switch\n");
        return FALSE;
    }

    // advance past colon

    pzCur++;

    switch (tolower(*pzCur))
    {
    case 'c':
        *pulFlags |= DSOP_SCOPE_SPECIFIED_MACHINE;
        break;

    case 'd':
        *pulFlags |= DSOP_SCOPE_SPECIFIED_DOMAIN;
        break;

    case 'g':
        *pulFlags |= DSOP_SCOPE_DIRECTORY;
        break;

    case 't':
        *pulFlags |= DSOP_SCOPE_DOMAIN_TREE;
        break;

    case 'x':
        *pulFlags |= DSOP_SCOPE_EXTERNAL_TRUSTED_DOMAINS;
        break;

    default:
        printf("invalid /InitialScope switch\n");
        return FALSE;
    }

    return TRUE;
}




BOOL
ParseProviders(
    char *pzProviderSwitch,
    PULONG pcAcceptableProviders,
    LPCWSTR **paptzAcceptableProviders)
{
    BOOL fOk = TRUE;
    PSTR pzCur = strchr(pzProviderSwitch, ':');
    static LPCWSTR apwzProviders[3];

    *paptzAcceptableProviders = apwzProviders;

    if (!pzCur)
    {
        printf("expected : after /Providers switch\n");
        return FALSE;
    }

    ZeroMemory(apwzProviders, sizeof apwzProviders);

    // advance past colon

    pzCur++;
    while (*pzCur)
    {
        switch (tolower(*pzCur))
        {
        case 'w':
            apwzProviders[(*pcAcceptableProviders)++] = L"WinNT";
            break;

        case 'l':
            apwzProviders[(*pcAcceptableProviders)++] = L"LDAP";
            break;

        case 'g':
            apwzProviders[(*pcAcceptableProviders)++] = L"GC";
            break;

        default:
            printf("invalid provider switch\n");
            return FALSE;
        }

        for (; *pzCur && *pzCur != ','; pzCur++)
        {
        }

        if (*pzCur == ',')
        {
            pzCur++;
        }

        // ignore extras
        if (*pcAcceptableProviders == 3)
        {
            break;
        }
    }

    return fOk;
}




BOOL
ParseRunCount(
    char *pzRunCountSwitch,
    PULONG pcRunCount)
{
    PSTR pzCur = strchr(pzRunCountSwitch, ':');

    if (!pzCur)
    {
        printf("expected : after /Runcount switch\n");
        return FALSE;
    }

    *pcRunCount = (ULONG) atol(pzCur + 1);

    if (!*pcRunCount || *pcRunCount > 10)
    {
        printf("Invalid run count %u\n", *pcRunCount);
    }
    return TRUE;
}




BOOL
ParseScope(
    char *pzScopeSwitch,
    ULONG *pulFlags,
    PWSTR wzComputer,
    PWSTR wzDomain)
{
    PSTR pzCur = strchr(pzScopeSwitch, ':');

    if (!pzCur)
    {
        printf("expected : after /Scope switch\n");
        return FALSE;
    }

    // advance past colon

    pzCur++;

    while (*pzCur)
    {
        switch (tolower(*pzCur))
        {
        case 'c':
        {
            *pulFlags |= DSOP_SCOPE_SPECIFIED_MACHINE;

            // find '='

            for (PSTR pzEqual = pzCur;
                 *pzEqual && *pzEqual != ',' && *pzEqual != '=';
                 pzEqual++)
            {
            }

            if (*pzEqual == '=')
            {
                CHAR szTemp[MAX_PATH];

                strcpy(szTemp, pzEqual + 1);
                LPSTR pzComma = strchr(szTemp, ',');

                if (pzComma)
                {
                    *pzComma = '\0';
                }
                AnsiToUnicode(wzComputer, szTemp, MAX_PATH);
                pzCur = pzEqual + 1;
            }
            break;
        }

        case 'd':
        {
            *pulFlags |= DSOP_SCOPE_SPECIFIED_DOMAIN;

            for (PSTR pzEqual = pzCur;
                 *pzEqual && *pzEqual != ',' && *pzEqual != '=';
                 pzEqual++)
            {
            }

            if (*pzEqual == '=')
            {
                CHAR szTemp[MAX_PATH];
                LPSTR pzOpenQuote = strchr(pzEqual, '\'');

                if (!pzOpenQuote)
                {
                    printf("Expected single quote after = in domain spec\n");
                    return FALSE;
                }

                LPSTR pzCloseQuote = strchr(pzOpenQuote + 1, '\'');

                if (!pzCloseQuote)
                {
                    printf("Expected closing single quote after = in domain spec\n");
                    return FALSE;
                }

                CopyMemory(szTemp, pzOpenQuote + 1, pzCloseQuote - pzOpenQuote - 1);
                szTemp[pzCloseQuote - pzOpenQuote - 1] = '\0';
                AnsiToUnicode(wzDomain, szTemp, MAX_PATH);
                pzCur = pzCloseQuote + 1;
            }
            break;
        }

        case 'g':
            *pulFlags |= DSOP_SCOPE_DIRECTORY;
            break;

        case 't':
            *pulFlags |= DSOP_SCOPE_DOMAIN_TREE;
            break;

        case 'x':
            *pulFlags |= DSOP_SCOPE_EXTERNAL_TRUSTED_DOMAINS;
            break;

        default:
            printf("invalid scope switch\n");
            return FALSE;
        }

        for (; *pzCur && *pzCur != ','; pzCur++)
        {
        }

        if (*pzCur == ',')
        {
            pzCur++;
        }
    }

    return TRUE;
}




//+--------------------------------------------------------------------------
//
//  Function:   DumpDsSelectedItemList
//
//  Synopsis:   Dump the contents of the list of DS items the user selected
//              to the console.
//
//  Arguments:  [pDsSelList] - list of Ds items
//
//  History:    11-04-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

VOID
DumpDsSelectedItemList(
    PDSSELECTIONLIST pDsSelList,
    ULONG cRequestedAttributes,
    LPCTSTR *aptzRequestedAttributes)
{
    if (!pDsSelList)
    {
        printf("List is empty\n");
        return;
    }

    ULONG i;
    PDSSELECTION pCur = &pDsSelList->aDsSelection[0];

    for (i = 0; i < pDsSelList->cItems; i++, pCur++)
    {
        printf("Name:    %ws\n", pCur->pwzName);
        printf("Class:   %ws\n", pCur->pwzClass);
        printf("Path:    %ws\n", pCur->pwzADsPath);
        printf("UPN:     %ws\n", pCur->pwzUPN);

        for (ULONG j = 0; j < cRequestedAttributes; j++)
        {
            printf("Attr %02u: %ws = %ws\n",
                   j,
                   aptzRequestedAttributes[j],
                   VariantString(&pCur->pvarOtherAttributes[j]));
        }
        printf("\n");
    }
}



LPWSTR
VariantString(
    VARIANT *pvar)
{
    static WCHAR wzBuf[1024];

    wzBuf[0] = L'\0';

    switch (pvar->vt)
    {
    case VT_EMPTY:
        lstrcpy(wzBuf, L"VT_EMPTY");
        break;

    case VT_NULL:
        lstrcpy(wzBuf, L"VT_NULL");
        break;

    case VT_I2:
        wsprintf(wzBuf, L"%d", V_I2(pvar));
        break;

    case VT_I4:
        wsprintf(wzBuf, L"%d", V_I4(pvar));
        break;

    case VT_R4:
        wsprintf(wzBuf, L"%f", V_R4(pvar));
        break;

    case VT_R8:
        wsprintf(wzBuf, L"%f", V_R8(pvar));
        break;

    case VT_CY:
        wsprintf(wzBuf, L"$%f", V_CY(pvar));
        break;

    case VT_DATE:
        wsprintf(wzBuf, L"date %f", V_DATE(pvar));
        break;

    case VT_BSTR:
        if (V_BSTR(pvar))
        {
            wsprintf(wzBuf, L"'%ws'", V_BSTR(pvar));
        }
        else
        {
            lstrcpy(wzBuf, L"VT_BSTR NULL");
        }
        break;

    case VT_DISPATCH:
        wsprintf(wzBuf, L"VT_DISPATCH 0x%x", V_DISPATCH(pvar));
        break;

    case VT_UNKNOWN:
        wsprintf(wzBuf, L"VT_UNKNOWN 0x%x", V_UNKNOWN(pvar));
        break;

    case VT_ERROR:
    case VT_HRESULT:
        wsprintf(wzBuf, L"hr 0x%x", V_ERROR(pvar));
        break;

    case VT_BOOL:
        wsprintf(wzBuf, L"%s", V_BOOL(pvar) ? "TRUE" : "FALSE");
        break;

    case VT_VARIANT:
        wsprintf(wzBuf, L"variant 0x%x", V_VARIANTREF(pvar));
        break;

    case VT_DECIMAL:
        lstrcpy(wzBuf, L"VT_DECIMAL");
        break;

    case VT_I1:
        wsprintf(wzBuf, L"%d", V_I1(pvar));
        break;

    case VT_UI1:
        wsprintf(wzBuf, L"%u", V_UI1(pvar));
        break;

    case VT_UI2:
        wsprintf(wzBuf, L"%u", V_UI2(pvar));
        break;

    case VT_UI4:
        wsprintf(wzBuf, L"%u", V_UI4(pvar));
        break;

    case VT_I8:
        lstrcpy(wzBuf, L"VT_I8");
        break;

    case VT_UI8:
        lstrcpy(wzBuf, L"VT_UI8");
        break;

    case VT_INT:
        wsprintf(wzBuf, L"%d", V_INT(pvar));
        break;

    case VT_UINT:
        wsprintf(wzBuf, L"%u", V_UINT(pvar));
        break;

    case VT_VOID:
        lstrcpy(wzBuf, L"VT_VOID");
        break;

    case VT_UI1 | VT_ARRAY:
        VarArrayToStr(pvar, wzBuf, ARRAYLEN(wzBuf));
        break;

    case VT_PTR:
    case VT_SAFEARRAY:
    case VT_CARRAY:
    case VT_USERDEFINED:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_RECORD:
    case VT_FILETIME:
    case VT_BLOB:
    case VT_STREAM:
    case VT_STORAGE:
    case VT_STREAMED_OBJECT:
    case VT_STORED_OBJECT:
    case VT_BLOB_OBJECT:
    case VT_CF:
    case VT_CLSID:
    case VT_BSTR_BLOB:
    default:
        wsprintf(wzBuf, L"VT 0x%x", V_VT(pvar));
        break;
    }
    return wzBuf;
}



void
VarArrayToStr(
    VARIANT *pvar,
    LPWSTR wzBuf,
    ULONG cchBuf)
{
    ULONG i;
    LPWSTR pwzNext = wzBuf;
    LPWSTR pwzEnd = wzBuf + cchBuf;

    for (i = 0; i < pvar->parray->rgsabound[0].cElements && pwzNext < pwzEnd + 6; i++)
    {
        wsprintf(pwzNext, L"x%02x ", ((LPBYTE)(pvar->parray->pvData))[i]);
        pwzNext += lstrlen(pwzNext);
    }
}




VOID
Usage()
{
    printf("\n");
    printf("Usage: opt <switches>\n");
    printf("\n");
    printf("Switches are:\n");
    printf("    /Computers[:Api]\n");
    printf("       If API is specified, GetComputerSelection is called, otherwise\n");
    printf("       this means include computer objects in the query\n");
    printf("    /Domain:{S|O}\n");
    printf("       If S is specified, then any following /Users, /Groups, or\n");
    printf("       /Computers switches apply only to the specified domain scope.\n");
    printf("       Otherwise, those switches apply to all other scopes\n");
    printf("    /Fetch:<attr>[,<attr>]...\n");
    printf("       <attr> is the name of an attribute to retrieve\n");
    printf("    /Groups:<group-type>[,<group-type>]...\n");
    printf("       <group-type> is one of:\n");
    printf("        ALL - same as specifiying each of the following\n");
    printf("        U   - Universal\n");
    printf("        A   - Account\n");
    printf("        R   - Resource\n");
    printf("        US  - Universal Security Enabled\n");
    printf("        AS  - Account Security Enabled\n");
    printf("        RS  - Resource Security Enabled\n");
    printf("        L   - Local\n");
    printf("        G   - Global\n");
    printf("        B   - Builtin\n");
    printf("        W   - Well-Known Security Principals\n");
    printf("    /Hidden\n");
    printf("       Include objects hidden from address book.\n");
    printf("    /Initialscope:{Computer|Domain|Gc|Tree|Xternal}\n");
    printf("    /Multiselect\n");
    printf("    /Namerestrict - reject names in unknown domains\n");
    printf("    /Providers:<provider>[,<provider>]\n");
    printf("       <provider> is one of:\n");
    printf("        WINNT\n");
    printf("        LDAP\n");
    printf("        GC\n");
    printf("    /Runcount:<n>\n");
    printf("        <n> is number of times to invoke object picker\n");
    printf("    /Scopes:<scope-spec>[,<scope-spec>]...\n");
    printf("       <scope-spec> is one of:\n");
    printf("        Computer[=name]\n");
    printf("        Domain[='<domain-spec>']\n");
    printf("        Gc\n");
    printf("        Tree\n");
    printf("        Xternal\n");
    printf("       <domain-spec> is one of:\n");
    printf("        <path> - the ADs path of a DS namespace\n");
    printf("        <name> - the flat name of a downlevel domain\n");
    printf("    /Users:<user-type>[,<user-type>]...\n");
    printf("       <user-type> is one of:\n");
    printf("        ALL - same as specifying each of the following\n");
    printf("        U   - User\n");
    printf("        C   - Contact\n");
    printf("        WORLD\n");
    printf("        AUTHENTICATED\n");
    printf("        ANONYMOUS\n");
    printf("        DIALUP\n");
    printf("        NETWORK\n");
    printf("        BATCH\n");
    printf("        INTERACTIVE\n");
    printf("        SERVICE\n");
    printf("        SYSTEM\n");
    printf("    /Xternal - force conversion of external paths to SIDs\n");
    printf("\n");
    printf("You must specify the Scope switch and at least one of the Computers,\n");
    printf("Groups, or Users switches.\n");
    printf("The significant characters in the switches are shown in upper case.\n");
}



//+---------------------------------------------------------------------------
//
//  Function:   AnsiToUnicode
//
//  Synopsis:   Convert ANSI string [szFrom] to Unicode string in buffer
//              [pwszTo].
//
//  Arguments:  [pwszTo] - destination buffer
//              [szFrom] - source string
//              [cchTo]  - size of destination buffer, in WCHARS
//
//  Returns:    S_OK               - conversion succeeded
//              HRESULT_FROM_WIN32 - MultiByteToWideChar failed
//
//  Modifies:   *[pwszTo]
//
//  History:    10-29-96   DavidMun   Created
//
//  Notes:      The string in [pwszTo] will be NULL terminated even on
//              failure.
//
//----------------------------------------------------------------------------

HRESULT
AnsiToUnicode(
    LPWSTR pwszTo,
    LPCSTR szFrom,
    LONG   cchTo)
{
    HRESULT hr = S_OK;
    ULONG   cchWritten;

    cchWritten = MultiByteToWideChar(CP_ACP, 0, szFrom, -1, pwszTo, cchTo);

    if (!cchWritten)
    {
        pwszTo[cchTo - 1] = L'\0';  // ensure NULL termination

        hr = HRESULT_FROM_WIN32(GetLastError());
        printf("AnsiToUnicode: MultiByteToWideChar hr=0x%x\n", hr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\test\dsopt\main.cxx ===
#include "headers.hxx"
#pragma hdrstop
#include <compobj.h>

#include <initguid.h>
#include <objsel.h>

PWSTR
ScopeTypeStr(
    ULONG flType);
LPWSTR
VariantString(
    VARIANT *pvar);
void
VarArrayToStr(
    VARIANT *pvar,
    LPWSTR wzBuf,
    ULONG cchBuf);


//
// Helpful macros
//
#define ARRAYLEN(a)                             (sizeof(a) / sizeof((a)[0]))

#define DBG_OUT_HRESULT(hr) printf("error 0x%x at line %u\n", hr, __LINE__)


#define BREAK_ON_FAIL_HRESULT(hr)   \
        if (FAILED(hr))             \
        {                           \
            DBG_OUT_HRESULT(hr);    \
            break;                  \
        }

VOID
DumpDsSelectedItemList(
    PDS_SELECTION_LIST pDsSelList,
    ULONG cRequestedAttributes,
    LPCTSTR *aptzRequestedAttributes)
{
    if (!pDsSelList)
    {
        printf("List is empty\n");
        return;
    }

    ULONG i;
    PDS_SELECTION pCur = &pDsSelList->aDsSelection[0];

    for (i = 0; i < pDsSelList->cItems; i++, pCur++)
    {
        printf("ScopeType:  %ws\n", ScopeTypeStr(pCur->flScopeType));
        printf("Name:       %ws\n", pCur->pwzName);
        printf("Class:      %ws\n", pCur->pwzClass);
        printf("Path:       %ws\n", pCur->pwzADsPath);
        printf("UPN:        %ws\n", pCur->pwzUPN);

        for (ULONG j = 0; j < cRequestedAttributes; j++)
        {
            printf("Attr %02u: %ws = %ws\n",
                   j,
                   aptzRequestedAttributes[j],
                   VariantString(&pCur->pvarFetchedAttributes[j]));
        }
        printf("\n");
    }
}


PWSTR
ScopeTypeStr(
    ULONG flType)
{
    switch (flType)
    {
    case DSOP_SCOPE_TYPE_TARGET_COMPUTER:
        return L"DSOP_SCOPE_TYPE_TARGET_COMPUTER";

    case DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN:
        return L"DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN";

    case DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN:
        return L"DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN";

    case DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN:
        return L"DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN";

    case DSOP_SCOPE_TYPE_GLOBAL_CATALOG:
        return L"DSOP_SCOPE_TYPE_GLOBAL_CATALOG";

    case DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN:
        return L"DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN";

    case DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN:
        return L"DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN";

    case DSOP_SCOPE_TYPE_WORKGROUP:
        return L"DSOP_SCOPE_TYPE_WORKGROUP";

    case DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE:
        return L"DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE";

    case DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE:
        return L"DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE";

    default:
        return L"*** invalid scope type ***";
    }
}


LPWSTR
VariantString(
    VARIANT *pvar)
{
    static WCHAR wzBuf[1024];

    wzBuf[0] = L'\0';

    switch (pvar->vt)
    {
    case VT_EMPTY:
        lstrcpy(wzBuf, L"VT_EMPTY");
        break;

    case VT_NULL:
        lstrcpy(wzBuf, L"VT_NULL");
        break;

    case VT_I2:
        wsprintf(wzBuf, L"%d", V_I2(pvar));
        break;

    case VT_I4:
        wsprintf(wzBuf, L"%d", V_I4(pvar));
        break;

    case VT_R4:
        wsprintf(wzBuf, L"%f", V_R4(pvar));
        break;

    case VT_R8:
        wsprintf(wzBuf, L"%f", V_R8(pvar));
        break;

    case VT_CY:
        wsprintf(wzBuf, L"$%f", V_CY(pvar));
        break;

    case VT_DATE:
        wsprintf(wzBuf, L"date %f", V_DATE(pvar));
        break;

    case VT_BSTR:
        if (V_BSTR(pvar))
        {
            wsprintf(wzBuf, L"'%ws'", V_BSTR(pvar));
        }
        else
        {
            lstrcpy(wzBuf, L"VT_BSTR NULL");
        }
        break;

    case VT_DISPATCH:
        wsprintf(wzBuf, L"VT_DISPATCH 0x%x", V_DISPATCH(pvar));
        break;

    case VT_UNKNOWN:
        wsprintf(wzBuf, L"VT_UNKNOWN 0x%x", V_UNKNOWN(pvar));
        break;

    case VT_ERROR:
    case VT_HRESULT:
        wsprintf(wzBuf, L"hr 0x%x", V_ERROR(pvar));
        break;

    case VT_BOOL:
        wsprintf(wzBuf, L"%s", V_BOOL(pvar) ? "TRUE" : "FALSE");
        break;

    case VT_VARIANT:
        wsprintf(wzBuf, L"variant 0x%x", V_VARIANTREF(pvar));
        break;

    case VT_DECIMAL:
        lstrcpy(wzBuf, L"VT_DECIMAL");
        break;

    case VT_I1:
        wsprintf(wzBuf, L"%d", V_I1(pvar));
        break;

    case VT_UI1:
        wsprintf(wzBuf, L"%u", V_UI1(pvar));
        break;

    case VT_UI2:
        wsprintf(wzBuf, L"%u", V_UI2(pvar));
        break;

    case VT_UI4:
        wsprintf(wzBuf, L"%u", V_UI4(pvar));
        break;

    case VT_I8:
        lstrcpy(wzBuf, L"VT_I8");
        break;

    case VT_UI8:
        lstrcpy(wzBuf, L"VT_UI8");
        break;

    case VT_INT:
        wsprintf(wzBuf, L"%d", V_INT(pvar));
        break;

    case VT_UINT:
        wsprintf(wzBuf, L"%u", V_UINT(pvar));
        break;

    case VT_VOID:
        lstrcpy(wzBuf, L"VT_VOID");
        break;

    case VT_UI1 | VT_ARRAY:
        VarArrayToStr(pvar, wzBuf, ARRAYLEN(wzBuf));
        break;

    case VT_PTR:
    case VT_SAFEARRAY:
    case VT_CARRAY:
    case VT_USERDEFINED:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_RECORD:
    case VT_FILETIME:
    case VT_BLOB:
    case VT_STREAM:
    case VT_STORAGE:
    case VT_STREAMED_OBJECT:
    case VT_STORED_OBJECT:
    case VT_BLOB_OBJECT:
    case VT_CF:
    case VT_CLSID:
    case VT_BSTR_BLOB:
    default:
        wsprintf(wzBuf, L"VT 0x%x", V_VT(pvar));
        break;
    }
    return wzBuf;
}



void
VarArrayToStr(
    VARIANT *pvar,
    LPWSTR wzBuf,
    ULONG cchBuf)
{
    ULONG i;
    LPWSTR pwzNext = wzBuf;
    LPWSTR pwzEnd = wzBuf + cchBuf;

    for (i = 0; i < pvar->parray->rgsabound[0].cElements && pwzNext < pwzEnd + 6; i++)
    {
        wsprintf(pwzNext, L"x%02x ", ((LPBYTE)(pvar->parray->pvData))[i]);
        pwzNext += lstrlen(pwzNext);
    }
}

//
// This example allows the user to pick a single computer object
// from any domain in the enterprise, the global catalog, or any
// user-specified domain.  If the target (local) computer is not
// joined to a domain, it allows the user to choose a computer
// object from the workgroup.
//

void func1(HWND hwndParent)
{
    HRESULT hr;
    IDsObjectPicker *pDsObjectPicker;

    hr = CoCreateInstance(CLSID_DsObjectPicker,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDsObjectPicker,
                          (void **) &pDsObjectPicker);

    DSOP_SCOPE_INIT_INFO aScopes[1];

    ZeroMemory(aScopes, sizeof(aScopes));

    aScopes[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopes[0].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN
                      | DSOP_SCOPE_TYPE_GLOBAL_CATALOG
                      | DSOP_SCOPE_TYPE_WORKGROUP
                      | DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE
                      | DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE;

    aScopes[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_COMPUTERS;
    aScopes[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_COMPUTERS;

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.cDsScopeInfos = 1;
    InitInfo.aDsScopeInfos = aScopes;

    hr = pDsObjectPicker->Initialize(&InitInfo);

    IDataObject *pdo = NULL;

    hr = pDsObjectPicker->InvokeDialog(hwndParent, &pdo);

    STGMEDIUM stgmedium =
    {
        TYMED_HGLOBAL,
        NULL
    };

    UINT cf = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

    FORMATETC formatetc =
    {
        cf,
        NULL,
        DVASPECT_CONTENT,
        -1,
        TYMED_HGLOBAL
    };

    hr = pdo->GetData(&formatetc, &stgmedium);

    PDS_SELECTION_LIST pDsSelList =
        (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

    ULONG i;

    for (i = 0; i < pDsSelList->cItems; i++)
    {
        printf("item %u: %ws\n", i + 1, pDsSelList->aDsSelection[i].pwzName);
    }
    GlobalUnlock(stgmedium.hGlobal);
    ReleaseStgMedium(&stgmedium);
    pdo->Release();
    pDsObjectPicker->Release();
}


//
// This example allows the user to select one or more objects which may
// legally be added to a security enabled global group.  It will not
// allow the user to specify objects which are contained in domains other
// than those in the enterprise.  The objectSid attribute is fetched for
// all selected objects.  The ADsPath of all selected objects is converted
// to a form using the WinNT provider.
//

void func2(HWND hwndParent)
{
    HRESULT hr;
    IDsObjectPicker *pDsObjectPicker;

    hr = CoCreateInstance(CLSID_DsObjectPicker,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IDsObjectPicker,
                          (void **) &pDsObjectPicker);

    PCWSTR apwzAttrs[] =
    {
        L"objectSid"
    };

    //
    // Specify the objects which should be displayed for the domain
    // to which the target computer is joined.
    //

    DSOP_SCOPE_INIT_INFO aScopes[2];

    ZeroMemory(aScopes, sizeof(aScopes));

    aScopes[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopes[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
                        | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
    aScopes[0].FilterFlags.Uplevel.flBothModes =
        DSOP_FILTER_USERS
        | DSOP_FILTER_CONTACTS
        | DSOP_FILTER_COMPUTERS;
    aScopes[0].FilterFlags.Uplevel.flNativeModeOnly =
        DSOP_FILTER_GLOBAL_GROUPS_DL
        | DSOP_FILTER_GLOBAL_GROUPS_SE;
    aScopes[0].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;

    // include downlevel filter in case target computer is joined to
    // an NT4 domain

    aScopes[0].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS;

    //
    // Specify the objects which should be displayed for all other
    // domains in the enterprise.
    //

    aScopes[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
    aScopes[1].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    aScopes[1].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_CONTACTS;
    aScopes[1].flScope = DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT;

    DSOP_INIT_INFO  InitInfo;
    ZeroMemory(&InitInfo, sizeof(InitInfo));

    InitInfo.cbSize = sizeof(InitInfo);
    InitInfo.cDsScopeInfos = 2;
    InitInfo.aDsScopeInfos = aScopes;
    InitInfo.flOptions = DSOP_FLAG_MULTISELECT;

    hr = pDsObjectPicker->Initialize(&InitInfo);

    IDataObject *pdo = NULL;

    hr = pDsObjectPicker->InvokeDialog(hwndParent, &pdo);


}

#include <initguid.h>
#include <objselp.h>

int _cdecl
main(int argc, char * argv[])
{
    HRESULT hr;
    IDsObjectPicker *pDsObjectPicker = NULL;

    do
    {
        hr = CoInitialize(NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPickerEx,
                              (void **) &pDsObjectPicker);
        BREAK_ON_FAIL_HRESULT(hr);

        DSOP_SCOPE_INIT_INFO aScopes[1];

        ZeroMemory(aScopes, sizeof(aScopes));

        aScopes[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        aScopes[0].flType = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN;
        aScopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
        aScopes[0].FilterFlags.Uplevel.flBothModes =
            DSOP_FILTER_WELL_KNOWN_PRINCIPALS
            | DSOP_FILTER_USERS;
        aScopes[0].FilterFlags.flDownlevel =
            DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS;

#if 0
        aScopes[0].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        aScopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;
        aScopes[0].flType =
            DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN
            | DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN;
        aScopes[0].FilterFlags.Uplevel.flMixedModeOnly =
            DSOP_FILTER_INCLUDE_ADVANCED_VIEW
            | DSOP_FILTER_USERS
            | DSOP_FILTER_BUILTIN_GROUPS
            | DSOP_FILTER_WELL_KNOWN_PRINCIPALS
            | DSOP_FILTER_GLOBAL_GROUPS_SE
            | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE
            | DSOP_FILTER_COMPUTERS;
        aScopes[0].FilterFlags.Uplevel.flNativeModeOnly =
            DSOP_FILTER_INCLUDE_ADVANCED_VIEW
            | DSOP_FILTER_USERS
            | DSOP_FILTER_BUILTIN_GROUPS
            | DSOP_FILTER_WELL_KNOWN_PRINCIPALS
            | DSOP_FILTER_UNIVERSAL_GROUPS_SE
            | DSOP_FILTER_GLOBAL_GROUPS_SE
            | DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE
            | DSOP_FILTER_COMPUTERS;
        aScopes[0].FilterFlags.flDownlevel = 0x800079fd;

        aScopes[1].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        aScopes[1].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG;
        aScopes[1].flScope = 0;
        aScopes[1].FilterFlags.Uplevel.flBothModes = 0x8a3;

        aScopes[2].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        aScopes[2].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
        aScopes[2].flScope = 0;
        aScopes[2].FilterFlags.Uplevel.flBothModes = 0x8a3;
        aScopes[2].FilterFlags.flDownlevel = 0x80000005;

        aScopes[3].cbSize = sizeof(DSOP_SCOPE_INIT_INFO);
        aScopes[3].flType =
            DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN
            | DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;
        aScopes[3].flScope = 0;
        aScopes[3].FilterFlags.Uplevel.flBothModes = 0x8a3;
        aScopes[3].FilterFlags.flDownlevel = 0x80000005;
#endif
        DSOP_INIT_INFO  InitInfo;
        ZeroMemory(&InitInfo, sizeof(InitInfo));

        PCWSTR apwzAttributeNames[] = {
            L"ObjectSid"
        };

        InitInfo.cbSize = sizeof(InitInfo);
        InitInfo.pwzTargetComputer = NULL;
        //InitInfo.flOptions = DSOP_FLAG_MULTISELECT;
        InitInfo.cDsScopeInfos = ARRAYLEN(aScopes);
        InitInfo.aDsScopeInfos = aScopes;
        InitInfo.cAttributesToFetch = ARRAYLEN(apwzAttributeNames);
        InitInfo.apwzAttributeNames = apwzAttributeNames;

        hr = pDsObjectPicker->Initialize(&InitInfo);
        BREAK_ON_FAIL_HRESULT(hr);

        IDataObject *pdo = NULL;

        hr = pDsObjectPicker->InvokeDialog(NULL, &pdo);
        BREAK_ON_FAIL_HRESULT(hr);

        if (hr == S_FALSE)
        {
            printf("User cancelled dialog\n");
            break;
        }

        STGMEDIUM stgmedium =
        {
            TYMED_HGLOBAL,
            NULL
        };

        UINT cf = RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST);

        FORMATETC formatetc =
        {
            cf,
            NULL,
            DVASPECT_CONTENT,
            -1,
            TYMED_HGLOBAL
        };

        hr = pdo->GetData(&formatetc, &stgmedium);
        BREAK_ON_FAIL_HRESULT(hr);

        PDS_SELECTION_LIST pDsSelList =
            (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);

        DumpDsSelectedItemList(
            pDsSelList,
            InitInfo.cAttributesToFetch,
            InitInfo.apwzAttributeNames);

        GlobalUnlock(stgmedium.hGlobal);
        ReleaseStgMedium(&stgmedium);
        pdo->Release();
    } while (0);

    if (pDsObjectPicker)
    {
        pDsObjectPicker->Release();
    }

    OutputDebugString(L"main.cxx: uninitializing OLE\n");
    CoUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\test\opt\glopres.h ===
#define IDC_ADD                         1000
#define IDD_GLOP                        1001
#define IDC_FILTER_LIST                 1002
#define IDR_MENU1                       1003
#define IDC_INIT_BUTTON                 1004
#define IDC_TARGET_COMPUTER_EDIT        1005
#define IDC_MULTISELECT_CHECK           1006
#define IDC_SKIP_DC_CHECK               1007
#define IDC_SCOPE_FILTER_LIST           1008
#define IDC_SCOPE_FLAG_LIST             1009
#define IDC_REMOVE                      1010

#define IDC_BOTH_RADIO                  1011
#define FIRST_MODE_RADIO                IDC_BOTH_RADIO
#define IDC_MIXED_RADIO                 1012
#define IDC_NATIVE_RADIO                1013
#define IDC_DOWNLEVEL_RADIO             1014
#define LAST_MODE_RADIO                 IDC_DOWNLEVEL_RADIO

#define IDC_ATTRIBUTES_EDIT             1015
#define IDC_SCOPE_LIST                  1016
#define IDC_INVOKE_BUTTON               1017
#define IDC_ADD_SCOPE_RADIO1            1018
#define FIRST_SCOPE_RADIO               IDC_ADD_SCOPE_RADIO1
#define IDC_ADD_SCOPE_RADIO2            1019
#define IDC_ADD_SCOPE_RADIO3            1020
#define IDC_ADD_SCOPE_RADIO4            1021
#define IDC_ADD_SCOPE_RADIO5            1022
#define IDC_ADD_SCOPE_RADIO6            1023
#define IDC_ADD_SCOPE_RADIO7            1024
#define IDC_ADD_SCOPE_RADIO8            1025
#define IDC_ADD_SCOPE_RADIO9            1026
#define IDC_ADD_SCOPE_RADIO10           1027
#define LAST_SCOPE_RADIO                IDC_ADD_SCOPE_RADIO10
#define IDD_ADD_SCOPE                   1028
#define IDC_RELEASE_BUTTON              1029
#define IDC_COCREATE_BUTTON             1030







#define IDM_OPEN                        40001
#define IDM_SAVE                        40002
#define IDM_EXIT                        40003
#define IDM_LUM                         40004
#define IDM_ACL_FILE                    40005
#define IDM_SAVE_AS                     40006
#define IDC_STATIC                      -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\test\listview\listtest.cpp ===
// test listview control for broken rendering



#include "headers.hxx"
#include "resource.h"



HINSTANCE hResourceModuleHandle = 0;
const wchar_t* HELPFILE_NAME = 0;   // no context help available
const wchar_t* RUNTIME_NAME = L"listtest";
DWORD DEFAULT_LOGGING_OPTIONS = Log::OUTPUT_TYPICAL;



void
AddIconImage(HIMAGELIST imageList, int iconResID)
{
   LOG_FUNCTION(AddIconImage);
   ASSERT(imageList);
   ASSERT(iconResID);
   
   if (iconResID && imageList)
   {
      HICON icon = 0;
      HRESULT hr = Win::LoadImage(iconResID, icon);

      ASSERT(SUCCEEDED(hr));

      if (SUCCEEDED(hr))
      {
         Win::ImageList_AddIcon(imageList, icon);

         // once the icon is added (copied) to the image list, we can
         // destroy the original.

         Win::DestroyIcon(icon);
      }
   }
}


static const DWORD HELP_MAP[] =
{
   0, 0
};

class ListViewDialog : public Dialog
{
   public:

   ListViewDialog()
      :
      Dialog(IDD_LOOK_FOR, HELP_MAP)
   {
   }

   ~ListViewDialog()
   {
   }

   protected:

   // Dialog overrides

   virtual
   void
   OnInit()
   {
      HWND listview = Win::GetDlgItem(hwnd, IDC_LOOK_FOR_LV);
      
      //
      // put listview in checkbox style
      //

      ListView_SetExtendedListViewStyleEx(
         listview,
         LVS_EX_CHECKBOXES,
         LVS_EX_CHECKBOXES);

//ImageList_Create(16, 16, ILC_COLOR16 | ILC_MASK, 1, 1);
         
      HIMAGELIST images =
         Win::ImageList_Create(
            16, // Win::GetSystemMetrics(SM_CXSMICON),
            16, // Win::GetSystemMetrics(SM_CYSMICON),
            ILC_MASK,
            1,
            1);
   
      // the order in which these are added must be the same that the
      // MemberInfo::Type enum values are listed!
   
      AddIconImage(images, IDI_SCOPE_WORKGROUP);
      AddIconImage(images, IDI_LOCAL_GROUP);
      AddIconImage(images, IDI_SCOPE_DIRECTORY);
      AddIconImage(images, IDI_SCOPE_DOMAIN);
      AddIconImage(images, IDI_DISABLED_USER);
      AddIconImage(images, IDI_DISABLED_COMPUTER);
   
      Win::ListView_SetImageList(listview, images, LVSIL_SMALL);
      
      //
      // Add a single column to the listview
      //

      LV_COLUMN   lvc;
      RECT        rcLv;

      GetClientRect(listview, &rcLv);
      ZeroMemory(&lvc, sizeof lvc);
      lvc.mask = LVCF_FMT | LVCF_WIDTH;
      lvc.fmt  = LVCFMT_LEFT;
      lvc.cx = rcLv.right;
      Win::ListView_InsertColumn(listview, 0, lvc);

      static PCWSTR itemLabels[] =
      {
         L"workgroup",
         L"Group",
         L"Directory",
         L"Domain",
         L"User",
         L"Computer",
         0
      };
            
      LVITEM  lvi;
      int i = 0;
      PCWSTR* labels = itemLabels;

      while (*labels)
      {
         ZeroMemory(&lvi, sizeof lvi);
         lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
         lvi.pszText = const_cast<PWSTR>(*labels);
         lvi.iImage = i;
         ++labels;
         ++i;
         
         Win::ListView_InsertItem(listview, lvi);
      };
      

      //
      // Make the first item in the listview have the focus
      //

      ListView_SetItemState(
         listview,
         0,
         LVIS_FOCUSED | LVIS_SELECTED,
         LVIS_FOCUSED | LVIS_SELECTED);
   }

   private:

   ListViewDialog(const ListViewDialog&);
   const ListViewDialog& operator=(const ListViewDialog&);   
};




int WINAPI
WinMain(
   HINSTANCE   hInstance,
   HINSTANCE   /* hPrevInstance */ ,
   PSTR        /* lpszCmdLine */ ,
   int         /* nCmdShow */)
{
   hResourceModuleHandle = hInstance;

   int exitCode = 0;

   INITCOMMONCONTROLSEX sex;
   sex.dwSize = sizeof(sex);      
   sex.dwICC  = ICC_ANIMATE_CLASS | ICC_USEREX_CLASSES;

   BOOL init = ::InitCommonControlsEx(&sex);
   ASSERT(init);
         
   ListViewDialog().ModalExecute(Win::GetDesktopWindow());
            
   return exitCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\test\opt\main.cxx ===
#include "headers.hxx"
#pragma hdrstop
#include "glopres.h"

const wchar_t* RUNTIME_NAME = L"opt";
#define DOWNLEVEL_FILTER_BIT        0x80000000

unsigned long  DEFAULT_LOGGING_OPTIONS = 0;
HINSTANCE hResourceModuleHandle;
#define ARRAYLEN(a)                             (sizeof(a) / sizeof((a)[0]))

#define DBG_OUT_HRESULT(hr) printf("error 0x%x at line %u\n", hr, __LINE__)


#define BREAK_ON_FAIL_HRESULT(hr)   \
        if (FAILED(hr))             \
        {                           \
            DBG_OUT_HRESULT(hr);    \
            break;                  \
        }
enum SCOPE_TYPE
{
    ST_INVALID = 0,
    ST_TARGET_COMPUTER              = DSOP_SCOPE_TYPE_TARGET_COMPUTER,
    ST_UPLEVEL_JOINED_DOMAIN        = DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,
    ST_DOWNLEVEL_JOINED_DOMAIN      = DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN,
    ST_ENTERPRISE_DOMAIN            = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN,
    ST_GLOBAL_CATALOG               = DSOP_SCOPE_TYPE_GLOBAL_CATALOG,
    ST_EXTERNAL_UPLEVEL_DOMAIN      = DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN,
    ST_EXTERNAL_DOWNLEVEL_DOMAIN    = DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN,
    ST_WORKGROUP                    = DSOP_SCOPE_TYPE_WORKGROUP,
    ST_USER_ENTERED_UPLEVEL_SCOPE   = DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE,
    ST_USER_ENTERED_DOWNLEVEL_SCOPE = DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE,
    ST_LDAP_CONTAINER               = 0x00000400
};

BOOL
IsUplevel(
    SCOPE_TYPE Type)
{
    switch (Type)
    {
    case ST_ENTERPRISE_DOMAIN:
    case ST_GLOBAL_CATALOG:
    case ST_UPLEVEL_JOINED_DOMAIN:
    case ST_EXTERNAL_UPLEVEL_DOMAIN:
    case ST_USER_ENTERED_UPLEVEL_SCOPE:
    case ST_LDAP_CONTAINER:
        return TRUE;

    default:
        return FALSE;
    }
}

PWSTR
ScopeNameFromType(ULONG st)
{
    PWSTR pwz = L"unknown";

    switch (st)
    {
    case DSOP_SCOPE_TYPE_TARGET_COMPUTER:
        pwz = L"Target Computer";
        break;

    case DSOP_SCOPE_TYPE_GLOBAL_CATALOG:
        pwz = L"Global Catalog";
        break;

    case DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN:
        pwz = L"Uplevel Joined Domain";
        break;

    case DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN:
        pwz = L"Enterprise Domain";
        break;

    case DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN:
        pwz = L"External Uplevel Domain";
        break;

    case DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN:
        pwz = L"External Downlevel Domain";
        break;

    case DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN:
        pwz = L"Downlevel Joined Domain";
        break;

    case DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE:
        pwz = L"User Entered Uplevel Scope";
        break;

    case DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE:
        pwz = L"User Entered Downlevel Scope";
        break;

    case DSOP_SCOPE_TYPE_WORKGROUP:
        pwz = L"Workgroup";
        break;
    }
    return pwz;
}

void
NewDupStr(
    PWSTR *ppwzDup,
    PCWSTR wszSrc)
{
    if (wszSrc)
    {
        *ppwzDup = new WCHAR[lstrlen(wszSrc) + 1];
        lstrcpy(*ppwzDup, wszSrc);
    }
    else
    {
        *ppwzDup = NULL;
    }
}

class CScopeInitInfo: public DSOP_SCOPE_INIT_INFO
{
public:

    CScopeInitInfo() { ZeroMemory(this, sizeof *this); cbSize = sizeof *this; }

    CScopeInitInfo(const CScopeInitInfo &ToCopy)
    {
                ZeroMemory(this, sizeof *this);
        CScopeInitInfo::operator =(ToCopy);
    }

    ~CScopeInitInfo()
    {
        delete [] const_cast<PWSTR>(pwzDcName);
        pwzDcName = NULL;
        delete [] const_cast<PWSTR>(pwzADsPath);
        pwzADsPath = NULL;
    }

    CScopeInitInfo &
    operator =(const CScopeInitInfo &rhs)
    {
        cbSize = rhs.cbSize;
        flType = rhs.flType;
        flScope = rhs.flScope;
        delete [] const_cast<PWSTR>(pwzDcName);
        NewDupStr(const_cast<PWSTR*>(&pwzDcName), rhs.pwzDcName);
        delete [] const_cast<PWSTR>(pwzADsPath);
        NewDupStr(const_cast<PWSTR*>(&pwzADsPath), rhs.pwzADsPath);
        hr = rhs.hr;
        FilterFlags.Uplevel.flBothModes = rhs.FilterFlags.Uplevel.flBothModes;
        FilterFlags.Uplevel.flMixedModeOnly = rhs.FilterFlags.Uplevel.flMixedModeOnly;
        FilterFlags.Uplevel.flNativeModeOnly = rhs.FilterFlags.Uplevel.flNativeModeOnly;
        FilterFlags.flDownlevel = rhs.FilterFlags.flDownlevel;
        return *this;
    }
};


class COpTestDlg: public CDlg
{
public:

    COpTestDlg():
        m_pop(NULL),
        m_idcLastRadioClicked(0),
        m_fIgnoreNotifications(FALSE)
    {
        m_wzFilename[0] = L'\0';
    }

    ~COpTestDlg()
    {
        if (m_pop)
        {
            m_pop->Release();
            m_pop = NULL;
        }
    }

    void
    DoModalDialog(HWND hwnd)
    {
        _DoModalDlg(hwnd, IDD_GLOP);
    }

    HRESULT
    Init()
    {
        HRESULT
        hr = CoCreateInstance(CLSID_DsObjectPicker,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IDsObjectPicker,
                              (void **) &m_pop);
        if (FAILED(hr))
        {
            DBG_OUT_HRESULT(hr);
        }
        return hr;
    }

protected:
    virtual BOOL _OnCommand(WPARAM wParam, LPARAM lParam);
    virtual HRESULT _OnInit(BOOL *pfSetFocus);
    virtual BOOL _OnNotify(WPARAM, LPARAM);

private:

    void
    _AddScope(
        ULONG stNew);

    void
    _SetFlagFilterUiFromInitInfo(int iItem);

    void
    _SetInitInfoFromFlagFilterUi(int iItem);

    void
    _PopulateScopeFlagList();

    void
    _PopulateFilterList(
        BOOL fUplevel);

    void
    _EnableScopeFlagWindows(
        BOOL fEnable);

    void
    _SaveAs();

    void
    _Save();

    void
    _Load();

    void
    _Clear();

    void
    _InitObjectPicker();

    void
    _PresetLocalUserManager();

    void
    _PresetAclUiFile();

    IDsObjectPicker                *m_pop;
    vector<CScopeInitInfo>          m_vsii;
    ULONG                           m_idcLastRadioClicked;
    WCHAR                           m_wzFilename[MAX_PATH];
    BOOL                            m_fIgnoreNotifications;
};

class CAddScopeDlg: public CDlg
{
public:

    CAddScopeDlg(): m_stNew(0) {}

    void
    DoModal(HWND hwndParent)
    {
        _DoModalDlg(hwndParent, IDD_ADD_SCOPE);
    }
    ULONG
    GetNewScopeType()
    {
        return m_stNew;
    }
protected:

    virtual HRESULT
    _OnInit(
        BOOL *pfSetFocus)
    {
        CheckRadioButton(m_hwnd, FIRST_SCOPE_RADIO, LAST_SCOPE_RADIO, IDC_ADD_SCOPE_RADIO1);
        return S_OK;
    }

    virtual BOOL _OnCommand(WPARAM wParam, LPARAM lParam);

private:

    ULONG   m_stNew;
};


void
COpTestDlg::_EnableScopeFlagWindows(
    BOOL fEnable)
{
    EnableWindow(_hCtrl(IDC_SCOPE_FLAG_LIST), fEnable);
    EnableWindow(_hCtrl(IDC_SCOPE_FILTER_LIST), fEnable);
    EnableWindow(_hCtrl(IDC_BOTH_RADIO), fEnable);
    EnableWindow(_hCtrl(IDC_MIXED_RADIO), fEnable);
    EnableWindow(_hCtrl(IDC_NATIVE_RADIO), fEnable);
    EnableWindow(_hCtrl(IDC_DOWNLEVEL_RADIO), fEnable);
}


BOOL
CAddScopeDlg::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    static ULONG s_ast[] =
    {
        DSOP_SCOPE_TYPE_TARGET_COMPUTER,
        DSOP_SCOPE_TYPE_GLOBAL_CATALOG,
        DSOP_SCOPE_TYPE_UPLEVEL_JOINED_DOMAIN,
        DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN,
        DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN,
        DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN,
        DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN,
        DSOP_SCOPE_TYPE_USER_ENTERED_UPLEVEL_SCOPE,
        DSOP_SCOPE_TYPE_USER_ENTERED_DOWNLEVEL_SCOPE,
        DSOP_SCOPE_TYPE_WORKGROUP
    };

    if (LOWORD(wParam) == IDCANCEL)
    {
        EndDialog(m_hwnd, 0);
        return FALSE;
    }

    if (LOWORD(wParam) != (WORD)IDOK)
    {
        return FALSE;
    }

    for (int i = IDC_ADD_SCOPE_RADIO1; i <= LAST_SCOPE_RADIO; i++)
    {
        if (IsDlgButtonChecked(m_hwnd, i))
        {
            m_stNew = s_ast[i - IDC_ADD_SCOPE_RADIO1];
        }
    }
    EndDialog(m_hwnd, 0);
    return FALSE;
}



struct SScopeFlagInfo
{
    LPWSTR  pwzName;
    ULONG   flValue;
};

static SScopeFlagInfo s_ScopeFlagInfo[] =
{
    {L"Starting scope", DSOP_SCOPE_FLAG_STARTING_SCOPE},
    {L"Default users", DSOP_SCOPE_FLAG_DEFAULT_FILTER_USERS},
    {L"Default groups", DSOP_SCOPE_FLAG_DEFAULT_FILTER_GROUPS},
    {L"Default computers", DSOP_SCOPE_FLAG_DEFAULT_FILTER_COMPUTERS},
    {L"Default contacts", DSOP_SCOPE_FLAG_DEFAULT_FILTER_CONTACTS},
    {L"Convert provider to WinNT", DSOP_SCOPE_FLAG_WANT_PROVIDER_WINNT},
    {L"Convert provider to LDAP", DSOP_SCOPE_FLAG_WANT_PROVIDER_LDAP},
    {L"Convert provider to GC", DSOP_SCOPE_FLAG_WANT_PROVIDER_GC},
    {L"Want SID path", DSOP_SCOPE_FLAG_WANT_SID_PATH},
    {L"Want downlevel builtins to have path", DSOP_SCOPE_FLAG_WANT_DOWNLEVEL_BUILTIN_PATH}
};

struct SScopeFilterInfo
{
    LPWSTR pwzName;
    ULONG flValue;
};

static SScopeFlagInfo s_DownlevelScopeFilterInfo[] =
{
    {L"Downlevel users", DSOP_DOWNLEVEL_FILTER_USERS},
    {L"Downlevel local groups", DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS},
    {L"Downlevel global groups", DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS},
    {L"Downlevel computers", DSOP_DOWNLEVEL_FILTER_COMPUTERS},
    {L"Downlevel world", DSOP_DOWNLEVEL_FILTER_WORLD},
    {L"Downlevel authenticated user", DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER},
    {L"Downlevel anonymous", DSOP_DOWNLEVEL_FILTER_ANONYMOUS},
    {L"Downlevel batch", DSOP_DOWNLEVEL_FILTER_BATCH},
    {L"Downlevel creator owner", DSOP_DOWNLEVEL_FILTER_CREATOR_OWNER},
    {L"Downlevel creator group", DSOP_DOWNLEVEL_FILTER_CREATOR_GROUP},
    {L"Downlevel dialup", DSOP_DOWNLEVEL_FILTER_DIALUP},
    {L"Downlevel interactive", DSOP_DOWNLEVEL_FILTER_INTERACTIVE},
    {L"Downlevel network", DSOP_DOWNLEVEL_FILTER_NETWORK},
    {L"Downlevel service", DSOP_DOWNLEVEL_FILTER_SERVICE},
    {L"Downlevel system", DSOP_DOWNLEVEL_FILTER_SYSTEM},
    {L"Downlevel exclude builtin groups", DSOP_DOWNLEVEL_FILTER_EXCLUDE_BUILTIN_GROUPS},
    {L"Downlevel terminal server", DSOP_DOWNLEVEL_FILTER_TERMINAL_SERVER},
    {L"Downlevel local service", DSOP_DOWNLEVEL_FILTER_LOCAL_SERVICE},
    {L"Downlevel network service", DSOP_DOWNLEVEL_FILTER_NETWORK_SERVICE},
    {L"Downlevel remote logon", DSOP_DOWNLEVEL_FILTER_REMOTE_LOGON},
    {L"Downlevel all well-known SIDs", DSOP_DOWNLEVEL_FILTER_ALL_WELLKNOWN_SIDS}
};

static SScopeFlagInfo s_UplevelScopeFilterInfo[] =
{
    {L"Include advanced view", DSOP_FILTER_INCLUDE_ADVANCED_VIEW},
    {L"Users",                  DSOP_FILTER_USERS},
    {L"Builtin groups",             DSOP_FILTER_BUILTIN_GROUPS},
    {L"Well-known principals", DSOP_FILTER_WELL_KNOWN_PRINCIPALS},
    {L"Universal groups DL",        DSOP_FILTER_UNIVERSAL_GROUPS_DL},
    {L"Universal groups SE",        DSOP_FILTER_UNIVERSAL_GROUPS_SE},
    {L"Global groups DL",       DSOP_FILTER_GLOBAL_GROUPS_DL},
    {L"Global groups SE",       DSOP_FILTER_GLOBAL_GROUPS_SE},
    {L"Domain local groups DL", DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL},
    {L"Domain local groups SE", DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE},
    {L"Contacts",                DSOP_FILTER_CONTACTS},
    {L"Computers",                  DSOP_FILTER_COMPUTERS}
};


HRESULT
COpTestDlg::_OnInit(
    BOOL *pfSetFocus)
{
    LV_COLUMN   lvc;
    RECT        rcLv;
    HWND        hwndLv;

    ZeroMemory(&lvc, sizeof lvc);
    lvc.mask = LVCF_FMT | LVCF_WIDTH;
    lvc.fmt  = LVCFMT_LEFT;

    hwndLv = _hCtrl(IDC_SCOPE_LIST);
    GetClientRect(hwndLv, &rcLv);
    lvc.cx = rcLv.right - GetSystemMetrics(SM_CXVSCROLL);
    ListView_InsertColumn(hwndLv, 0, &lvc);

    hwndLv = _hCtrl(IDC_SCOPE_FLAG_LIST);
    GetClientRect(hwndLv, &rcLv);
    lvc.cx = rcLv.right - GetSystemMetrics(SM_CXVSCROLL);
    ListView_InsertColumn(hwndLv, 0, &lvc);

    hwndLv = _hCtrl(IDC_SCOPE_FILTER_LIST);
    GetClientRect(hwndLv, &rcLv);
    lvc.cx = rcLv.right - GetSystemMetrics(SM_CXVSCROLL);
    ListView_InsertColumn(hwndLv, 0, &lvc);

    ListView_SetExtendedListViewStyleEx(_hCtrl(IDC_SCOPE_LIST),
                                        LVS_EX_FULLROWSELECT,
                                        LVS_EX_FULLROWSELECT);

    ListView_SetExtendedListViewStyleEx(_hCtrl(IDC_SCOPE_FILTER_LIST),
                                        LVS_EX_CHECKBOXES,
                                        LVS_EX_CHECKBOXES);

    ListView_SetExtendedListViewStyleEx(_hCtrl(IDC_SCOPE_FLAG_LIST),
                                        LVS_EX_CHECKBOXES,
                                        LVS_EX_CHECKBOXES);

    _EnableScopeFlagWindows(FALSE);
    SetMenu(m_hwnd, LoadMenu(hResourceModuleHandle, MAKEINTRESOURCE(IDR_MENU1)));
    CheckRadioButton(m_hwnd, FIRST_SCOPE_RADIO, LAST_SCOPE_RADIO, IDC_BOTH_RADIO);

    EnableWindow(_hCtrl(IDC_COCREATE_BUTTON), FALSE);
    return S_OK;
}

BOOL
COpTestDlg::_OnNotify(
    WPARAM wParam,
    LPARAM lParam)
{
    LPNMHDR pnmh = reinterpret_cast<LPNMHDR> (lParam);
    BOOL fResult = TRUE;

    if (m_fIgnoreNotifications)
    {
        return fResult;
    }
    if (pnmh->idFrom == IDC_SCOPE_LIST)
    {
        LPNMLISTVIEW pnmlv = reinterpret_cast<LPNMLISTVIEW> (lParam);

        switch(pnmh->code)
        {
        case LVN_ITEMCHANGING:
            if (pnmlv->uOldState & LVIS_SELECTED &&
                !(pnmlv->uNewState & LVIS_SELECTED))
            {
                _SetInitInfoFromFlagFilterUi(pnmlv->iItem);
            }

            break;

        case LVN_ITEMCHANGED:
            if (pnmlv->uNewState & LVIS_SELECTED &&
                !(pnmlv->uOldState & LVIS_SELECTED))
            {
                _SetFlagFilterUiFromInitInfo(pnmlv->iItem);
            }
            break;
        }
    }
    return fResult;
}


void
COpTestDlg::_SetFlagFilterUiFromInitInfo(
    int iItem)
{
    if (iItem < 0)
    {
        return;
    }
    HWND hwndLv = _hCtrl(IDC_SCOPE_FLAG_LIST);

    for (int i = 0; i < ARRAYLEN(s_ScopeFlagInfo); i++)
    {
        if (m_vsii[iItem].flScope & s_ScopeFlagInfo[i].flValue)
        {
            ListView_SetCheckState(hwndLv, i, TRUE);
        }
        else
        {
            ListView_SetCheckState(hwndLv, i, FALSE);
        }
    }

    ULONG *pFilter = NULL;
    BOOL fShowingUplevel = TRUE;

    if (Button_GetCheck(_hCtrl(IDC_BOTH_RADIO)) == BST_CHECKED)
    {
        pFilter = &m_vsii[iItem].FilterFlags.Uplevel.flBothModes;
    }
    else if (Button_GetCheck(_hCtrl(IDC_MIXED_RADIO)) == BST_CHECKED)
    {
        pFilter = &m_vsii[iItem].FilterFlags.Uplevel.flMixedModeOnly;
    }
    else if (Button_GetCheck(_hCtrl(IDC_NATIVE_RADIO)) == BST_CHECKED)
    {
        pFilter = &m_vsii[iItem].FilterFlags.Uplevel.flNativeModeOnly;
    }
    else if (Button_GetCheck(_hCtrl(IDC_DOWNLEVEL_RADIO)) == BST_CHECKED)
    {
        pFilter = &m_vsii[iItem].FilterFlags.flDownlevel;
        fShowingUplevel = FALSE;
    }

    if (!pFilter)
    {
        return;
    }

    hwndLv = _hCtrl(IDC_SCOPE_FILTER_LIST);
    if (!ListView_GetItemCount(hwndLv))
    {
        return;
    }
    if (fShowingUplevel)
    {
        for (i = 0; i < ARRAYLEN(s_UplevelScopeFilterInfo); i++)
        {
            if (*pFilter & s_UplevelScopeFilterInfo[i].flValue)
            {
                ListView_SetCheckState(hwndLv, i, TRUE);
            }
            else
            {
                ListView_SetCheckState(hwndLv, i, FALSE);
            }
        }
    }
    else
    {
        for (i = 0; i < ARRAYLEN(s_DownlevelScopeFilterInfo); i++)
        {
            if ((*pFilter & s_DownlevelScopeFilterInfo[i].flValue) ==
                s_DownlevelScopeFilterInfo[i].flValue)
            {
                ListView_SetCheckState(hwndLv, i, TRUE);
            }
            else
            {
                ListView_SetCheckState(hwndLv, i, FALSE);
            }
        }
    }
}


void
COpTestDlg::_SetInitInfoFromFlagFilterUi(int iItem)
{
    if (iItem < 0)
    {
        return;
    }
    HWND hwndLv = _hCtrl(IDC_SCOPE_FLAG_LIST);

    for (int i = 0; i < ARRAYLEN(s_ScopeFlagInfo); i++)
    {
        if (ListView_GetCheckState(hwndLv, i))
        {
            m_vsii[iItem].flScope |= s_ScopeFlagInfo[i].flValue;
        }
        else
        {
            m_vsii[iItem].flScope &= ~s_ScopeFlagInfo[i].flValue;
        }
    }

    if (!m_idcLastRadioClicked)
    {
        return;
    }

    ULONG *pFilter = NULL;
    BOOL fShowingUplevel = TRUE;

    if (m_idcLastRadioClicked == IDC_BOTH_RADIO)
    {
        pFilter = &m_vsii[iItem].FilterFlags.Uplevel.flBothModes;
    }
    else if (m_idcLastRadioClicked == IDC_MIXED_RADIO)
    {
        pFilter = &m_vsii[iItem].FilterFlags.Uplevel.flMixedModeOnly;
    }
    else if (m_idcLastRadioClicked == IDC_NATIVE_RADIO)
    {
        pFilter = &m_vsii[iItem].FilterFlags.Uplevel.flNativeModeOnly;
    }
    else if (m_idcLastRadioClicked == IDC_DOWNLEVEL_RADIO)
    {
        pFilter = &m_vsii[iItem].FilterFlags.flDownlevel;
        fShowingUplevel = FALSE;
    }

    if (!pFilter)
    {
        return;
    }

    hwndLv = _hCtrl(IDC_SCOPE_FILTER_LIST);

    if (!ListView_GetItemCount(hwndLv))
    {
        return;
    }

    if (fShowingUplevel)
    {
        for (i = 0; i < ARRAYLEN(s_UplevelScopeFilterInfo); i++)
        {
            if (ListView_GetCheckState(hwndLv, i))
            {
                *pFilter |= s_UplevelScopeFilterInfo[i].flValue;
            }
            else
            {
                *pFilter &= ~s_UplevelScopeFilterInfo[i].flValue;
            }
        }
    }
    else
    {
        for (i = 0; i < ARRAYLEN(s_DownlevelScopeFilterInfo); i++)
        {
            if (ListView_GetCheckState(hwndLv, i))
            {
                *pFilter |= s_DownlevelScopeFilterInfo[i].flValue;
            }
            else
            {
                *pFilter &= ~s_DownlevelScopeFilterInfo[i].flValue;
                if (*pFilter)
                {
                    *pFilter |= DOWNLEVEL_FILTER_BIT;
                }
            }
        }
    }
}

#define GetFirstSelected(hwndLv) ListView_GetNextItem(hwndLv, -1, LVNI_SELECTED)

BOOL
COpTestDlg::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = TRUE;

    if (m_fIgnoreNotifications)
    {
        return FALSE;
    }

    switch (LOWORD(wParam))
    {
    case IDC_ADD:
    {
        CAddScopeDlg    dlg;

        dlg.DoModal(m_hwnd);
        ULONG stNew = dlg.GetNewScopeType();
        if (stNew)
        {
            _AddScope(stNew);
        }
        break;
    }

    case IDC_REMOVE:
    {
        int iItem = GetFirstSelected(_hCtrl(IDC_SCOPE_LIST));

        if (iItem == -1)
        {
            break;
        }

        ListView_DeleteItem(_hCtrl(IDC_SCOPE_LIST), iItem);
        m_vsii.erase(m_vsii.begin() + iItem);

        if (m_vsii.empty())
        {
            _Clear();
            _EnableScopeFlagWindows(FALSE);
        }
        break;
    }

    case IDM_OPEN:
        _Clear();
        _Load();
        if (ListView_GetItemCount(_hCtrl(IDC_SCOPE_LIST)) > 0)
        {
            m_fIgnoreNotifications = TRUE;
            ListView_SetItemState(_hCtrl(IDC_SCOPE_LIST), 0, LVIS_SELECTED, LVIS_SELECTED);
            _SetFlagFilterUiFromInitInfo(0);
            m_fIgnoreNotifications = FALSE;
        }
        else
        {
            _EnableScopeFlagWindows(FALSE);
        }
        break;

    case IDM_SAVE:
        _SetInitInfoFromFlagFilterUi(GetFirstSelected(_hCtrl(IDC_SCOPE_LIST)));
        _Save();
        break;

    case IDM_SAVE_AS:
        _SetInitInfoFromFlagFilterUi(GetFirstSelected(_hCtrl(IDC_SCOPE_LIST)));
        _SaveAs();
        break;

    case IDM_LUM:
        _PresetLocalUserManager();
        break;

    case IDM_ACL_FILE:
        _PresetAclUiFile();
        break;

    case IDM_EXIT:
    case IDCANCEL:
        EndDialog(GetHwnd(), 0);
        break;

    case IDC_DOWNLEVEL_RADIO:
    case IDC_BOTH_RADIO:
    case IDC_MIXED_RADIO:
    case IDC_NATIVE_RADIO:
        if (HIWORD(wParam) == BN_CLICKED)
        {
            _SetInitInfoFromFlagFilterUi(GetFirstSelected(_hCtrl(IDC_SCOPE_LIST)));
            _PopulateFilterList(LOWORD(wParam) != IDC_DOWNLEVEL_RADIO);
            _SetFlagFilterUiFromInitInfo(GetFirstSelected(_hCtrl(IDC_SCOPE_LIST)));
            m_idcLastRadioClicked = LOWORD(wParam);
        }
        break;

    case IDC_INIT_BUTTON:
        _InitObjectPicker();
        break;

    case IDC_COCREATE_BUTTON:
        if (!m_pop)
        {
            HRESULT hr = CoCreateInstance(CLSID_DsObjectPicker,
                                          NULL,
                                          CLSCTX_INPROC_SERVER,
                                          IID_IDsObjectPicker,
                                          (void **) &m_pop);
            BREAK_ON_FAIL_HRESULT(hr);

            EnableWindow(_hCtrl(IDC_COCREATE_BUTTON), FALSE);
            EnableWindow(_hCtrl(IDC_RELEASE_BUTTON), TRUE);
            EnableWindow(_hCtrl(IDC_INIT_BUTTON), TRUE);
            EnableWindow(_hCtrl(IDC_INVOKE_BUTTON), TRUE);
        }
        else
        {
            MessageBeep(0);
        }
        break;

    case IDC_RELEASE_BUTTON:
        if (m_pop)
        {
            m_pop->Release();
            m_pop = NULL;
            EnableWindow(_hCtrl(IDC_RELEASE_BUTTON), FALSE);
            EnableWindow(_hCtrl(IDC_COCREATE_BUTTON), TRUE);
            EnableWindow(_hCtrl(IDC_INIT_BUTTON), FALSE);
            EnableWindow(_hCtrl(IDC_INVOKE_BUTTON), FALSE);
        }
        break;

    case IDC_INVOKE_BUTTON:
    {
        IDataObject *pdo;
        m_pop->InvokeDialog(m_hwnd, &pdo);
        if (pdo)
        {
            STGMEDIUM stgmedium =
            {
                TYMED_HGLOBAL,
                NULL
            };

            FORMATETC formatetc =
            {
                static_cast<CLIPFORMAT>(RegisterClipboardFormat(CFSTR_DSOP_DS_SELECTION_LIST)),
                NULL,
                DVASPECT_CONTENT,
                -1,
                TYMED_HGLOBAL
            };

            pdo->GetData(&formatetc, &stgmedium);

            ReleaseStgMedium(&stgmedium);
            pdo->Release();
        }
        break;
    }

    default:
        fHandled = FALSE;
        break;
    }

    return fHandled;
}

void
COpTestDlg::_PresetLocalUserManager()
{
    _Clear();
    m_fIgnoreNotifications = TRUE;
    CheckDlgButton(m_hwnd, IDC_MULTISELECT_CHECK, BST_CHECKED);
    Edit_SetText(_hCtrl(IDC_ATTRIBUTES_EDIT), L"groupType; ObjectSID");
    m_vsii.reserve(7);

    CScopeInitInfo sii;

    sii.flType =                                0x1;
    sii.flScope =                               0x21;
    sii.FilterFlags.Uplevel.flBothModes =       0x2;
    sii.FilterFlags.Uplevel.flMixedModeOnly =   0x0;
    sii.FilterFlags.Uplevel.flNativeModeOnly =  0x0;
    sii.FilterFlags.flDownlevel =               0x80020001;
    m_vsii.push_back(sii);

    sii.flType =                               0x2;
    sii.flScope =                              0x2;
    sii.FilterFlags.Uplevel.flBothModes =      0x0;
    sii.FilterFlags.Uplevel.flMixedModeOnly =  0x82;
    sii.FilterFlags.Uplevel.flNativeModeOnly = 0x2a2;
    sii.FilterFlags.flDownlevel =              0x80000005;
    m_vsii.push_back(sii);

    sii.flType =                                0x4;
    sii.flScope =                               0x2;
    sii.FilterFlags.Uplevel.flBothModes =       0x0;
    sii.FilterFlags.Uplevel.flMixedModeOnly =   0x82;
    sii.FilterFlags.Uplevel.flNativeModeOnly =  0x2a2;
    sii.FilterFlags.flDownlevel =               0x80000005;
    m_vsii.push_back(sii);

    sii.flType =                                0x8;
    sii.flScope =                               0x2;
    sii.FilterFlags.Uplevel.flBothModes =       0x0;
    sii.FilterFlags.Uplevel.flMixedModeOnly =   0x82;
    sii.FilterFlags.Uplevel.flNativeModeOnly =  0xa2;
    sii.FilterFlags.flDownlevel =               0x0;
    m_vsii.push_back(sii);

    sii.flType =                                0x20;
    sii.flScope =                               0x2;
    sii.FilterFlags.Uplevel.flBothModes =       0x0;
    sii.FilterFlags.Uplevel.flMixedModeOnly =   0x82;
    sii.FilterFlags.Uplevel.flNativeModeOnly =  0xa2;
    sii.FilterFlags.flDownlevel =               0x80000005;
    m_vsii.push_back(sii);

    sii.flType =                                0x40;
    sii.flScope =                               0x2;
    sii.FilterFlags.Uplevel.flBothModes =       0x0;
    sii.FilterFlags.Uplevel.flMixedModeOnly =   0x82;
    sii.FilterFlags.Uplevel.flNativeModeOnly =  0xa2;
    sii.FilterFlags.flDownlevel =               0x80000005;
    m_vsii.push_back(sii);

    sii.flType =                                0x10;
    sii.flScope =                               0x2;
    sii.FilterFlags.Uplevel.flBothModes =       0x0;
    sii.FilterFlags.Uplevel.flMixedModeOnly =   0x0;
    sii.FilterFlags.Uplevel.flNativeModeOnly =  0xa2;
    sii.FilterFlags.flDownlevel =               0x0;
    m_vsii.push_back(sii);


    LVITEM lvi;
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_TEXT;
    lvi.iItem = 1000;
    HWND hwndLv = _hCtrl(IDC_SCOPE_LIST);

    for (int i = 0; i < m_vsii.size(); i++)
    {
        lvi.pszText = ScopeNameFromType(m_vsii[i].flType);
        ListView_InsertItem(hwndLv, &lvi);
    }

    BOOL fUplevel = IsUplevel((SCOPE_TYPE)m_vsii[0].flType);
    _EnableScopeFlagWindows(TRUE);
    _PopulateScopeFlagList();
    _PopulateFilterList(fUplevel);
    ListView_SetItemState(_hCtrl(IDC_SCOPE_LIST), 0, LVIS_SELECTED, LVIS_SELECTED);
    m_fIgnoreNotifications = FALSE;

    if (fUplevel)
    {
        CheckRadioButton(m_hwnd, FIRST_MODE_RADIO, LAST_MODE_RADIO, IDC_BOTH_RADIO);
    }
    else
    {
        CheckRadioButton(m_hwnd, FIRST_MODE_RADIO, LAST_MODE_RADIO, IDC_DOWNLEVEL_RADIO);
    }
    _SetFlagFilterUiFromInitInfo(0);
}

void
COpTestDlg::_PresetAclUiFile()
{
    _Clear();
    m_fIgnoreNotifications = TRUE;
    CheckDlgButton(m_hwnd, IDC_MULTISELECT_CHECK, BST_CHECKED);
    CheckDlgButton(m_hwnd, IDC_SKIP_DC_CHECK, BST_CHECKED);
    Edit_SetText(_hCtrl(IDC_ATTRIBUTES_EDIT), L"ObjectSID");
    m_vsii.reserve(6);

    CScopeInitInfo sii;

    sii.flType =                                 0x2;
    sii.flScope =                                0x1;
    sii.FilterFlags.Uplevel.flBothModes =        0x0;
    sii.FilterFlags.Uplevel.flMixedModeOnly =    0x88b;
    sii.FilterFlags.Uplevel.flNativeModeOnly =   0xaab;
    sii.FilterFlags.flDownlevel =                0x0;
    m_vsii.push_back(sii);

    sii.flType =                                 0x4;
    sii.flScope =                                0x1;
    sii.FilterFlags.Uplevel.flBothModes =        0x0;
    sii.FilterFlags.Uplevel.flMixedModeOnly =    0x0;
    sii.FilterFlags.Uplevel.flNativeModeOnly =   0x0;
    sii.FilterFlags.flDownlevel =                0x80017cfd;
    m_vsii.push_back(sii);

    sii.flType =                                 0x1;
    sii.flScope =                                0x0;
    sii.FilterFlags.Uplevel.flBothModes =        0x0;
    sii.FilterFlags.Uplevel.flMixedModeOnly =    0x0;
    sii.FilterFlags.Uplevel.flNativeModeOnly =   0x0;
    sii.FilterFlags.flDownlevel =                0x80017cff;
    m_vsii.push_back(sii);

    sii.flType =                                 0x10;
    sii.flScope =                                0x0;
    sii.FilterFlags.Uplevel.flBothModes =        0x8ab;
    sii.FilterFlags.Uplevel.flMixedModeOnly =    0x0;
    sii.FilterFlags.Uplevel.flNativeModeOnly =   0x0;
    sii.FilterFlags.flDownlevel =                0x0;
    m_vsii.push_back(sii);

    sii.flType =                                 0x8;
    sii.flScope =                                0x0;
    sii.FilterFlags.Uplevel.flBothModes =        0x8a3;
    sii.FilterFlags.Uplevel.flMixedModeOnly =    0x0;
    sii.FilterFlags.Uplevel.flNativeModeOnly =   0x0;
    sii.FilterFlags.flDownlevel =                0x0;
    m_vsii.push_back(sii);

    sii.flType =                                 0x20;
    sii.flScope =                                0x0;
    sii.FilterFlags.Uplevel.flBothModes =        0x8a3;
    sii.FilterFlags.Uplevel.flMixedModeOnly =    0x0;
    sii.FilterFlags.Uplevel.flNativeModeOnly =   0x0;
    sii.FilterFlags.flDownlevel =                0x80017cf5;
    m_vsii.push_back(sii);

    sii.flType =                                 0x40;
    sii.flScope =                                0x0;
    sii.FilterFlags.Uplevel.flBothModes =        0x8a3;
    sii.FilterFlags.Uplevel.flMixedModeOnly =    0x0;
    sii.FilterFlags.Uplevel.flNativeModeOnly =   0x0;
    sii.FilterFlags.flDownlevel =                0x80017cf5;
    m_vsii.push_back(sii);

    LVITEM lvi;
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_TEXT;
    lvi.iItem = 1000;
    HWND hwndLv = _hCtrl(IDC_SCOPE_LIST);

    for (int i = 0; i < m_vsii.size(); i++)
    {
        lvi.pszText = ScopeNameFromType(m_vsii[i].flType);
        ListView_InsertItem(hwndLv, &lvi);
    }

    BOOL fUplevel = IsUplevel((SCOPE_TYPE)m_vsii[0].flType);
    _EnableScopeFlagWindows(TRUE);
    _PopulateScopeFlagList();
    _PopulateFilterList(fUplevel);
    ListView_SetItemState(_hCtrl(IDC_SCOPE_LIST), 0, LVIS_SELECTED, LVIS_SELECTED);
    m_fIgnoreNotifications = FALSE;
    _SetFlagFilterUiFromInitInfo(0);

    if (fUplevel)
    {
        CheckRadioButton(m_hwnd, FIRST_MODE_RADIO, LAST_MODE_RADIO, IDC_BOTH_RADIO);
    }
    else
    {
        CheckRadioButton(m_hwnd, FIRST_MODE_RADIO, LAST_MODE_RADIO, IDC_DOWNLEVEL_RADIO);
    }
    _SetFlagFilterUiFromInitInfo(0);
}



void
COpTestDlg::_InitObjectPicker()
{
    DSOP_INIT_INFO ii;

    ZeroMemory(&ii, sizeof ii);
    ii.cbSize = sizeof(ii);
    ULONG flags = 0;

    if (IsDlgButtonChecked(m_hwnd, IDC_MULTISELECT_CHECK))
    {
        flags |= DSOP_FLAG_MULTISELECT;
    }

    if (IsDlgButtonChecked(m_hwnd, IDC_SKIP_DC_CHECK))
    {
        flags |= DSOP_FLAG_SKIP_TARGET_COMPUTER_DC_CHECK;
    }

    ii.flOptions = flags;
    WCHAR wzTarget[MAX_PATH];
    Edit_GetText(_hCtrl(IDC_TARGET_COMPUTER_EDIT), wzTarget, ARRAYLEN(wzTarget));
    ii.pwzTargetComputer = wzTarget;

    ULONG cchAttributes = Edit_GetTextLength(_hCtrl(IDC_ATTRIBUTES_EDIT));
    PWSTR pwzAttributes = new WCHAR[cchAttributes + 1];
    if (!pwzAttributes)
    {
        printf("out of memory\n");
        return;
    }
    Edit_GetText(_hCtrl(IDC_ATTRIBUTES_EDIT), pwzAttributes, cchAttributes + 1);

    String strAttr = pwzAttributes;
    delete [] pwzAttributes;

    list<String> tokens;
    strAttr.tokenize(back_inserter(tokens), L"; ");

    ii.cAttributesToFetch = static_cast<ULONG>(tokens.size());
    list<String>::iterator it;

    ii.apwzAttributeNames = new PCWSTR[tokens.size()];
    int i;

    for (i = 0, it = tokens.begin(); it != tokens.end(); it++, i++)
    {
        ii.apwzAttributeNames[i] = it->c_str();
    }

    ii.cDsScopeInfos = static_cast<ULONG>(m_vsii.size());
    ii.aDsScopeInfos = new DSOP_SCOPE_INIT_INFO[m_vsii.size()];


    for (i = 0; i < ii.cDsScopeInfos; i++)
    {
        CopyMemory(&ii.aDsScopeInfos[i], &m_vsii[i], sizeof DSOP_SCOPE_INIT_INFO);
    }

    HRESULT hr = m_pop->Initialize(&ii);

    if (FAILED(hr))
    {
        printf("init failed %#x\n", hr);
    }

    delete [] ii.aDsScopeInfos;
    delete [] ii.apwzAttributeNames;
}



void
COpTestDlg::_SaveAs()
{
    OPENFILENAME ofn;

    ZeroMemory(&ofn, sizeof ofn);
    ofn.lStructSize = sizeof ofn;
    ofn.hwndOwner = m_hwnd;
    ofn.lpstrFilter = L"Object Picker Tester (*.opt)\0*.OPT\0";
    ofn.lpstrDefExt = L"opt";
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = m_wzFilename;
    ofn.nMaxFile = ARRAYLEN(m_wzFilename);
    ofn.Flags = OFN_PATHMUSTEXIST;

    BOOL fOk = GetSaveFileName(&ofn);

    if (!fOk)
    {
        return;
    }

    _Save();
}


void
COpTestDlg::_Save()
{
    String c_strCRLF(L"\r\n");
    String c_strQuote(L"\"");

    if (!*m_wzFilename)
    {
        _SaveAs();
        return;
    }

    // target
    // options
    // attribute string
    // cScopeInfos
    // Scopes

    String strBuffer;

    WCHAR wzTarget[MAX_PATH];
    Edit_GetText(_hCtrl(IDC_TARGET_COMPUTER_EDIT), wzTarget, ARRAYLEN(wzTarget));

    strBuffer = c_strQuote + wzTarget + c_strQuote + c_strCRLF;

    ULONG flags = 0;

    if (IsDlgButtonChecked(m_hwnd, IDC_MULTISELECT_CHECK))
    {
        flags |= DSOP_FLAG_MULTISELECT;
    }

    if (IsDlgButtonChecked(m_hwnd, IDC_SKIP_DC_CHECK))
    {
        flags |= DSOP_FLAG_SKIP_TARGET_COMPUTER_DC_CHECK;
    }

    WCHAR wzBuf[20];

    wsprintf(wzBuf, L"%#x", flags);
    strBuffer += wzBuf + c_strCRLF;

    ULONG cchAttributes = Edit_GetTextLength(_hCtrl(IDC_ATTRIBUTES_EDIT));
    PWSTR pwzAttributes = new WCHAR[cchAttributes + 1];
    if (!pwzAttributes)
    {
        printf("out of memory\n");
        return;
    }
    Edit_GetText(_hCtrl(IDC_ATTRIBUTES_EDIT), pwzAttributes, cchAttributes + 1);
    strBuffer += c_strQuote + pwzAttributes + c_strQuote + c_strCRLF;
    delete [] pwzAttributes;

    wsprintf(wzBuf, L"%u", m_vsii.size());
    strBuffer += wzBuf + c_strCRLF;

    for (int i = 0; i < m_vsii.size(); i++)
    {
        wsprintf(wzBuf, L"%#x", m_vsii[i].flType);
        strBuffer += wzBuf + c_strCRLF;

        wsprintf(wzBuf, L"%#x", m_vsii[i].flScope);
        strBuffer += wzBuf + c_strCRLF;

        wsprintf(wzBuf, L"%#x", m_vsii[i].FilterFlags.Uplevel.flBothModes);
        strBuffer += wzBuf + c_strCRLF;

        wsprintf(wzBuf, L"%#x", m_vsii[i].FilterFlags.Uplevel.flMixedModeOnly);
        strBuffer += wzBuf + c_strCRLF;

        wsprintf(wzBuf, L"%#x", m_vsii[i].FilterFlags.Uplevel.flNativeModeOnly);
        strBuffer += wzBuf + c_strCRLF;

        wsprintf(wzBuf, L"%#x", m_vsii[i].FilterFlags.flDownlevel);
        strBuffer += wzBuf + c_strCRLF;

        if (m_vsii[i].pwzDcName)
        {
            strBuffer += c_strQuote + m_vsii[i].pwzDcName + c_strQuote + c_strCRLF;
        }
        else
        {
            strBuffer += c_strQuote + c_strQuote + c_strCRLF;
        }

        if (m_vsii[i].pwzADsPath)
        {
            strBuffer += c_strQuote + m_vsii[i].pwzADsPath + c_strQuote + c_strCRLF;
        }
        else
        {
            strBuffer += c_strQuote + c_strQuote + c_strCRLF;
        }
    }

    HANDLE hFile = CreateFile(m_wzFilename,
                              GENERIC_WRITE,
                              FILE_SHARE_READ,
                              NULL,
                              CREATE_ALWAYS,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        printf("CreateFile failed %u\n", GetLastError());
        return;
    }

    AnsiString  straBuffer;

    strBuffer.convert(straBuffer);

    ULONG cbWritten;

    WriteFile(hFile,
              straBuffer.c_str(),
              static_cast<ULONG>(straBuffer.length()),
              &cbWritten,
              NULL);

    CloseHandle(hFile);
}



void
COpTestDlg::_Load()
{
    OPENFILENAME ofn;

    ZeroMemory(&ofn, sizeof ofn);
    ofn.lStructSize = sizeof ofn;
    ofn.hwndOwner = m_hwnd;
    ofn.lpstrFilter = L"Object Picker Tester (*.opt)\0*.opt\0";
    ofn.lpstrDefExt = L"opt";
    ofn.nFilterIndex = 1;
    ofn.lpstrFile = m_wzFilename;
    ofn.nMaxFile = ARRAYLEN(m_wzFilename);
    ofn.Flags = OFN_PATHMUSTEXIST;

    BOOL fOk = GetOpenFileName(&ofn);

    if (!fOk)
    {
        return;
    }

    HANDLE hFile = CreateFile(m_wzFilename,
                              GENERIC_READ,
                              FILE_SHARE_READ,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        printf("CreateFile failed %u\n", GetLastError());
        return;
    }

    ULONG cbFile = GetFileSize(hFile, NULL);

    PSTR pstr = new CHAR[cbFile + 1];

    if (!pstr)
    {
        printf("out of memory\n");
        CloseHandle(hFile);
        return;
    }

    ULONG cbRead;

    ReadFile(hFile, pstr, cbFile, &cbRead, NULL);
    CloseHandle(hFile);

    pstr[cbRead] = '\0';
    String strBuffer(pstr);
    delete [] pstr;

    list<String> tokens;
    String c_strCRLF(L"\r\n");

    strBuffer.tokenize(back_inserter(tokens), c_strCRLF);

    list<String>::iterator it;

    it = tokens.begin();

    // target
    // options
    // attribute string
    // cScopeInfos
    // Scopes

    it->strip(String::BOTH, L' ');
    it->strip(String::BOTH, L'"');
    Edit_SetText(_hCtrl(IDC_TARGET_COMPUTER_EDIT), it->c_str());

    it++;
    ULONG flags;

    it->convert(flags, 16);

    if (flags & DSOP_FLAG_MULTISELECT)
    {
        CheckDlgButton(m_hwnd, IDC_MULTISELECT_CHECK, BST_CHECKED);
    }
    else
    {
        CheckDlgButton(m_hwnd, IDC_MULTISELECT_CHECK, BST_UNCHECKED);
    }

    if (flags & DSOP_FLAG_SKIP_TARGET_COMPUTER_DC_CHECK)
    {
        CheckDlgButton(m_hwnd, IDC_SKIP_DC_CHECK, BST_CHECKED);
    }
    else
    {
        CheckDlgButton(m_hwnd, IDC_SKIP_DC_CHECK, BST_UNCHECKED);
    }

    it++;
    it->strip(String::BOTH, L' ');
    it->strip(String::BOTH, L'"');
    Edit_SetText(_hCtrl(IDC_ATTRIBUTES_EDIT), it->c_str());

    it++;
    ULONG cInitInfos;
    it->convert(cInitInfos);

    HWND hwndLv = _hCtrl(IDC_SCOPE_LIST);
    BOOL fFirstIsUplevel = FALSE;

    for (int i = 0; i < cInitInfos; i++)
    {
        CScopeInitInfo sii;

        it++;
        it->convert(sii.flType, 16);

        if (!i)
        {
            fFirstIsUplevel = IsUplevel((SCOPE_TYPE)sii.flType);
        }

        it++;
        it->convert(sii.flScope, 16);

        it++;
        it->convert(sii.FilterFlags.Uplevel.flBothModes, 16);

        it++;
        it->convert(sii.FilterFlags.Uplevel.flMixedModeOnly, 16);

        it++;
        it->convert(sii.FilterFlags.Uplevel.flNativeModeOnly, 16);

        it++;
        it->convert(sii.FilterFlags.flDownlevel, 16);

        it++;
        it->strip(String::BOTH, L' ');
        it->strip(String::BOTH, L'"');
        NewDupStr(const_cast<PWSTR*>(&sii.pwzDcName),it->c_str());

        it++;
        it->strip(String::BOTH, L' ');
        it->strip(String::BOTH, L'"');
        NewDupStr(const_cast<PWSTR*>(&sii.pwzADsPath), it->c_str());

        m_vsii.push_back(sii);

        LVITEM lvi;
        ZeroMemory(&lvi, sizeof lvi);
        lvi.mask = LVIF_TEXT;
        lvi.iItem = 1000;
        lvi.pszText = ScopeNameFromType(sii.flType);

        ListView_InsertItem(hwndLv, &lvi);
    }


    if (cInitInfos)
    {
        m_fIgnoreNotifications = TRUE;
        BOOL fUplevel = IsUplevel((SCOPE_TYPE)m_vsii[0].flType);
        _EnableScopeFlagWindows(TRUE);
        _PopulateScopeFlagList();
        _PopulateFilterList(fUplevel);
        ListView_SetItemState(_hCtrl(IDC_SCOPE_LIST), 0, LVIS_SELECTED, LVIS_SELECTED);
        m_fIgnoreNotifications = FALSE;
    }
}





void
COpTestDlg::_PopulateFilterList(
    BOOL fUplevel)
{
    HWND hwndLv = _hCtrl(IDC_SCOPE_FILTER_LIST);
    ListView_DeleteAllItems(hwndLv);
    LVITEM lvi;
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_TEXT;
    lvi.iItem = 1000;

    int i=0;
    if (fUplevel)
    {
        for (i = 0; i < ARRAYLEN(s_UplevelScopeFilterInfo); i++)
        {
            lvi.pszText = s_UplevelScopeFilterInfo[i].pwzName;
            ListView_InsertItem(hwndLv, &lvi);
        }
    }
    else
    {
        for (i = 0; i < ARRAYLEN(s_DownlevelScopeFilterInfo); i++)
        {
            lvi.pszText = s_DownlevelScopeFilterInfo[i].pwzName;
            ListView_InsertItem(hwndLv, &lvi);
        }
    }
}
void
COpTestDlg::_AddScope(
    ULONG stNew)
{
    LVITEM lvi;

    CScopeInitInfo sii;

    sii.flType = stNew;
    m_vsii.push_back(sii);

    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_TEXT;
    lvi.iItem = 1000;
    lvi.pszText = ScopeNameFromType(stNew);

    HWND hwndLv = _hCtrl(IDC_SCOPE_LIST);
    INT iNew = ListView_InsertItem(hwndLv, &lvi);
    ListView_SetItemState(_hCtrl(IDC_SCOPE_LIST), iNew, LVIS_SELECTED, LVIS_SELECTED);

    hwndLv = _hCtrl(IDC_SCOPE_FLAG_LIST);
    if (!ListView_GetItemCount(hwndLv))
    {
        _EnableScopeFlagWindows(TRUE);
        _PopulateScopeFlagList();
    }

    if (IsUplevel((SCOPE_TYPE)stNew))
    {
        CheckRadioButton(m_hwnd, FIRST_SCOPE_RADIO, LAST_SCOPE_RADIO, IDC_BOTH_RADIO);
    }
    else
    {
        CheckRadioButton(m_hwnd, FIRST_SCOPE_RADIO, LAST_SCOPE_RADIO, IDC_DOWNLEVEL_RADIO);
    }

    _SetFlagFilterUiFromInitInfo(static_cast<ULONG>(m_vsii.size() - 1));
}

void
COpTestDlg::_PopulateScopeFlagList()
{
    LVITEM lvi;
    ZeroMemory(&lvi, sizeof lvi);
    lvi.mask = LVIF_PARAM | LVIF_TEXT;
    lvi.iItem = 1000;
    HWND hwndLv = _hCtrl(IDC_SCOPE_FLAG_LIST);
    for (int i = 0; i < ARRAYLEN(s_ScopeFlagInfo); i++)
    {
        lvi.pszText = s_ScopeFlagInfo[i].pwzName;
        lvi.lParam = s_ScopeFlagInfo[i].flValue;
        ListView_InsertItem(hwndLv, &lvi);
    }
}




void
COpTestDlg::_Clear()
{
    CheckDlgButton(m_hwnd, m_idcLastRadioClicked, BST_UNCHECKED);
    CheckDlgButton(m_hwnd, IDC_MULTISELECT_CHECK, BST_UNCHECKED);
    CheckDlgButton(m_hwnd, IDC_SKIP_DC_CHECK, BST_UNCHECKED);
    m_idcLastRadioClicked = 0;
    m_vsii.clear();
    ListView_DeleteAllItems(_hCtrl(IDC_SCOPE_LIST));
    ListView_DeleteAllItems(_hCtrl(IDC_SCOPE_FLAG_LIST));
    ListView_DeleteAllItems(_hCtrl(IDC_SCOPE_FILTER_LIST));
    Edit_SetText(_hCtrl(IDC_ATTRIBUTES_EDIT), L"");
    Edit_SetText(_hCtrl(IDC_TARGET_COMPUTER_EDIT), L"");
}




void __cdecl
main(int argc, char *argv[])
{
    hResourceModuleHandle = GetModuleHandle(NULL);
    INITCOMMONCONTROLSEX icce;

    icce.dwSize = sizeof icce;
    icce.dwICC = ICC_LISTVIEW_CLASSES;
    InitCommonControlsEx(&icce);

    HRESULT hr;
    do
    {
        hr = CoInitialize(NULL);
        BREAK_ON_FAIL_HRESULT(hr);

        COpTestDlg    dlg;

        hr = dlg.Init();
        BREAK_ON_FAIL_HRESULT(hr);

        dlg.DoModalDialog(NULL);
    }
    while (0);
    CoUninitialize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\test\listview\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Select.rc
//
#define IDD_FRAME                               101
#define IDD_SELECTION                           102
#define IDD_PASSWORD                            103
#define IDD_BROWSE_MULTI                        104
#define IDD_BROWSE_SINGLE                       106
#define IDD_MULTI                               107

#define IDC_ENUMWINDOW                          1002
#define IDC_SELECTWINDOW                        1003
#define IDC_SEARCH                              1004
#define IDC_SCOPE                               1005
#define IDC_LOOKIN                              1006
#define IDC_TOOLBAR                             1007


#define IDB_TOOLBAR                             101
#define IDC_ADD                                 101
#define IDC_NAME                                103
#define IDS_LVCOLUMN_0                          105
#define IDS_LVCOLUMN_1                          106
#define IDC_BROWSER                             108
#define IDS_DIRECTORY                           112
#define IDS_OTHER_TRUSTED                       113
#define IDC_EMPTY                               115
#define IDS_NO_SELECTION                        120
#define IDS_NO_SELECTIONS                       121
#define IDS_OUT_OF_MEMORY                       122
#define IDC_NAME_LBL                            126
#define IDS_SELECT_COMPUTERS                    127
#define IDS_WORKING                             128
#define IDS_NO_OBJECTS                          129
#define IDS_SELECT_COMPUTER                     133
#define IDC_USER_NAME_LBL                       134
#define IDC_USER_NAME                           135
#define IDC_PASSWORD_LBL                        136
#define IDC_PASSWORD                            137
#define IDS_USER                                138 // caution these must remain
#define IDS_USERS                               139 // consecutive
#define IDS_CONTACT                             140
#define IDS_CONTACTS                            141
#define IDS_GROUP                               142
#define IDS_GROUPS                              143
#define IDS_COMPUTER                            144
#define IDS_COMPUTERS                           145 // end consecutive
#define IDC_BROWSER_STATIC_OVERLAY              150
#define IDS_COL1FORMAT                          151
#define IDC_SELECTIONLIST_LBL                   152
#define IDC_SELECT_MATCHING_LBL                 153
#define IDC_MATCHING_LIST                       154
#define IDS_BAD_NAME_EXTRA_SLASH                155
#define IDS_NAME_NOT_FOUND_FMT_MULTI            156
#define IDS_NAME_BAD_CLASS_FMT                  157
#define IDS_NAME_QUERY_FAILED                   158
#define IDS_MAX_HITS                            159
#define IDS_MULTI_PICK_ONE                      161
#define IDS_HIT_QUERY_LIMIT                     164
#define IDS_BAD_NAME_SLASH_AT_END               165
#define IDC_PASSWORD_EXPLANATION                166
#define IDC_TARGET                              168
#define IDS_UNKNOWN_DOMAIN                      169
#define IDC_PASSWORD_EXPLANATION2               170
#define IDC_PASSWORD_EXPLANATION3               171
#define IDC_EXAMPLE_LBL                         172
#define IDS_EXAMPLE_UPN_NT4                     173
#define IDS_EXAMPLE_NT4                         174
#define IDS_NO_SCOPES                           175
#define IDS_BAD_NAME_EXTRA_START_SLASH          176
#define IDS_COMP_IN_UNKNOWN_DOMAIN              179
#define IDS_COMP_IN_INVALID_DOMAIN              180
#define IDD_ERROR                               181
#define IDC_POPUP_MSG_ICON                      182
#define IDC_ERRORMSG                            183
#define IDC_ERROR_CODE_LBL                      185
#define IDC_ERROR_CODE_EDIT                     186
#define IDS_NO_SELECTION2                       187
#define IDS_INIT_FAILED_MEMORY                  189
#define IDS_BAD_NAME                            190
#define IDS_COMPUTER_NOT_FOUND                  192
#define IDS_INTERNAL_ERROR_COMPUTER             193
#define IDS_GET_ITEM_FAILED                     194
#define IDD_NAMENOTFOUND                        195
#define IDC_NOT_FOUND_ICON                      196
#define IDC_NOT_FOUND_MESSAGE                   197
#define IDC_CORRECT_RADIO                       198
#define IDC_CORRECT_EDIT                        199
#define IDC_REMOVE_RADIO                        200
#define IDS_NAME_NOT_FOUND_FMT_SINGLE           201
//used by burnslib                              202
#define IDS_CANNOT_INVOKE                       203
#define IDS_CANNOT_PROCESS                      204
#define IDC_SIZEGRIP                            207
#define IDA_SEARCH                              208
#define IDC_ANIMATION                           209
#define IDS_INIT_FAILED_NO_SCOPES               210
#define IDS_BIND_ERROR                          211
#define IDC_RICHEDIT                            214
#define IDC_REPLACE_RADIO                       216
#define IDS_REPLACE_SINGLE                      217
#define IDM_CUT                                 218
#define IDM_COPY                                219
#define IDM_PASTE                               220
#define IDM_RICHEDIT                            221
#define IDC_WHAT                                222
#define IDS_DNS_SLASH_NAME                      223
#define IDC_SELECTION_LBL                       224
//used by burnslib                              225
//used by burnslib                              226
//used by burnslib                              227
#define IDS_DISABLED_WARNING_FMT                228
#define IDS_UPN_FORM_NOT_ALLOWED                229
#define IDC_LOOK_FOR_PB                         230
#define IDC_LOOK_FOR_EDIT                       231
#define IDC_LOOK_IN_PB                          232
#define IDC_LOOK_IN_EDIT                        233
#define IDC_INSTRUCTION_LBL                     234
#define IDC_CHECK_NAMES_PB                      235
#define IDC_ADVANCED_PB                         236
#define IDD_STANDALONE_TEXT                     237
#define IDD_LOOK_FOR                            238
#define IDC_LOOK_FOR_LV                         239
#define IDD_LOOK_IN                             240
#define IDC_LOOK_IN_TV                          241
#define IDS_BROWSE_ERROR_FMT                    242
#define IDS_INIT_FAILED_MACHINE_CONFIG          246
#define IDS_INIT_FAILED_LOCAL_MACHINE_CONFIG    247
#define IDS_INIT_FAILED_BAD_ARGS                248
#define IDS_NEW_SCOPE_CLASSES_0_INTERSECTION    249
#define IDS_CANNOT_CONTACT_GC                   250
#define IDS_EXPAND_FAILED                       251
#define IDC_LOOK_FOR_LBL                        256
#define IDC_LOOK_IN_LBL                         257
#define IDC_TAB                                 258
#define IDC_FIND_NOW_PB                         259
#define IDC_STOP_PB                             260
#define IDD_ADVANCED                            261
#define IDS_COMMON_QUERIES                      262
#define IDS_QUERY_BUILDER                       263
#define IDD_COMMON_QUERIES                      264
#define IDD_QUERY_BUILDER                       265
#define IDC_NAME_COMBO                          266
#define IDC_NAME_EDIT                           267
#define IDC_DESCRIPTION_COMBO                   268
#define IDC_DESCRIPTION_EDIT                    269
#define IDC_DISABLED_CKBOX                      270
#define IDC_NON_EXPIRING_CKBOX                  271
#define IDC_LAST_LOGON_COMBO                    272
#define IDC_EXPIRED_EDIT                        273
#define IDC_CLAUSE_LIST                         274
#define IDC_ADD_BTN                             275
#define IDC_EDIT_BTN                            276
#define IDC_REMOVE_BTN                          277
#define IDS_STARTS_WITH                         278
#define IDS_IS_EXACTLY                          279
#define IDC_LBL1                                280
#define IDC_LBL2                                281
#define IDC_QUERY_LISTVIEW                      282
#define IDS_SINGLE_SELECT_INSTRUCTIONS          283
#define IDS_BUILTIN_WKSP                        284
#define IDS_BUILTIN_WKSPS                       285
#define IDI_GROUP                               286
#define IDI_USER                                287
#define IDI_COMPUTER                            288
#define IDS_OTHER_OBJECT                        289
#define IDS_OTHER_OBJECTS                       290
#define IDC_DESCRIPTION_LBL                     291
#define IDC_ATTR_LIST                           292
#define IDD_ADDCLAUSE                           293
#define IDS_UNIQUE_ATTR_FMT                     294
#define IDD_STRING_ATTR                         295
#define IDC_CONDITION_COMBO                     296
#define IDC_VALUE_EDIT                          297
#define IDS_STR_FILTER_EXACT_DESCRIPTION_FMT    298
#define IDS_STR_FILTER_PREFIX_DESCRIPTION_FMT   299
#define IDD_DN_ATTR                             300
#define IDD_CLEAR_QB                            301
#define IDS_CLEAR_QB_CAPTION                    302
#define IDS_CLEAR_QB_TEXT                       303
#define IDC_LASTLOGON_COMBO                     304
#define IDC_LASTLOGON_LBL                       305
#define IDS_SCOPE_ERROR                         306
#define IDS_NOTHINGFOUND                        307
#define IDS_QUERY_ERROR                         308
#define IDS_SEARCHING                           309
#define IDS_STOPPING_QUERY                      310
#define IDS_LOCAL_GROUP                         311
#define IDS_GLOBAL_GROUP                        312
#define IDC_AVAILABLE_LIST                      313
#define IDC_SHOWN_LIST                          314
#define IDS_CHOOSE_COLUMNS                      315
#define IDD_COLUMN_PICKER                       316
#define IDS_CANNOT_READ_RICHEDIT                317
#define IDS_MULTI_PICK_ONE_OR_MORE              318
#define IDC_COLUMNS_PB                          319
#define IDC_ADD_COL_BTN                         320
#define IDC_REMOVE_COL_BTN                      321
#define IDS_SEMICOLON_IN_NAME                   322



//
// BEGIN: Blocks of IDs which must remain consecutive
//

#define IDS_FILTER_ONE                          500
#define IDS_FILTER_TWO                          501
#define IDS_FILTER_THREE                        502
#define IDS_FILTER_FOUR                         503
#define IDS_FILTER_FIVE                         504
#define IDS_FILTER_SIX                          505

#define IDS_SELECT_ONE                          600
#define IDS_SELECT_TWO                          601
#define IDS_SELECT_THREE                        602
#define IDS_SELECT_FOUR                         603
#define IDS_SELECT_FIVE                         604
#define IDS_SELECT_SIX                          605

//
// END: Blocks of IDs which must remain consecutive
//

//
// Icons
//

#define IDI_LOCAL_GROUP                 100
#define IDI_SCOPE_WORKGROUP             105
#define IDI_SCOPE_DIRECTORY             106
#define IDI_SCOPE_DOMAIN                107

#define IDI_DISABLED_USER               200
#define IDI_DISABLED_COMPUTER           201

//
// Timers
//

#define ID_CRED_PROMPT_TIMER            100


//
// Sizing values
//

#define CX_PLUGIN_DIALOG    355
#define CX_MAIN_CONTROL     353

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\select\test\opt\dlg.cxx ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1996.
//
//  File:       dlg.cxx
//
//  Contents:   Implementation of modeless dialog base class
//
//  Classes:    CDlg
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

#include "headers.hxx"
#pragma hdrstop





//+--------------------------------------------------------------------------
//
//  Member:     CDlg::CDlg
//
//  Synopsis:   ctor
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDlg::CDlg():
    m_hwnd(NULL)
{
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::~CDlg
//
//  Synopsis:   dtor
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

CDlg::~CDlg()
{
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_DoModalDlg
//
//  Synopsis:   Create the dialog and return its window handle
//
//  Arguments:  [hwndParent] - handle to owner window of dialog to create
//              [idd]        - resource id of dialog template
//
//  Returns:    Dialog's return code
//
//  History:    04-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

INT_PTR
CDlg::_DoModalDlg(
    HWND hwndParent,
    INT idd) const
{
    INT_PTR iResult = DialogBoxParam(GetModuleHandle(NULL),
                          MAKEINTRESOURCE(idd),
                          hwndParent,
                          CDlg::_DlgProc,
                          (LPARAM) this);

    return iResult;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_DoModelessDlg
//
//  Synopsis:   Create the dialog and return its window handle
//
//  Arguments:  [hwndParent] - handle to owner window of dialog to create
//              [idd]        - resource id of dialog template
//
//  Returns:    Dialog window handle, or NULL on failure
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

HWND
CDlg::_DoModelessDlg(
    HWND hwndParent,
    INT idd)
{

    HWND hwnd;

    hwnd = CreateDialogParam(GetModuleHandle(NULL),
                             MAKEINTRESOURCE(idd),
                             hwndParent,
                             CDlg::_DlgProc,
                             (LPARAM) this);
    return hwnd;
}




//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_DlgProc
//
//  Synopsis:   Dispatch selected messages to derived class
//
//  Arguments:  standard windows dialog
//
//  Returns:    standard windows dialog
//
//  History:    4-22-1997   DavidMun   Created
//
//---------------------------------------------------------------------------

INT_PTR CALLBACK
CDlg::_DlgProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    BOOL fReturn = TRUE;
    CDlg *pThis = (CDlg *)GetWindowLongPtr(hwnd, DWLP_USER);

    switch (message)
    {
    case WM_INITDIALOG:
    {
        HRESULT hr = S_OK;

        //
        // pThis isn't valid because we haven't set DWLP_USER yet.  Make
        // it valid.
        //

        pThis = (CDlg*) lParam;

        SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR) pThis);
        pThis->m_hwnd = hwnd;
        BOOL fInitResult = TRUE;
        hr = pThis->_OnInit(&fInitResult);
        fReturn = fInitResult;

        //
        // If the initialization failed do not allow the dialog to start.
        //

        if (FAILED(hr))
        {
            DestroyWindow(hwnd);
        }
        break;
    }

    case WM_COMMAND:
        fReturn = pThis->_OnCommand(wParam, lParam);
        break;

    case WM_SIZE:
        fReturn = pThis->_OnSize(wParam, lParam);
        break;

    case WM_GETMINMAXINFO:
        fReturn = pThis->_OnMinMaxInfo((LPMINMAXINFO) lParam);
        break;

    case WM_NOTIFY:
        fReturn = pThis->_OnNotify(wParam, lParam);
        break;

    case WM_DRAWITEM:
        fReturn = pThis->_OnDrawItem(wParam, lParam);
        break;

    case WM_CTLCOLORSTATIC:
        fReturn = static_cast<ULONG>(pThis->_OnStaticCtlColor((HDC) wParam, (HWND) lParam));
        break;

    case WM_SYSCOLORCHANGE:
        pThis->_OnSysColorChange();
        break;
/*
    case WM_SETFOCUS:
        pThis->_OnSetFocus((HWND)wParam);
        break;
*/

    case WM_DESTROY:
        //
        // It's possible to get a WM_DESTROY message without having gotten
        // a WM_INITDIALOG if loading a dll that the dialog needs (e.g.
        // comctl32.dll) fails, so guard pThis access here.
        //

        if (pThis)
        {
            pThis->_OnDestroy();
            pThis->m_hwnd = NULL;
        }
        break;

    case WM_HELP:
    case WM_CONTEXTMENU:
        pThis->_OnHelp(message, wParam, lParam);
        break;

    default:
        fReturn = FALSE;
        break;
    }
    return fReturn;
}


#define VERIFY(x) x

//+--------------------------------------------------------------------------
//
//  Member:     CDlg::_GetChildWindowRect
//
//  Synopsis:   Init *[prc] with the window rect, in client coordinates, of
//              child window [hwndChild].
//
//  Arguments:  [hwndChild] - child window for which to retrieve rect
//              [prc]       - pointer to rect struct to receive info
//
//  Modifies:   *[prc]
//
//  History:    07-21-1998   DavidMun   Created
//
//---------------------------------------------------------------------------

void
CDlg::_GetChildWindowRect(
    HWND hwndChild,
    RECT *prc)
{

    VERIFY(GetWindowRect(hwndChild, prc));
    VERIFY(MapWindowPoints(NULL, m_hwnd, (LPPOINT) prc, 2));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 2000 - 2000

Module Name:

    sources.inc

Note:

    Common Drizzle build switches.

!ENDIF

# USE_WININET=1
BITS_V12=1

MSC_WARNING_LEVEL=/WX /W3
USE_MSVCRT=1
USE_NATIVE_EH=1

C_DEFINES = $(C_DEFINES) -DUNICODE -D_UNICODE  -DWPP_CHECK_FOR_NULL_STRING

!if defined(USE_WININET)
C_DEFINES = $(C_DEFINES) -DUSE_WININET
!endif

!if defined(BITS_V12_ON_NT4)
C_DEFINES = $(C_DEFINES) -DBITS_V12_ON_NT4 -DBITS_DONT_USE_ASYNC_DCOM
BITS_V12=1
MIDL_OPTIMIZATION = /Oicf -error all
!endif

!if defined(BITS_V12)
C_DEFINES = $(C_DEFINES) -DBITS_V12
!endif

LINKER_FLAGS = $(LINKER_FLAGS) -ignore:4049,4217
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\bits_client_msm\makefile.inc ===
MSM_NAME=$(TARGETPATH)\$(TARGETNAME)

make_msm: $(MSM_NAME)


$(MSM_NAME): *.idt
        md   Binary
        copy $(TARGETPATH)\bitscnfg.exe Binary\New_Binary3.7AA0B4BB_5B6C_41AE_84E6_F3C3C865051A.ibd
        msidb -c -d $(MSM_NAME) -f $(MAKEDIR) *
        msidb -d $(MSM_NAME) -a $(TARGETPATH)\qmgr.dll
        msidb -d $(MSM_NAME) -a $(TARGETPATH)\qmgrprxy.dll
        msidb -d $(MSM_NAME) -a $(TARGETPATH)\bitsprx2.dll
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\bitsadmin\bitsadmin.cpp ===
/************************************************************************

Copyright (c) 2000-2000 Microsoft Corporation

Module Name :

    client.cpp

Abstract :

    This file contains a very simple commandline utility for controlling
    the BITS service.

Author :

    Mike Zoran  mzoran   July 2000.

Revision History :

Notes:

    This tools does not do all the necessary Release and memory
    free calls that a long lived program would need to do.   Since
    this tool is generally short lived, or only a small section of code
    is used when it isn't, the system can be relied on for resource
    cleanup.

  ***********************************************************************/

#define MAKE_UNICODE(x)      L ## x

#include <windows.h>
#include <sddl.h>
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <bits.h>
#include <bits1_5.h>
#include <ntverp.h>
#include <locale.h>
#include <strsafe.h>
#include <memory>

using namespace std;

typedef auto_ptr<WCHAR> CAutoString;

const UINT MAX_GUID_CHARS=40;
typedef OLECHAR GUIDSTR[MAX_GUID_CHARS];

void __declspec(noreturn) AppExit( int val );

bool g_Shutdown = false;
HANDLE g_MainThreadHandle = NULL;
void PollShutdown();
void SignalShutdown( DWORD MilliTimeout );

template<class T> class SmartRefPointer
{
private:
   T * m_Interface;

   void ReleaseIt()
   {
      if ( m_Interface )
         m_Interface->Release();
      m_Interface = NULL;
   }

   void RefIt()
   {
      if ( m_Interface )
          m_Interface->AddRef();
   }

public:

   SmartRefPointer()
   {
      m_Interface = NULL;
   }

   SmartRefPointer( T * RawInterface )
   {
      m_Interface = RawInterface;
      RefIt();
   }

   SmartRefPointer( SmartRefPointer & Other )
   {
      m_Interface = Other.m_Interface;
      RefIt();
   }

   ~SmartRefPointer()
   {
      ReleaseIt();
   }

   T * Get() const
   {
      return m_Interface;
   }

   T * Release()
   {
      T * temp = m_Interface;
      m_Interface = NULL;
      return temp;
   }

   void Clear()
   {
      ReleaseIt();
   }

   T** GetRecvPointer()
   {
      ReleaseIt();
      return &m_Interface;
   }

   SmartRefPointer & operator=( SmartRefPointer & Other )
   {
      ReleaseIt();
      m_Interface = Other.m_Interface;
      RefIt();
      return *this;
   }

   T* operator->() const
   {
      return m_Interface;
   }

   operator const T*() const
   {
      return m_Interface;
   }
};

typedef SmartRefPointer<IUnknown> SmartIUnknownPointer;
typedef SmartRefPointer<IBackgroundCopyManager> SmartManagerPointer;
typedef SmartRefPointer<IBackgroundCopyJob> SmartJobPointer;
typedef SmartRefPointer<IBackgroundCopyJob2> SmartJob2Pointer;
typedef SmartRefPointer<IBackgroundCopyError> SmartJobErrorPointer;
typedef SmartRefPointer<IBackgroundCopyFile> SmartFilePointer;
typedef SmartRefPointer<IEnumBackgroundCopyFiles> SmartEnumFilesPointer;
typedef SmartRefPointer<IEnumBackgroundCopyJobs> SmartEnumJobsPointer;

class AutoStringPointer
{
private:
   WCHAR * m_String;

public:

   AutoStringPointer( WCHAR *pString = NULL )
   {
      m_String = pString;
   }

   ~AutoStringPointer()
   {
      delete m_String;
      m_String = NULL;
   }

   WCHAR *Get()
   {
      return m_String;
   }

   WCHAR ** GetRecvPointer()
   {
      delete m_String;
      m_String = NULL;
      return &m_String;
   }

   void Clear()
   {
      delete m_String;
      m_String = NULL;
   }

   operator WCHAR *() const
   {
      return m_String;
   }

   AutoStringPointer & operator=( WCHAR *pString )
   {
      delete m_String;
      m_String = pString;
      return *this;
   }
};

WCHAR* pComputerName;
SmartManagerPointer g_Manager;
bool bRawReturn = false;
bool bWrap = false;

typedef void (* PSET_THREAD_UI)( DWORD );

void BITSADMINSetThreadUILanguage()
{
    HINSTANCE hInstance = LoadLibrary( L"kernel32.dll" );                                   // SEC-REVIEWED: 2002-03-21

    if ( !hInstance )
        return;

    PSET_THREAD_UI SetUI = (PSET_THREAD_UI)GetProcAddress( hInstance, "SetThreadUILanguage" );

    if ( !SetUI )
        {
        FreeLibrary( hInstance );
        return;
        }

    (*SetUI)(0);
    FreeLibrary( hInstance );

    return;
}

HRESULT
Job2FromJob(
    SmartJobPointer & Job,
    SmartJob2Pointer & Job2
    )
{
    return Job->QueryInterface( __uuidof(IBackgroundCopyJob2), (void **) Job2.GetRecvPointer() );
}


//
//  Generic print operators and input functions
//

class BITSOUTStream
{

  HANDLE Handle;

  char  MBBuffer[ 4096 * 8 ];
  WCHAR Buffer[ 4096 ];
  DWORD BufferUsed;

public:

  BITSOUTStream( DWORD StdHandle );

  void FlushBuffer( bool HasNewLine=false );
  void OutputString( const WCHAR *RawString );
  HANDLE GetHandle() { return Handle; }

};

BITSOUTStream bcout( STD_OUTPUT_HANDLE );
BITSOUTStream bcerr( STD_ERROR_HANDLE );

BITSOUTStream::BITSOUTStream( DWORD StdHandle ) :
    BufferUsed( 0 ),
    Handle( GetStdHandle( StdHandle ) )
{
}

void
BITSOUTStream::OutputString( const WCHAR *RawString )
{
   SIZE_T CurrentPos = 0;

   PollShutdown();

   while( RawString[ CurrentPos ] != '\0' )
       {

       if ( L'\n' == RawString[ CurrentPos ] )
           {
           Buffer[ BufferUsed++ ] = L'\x000D';
           Buffer[ BufferUsed++ ] = L'\x000A';
           CurrentPos++;
           FlushBuffer( true );
           }

       else if ( L'\t' == RawString[ CurrentPos ] )
           {
           // Tabs complicate things, flush them
           FlushBuffer();
           Buffer[ BufferUsed++ ] = RawString[ CurrentPos++ ];
           FlushBuffer();
           }

       else
           {
           Buffer[ BufferUsed++ ] = RawString[ CurrentPos++ ];

           if ( BufferUsed >= ( 4096 - 10 ) ) // keep a pad of 10 chars
               FlushBuffer();
           }
       }
}

void
BITSOUTStream::FlushBuffer( bool HasNewLine )
{

    if (!BufferUsed)
        return;

    if( GetFileType(Handle) == FILE_TYPE_CHAR )
        {
        DWORD CharsWritten;
        if ( bWrap )
            WriteConsoleW( Handle, Buffer, BufferUsed, &CharsWritten, 0);
        else
            {

            // The console code has what appears to be a bug in that it doesn't
            // handle the case were line wrapping is disabled and WriteConsoleW
            // is called.  Need to manually handle the truncation.

            CONSOLE_SCREEN_BUFFER_INFO ConsoleScreenBufferInfo;
            GetConsoleScreenBufferInfo( Handle, &ConsoleScreenBufferInfo );

            SHORT Columns = ( ConsoleScreenBufferInfo.dwSize.X - 1 ) -
                            ( ConsoleScreenBufferInfo.dwCursorPosition.X );

            DWORD ActualChars = HasNewLine ? ( BufferUsed - 2 ) : BufferUsed;

            if ( Columns >= (INT32)ActualChars )
                WriteConsoleW( Handle, Buffer, BufferUsed, &CharsWritten, 0 );
            else
                {
                WriteConsoleW( Handle, Buffer, Columns, &CharsWritten, 0 );
                if ( HasNewLine )
                    WriteConsoleW( Handle, Buffer + ActualChars, 2, &CharsWritten, 0 );
                }
            }
        }
    else
        {
        DWORD BytesWritten;
        int CharCount = WideCharToMultiByte( GetConsoleOutputCP(), 0, Buffer, BufferUsed, MBBuffer, sizeof(MBBuffer), 0, 0); // SEC-REVIEWED: 2002-03-21
        if ( CharCount )
            {
            if ( MBBuffer[CharCount-1] == '\0' )
                CharCount--;
            WriteFile(Handle, MBBuffer, CharCount, &BytesWritten, 0); // SEC-REVIEWED: 2002-03-21
            }
        }

    BufferUsed = 0;

}

BITSOUTStream& operator<< (BITSOUTStream &s, const WCHAR * String )
{
    s.OutputString( String );
    return s;
}

BITSOUTStream& operator<< (BITSOUTStream &s, UINT64 Number )
{
    static WCHAR Buffer[256];
    StringCbPrintf( Buffer, sizeof(Buffer), L"%I64u", Number );
    return ( s << Buffer );
}

WCHAR * HRESULTToString( HRESULT Hr )
{
    static WCHAR ErrorCode[12];
    StringCbPrintf( ErrorCode, sizeof(ErrorCode), L"0x%8.8x", Hr );

    return ErrorCode;
}

BITSOUTStream& operator<< ( BITSOUTStream &s, AutoStringPointer & String )
{
    return ( s << String.Get() );
}


BITSOUTStream& operator<< ( BITSOUTStream &s, GUID & guid )
{
    WCHAR GUIDSTR[40];
    if (!StringFromGUID2( guid, GUIDSTR, 40 ))
    {
        bcout << L"Internal error converting guid to string.\n";
        AppExit(1);
    }
    return ( s << GUIDSTR );
}

BITSOUTStream& operator<< ( BITSOUTStream &s, FILETIME & filetime )
{

     // Convert the time and date into a localized string.
     // If an error occures, ignore it and print ERROR instead

     if ( !filetime.dwLowDateTime && !filetime.dwHighDateTime )
         return ( s << L"UNKNOWN" );

     FILETIME localtime;
     FileTimeToLocalFileTime( &filetime, &localtime );

     SYSTEMTIME systemtime;
     FileTimeToSystemTime( &localtime, &systemtime );

     // Get the required date size
     int RequiredDateSize =
         GetDateFormatW(
             LOCALE_USER_DEFAULT,
             0,
             &systemtime,
             NULL,
             NULL,
             0 );

     if (!RequiredDateSize)
         return ( s << L"ERROR" );

     CAutoString DateBuffer( new WCHAR[ RequiredDateSize + 1 ]);

     // Actually retrieve the date

     int DateSize =
         GetDateFormatW( LOCALE_USER_DEFAULT,
                        0,
                        &systemtime,
                        NULL,
                        DateBuffer.get(),
                        RequiredDateSize );

     if (!DateSize)
         return ( s << L"ERROR" );

     // Get the required time size
     int RequiredTimeSize =
         GetTimeFormatW( LOCALE_USER_DEFAULT,
                        0,
                        &systemtime,
                        NULL,
                        NULL,
                        0 );

     if (!RequiredTimeSize)
         return ( s << L"ERROR" );

     CAutoString TimeBuffer( new WCHAR[ RequiredTimeSize + 1 ]);

     int TimeSize =
         GetTimeFormatW( LOCALE_USER_DEFAULT,
                        0,
                        &systemtime,
                        NULL,
                        TimeBuffer.get(),
                        RequiredTimeSize );

     if (!TimeSize)
         return ( s << L"ERROR" );

     return ( s << DateBuffer.get() << L" " << TimeBuffer.get() );
}

BITSOUTStream& operator<< ( BITSOUTStream &s, BG_JOB_PROXY_USAGE ProxyUsage )
{
     switch( ProxyUsage )
         {
         case BG_JOB_PROXY_USAGE_PRECONFIG:
             return (s << L"PRECONFIG");
         case BG_JOB_PROXY_USAGE_NO_PROXY:
             return (s << L"NO_PROXY");
         case BG_JOB_PROXY_USAGE_OVERRIDE:
             return (s << L"OVERRIDE");
         default:
             return (s << L"UNKNOWN");
         }
}

ULONG InputULONG( WCHAR *pText )
{
   ULONG number;
   if ( 1 != swscanf( pText, L"%u", &number ) )
       {
       bcout << L"Invalid number.\n";
       AppExit(1);
       }
   return number;
}

class PrintSidString
{

public:

   WCHAR *m_SidString;

   PrintSidString( WCHAR * SidString ) :
       m_SidString( SidString )
   {
   }

};

BOOL
LocalConvertStringSidToSid (
    IN  PWSTR       StringSid,
    OUT PSID       *Sid,
    OUT PWSTR      *End
    )
/*++

Routine Description:

    This routine will convert a string representation of a SID back into
    a sid.  The expected format of the string is:
                "S-1-5-32-549"
    If a string in a different format or an incorrect or incomplete string
    is given, the operation is failed.

    The returned sid must be free via a call to LocalFree


Arguments:

    StringSid - The string to be converted

    Sid - Where the created SID is to be returned

    End - Where in the string we stopped processing


Return Value:

    TRUE - Success.

    FALSE - Failure.  Additional information returned from GetLastError().  Errors set are:

            ERROR_SUCCESS indicates success

            ERROR_NOT_ENOUGH_MEMORY indicates a memory allocation for the ouput sid
                                    failed
            ERROR_INVALID_SID indicates that the given string did not represent a sid

--*/
{
    DWORD Err = ERROR_SUCCESS;
    UCHAR Revision, Subs;
    SID_IDENTIFIER_AUTHORITY IDAuth;
    PULONG SubAuth = NULL;
    PWSTR CurrEnd, Curr, Next;
    WCHAR Stub, *StubPtr = NULL;
    ULONG Index;
    INT gBase=10;
    INT lBase=10;
    ULONG Auto;

    if ( NULL == StringSid || NULL == Sid || NULL == End ) {

        SetLastError( ERROR_INVALID_PARAMETER );
        return( FALSE );

    }

//    if ( wcslen( StringSid ) < 2 || ( *StringSid != L'S' && *( StringSid + 1 ) != L'-' ) ) {

    //
    // no need to check length because StringSid is NULL
    // and if the first char is NULL, it won't access the second char
    //
    if ( (*StringSid != L'S' && *StringSid != L's') ||
         *( StringSid + 1 ) != L'-' ) {
        //
        // string sid should always start with S-
        //
        SetLastError( ERROR_INVALID_SID );
        return( FALSE );
    }


    Curr = StringSid + 2;

    if ( (*Curr == L'0') &&
         ( *(Curr+1) == L'x' ||
           *(Curr+1) == L'X' ) ) {

        gBase = 16;
    }

    Revision = ( UCHAR )wcstol( Curr, &CurrEnd, gBase );

    if ( CurrEnd == Curr || *CurrEnd != L'-' || *(CurrEnd+1) == L'\0' ) {
        //
        // no revision is provided, or invalid delimeter
        //
        SetLastError( ERROR_INVALID_SID );
        return( FALSE );
    }

    Curr = CurrEnd + 1;

    //
    // Count the number of characters in the indentifer authority...
    //
    Next = wcschr( Curr, L'-' );
/*
    Length = 6 doesn't mean each digit is a id authority value, could be 0x...

    if ( Next != NULL && (Next - Curr == 6) ) {

        for ( Index = 0; Index < 6; Index++ ) {

//            IDAuth.Value[Index] = (UCHAR)Next[Index];  what is this ???
            IDAuth.Value[Index] = (BYTE) (Curr[Index]-L'0');
        }

        Curr +=6;

    } else {
*/
        if ( (*Curr == L'0') &&
             ( *(Curr+1) == L'x' ||
               *(Curr+1) == L'X' ) ) {

            lBase = 16;
        } else {
            lBase = gBase;
        }

        Auto = wcstoul( Curr, &CurrEnd, lBase );

         if ( CurrEnd == Curr || *CurrEnd != L'-' || *(CurrEnd+1) == L'\0' ) {
             //
             // no revision is provided, or invalid delimeter
             //
             SetLastError( ERROR_INVALID_SID );
             return( FALSE );
         }

         IDAuth.Value[0] = IDAuth.Value[1] = 0;
         IDAuth.Value[5] = ( UCHAR )Auto & 0xFF;
         IDAuth.Value[4] = ( UCHAR )(( Auto >> 8 ) & 0xFF );
         IDAuth.Value[3] = ( UCHAR )(( Auto >> 16 ) & 0xFF );
         IDAuth.Value[2] = ( UCHAR )(( Auto >> 24 ) & 0xFF );
         Curr = CurrEnd;
//    }

    //
    // Now, count the number of sub auths, at least one sub auth is required
    //
    Subs = 0;
    Next = Curr;

    //
    // We'll have to count our sub authoritys one character at a time,
    // since there are several deliminators that we can have...
    //

    while ( Next ) {

        if ( *Next == L'-' && *(Next-1) != L'-') {

            //
            // do not allow two continuous '-'s
            // We've found one!
            //
            Subs++;

            if ( (*(Next+1) == L'0') &&
                 ( *(Next+2) == L'x' ||
                   *(Next+2) == L'X' ) ) {
                //
                // this is hex indicator
                //
                Next += 2;

            }

        } else if ( *Next == SDDL_SEPERATORC || *Next  == L'\0' ||
                    *Next == SDDL_ACE_ENDC || *Next == L' ' ||
                    ( *(Next+1) == SDDL_DELIMINATORC &&
                      (*Next == L'G' || *Next == L'O' || *Next == L'S')) ) {
            //
            // space is a terminator too
            //
            if ( *( Next - 1 ) == L'-' ) {
                //
                // shouldn't allow a SID terminated with '-'
                //
                Err = ERROR_INVALID_SID;
                Next--;

            } else {
                Subs++;
            }

            *End = Next;
            break;

        } else if ( !iswxdigit( *Next ) ) {

            Err = ERROR_INVALID_SID;
            *End = Next;
//            Subs++;
            break;

        } else {

            //
            // Note: SID is also used as a owner or group
            //
            // Some of the tags (namely 'D' for Dacl) fall under the category of iswxdigit, so
            // if the current character is a character we care about and the next one is a
            // delminiator, we'll quit
            //
            if ( *Next == L'D' && *( Next + 1 ) == SDDL_DELIMINATORC ) {

                //
                // We'll also need to temporarily truncate the string to this length so
                // we don't accidentally include the character in one of the conversions
                //
                Stub = *Next;
                StubPtr = Next;
                *StubPtr = UNICODE_NULL;
                *End = Next;
                Subs++;
                break;
            }

        }

        Next++;

    }

    if ( Err == ERROR_SUCCESS ) {

        if ( Subs != 0 ) Subs--;

        if ( Subs != 0 ) {

            Curr++;

            SubAuth = ( PULONG )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, Subs * sizeof( ULONG ) );

            if ( SubAuth == NULL ) {

                Err = ERROR_NOT_ENOUGH_MEMORY;

            } else {

                for ( Index = 0; Index < Subs; Index++ ) {

                    if ( (*Curr == L'0') &&
                         ( *(Curr+1) == L'x' ||
                           *(Curr+1) == L'X' ) ) {

                        lBase = 16;
                    } else {
                        lBase = gBase;
                    }

                    SubAuth[Index] = wcstoul( Curr, &CurrEnd, lBase );
                    Curr = CurrEnd + 1;
                }
            }

        } else {

            Err = ERROR_INVALID_SID;
        }
    }

    //
    // Now, create the SID
    //
    if ( Err == ERROR_SUCCESS ) {

        *Sid = ( PSID )LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT,
                                   sizeof( SID ) + Subs * sizeof( ULONG ) );

        if ( *Sid == NULL ) {

            Err = ERROR_NOT_ENOUGH_MEMORY;

        } else {

            PISID ISid = ( PISID )*Sid;
            ISid->Revision = Revision;
            ISid->SubAuthorityCount = Subs;
            ISid->IdentifierAuthority = IDAuth;
            RtlCopyMemory( ISid->SubAuthority, SubAuth, Subs * sizeof( ULONG ) ); // SEC-REVIEWED: 2002-03-21
        }
    }

    LocalFree( SubAuth );

    //
    // Restore any character we may have stubbed out
    //
    if ( StubPtr ) {

        *StubPtr = Stub;
    }

    SetLastError( Err );

    return( Err == ERROR_SUCCESS );
}

BOOL
AltConvertStringSidToSid(
    IN LPCWSTR  StringSid,
    OUT PSID   *Sid
    )

/*++

Routine Description:

    This routine converts a stringized SID into a valid, functional SID

Arguments:

    StringSid - SID to be converted.

    Sid - Where the converted SID is returned.  Buffer is allocated via LocalAlloc and should
        be free via LocalFree.


Return Value:

    TRUE    -   Success
    FALSE   -   Failure

    Extended error status is available using GetLastError.

        ERROR_INVALID_PARAMETER - A NULL name was given

        ERROR_INVALID_SID - The format of the given sid was incorrect

--*/

{
    PWSTR End = NULL;
    BOOL ReturnValue = FALSE;
    PSID pSASid=NULL;
    ULONG Len=0;
    DWORD SaveCode=0;
    DWORD Err=0;

    if ( StringSid == NULL || Sid == NULL )
        {
        SetLastError( ERROR_INVALID_PARAMETER );
        return ReturnValue;
        }

    ReturnValue = LocalConvertStringSidToSid( ( PWSTR )StringSid, Sid, &End );

    if ( !ReturnValue )
        {
        SetLastError( ERROR_INVALID_PARAMETER );
        return ReturnValue;
        }

    if ( ( ULONG )( End - StringSid ) != wcslen( StringSid ) ) {

        SetLastError( ERROR_INVALID_SID );
        LocalFree( *Sid );
        *Sid = FALSE;
        ReturnValue = FALSE;

        } else {
            SetLastError(ERROR_SUCCESS);
        }

    return ReturnValue;

}

BITSOUTStream& operator<< ( BITSOUTStream &s, PrintSidString SidString )
{

    // Convert the SID string into the user name
    // in domain\account format.
    // If an error occures, just return the SID string

    PSID pSid = NULL;
    BOOL bResult =
        AltConvertStringSidToSid(
            SidString.m_SidString,
            &pSid );

    if ( !bResult )
        {
        return ( s << SidString.m_SidString );
        }

    SID_NAME_USE NameUse;
    DWORD dwNameSize = 0;
    DWORD dwDomainSize = 0;
    bResult = LookupAccountSid(
        NULL,
        pSid,
        NULL,
        &dwNameSize,
        NULL,
        &dwDomainSize,
        &NameUse);

    if ( bResult ||
         ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) )
        {
        LocalFree( pSid );
        return ( s << SidString.m_SidString );
        }

    CAutoString pName( new WCHAR[ dwNameSize ] );
    CAutoString pDomain( new WCHAR[ dwDomainSize ] );

    bResult = LookupAccountSid(
        NULL,
        pSid,
        pName.get(),
        &dwNameSize,
        pDomain.get(),
        &dwDomainSize,
        &NameUse);

    if (!bResult)
        {
        LocalFree( pSid );
        return ( s << SidString.m_SidString );
        }

    LocalFree( pSid );
    return ( s << pDomain.get() << L"\\" << pName.get() );

}

void * _cdecl operator new( size_t Size )
{
   void *Memory = CoTaskMemAlloc( Size );

   if ( !Memory )
      {
      bcout << L"Out of memory while allocating " << Size << L" bytes.\n";
      AppExit( (int)E_OUTOFMEMORY );
      }

   return Memory;
}

void _cdecl operator delete( void *Mem )
{
   CoTaskMemFree( Mem );
}

void RestoreConsole();
void __declspec(noreturn) AppExit( int val )
{
    bcout.FlushBuffer();
    RestoreConsole();
    exit( val );
}

void PollShutdown()
{
    if ( g_Shutdown )
        AppExit( (DWORD)CONTROL_C_EXIT );
}


void ShutdownAPC( ULONG_PTR )
{
    return;
}

void SignalShutdown( DWORD MilliTimeout )
{
    g_Shutdown = true;

    // Queue a shutdown APC

    if ( g_MainThreadHandle )
        {
        QueueUserAPC( ShutdownAPC, g_MainThreadHandle, NULL );
        }

    Sleep( MilliTimeout );
    RestoreConsole();
    TerminateProcess( GetCurrentProcess(),  (DWORD)CONTROL_C_EXIT );
}



void CheckHR( const WCHAR *pFailTxt, HRESULT Hr )
{

    // Check error code for success, and exit
    // with a failure message if unsuccessfull.

    if ( !SUCCEEDED(Hr) ) {
        WCHAR ErrorCode[12];
        StringCbPrintf( ErrorCode, sizeof(ErrorCode), L"0x%8.8x", Hr );
        bcout << pFailTxt << L" - " << ErrorCode << L"\n";

        WCHAR *pMessage = NULL;

        if ( FormatMessage(
                FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                (DWORD)Hr,
                GetThreadLocale(),
                (WCHAR*)&pMessage,
                0,
                NULL ) )
            {
            bcout << pMessage << L"\n";
            LocalFree( pMessage );
            }

        AppExit( Hr );
    }
}

//
// Code to handle console pretty printing mode changes
//

bool bConsoleInfoRetrieved = false;
HANDLE hConsole;
CRITICAL_SECTION CritSection;
CONSOLE_SCREEN_BUFFER_INFO StartConsoleInfo;
DWORD StartConsoleMode;

void SetupConsole()
{
    if (!( GetFileType( bcout.GetHandle() ) == FILE_TYPE_CHAR ) )
        return;

    hConsole = bcout.GetHandle();
    if ( INVALID_HANDLE_VALUE == hConsole )
        CheckHR( L"Unable to get console handle", HRESULT_FROM_WIN32( GetLastError() ) );

    if (!GetConsoleScreenBufferInfo( hConsole, &StartConsoleInfo ) )
        CheckHR( L"Unable get setup console information", HRESULT_FROM_WIN32( GetLastError() ) );

    if (!GetConsoleMode( hConsole, &StartConsoleMode ) )
        CheckHR( L"Unable get setup console information", HRESULT_FROM_WIN32( GetLastError() ) );

    InitializeCriticalSection( &CritSection );
    bConsoleInfoRetrieved = true;

    EnterCriticalSection( &CritSection );

    DWORD NewConsoleMode = ( bWrap ) ?
        ( StartConsoleMode | ENABLE_WRAP_AT_EOL_OUTPUT ) :
        ( StartConsoleMode & ~ENABLE_WRAP_AT_EOL_OUTPUT );

    if (!SetConsoleMode( hConsole, NewConsoleMode ) )
        CheckHR( L"Unable set console mode", HRESULT_FROM_WIN32( GetLastError() ) );
    LeaveCriticalSection( &CritSection );
}

void RestoreConsole()
{
    if ( bConsoleInfoRetrieved )
        {
        EnterCriticalSection( &CritSection );
        SetConsoleTextAttribute( hConsole, StartConsoleInfo.wAttributes );
        SetConsoleMode( hConsole, StartConsoleMode );
        // Do not unlock, since we shouldn't allow any more console attribute changes
        }
}

void ClearScreen()
{
  COORD coordScreen = { 0, 0 };
  BOOL bSuccess;
  DWORD cCharsWritten;
  CONSOLE_SCREEN_BUFFER_INFO csbi;
  DWORD dwConSize;

  EnterCriticalSection( &CritSection );
  if (!GetConsoleScreenBufferInfo(hConsole, &csbi))
      goto error;
  dwConSize = csbi.dwSize.X * csbi.dwSize.Y;
  if (!FillConsoleOutputCharacter(hConsole, (WCHAR) ' ',
      dwConSize, coordScreen, &cCharsWritten))
      goto error;
  if (!GetConsoleScreenBufferInfo(hConsole, &csbi))
      goto error;
  if (!FillConsoleOutputAttribute(hConsole, csbi.wAttributes,
      dwConSize, coordScreen, &cCharsWritten))
      goto error;
  if  (!SetConsoleCursorPosition(hConsole, coordScreen))
      goto error;
  LeaveCriticalSection( &CritSection );
  return;

error:

  DWORD dwError = GetLastError();
  LeaveCriticalSection( &CritSection );
  CheckHR( L"Unable to clear the console window", HRESULT_FROM_WIN32( dwError ) );
  AppExit( dwError );
}

//
// Classes set the intensity mode for the text.  Use as follows
// bcout << L"Some normal text " << AddIntensity();
// bcout << L"Intense text" << ResetIntensity() << L"Normal";
//


class AddIntensity
{
};

BITSOUTStream & operator<<( BITSOUTStream & s, AddIntensity  )
{
    if ( GetFileType( s.GetHandle() ) == FILE_TYPE_CHAR )
        {
        s.FlushBuffer();
        EnterCriticalSection( &CritSection );
        SetConsoleTextAttribute( hConsole, StartConsoleInfo.wAttributes | FOREGROUND_INTENSITY );
        LeaveCriticalSection( &CritSection );
    }
    return s;
}

class ResetIntensity
{
};

BITSOUTStream & operator<<( BITSOUTStream & s, ResetIntensity )
{
    if ( GetFileType( s.GetHandle() ) == FILE_TYPE_CHAR )
        {
        s.FlushBuffer();
        EnterCriticalSection( &CritSection );
        SetConsoleTextAttribute( hConsole, StartConsoleInfo.wAttributes );
        LeaveCriticalSection( &CritSection );
        }
    return s;
}


void CheckBITSHR( const WCHAR *pFailTxt, HRESULT Hr )
{
   // Check on error code returned from BITS,
   // and exit with a printed error messeage on an error

   if ( !SUCCEEDED(Hr) )
        {
        WCHAR ErrorCode[12];
        StringCbPrintf( ErrorCode, sizeof(ErrorCode), L"0x%8.8x", Hr );
        bcout << pFailTxt << L" - " << ErrorCode << L"\n";

        AutoStringPointer Message;

        if ( SUCCEEDED( g_Manager->GetErrorDescription(
                            Hr,
                            GetThreadLocale(),
                            Message.GetRecvPointer() ) ) )
            {
            bcout << Message << L"\n";
            }

        AppExit( Hr );
        }
}

void ConnectToBITS()
{

    // Connects to the BITS service

    if ( g_Manager.Get() )
        return;

    if ( !pComputerName )
        {
        CheckHR( L"Unable to connect to BITS",
                 CoCreateInstance( CLSID_BackgroundCopyManager,
                                   NULL,
                                   CLSCTX_LOCAL_SERVER,
                                   IID_IBackgroundCopyManager,
                                   (void**)g_Manager.GetRecvPointer() ) );
        }
    else
        {
        COSERVERINFO ServerInfo;
        memset( &ServerInfo, 0 , sizeof( ServerInfo ) );
        ServerInfo.pwszName = pComputerName;

        IClassFactory *pFactory = NULL;

        CheckHR( L"Unable to connect to BITS",
                 CoGetClassObject(
                     CLSID_BackgroundCopyManager,
                     CLSCTX_REMOTE_SERVER,
                     &ServerInfo,
                     IID_IClassFactory,
                     (void**) &pFactory ) );


        CheckHR( L"Unable to connect to BITS",
                 pFactory->CreateInstance(
                     NULL,
                     IID_IBackgroundCopyManager,
                     (void**)g_Manager.GetRecvPointer() ));
        pFactory->Release();
        }
}

//
// Generic commandline parsing structures and functions
//

typedef void (*PCMDPARSEFUNC)(int, WCHAR** );
typedef struct _PARSEENTRY
{
  const WCHAR * pCommand;
  PCMDPARSEFUNC pParseFunc;
} PARSEENTRY;

typedef struct _PARSETABLE
{
  const PARSEENTRY *pEntries;
  PCMDPARSEFUNC pErrorFunc;
  void * pErrorContext;
} PARSETABLE;

void ParseCmd( int argc, WCHAR **argv, const PARSETABLE *pParseTable )
{
    if ( !argc) goto InvalidCommand;

    for( const PARSEENTRY *pEntry = pParseTable->pEntries;
         pEntry->pCommand; pEntry++ )
    {
       if (!_wcsicmp( *argv, pEntry->pCommand ))
       {
           argc--;
           argv++;
           (*pEntry->pParseFunc)( argc, argv  );
           return;
       }
    }

InvalidCommand:
    // Couldn't find a match, so complain
    bcout << L"Invalid command\n";
    (*pParseTable->pErrorFunc)( argc, argv );
    AppExit( 1 );

}

//
// BITS specific input and output
//

BITSOUTStream & operator<<( BITSOUTStream &s, SmartJobPointer Job )
{
    GUID guid;
    CheckBITSHR( L"Unable to get guid to job", Job->GetId( &guid ) );
    return (s << guid );
}

BITSOUTStream& operator<<( BITSOUTStream &s, SmartJobErrorPointer Error )
{
    SmartFilePointer pFile;
    AutoStringPointer LocalName;
    AutoStringPointer URL;

    CheckBITSHR( L"Unable to get error file", Error->GetFile( pFile.GetRecvPointer() ) );
    CheckBITSHR( L"Unable to get error URL", pFile->GetRemoteName( URL.GetRecvPointer() ) );
    CheckBITSHR( L"Unable to get error file name", pFile->GetLocalName( LocalName.GetRecvPointer() ) );

    bcout << AddIntensity() << L"ERROR FILE:    " << ResetIntensity() << URL << L" -> " << LocalName << L"\n";

    BG_ERROR_CONTEXT Context;
    HRESULT Code;
    AutoStringPointer ErrorDescription;
    AutoStringPointer ContextDescription;
    CheckBITSHR( L"Unable to get error code", Error->GetError( &Context, &Code ) );
    CheckBITSHR( L"Unable to get error description",
                 Error->GetErrorDescription( (DWORD)GetThreadLocale(), ErrorDescription.GetRecvPointer() ) );
    CheckBITSHR( L"Unable to get context description",
                 Error->GetErrorContextDescription( (DWORD)GetThreadLocale(), ContextDescription.GetRecvPointer() ) );

    bcout << AddIntensity() << L"ERROR CODE:    " << ResetIntensity() <<
             HRESULTToString(Code) << L" - " << ErrorDescription;
    bcout << AddIntensity() << L"ERROR CONTEXT: " << ResetIntensity() <<
             HRESULTToString((HRESULT)Context) << L" - " << ContextDescription;

    return s;
}

BITSOUTStream & operator<<( BITSOUTStream &s, BG_JOB_TYPE type )
{
    if ( BG_JOB_TYPE_DOWNLOAD == type )
        return ( s << L"DOWNLOAD" );
    else if ( BG_JOB_TYPE_UPLOAD == type )
        return ( s << L"UPLOAD" );
    else if ( BG_JOB_TYPE_UPLOAD_REPLY == type )
        return ( s << L"UPLOAD-REPLY" );
    else
        return ( s << L"UNKNOWN" );
}

BITSOUTStream & operator<<( BITSOUTStream &s, BG_JOB_STATE state )
{
    switch(state)
        {
        case BG_JOB_STATE_QUEUED:
            return ( s << L"QUEUED" );
        case BG_JOB_STATE_CONNECTING:
            return ( s << L"CONNECTING" );
        case BG_JOB_STATE_TRANSFERRING:
            return ( s << L"TRANSFERRING" );
        case BG_JOB_STATE_SUSPENDED:
            return ( s << L"SUSPENDED" );
        case BG_JOB_STATE_ERROR:
            return ( s << L"ERROR" );
        case BG_JOB_STATE_TRANSIENT_ERROR:
            return ( s << L"TRANSIENT_ERROR" );
        case BG_JOB_STATE_TRANSFERRED:
            return ( s << L"TRANSFERRED" );
        case BG_JOB_STATE_ACKNOWLEDGED:
            return ( s << L"ACKNOWLEDGED" );
        case BG_JOB_STATE_CANCELLED:
            return ( s << L"CANCELLED" );
        default:
            return ( s << L"UNKNOWN" );
        }
}

BITSOUTStream & operator<<( BITSOUTStream &s, BG_JOB_PRIORITY priority )
{
    switch(priority)
        {
        case BG_JOB_PRIORITY_FOREGROUND:
            return ( s << L"FOREGROUND" );
        case BG_JOB_PRIORITY_HIGH:
            return ( s << L"HIGH" );
        case BG_JOB_PRIORITY_NORMAL:
            return ( s << L"NORMAL" );
        case BG_JOB_PRIORITY_LOW:
            return ( s << L"LOW" );
        default:
            return ( s << L"UNKNOWN" );
        }
}

BG_JOB_PRIORITY JobInputPriority(  WCHAR *pText )
{
    if ( _wcsicmp( pText, L"FOREGROUND" )  == 0 )
        return BG_JOB_PRIORITY_FOREGROUND;
    if ( _wcsicmp( pText, L"HIGH" ) == 0 )
        return BG_JOB_PRIORITY_HIGH;
    if ( _wcsicmp( pText, L"NORMAL" ) == 0 )
        return BG_JOB_PRIORITY_NORMAL;
    if ( _wcsicmp( pText, L"LOW" ) == 0 )
        return BG_JOB_PRIORITY_LOW;

    bcout << L"Invalid priority.\n";
    AppExit(1);
}

SmartJobPointer
JobLookupViaDisplayName( const WCHAR * JobName )
{
     SmartEnumJobsPointer Enum;
     CheckBITSHR( L"Unable to lookup job", g_Manager->EnumJobs( 0, Enum.GetRecvPointer() ) );

     size_t FoundJobs = 0;
     SmartJobPointer FoundJob;

     SmartJobPointer Job;
     while( Enum->Next( 1, Job.GetRecvPointer(), NULL ) == S_OK )
         {

         PollShutdown();

         AutoStringPointer DisplayName;
         CheckBITSHR( L"Unable to lookup job", Job->GetDisplayName( DisplayName.GetRecvPointer() ) );

         if ( wcscmp( DisplayName, JobName) == 0 )
             {
             FoundJobs++;
             FoundJob = Job;
             }

         }

     if ( 1 == FoundJobs )
         {
         return FoundJob;
         }

     if ( !FoundJobs )
         {
         bcout << L"Unable to find job named \"" << JobName << L"\".\n";
         AppExit( 1 );
         }

     bcout << L"Found " << FoundJobs << L" jobs named \"" << JobName << L"\".\n";
     bcout << L"Use the job identifier instead of the job name.\n";

     AppExit( 1 );

}

SmartJobPointer
JobLookup( WCHAR * JobName )
{
    ConnectToBITS();

    GUID JobGuid;
    SmartJobPointer Job;
    if ( FAILED( CLSIDFromString( JobName, &JobGuid) ) )
        return JobLookupViaDisplayName( JobName );

    if ( FAILED( g_Manager->GetJob( JobGuid, Job.GetRecvPointer() ) ) )
        return JobLookupViaDisplayName( JobName );

    return Job;
}

SmartJobPointer
JobLookupForNoArg( int argc, WCHAR **argv )
{
    if (1 != argc)
        {
        bcout << L"Invalid number of arguments.\n";
        AppExit(1);
        }
    return JobLookup( argv[0] );
}

void JobValidateArgs( int argc, WCHAR**argv, int required )
{
    if ( argc != required )
        {
        bcout << L"Invalid number of arguments.\n";
        AppExit(1);
        }
}

//
// Actual command functions
//

void JobCreate( int argc, WCHAR **argv )
{
    GUID guid;
    SmartJobPointer Job;

    BG_JOB_TYPE type = BG_JOB_TYPE_DOWNLOAD;

    while (argc > 0)
        {
        if (argv[0][0] != '/')
            {
            break;
            }

        if ( !_wcsicmp( argv[0], L"/UPLOAD" ) )
            {
            type = BG_JOB_TYPE_UPLOAD;
            }
        else if ( !_wcsicmp( argv[0], L"/UPLOAD-REPLY" ) )
            {
            type = BG_JOB_TYPE_UPLOAD_REPLY;
            }
        else if ( !_wcsicmp( argv[0], L"/DOWNLOAD" ) )
            {
            type = BG_JOB_TYPE_DOWNLOAD;
            }
        else
            {
            bcout << L"Invalid argument.\n";
            AppExit(1);
            }

        --argc;
        ++argv;
        }

    JobValidateArgs( argc, argv, 1 );

    ConnectToBITS();

    CheckBITSHR( L"Unable to create group",
                 g_Manager->CreateJob( argv[0],
                                       type,
                                       &guid,
                                       Job.GetRecvPointer() ) );
    if (bRawReturn)
        bcout << Job;
    else
        bcout << L"Created job " << Job << L".\n";
}

void JobAddFile( int argc, WCHAR **argv )
{
     JobValidateArgs( argc, argv, 3 );
     SmartJobPointer Job = JobLookup( argv[0] );
     CheckBITSHR( L"Unable to add file to job", Job->AddFile( argv[1], argv[2] ) );
     bcout << L"Added " << argv[1] << L" -> " << argv[2] << L" to job.\n";
}

size_t JobListFiles( SmartJobPointer Job, bool bDoIndent )
{
    SmartEnumFilesPointer Enum;
    CheckBITSHR( L"Unable to enum files in job", Job->EnumFiles( Enum.GetRecvPointer() ) );
    SmartFilePointer pFile;
    size_t FilesListed = 0;
    while( Enum->Next( 1, pFile.GetRecvPointer(), NULL ) == S_OK )
        {
        BG_FILE_PROGRESS progress;
        AutoStringPointer URL;
        AutoStringPointer Local;

        CheckBITSHR( L"Unable to get file progress", pFile->GetProgress( &progress ) );
        CheckBITSHR( L"Unable to get file URL", pFile->GetRemoteName( URL.GetRecvPointer() ) );
        CheckBITSHR( L"Unable to get local file name", pFile->GetLocalName( Local.GetRecvPointer() ) );

        if ( bDoIndent )
            bcout << L"\t";

        WCHAR *pCompleteText = progress.Completed ? L"COMPLETED" : L"WORKING";

        bcout << progress.BytesTransferred << L" / ";
        if ( progress.BytesTotal != (UINT64)-1 )
            {
            bcout << progress.BytesTotal;
            }
        else
            {
            bcout << L"UNKNOWN";
            }
        bcout << L" " << pCompleteText << L" " << URL << L" -> " << Local << L"\n";

        // Example output:
        // 10 / 1000 INCOMPLETE http://www.microsoft.com -> c:\temp\microsoft.htm

        FilesListed++;

        }
    return FilesListed;
}

void JobListFiles( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    size_t FilesListed = JobListFiles( Job, false );

    if (!bRawReturn)
        bcout << L"Listed " << FilesListed << L" file(s).\n";
}

void JobSuspend( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    CheckBITSHR( L"Unable to suspend job", Job->Suspend() );
    bcout << L"Job suspended.\n";
}

void JobResume( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    CheckBITSHR( L"Unable to resume job", Job->Resume() );
    bcout << L"Job resumed.\n";
}

void JobCancel( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    CheckBITSHR( L"Unable to cancel job", Job->Cancel() );
    bcout <<  L"Job canceled.\n";
}

void JobComplete( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    CheckBITSHR( L"Unable to complete job", Job->Complete() );
    bcout << L"Job completed.\n";
}

void JobGetType( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_TYPE type;
    CheckBITSHR( L"Unable to get job type", Job->GetType(&type) );
    bcout << type;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetBytesTotal( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_PROGRESS progress;
    CheckBITSHR( L"Unable to get total bytes in job", Job->GetProgress( &progress ) );
    bcout << progress.BytesTotal;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetBytesTransferred( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_PROGRESS progress;
    CheckBITSHR( L"Unable to get bytes transferred in job", Job->GetProgress( &progress ) );
    bcout << progress.BytesTransferred;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetFilesTotal( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_PROGRESS progress;
    CheckBITSHR( L"Unable to get number of files in job", Job->GetProgress( &progress ) );
    bcout << progress.FilesTotal;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetFilesTransferred( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_PROGRESS progress;
    CheckBITSHR( L"Unable to get numeber of transferred files in job", Job->GetProgress( &progress ) );
    bcout << progress.FilesTransferred;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetCreationTime( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_TIMES times;
    CheckBITSHR( L"Unable to get job creation time", Job->GetTimes( &times ) );
    bcout << times.CreationTime;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetModificationTime( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_TIMES times;
    CheckBITSHR( L"Unable to get job modification time", Job->GetTimes( &times ) );
    bcout << times.ModificationTime;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetCompletionTime( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_TIMES times;
    CheckBITSHR( L"Unable to get job completion time", Job->GetTimes( &times ) );
    if ( !times.TransferCompletionTime.dwLowDateTime && !times.TransferCompletionTime.dwHighDateTime )
        bcout << L"WORKING";
    else
        bcout << times.TransferCompletionTime;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetError( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    SmartJobErrorPointer Error;
    CheckBITSHR( L"Unable to get error", Job->GetError( Error.GetRecvPointer() ) );
    bcout << Error;
}

void JobGetState( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_STATE state;
    CheckBITSHR( L"Unable to get job state", Job->GetState( &state ) );
    bcout << state;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetOwner( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    AutoStringPointer Owner;
    CheckBITSHR( L"Unable to get job owner", Job->GetOwner( Owner.GetRecvPointer() ) );
    bcout << PrintSidString( Owner );
    if (!bRawReturn) bcout << L"\n";
}

void JobGetDisplayName( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    AutoStringPointer DisplayName;
    CheckBITSHR( L"Unable to get job displayname", Job->GetDisplayName( DisplayName.GetRecvPointer() ) );
    bcout << DisplayName;
    if (!bRawReturn) bcout << L"\n";
}

void JobSetDisplayName( int argc, WCHAR **argv )
{
     JobValidateArgs( argc, argv, 2 );
     SmartJobPointer Job = JobLookup( argv[0] );
     CheckBITSHR( L"Unable to set display name", Job->SetDisplayName( argv[1] ) );
     bcout << L"Display name set to " << argv[1] << L".\n";
}

void JobGetDescription( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    AutoStringPointer Description;
    CheckBITSHR( L"Unable to get job displayname", Job->GetDescription( Description.GetRecvPointer() ) );
    bcout << Description;
    if (!bRawReturn) bcout << L"\n";
}

void JobSetDescription( int argc, WCHAR **argv )
{
     JobValidateArgs( argc, argv, 2 );
     SmartJobPointer Job = JobLookup( argv[0] );
     CheckBITSHR( L"Unable to set description", Job->SetDescription( argv[1] ) );
     bcout << L"Description set to " << argv[1] << L".\n";
}

void JobGetReplyFileName( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );

    SmartJob2Pointer Job2;
    CheckBITSHR( L"Unable to get the IBackgroundCopyJob2 interface. Version 1.5 is required", Job2FromJob( Job, Job2 ));

    AutoStringPointer ReplyFileName;
    CheckBITSHR( L"Unable to get reply file name", Job2->GetReplyFileName( ReplyFileName.GetRecvPointer() ) );
    if (ReplyFileName)
        {
        bcout << L"'" << ReplyFileName << L"'";
        }
    else
        {
        bcout << L"(null)";
        }

    if (!bRawReturn) bcout << L"\n";
}

void JobSetReplyFileName( int argc, WCHAR **argv )
{
     JobValidateArgs( argc, argv, 2 );
     SmartJobPointer Job = JobLookup( argv[0] );

     SmartJob2Pointer Job2;
     CheckBITSHR( L"Unable to get the IBackgroundCopyJob2 interface. Version 1.5 is required", Job2FromJob( Job, Job2 ));

     CheckBITSHR( L"Unable to set reply file name", Job2->SetReplyFileName( argv[1] ) );
     bcout << L"reply file name set to " << argv[1] << L".\n";
}

void JobGetReplyProgress( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );

    SmartJob2Pointer Job2;
    CheckBITSHR( L"Unable to get the IBackgroundCopyJob2 interface. Version 1.5 is required", Job2FromJob( Job, Job2 ));

    BG_JOB_REPLY_PROGRESS Progress;
    CheckBITSHR( L"Unable to get reply progress", Job2->GetReplyProgress( &Progress ) );

    bcout << L"progress: " << ULONG(Progress.BytesTransferred) << L" / ";

    if (Progress.BytesTotal == BG_SIZE_UNKNOWN)
        bcout << L"(unknown)";
    else
        bcout << ULONG(Progress.BytesTotal);

    bcout << L".\n";

    if (!bRawReturn) bcout << L"\n";
}

bool
printable( char c )
{
    if ( c < 32 )
        {
        return false;
        }

    if ( c > 126 )
        {
        return false;
        }

    return true;
}

void
DumpBuffer(
          void * Buffer,
          unsigned Length
          )
{
    const BYTES_PER_LINE = 16;

    unsigned char FAR *p = (unsigned char FAR *) Buffer;

    //
    // 3 chars per byte for hex display, plus an extra space every 4 bytes,
    // plus a byte for the printable representation, plus the \0.
    //
    const buflen = BYTES_PER_LINE*3+BYTES_PER_LINE/4+BYTES_PER_LINE;
    wchar_t Outbuf[buflen+1];
    Outbuf[0] = 0;
    Outbuf[buflen] = 0;
    wchar_t * HexDigits = L"0123456789abcdef";

    unsigned Index;
    for ( unsigned Offset=0; Offset < Length; Offset++ )
        {
        Index = Offset % BYTES_PER_LINE;

        if ( Index == 0 )
            {
            bcout << L"    " << Outbuf << L"\n";

            for (int i=0; i < buflen; ++i)
                {
                Outbuf[i] = L' ';
                }
            }

        Outbuf[Index*3+Index/4  ] = HexDigits[p[Offset] / 16];
        Outbuf[Index*3+Index/4+1] = HexDigits[p[Offset] % 16];
        Outbuf[BYTES_PER_LINE*3+BYTES_PER_LINE/4+Index] = printable(p[Offset]) ? p[Offset] : L'.';
        }

    bcout << L"    " << Outbuf << L"\n";
}

void JobGetReplyData( int argc, WCHAR **argv )
{
    byte * Buffer = 0;
    ULONG Length = 0;

    SmartJobPointer Job = JobLookupForNoArg( argc, argv );

    SmartJob2Pointer Job2;
    CheckBITSHR( L"Unable to get the IBackgroundCopyJob2 interface. Version 1.5 is required", Job2FromJob( Job, Job2 ));

    CheckBITSHR( L"Unable to get reply data", Job2->GetReplyData( &Buffer, &Length ) );

    bcout << L"data length is " << Length;
    DumpBuffer( Buffer, Length );
}

void JobGetNotifyCmdLine( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );

    SmartJob2Pointer Job2;
    CheckBITSHR( L"Unable to get the IBackgroundCopyJob2 interface. Version 1.5 is required", Job2FromJob( Job, Job2 ));

    LPWSTR CmdLine = 0;
    CheckBITSHR( L"Unable to get command line", Job2->GetNotifyCmdLine( &CmdLine ) );

    bcout << L"the notification command line is '" << CmdLine << L"'";

    if (!bRawReturn) bcout << L"\n";
}

void JobSetNotifyCmdLine( int argc, WCHAR **argv )
{
     JobValidateArgs( argc, argv, 2 );
     SmartJobPointer Job = JobLookup( argv[0] );

     SmartJob2Pointer Job2;
     CheckBITSHR( L"Unable to get the IBackgroundCopyJob2 interface. Version 1.5 is required", Job2FromJob( Job, Job2 ));

     CheckBITSHR( L"Unable to set the notification command line", Job2->SetNotifyCmdLine( argv[1] ) );
     bcout << L"notification command line set to '" << argv[1] << L"'.\n";
}



BG_AUTH_TARGET TargetFromString( LPCWSTR s )
{
    if (0 == _wcsicmp(s, L"server"))
        {
        return BG_AUTH_TARGET_SERVER;
        }
    else if (0 == _wcsicmp(s, L"proxy"))
        {
        return BG_AUTH_TARGET_PROXY;
        }

    bcout << L"'" << s << L"' is not a valid credential target.  It must be 'proxy' or 'server'.\n";
    AppExit( 1 );
}

struct
{
    LPCWSTR        Name;
    BG_AUTH_SCHEME Scheme;
}
SchemeNames[] =
{
    { L"basic",      BG_AUTH_SCHEME_BASIC },
    { L"digest",     BG_AUTH_SCHEME_DIGEST },
    { L"ntlm",       BG_AUTH_SCHEME_NTLM },
    { L"negotiate",  BG_AUTH_SCHEME_NEGOTIATE },
    { L"passport",   BG_AUTH_SCHEME_PASSPORT },

    { NULL,         BG_AUTH_SCHEME_BASIC }
};

BG_AUTH_SCHEME SchemeFromString( LPCWSTR s )
{
    int i;

    i = 0;
    while (SchemeNames[i].Name != NULL)
        {
        if (0 == _wcsicmp( s, SchemeNames[i].Name ))
            {
            return SchemeNames[i].Scheme;
            }

        ++i;
        }

    bcout << L"'" << s << L"is not a valid credential scheme.\n"
        L"It must be one of the following:\n"
        L"    basic\n"
        L"    digest\n"
        L"    ntlm\n"
        L"    negotiate\n"
        L"    passport\n";

    AppExit( 1 );
}


void JobSetCredentials( int argc, WCHAR **argv )
/*

    args:

        0:  job ID
        1:  "proxy" | "server"
        2:  "basic" | "digest" | "ntlm" | "negotiate" | "passport"
        3:  user name
        4:  password

*/
{
     JobValidateArgs( argc, argv, 5 );
     SmartJobPointer Job = JobLookup( argv[0] );

     SmartJob2Pointer Job2;
     CheckBITSHR( L"Unable to get the IBackgroundCopyJob2 interface. Version 1.5 is required", Job2FromJob( Job, Job2 ));

     BG_AUTH_CREDENTIALS cred;

     cred.Target = TargetFromString( argv[1] );
     cred.Scheme = SchemeFromString( argv[2] );

     cred.Credentials.Basic.UserName = argv[3];

     cred.Credentials.Basic.Password = argv[4];

     CheckBITSHR( L"Unable to add credentials", Job2->SetCredentials( &cred ));

     bcout << L"OK" << L".\n";
}

void JobRemoveCredentials( int argc, WCHAR **argv )
/*

    args:

        0:  job ID
        1:  "proxy" | "server"
        2:  "basic" | "digest" | "ntlm" | "negotiate" | "passport"

*/
{
     JobValidateArgs( argc, argv, 3 );
     SmartJobPointer Job = JobLookup( argv[0] );

     SmartJob2Pointer Job2;
     CheckBITSHR( L"Unable to get the IBackgroundCopyJob2 interface. Version 1.5 is required", Job2FromJob( Job, Job2 ));

     HRESULT hr;
     BG_AUTH_TARGET Target;
     BG_AUTH_SCHEME Scheme;

     Target = TargetFromString( argv[1] );
     Scheme = SchemeFromString( argv[2] );

     hr = Job2->RemoveCredentials( Target, Scheme );

     CheckBITSHR( L"Unable to remove credentials", hr);

     if (hr == S_FALSE)
         {
         bcout << L"no matching credential was found.\n";
         }
     else
         {
         bcout << L"OK" << L".\n";
         }
}


void JobGetPriority( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_PRIORITY priority;
    CheckBITSHR( L"Unable to get job displayname", Job->GetPriority( &priority ) );
    bcout << priority;
    if (!bRawReturn) bcout << L"\n";
}

void JobSetPriority( int argc, WCHAR **argv )
{
     JobValidateArgs( argc, argv, 2 );
     SmartJobPointer Job = JobLookup( argv[0] );
     BG_JOB_PRIORITY priority = JobInputPriority(  argv[1] );
     CheckBITSHR( L"Unable to set description", Job->SetPriority( priority ) );
     bcout << L"Priority set to " << priority << L".\n";
}

void JobGetNotifyFlags( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    ULONG flags;
    CheckBITSHR( L"Unable to get notify flags", Job->GetNotifyFlags( &flags ) );
    bcout << flags;
    if (!bRawReturn) bcout << L"\n";
}

void JobSetNotifyFlags( int argc, WCHAR **argv )
{
     JobValidateArgs( argc, argv, 2 );
     SmartJobPointer Job = JobLookup( argv[0] );
     ULONG NewFlags = InputULONG( argv[1] );
     CheckBITSHR( L"Unable to set description", Job->SetNotifyFlags( NewFlags ) );
     bcout << L"Notification flags set to " << NewFlags << L".\n";
}

void JobGetNotifyInterface( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    SmartIUnknownPointer pUnknown;
    CheckBITSHR( L"Unable to get notify interface", Job->GetNotifyInterface( pUnknown.GetRecvPointer() ) );
    if ( pUnknown.Get() )
        bcout << L"REGISTERED";
    else
        bcout << L"UNREGISTERED";
    if (!bRawReturn) bcout << L"\n";
}

void JobSetMinimumRetryDelay( int argc, WCHAR **argv )
{
     JobValidateArgs( argc, argv, 2 );
     SmartJobPointer Job = JobLookup( argv[0] );
     ULONG NewDelay = InputULONG( argv[1] );
     CheckBITSHR( L"Unable to set new minimum retry delay", Job->SetMinimumRetryDelay( NewDelay ) );
     bcout << L"Minimum retry delay set to " << NewDelay << L".\n";
}

void JobGetMinimumRetryDelay( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    ULONG delay;
    CheckBITSHR( L"Unable to get minimum retry delay", Job->GetMinimumRetryDelay( &delay ) );
    bcout << delay;
    if (!bRawReturn) bcout << L"\n";
}


void JobGetNoProgressTimeout( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    ULONG timeout;
    CheckBITSHR( L"Unable to get no progress timeout", Job->GetNoProgressTimeout( &timeout ) );
    bcout << timeout;
    if (!bRawReturn) bcout << L"\n";
}

void JobSetNoProgressTimeout( int argc, WCHAR **argv )
{
     JobValidateArgs( argc, argv, 2 );
     SmartJobPointer Job = JobLookup( argv[0] );
     ULONG NewTimeout = InputULONG( argv[1] );
     CheckBITSHR( L"Unable to set new no progress timeout", Job->SetNoProgressTimeout( NewTimeout ) );
     bcout << L"No progress timeout set to " << NewTimeout << L".\n";
}

void JobGetErrorCount( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    ULONG errors;
    CheckBITSHR( L"Unable to get no progress timeout", Job->GetErrorCount( &errors ) );
    bcout << errors;
    if (!bRawReturn) bcout << L"\n";
}

void JobInfo( SmartJobPointer Job )
{
     GUID id;
     BG_JOB_STATE    state;
     BG_JOB_PROGRESS progress;
     AutoStringPointer DisplayName;

     CheckBITSHR( L"Unable to get job ID",       Job->GetId( &id ));
     CheckBITSHR( L"Unable to get job state",    Job->GetState( &state ));
     CheckBITSHR( L"Unable to get job progress", Job->GetProgress( &progress ));
     CheckBITSHR( L"Unable to get display name", Job->GetDisplayName( DisplayName.GetRecvPointer() ) );

     bcout << id << L" " << DisplayName << L" " << state;
     bcout << L" " << progress.FilesTransferred << L" / " << progress.FilesTotal;
     bcout << L" " << progress.BytesTransferred << L" / ";
     if ( (UINT64)-1 == progress.BytesTotal )
         bcout << L"UNKNOWN";
     else
         bcout << progress.BytesTotal;
     bcout << L"\n";
}

void JobVerboseInfo( SmartJobPointer Job )
{
    GUID id;
    AutoStringPointer Display;
    BG_JOB_TYPE type;
    BG_JOB_STATE state;
    AutoStringPointer Owner;
    BG_JOB_PRIORITY priority;
    BG_JOB_PROGRESS progress;
    BG_JOB_TIMES times;
    SmartIUnknownPointer Notify;
    ULONG NotifyFlags;
    ULONG retrydelay;
    ULONG noprogresstimeout;
    ULONG ErrorCount;
    AutoStringPointer Description;
    SmartJobErrorPointer Error;
    BG_JOB_PROXY_USAGE ProxyUsage;
    AutoStringPointer ProxyList;
    AutoStringPointer ProxyBypassList;

    bool fShow15Fields;
    SmartJob2Pointer Job2;
    BG_JOB_REPLY_PROGRESS ReplyProgress;
    AutoStringPointer ReplyFileName;
    AutoStringPointer CmdLine;

    CheckBITSHR( L"Unable to get job ID",                    Job->GetId( &id) );
    CheckBITSHR( L"Unable to get job display name",          Job->GetDisplayName(Display.GetRecvPointer()) );
    CheckBITSHR( L"Unable to get job type",                  Job->GetType( &type ) );
    CheckBITSHR( L"Unable to get job state",                 Job->GetState( &state ) );
    CheckBITSHR( L"Unable to get job owner",                 Job->GetOwner( Owner.GetRecvPointer() ) );
    CheckBITSHR( L"Unable to get job priority",              Job->GetPriority( &priority ) );
    CheckBITSHR( L"Unable to get job progress",              Job->GetProgress( &progress ) );
    CheckBITSHR( L"Unable to get job times",                 Job->GetTimes( &times ) );
    bool NotifyAvailable = SUCCEEDED( Job->GetNotifyInterface( Notify.GetRecvPointer() ) );
    CheckBITSHR( L"Unable to get job notification flags",    Job->GetNotifyFlags( &NotifyFlags ) );
    CheckBITSHR( L"Unable to get job retry delay",           Job->GetMinimumRetryDelay( &retrydelay ) );
    CheckBITSHR( L"Unable to get job no progress timeout",   Job->GetNoProgressTimeout( &noprogresstimeout ) );
    CheckBITSHR( L"Unable to get job error count",           Job->GetErrorCount( &ErrorCount ) );
    CheckBITSHR( L"Unable to get job description",           Job->GetDescription( Description.GetRecvPointer() ) );
    CheckBITSHR( L"Unable to get proxy settings",            Job->GetProxySettings( &ProxyUsage,
                                                                                    ProxyList.GetRecvPointer(),
                                                                                    ProxyBypassList.GetRecvPointer() ) );

    if (FAILED(Job->GetError( Error.GetRecvPointer() )) )
        Error.Clear();

    if (SUCCEEDED(Job2FromJob( Job, Job2 )))
        {
        fShow15Fields = true;
        CheckBITSHR( L"unable to get notification command line", Job2->GetNotifyCmdLine( CmdLine.GetRecvPointer() ));

        if (type == BG_JOB_TYPE_UPLOAD_REPLY )
            {
            CheckBITSHR( L"unable to get reply progress",  Job2->GetReplyProgress( &ReplyProgress ));
            CheckBITSHR( L"unable to get reply file name", Job2->GetReplyFileName( ReplyFileName.GetRecvPointer() ));
            }
        }
    else
        {
        fShow15Fields = false;
        }

    // Example output
    // GUID: {F196178C-0C00-4E92-A8AD-1F44E30C2485} DISPLAY: Test Job
    // TYPE: DOWNLOAD STATE: SUSPENDED OWNER: ntdev\somedev
    // PRIORITY: NORMAL FILES: 0 / 0 BYTES: 0 / 0
    // CREATION TIME: 5:29:35 PM 11/9/2000 MODIFICATION TIME: 5:29:35 PM 11/9/2000
    // COMPLETION TIME: 5:29:35 PM 11/9/2000
    // NOTIFY INTERFACE: 00000000 NOTIFICATION FLAGS: 3
    // RETRY DELAY: 300 NO PROGRESS TIMEOUT: 1209600 ERROR COUNT: 0
    // PROXY USAGE: PRECONFIG PROXY LIST: NULL PROXY BYPASS LIST: NULL
    // [ error info ]
    // DESCRIPTION:
    // [ file list ]

    //
    // Additional output for BITS 1.5:
    // NOTIFICATION COMMAND LINE: NULL
    // REPLY FILE:  10 / 1000  'C:\foo\replyfile'
    //

    bcout << AddIntensity() << L"GUID: " << ResetIntensity() << id << AddIntensity() << L" DISPLAY: " << ResetIntensity() << Display << L"\n";

    bcout << AddIntensity() << L"TYPE: " << ResetIntensity() << type;
    bcout << AddIntensity() << L" STATE: " << ResetIntensity() << state;
    bcout << AddIntensity() << L" OWNER: " << ResetIntensity() << PrintSidString( Owner ) << L"\n";

    bcout << AddIntensity() << L"PRIORITY: " << ResetIntensity() << priority;
    bcout << AddIntensity() << L" FILES: " << ResetIntensity() << progress.FilesTransferred << L" / " << progress.FilesTotal;
    bcout << AddIntensity() << L" BYTES: " << ResetIntensity() << progress.BytesTransferred << L" / ";
    if ( (UINT64)-1 == progress.BytesTotal )
        bcout << L"UNKNOWN";
    else
        bcout << progress.BytesTotal;
    bcout << L"\n";

    bcout << AddIntensity() << L"CREATION TIME: " << ResetIntensity() << times.CreationTime;
    bcout << AddIntensity() << L" MODIFICATION TIME: " << ResetIntensity() << times.ModificationTime << L"\n";

    bcout << AddIntensity() << L"COMPLETION TIME: " << ResetIntensity() << times.TransferCompletionTime << L"\n";

    bcout << AddIntensity() << L"NOTIFY INTERFACE: " << ResetIntensity();

    if ( NotifyAvailable )
        {
        if ( Notify.Get() )
            bcout << L"REGISTERED";
        else
            bcout << L"UNREGISTERED";
        }
    else
        bcout << L"UNAVAILABLE";

    bcout << AddIntensity() << L" NOTIFICATION FLAGS: " << ResetIntensity() << NotifyFlags << L"\n";

    bcout << AddIntensity() << L"RETRY DELAY: " << ResetIntensity() << retrydelay;
    bcout << AddIntensity() << L" NO PROGRESS TIMEOUT: " << ResetIntensity() << noprogresstimeout;
    bcout << AddIntensity() << L" ERROR COUNT: " << ResetIntensity() << ErrorCount << L"\n";

    bcout << AddIntensity() << L"PROXY USAGE: " << ResetIntensity() << ProxyUsage;
    bcout << AddIntensity() << L" PROXY LIST: " << ResetIntensity() << ( (WCHAR*)ProxyList ? (WCHAR*)ProxyList : L"NULL" );
    bcout << AddIntensity() << L" PROXY BYPASS LIST: " << ResetIntensity() << ((WCHAR*)ProxyBypassList ? (WCHAR*)ProxyBypassList : L"NULL" );
    bcout << L"\n";

    if ( Error.Get() )
        bcout << Error;

    bcout << AddIntensity() << L"DESCRIPTION: " << ResetIntensity() << Description << L"\n";
    bcout << AddIntensity() << L"JOB FILES: \n" << ResetIntensity();
    JobListFiles( Job, true );

    if (fShow15Fields)
        {
        bcout << AddIntensity() << L"NOTIFICATION COMMAND LINE: " << ResetIntensity();

        if (wcslen( CmdLine ) > 0)
            {
            bcout << L"'" << CmdLine << L"'\n";
            }
        else
            {
            bcout << L"NULL\n";
            }

        if (type == BG_JOB_TYPE_UPLOAD_REPLY )
            {
            bcout << AddIntensity() << L"REPLY FILE: " << ResetIntensity() << ReplyProgress.BytesTransferred << L" / ";
            if ( (UINT64)-1 == ReplyProgress.BytesTotal )
                bcout << L"UNKNOWN";
            else
                bcout << ReplyProgress.BytesTotal;

            bcout << L"  '" << ReplyFileName << L"'\n";
            }
        }
}

void JobInfo( int argc, WCHAR **argv )
{
     if ( ( argc != 1 ) && (argc != 2 ) )
         {
         bcout << L"Invalid argument.\n";
         AppExit(1);
         }

     bool Verbose = false;
     if ( 2 == argc )
         {

         if ( !_wcsicmp( argv[1], L"/VERBOSE" ) )
             Verbose = true;
         else
             {
             bcout << L"Invalid argument.\n";
             AppExit(1);
             }

         }

     SmartJobPointer Job = JobLookup( argv[0] );

     if ( Verbose )
         JobVerboseInfo( Job );
     else
         JobInfo( Job );
}

size_t JobList( bool Verbose, bool AllUsers )
{
     DWORD dwFlags = 0;
     if ( AllUsers )
         dwFlags |= BG_JOB_ENUM_ALL_USERS;

     size_t JobsListed = 0;
     SmartEnumJobsPointer Enum;
     CheckBITSHR( L"Unable to enum jobs", g_Manager->EnumJobs( dwFlags, Enum.GetRecvPointer() ) );
     SmartJobPointer Job;
     while( Enum->Next( 1, Job.GetRecvPointer(), NULL ) == S_OK )
         {
         if ( Verbose )
             {
             JobVerboseInfo( Job );
             bcout << L"\n";
             }
         else
             JobInfo( Job );
         JobsListed++;
         }
     return JobsListed;
}

void JobList( int argc, WCHAR **argv )
{
     if ( argc > 2 )
         {
         bcout << L"Invalid number of arguments.\n";
         AppExit(1);
         }

     bool Verbose = false;
     bool AllUsers = false;

     for( int i = 0; i < argc; i++)
         {
         if ( !_wcsicmp( argv[i], L"/VERBOSE" ) )
             {
             Verbose = true;
             }
         else if ( !_wcsicmp( argv[i], L"/ALLUSERS" ) )
             {
             AllUsers = true;
             }
         else
             {
             bcout << L"Invalid argument.\n";
             AppExit(1);
             }
         }

     ConnectToBITS();
     size_t JobsListed = JobList( Verbose, AllUsers );

     if (!bRawReturn)
         bcout << L"Listed " << JobsListed << L" job(s).\n";
}

void JobMonitor( int argc, WCHAR**argv )
{
    DWORD dwSleepSeconds = 5;
    bool AllUsers = false;

    if ( argc > 3 )
        {
        bcout << L"Invalid number of arguments.\n";
        AppExit( 1 );
        }

    for( int i=0; i < argc; i++ )
        {
        if ( !_wcsicmp( argv[i], L"/ALLUSERS" ) )
            {
            AllUsers = true;
            }
        else if ( !_wcsicmp( argv[i], L"/REFRESH" ) )
            {
            i++;
            if ( i >= argc )
                {
                bcout << L"/REFRESH is missing the refresh rate.";
                AppExit(1);
                }
            dwSleepSeconds = InputULONG( argv[i] );
            }
        else
            {
            bcout << L"Invalid argument.\n";
            AppExit(1);
            }
        }

    if ( GetFileType( bcout.GetHandle() ) != FILE_TYPE_CHAR )
    {
        bcerr << L"/MONITOR will not work with a redirected stdout.\n";
        AppExit(1);
    }

    ConnectToBITS();

    for(;;)
    {
        ClearScreen();
        bcout << L"MONITORING BACKGROUND COPY MANAGER(" << dwSleepSeconds << L" second refresh)\n";
        JobList( false, AllUsers );
        SleepEx( dwSleepSeconds * 1000, TRUE );
        PollShutdown();
    }
}

void JobReset( int argc, WCHAR **argv )
{
    JobValidateArgs( argc, argv, 0 );
    ConnectToBITS();

    ULONG JobsFound = 0;
    ULONG JobsCanceled = 0;

    SmartEnumJobsPointer Enum;
    CheckBITSHR( L"Unable to enum jobs", g_Manager->EnumJobs( 0, Enum.GetRecvPointer() ) );
    SmartJobPointer Job;
    while( Enum->Next( 1, Job.GetRecvPointer(), NULL ) == S_OK )
        {
        JobsFound++;
        if (SUCCEEDED( Job->Cancel() ) )
            {
            bcout << Job << L" canceled.\n";
            JobsCanceled++;
            }
        }

    bcout << JobsCanceled << L" out of " << JobsFound << L" jobs canceled.\n";
}

void JobGetProxyUsage( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_PROXY_USAGE ProxyUsage;
    AutoStringPointer ProxyList;
    AutoStringPointer ProxyBypassList;
    CheckBITSHR( L"Unable to get proxy usage",
                 Job->GetProxySettings( &ProxyUsage, ProxyList.GetRecvPointer(), ProxyBypassList.GetRecvPointer() ) );
    bcout << ProxyUsage;
    if (!bRawReturn) bcout << L"\n";
}

void JobGetProxyList( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_PROXY_USAGE ProxyUsage;
    AutoStringPointer ProxyList;
    AutoStringPointer ProxyBypassList;
    CheckBITSHR( L"Unable to get proxy list",
                 Job->GetProxySettings( &ProxyUsage, ProxyList.GetRecvPointer(), ProxyBypassList.GetRecvPointer() ) );
    bcout << ( (WCHAR*)ProxyList ? (WCHAR*)ProxyList : L"NULL");
    if (!bRawReturn) bcout << L"\n";
}

void JobGetProxyBypassList( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    BG_JOB_PROXY_USAGE ProxyUsage;
    AutoStringPointer ProxyList;
    AutoStringPointer ProxyBypassList;
    CheckBITSHR( L"Unable to get proxy bypass list",
                 Job->GetProxySettings( &ProxyUsage, ProxyList.GetRecvPointer(), ProxyBypassList.GetRecvPointer() ) );
    bcout << ( (WCHAR*)ProxyBypassList ? (WCHAR*)ProxyBypassList : L"NULL");
    if (!bRawReturn) bcout << L"\n";
}

WCHAR *
FindMatching( WCHAR *pStr, WCHAR start, WCHAR finish, ULONG CurrentLevel )
{
    while( *pStr != L'\0' )
    {

        if ( start == *pStr )
            CurrentLevel++;
        else if ( finish == *pStr )
            CurrentLevel--;

        if ( !CurrentLevel )
            return pStr;

        pStr++;
    }

    return NULL;
}

void JobSetProxySettings( int argc, WCHAR **argv )
{

     JobValidateArgs( argc, argv, 2 );
     SmartJobPointer Job = JobLookup( argv[0] );

     WCHAR *pSettings = argv[1];
     // The format of the settings is usage,<ProxyList>,<ProxyBypassList>

     WCHAR *pEndUsage = wcsstr( pSettings, L"," );
     if ( !pEndUsage )
         pEndUsage = pSettings + wcslen( pSettings );

     size_t UsageSize = ((char*)pEndUsage - (char*)pSettings)/sizeof(WCHAR);
     AutoStringPointer Usage( new WCHAR[UsageSize + 1] );
     memcpy( Usage.Get(), pSettings, UsageSize * sizeof(WCHAR) );
     Usage.Get()[UsageSize] = L'\0';

     BG_JOB_PROXY_USAGE ProxyUsage;
     if ( _wcsicmp( Usage, L"PRECONFIG" ) == 0 )
         {
         ProxyUsage = BG_JOB_PROXY_USAGE_PRECONFIG;
         }
     else if ( _wcsicmp( Usage, L"NO_PROXY" ) == 0 )
         {
         ProxyUsage = BG_JOB_PROXY_USAGE_NO_PROXY;
         }
     else if ( _wcsicmp( Usage, L"OVERRIDE" ) == 0 )
         {
         ProxyUsage = BG_JOB_PROXY_USAGE_OVERRIDE;
         }
     else
         {
         bcout << L"Unknown proxy usage\n";
         AppExit(0);
         }

     if ( BG_JOB_PROXY_USAGE_PRECONFIG == ProxyUsage ||
          BG_JOB_PROXY_USAGE_NO_PROXY == ProxyUsage )
         {

         CheckBITSHR( L"Unable to set proxy settings", Job->SetProxySettings( ProxyUsage, NULL, NULL ) );
         bcout << L"Proxy usage set to " << ProxyUsage << L".\n";
         return;
         }

     if ( L',' != *pEndUsage )
         {
         bcout << L"Missing a , after the proxy usage setting";
         AppExit(1);
         }

     WCHAR *pProxyListStart = pEndUsage + 1; // skip ,
     if ( *pProxyListStart != L'<' )
         {
         bcout << L"Missing a < before the proxy list.\n";
         AppExit(0);
         }
     pProxyListStart++; // skip the <

     WCHAR *pEndProxyList = FindMatching( pProxyListStart, L'<', L'>', 1 );
     if ( !pEndProxyList )
         {
         bcout << L"Missing a matching > after the proxy list.\n";
         AppExit(0);
         }

     size_t ProxyListSize = ((char*)pEndProxyList - (char*)pProxyListStart)/sizeof(WCHAR);
     AutoStringPointer ProxyList( new WCHAR[ ProxyListSize + 1 ] );
     memcpy( ProxyList.Get(), pProxyListStart, ProxyListSize * sizeof(WCHAR) );
     ProxyList.Get()[ ProxyListSize ] = L'\0';

     WCHAR *pProxyBypassListStart = pEndProxyList + 1; // skip >
     if ( *pProxyBypassListStart != L',' )
         {
         bcout << L"Missing a , after the proxy list.\n";
         AppExit(0);
         }
     pProxyBypassListStart += 1; // skip the ,

     if ( *pProxyBypassListStart != L'<' )
         {
         bcout << L"Missing a < before the proxy bypass list.";
         AppExit(0);
         }
     pProxyBypassListStart += 1; // skip the <

     WCHAR *pEndProxyBypassList = FindMatching( pProxyBypassListStart, L'<', L'>', 1 );
     if ( !pEndProxyBypassList )
         {
         bcout << L"Missing a > after the proxy bypass list.";
         AppExit(0);
         }

     size_t ProxyBypassListSize = ((char*)pEndProxyBypassList - (char*)pProxyBypassListStart)/sizeof(WCHAR);
     AutoStringPointer ProxyBypassList( new WCHAR[ ProxyBypassListSize + 1 ] );
     memcpy( ProxyBypassList.Get(), pProxyBypassListStart, ProxyBypassListSize * sizeof(WCHAR) );
     ProxyBypassList.Get()[ ProxyBypassListSize ] = L'\0';

     if ( _wcsicmp( ProxyList, L"NULL" ) == 0 )
         {
         ProxyList.Clear();
         }

     if ( _wcsicmp( ProxyBypassList, L"NULL" ) == 0 )
         {
         ProxyBypassList.Clear();
         }

     CheckBITSHR( L"Unable to set proxy settings", Job->SetProxySettings( ProxyUsage, ProxyList, ProxyBypassList ) );
     bcout << L"Proxy usage set to " << ProxyUsage << L".\n";
     bcout << L"Proxy list set to " << ( (WCHAR*)ProxyList ? (WCHAR*)ProxyList : L"NULL" )<< L".\n";
     bcout << L"Proxy bypass list set to " << ( (WCHAR*)ProxyBypassList ? (WCHAR*)ProxyBypassList : L"NULL" ) << L".\n";
}

void JobTakeOwnership( int argc, WCHAR **argv )
{
    SmartJobPointer Job = JobLookupForNoArg( argc, argv );
    CheckBITSHR( L"Unable to take ownership", Job->TakeOwnership() );
    bcout << L"Took ownership of " << Job << L".\n";
}

void PrintBanner()
{
    const char ProductVer[] = VER_PRODUCTVERSION_STR;
    // double for extra protection
    wchar_t WProductVer[ sizeof(ProductVer) * 2];

    memset( WProductVer, 0, sizeof(WProductVer) );
    mbstowcs( WProductVer, ProductVer, sizeof(ProductVer) );

    bcout <<
        L"\n" <<
        L"BITSADMIN version 1.5 [ " << WProductVer << L" ]\n" <<
        L"BITS administration utility.\n" <<
        L"(C) Copyright 2000-2002 Microsoft Corp.\n" <<
        L"\n";

}

const wchar_t UsageLine[] = L"USAGE: BITSADMIN [/RAWRETURN] [/WRAP] command\n";

void JobHelp()
{
    bcout << UsageLine;
    bcout <<
        L"The following commands are available:\n"
        L"\n"
        L"/HELP                                    Prints this help \n"
        L"/?                                       Prints this help \n"
        L"/LIST [/ALLUSERS] [/VERBOSE]             List the jobs\n"
        L"/MONITOR [/ALLUSERS] [/REFRESH sec]      Monitors the copy manager\n"
        L"/RESET                                   Deletes all jobs in the manager\n"
        L"/CREATE display_name                     Create job\n"
        L"/INFO job [/VERBOSE]                     Display information about the job\n"
        L"/ADDFILE job remote_url local_name       Adds a file to the job\n"
        L"/LISTFILES job                           Lists the files in the job\n"
        L"/SUSPEND job                             Suspends the job\n"
        L"/RESUME job                              Resumes the job\n"
        L"/CANCEL job                              Cancels the job\n"
        L"/COMPLETE job                            Completes the job\n"
        L"\n"
        L"/GETTYPE job                             Retrieves the job type\n"
        L"/GETBYTESTOTAL job                       Retrieves the size of the job\n"
        L"/GETBYTESTRANSFERRED job                 Retrieves the number of bytes transferred\n"
        L"/GETFILESTOTAL job                       Retrieves the number of files in the job\n"
        L"/GETFILESTRANSFERRED job                 Retrieves the number of files transferred\n"
        L"/GETCREATIONTIME job                     Retrieves the job creation time\n"
        L"/GETMODIFICATIONTIME job                 Retrieves the job modification time\n"
        L"/GETCOMPLETIONTIME job                   Retrieves the job completion time\n"
        L"/GETSTATE job                            Retrieves the job state\n"
        L"/GETERROR job                            Retrieves detailed error information\n"
        L"/GETOWNER job                            Retrieves the job owner\n"
        L"/GETDISPLAYNAME job                      Retrieves the job display name.\n"
        L"/SETDISPLAYNAME job displayname          Sets the job display name.\n"
        L"/GETDESCRIPTION job                      Retrieves the job description\n"
        L"/SETDESCRIPTION job description          Sets the job description\n"
        L"/GETPRIORITY    job                      Retrieves the job priority\n"
        L"/SETPRIORITY    job priority             Sets the job priority\n"
        L"/GETNOTIFYFLAGS job                      Retrieves the notify flags\n"
        L"/SETNOTIFYFLAGS job notify_flags         Sets the notify flags\n"
        L"/GETNOTIFYINTERFACE job                  Determines if notify interface is registered\n"
        L"/GETMINRETRYDELAY job                    Retrieves the retry delay in seconds\n"
        L"/SETMINRETRYDELAY job retry_delay        Sets the retry delay in seconds\n"
        L"/GETNOPROGRESSTIMEOUT job                Retrieves the no progress timeout in seconds\n"
        L"/SETNOPROGRESSTIMEOUT job timeout        Sets the no progress timeout in seconds\n"
        L"/GETERRORCOUNT job                       Retrieves an error count for the job\n"
        L"/GETPROXYUSAGE job                       Retries the proxy usage setting\n"
        L"/GETPROXYLIST job                        Retries the proxy list\n"
        L"/GETPROXYBYPASSLIST job                  Retries the proxy bypass list\n"
        L"/SETPROXYSETTINGS job use,<List>,<Bypass>Sets the proxy Settings\n"
        L"/TAKEOWNERSHIP job                       Take ownership of the job\n"
        L"\n"
        L"/SETNOTIFYCMDLINE job connamd-line       Sets a command line for job notification\n"
        L"/GETNOTIFYCMDLINE job                    returns the job's notification command line\n"
        L"\n"
        L"/SetCredentials job {proxy|server} {basic|digest|ntlm|negotiate|passport} username password\n"
        L"                                         adds credentials to a job\n"
        L"/RemoveCredentials job {proxy|server} {basic|digest|ntlm|negotiate|passport} \n"
        L"                                         removes credentials from a job\n"
        L"\n"
        L"the following options are valid for UPLOAD-REPLY jobs only:\n"
        L"\n"
        L"/GETREPLYFILENAME job                    gets the name of the file containing the server reply\n"
        L"/SETREPLYFILENAME job filespec           sets the name of the file containing the server reply\n"
        L"/GETREPLYPROGRESS job                    gets the number of bytes and progress of the server reply\n"
        L"/GETREPLYDATA     job                    dumps the server's reply data in hex format\n"
        L"\n"
        L"The Following options can be placed before the command:\n"
        L"/RAWRETURN                               Return data more suitable for parsing\n"
        L"/WRAP                                    Wrap output around console\n"
        L"The /RAWRETURN option strips new line characters and formatting.\nIt is recognized by the "
        L"/CREATE and /GET* commands.\n"
        L"\n";
}

void JobHelpAdapter( int, WCHAR ** )
{
    JobHelp();
}

void JobNotImplemented( int, WCHAR ** )
{
    bcout << L"Not implemented.\n";
    AppExit(1);
}

const PARSEENTRY JobParseTableEntries[] =
{
    {L"/HELP",                  JobHelpAdapter },
    {L"/?",                     JobHelpAdapter },
    {L"/LIST",                  JobList },
    {L"/MONITOR",               JobMonitor },
    {L"/RESET",                 JobReset },
    {L"/CREATE",                JobCreate },
    {L"/INFO",                  JobInfo },
    {L"/ADDFILE",               JobAddFile },
    {L"/LISTFILES",             JobListFiles },
    {L"/SUSPEND",               JobSuspend },
    {L"/RESUME",                JobResume },
    {L"/CANCEL",                JobCancel },
    {L"/COMPLETE",              JobComplete },
    {L"/GETTYPE",               JobGetType },
    {L"/GETBYTESTOTAL",         JobGetBytesTotal },
    {L"/GETBYTESTRANSFERRED",   JobGetBytesTransferred },
    {L"/GETFILESTOTAL",         JobGetFilesTotal },
    {L"/GETFILESTRANSFERRED",   JobGetFilesTransferred },
    {L"/GETCREATIONTIME",       JobGetCreationTime },
    {L"/GETMODIFICATIONTIME",   JobGetModificationTime },
    {L"/GETCOMPLETIONTIME",     JobGetCompletionTime },
    {L"/GETSTATE",              JobGetState },
    {L"/GETERROR",              JobGetError },
    {L"/GETOWNER",              JobGetOwner },
    {L"/GETDISPLAYNAME",        JobGetDisplayName },
    {L"/SETDISPLAYNAME",        JobSetDisplayName },
    {L"/GETDESCRIPTION",        JobGetDescription },
    {L"/SETDESCRIPTION",        JobSetDescription },
    {L"/GETPRIORITY",           JobGetPriority },
    {L"/SETPRIORITY",           JobSetPriority },
    {L"/GETNOTIFYFLAGS",        JobGetNotifyFlags },
    {L"/SETNOTIFYFLAGS",        JobSetNotifyFlags },
    {L"/GETNOTIFYINTERFACE",    JobGetNotifyInterface },
    {L"/GETMINRETRYDELAY",      JobGetMinimumRetryDelay },
    {L"/SETMINRETRYDELAY",      JobSetMinimumRetryDelay },
    {L"/GETNOPROGRESSTIMEOUT",  JobGetNoProgressTimeout },
    {L"/SETNOPROGRESSTIMEOUT",  JobSetNoProgressTimeout },
    {L"/GETERRORCOUNT",         JobGetErrorCount },
    {L"/GETPROXYUSAGE",         JobGetProxyUsage },
    {L"/GETPROXYLIST",          JobGetProxyList },
    {L"/GETPROXYBYPASSLIST",    JobGetProxyBypassList },
    {L"/SETPROXYSETTINGS",      JobSetProxySettings },
    {L"/TAKEOWNERSHIP",         JobTakeOwnership },
    {L"/GETREPLYFILENAME",      JobGetReplyFileName },
    {L"/SETREPLYFILENAME",      JobSetReplyFileName },
    {L"/GETREPLYPROGRESS",      JobGetReplyProgress },
    {L"/GETREPLYDATA",          JobGetReplyData },
    {L"/GETNOTIFYCMDLINE",      JobGetNotifyCmdLine },
    {L"/SETNOTIFYCMDLINE",      JobSetNotifyCmdLine },
    {L"/SETCREDENTIALS",        JobSetCredentials },
    {L"/REMOVECREDENTIALS",     JobRemoveCredentials },
    {NULL,                      NULL }
};

const PARSETABLE JobParseTable =
{
    JobParseTableEntries,
    JobHelpAdapter,
    NULL
};

void ParseCmdAdapter( int argc, WCHAR **argv, void *pContext )
{
    ParseCmd( argc, argv, (const PARSETABLE *) pContext );
}

BOOL ControlHandler( DWORD Event )
{
    switch( Event )
        {
        case CTRL_C_EVENT:
        case CTRL_CLOSE_EVENT:
            SignalShutdown( 5000 );
            return TRUE;

        case CTRL_BREAK_EVENT:
            SignalShutdown( 500 );
            return TRUE;

        default:
            return FALSE;
        }
}

int _cdecl wmain(int argc, WCHAR **argv )
{

    DuplicateHandle(
        GetCurrentProcess(),    // handle to source process
        GetCurrentThread(),     // handle to duplicate
        GetCurrentProcess(),    // handle to target process
        &g_MainThreadHandle,    // duplicate handle
        0,                      // requested access
        TRUE,                   // handle inheritance option
        DUPLICATE_SAME_ACCESS   // optional actions
        );

    SetConsoleCtrlHandler( ControlHandler, TRUE );

    BITSADMINSetThreadUILanguage();

    _wsetlocale (LC_COLLATE, L".OCP" );    // sets the sort order
    _wsetlocale (LC_MONETARY, L".OCP" ); // sets the currency formatting rules
    _wsetlocale (LC_NUMERIC, L".OCP" );  // sets the formatting of numerals
    _wsetlocale (LC_TIME, L".OCP" );     // defines the date/time formatting

    // skip command name
    argc--;
    argv++;

    if ( 0 == argc )
        {

        PrintBanner();
        bcout << UsageLine;
        return 0;
        }

    // parse /RAWRETURN
    if ( argc >= 1 && ( _wcsicmp( argv[0], L"/RAWRETURN" ) ==  0 ))
        {
        bRawReturn = true;

        // skip /RAWRETURN
        argc--;
        argv++;
        }

    // parse /WRAP
    if ( argc >= 1 && ( _wcsicmp( argv[0], L"/WRAP" ) ==  0 ))
        {
        bWrap = true;

        // skip /WRAP
        argc--;
        argv++;
        }

    if ( !bRawReturn )
        PrintBanner();

#ifdef DBG

    // parse /COMPUTERNAME

    if ( argc >= 1 && ( _wcsicmp( argv[0], L"/COMPUTERNAME" ) == 0 ))
        {
        argc--;
        argv++;

        if (argc < 1)
            {
            bcout << L"/COMPUTERNAME option is missing the computer name.\n";
            AppExit(1);
            }

        pComputerName = argv[0];
        argc--;
        argv++;

        }
#endif



    CheckHR( L"Unable to initialize COM", CoInitializeEx(NULL, COINIT_MULTITHREADED ) );

    SetupConsole();
    ParseCmd( argc, argv, &JobParseTable );

    g_Manager.Clear();
    CoUninitialize();
    bcout.FlushBuffer();
    RestoreConsole();

    if ( g_MainThreadHandle )
        CloseHandle( g_MainThreadHandle );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\bits_ie\bits_ie.cpp ===
/************************************************************************

Copyright (c) Microsoft Corporation

Module Name :

    bits_ie.cpp

Abstract :

    Sample background downloader which uses BITS.

Revision History :

Notes:

    This program is a very simple background downloader which demonstrates
    the use of BITS. The program hooks into the IE context menu, to
    allow the user to schedule the download instead of using the default
    IE downloader.

Concepts Covered:

    1. Basic connection with manager and job submission.
    2. Example presentation to user of job state.
    3. Job control such as suspend/resume/cancel/complete.
    4. Interface based callbacks for updating progress/state.
    5. How to get the text message for a BITS error code.
    
 ***********************************************************************/

#ifndef UNICODE
#define UNICODE
#endif

#ifndef _UNICODE
#define _UNICODE
#endif

#pragma warning( disable : 4786 )

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <math.h>
#include <float.h>
#include <commctrl.h>
#include <commdlg.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <wininet.h>
#include <shlobj.h>
#include "resource.h"
#include <bits.h>
#include <comdef.h>


// Maxstring size, bump up on problems
#define MAX_STRING 0x800 // 2K

GUID g_JobId;
WCHAR g_szFileName[MAX_PATH];
HWND g_hwndDlg = NULL;

// These two global variables throttle updates.
// The algorithm is to set a timer on the first update request,
// and delay additional updates until after the timer expires.

// The timer is set
bool g_UpdateTimerSet = FALSE;
// Received on update request while timer is active
bool g_RefreshOnTimer = FALSE; 

IBackgroundCopyJob *g_pJob = NULL;
IBackgroundCopyManager *g_pManager = NULL;

HRESULT HandleUpdate( );

const WCHAR * GetString( UINT id )
{

    //
    // Retrieves the localized string for the resource id
    // caching the string when loaded.

    static const WCHAR* pStringArray[ IDS_MAX ];
    static WCHAR TempStringBuffer[ MAX_STRING ];
    const WCHAR * & pStringPointer = pStringArray[ id - 1 ];

    // Cache resource strings
    if ( pStringPointer )
        return pStringPointer;

    // Load string from resource

    int CharsLoaded =
        LoadStringW(
            (HINSTANCE)GetModuleHandle(NULL),
            id,
            TempStringBuffer,
            MAX_STRING );

    if ( !CharsLoaded )
        return L"";

    WCHAR *pNewString = new WCHAR[ CharsLoaded + 1];
    if ( !pNewString )
        return L"";

    wcscpy( pNewString, TempStringBuffer );
    return ( pStringPointer = pNewString );

}

void
DeleteStartupLink(
    GUID JobID
    )
{

    //
    // Delete the link in the Startup folder for the job
    //

    WCHAR szLinkFileName[MAX_PATH] = {0};
    WCHAR szGUIDString[MAX_PATH] = {0};

    BOOL bResult =
        SHGetSpecialFolderPath(
            NULL,
            szLinkFileName,
            CSIDL_STARTUP,
            FALSE );

    if ( !bResult )
        return;

    wcscat( szLinkFileName, L"\\" );
    wcscat( szLinkFileName, GetString( IDS_STARTUPLINK ) );
    wcscat( szLinkFileName, L" " );

    StringFromGUID2( JobID, szGUIDString, MAX_PATH );
    wcscat( szLinkFileName, szGUIDString );
    wcscat( szLinkFileName, L".lnk" );

    DeleteFile( szLinkFileName );

}

HRESULT
CreateStartupLink(
    GUID JobID,
    WCHAR *pszFileName
    )
{
    //
    // Create a link in the Startup folder for this job.
    //

    IShellLink*   pShellLink   = NULL;
    IPersistFile* pPersistFile = NULL;
    HRESULT hResult;
    LONG lCreateResult, lSetValueResult;
    WCHAR szLinkFileName[MAX_PATH] = {0};

    BOOL bResult =
        SHGetSpecialFolderPath(
            NULL,
            szLinkFileName,
            CSIDL_STARTUP,
            FALSE );

    if ( !bResult )
        return E_FAIL;

    WCHAR szLinkDescription[MAX_PATH] = {0};
    wcscpy( szLinkDescription, GetString( IDS_STARTUPLINK ) );
    wcscat( szLinkDescription, L" " );

    WCHAR szGUIDString[MAX_PATH] = {0};
    StringFromGUID2( JobID, szGUIDString, MAX_PATH );
    wcscat( szLinkDescription, szGUIDString );

    WCHAR szArguments[MAX_PATH] = {0};
    wcscpy( szArguments, L"/RESUMEJOB ");
    wcscat( szArguments, szGUIDString );
    wcscat( szArguments, L" " );
    wcscat( szArguments, pszFileName );

    wcscat( szLinkFileName, L"\\" );
    wcscat( szLinkFileName, szLinkDescription );
    wcscat( szLinkFileName, L".lnk" );

    hResult = CoCreateInstance( CLSID_ShellLink, NULL, CLSCTX_INPROC_SERVER,
        IID_IShellLink, (LPVOID*)&pShellLink);
    if ( FAILED( hResult ) ) goto EXIT;

    hResult = pShellLink->SetShowCmd( SW_SHOWMINIMIZED );
    if ( FAILED( hResult ) ) goto EXIT;

    hResult = pShellLink->QueryInterface( IID_IPersistFile, (LPVOID*)&pPersistFile );
    if ( FAILED( hResult ) ) goto EXIT;

    hResult = pShellLink->SetPath( L"%windir%\\system32\\bits_ie.exe" );
    if ( FAILED( hResult ) ) goto EXIT;

    hResult = pShellLink->SetArguments( szArguments );
    if ( FAILED( hResult ) ) goto EXIT;

    hResult = pShellLink->SetDescription( szLinkDescription );
    if ( FAILED( hResult ) ) goto EXIT;

    hResult = pPersistFile->Save( szLinkFileName, TRUE );

EXIT:
    if (pPersistFile) {
        pPersistFile->Release();
    }

    if (pShellLink) {
        pShellLink->Release();
    }

    return hResult;
}


void SetWindowTime(
    HWND hwnd,
    FILETIME filetime
    )
{
     // Set the window text to be the text representation
     // of the file time.
     // If an error occurs, set the window text to be error

     FILETIME localtime;
     FileTimeToLocalFileTime( &filetime, &localtime );

     SYSTEMTIME systemtime;
     FileTimeToSystemTime( &localtime, &systemtime );

     int RequiredDateSize =
         GetDateFormatW(
             LOCALE_USER_DEFAULT,
             0,
             &systemtime,
             NULL,
             NULL,
             0 );

     if ( !RequiredDateSize )
         {
         SetWindowText( hwnd, GetString( IDS_ERROR ) );
         return;
         }

     WCHAR *pszDateBuffer = (WCHAR*)alloca( sizeof(WCHAR) * (RequiredDateSize + 1) );

     int DateSize =
         GetDateFormatW(
             LOCALE_USER_DEFAULT,
             0,
             &systemtime,
             NULL,
             pszDateBuffer,
             RequiredDateSize );

     if (!DateSize)
         {
         SetWindowText( hwnd, GetString( IDS_ERROR ) );
         return;
         }

     int RequiredTimeSize =
         GetTimeFormatW(
             LOCALE_USER_DEFAULT,
             0,
             &systemtime,
             NULL,
             NULL,
             0 );

     if (!RequiredTimeSize)
         {
         SetWindowText( hwnd, GetString( IDS_ERROR ) );
         return;
         }

     WCHAR *pszTimeBuffer = (WCHAR*)alloca( sizeof( WCHAR ) * ( RequiredTimeSize + 1 ) );

     int TimeSize =
        GetTimeFormatW(
            LOCALE_USER_DEFAULT,
            0,
            &systemtime,
            NULL,
            pszTimeBuffer,
            RequiredTimeSize );

     if (!TimeSize)
         {
         SetWindowText( hwnd, GetString( IDS_ERROR ) );
         return;
         }

     // Add 2 for extra measure
     WCHAR *FullTime =
         (WCHAR*)alloca( sizeof( WCHAR ) *
                          ( RequiredTimeSize + RequiredDateSize + 2 ) );
     swprintf( FullTime, L"%s %s", pszDateBuffer, pszTimeBuffer );

     SetWindowText( hwnd, FullTime );
}

UINT64
GetSystemTimeAsUINT64()
{

    //
    // Returns the system time as an UINT instead of a FILETIME.
    //

    FILETIME filetime;
    GetSystemTimeAsFileTime( &filetime );

    ULARGE_INTEGER large;
    memcpy( &large, &filetime, sizeof(FILETIME) );

    return large.QuadPart;
}

void SignalAlert(
    HWND hwndDlg,
    UINT Type
    )
{

    //
    // Alert the user that an important event has occurred
    //

    FLASHWINFO FlashInfo;
    FlashInfo.cbSize    = sizeof(FlashInfo);
    FlashInfo.hwnd      = hwndDlg;
    FlashInfo.dwFlags   = FLASHW_ALL | FLASHW_TIMERNOFG;
    FlashInfo.uCount    = 0;
    FlashInfo.dwTimeout = 0;

    FlashWindowEx( &FlashInfo );
    MessageBeep( Type );

}

const WCHAR *
MapStateToString(
    BG_JOB_STATE state
    )
{

   //
   // Maps a BITS job state to a human readable string
   //

   switch( state )
       {

       case BG_JOB_STATE_QUEUED:
           return GetString( IDS_QUEUED );

       case BG_JOB_STATE_CONNECTING:
           return GetString( IDS_CONNECTING );

       case BG_JOB_STATE_TRANSFERRING:
           return GetString( IDS_TRANSFERRING );

       case BG_JOB_STATE_SUSPENDED:
           return GetString( IDS_SUSPENDED );

       case BG_JOB_STATE_ERROR:
           return GetString( IDS_FATALERROR );

       case BG_JOB_STATE_TRANSIENT_ERROR:
           return GetString( IDS_TRANSIENTERROR );

       case BG_JOB_STATE_TRANSFERRED:
           return GetString( IDS_TRANSFERRED );

       case BG_JOB_STATE_ACKNOWLEDGED:
           return GetString( IDS_ACKNOWLEDGED );

       case BG_JOB_STATE_CANCELLED:
           return GetString( IDS_CANCELLED );

       default:

           // NOTE: Always provide a default case
           // since new states may be added in future versions.
           return GetString( IDS_UNKNOWN );

       }
}

double
ScaleDownloadRate(
    double Rate, // rate in seconds
    const WCHAR **pFormat )
{

    //
    // Scales a download rate and selects the correct
    // format to pass to wprintf for printing.
    //

    double RateBounds[] =
    {
       1073741824.0, // Gigabyte
       1048576.0,    // Megabyte
       1024.0,       // Kilobyte
       0             // Byte
    };

    UINT RateFormat[] =
    {
        IDS_GIGAFORMAT,
        IDS_MEGAFORMAT,
        IDS_KILOFORMAT,
        IDS_BYTEFORMAT
    };

    for( unsigned int c = 0;; c++ )
        {
        if ( Rate >= RateBounds[c] )
            {
            *pFormat = GetString( RateFormat[c] );
            double scale = (RateBounds[c] >= 1.0) ? RateBounds[c] : 1.0;
            return Rate / scale;
            }
        }
}

UINT64
ScaleDownloadEstimate(
    double Time, // time in seconds
    const WCHAR **pFormat )
{

    //
    // Scales a download time estimate and selects the correct
    // format to pass to wprintf for printing.
    //


    double TimeBounds[] =
    {
       60.0 * 60.0 * 24.0,        // Days
       60.0 * 60.0,               // Hours
       60.0,                      // Minutes
       0.0                        // Seconds
    };

    UINT TimeFormat[] =
    {
        IDS_DAYSFORMAT,
        IDS_HOURSFORMAT,
        IDS_MINUTESFORMAT,
        IDS_SECONDSFORMAT
    };

    for( unsigned int c = 0;; c++ )
        {
        if ( Time >= TimeBounds[c] )
            {
            *pFormat = GetString( TimeFormat[c] );
            double scale = (TimeBounds[c] >= 1.0) ? TimeBounds[c] : 1.0;
            return (UINT64)floor( ( Time / scale ) + 0.5);
            }
        }

}

void
UpdateDialog(
    HWND hwndDlg
    )
{

   //
   // Main update routine for the dialog box.
   // Retries the job state/properties from
   // BITS and updates the dialog box.
   //

   {
   // update the display name

   HWND hwndDisplayName = GetDlgItem( hwndDlg, IDC_DISPLAYNAME );
   WCHAR * pszDisplayName = NULL;
   if (FAILED( g_pJob->GetDisplayName( &pszDisplayName ) ) ) 
       return; // stop updating on an error
   SetWindowText( hwndDisplayName, pszDisplayName );
   ShowWindow( hwndDisplayName, SW_SHOW );
   CoTaskMemFree( pszDisplayName );

   }

   static BG_JOB_STATE prevstate = BG_JOB_STATE_SUSPENDED;
   BG_JOB_STATE state;

   if (FAILED(g_pJob->GetState( &state )))
       return; // stop updating on an error

   if ( BG_JOB_STATE_ACKNOWLEDGED == state ||
        BG_JOB_STATE_CANCELLED == state )
       {
       // someone else cancelled or completed the job on us,
       // just exist the exit.
       // May happen if job is canceled with bitsadmin

       DeleteStartupLink( g_JobId );
       ExitProcess( 0 );
       }

   BG_JOB_PROGRESS progress;
   if (FAILED(g_pJob->GetProgress( &progress )))
       return; // stop updating on an error

   {
      // update the title, progress bar, and progress description
      WCHAR szProgress[MAX_STRING];
      WCHAR szTitle[MAX_STRING];
      WPARAM newpos = 0;

      if ( progress.BytesTotal &&
           ( progress.BytesTotal != BG_SIZE_UNKNOWN ) )
          {
          swprintf( szProgress, GetString( IDS_LONGPROGRESS ), progress.BytesTransferred,
                    progress.BytesTotal );

          double Percent = (double)(__int64)progress.BytesTransferred /
                           (double)(__int64)progress.BytesTotal;
          Percent *= 100.0;
          swprintf( szTitle, L"%u%% %s", (unsigned int)Percent, g_szFileName );
          newpos = (WPARAM)Percent;

          }
      else
          {
          swprintf( szProgress, GetString( IDS_SHORTPROGRESS ), progress.BytesTransferred );
          wcscpy( szTitle, g_szFileName );
          newpos = 0;
          }

      SendDlgItemMessage( hwndDlg, IDC_PROGRESSBAR, PBM_SETPOS, newpos, 0 );
      SetWindowText( GetDlgItem( hwndDlg, IDC_PROGRESSINFO ), szProgress );
      ShowWindow( GetDlgItem( hwndDlg, IDC_PROGRESSINFO ), SW_SHOW );
      EnableWindow( GetDlgItem( hwndDlg, IDC_PROGRESSINFOTXT ), TRUE );
      SetWindowText( hwndDlg, szTitle );

   }

   {
   // update the status
   HWND hwndStatus = GetDlgItem( hwndDlg, IDC_STATUS );

   SetWindowText( hwndStatus, MapStateToString( state ) );
   ShowWindow( hwndStatus, SW_SHOW );

   // Only enable the finish button if the job is finished.
   EnableWindow( GetDlgItem( hwndDlg, IDC_FINISH ), ( state == BG_JOB_STATE_TRANSFERRED ) );

   // Only enable the suspend button if the job is not finished or transferred
   BOOL EnableSuspend =
       ( state != BG_JOB_STATE_SUSPENDED ) && ( state != BG_JOB_STATE_TRANSFERRED );
   EnableWindow( GetDlgItem( hwndDlg, IDC_SUSPEND ), EnableSuspend );

   // Only enable the resume button if the job is suspended
   BOOL EnableResume = ( BG_JOB_STATE_SUSPENDED == state );
   EnableWindow( GetDlgItem( hwndDlg, IDC_RESUME ), EnableResume );

   // Alert the user when something important happens
   // such as the job completes or a unrecoverable error occurs
   if ( BG_JOB_STATE_TRANSFERRED == state &&
        BG_JOB_STATE_TRANSFERRED != prevstate )
       SignalAlert( hwndDlg, MB_OK );

   else if ( BG_JOB_STATE_ERROR == state &&
        BG_JOB_STATE_ERROR != prevstate )
       SignalAlert( hwndDlg, MB_ICONEXCLAMATION );

   }

   {
   // update times
   BG_JOB_TIMES times;
   if (FAILED(g_pJob->GetTimes( &times )))
       return;

   HWND hwndCreationTime = GetDlgItem( hwndDlg, IDC_STARTTIME );
   SetWindowTime( hwndCreationTime, times.CreationTime );
   ShowWindow( hwndCreationTime, SW_SHOW );

   HWND hwndModificationTime = GetDlgItem( hwndDlg, IDC_MODIFICATIONTIME );
   SetWindowTime( hwndModificationTime, times.ModificationTime );
   ShowWindow( hwndModificationTime, SW_SHOW );

   HWND hwndCompletionTime = GetDlgItem( hwndDlg, IDC_COMPLETIONTIME );
   if ( !times.TransferCompletionTime.dwLowDateTime && !times.TransferCompletionTime.dwHighDateTime )
       {

       // BITS sets the CompletionTime to all zeros
       // if the job is incomplete

       ShowWindow( hwndCompletionTime, SW_HIDE );
       EnableWindow( GetDlgItem( hwndDlg, IDC_COMPLETIONTIMETXT ), FALSE );
       }
   else
       {
       SetWindowTime( hwndCompletionTime, times.TransferCompletionTime );
       ShowWindow( hwndCompletionTime, SW_SHOW );
       EnableWindow( GetDlgItem( hwndDlg, IDC_COMPLETIONTIMETXT ), TRUE );
       }
   }

   {
   // update the error message
   IBackgroundCopyError *pError;
   HRESULT Hr = g_pJob->GetError( &pError );

   if ( FAILED(Hr) )
       {
       ShowWindow( GetDlgItem( hwndDlg, IDC_ERRORMSG ), SW_HIDE );
       EnableWindow( GetDlgItem( hwndDlg, IDC_ERRORMSGTXT ), FALSE );
       }
   else
       {

       WCHAR* pszDescription = NULL;
       WCHAR* pszContext = NULL;
       SIZE_T SizeRequired = 0;

       // If these APIs fail, we should get back
       // a NULL string. So everything should be harmless.

       pError->GetErrorDescription(
           LANGIDFROMLCID( GetThreadLocale() ),
           &pszDescription );
       pError->GetErrorContextDescription(
           LANGIDFROMLCID( GetThreadLocale() ),
           &pszContext );

       if ( pszDescription )
           SizeRequired += wcslen( pszDescription );
       if ( pszContext )
           SizeRequired += wcslen( pszContext );

       WCHAR* pszFullText = (WCHAR*)_alloca((SizeRequired + 1) * sizeof(WCHAR));
       *pszFullText = L'\0';

       if ( pszDescription )
           wcscpy( pszFullText, pszDescription );
       if ( pszContext )
           wcscat( pszFullText, pszContext );
       CoTaskMemFree( pszDescription );
       CoTaskMemFree( pszContext );

       HWND hwndErrorText = GetDlgItem( hwndDlg, IDC_ERRORMSG );
       SetWindowText( hwndErrorText, pszFullText );
       ShowWindow( hwndErrorText, SW_SHOW );
       EnableWindow( GetDlgItem( hwndDlg, IDC_ERRORMSGTXT ), TRUE );

       }

   }

   if (!SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_GETDROPPEDSTATE, 0, 0) )
       {
       // set the priority, but only do it if user isn't trying to
       // set the priority.
       BG_JOB_PRIORITY priority;
       g_pJob->GetPriority( &priority );
       SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_SETCURSEL, (WPARAM)priority, 0 );
       }

   {

   //
   // This large block of text computes the average transfer rate
   // and estimated completion time.  This code has much
   // room for improvement.
   //

   static BOOL HasRates = FALSE;
   static UINT64 LastMeasurementTime;
   static UINT64 LastMeasurementBytes;
   static double LastMeasurementRate;

   WCHAR szRateText[MAX_STRING];
   BOOL EnableRate = FALSE;

   if ( !( BG_JOB_STATE_QUEUED == state ) &&
        !( BG_JOB_STATE_CONNECTING == state ) &&
        !( BG_JOB_STATE_TRANSFERRING == state ) )
       {
       // If the job isn't running, then rate values won't
       // make any sense. Don't display them.
       HasRates = FALSE;
       }
   else
       {

       if ( !HasRates )
           {
           LastMeasurementTime = GetSystemTimeAsUINT64();
           LastMeasurementBytes = progress.BytesTransferred;
           LastMeasurementRate = 0;
           HasRates = TRUE;
           }
       else
           {

           UINT64 CurrentTime = GetSystemTimeAsUINT64();
           UINT64 NewTotalBytes = progress.BytesTransferred;

           UINT64 NewTimeDiff = CurrentTime - LastMeasurementTime;
           UINT64 NewBytesDiff = NewTotalBytes - LastMeasurementBytes;
           double NewInstantRate = (double)(__int64)NewBytesDiff /
                                   (double)(__int64)NewTimeDiff;
           double NewAvgRate = (0.3 * LastMeasurementRate) +
                               (0.7 * NewInstantRate );

           if ( !_finite(NewInstantRate) || !_finite(NewAvgRate) )
               {
               NewInstantRate = 0;
               NewAvgRate = LastMeasurementRate;
               }

           LastMeasurementTime = CurrentTime;
           LastMeasurementBytes = NewTotalBytes;
           LastMeasurementRate = NewAvgRate;

           // convert from FILETIME units to seconds
           double NewDisplayRate = NewAvgRate * 10000000;

           const WCHAR *pRateFormat = NULL;
           double ScaledRate = ScaleDownloadRate( NewDisplayRate, &pRateFormat );
           swprintf( szRateText, pRateFormat, ScaledRate );
           
           EnableRate = TRUE;
           }

       }

   if (!EnableRate)
       {
       ShowWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATE ), SW_HIDE );
       EnableWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATETXT ), FALSE );
       }
   else
       {
       SetWindowText( GetDlgItem( hwndDlg, IDC_TRANSFERRATE ), szRateText );
       ShowWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATE ), SW_SHOW );
       EnableWindow( GetDlgItem( hwndDlg, IDC_TRANSFERRATETXT ), TRUE );
       }

   BOOL EnableEstimate = FALSE;
   WCHAR szEstimateText[MAX_STRING];

   if ( EnableRate )
       {

       if ( progress.BytesTotal != 0 &&
            progress.BytesTotal != BG_SIZE_UNKNOWN )
           {

           double TimeRemaining =
               ( (__int64)progress.BytesTotal - (__int64)LastMeasurementBytes ) / LastMeasurementRate;

           // convert from FILETIME units to seconds
           TimeRemaining = TimeRemaining / 10000000.0;

           static const double SecsPer30Days = 60.0 * 60.0 * 24.0 * 30.0;

           // Don't estimate if estimate is larger then 30 days.
           if ( TimeRemaining < SecsPer30Days )
               {

               const WCHAR *pFormat = NULL;
               UINT64 Time = ScaleDownloadEstimate( TimeRemaining, &pFormat );
               swprintf( szEstimateText, pFormat, Time );
               EnableEstimate = TRUE;
               }
           }
       }

   if (!EnableEstimate)
       {
       ShowWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIME ), SW_HIDE );
       EnableWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIMETXT ), FALSE );
       }
   else
       {
       SetWindowText( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIME ), szEstimateText );
       ShowWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIME ), SW_SHOW );
       EnableWindow( GetDlgItem( hwndDlg, IDC_ESTIMATEDTIMETXT ), TRUE );
       }

   }

   prevstate = state;
}

void
InitDialog(
    HWND hwndDlg
    )
{

   //
   // Populate the priority list with priority descriptions
   //

   const WCHAR *Foreground    = GetString( IDS_FOREGROUND );
   const WCHAR *High          = GetString( IDS_HIGH );
   const WCHAR *Normal        = GetString( IDS_NORMAL );
   const WCHAR *Low           = GetString( IDS_LOW );

   SendDlgItemMessage( hwndDlg, IDC_PROGRESSBAR, PBM_SETRANGE, 0, MAKELPARAM(0, 100) );
   SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_ADDSTRING, 0, (LPARAM)Foreground );
   SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_ADDSTRING, 0, (LPARAM)High );
   SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_ADDSTRING, 0, (LPARAM)Normal );
   SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_ADDSTRING, 0, (LPARAM)Low );

}

void CheckHR( HWND hwnd, HRESULT Hr, bool bThrow )
{
    //
    // Provides automatic error code checking and dialog
    // for generic system errors
    //

    if (SUCCEEDED(Hr))
        return;

    WCHAR * pszError = NULL;

    DWORD dwFormatError =
    FormatMessage(
        FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | 
        FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL,
        (DWORD)Hr,
        LANGIDFROMLCID( GetThreadLocale() ),
        (WCHAR*)&pszError,
        0,
        NULL );

    if ( !dwFormatError ) 
       {
       WCHAR ErrorMsg[ MAX_STRING ];
       swprintf( ErrorMsg, GetString( IDS_DISPLAYERRORCODE ), Hr );
       
       MessageBox( hwnd, ErrorMsg, GetString( IDS_ERRORBOXTITLE ),
                   MB_OK | MB_ICONSTOP | MB_APPLMODAL );
       }
    else
       {
       MessageBox( hwnd, pszError, GetString( IDS_ERRORBOXTITLE ),
                   MB_OK | MB_ICONSTOP | MB_APPLMODAL );
       LocalFree( pszError );
       }

    if ( bThrow )
        throw _com_error( Hr );

}

void BITSCheckHR( HWND hwnd, HRESULT Hr, bool bThrow )
{

   //
   // Provides automatic error code checking and dialog
   // for BITS specific errors
   //


   if (SUCCEEDED(Hr))
       return;

   WCHAR * pszError = NULL;
   HRESULT hErrorHr = 
   g_pManager->GetErrorDescription(
       Hr,
       LANGIDFROMLCID( GetThreadLocale() ),
       &pszError );

   if ( FAILED(hErrorHr) || !pszError )
       {

       WCHAR ErrorMsg[ MAX_STRING ];
       swprintf( ErrorMsg, GetString( IDS_DISPLAYERRORCODE ), Hr );

       MessageBox( hwnd, ErrorMsg, GetString( IDS_ERRORBOXTITLE ),
                   MB_OK | MB_ICONSTOP | MB_APPLMODAL );

       }

   else
       {
      
       MessageBox( hwnd, pszError, GetString( IDS_ERRORBOXTITLE ),
                   MB_OK | MB_ICONSTOP | MB_APPLMODAL );
       CoTaskMemFree( pszError );

       }


   if ( bThrow )
       throw _com_error( Hr );
}

void
DoCancel(
    HWND hwndDlg,
    bool PromptUser
    )
{

   //
   // Handle all the operations required to cancel the job.
   // This includes asking the user for confirmation.
   //

   if ( PromptUser )
       {

       int Result =
           MessageBox(
               hwndDlg,
               GetString( IDS_CANCELTEXT ),
               GetString( IDS_CANCELCAPTION ),
               MB_YESNO | MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL |
               MB_SETFOREGROUND | MB_TOPMOST );


       if ( IDYES != Result )
           return;

       }

   try
   {
       BITSCheckHR( hwndDlg, g_pJob->Cancel(), true );
   }
   catch( _com_error Error )
   {
       // If we can't cancel for some unknown reason,
       // don't exit
       return;
   }

   DeleteStartupLink( g_JobId );
   ExitProcess( 0 );
}

void
DoFinish(
    HWND hwndDlg
    )
{

   //
   // Handles all the necessary work to complete
   // the download.
   //

   try
   {
       BITSCheckHR( hwndDlg, g_pJob->Complete(), true );
   }
   catch( _com_error Error )
   {
       // If we can't finish/complete for some unknown reason,
       // don't exit
       return;
   }

   DeleteStartupLink( g_JobId );
   ExitProcess( 0 );

}

void
DoClose(
    HWND hwndDlg
    )
{
    //
    // Handles an attempt by the user to close the sample.
    //

    // Check to see if the download has finished,
    // if so don't let the user exit.

    BG_JOB_STATE state;
    HRESULT hResult = g_pJob->GetState( &state );

    if (FAILED( hResult ))
        {
        BITSCheckHR( hwndDlg, hResult, false );
        return;
        }

    if ( BG_JOB_STATE_ERROR == state ||
         BG_JOB_STATE_TRANSFERRED == state )
        {

        MessageBox(
            hwndDlg,
            GetString( IDS_ALREADYFINISHED ),
            GetString( IDS_ALREADYFINISHEDCAPTION ),
            MB_OK | MB_ICONERROR | MB_DEFBUTTON1 | MB_APPLMODAL |
            MB_SETFOREGROUND | MB_TOPMOST );


        return;
        }


    //
    // Inform the user that he selected close and ask
    // confirm the intention to exit.  Explain that the job 
    // will be canceled.

    int Result =
        MessageBox(
            hwndDlg,
            GetString( IDS_CLOSETEXT ),
            GetString( IDS_CLOSECAPTION ),
            MB_OKCANCEL | MB_ICONWARNING | MB_DEFBUTTON2 | MB_APPLMODAL |
            MB_SETFOREGROUND | MB_TOPMOST );

    if ( IDOK == Result )
        {
        
        // User confirmed the cancel, just do it.

        DoCancel( hwndDlg, false );
        return;
        }

    // The user didn't really want to exit, so ignore him
    else
        return;

}

void
HandleTimerTick( HWND hwndDlg )
{

    //
    // Handle the throttling timer event 
    // and update the dialog if needed
    //

    if ( g_RefreshOnTimer )
        {
        // The timer fired, handle all updates at once.
        UpdateDialog( hwndDlg );
        g_RefreshOnTimer = FALSE;
        }
    else
        {
        // The timer expired with an additional modification
        // notification.  Just kill the timer.
        KillTimer( hwndDlg, 0 );
        g_RefreshOnTimer = g_UpdateTimerSet = FALSE;
        }

}

HRESULT
HandleUpdate()
{

    //
    // Handle a update request, batching the update if needed
    //

    if ( !g_UpdateTimerSet )
        {
        // We aren't currently batching updates,
        // so do this one update but prevent
        // further updates until the timer expires.
        SetTimer( g_hwndDlg, 0, 1000, NULL );
        g_UpdateTimerSet = TRUE;
        UpdateDialog( g_hwndDlg );
        }
    else
        {
        // We've started batching and yet received
        // another update request.  Delay this
        // update until the timer fires.
        g_RefreshOnTimer = TRUE;
        }
    return S_OK;

}

INT_PTR CALLBACK
DialogProc(
  HWND hwndDlg,  // handle to dialog box
  UINT uMsg,     // message
  WPARAM wParam, // first message parameter
  LPARAM lParam  // second message parameter
  )
{

  //
  // Dialog proc for main dialog window
  //

  switch( uMsg )
      {

      case WM_INITDIALOG:
          g_hwndDlg = hwndDlg;
          InitDialog( hwndDlg );
          return TRUE;

      case WM_TIMER:
          HandleTimerTick( hwndDlg );
          return TRUE;

      case WM_CLOSE:
          DoClose( hwndDlg );
          return TRUE;

      case WM_COMMAND:

          switch( LOWORD( wParam ) )
              {

              case IDC_RESUME:
                  BITSCheckHR( hwndDlg, g_pJob->Resume(), false );
                  return TRUE;

              case IDC_SUSPEND:
                  BITSCheckHR( hwndDlg, g_pJob->Suspend(), false );
                  return TRUE;

              case IDC_CANCEL:
                  DoCancel( hwndDlg, true );
                  return TRUE;

              case IDC_FINISH:
                  DoFinish( hwndDlg );
                  return TRUE;

              case IDC_PRIORITY:
                  switch( HIWORD( wParam ) )
                      {

                      case CBN_SELENDOK:

                          // User clicked on priority,
                          // update it.

                          BITSCheckHR( hwndDlg,
                              g_pJob->SetPriority( (BG_JOB_PRIORITY)
                                  SendDlgItemMessage( hwndDlg, IDC_PRIORITY, CB_GETCURSEL, 0, 0 ) ), false );
                          return TRUE;

                      case CBN_SELENDCANCEL:
                          return TRUE;

                      default:
                          return FALSE;
                      }

              default:
                  return FALSE;
              }
      default:
          return FALSE;
      }
}

HRESULT
HandleCOMCallback(
    IBackgroundCopyJob* pJob,
    bool CriticalEvent
    );

class CBackgroundCopyCallback : public IBackgroundCopyCallback
{

    //
    // Callback class.   Used for change notifications.
    //

public:
    virtual HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void **ppvObject)
    {

        if ( riid == _uuidof(IUnknown) )
            {
            *ppvObject = (IUnknown*)(IBackgroundCopyCallback*)this;
            return S_OK;
            }

        else if ( riid == _uuidof(IBackgroundCopyCallback) )
            {
            *ppvObject = (IBackgroundCopyCallback*)this;
            return S_OK;
            }

        else
            return E_NOINTERFACE;

    }

    virtual HRESULT STDMETHODCALLTYPE CreateInstance(
        IUnknown *pUnkOuter,
        REFIID riid,
        void **ppvObject )
    {

        if ( pUnkOuter )
            return CLASS_E_NOAGGREGATION;

        return QueryInterface( riid, ppvObject );

    }

    // We are cheating on COM here, but we
    // are forcing the lifetime of the callback object
    // to be the same of the lifetime of the exe.

    virtual ULONG STDMETHODCALLTYPE AddRef(void)
    {
        return 0;
    }
    virtual ULONG STDMETHODCALLTYPE Release(void)
    {
        return 0;
    }

    virtual HRESULT STDMETHODCALLTYPE JobTransferred(IBackgroundCopyJob *pJob)
    {
        return HandleCOMCallback( pJob, true );
    }

    virtual HRESULT STDMETHODCALLTYPE JobError(IBackgroundCopyJob *pJob, IBackgroundCopyError *pError)
    {
        return HandleCOMCallback( pJob, true );
    }

    virtual HRESULT STDMETHODCALLTYPE JobModification( IBackgroundCopyJob *pJob, DWORD dwReserved )
    {
        return HandleCOMCallback( pJob, true );
    }
} g_Callback;

HRESULT
HandleCOMCallback(
    IBackgroundCopyJob* pJob,
    bool CriticalEvent
    )
{

    // In addition to the work of HandleUpdate,
    // this function checks to see if we've
    // already initialized the manager.  If not,
    // do it now.

    if ( !g_pManager )
        {

        try
        {
            CheckHR( NULL,
                     CoCreateInstance( CLSID_BackgroundCopyManager,
                         NULL,
                         CLSCTX_LOCAL_SERVER,
                         IID_IBackgroundCopyManager,
                         (void**)&g_pManager ), true );

            pJob->AddRef();
            g_pJob = pJob;

            BITSCheckHR( NULL, g_pJob->SetNotifyFlags( BG_NOTIFY_JOB_MODIFICATION ), true );

            // As an optimization, set the notification interface to be the callback
            // It shouldn't matter if this fails
            g_pJob->SetNotifyInterface( (IBackgroundCopyCallback*)&g_Callback );

            HRESULT Hr = HandleUpdate();

            ShowWindow( g_hwndDlg, CriticalEvent ? SW_NORMAL : SW_MINIMIZE );

        }
        catch(_com_error error )
        {
            if ( g_pManager )
                g_pManager->Release();
            g_pManager = NULL;

            if ( g_pJob )
                g_pJob->Release();
            g_pJob = NULL;

            return error.Error();
        }

        }

    return HandleUpdate();
}

HRESULT
CreateUI( int nShowCmd )
{

    //
    // Creates the dialog box for the sample.
    //

    g_hwndDlg =
      CreateDialog(
         (HINSTANCE)GetModuleHandle(NULL),
         MAKEINTRESOURCE( IDD_DIALOG ),
         GetDesktopWindow(),
         DialogProc );

    if ( !g_hwndDlg )
        return HRESULT_FROM_WIN32(GetLastError());

    ShowWindow( g_hwndDlg, nShowCmd );

    return S_OK;
}

void CreateJob(
    WCHAR* szJobURL
    )
{
    //
    // Request a destination file name from the user
    // and submit a new job.
    //

    try
    {

        // crack the URL and get the filename
        WCHAR szURLFilePath[MAX_PATH] = {L'\0'};
        URL_COMPONENTS UrlComponents;

        memset( &UrlComponents, 0, sizeof(UrlComponents) );
        UrlComponents.dwStructSize = sizeof(URL_COMPONENTS);
        UrlComponents.lpszUrlPath = szURLFilePath;
        UrlComponents.dwUrlPathLength =
            sizeof(szURLFilePath)/sizeof(*szURLFilePath);

        BOOL CrackResult =
            InternetCrackUrl(
                szJobURL,
                0,
                0,
                &UrlComponents );

        if (!CrackResult)
            CheckHR( NULL, HRESULT_FROM_WIN32( GetLastError() ), false );

        if ( UrlComponents.nScheme != INTERNET_SCHEME_HTTP &&
             UrlComponents.nScheme != INTERNET_SCHEME_HTTPS
             )
            {

            MessageBox(
                NULL,
                GetString( IDS_NOHTTPORHTTPS ),
                GetString( IDS_ERRORBOXTITLE ),
                MB_OK | MB_ICONERROR | MB_APPLMODAL |
                MB_SETFOREGROUND | MB_TOPMOST );


            throw _com_error( E_INVALIDARG );

            }

        const WCHAR *szURLFileName =
            szURLFilePath + wcslen( szURLFilePath );

        // parse out the filename part of the URL
        while( szURLFileName != szURLFilePath )
            {

            if ( L'/' == *szURLFileName ||
                 L'\\' == *szURLFileName )
                {
                szURLFileName++;
                break;
                }

            szURLFileName--;
            }
       
		// This is needed in case the first
		// character is a slash.
        if ( L'/' == *szURLFileName ||
			 L'\\' == *szURLFileName )
			 szURLFileName++;

        // parse out the extension from the name
        const WCHAR *szURLFileExtension =
            szURLFileName + wcslen( szURLFileName );

        while( szURLFileName != szURLFileExtension )
            {
            if ( L'.' == *szURLFileExtension )
                break;
            szURLFileExtension--;
            }

        // build the extension list

        WCHAR *szExtensionList = NULL;
        const WCHAR *szAllFiles = GetString( IDS_ALLFILES );
        const size_t AllFilesSize = wcslen( szAllFiles ) + 1;
        const WCHAR *szAllFilesPattern = L"*";
        const size_t AllFilesPatternSize = sizeof(L"*")/sizeof(WCHAR);

        WCHAR *p;

        if ( szURLFileExtension == szURLFileName &&
             *szURLFileExtension != L'.' )
            {
            size_t StringSize = sizeof(WCHAR) * ( AllFilesSize + AllFilesPatternSize + 2 );
            szExtensionList = (WCHAR*)_alloca( StringSize );
            p = szExtensionList;
            }
        else
            {
            size_t ExtensionSize = wcslen( szURLFileExtension ) + 1;
            size_t StringSize =
                sizeof(WCHAR) * ( ExtensionSize + ExtensionSize + 1 + AllFilesSize
                                  + AllFilesPatternSize + 2 );
            szExtensionList = (WCHAR*)_alloca( StringSize );
            p = szExtensionList;

            memcpy( p, szURLFileExtension, ExtensionSize * sizeof(WCHAR) );
            p += ExtensionSize;
            *p++ = L'*';
            memcpy( p, szURLFileExtension, ExtensionSize * sizeof(WCHAR) );
            p += ExtensionSize;
            }

        memcpy( p, szAllFiles, AllFilesSize * sizeof(WCHAR) );
        p += AllFilesSize;
        memcpy( p, szAllFilesPattern, AllFilesPatternSize * sizeof(WCHAR) );
        p += AllFilesPatternSize;
        memset( p, 0, sizeof(WCHAR) * 2 );


        OPENFILENAME ofn;
        memset( &ofn, 0, sizeof( ofn ) );

        WCHAR szFileName[MAX_PATH];
        WCHAR szFileTitle[MAX_PATH];

        wcscpy(szFileName, szURLFileName);
        wcscpy(szFileTitle, szURLFileName);

        /* fill in non-variant fields of OPENFILENAME struct. */
        ofn.lStructSize       = sizeof(OPENFILENAME);
        ofn.hwndOwner         = g_hwndDlg;
        ofn.lpstrFilter       = szExtensionList;
        ofn.lpstrCustomFilter = NULL;
        ofn.nMaxCustFilter    = 0;
        ofn.nFilterIndex      = 0;
        ofn.lpstrFile         = szFileName;
        ofn.nMaxFile          = MAX_PATH;
        ofn.lpstrInitialDir   = NULL;
        ofn.lpstrFileTitle    = szFileTitle;
        ofn.nMaxFileTitle     = MAX_PATH;
        ofn.lpstrTitle        = GetString( IDS_FILEDLGTITLE );
        ofn.lpstrDefExt       = NULL;
        ofn.Flags             = 0;

        /* Use standard open dialog */
        BOOL bResult = GetSaveFileName ((LPOPENFILENAME)&ofn);

        if ( !bResult )
            {
            if ( !CommDlgExtendedError() )
                {
                // user canceled the box
                ExitProcess( 0 );
                }
            else
                CheckHR( NULL, HRESULT_FROM_WIN32( GetLastError() ), true );
            }


        wcscpy( g_szFileName, szFileTitle );

        CheckHR( NULL,
                 CoCreateInstance( CLSID_BackgroundCopyManager,
                     NULL,
                     CLSCTX_LOCAL_SERVER,
                     IID_IBackgroundCopyManager,
                     (void**)&g_pManager ), true );

        GUID guid;
        BITSCheckHR( NULL,
            g_pManager->CreateJob( szJobURL,
                                 BG_JOB_TYPE_DOWNLOAD,
                                 &guid,
                                 &g_pJob ),
                        true );

        memset( &g_JobId, 0, sizeof(GUID) );
        BITSCheckHR( NULL, g_pJob->GetId( &g_JobId ), true );
        BITSCheckHR( NULL, g_pJob->AddFile( szJobURL, szFileName ), true );

        CheckHR( NULL, CreateStartupLink( g_JobId, g_szFileName ), true );

        IBackgroundCopyCallback *pCallback = new CBackgroundCopyCallback();
        BITSCheckHR( NULL, g_pJob->SetNotifyFlags( BG_NOTIFY_JOB_MODIFICATION ), true );

        BITSCheckHR( NULL,
                     g_pJob->SetNotifyInterface( (IBackgroundCopyCallback*)&g_Callback ),
                     true );
        BITSCheckHR( NULL, g_pJob->Resume(), true );

        HandleUpdate();

    }
    catch(_com_error error )
    {
        if ( g_pJob )
            {
            g_pJob->Cancel();
            DeleteStartupLink( g_JobId );
            }

        ExitProcess( error.Error() );
    }

}

void ResumeJob(
    WCHAR* szJobGUID,
    WCHAR* szJobFileName
    )
{

    //
    // Resume the display on an existing job
    //

    try
    {
        wcscpy( g_szFileName, szJobFileName );
        CheckHR( NULL, IIDFromString( szJobGUID, &g_JobId ), true );

        CheckHR( NULL,
                 CoCreateInstance( CLSID_BackgroundCopyManager,
                     NULL,
                     CLSCTX_LOCAL_SERVER,
                     IID_IBackgroundCopyManager,
                     (void**)&g_pManager ), true );

        BITSCheckHR( NULL, g_pManager->GetJob( g_JobId, &g_pJob ), true );
        BITSCheckHR( NULL,
                     g_pJob->SetNotifyInterface( (IBackgroundCopyCallback*)&g_Callback ),
                     true );
        BITSCheckHR( NULL, g_pJob->SetNotifyFlags( BG_NOTIFY_JOB_MODIFICATION ), true );

        ShowWindow( g_hwndDlg, SW_MINIMIZE );
        HandleUpdate();
    }
    catch(_com_error error )
    {
        ExitProcess( error.Error() );
    }
}

int WINAPI WinMain(
  HINSTANCE hInstance,      // handle to current instance
  HINSTANCE hPrevInstance,  // handle to previous instance
  LPSTR lpCmdLine,          // command line
  int nCmdShow)             // show state
{

  //
  // Expected syntax:
  // bits_ie /CREATEJOB URL
  // bits_ie /RESUMEJOB JobGUID DestinationFile

  // /CREATEJOB - Called from the script which is run when 
  //              "Background Download As" is selected.
  // /RESUMEJOB - Called from the link in the startup directory
  //              to resume a job when it is restarted.

  CoInitialize(NULL);

  InitCommonControls();

  if ( FAILED( CreateUI( nCmdShow ) ) )
      return -1;

  LPTSTR lpCommandLine = GetCommandLine();

  int argc;
  WCHAR **argv =
      CommandLineToArgvW(
          lpCommandLine,
          &argc );

  if ( argc < 2 )
      return -1;

  if ( argc == 3 &&
       _wcsicmp( L"/CREATEJOB", argv[1] ) == 0 )
      CreateJob( argv[2] );

  else if ( argc == 4 &&
            _wcsicmp( L"/RESUMEJOB", argv[1] ) == 0 )
      ResumeJob( argv[2], argv[3] );

  else
      return -1;

  MSG msg;
  while( GetMessage( &msg, NULL, 0, 0 ) )
  {
      TranslateMessage( &msg );
      DispatchMessage( &msg );
  }

  return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\bits_ie\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by bits_ie.rc
//
#define IDS_LONGPROGRESS                1
#define IDS_ERROR                       2
#define IDS_SHORTPROGRESS               3
#define IDS_QUEUED                      4
#define IDS_CONNECTING                  5
#define IDS_TRANSFERRING                6
#define IDS_SUSPENDED                   7
#define IDS_FATALERROR                  8
#define IDS_TRANSIENTERROR              9
#define IDS_TRANSFERRED                 10
#define IDS_ACKNOWLEDGED                11
#define IDS_CANCELLED                   12
#define IDS_UNKNOWN                     13
#define IDS_DAYSFORMAT                  14
#define IDS_HOURSFORMAT                 15
#define IDS_MINUTESFORMAT               16
#define IDS_SECONDSFORMAT               17
#define IDS_FOREGROUND                  18
#define IDS_HIGH                        19
#define IDS_NORMAL                      20
#define IDS_LOW                         21
#define IDS_ERRORBOXTITLE               22
#define IDS_FILEDLGTITLE                23
#define IDS_CANCELCAPTION               24
#define IDS_CANCELTEXT                  25
#define IDS_NOHTTPORHTTPS               26
#define IDS_ALLFILES                    27
#define IDS_STARTUPLINK                 28
#define IDS_CLOSECAPTION                29
#define IDS_CLOSETEXT                   30
#define IDS_ALREADYFINISHED             31
#define IDS_ALREADYFINISHEDCAPTION      32
#define IDS_GIGAFORMAT                  33
#define IDS_MEGAFORMAT                  34
#define IDS_KILOFORMAT                  35
#define IDS_BYTEFORMAT                  36
#define IDS_DISPLAYERRORCODE            37
#define IDS_MAX                         IDS_DISPLAYERRORCODE
#define IDD_DIALOG                      101
#define IDI_ICON1                       105
#define IDC_COMPLETE2                   1004
#define IDC_FINISH                      1004
#define IDC_CANCEL2                     1005
#define IDC_CANCEL                      1005
#define IDC_SUSPEND2                    1006
#define IDC_SUSPEND                     1006
#define IDC_PROGRESS                    1007
#define IDC_PROGRESSBAR                 1007
#define IDC_STATUSTXT                   1008
#define IDC_CREATIONTIMETXT             1009
#define IDC_MODIFICATONTIMETXT          1010
#define IDC_COMPLETIONTIMETXT           1011
#define IDC_ESTIMATEDTIMETXT            1012
#define IDC_TRANSFERRATETXT             1013
#define IDC_PRIORITY                    1014
#define IDC_RESUME2                     1015
#define IDC_RESUME                      1015
#define IDC_PRIORITYTXT                 1016
#define IDC_ERRORMSGTXT                 1017
#define IDC_STATUS                      1021
#define IDC_STARTTIME                   1022
#define IDC_MODIFICATIONTIME            1023
#define IDC_COMPLETIONTIME              1024
#define IDC_ESTIMATEDTIME               1025
#define IDC_TRANSFERRATE                1026
#define IDC_ERRORMSG                    1027
#define IDC_PROGRESSINFOTXT             1045
#define IDC_PROGRESSINFO                1046
#define IDC_DISPLAYNAME                 1047

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1037
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\bits_client_msm\bitscnfg\bitscnfg.cpp ===
//----------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       bitscnfg.cpp
//
//  Contents:   Configure BITS client service to default settings.
//
//  EdwardR     07/27/2001   Initial version.
//              08/03/2001   Add code to fixup ServiceDLL in registry.
//                           Add code to regsvr qmgrprxy.dll
//              08/13/2001   Add code to support XP as well as Win2k.
//----------------------------------------------------------------------------

#define  UNICODE
#include <windows.h>
#include <stdio.h>
#include <malloc.h>

#define  VER_WINDOWS_2000         500
#define  VER_WINDOWS_XP           501
//
//  Service configuration settings:
//
#define BITS_SERVICE_NAME        TEXT("BITS")
#define BITS_DISPLAY_NAME        TEXT("Background Intelligent Transfer Service")
#define BITS_BINARY_PATH         TEXT("%SystemRoot%\\System32\\svchost.exe -k BITSgroup")
#define BITS_LOAD_ORDER_GROUP    TEXT("BITSgroup")

#define BITS_SERVICE_TYPE        SERVICE_WIN32_SHARE_PROCESS
#define BITS_START_TYPE          SERVICE_DEMAND_START
#define BITS_ERROR_CONTROL       SERVICE_ERROR_NORMAL

//
//  This additional service registry setting is set incorrectly by the
//  Darwin install
//
#define REG_SERVICE_PATH         TEXT("SYSTEM\\CurrentControlSet\\Services\\BITS")
#define REG_PARAMETERS           TEXT("Parameters")
#define REG_SERVICEDLL           TEXT("ServiceDll")
#define REG_SERVICEDLL_PATH      TEXT("%SystemRoot%\\System32\\qmgr.dll")

//
//  For side-by-side install on Windows XP
//
#define BACKSLASH_STR            TEXT("\\")
#define BITS_SUBDIRECTORY        TEXT("BITS")
#define BITS_QMGR_DLL            TEXT("qmgr.dll")

#define REG_BITS                 TEXT("BITS")
#define REG_BITS_SERVICEDLL      TEXT("ServiceDLL")
#define REG_SERVICEDLL_KEY       TEXT("Software\\Microsoft\\Windows\\CurrentVersion")

//
//  Constants to register qmgrprxy.dll
//
#define BITS_QMGRPRXY_DLL        TEXT("qmgrprxy.dll")
#define BITS_BITS15PRXY_DLL      TEXT("bitsprx2.dll")
#define BITS_DLL_REGISTER_FN     "DllRegisterServer"

typedef HRESULT (*RegisterFn)();

//
//  Constants for parsing bitscnfg.exe runstring arguments
//
#define SZ_DELIMITERS            " \t"
#define SZ_INSTALL               "/i"
#define SZ_UNINSTALL             "/u"
#define SZ_DELETE_SERVICE        "/d"

#define ACTION_INSTALL             0
#define ACTION_UNINSTALL           1
#define ACTION_DELETE_SERVICE      2

//
//  Log file for testing
//
FILE   *f = NULL;

//---------------------------------------------------------------------
//  RegSetKeyAndValue()
//
//  Helper function to create a key, sets a value in the key,
//  then close the key.
//
//  Parameters:
//    pwsKey       WCHAR* The name of the key
//    pwsSubkey    WCHAR* The name of a subkey
//    pwsValueName WCHAR* The value name.
//    pwsValue     WCHAR* The data value to store
//    dwType       The type for the new registry value.
//    dwDataSize   The size for non-REG_SZ registry entry types.
//
//  Return:
//    BOOL         TRUE if successful, FALSE otherwise.
//---------------------------------------------------------------------
DWORD RegSetKeyAndValue( const WCHAR *pwsKey,
                         const WCHAR *pwsSubKey,
                         const WCHAR *pwsValueName,
                         const WCHAR *pwsValue,
                         const DWORD  dwType = REG_SZ,
                               DWORD  dwDataSize = 0,
                               BOOL   fReCreate = TRUE )
    {
    HKEY   hKey;
    DWORD  dwStatus;
    DWORD  dwSize = 0;
    WCHAR  *pwsCompleteKey;

    if (pwsKey)
        dwSize = wcslen(pwsKey);

    if (pwsSubKey)
        dwSize += wcslen(pwsSubKey);

    dwSize = (1+1+dwSize)*sizeof(WCHAR);  // Extra +1 for the backslash...

    pwsCompleteKey = (WCHAR*)_alloca(dwSize);

    wcscpy(pwsCompleteKey,pwsKey);

    if (NULL!=pwsSubKey)
        {
        wcscat(pwsCompleteKey, BACKSLASH_STR);
        wcscat(pwsCompleteKey, pwsSubKey);
        }

    // If the key is already there then delete it, we will recreate it.
    if (fReCreate)
        {
        dwStatus = RegDeleteKey( HKEY_LOCAL_MACHINE,
                                 pwsCompleteKey );
        }

    dwStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                               pwsCompleteKey,
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKey,
                               NULL );
    if (dwStatus != ERROR_SUCCESS)
        {
        return dwStatus;
        }

    if (pwsValue)
        {
        if ((dwType == REG_SZ)||(dwType == REG_EXPAND_SZ))
          dwDataSize = (1+wcslen(pwsValue))*sizeof(WCHAR);

        RegSetValueEx( hKey,
                       pwsValueName, 0, dwType, (BYTE *)pwsValue, dwDataSize );
        }
    else
        {
        RegSetValueEx( hKey,
                       pwsValueName, 0, dwType, (BYTE *)pwsValue, 0 );
        }

    RegCloseKey(hKey);
    return dwStatus;
    }

//-------------------------------------------------------------------------
//  RegDeleteKeyOrValue()
//
//  Delete either the specified sub-key or delete the specified value
//  within the sub-key. If pwszValueName is specified, the just delete
//  it and leave the key alone. If pwszValueName is NULL, then delete
//  the key.
//-------------------------------------------------------------------------
DWORD RegDeleteKeyOrValue( IN const WCHAR *pwszKey,
                           IN const WCHAR *pwszSubKey,
                           IN const WCHAR *pwszValueName )
    {
    LONG    lStatus = 0;
    DWORD   dwLen;
    DWORD   dwSize;
    HKEY    hKey;
    WCHAR  *pwszCompleteKey;

    if (!pwszKey || !pwszSubKey)
        {
        return lStatus;
        }

    dwLen = wcslen(pwszKey) + wcslen(pwszSubKey) + 2;
    dwSize = dwLen * sizeof(WCHAR);
    pwszCompleteKey = (WCHAR*)_alloca(dwSize);
    wcscpy(pwszCompleteKey,pwszKey);
    wcscat(pwszCompleteKey,BACKSLASH_STR);
    wcscat(pwszCompleteKey,pwszSubKey);

    if (pwszValueName)
        {
        // Delete a value in a key:
        if (f) fwprintf(f,TEXT("Delete Reg Value: %s : %s\n"),pwszCompleteKey,pwszValueName);

        lStatus = RegOpenKey(HKEY_LOCAL_MACHINE,pwszCompleteKey,&hKey);
        if (lStatus == ERROR_SUCCESS)
            {
            lStatus = RegDeleteValue(hKey,pwszValueName);
            RegCloseKey(hKey);
            }
        }
    else
        {
        // Delete the specified key:
        if (f) fwprintf(f,TEXT("Delete Reg Key: %s\n"),pwszCompleteKey);

        lStatus = RegDeleteKey(HKEY_LOCAL_MACHINE,pwszCompleteKey);
        }

    return lStatus;
    }

//-------------------------------------------------------------------------
// RegisterDLL()
//
//-------------------------------------------------------------------------
DWORD RegisterDLL( IN WCHAR *pwszSubdirectory,
                   IN WCHAR *pwszDllName )
    {
    DWORD      dwStatus = 0;
    HMODULE    hModule;
    RegisterFn pRegisterFn;
    UINT       nChars;
    WCHAR      wszDllPath[MAX_PATH+1];
    WCHAR      wszSystemDirectory[MAX_PATH+1];

    if (pwszSubdirectory)
        {
        nChars = GetSystemDirectory(wszSystemDirectory,MAX_PATH);
        if (  (nChars > MAX_PATH)
           || (MAX_PATH < (3+wcslen(wszSystemDirectory)+wcslen(BITS_SUBDIRECTORY)+wcslen(pwszDllName))) )
            {
            return ERROR_BUFFER_OVERFLOW;
            }

        wcscpy(wszDllPath,wszSystemDirectory);
        wcscat(wszDllPath,BACKSLASH_STR);
        wcscat(wszDllPath,pwszSubdirectory);
        wcscat(wszDllPath,BACKSLASH_STR);
        wcscat(wszDllPath,pwszDllName);
        }
    else
        {
        if (MAX_PATH < wcslen(pwszDllName))
            {
            return ERROR_BUFFER_OVERFLOW;
            }
        wcscpy(wszDllPath,pwszDllName);
        }

    hModule = LoadLibrary(wszDllPath);
    if (!hModule)
        {
        dwStatus = GetLastError();
        return dwStatus;
        }

    pRegisterFn = (RegisterFn)GetProcAddress(hModule,BITS_DLL_REGISTER_FN);
    if (!pRegisterFn)
        {
        dwStatus = GetLastError();
        FreeLibrary(hModule);
        return dwStatus;
        }

    dwStatus = pRegisterFn();

    FreeLibrary(hModule);

    return dwStatus;
    }

//-------------------------------------------------------------------------
// ParseCmdLine()
//
//-------------------------------------------------------------------------
void ParseCmdLine( LPSTR  pszCmdLine,
                   DWORD *pdwAction )
    {
    CHAR  *pszTemp = pszCmdLine;
    CHAR  *pszArg;
    BOOL   fFirstTime = TRUE;

    *pdwAction = ACTION_INSTALL;   // default is install.

    while (pszArg=strtok(pszTemp,SZ_DELIMITERS))
        {
        if (fFirstTime)
            {
            fFirstTime = FALSE;
            pszTemp = NULL;
            continue;       // Skip over program name...
            }

        if (!_stricmp(pszArg,SZ_INSTALL))
            {
            *pdwAction = ACTION_INSTALL;
            if (f) fwprintf(f,TEXT("Install: %S\n"),SZ_INSTALL);
            }
        if (!_stricmp(pszArg,SZ_UNINSTALL))
            {
            *pdwAction = ACTION_UNINSTALL;
            if (f) fwprintf(f,TEXT("Uninstall: %S\n"),SZ_UNINSTALL);
            }
        if (!_stricmp(pszArg,SZ_DELETE_SERVICE))
            {
            *pdwAction = ACTION_DELETE_SERVICE;
            if (f) fwprintf(f,TEXT("DeleteService: %S\n"),SZ_UNINSTALL);
            }
        }
    }

//-------------------------------------------------------------------------
//  DoInstall()
//-------------------------------------------------------------------------
DWORD DoInstall( DWORD dwOsVersion )
{
    SC_HANDLE  hSCM = NULL;
    SC_HANDLE  hService = NULL;
    DWORD      dwStatus = 0;
    UINT       nChars;
    WCHAR      wszQmgrPath[MAX_PATH+1];
    WCHAR      wszSystemDirectory[MAX_PATH+1];

    //
    // Cleanup the service configuration:
    //
    if (dwOsVersion == VER_WINDOWS_2000)
        {
        hSCM = OpenSCManager(NULL,SERVICES_ACTIVE_DATABASE,SC_MANAGER_ALL_ACCESS);
        if (hSCM == NULL)
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("OpenSCManager(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }

        if (f) fwprintf(f,TEXT("Configuring BITS Service... \n"));

        hService = OpenService(hSCM,BITS_SERVICE_NAME,SERVICE_CHANGE_CONFIG);
        if (hService == NULL)
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("OpenService(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }

        if (!ChangeServiceConfig(hService,
                                 BITS_SERVICE_TYPE,
                                 BITS_START_TYPE,
                                 BITS_ERROR_CONTROL,
                                 BITS_BINARY_PATH,
                                 NULL,   // Load order group (not changing this).
                                 NULL,   // Tag ID for load order group (not needed).

                                 // Service dependencies (this is different for Win2k )
                                 // reply on XP installer to overwrite this.
                                 TEXT("LanmanWorkstation\0Rpcss\0SENS\0Wmi\0"),   
                                 NULL,   // Account Name (not changing this).
                                 NULL,   // Account Password (not changing this).
                                 BITS_DISPLAY_NAME))
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("ChangeServiceConfig(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }

        //
        //  Fix the ServiceDll registry value...
        //
        if (f) fwprintf(f,TEXT("bitscnfg.exe: Fix ServiceDll entry.\n"));

        dwStatus = RegSetKeyAndValue( REG_SERVICE_PATH,
                                      REG_PARAMETERS,
                                      REG_SERVICEDLL,
                                      REG_SERVICEDLL_PATH,
                                      REG_EXPAND_SZ);
        if (dwStatus)
            {
            if (f) fwprintf(f,TEXT("RegSetKeyAndValue(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }
        }

    //
    //  Register qmgrproxy.dll
    //
    if (dwOsVersion == VER_WINDOWS_2000)
        {
        if (f) fwprintf(f,TEXT("bitscnfg.exe: Register %s.\n"),BITS_QMGRPRXY_DLL);

        dwStatus = RegisterDLL(NULL,BITS_QMGRPRXY_DLL);
        if (dwStatus != 0)
            {
            if (f) fwprintf(f,TEXT("RegisterDLL(%s): Failed: 0x%x (%d)\n"),BITS_QMGRPRXY_DLL,dwStatus,dwStatus);
            goto error;
            }
        }

    //
    //  Register bits15prxy.dll
    //
    if ((dwOsVersion == VER_WINDOWS_2000)||(dwOsVersion == VER_WINDOWS_XP))
        {
        if (f) fwprintf(f,TEXT("bitscnfg.exe: Register %s.\n"),BITS_BITS15PRXY_DLL);

        dwStatus = RegisterDLL(BITS_SUBDIRECTORY,BITS_BITS15PRXY_DLL);
        if (dwStatus != 0)
            {
            if (f) fwprintf(f,TEXT("RegisterDLL(%s): Failed: 0x%x (%d)\n"),BITS_BITS15PRXY_DLL,dwStatus,dwStatus);
            goto error;
            }
        }

    //
    // Configure WindowsXP BITS to run V1.5 qmgr.dll. This is also configured on Windows2000 systems to ready
    // it in case the system is upgraded to WindowsXP. This is done because there is no Migrate.dll to go from
    // Windows2000 to WindowsXP.
    //
    if ((dwOsVersion == VER_WINDOWS_2000)||(dwOsVersion == VER_WINDOWS_XP))
        {
        nChars = GetSystemDirectory(wszSystemDirectory,MAX_PATH);
        if (  (nChars > MAX_PATH)
           || (MAX_PATH < (3+wcslen(wszSystemDirectory)+wcslen(BITS_SUBDIRECTORY)+wcslen(BITS_QMGR_DLL))) )
            {
            if (f) fwprintf(f,TEXT("GetSystemDirectory(): System Path too long.\n"));
            goto error;
            }

        wcscpy(wszQmgrPath,wszSystemDirectory);
        wcscat(wszQmgrPath,BACKSLASH_STR);
        wcscat(wszQmgrPath,BITS_SUBDIRECTORY);
        wcscat(wszQmgrPath,BACKSLASH_STR);
        wcscat(wszQmgrPath,BITS_QMGR_DLL);

        if (f) fwprintf(f,TEXT("Set BITS V1.5 Override Path: %s\n"),wszQmgrPath);


        dwStatus = RegSetKeyAndValue( REG_SERVICEDLL_KEY,
                                      REG_BITS,
                                      REG_BITS_SERVICEDLL,
                                      wszQmgrPath,
                                      REG_SZ, 0, FALSE);
        if (dwStatus)
            {
            if (f) fwprintf(f,TEXT("RegSetKeyAndValue(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }
        }

error:
    if (hService)
        {
        CloseServiceHandle(hService);
        }

    if (hSCM)
        {
        CloseServiceHandle(hSCM);
        }

    return dwStatus;
}

//-------------------------------------------------------------------------
//  DoUninstall()
//
//  If this is Windows2000 then delete the BITS service.
//-------------------------------------------------------------------------
DWORD DoUninstall( DWORD dwOsVersion )
{
    DWORD      dwStatus = 0;
    SC_HANDLE  hSCM = NULL;
    SC_HANDLE  hService = NULL;


    //
    // Delete the BITS thunk DLL registry entry:
    //
    if (dwOsVersion == VER_WINDOWS_2000)
        {
        // If Windows2000, then delete the BITS subkey and all its values.
        RegDeleteKeyOrValue( REG_SERVICEDLL_KEY,
                             REG_BITS,
                             NULL );
        }

    if (dwOsVersion == VER_WINDOWS_XP)
        {
        // If WindowsXP, then just delete the ServiceDLL value and leave the key and any other values.
        RegDeleteKeyOrValue( REG_SERVICEDLL_KEY,
                             REG_BITS,
                             REG_BITS_SERVICEDLL );
        }

    //
    //  If this is Windows2000, then delete the service.
    //
    if (dwOsVersion == VER_WINDOWS_2000)
        {
        hSCM = OpenSCManager(NULL,SERVICES_ACTIVE_DATABASE,SC_MANAGER_ALL_ACCESS);
        if (hSCM == NULL)
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("OpenSCManager(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }

        if (f) fwprintf(f,TEXT("Configuring BITS Service... \n"));
        hService = OpenService(hSCM,BITS_SERVICE_NAME,SERVICE_CHANGE_CONFIG);
        if (hService == NULL)
            {
            dwStatus = GetLastError();
            if (dwStatus == ERROR_SERVICE_DOES_NOT_EXIST)
                {
                dwStatus = 0;
                if (f) fwprintf(f,TEXT("OpenService(): Failed: 0x%x (%d) Service doesn't exist.\n"),dwStatus,dwStatus);
                }
            else
                {
                if (f) fwprintf(f,TEXT("OpenService(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
                }
            goto error;
            }

        if (!DeleteService(hService))
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("DeleteService(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            }
        }

error:
    if (hService)
        {
        CloseServiceHandle(hService);
        }

    if (hSCM)
        {
        CloseServiceHandle(hSCM);
        }

    return dwStatus;
}

//-------------------------------------------------------------------------
//  DeleteBitsService()
//
//  Currently this is the same action as DoInstall().
//-------------------------------------------------------------------------
DWORD DeleteBitsService( IN DWORD dwOsVersion )
    {
    return DoUninstall( dwOsVersion );
    }

//-------------------------------------------------------------------------
// main()
//
//-------------------------------------------------------------------------
int PASCAL WinMain( HINSTANCE hInstance,
                    HINSTANCE hPrevInstance,
                    LPSTR     pszCmdLine,
                    int       nCmdShow )
    {
    SC_HANDLE  hSCM = NULL;
    SC_HANDLE  hService = NULL;
    DWORD      dwAction;
    DWORD      dwStatus;
    DWORD      dwOsVersion;
    UINT       nChars;
    WCHAR      wszQmgrPath[MAX_PATH+1];
    WCHAR      wszSystemDirectory[MAX_PATH+1];
    OSVERSIONINFO osVersionInfo;

    f = _wfopen(TEXT("c:\\temp\\bitscnfg.log"),TEXT("w"));

    if (f) fwprintf(f,TEXT("Runstring: %S\n"),pszCmdLine);

    ParseCmdLine(pszCmdLine,&dwAction);

    //
    // Get the operating system verison (Win2k == 500, XP == 501):
    //
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osVersionInfo))
        {
        dwStatus = GetLastError();
        if (f) fwprintf(f,TEXT("GetVersionEx(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
        goto error;
        }

    dwOsVersion = 100*osVersionInfo.dwMajorVersion + osVersionInfo.dwMinorVersion;

    if (f) fwprintf(f,TEXT("Windows Version: %d\n"),dwOsVersion);

    switch (dwAction)
        {
        case ACTION_INSTALL:
             dwStatus = DoInstall(dwOsVersion);
             break;

        case ACTION_UNINSTALL:
             dwStatus = DoUninstall(dwOsVersion);
             break;

        case ACTION_DELETE_SERVICE:
             dwStatus = DeleteBitsService(dwOsVersion);
             break;

        default:
             if (f) fwprintf(f,TEXT("Undefined Custom Action: %d\n"),dwAction);
             break;
        }

error:
    if (f) fwprintf(f,TEXT("bitscnfg.exe: Complete.\n"));

    if (f) fclose(f);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\client_cust_action\bitscnfg.cpp ===
//----------------------------------------------------------------------------
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       bitscnfg.cpp
//
//  Contents:   Configure BITS client service to default settings.
//
//  EdwardR     07/27/2001   Initial version.
//              08/03/2001   Add code to fixup ServiceDLL in registry.
//                           Add code to regsvr qmgrprxy.dll
//              08/13/2001   Add code to support XP as well as Win2k.
//----------------------------------------------------------------------------

#define  UNICODE
#include <windows.h>
#include <stdio.h>
#include <memory>

using namespace std;

#define  VER_WINDOWS_2000         500
#define  VER_WINDOWS_XP           501
//
//  Service configuration settings:
//
#define BITS_SERVICE_NAME        TEXT("BITS")
#define BITS_DISPLAY_NAME        TEXT("Background Intelligent Transfer Service")
#define BITS_BINARY_PATH         TEXT("%SystemRoot%\\System32\\svchost.exe -k BITSgroup")
#define BITS_LOAD_ORDER_GROUP    TEXT("BITSgroup")

#define BITS_SERVICE_TYPE        SERVICE_WIN32_SHARE_PROCESS
#define BITS_START_TYPE          SERVICE_DEMAND_START
#define BITS_ERROR_CONTROL       SERVICE_ERROR_NORMAL

//
//  This additional service registry setting is set incorrectly by the
//  Darwin install
//
#define REG_SERVICE_PATH         TEXT("SYSTEM\\CurrentControlSet\\Services\\BITS")
#define REG_PARAMETERS           TEXT("Parameters")
#define REG_SERVICEDLL           TEXT("ServiceDll")
#define REG_SERVICEDLL_PATH      TEXT("%SystemRoot%\\System32\\qmgr.dll")

//
//  For side-by-side install on Windows XP
//
#define BACKSLASH_STR            TEXT("\\")
#define BITS_SUBDIRECTORY        TEXT("BITS")
#define BITS_QMGR_DLL            TEXT("qmgr.dll")

#define REG_BITS                 TEXT("BITS")
#define REG_BITS_SERVICEDLL      TEXT("ServiceDLL")
#define REG_SERVICEDLL_KEY       TEXT("Software\\Microsoft\\Windows\\CurrentVersion")

//
//  Constants to register qmgrprxy.dll
//
#define BITS_QMGRPRXY_DLL        TEXT("qmgrprxy.dll")
#define BITS_BITS15PRXY_DLL      TEXT("bitsprx2.dll")
#define BITS_DLL_REGISTER_FN     "DllRegisterServer"

typedef HRESULT (*RegisterFn)();

//
//  Constants for parsing bitscnfg.exe runstring arguments
//
#define SZ_DELIMITERS            " \t"
#define SZ_INSTALL               "/i"
#define SZ_UNINSTALL             "/u"
#define SZ_DELETE_SERVICE        "/d"

#define ACTION_INSTALL             0
#define ACTION_UNINSTALL           1
#define ACTION_DELETE_SERVICE      2

//
//  Log file for testing
//
FILE   *f = NULL;

//---------------------------------------------------------------------
//  RegSetKeyAndValue()
//
//  Helper function to create a key, sets a value in the key,
//  then close the key.
//
//  Parameters:
//    pwsKey       WCHAR* The name of the key
//    pwsSubkey    WCHAR* The name of a subkey
//    pwsValueName WCHAR* The value name.
//    pwsValue     WCHAR* The data value to store
//    dwType       The type for the new registry value.
//    dwDataSize   The size for non-REG_SZ registry entry types.
//
//  Return:
//    BOOL         TRUE if successful, FALSE otherwise.
//---------------------------------------------------------------------
DWORD RegSetKeyAndValue( const WCHAR *pwsKey,
                         const WCHAR *pwsSubKey,
                         const WCHAR *pwsValueName,
                         const WCHAR *pwsValue,
                         const DWORD  dwType = REG_SZ,
                               DWORD  dwDataSize = 0,
                               BOOL   fReCreate = TRUE )
    {
    HKEY   hKey;
    DWORD  dwStatus;
    DWORD  dwSize = 0;

    if (pwsKey)
        dwSize = wcslen(pwsKey);

    if (pwsSubKey)
        dwSize += wcslen(pwsSubKey);

    auto_ptr<WCHAR> pwsCompleteKey( new WCHAR[ 1+1+dwSize ] );   // Extra +1 for the backslash...

    wcscpy(pwsCompleteKey.get(), pwsKey);

    if (NULL!=pwsSubKey)
        {
        wcscat(pwsCompleteKey.get(), BACKSLASH_STR);
        wcscat(pwsCompleteKey.get(), pwsSubKey);
        }

    // If the key is already there then delete it, we will recreate it.
    if (fReCreate)
        {
        dwStatus = RegDeleteKey( HKEY_LOCAL_MACHINE,
                                 pwsCompleteKey.get() );
        }

    dwStatus = RegCreateKeyEx( HKEY_LOCAL_MACHINE,
                               pwsCompleteKey.get(),
                               0,
                               NULL,
                               REG_OPTION_NON_VOLATILE,
                               KEY_ALL_ACCESS,
                               NULL,
                               &hKey,
                               NULL );
    if (dwStatus != ERROR_SUCCESS)
        {
        return dwStatus;
        }

    if (pwsValue)
        {
        if ((dwType == REG_SZ)||(dwType == REG_EXPAND_SZ))
          dwDataSize = (1+wcslen(pwsValue))*sizeof(WCHAR);

        RegSetValueEx( hKey,
                       pwsValueName, 0, dwType, (BYTE *)pwsValue, dwDataSize );
        }
    else
        {
        RegSetValueEx( hKey,
                       pwsValueName, 0, dwType, (BYTE *)pwsValue, 0 );
        }

    RegCloseKey(hKey);
    return dwStatus;
    }

//-------------------------------------------------------------------------
//  RegDeleteKeyOrValue()
//
//  Delete either the specified sub-key or delete the specified value
//  within the sub-key. If pwszValueName is specified, the just delete
//  it and leave the key alone. If pwszValueName is NULL, then delete
//  the key.
//-------------------------------------------------------------------------
DWORD RegDeleteKeyOrValue( IN const WCHAR *pwszKey,
                           IN const WCHAR *pwszSubKey,
                           IN const WCHAR *pwszValueName )
    {
    LONG    lStatus = 0;
    DWORD   dwLen;
    HKEY    hKey;

    if (!pwszKey || !pwszSubKey)
        {
        return lStatus;
        }

    dwLen = wcslen(pwszKey) + wcslen(pwszSubKey) + 2;

    auto_ptr<WCHAR> pwszCompleteKey ( new WCHAR[ dwLen ]);
    wcscpy(pwszCompleteKey.get(),pwszKey);
    wcscat(pwszCompleteKey.get(),BACKSLASH_STR);
    wcscat(pwszCompleteKey.get(),pwszSubKey);

    if (pwszValueName)
        {
        // Delete a value in a key:
        if (f) fwprintf(f,TEXT("Delete Reg Value: %s : %s\n"),pwszCompleteKey.get(),pwszValueName);

        lStatus = RegOpenKey(HKEY_LOCAL_MACHINE,pwszCompleteKey.get(),&hKey);
        if (lStatus == ERROR_SUCCESS)
            {
            lStatus = RegDeleteValue(hKey,pwszValueName);
            RegCloseKey(hKey);
            }
        }
    else
        {
        // Delete the specified key:
        if (f) fwprintf(f,TEXT("Delete Reg Key: %s\n"),pwszCompleteKey.get());

        lStatus = RegDeleteKey(HKEY_LOCAL_MACHINE,pwszCompleteKey.get());
        }

    return lStatus;
    }

//-------------------------------------------------------------------------
// RegisterDLL()
//
//-------------------------------------------------------------------------
DWORD RegisterDLL( IN WCHAR *pwszSubdirectory,
                   IN WCHAR *pwszDllName )
    {
    DWORD      dwStatus = 0;
    HMODULE    hModule;
    RegisterFn pRegisterFn;
    UINT       nChars;
    WCHAR      wszDllPath[MAX_PATH+1];
    WCHAR      wszSystemDirectory[MAX_PATH+1];

    if (pwszSubdirectory)
        {
        nChars = GetSystemDirectory(wszSystemDirectory,MAX_PATH);
        if (  (nChars > MAX_PATH)
           || (MAX_PATH < (3+wcslen(wszSystemDirectory)+wcslen(BITS_SUBDIRECTORY)+wcslen(pwszDllName))) )
            {
            return ERROR_BUFFER_OVERFLOW;
            }

        wcscpy(wszDllPath,wszSystemDirectory);
        wcscat(wszDllPath,BACKSLASH_STR);
        wcscat(wszDllPath,pwszSubdirectory);
        wcscat(wszDllPath,BACKSLASH_STR);
        wcscat(wszDllPath,pwszDllName);
        }
    else
        {
        if (MAX_PATH < wcslen(pwszDllName))
            {
            return ERROR_BUFFER_OVERFLOW;
            }
        wcscpy(wszDllPath,pwszDllName);
        }

    hModule = LoadLibrary(wszDllPath);
    if (!hModule)
        {
        dwStatus = GetLastError();
        return dwStatus;
        }

    pRegisterFn = (RegisterFn)GetProcAddress(hModule,BITS_DLL_REGISTER_FN);
    if (!pRegisterFn)
        {
        dwStatus = GetLastError();
        FreeLibrary(hModule);
        return dwStatus;
        }

    dwStatus = pRegisterFn();

    FreeLibrary(hModule);

    return dwStatus;
    }

//-------------------------------------------------------------------------
// ParseCmdLine()
//
//-------------------------------------------------------------------------
void ParseCmdLine( LPSTR  pszCmdLine,
                   DWORD *pdwAction )
    {
    CHAR  *pszTemp = pszCmdLine;
    CHAR  *pszArg;
    BOOL   fFirstTime = TRUE;

    *pdwAction = ACTION_INSTALL;   // default is install.

    while (pszArg=strtok(pszTemp,SZ_DELIMITERS))
        {
        if (fFirstTime)
            {
            fFirstTime = FALSE;
            pszTemp = NULL;
            continue;       // Skip over program name...
            }

        if (!_stricmp(pszArg,SZ_INSTALL))
            {
            *pdwAction = ACTION_INSTALL;
            if (f) fwprintf(f,TEXT("Install: %S\n"),SZ_INSTALL);
            }
        if (!_stricmp(pszArg,SZ_UNINSTALL))
            {
            *pdwAction = ACTION_UNINSTALL;
            if (f) fwprintf(f,TEXT("Uninstall: %S\n"),SZ_UNINSTALL);
            }
        if (!_stricmp(pszArg,SZ_DELETE_SERVICE))
            {
            *pdwAction = ACTION_DELETE_SERVICE;
            if (f) fwprintf(f,TEXT("DeleteService: %S\n"),SZ_UNINSTALL);
            }
        }
    }

//-------------------------------------------------------------------------
//  DoInstall()
//-------------------------------------------------------------------------
DWORD DoInstall( DWORD dwOsVersion )
{
    SC_HANDLE  hSCM = NULL;
    SC_HANDLE  hService = NULL;
    DWORD      dwStatus = 0;
    UINT       nChars;
    WCHAR      wszQmgrPath[MAX_PATH+1];
    WCHAR      wszSystemDirectory[MAX_PATH+1];

    //
    // Cleanup the service configuration:
    //
    if (dwOsVersion == VER_WINDOWS_2000)
        {
        hSCM = OpenSCManager(NULL,SERVICES_ACTIVE_DATABASE,SC_MANAGER_ALL_ACCESS);
        if (hSCM == NULL)
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("OpenSCManager(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }

        if (f) fwprintf(f,TEXT("Configuring BITS Service... \n"));

        hService = OpenService(hSCM,BITS_SERVICE_NAME,SERVICE_CHANGE_CONFIG);
        if (hService == NULL)
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("OpenService(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }

        if (!ChangeServiceConfig(hService,
                                 BITS_SERVICE_TYPE,
                                 BITS_START_TYPE,
                                 BITS_ERROR_CONTROL,
                                 BITS_BINARY_PATH,
                                 NULL,   // Load order group (not changing this).
                                 NULL,   // Tag ID for load order group (not needed).

                                 // Service dependencies (this is different for Win2k )
                                 // reply on XP installer to overwrite this.
                                 TEXT("LanmanWorkstation\0Rpcss\0SENS\0Wmi\0"),
                                 NULL,   // Account Name (not changing this).
                                 NULL,   // Account Password (not changing this).
                                 BITS_DISPLAY_NAME))
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("ChangeServiceConfig(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }

        //
        //  Fix the ServiceDll registry value...
        //
        if (f) fwprintf(f,TEXT("bitscnfg.exe: Fix ServiceDll entry.\n"));

        dwStatus = RegSetKeyAndValue( REG_SERVICE_PATH,
                                      REG_PARAMETERS,
                                      REG_SERVICEDLL,
                                      REG_SERVICEDLL_PATH,
                                      REG_EXPAND_SZ);
        if (dwStatus)
            {
            if (f) fwprintf(f,TEXT("RegSetKeyAndValue(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }
        }

    //
    //  Register qmgrproxy.dll
    //
    if (dwOsVersion == VER_WINDOWS_2000)
        {
        if (f) fwprintf(f,TEXT("bitscnfg.exe: Register %s.\n"),BITS_QMGRPRXY_DLL);

        dwStatus = RegisterDLL(NULL,BITS_QMGRPRXY_DLL);
        if (dwStatus != 0)
            {
            if (f) fwprintf(f,TEXT("RegisterDLL(%s): Failed: 0x%x (%d)\n"),BITS_QMGRPRXY_DLL,dwStatus,dwStatus);
            goto error;
            }
        }

    //
    //  Register bits15prxy.dll
    //
    if ((dwOsVersion == VER_WINDOWS_2000)||(dwOsVersion == VER_WINDOWS_XP))
        {
        if (f) fwprintf(f,TEXT("bitscnfg.exe: Register %s.\n"),BITS_BITS15PRXY_DLL);

        dwStatus = RegisterDLL(BITS_SUBDIRECTORY,BITS_BITS15PRXY_DLL);
        if (dwStatus != 0)
            {
            if (f) fwprintf(f,TEXT("RegisterDLL(%s): Failed: 0x%x (%d)\n"),BITS_BITS15PRXY_DLL,dwStatus,dwStatus);
            goto error;
            }
        }

    //
    // Configure WindowsXP BITS to run V1.5 qmgr.dll. This is also configured on Windows2000 systems to ready
    // it in case the system is upgraded to WindowsXP. This is done because there is no Migrate.dll to go from
    // Windows2000 to WindowsXP.
    //
    if ((dwOsVersion == VER_WINDOWS_2000)||(dwOsVersion == VER_WINDOWS_XP))
        {
        nChars = GetSystemDirectory(wszSystemDirectory,MAX_PATH);
        if (  (nChars > MAX_PATH)
           || (MAX_PATH < (3+wcslen(wszSystemDirectory)+wcslen(BITS_SUBDIRECTORY)+wcslen(BITS_QMGR_DLL))) )
            {
            if (f) fwprintf(f,TEXT("GetSystemDirectory(): System Path too long.\n"));
            goto error;
            }

        wcscpy(wszQmgrPath,wszSystemDirectory);
        wcscat(wszQmgrPath,BACKSLASH_STR);
        wcscat(wszQmgrPath,BITS_SUBDIRECTORY);
        wcscat(wszQmgrPath,BACKSLASH_STR);
        wcscat(wszQmgrPath,BITS_QMGR_DLL);

        if (f) fwprintf(f,TEXT("Set BITS V1.5 Override Path: %s\n"),wszQmgrPath);


        dwStatus = RegSetKeyAndValue( REG_SERVICEDLL_KEY,
                                      REG_BITS,
                                      REG_BITS_SERVICEDLL,
                                      wszQmgrPath,
                                      REG_SZ, 0, FALSE);
        if (dwStatus)
            {
            if (f) fwprintf(f,TEXT("RegSetKeyAndValue(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }
        }

error:
    if (hService)
        {
        CloseServiceHandle(hService);
        }

    if (hSCM)
        {
        CloseServiceHandle(hSCM);
        }

    return dwStatus;
}

//-------------------------------------------------------------------------
//  DoUninstall()
//
//  If this is Windows2000 then delete the BITS service.
//-------------------------------------------------------------------------
DWORD DoUninstall( DWORD dwOsVersion )
{
    DWORD      dwStatus = 0;
    SC_HANDLE  hSCM = NULL;
    SC_HANDLE  hService = NULL;


    //
    // Delete the BITS thunk DLL registry entry:
    //
    if (dwOsVersion == VER_WINDOWS_2000)
        {
        // If Windows2000, then delete the BITS subkey and all its values.
        RegDeleteKeyOrValue( REG_SERVICEDLL_KEY,
                             REG_BITS,
                             NULL );
        }

    if (dwOsVersion == VER_WINDOWS_XP)
        {
        // If WindowsXP, then just delete the ServiceDLL value and leave the key and any other values.
        RegDeleteKeyOrValue( REG_SERVICEDLL_KEY,
                             REG_BITS,
                             REG_BITS_SERVICEDLL );
        }

    //
    //  If this is Windows2000, then delete the service.
    //
    if (dwOsVersion == VER_WINDOWS_2000)
        {
        hSCM = OpenSCManager(NULL,SERVICES_ACTIVE_DATABASE,SC_MANAGER_ALL_ACCESS);
        if (hSCM == NULL)
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("OpenSCManager(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            goto error;
            }

        if (f) fwprintf(f,TEXT("Configuring BITS Service... \n"));
        hService = OpenService(hSCM,BITS_SERVICE_NAME,SERVICE_CHANGE_CONFIG);
        if (hService == NULL)
            {
            dwStatus = GetLastError();
            if (dwStatus == ERROR_SERVICE_DOES_NOT_EXIST)
                {
                dwStatus = 0;
                if (f) fwprintf(f,TEXT("OpenService(): Failed: 0x%x (%d) Service doesn't exist.\n"),dwStatus,dwStatus);
                }
            else
                {
                if (f) fwprintf(f,TEXT("OpenService(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
                }
            goto error;
            }

        if (!DeleteService(hService))
            {
            dwStatus = GetLastError();
            if (f) fwprintf(f,TEXT("DeleteService(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
            }
        }

error:
    if (hService)
        {
        CloseServiceHandle(hService);
        }

    if (hSCM)
        {
        CloseServiceHandle(hSCM);
        }

    return dwStatus;
}

//-------------------------------------------------------------------------
//  DeleteBitsService()
//
//  Currently this is the same action as DoInstall().
//-------------------------------------------------------------------------
DWORD DeleteBitsService( IN DWORD dwOsVersion )
    {
    return DoUninstall( dwOsVersion );
    }

//-------------------------------------------------------------------------
// main()
//
//-------------------------------------------------------------------------
int PASCAL WinMain( HINSTANCE hInstance,
                    HINSTANCE hPrevInstance,
                    LPSTR     pszCmdLine,
                    int       nCmdShow )
    {
    SC_HANDLE  hSCM = NULL;
    SC_HANDLE  hService = NULL;
    DWORD      dwAction;
    DWORD      dwStatus;
    DWORD      dwOsVersion;
    UINT       nChars;
    WCHAR      wszQmgrPath[MAX_PATH+1];
    WCHAR      wszSystemDirectory[MAX_PATH+1];
    OSVERSIONINFO osVersionInfo;

    f = _wfopen(TEXT("c:\\temp\\bitscnfg.log"),TEXT("w"));

    if (f) fwprintf(f,TEXT("Runstring: %S\n"),pszCmdLine);

    ParseCmdLine(pszCmdLine,&dwAction);

    //
    // Get the operating system verison (Win2k == 500, XP == 501):
    //
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    if (!GetVersionEx(&osVersionInfo))
        {
        dwStatus = GetLastError();
        if (f) fwprintf(f,TEXT("GetVersionEx(): Failed: 0x%x (%d)\n"),dwStatus,dwStatus);
        goto error;
        }

    dwOsVersion = 100*osVersionInfo.dwMajorVersion + osVersionInfo.dwMinorVersion;

    if (f) fwprintf(f,TEXT("Windows Version: %d\n"),dwOsVersion);

    switch (dwAction)
        {
        case ACTION_INSTALL:
             dwStatus = DoInstall(dwOsVersion);
             break;

        case ACTION_UNINSTALL:
             dwStatus = DoUninstall(dwOsVersion);
             break;

        case ACTION_DELETE_SERVICE:
             dwStatus = DeleteBitsService(dwOsVersion);
             break;

        default:
             if (f) fwprintf(f,TEXT("Undefined Custom Action: %d\n"),dwAction);
             break;
        }

error:
    if (f) fwprintf(f,TEXT("bitscnfg.exe: Complete.\n"));

    if (f) fclose(f);

    return 0;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\drizzle\client\client.cpp ===
// client.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f clientps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "client.h"

#include "client_i.c"
#include "DrizzleClient.h"


const DWORD dwTimeOut = 5000; // time for EXE to be idle before shutting down
const DWORD dwPause = 1000; // time to wait for threads to finish up

// Passed to CreateThread to monitor the shutdown event
static DWORD WINAPI MonitorProc(void* pv)
{
    CExeModule* p = (CExeModule*)pv;
    p->MonitorShutdown();
    return 0;
}

LONG CExeModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0)
    {
        bActivity = true;
        SetEvent(hEventShutdown); // tell monitor that we transitioned to zero
    }
    return l;
}

//Monitors the shutdown event
void CExeModule::MonitorShutdown()
{
    while (1)
    {
        WaitForSingleObject(hEventShutdown, INFINITE);
        DWORD dwWait=0;
        do
        {
            bActivity = false;
            dwWait = WaitForSingleObject(hEventShutdown, dwTimeOut);
        } while (dwWait == WAIT_OBJECT_0);
        // timed out
        if (!bActivity && m_nLockCnt == 0) // if no activity let's really bail
        {
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
            CoSuspendClassObjects();
            if (!bActivity && m_nLockCnt == 0)
#endif
                break;
        }
    }
    CloseHandle(hEventShutdown);
    PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
}

bool CExeModule::StartMonitor()
{
    hEventShutdown = CreateEvent(NULL, false, false, NULL);
    if (hEventShutdown == NULL)
        return false;
    DWORD dwThreadID;
    HANDLE h = CreateThread(NULL, 0, MonitorProc, this, 0, &dwThreadID);
    return (h != NULL);
}

CExeModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DrizzleClient, CDrizzleClient)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT

#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
    HRESULT hRes = CoInitializeEx(NULL, COINIT_MULTITHREADED);
#else
    HRESULT hRes = CoInitialize(NULL);
#endif
    _ASSERTE(SUCCEEDED(hRes));
    _Module.Init(ObjectMap, hInstance, &LIBID_CLIENTLib);
    _Module.dwThreadID = GetCurrentThreadId();
    TCHAR szTokens[] = _T("-/");

    int nRet = 0;
    BOOL bRun = TRUE;
    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_Client, FALSE);
            nRet = _Module.UnregisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
        {
            _Module.UpdateRegistryFromResource(IDR_Client, TRUE);
            nRet = _Module.RegisterServer(TRUE);
            bRun = FALSE;
            break;
        }
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    if (bRun)
    {
        _Module.StartMonitor();
#if _WIN32_WINNT >= 0x0400 & defined(_ATL_FREE_THREADED)
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE | REGCLS_SUSPENDED);
        _ASSERTE(SUCCEEDED(hRes));
        hRes = CoResumeClassObjects();
#else
        hRes = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER, 
            REGCLS_MULTIPLEUSE);
#endif
        _ASSERTE(SUCCEEDED(hRes));


		
        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
            DispatchMessage(&msg);

        _Module.RevokeClassObjects();
        Sleep(dwPause); //wait for any threads to finish
    }

    _Module.Term();
    CoUninitialize();
    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\idl\drizcompat.h ===
//=======================================================================
//
//  Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
//
//=======================================================================


#define IBackgroundCopyJob          IBackgroundCopyJob1
#define IBackgroundCopyCallback     IBackgroundCopyCallback1
#define IEnumBackgroundCopyJobs     IEnumBackgroundCopyJobs1

#define IID_IBackgroundCopyJob          IID_IBackgroundCopyJob1
#define IID_IBackgroundCopyCallback     IID_IBackgroundCopyCallback1
#define IID_IEnumBackgroundCopyJobs     IID_IEnumBackgroundCopyJobs1

#define CLSID_IBackgroundCopyJob          CLSID_IBackgroundCopyJob1
#define CLSID_IBackgroundCopyCallback     CLSID_IBackgroundCopyCallback1
#define CLSID_IEnumBackgroundCopyJobs     CLSID_IEnumBackgroundCopyJobs1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\inc\bitsverp.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    bitsverp.h

Abstract :

    Version file for BITS.

Author :

Revision History :

 ***********************************************************************/

#include <ntverp.h>

#undef VER_PRODUCTMAJORVERSION
#undef VER_PRODUCTMINORVERSION
#undef VER_PRODUCTBETA_STR
#undef VER_PRODUCTVERSION_MAJORMINOR2
#undef VER_PRODUCTVERSION_MAJORMINOR1
#undef VER_PRODUCTVERSION_STRING
#undef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION_W
#undef VER_PRODUCTVERSION_DW

#define VER_PRODUCTMAJORVERSION     6
#define VER_PRODUCTMINORVERSION     2

#define VER_PRODUCTBETA_STR         /* NT */     ""

//
// not sure why VER_PRODUCTVERSION_MAJORMINOR1 needs to be defined in terms of VER_PRODUCTVERSION_MAJORMINOR2
//
#define VER_PRODUCTVERSION_MAJORMINOR2(x,y) #x "." #y
#define VER_PRODUCTVERSION_MAJORMINOR1(x,y) VER_PRODUCTVERSION_MAJORMINOR2(x, y)
#define VER_PRODUCTVERSION_STRING   VER_PRODUCTVERSION_MAJORMINOR1(VER_PRODUCTMAJORVERSION, VER_PRODUCTMINORVERSION)

#define VER_PRODUCTVERSION_MAJORMINOR2_WSTRING(x,y) L#x L"." L#y
#define VER_PRODUCTVERSION_MAJORMINOR1_WSTRING(x,y) VER_PRODUCTVERSION_MAJORMINOR2_WSTRING(x, y)
#define VER_PRODUCTVERSION_WSTRING   VER_PRODUCTVERSION_MAJORMINOR1_WSTRING(VER_PRODUCTMAJORVERSION, VER_PRODUCTMINORVERSION)

#define VER_PRODUCTVERSION          VER_PRODUCTMAJORVERSION,VER_PRODUCTMINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE
#define VER_PRODUCTVERSION_W        (0x0602)
#define VER_PRODUCTVERSION_DW       (0x06020000 | VER_PRODUCTBUILD)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\cache.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    cache.cpp

Abstract :

    Sources files for file cache management

Author :

Revision History :

 ***********************************************************************/


#include "stdafx.h"
#include <accctrl.h>
#include <aclapi.h>

#if !defined(BITS_V12_ON_NT4)
#include "cache.tmh"
#endif

BOOL
CProgressiveDL::OpenLocalDownloadFile(
    LPCTSTR Path,
    UINT64  Offset,
    UINT64  Size,
    FILETIME UrlModificationTime // 0 if unknown
    )
{
    HANDLE hFile;

    bool bOpenExisting;

    if (Offset > 0)
        {
        // BUGBUG storing the creation time via SetFileTime doesn't work due to granularity problems.
        // The queue manager needs to find out the size & time and store them in the CFile object,
        // and the downloader needs to check them when a download resumes.

        bOpenExisting = true;

        hFile = CreateFile( Path,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL );

        if (hFile == INVALID_HANDLE_VALUE )
            {
            DWORD dwError = GetLastError();
            LogError("error %!winerr!, opening '%S'", dwError, Path );
            SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, dwError, "CreateFile" );
            return FALSE;
            }

        LARGE_INTEGER liFileSize;

        if ( !GetFileSizeEx( hFile, &liFileSize ) )
            {
            DWORD dwError = GetLastError();
            CloseHandle( hFile );
            LogError("error %!winerr!, retrieving size of '%S'", dwError, Path );
            SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, dwError, "GetFileSizeEx" );
            return FALSE;
            }


        if ( Size != liFileSize.QuadPart )
            {

            CloseHandle( hFile );
            LogError("File size of '%S' changed", Path );
            m_pQMInfo->result = QM_SERVER_FILE_CHANGED;
            return FALSE;
            }

        LARGE_INTEGER liOffset;

        liOffset.QuadPart = Offset;

        if (!SetFilePointerEx( hFile,
                               liOffset,
                               NULL,        // don't need the new file pointer
                               FILE_BEGIN ))
            {
            DWORD dwError = GetLastError();
            CloseHandle( hFile );
            LogError("error %!winerr!, seeking to current position in '%S'", dwError, Path );
            SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, dwError, "SetFilePointerEx" );
            return FALSE;
            }

        }
    else
        {

        bOpenExisting = false;

        hFile = CreateFile( Path,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_HIDDEN,
                            NULL );

        if (hFile == INVALID_HANDLE_VALUE )
            {
            SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, GetLastError(), "CreateFile" );
            return FALSE;
            }

        // Reserve space for the file upfront.

        LARGE_INTEGER liOffset;
        liOffset.QuadPart = Size;

        if (!SetFilePointerEx( hFile,
                               liOffset,
                               NULL,
                               FILE_BEGIN ))
            {
            DWORD dwError = GetLastError();
            CloseHandle( hFile );
            LogError( "error %!winerr! setting end of file, out of disk space?", dwError );

            SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, dwError, "SetFilePointerEx" );
            return FALSE;
            }

        if ( !SetEndOfFile( hFile ) )
            {
            DWORD dwError = GetLastError();
            CloseHandle( hFile );
            LogError( "error %!winerr! setting end of file, out of disk space?", dwError );

            SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, dwError, "SetFilePointerEx" );
            return FALSE;
            }

        liOffset.QuadPart = 0;
        if (!SetFilePointerEx( hFile,
                               liOffset,
                               NULL,
                               FILE_BEGIN ))
            {
            DWORD dwError = GetLastError();
            CloseHandle( hFile );
            LogError( "error %!winerr! returning to the beginning of the file", dwError );
            SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, dwError, "SetFilePointerEx" );
            return FALSE;
            }


        if ( UrlModificationTime.dwHighDateTime ||
             UrlModificationTime.dwLowDateTime )
            {

            if (!SetFileTime( hFile, &UrlModificationTime, NULL, NULL ) )
                {
                DWORD dwError = GetLastError();
                CloseHandle( hFile );
                LogError( "error %!winerr! setting creation time", dwError );

                SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, dwError, "SetFileTime" );
                return FALSE;
                }

            }

        }

    FILETIME CreationTime;

    if (!GetFileTime( hFile, &CreationTime, NULL, NULL ) )
        {

        DWORD dwError = GetLastError();
        CloseHandle( hFile );
        LogError( "error %!winerr!, unable to get file creation time", dwError );

        SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, dwError, "GetFileTime" );
        return FALSE;
        }

    if ( bOpenExisting )
        {

        if ( UrlModificationTime.dwHighDateTime ||
             UrlModificationTime.dwLowDateTime )
            {

            if ( CompareFileTime( &UrlModificationTime, &CreationTime ) > 0 )
                {
                // UrlModificationTime is newer
                CloseHandle( hFile );
                LogError("File time of '%S' changed", Path );
                m_pQMInfo->result = QM_SERVER_FILE_CHANGED;
                return FALSE;
                }

            }

        }

    m_hFile = hFile;
    m_wupdinfo->FileCreationTime = CreationTime;
    m_CurrentOffset = Offset;

    return TRUE;
}

BOOL CProgressiveDL::CloseLocalFile()
{

    if (m_hFile == INVALID_HANDLE_VALUE)
        {
        return FALSE;
        }

    CloseHandle( m_hFile );
    m_hFile = INVALID_HANDLE_VALUE;
    return TRUE;
}

BOOL
CProgressiveDL::WriteBlockToCache(
    LPBYTE lpBuffer,
    DWORD dwRead
    )
{
    DWORD dwWritten = 0;

    ASSERT( m_hFile != INVALID_HANDLE_VALUE );

    if (! WriteFile( m_hFile,
                     lpBuffer,
                     dwRead,
                     &dwWritten,
                     NULL)
        || (dwRead != dwWritten))
        {
        SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, GetLastError(), "WriteFile" );
        return FALSE;
        }

    m_CurrentOffset += dwWritten;

    return TRUE;
}

BOOL
CProgressiveDL::SetFileTimes()
{

    ASSERT( m_hFile != INVALID_HANDLE_VALUE );

    if ( !m_wupdinfo->UrlModificationTime.dwHighDateTime &&
         !m_wupdinfo->UrlModificationTime.dwLowDateTime )
        {
        LogWarning( "Server doesn't support modification times, can't set it on the files." );
        return TRUE;
        }

    if ( !SetFileTime( m_hFile,
                       &m_wupdinfo->UrlModificationTime,
                       &m_wupdinfo->UrlModificationTime,
                       &m_wupdinfo->UrlModificationTime ) )
        {
        DWORD dwError = GetLastError();
        LogError( "Unable to get times on the local file, error %!winerr!", dwError );
        SetError( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, dwError, "SetFileTime" );
        return FALSE;
        }

    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\isapi\bitisapi.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    bitisapi.cpp

Abstract :

    ISAPI to get HTTP/1.1 byte range to work through HTTP/1.0 proxies.

Author :

Revision History :

 ***********************************************************************/

#include <windows.h>
#include <wininet.h>
#include <stdio.h>
#include <stdlib.h>
#include <httpfilt.h>
#include <strsafe.h>

// From ntrtl.h:
//
extern "C"
{
ULONG
__cdecl
DbgPrint(
    PCH Format,
    ...
    );
}

const size_t INT_DIGITS = 10;
const size_t INT64_DIGITS = 20;

BOOL
DecodeURL(LPSTR pszUrl, LPCSTR * ppRange);

BOOL WINAPI
GetFilterVersion(HTTP_FILTER_VERSION * pVer)
{
    //
    //  Specify the types and order of notification
    //
    pVer->dwFlags = (SF_NOTIFY_PREPROC_HEADERS | SF_NOTIFY_ORDER_HIGH);
    pVer->dwFilterVersion = HTTP_FILTER_REVISION;

    StringCchCopyA( pVer->lpszFilterDesc, SF_MAX_FILTER_DESC_LEN, "ISAPI filter for BITS download");

    return TRUE;
}


DWORD WINAPI
HttpFilterProc( HTTP_FILTER_CONTEXT *   pfc,
                DWORD                   NotificationType,
                VOID *                  pvData )
{
    char Template[] = " bytes=%s\r\n";

    HTTP_FILTER_PREPROC_HEADERS *pHeaders;

    char szUrl[INTERNET_MAX_URL_LENGTH];
    DWORD cbUrl = sizeof(szUrl);

    // The value of the range header.  Looks like "bytes=<start>-<end>".
    //
    char szValue[ RTL_NUMBER_OF(Template) + INT64_DIGITS + 1 + INT64_DIGITS ];

    LPCSTR szRange = 0;


    if (NotificationType == SF_NOTIFY_PREPROC_HEADERS)
    {
        pHeaders = (PHTTP_FILTER_PREPROC_HEADERS) pvData;
        if (! pHeaders->GetHeader(pfc, "url", szUrl, &cbUrl))
            {
            return SF_STATUS_REQ_NEXT_NOTIFICATION;
            }

        if (! DecodeURL(szUrl, &szRange))
            {
            return SF_STATUS_REQ_NEXT_NOTIFICATION;
            }

        if (! pHeaders->SetHeader(pfc, "url", szUrl))
            {
            #if DBG
            DbgPrint("unable to set URL='%s'", szUrl);
            #endif
            return SF_STATUS_REQ_ERROR;
            }

        if (S_OK != StringCbPrintfA(szValue, sizeof(szValue), Template, szRange))
            {
            #if DBG
            DbgPrint("byte range is too long: '%s'", szRange );
            #endif
            return SF_STATUS_REQ_ERROR;
            }

        if (! pHeaders->AddHeader(pfc, "Range:", szValue))
            {
            return SF_STATUS_REQ_ERROR;
            }
    }
    return SF_STATUS_REQ_NEXT_NOTIFICATION;

}

BOOL
DecodeURL(LPSTR pszUrl, LPCSTR * ppRange)
{
    LPSTR pszStart = strchr(pszUrl, '@');
    if (!pszStart)
        {
        return FALSE;
        }

    ++pszStart;

    LPSTR pszEnd = strchr(pszStart, '@');
    if (!pszEnd)
        {
        return FALSE;
        }

    //
    // Plant '\0' over the leading and trailing '@'.
    //
    *(pszStart-1) = '\0';
    *pszEnd = '\0';

    *ppRange = pszStart;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\mmcexts\cleanup.cpp ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    cleanup.cpp

Abstract:

    This file implements the BITS server extensions cleanup worker

--*/

#include "precomp.h"

const UINT64 NanoSec100PerSec = 10000000;    //no of 100 nanosecs per second

inline UINT64 FILETIMEToUINT64( const FILETIME & FileTime )
{
    ULARGE_INTEGER LargeInteger;
    LargeInteger.HighPart = FileTime.dwHighDateTime;
    LargeInteger.LowPart = FileTime.dwLowDateTime;
    return LargeInteger.QuadPart;
};

class CleanupWorker
{

public:
    CleanupWorker( HWND hwnd, const WCHAR* Path, const WCHAR *WorkItemName,
                   const WCHAR *GuidString );
    ~CleanupWorker();
    void DoIt();

private:

    HWND          m_hwnd;
    const WCHAR * m_Path;
    const WCHAR * m_WorkItemName;
    const WCHAR * m_GuidString;
    const WCHAR * m_ADSIPath;
    IADs        * m_VDir;
    BSTR          m_VDirPath;
    BSTR          m_SessionDirectory;
    BSTR          m_UNCUsername;
    BSTR          m_UNCPassword;
    UINT64        m_CleanupThreshold;
    
    VARIANT       m_vt;
    HANDLE        m_FindHandle;

    HANDLE        m_UserToken;

    WCHAR * BuildPath( const WCHAR * Dir, const WCHAR *Sub );
    BSTR    GetBSTRProp( BSTR PropName );
    void  LogonIfRequired();
    void PollKill();

    void RemoveConnectionsFromTree( 
        const WCHAR * DirectoryPath,
        bool IsConnectionDirectory );

    void RemoveConnection( const WCHAR * ConnectionDirectory );

};

CleanupWorker::CleanupWorker( 
    HWND hwnd, 
    const WCHAR* Path, 
    const WCHAR* WorkItemName,
    const WCHAR* GuidString ) :
m_hwnd( hwnd ),
m_Path( Path ),
m_WorkItemName( WorkItemName ),
m_GuidString( GuidString ),
m_ADSIPath( NULL ),
m_VDir( NULL ),
m_VDirPath( NULL ),
m_SessionDirectory( NULL ),
m_CleanupThreshold( 0 ),
m_UNCUsername( NULL ),
m_UNCPassword( NULL ),
m_UserToken( NULL )
{
    VariantInit( &m_vt );
}

CleanupWorker::~CleanupWorker()
{

    if ( m_UserToken )
        {
        SetThreadToken( NULL, NULL );
        CloseHandle( m_UserToken );
        }

    delete m_ADSIPath;
    SysFreeString( m_VDirPath );
    SysFreeString( m_SessionDirectory );
    SysFreeString( m_UNCUsername );
    SysFreeString( m_UNCPassword );
}


void 
CleanupWorker::RemoveConnection( const WCHAR * ConnectionDirectory )
{
   UINT64 LatestTime = 0; 
   HANDLE FindHandle = INVALID_HANDLE_VALUE;
   WCHAR *SearchPath = NULL;
   WCHAR *FileName   = NULL;

   try
   {

       SearchPath = BuildPath( ConnectionDirectory, L"*" );
       
       WIN32_FIND_DATA FindData;

       FindHandle =
            FindFirstFile(
                SearchPath,
                &FindData
                );

       if ( INVALID_HANDLE_VALUE == FindHandle )
           throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

       bool FoundFile = false;
       do
           {

           if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
               continue;

           FoundFile = true;
           UINT64 CreationTime      = FILETIMEToUINT64( FindData.ftCreationTime );
           UINT64 LastWriteTime     = FILETIMEToUINT64( FindData.ftLastWriteTime ); 
           LatestTime = max( LatestTime, max( CreationTime, LastWriteTime ) );
           }
       while ( FindNextFile( FindHandle, &FindData ) );

       FindClose( FindHandle );
       FindHandle = INVALID_HANDLE_VALUE;

       FILETIME ftCurrentTime;
       GetSystemTimeAsFileTime( &ftCurrentTime );
       UINT64 CurrentTime = FILETIMEToUINT64( ftCurrentTime );

       if ( FoundFile &&
            ( 0xFFFFFFFF - LatestTime > m_CleanupThreshold ) && 
            ( LatestTime + m_CleanupThreshold < CurrentTime ) )
           {
           
           FindHandle =
                FindFirstFile(
                    SearchPath,
                    &FindData
                    );

           if ( INVALID_HANDLE_VALUE == FindHandle )
               throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

           do
               {

               if ( FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY )
                   continue;

               FileName = BuildPath( ConnectionDirectory, FindData.cFileName );
               DeleteFile( FileName );

               delete FileName;
               FileName = NULL;

               }
           while ( FindNextFile( FindHandle, &FindData ) );

           FindClose( FindHandle );
           FindHandle = INVALID_HANDLE_VALUE;
                      
           }

       RemoveDirectory( ConnectionDirectory );
   }

   catch( ComError Error )
   {
       if ( INVALID_HANDLE_VALUE != FindHandle )
           FindClose( FindHandle );
       
       delete SearchPath;
       delete FileName;
       
       throw;
   }    

   if ( INVALID_HANDLE_VALUE != FindHandle )
       FindClose( FindHandle );

   delete SearchPath;
   delete FileName;

}


void 
CleanupWorker::RemoveConnectionsFromTree( 
    const WCHAR * DirectoryPath,
    bool IsConnectionDirectory )
{
    WCHAR *ConnectionDir    = NULL;
    HANDLE FindHandle       = INVALID_HANDLE_VALUE;
    WCHAR *SearchString     = NULL;
    WCHAR *NextSearchPath   = NULL;

    try
    {
        // Look for BITS-Sessions directory in connection tree

        SearchString = BuildPath( DirectoryPath, L"*" );
        
        WIN32_FIND_DATA FindData;


        FindHandle =
            FindFirstFile(
                SearchString,
                &FindData );


        if ( INVALID_HANDLE_VALUE == FindHandle )
            return;

        do
            {

            PollKill();

            if ( !(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) )
                continue;

            if ( _wcsicmp( L".", FindData.cFileName ) == 0 )
                continue;

            if ( _wcsicmp( L"..", FindData.cFileName ) == 0 )
                continue;

            if ( IsConnectionDirectory )
                {

                GUID Guid;
                if (SUCCEEDED( IIDFromString( FindData.cFileName, &Guid ) ) )
                    {

                    NextSearchPath = BuildPath( DirectoryPath, FindData.cFileName );

                    RemoveConnection( NextSearchPath );

                    delete NextSearchPath;
                    NextSearchPath = NULL;
                    }

                }
            else
                {

                if ( _wcsicmp( m_SessionDirectory, FindData.cFileName ) == 0 )
                    {

                    NextSearchPath = BuildPath( DirectoryPath, FindData.cFileName );

                    RemoveConnectionsFromTree( NextSearchPath, true );

                    // Mark this as the connection directory so it
                    // will be closed after the search handles are closed.
                    ConnectionDir = NextSearchPath;
                    NextSearchPath = NULL;

                    }
                else
                    {

                    // just another directory to recurse into

                    NextSearchPath = BuildPath( DirectoryPath, FindData.cFileName );

                    RemoveConnectionsFromTree( NextSearchPath, false );

                    delete NextSearchPath;
                    NextSearchPath = NULL;

                    }

                }

                
            }
        while( FindNextFile( FindHandle, &FindData ) );

        if ( INVALID_HANDLE_VALUE != FindHandle )
            FindClose( FindHandle );
        delete SearchString;
        delete NextSearchPath;

        if ( ConnectionDir )
            {
            // The attempt to remove the directory will fail if 
            // the directory still has valid connections 
            RemoveDirectory( ConnectionDir );
            delete ConnectionDir;
            }

    }
    catch( ComError Error )
    {

        if ( INVALID_HANDLE_VALUE != FindHandle )
            FindClose( FindHandle );
        delete SearchString;
        delete NextSearchPath;
        delete ConnectionDir;

        throw;
    }

}

void 
CleanupWorker::PollKill()
{
    MSG msg;

    while( PeekMessage(
               &msg,
               m_hwnd,
               0,
               0,
               PM_REMOVE ) )
        {

        if ( WM_QUIT == msg.message )
            throw ComError( (HRESULT)msg.wParam );

        TranslateMessage( &msg );
        DispatchMessage( &msg );

        }

}

WCHAR * 
CleanupWorker::BuildPath( 
    const WCHAR *Dir, 
    const WCHAR *Sub )
{
    
    SIZE_T DirLen = wcslen( Dir );
    SIZE_T SubLen = wcslen( Sub );
    SIZE_T MaxStringSize = DirLen + SubLen + 2; // one slash, one terminator
    WCHAR *RetString = new WCHAR[ MaxStringSize ];

    if ( !RetString )
        throw ComError( E_OUTOFMEMORY );

    memcpy( RetString, Dir, sizeof(WCHAR) * (DirLen + 1) );
    WCHAR *p = RetString + DirLen;
    
    if ( p != RetString && *(p - 1) != L'\\' && *(p - 1) != L'/' )
        *p++ = L'\\';

    memcpy( p, Sub, sizeof(WCHAR) * ( SubLen + 1 ) );
    
    return RetString;
}

BSTR
CleanupWorker::GetBSTRProp( BSTR PropName )
{

  BSTR Retval;

  THROW_COMERROR( m_VDir->Get( PropName, &m_vt ) );
  THROW_COMERROR( VariantChangeType( &m_vt, &m_vt, 0, VT_BSTR ) );
  Retval = m_vt.bstrVal;
  m_vt.bstrVal = NULL;
  VariantClear( &m_vt );

  return Retval;

}

void
CleanupWorker::LogonIfRequired()
{

    // Don't logon if the path isn't a UNC path
    // or the user name is blank

    if ( ((WCHAR*)m_VDirPath)[0] != L'\\' ||
         ((WCHAR*)m_VDirPath)[1] != L'\\' ||
         *(WCHAR*)m_UNCUsername == L'\0' )
        return; // no logon required

    // crack the user name into a user and domain
    
    WCHAR *UserName     = (WCHAR*)m_UNCUsername;
    WCHAR *DomainName   = NULL;

    WCHAR *p = UserName;
    while(*p != L'\0')
    {
        if(*p == L'\\')
        {
            *p = L'\0';
            p++;
            //
            // first part is domain
            // second is user.
            //
            DomainName  = UserName;
            UserName    = p;
            break;
        }
        p++;
    }

    if ( !LogonUser(
            UserName,
            DomainName,
            (WCHAR*)m_UNCPassword,
            LOGON32_LOGON_BATCH,
            LOGON32_PROVIDER_DEFAULT,
            &m_UserToken ) )
        {

        if ( GetLastError() == ERROR_LOGON_TYPE_NOT_GRANTED )
            {


            if ( !LogonUser(
                    UserName,
                    DomainName,
                    (WCHAR*)m_UNCPassword,
                    LOGON32_LOGON_INTERACTIVE,
                    LOGON32_PROVIDER_DEFAULT,
                    &m_UserToken ) )
                {

                throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

                }

             }

        }


    if ( !ImpersonateLoggedOnUser( m_UserToken ) )
        throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

    
}

void 
CleanupWorker::DoIt()
{

    m_ADSIPath = ConvertObjectPathToADSI( m_Path );

    try
    {
        THROW_COMERROR( ADsGetObject( m_ADSIPath, __uuidof(*m_VDir), (void**)&m_VDir ) );

        if ( m_GuidString )
           {

           BSTR BSTRGuid = GetBSTRProp( (BSTR)L"BITSCleanupWorkItemKey" );
           int Result = wcscmp( (LPWSTR)BSTRGuid, m_GuidString );

           SysFreeString( BSTRGuid );

           if ( Result != 0 )
              throw ComError( E_ADS_UNKNOWN_OBJECT );

           }

    }
    catch( ComError Error )
    {
        
        if ( ( Error.m_Hr == E_ADS_UNKNOWN_OBJECT ) ||
			 ( Error.m_Hr == HRESULT_FROM_WIN32( ERROR_PATH_NOT_FOUND ) ) ||
          ( Error.m_Hr == E_ADS_PROPERTY_NOT_FOUND ) )
            {
            // Somehow the virtual directory was deleted, but the 
            // task scheduler work item wasn't.  Try to delete it now.

            ITaskScheduler *TaskScheduler;
            if ( SUCCEEDED( ConnectToTaskScheduler( NULL, &TaskScheduler ) ) )
                {
                TaskScheduler->Delete( m_WorkItemName );
                TaskScheduler->Release();
                }

            }

        throw;
    }

    THROW_COMERROR( m_VDir->Get( (BSTR)L"BITSUploadEnabled", &m_vt ) );
    THROW_COMERROR( VariantChangeType( &m_vt, &m_vt, 0, VT_BOOL ) );

    if ( !m_vt.boolVal ) // Uploads arn't enabled on this directory
        return;

    THROW_COMERROR( m_VDir->Get( (BSTR)L"BITSSessionTimeout", &m_vt ) );
    THROW_COMERROR( VariantChangeType( &m_vt, &m_vt, 0, VT_BSTR ) );

    if ( L'-' == *m_vt.bstrVal )
        return; // do not run cleanup in this directory since cleanup has been disabled 

    UINT64 CleanupSeconds;
    if ( 1 != swscanf( (WCHAR*)m_vt.bstrVal, L"%I64u", &CleanupSeconds ) )
        return;

    if (  CleanupSeconds > ( 0xFFFFFFFFFFFFFFFF / NanoSec100PerSec ) )
        m_CleanupThreshold = 0xFFFFFFFFFFFFFFFF; // overflow case
    else
        m_CleanupThreshold = CleanupSeconds * NanoSec100PerSec;

    m_VDirPath          = GetBSTRProp( (BSTR)L"Path" );
    m_SessionDirectory  = GetBSTRProp( (BSTR)L"BITSSessionDirectory" );
    m_UNCUsername       = GetBSTRProp( (BSTR)L"UNCUserName" );
    m_UNCPassword       = GetBSTRProp( (BSTR)L"UNCPassword" );

    LogonIfRequired();

    RemoveConnectionsFromTree( (WCHAR*)m_VDirPath, false );
}

void Cleanup_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpszCmdLine, int nCmdShow )
{
    int NumArgs;

    LPWSTR * CommandArgs =
        CommandLineToArgvW(
            lpszCmdLine,
            &NumArgs );

    if ( !CommandArgs )
        return;


    if ( FAILED( CoInitializeEx( NULL, COINIT_MULTITHREADED ) ) )
        return;

    if ( NumArgs != 2 && NumArgs != 3 )
        return;

    LPWSTR Path         = CommandArgs[0];
    LPWSTR WorkItemName = CommandArgs[1];
    LPWSTR GuidString   = NumArgs == 3 ? CommandArgs[2] : NULL;

    try
    {
        CleanupWorker Worker( hwndStub, Path, WorkItemName, GuidString );
        Worker.DoIt();
    }
    catch( ComError Error )
    {
    }

    CoUninitialize( );
    GlobalFree( CommandArgs );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\inc\qmgrlib.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    qmgrlib.h

Abstract :

    External header for library functions.

Author :

Revision History :

 ***********************************************************************/

#pragma once

#include<nt.h>
#include<ntrtl.h>
#include<nturtl.h>
#include <windows.h>
#include <sddl.h>
#include <unknwn.h>
#include <memory>
#include <tchar.h>
#include <strsafe.h>
#include "bitsverp.h"

// strsafe.h deprecates the shlwapi string functions
//
#define NO_SHLWAPI_STRFCNS

//
// Version Control
//

enum PLATFORM_PRODUCT_VERSION
{
   WIN95_PLATFORM,
   WIN98_PLATFORM,
#if defined( BITS_V12_ON_NT4 )
   NT4_PLATFORM,
#endif
   WINDOWS2000_PLATFORM,
   WINDOWSXP_PLATFORM
};

extern PLATFORM_PRODUCT_VERSION g_PlatformVersion;
extern bool bIsWin9x;

BOOL DetectProductVersion();


//
// Limits
//

const size_t INT_DIGITS = 10;
const size_t INT64_DIGITS = 20;

const SIZE_T MAX_DISPLAYNAME        = 255;
const SIZE_T MAX_DESCRIPTION        = 1023;
const SIZE_T MAX_NOTIFY_CMD_LINE    = 4000;
const SIZE_T MAX_PROXYLIST          = 32767;
const SIZE_T MAX_PROXYBYPASSLIST    = 32767;

//
// Metadata overhead
//

const SIZE_T METADATA_PADDING                  = 4096;  // Padding on metadata for small changes such as timers
const SIZE_T METADATA_PREALLOC_SIZE          = 262144;  // Size to prealloc before a change
const SIZE_T METADATA_FOR_FILE                 = 4096;  // Initial file size.

const UINT MAX_GUID_CHARS=40;
typedef WCHAR GUIDSTR[MAX_GUID_CHARS];

template <class T>
inline void SafeRelease( T * & p ) { if (NULL != (p)) { p->Release(); p = NULL; } }

using namespace std;

template<HANDLE InvalidValue=NULL>
class auto_HANDLE
    {
public:
    auto_HANDLE(HANDLE Handle = InvalidValue)
    : m_Handle(Handle) {}
    auto_HANDLE(auto_HANDLE<InvalidValue>& Other)
    : m_Handle(Other.release()) {}
    auto_HANDLE<InvalidValue>& operator=( HANDLE Handle )
    {
        if (InvalidValue != m_Handle)
            {
            CloseHandle(m_Handle);
            }
        m_Handle = Handle;
        return *this;
    }
    auto_HANDLE<InvalidValue>& operator=(auto_HANDLE<InvalidValue>& Other)
    {
        if (this != &Other)
            {
            m_Handle = Other.release();
            }
        return *this;
    }
    ~auto_HANDLE()
    {
        if (InvalidValue != m_Handle)
            CloseHandle(m_Handle);
    }
    HANDLE get() const
    {
        return m_Handle;
    }

    HANDLE * GetWritePointer()
    {
        return &m_Handle;
    }

    HANDLE release()
    {
        HANDLE Handle = m_Handle;
        m_Handle = InvalidValue;
        return Handle;
    }
private:
    HANDLE m_Handle;
    };
typedef auto_HANDLE<INVALID_HANDLE_VALUE> auto_FILE_HANDLE;

class SidHandle
{
    PSID    m_pValue;
    long *  m_pRefs;

public:

    PSID operator->()  { ASSERT( *m_pRefs > 0); return m_pValue; }

    SidHandle( PSID value=NULL ) : m_pValue( value ), m_pRefs( new long(1) )
    {
    }

    SidHandle( const SidHandle & r ) : m_pValue( r.m_pValue ), m_pRefs( r.m_pRefs )
    {
        InterlockedIncrement( m_pRefs );
    }

    ~SidHandle()
    {
        if ( InterlockedDecrement( m_pRefs ) == 0 )
            {
            delete m_pRefs;
            delete m_pValue;
            m_pRefs = NULL;
            m_pValue = NULL;
            }
    }

    SidHandle & operator=( const SidHandle & r );

    bool operator==( const SidHandle & r ) const
    {
        // this odd construction converts BOOL to bool.
        //
        return !!EqualSid( get(), r.get());
    }

    bool operator!=( const SidHandle & r ) const
    {
        return !((*this) == r);
    }

    PSID get() const  { ASSERT( *m_pRefs > 0); return m_pValue; }

};

template<class T>
class GenericStringHandle
{

    struct StringData
    {
        SIZE_T        m_Count;
        long          m_Refs;
        T             m_Data[1];
    };

    static StringData s_EmptyString;

    StringData *m_Value;

    void NewString( const T *String )
    {
       if ( !String )
           {
           m_Value = Alloc( 0 );
           return;
           }

       size_t Length = wcslen( String );
       m_Value = Alloc( Length );

       THROW_HRESULT( StringCchCopy( m_Value->m_Data, Length+1, String ));
    }

    static StringData * Alloc( SIZE_T max )
    {
        if (max == 0)
            {
            InterlockedIncrement( &s_EmptyString.m_Refs );
            return &s_EmptyString;
            }

        StringData * Value;

        Value = (StringData*) new char[sizeof(StringData)+(max*sizeof(T))];
        Value->m_Count = max;
        Value->m_Refs  = 1;

        Value->m_Data[0] = L'\0';

        return Value;
    }

    StringData * RefIt() const
    {
        InterlockedIncrement( &m_Value->m_Refs );
        return m_Value;
    }

    void FreeIt()
    {
        if ( InterlockedDecrement( &m_Value->m_Refs ) == 0 )
            delete m_Value;
    }

public:

    GenericStringHandle( const T *String = NULL )
    {
        NewString( String );
    }

    GenericStringHandle( const GenericStringHandle & Other ) :
        m_Value( Other.RefIt() )
    {
    }

    ~GenericStringHandle()
    {
        FreeIt();
    }

    GenericStringHandle & operator=( const GenericStringHandle & r )
    {
        FreeIt();
        m_Value = r.RefIt();
        return *this;
    }

    void operator=( const T * r )
    {
        FreeIt();
        NewString( r );
    }

    SIZE_T Size() const
    {
        return m_Value->m_Count;
    }

    operator const T *() const
    {
        return m_Value->m_Data;
    }

    //
    // Force a new copy of the data to be made.
    //
    GenericStringHandle Copy()
    {
        GenericStringHandle temp = m_Value->m_Data;
        return temp;
    }

    bool operator <( const GenericStringHandle & r ) const
    {
        if ( m_Value == r.m_Value)
            return false;
        return (wcscmp( this->m_Value->m_Data, r.m_Value->m_Data ) < 0);
    }

    T & operator[] ( const SIZE_T offset )
    {
        if (offset > Size())
            {
            THROW_HRESULT( E_INVALIDARG );
            }

        return m_Value->m_Data[ offset ];
    }

    void Truncate( SIZE_T max )
    {
        if (Size() <= max)
            {
            return;
            }

        //
        // Create the new value string.
        //
        StringData * NewValue = Alloc( max );

        StringCchCopy( NewValue->m_Data, max+1, m_Value->m_Data );

        //
        // Replace the current value with the new value.
        //
        FreeIt();
        m_Value = NewValue;
    }

    T * GetToken( T * CursorIn, const T Separators[], T ** CursorOut );
};

typedef GenericStringHandle<TCHAR> StringHandleT;
typedef GenericStringHandle<CHAR> StringHandleA;
typedef GenericStringHandle<WCHAR> StringHandle;

inline WCHAR *
GenericStringHandle<WCHAR>::GetToken( WCHAR * Cursor, const WCHAR Separators[], WCHAR **pCursor )
{
    if (Cursor == NULL)
        {
        Cursor = m_Value->m_Data;
        }

    WCHAR * Token = NULL;

    if (Cursor < m_Value->m_Data + m_Value->m_Count)
        {
        Token = wcstok( Cursor, Separators );
        }

    if (Token)
        {
        *pCursor = Token + wcslen(Token) + 1;
        }
    else
        {
        *pCursor = m_Value->m_Data + m_Value->m_Count;
        }

    return Token;
}

typedef auto_ptr<WCHAR> CAutoStringW;
typedef auto_ptr<TCHAR> CAutoStringT;
typedef auto_ptr<char> CAutoStringA;
typedef  CAutoStringW CAutoString;

//
// PSID does not have an obvious ordering of the type required by the MAP classes.
// So we define one here.
//
class CSidSorter
{
public:

    bool operator()( const SidHandle & psid1, const SidHandle & psid2 ) const;
};

PSID DuplicateSid( PSID _Sid );

//---------------------------------------------

enum FILE_DOWNLOAD_RESULT
{
    QM_IN_PROGRESS,
    QM_FILE_ABORTED,
    QM_FILE_DONE,
    QM_FILE_TRANSIENT_ERROR,
    QM_FILE_FATAL_ERROR,
    QM_SERVER_FILE_CHANGED
};
/*
 The source field is divided into regions, like NTSTATUS and HRESULT codes.
 The lowest-order bit is bit 0; the highest is bit 31.

  bit 31:     reserved, MBZ

  bits 30-29: component

                00 = unknown
                01 = queue manager
                10 = transport
                11 =

  bits 28-16: sub-component

                for queue manager:  0 = unknown
                                    1 = local file handling
                                    2 = queue management
                                    3 = notification

                for transport:      0 = unknown
                                    1 = HTTP
                                    2 = HTTPS
                                    3 = FTP
                                    4 = SMB
                                    5 = DAV

  bits 15-0:  defined by sub-component

                for HTTP:           0 = unknown
                                    1 = client connection
                                    2 = server connection
                                    3 = server file handling

*/

#define COMPONENT_MASK  (0x3    << 30)
#define SUBCOMP_MASK    (0x3fff << 16)
#define FINAL_MASK      (0xffff << 0 )

#define COMPONENT_QMGR  (0x1 << 30)
#define COMPONENT_TRANS (0x2 << 30)

#define SUBCOMP_QMGR_FILE       (0x1 << 16)
#define SUBCOMP_QMGR_QUEUE      (0x2 << 16)
#define SUBCOMP_QMGR_NOTIFY     (0x3 << 16)
#define SUBCOMP_QMGR_CACHE      (0x4 << 16)

#define SUBCOMP_TRANS_HTTP      (COMPONENT_TRANS | (0x1 << 16))
#define SUBCOMP_TRANS_HTTPS     (COMPONENT_TRANS | (0x2 << 16))
#define SUBCOMP_TRANS_FTP       (COMPONENT_TRANS | (0x3 << 16))

enum ERROR_SOURCE
{
    SOURCE_NONE             = 0,
    SOURCE_QMGR_FILE        = (COMPONENT_QMGR | SUBCOMP_QMGR_FILE   | 0x0),
    SOURCE_QMGR_QUEUE       = (COMPONENT_QMGR | SUBCOMP_QMGR_QUEUE  | 0x0),
    SOURCE_QMGR_NOTIFY      = (COMPONENT_QMGR | SUBCOMP_QMGR_NOTIFY | 0x0),

    SOURCE_HTTP_UNKNOWN     = (COMPONENT_TRANS | SUBCOMP_TRANS_HTTP | 0x0),
    SOURCE_HTTP_CLIENT_CONN = (COMPONENT_TRANS | SUBCOMP_TRANS_HTTP | 0x1),
    SOURCE_HTTP_SERVER      = (COMPONENT_TRANS | SUBCOMP_TRANS_HTTP | 0x2),
    SOURCE_HTTP_SERVER_FILE = (COMPONENT_TRANS | SUBCOMP_TRANS_HTTP | 0x3),
    SOURCE_HTTP_SERVER_APP  = (COMPONENT_TRANS | SUBCOMP_TRANS_HTTP | 0x4)
};

enum ERROR_STYLE
{
    ERROR_STYLE_NONE        = 0,
    ERROR_STYLE_HRESULT     = 1,
    ERROR_STYLE_WIN32       = 2,
    ERROR_STYLE_HTTP        = 3
};

struct QMErrInfo
{
    FILE_DOWNLOAD_RESULT result;

    UINT64          Code;
    ERROR_STYLE     Style;
    ERROR_SOURCE    Source;
    wchar_t *       Description;

    QMErrInfo()
    {
        result = QM_FILE_DONE;
        Clear();
    }

    QMErrInfo(
        ERROR_SOURCE  Source,
        ERROR_STYLE   Style,
        UINT64        Code,
        char *        comment = 0
        );

    void
    Set(
        ERROR_SOURCE  Source,
        ERROR_STYLE   Style,
        UINT64        Code,
        char *        comment = 0
        );

    void Clear()
    {
        Source   = SOURCE_NONE;
        Style    = ERROR_STYLE_NONE;
        Code     = 0;
        Description = NULL;
    }

    bool IsSet()
    {
        return (Style != ERROR_STYLE_NONE);
    }

    void Log();

    bool operator==( const QMErrInfo & err )
    {
        if (Source == err.Source &&
            Style  == err.Style  &&
            Code   == err.Code)
            {
            return true;
            }

        return false;
    }

    bool operator!=( const QMErrInfo & err )
    {
        if (*this == err)
            {
            return false;
            }

        return true;
    }
};

//---------------------------------------------

const UINT64 NanoSec100PerSec = 10000000;    //no of 100 nanosecs per sec

const TCHAR * const C_BITS_USER_AGENT = _T("Microsoft BITS/") VER_PRODUCTVERSION_WSTRING;

// Registry keys
const TCHAR * const  C_QMGR_REG_KEY = _T("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\BITS");

// Registry Value(REG_SZ).
// Point to where to load the upgraded DLL
const TCHAR * const  C_QMGR_SERVICEDLL = _T("ServiceDLL");

// Registry Values(REG_DWORD/seconds)
const TCHAR * const  C_QMGR_STATE_INDEX            = _T("StateIndex");
const TCHAR * const  C_QMGR_JOB_INACTIVITY_TIMEOUT = _T("JobInactivityTimeout");
const TCHAR * const  C_QMGR_TIME_QUANTA_LENGTH     = _T("TimeQuantaLength");
const TCHAR * const  C_QMGR_NO_PROGRESS_TIMEOUT    = _T("JobNoProgressTimeout");
const TCHAR * const  C_QMGR_MINIMUM_RETRY_DELAY    = _T("JobMinimumRetryDelay");

// Logging registry Values(REG_DWORD)
const TCHAR * const C_QMGR_LOGFILE_SIZE            = _T("LogFileSize"); // In MB
const TCHAR * const C_QMGR_LOGFILE_FLAGS           = _T("LogFileFlags");
const TCHAR * const C_QMGR_LOGFILE_MINMEMORY       = _T("LogFileMinMemory"); // In MB

// default values
const UINT32 C_QMGR_JOB_INACTIVITY_TIMEOUT_DEFAULT  = (60ui64 * 60ui64 * 24ui64 * 90ui64); // 90 days
const UINT32 C_QMGR_TIME_QUANTA_LENGTH_DEFAULT      = (5 * 60); // 5 minutes
const UINT32 C_QMGR_NO_PROGRESS_TIMEOUT_DEFAULT     = (14 * 24 * 60 * 60); //14 days
const UINT32 C_QMGR_MINIMUM_RETRY_DELAY_DEFAULT     = (10 * 60); // ten minutes

// Logging default values
const UINT32 C_QMGR_LOGFILE_SIZE_DEFAULT            = 1;

#if DBG
// Debug/Non-ship mode
// everything except 0x010 - Ref Counts and 0x020 - State File
//
const UINT32 C_QMGR_LOGFILE_FLAGS_DEFAULT           = 0xFFCF;
#else
const UINT32 C_QMGR_LOGFILE_FLAGS_DEFAULT           = 0;
#endif

const UINT32 C_QMGR_LOGFILE_MINMEMORY_DEFAULT       = 120;

// Policy keys
const TCHAR * const  C_QMGR_POLICY_REG_KEY = _T("Software\\Policies\\Microsoft\\Windows\\BITS");

// Policy values
const TCHAR * const  C_QMGR_POLICY_JOB_INACTIVITY_TIMEOUT = _T("JobInactivityTimeout");

// Special directories
const TCHAR * const  C_QMGR_DIRECTORY = _T("\\Microsoft\\Network\\Downloader\\");

const wchar_t NullString[] = L"(null)";



// cfreg.cpp - Functions to handle registry keys
HRESULT GetRegStringValue(LPCTSTR lpszValueName, LPTSTR lpszBuffer, int iBufferSize);
HRESULT SetRegStringValue(LPCTSTR lpszValueName, LPCTSTR lpszNewValue);
HRESULT DeleteRegStringValue(LPCTSTR lpszValueName);
HRESULT GetRegDWordValue(LPCTSTR lpszValueName, LPDWORD pdwValue);
HRESULT SetRegDWordValue(LPCTSTR lpszValueName, DWORD dwValue);

// service.cxx
HRESULT SetServiceStartup( bool bAutoStart );

// helpers.cpp
BOOL QMgrFileExists(LPCTSTR szFile);
FILETIME GetTimeAfterDelta( UINT64 uDelta );
BOOL IsConnected();

LPCWSTR TruncateString( LPCWSTR String, SIZE_T MaxLength, auto_ptr<WCHAR> & AutoPointer );

//
// The standard error class.  This is the only type of C++ exception that
// BITS functions should throw.
//
class ComError
{
    HRESULT m_error;

public:

    ComError(HRESULT NewErrorCode) : m_error ( NewErrorCode ) {}

    HRESULT Error() { return m_error; }

};

inline void THROW_HRESULT( HRESULT hr )
{
    if (FAILED(hr))
        {
        throw ComError( hr );
        }
}

inline void ThrowLastError()
{
    throw ComError( HRESULT_FROM_WIN32( GetLastError() ));
}

////////////////////////////////////////////////////////////////////////
//
//   Global info class
//
////////////////////////////////////////////////////////////////////////


class GlobalInfo
{
private:

    GlobalInfo( TCHAR *QmgrDirectory,
                LARGE_INTEGER PerfamceCounterFrequency,
                HKEY QmgrRegistryRoot,
                UINT64 JobInactivityTimeout,
                UINT64 TimeQuantaLength,
                UINT32 DefaultNoProgressTimeout,
                UINT32 DefaultMinimumRetryDelay,
                SECURITY_DESCRIPTOR *MetadataSecurityDescriptor,
                DWORD MetadataSecurityDescriptorLength,
                SidHandle AdministratorsSid,
                SidHandle LocalSystemSid,
                SidHandle NetworkUsersSid
                );

    ~GlobalInfo();

public:

    static DWORD RegGetDWORD( HKEY hKey, const TCHAR * pValue, DWORD dwDefault );

    const TCHAR * const m_QmgrDirectory;
    const LARGE_INTEGER m_PerformanceCounterFrequency;
    const HKEY m_QmgrRegistryRoot;
    const UINT64 m_JobInactivityTimeout;
    const UINT64 m_TimeQuantaLength;
    const UINT32 m_DefaultNoProgressTimeout;
    const UINT32 m_DefaultMinimumRetryDelay;
    const SECURITY_DESCRIPTOR * const m_MetadataSecurityDescriptor;
    const DWORD m_MetadataSecurityDescriptorLength;
    const SidHandle m_AdministratorsSid;
    const SidHandle m_LocalSystemSid;
    const SidHandle m_NetworkUsersSid;

    static HRESULT Init(void);
    static HRESULT Uninit(void);

};

extern class GlobalInfo *g_GlobalInfo;

//
// variables to keep track of service state
//
enum MANAGER_STATE
{
    MANAGER_INACTIVE,
    MANAGER_ACTIVE,
    MANAGER_TERMINATING
};

extern MANAGER_STATE g_ServiceState;
extern long          g_ServiceInstance;
extern DWORD         g_LastServiceControl;

//
// Jump to a label on failure.  Assumes an HRESULT "hr" and a label "Cleanup".
//
#define CLEANUP_ON_FAILURE( x ) \
                hr = x; \
                if (FAILED(hr)) \
                    { \
                    goto Cleanup; \
                    }

#define RETURN_HRESULT( x ) \
            { \
            HRESULT _hr_ = (x); \
            if (FAILED(_hr_)) \
                { \
                return _hr_; \
                } \
            }

#define GFA_FAILED   DWORD(-1)

inline BOOL FileExists( LPWSTR szFile )
{
    DWORD dwAttr = GetFileAttributes( szFile );

    if( GFA_FAILED == dwAttr )
        return FALSE;

    return (BOOL)( !(dwAttr & FILE_ATTRIBUTE_DIRECTORY) );
}

inline UINT64 FILETIMEToUINT64( const FILETIME & FileTime )
{
    ULARGE_INTEGER LargeInteger;
    LargeInteger.HighPart = FileTime.dwHighDateTime;
    LargeInteger.LowPart = FileTime.dwLowDateTime;
    return LargeInteger.QuadPart;
}

inline FILETIME UINT64ToFILETIME( UINT64 Int64Value )
{
    ULARGE_INTEGER LargeInteger;
    LargeInteger.QuadPart = Int64Value;

    FILETIME FileTime;
    FileTime.dwHighDateTime = LargeInteger.HighPart;
    FileTime.dwLowDateTime = LargeInteger.LowPart;

    return FileTime;
}

//------------------------------------------------------------------------
//
// NT security
//
//------------------------------------------------------------------------

SidHandle GetThreadClientSid();

HRESULT
ImpersonateSid(
    PSID sid
    );

BOOL
SidToString(
    PSID sid,
    wchar_t buffer[],
    USHORT bytes
    );

HRESULT
IsRemoteUser();

HRESULT
IsAdministratorUser();

HRESULT
DenyRemoteAccess();

HRESULT
DenyNonAdminAccess();

PSID DuplicateSid( PSID _Sid );

//
// Copy of RtlSecureZeroMemory() from the .Net Server tree.
//
FORCEINLINE
PVOID
MySecureZeroMemory(
    IN PVOID ptr, 
    IN SIZE_T cnt
    ) 
{
    volatile char *vptr = (volatile char *)ptr;
    while (cnt) {
        *vptr = 0;
        vptr++;
        cnt--;
    }
    return ptr;
}


//
// allows CreateInstanceInSession to choose an arbitrary session.
//
#define ANY_SESSION  DWORD(-1)

HRESULT
CreateInstanceInSession(
    REFCLSID clsid,
    REFIID   iid,
    DWORD    session,
    void **  pif
    );

HRESULT
SetStaticCloaking(
    IUnknown *pUnk
    );

HRESULT
ApplyIdentityToInterface(
  IUnknown *pUnk,
  PSID sid
  );

struct IBackgroundCopyCallback;
struct IBackgroundCopyCallback1;

HRESULT
CreateUserCallback(
  CLSID clsid,
  PSID sid,
  IBackgroundCopyCallback **pICB
  );

HRESULT
CreateOldUserCallback(
  CLSID clsid,
  PSID sid,
  IBackgroundCopyCallback1 **pICB
  );

HRESULT
SessionLogonCallback(
    DWORD SessionId
    );

HRESULT
SessionLogoffCallback(
    DWORD SessionId
    );

DWORD
DeviceEventCallback(
    DWORD dwEventType,
    LPVOID lpEventData
    );


BOOL Log_Init();
void Log_StartLogger();
void Log_Close();

HRESULT GlobalInit();
HRESULT GlobalUninit();

HRESULT InitQmgr();
HRESULT UninitQmgr();


const GUID BITSCtrlGuid = {0x4a8aaa94,0xcfc4,0x46a7,{0x8e,0x4e,0x17,0xbc,0x45,0x60,0x8f,0x0a}};

#define WPP_CONTROL_GUIDS \
    WPP_DEFINE_CONTROL_GUID(CtlGuid,(4a8aaa94,cfc4,46a7,8e4e,17bc45608f0a),  \
        WPP_DEFINE_BIT(LogFlagInfo)                 \
        WPP_DEFINE_BIT(LogFlagWarning)              \
        WPP_DEFINE_BIT(LogFlagError)                \
        WPP_DEFINE_BIT(LogFlagFunction)             \
        WPP_DEFINE_BIT(LogFlagRefCount)             \
        WPP_DEFINE_BIT(LogFlagSerialize)            \
        WPP_DEFINE_BIT(LogFlagDownload)             \
        WPP_DEFINE_BIT(LogFlagTask)                 \
        WPP_DEFINE_BIT(LogFlagLock)                 \
        WPP_DEFINE_BIT(LogFlagService)              \
        )


#define LogLevelEnabled(flags) WPP_LEVEL_ENABLED(flags)                                                       \

LONG ExternalFuncExceptionFilter( struct _EXCEPTION_POINTERS *ExceptionInfo );

//
// We keep track of COM calls because we can't delete our objects at shutdown
// until all the active calls have stopped referring to them.
//
extern long g_cCalls;

inline void IncrementCallCount()
{
    InterlockedIncrement(&g_cCalls);
}

inline void DecrementCallCount()
{
    InterlockedDecrement(&g_cCalls);
}

inline long ActiveCallCount()
{
    return g_cCalls;
}

//
// A simple helper class to keep track of our call count.
//
class DispatchedCall
{
public:
    DispatchedCall()  { IncrementCallCount(); }
    ~DispatchedCall() { DecrementCallCount(); }
};

//
// Each member function of our public COM interfaces has an external
// and an internal version.  The external version is simply
//    {
//        EXTERNAL_FUNC_WRAP( internal-version );
//    }
// This captures any exceptions in a way that can be reported by the OfficeWatson
// error-reporting apparatus.
// It also checks for service shutdown.
//
HRESULT
CheckServerInstance(
    long ObjectServiceInstance
    );

#define EXTERNAL_FUNC_WRAP( call_parent )                       \
                                                                \
    __try                                                       \
        {                                                       \
        RETURN_HRESULT( CheckServerInstance( m_ServiceInstance )); \
                                                                \
        HRESULT hr = call_parent ;                              \
                                                                \
        DecrementCallCount();                                   \
        return hr;                                              \
        }                                                       \
    __except( ExternalFuncExceptionFilter( GetExceptionInformation() ) ) \
        {                                                       \
        DecrementCallCount();                                   \
        return RPC_E_SERVERFAULT;                               \
        }                                                       \

//
// IUnknown member functions use these alternate macros.
//
#define BEGIN_EXTERNAL_FUNC                                     \
    __try                                                       \
        {                                                       \

#define END_EXTERNAL_FUNC                                       \
        }                                                       \
    __except( ExternalFuncExceptionFilter( GetExceptionInformation() ) ) \
        {                                                       \
        return RPC_E_SERVERFAULT;                               \
        }                                                       \


StringHandle
BITSCrackFileName(
    const WCHAR * RawFileName,
    StringHandle & ReturnFileName
    );

StringHandle
BITSCreateTempFile(
    StringHandle Directory
    );

HRESULT
BITSCheckFileWritability(
    LPCWSTR name
    );

StringHandle
CombineUrl(
    LPCWSTR BaseUrl,
    LPCWSTR RelativeUrl,
    DWORD Flags
    );

LPWSTR MidlCopyString( LPCWSTR source, size_t Length  = -1);

inline LPWSTR MidlCopyString( StringHandle source )
{
    return MidlCopyString( source, source.Size()+1 );
}

LPWSTR CopyString( LPCWSTR source, size_t Length  = -1);

inline LPWSTR CopyString( StringHandle source )
{
    return CopyString( source, source.Size()+1 );
}

inline bool operator==( const FILETIME left, const FILETIME right )
{
    return ((left.dwLowDateTime  == right.dwLowDateTime) &&
            (left.dwHighDateTime == right.dwHighDateTime));
}

inline bool operator!=( const FILETIME left, const FILETIME right )
{
    return !(left == right);
}

bool IsServiceShuttingDown();

bool IsAnyDebuggerPresent();

bool InitCompilerLibrary();
bool UninitCompilerLibrary();

#if defined(BITS_V12_ON_NT4)

extern ULONG BITSFlags;
void Log( const CHAR *Prefix, const CHAR *Format, va_list ArgList );

const DWORD LogFlagInfo         = 0;
const DWORD LogFlagWarning      = 1;
const DWORD LogFlagError        = 2;
const DWORD LogFlagFunction     = 4;
const DWORD LogFlagRefCount     = 8;
const DWORD LogFlagRef          = LogFlagRefCount;
const DWORD LogFlagSerialize    = 16;
const DWORD LogFlagSerial       = LogFlagSerialize;
const DWORD LogFlagDownload     = 32;
const DWORD LogFlagDl           = LogFlagDownload;
const DWORD LogFlagTask         = 64;
const DWORD LogFlagLock         = 128;
const DWORD LogFlagService      = 256;
const DWORD LogFlagPublicApiBegin = LogFlagFunction;
const DWORD LogFlagPublicApiEnd   = LogFlagFunction;

#define DEFINE_SIMPLE_LOG_FUNCT( flag, prefix )                    \
inline void Log##flag##( const char *format, ...)                  \
{                                                                  \
    if ( ! ( BITSFlags & ~LogFlag##flag ) )                        \
        return;                                                    \
    va_list marker;                                                \
    va_start( marker, format );                                    \
    Log( prefix, format, marker );                                 \
}                                                                  \

DEFINE_SIMPLE_LOG_FUNCT( Info,              " INFO        :" )
DEFINE_SIMPLE_LOG_FUNCT( Warning,           " WARNING     :" )
DEFINE_SIMPLE_LOG_FUNCT( Error,             " ERROR       :" )
DEFINE_SIMPLE_LOG_FUNCT( PublicApiBegin,    " FUNC_BEGIN  :" )
DEFINE_SIMPLE_LOG_FUNCT( PublicApiEnd,      " FUNC_END    :" )
DEFINE_SIMPLE_LOG_FUNCT( Ref,               " REF         :" )
DEFINE_SIMPLE_LOG_FUNCT( Lock,              " LOCK        :" )
DEFINE_SIMPLE_LOG_FUNCT( Task,              " TASK        :" )
DEFINE_SIMPLE_LOG_FUNCT( Service,           " SERVICE     :" )
DEFINE_SIMPLE_LOG_FUNCT( Dl,                " DOWNLOAD    :" )
DEFINE_SIMPLE_LOG_FUNCT( Serial,            " SERIALIZE   :" )

BOOL
BITSAltGetFileSizeEx(
   HANDLE hFile,              // handle to file
   PLARGE_INTEGER lpFileSize  // file size
   );

BOOL
BITSAltSetFilePointerEx(
    HANDLE hFile,                    // handle to file
    LARGE_INTEGER liDistanceToMove,  // bytes to move pointer
    PLARGE_INTEGER lpNewFilePointer, // new file pointer
    DWORD dwMoveMethod               // starting point
    );

BOOL
BITSAltConvertSidToStringSidW(
    IN  PSID     Sid,
    OUT LPWSTR  *StringSid
    );

BOOL
BITSAltConvertStringSidToSidW(
    IN LPCWSTR  StringSid,
    OUT PSID   *Sid
    );

BOOL
BITSAltCheckTokenMembership(
    IN HANDLE TokenHandle OPTIONAL,
    IN PSID SidToCheck,
    OUT PBOOL IsMember
    );

SERVICE_STATUS_HANDLE
BITSAltRegisterServiceCtrlHandlerExW(
  LPCTSTR lpServiceName,                // name of service
  LPHANDLER_FUNCTION_EX lpHandlerProc,  // handler function
  LPVOID lpContext                      // user data
);

#define GetFileSizeEx BITSAltGetFileSizeEx
#define SetFilePointerEx BITSAltSetFilePointerEx
#define ConvertSidToStringSidW BITSAltConvertSidToStringSidW
#define ConvertStringSidToSidW BITSAltConvertStringSidToSidW
#define CheckTokenMembership  BITSAltCheckTokenMembership
#define RegisterServiceCtrlHandlerExW BITSAltRegisterServiceCtrlHandlerExW

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\inc\inethttp.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    inethttp.h

Abstract:

    This header maps some wininet API to winhttp

--*/

// API mappings

#define INTERNET_MAX_URL_LENGTH  2200
#define INTERNET_MAX_HOST_NAME_LENGTH   256
#define INTERNET_RFC1123_BUFSIZE    WINHTTP_TIME_FORMAT_BUFSIZE
#define INTERNET_RFC1123_FORMAT     0

inline BOOL __stdcall
InternetTimeFromSystemTime(
    IN  CONST SYSTEMTIME *pst,  // input GMT time
    IN  DWORD dwRFC,            // RFC format
    OUT LPWSTR lpszTime,        // output string buffer
    IN  DWORD cbTime            // output buffer size
    )
{
    if (cbTime < WINHTTP_TIME_FORMAT_BUFSIZE)
        {
        return ERROR_BUFFER_OVERFLOW;
        }

    return WinHttpTimeFromSystemTime( pst, lpszTime );
}

#define InternetTimeToSystemTime    WinHttpTimeToSystemTime

#define InternetCrackUrl            WinHttpCrackUrl

#define InternetCreateUrl           WinHttpCreateUrl

#define INTERNET_OPEN_TYPE_PRECONFIG        WINHTTP_ACCESS_TYPE_DEFAULT_PROXY
#define INTERNET_OPEN_TYPE_DIRECT           WINHTTP_ACCESS_TYPE_NO_PROXY
#define INTERNET_OPEN_TYPE_PROXY            WINHTTP_ACCESS_TYPE_NAMED_PROXY

#define InternetOpen                WinHttpOpen

#define InternetSetStatusCallback(h, pcb)\
    WinHttpSetStatusCallback(h, pcb, WINHTTP_CALLBACK_FLAG_ALL_NOTIFICATIONS, 0)


#define INTERNET_OPTION_END_BROWSER_SESSION     42

inline BOOL __stdcall
InternetSetOption(
    IN HINTERNET hInternet,
    IN DWORD dwOption,
    IN LPVOID lpBuffer,
    IN DWORD dwBufferLength
    )
{
    if (dwOption == INTERNET_OPTION_END_BROWSER_SESSION)
        {
        return TRUE;
        }

    return WinHttpSetOption( hInternet, dwOption, lpBuffer, dwBufferLength );
}


#define InternetQueryOption         WinHttpQueryOption

#define INTERNET_SERVICE_HTTP   3

inline HINTERNET __stdcall
InternetConnect(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszServerName,
    IN INTERNET_PORT nServerPort,
    IN LPCWSTR lpszUserName OPTIONAL,
    IN LPCWSTR lpszPassword OPTIONAL,
    IN DWORD dwService,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    return WinHttpConnect( hInternet,
                           lpszServerName,
                           nServerPort,
                           0 );
}


inline HINTERNET __stdcall
HttpOpenRequest(
    IN HINTERNET hConnect,
    IN LPCWSTR lpszVerb,
    IN LPCWSTR lpszObjectName,
    IN LPCWSTR lpszVersion,
    IN LPCWSTR lpszReferrer OPTIONAL,
    IN LPCWSTR FAR * lplpszAcceptTypes OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    return WinHttpOpenRequest( hConnect,
                               lpszVerb,
                               lpszObjectName,
                               lpszVersion,
                               lpszReferrer,
                               lplpszAcceptTypes,
                               dwFlags
                               );
}


#define HttpAddRequestHeaders       WinHttpAddRequestHeaders

inline BOOL
HttpSendRequest(
HINTERNET hRequest,
    LPCWSTR pwszHeaders,
    DWORD dwHeadersLength,
    LPVOID lpOptional,
    DWORD dwOptionalLength
    )
{
    BOOL b;

    b = WinHttpSendRequest( hRequest,
                            pwszHeaders,
                            dwHeadersLength,
                            lpOptional,
                            dwOptionalLength,
                            dwOptionalLength,
                            0
                            );
    if (!b)
        {
        return FALSE;
        }

    b = WinHttpReceiveResponse( hRequest, 0 );

    return b;
}

typedef struct _INTERNET_BUFFERS {
    DWORD dwStructSize;                 // used for API versioning. Set to sizeof(INTERNET_BUFFERS)
    struct _INTERNET_BUFFERSW * Next;   // chain of buffers
    LPCWSTR  lpcszHeader;               // pointer to headers (may be NULL)
    DWORD dwHeadersLength;              // length of headers if not NULL
    DWORD dwHeadersTotal;               // size of headers if not enough buffer
    LPVOID lpvBuffer;                   // pointer to data buffer (may be NULL)
    DWORD dwBufferLength;               // length of data buffer if not NULL
    DWORD dwBufferTotal;                // total size of chunk, or content-length if not chunked
    DWORD dwOffsetLow;                  // used for read-ranges (only used in HttpSendRequest2)
    DWORD dwOffsetHigh;
} INTERNET_BUFFERS, * LPINTERNET_BUFFERS;

#define HSR_INITIATE 8

inline BOOL __stdcall
HttpSendRequestEx(
    IN HINTERNET hRequest,
    IN LPINTERNET_BUFFERS lpBuffersIn OPTIONAL,
    OUT LPINTERNET_BUFFERS lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    if (dwFlags != HSR_INITIATE ||
        lpBuffersOut)
        {
        return ERROR_CALL_NOT_IMPLEMENTED;
        }

    return WinHttpSendRequest( hRequest,
                               NULL,
                               0,
                               NULL,
                               WINHTTP_NO_REQUEST_DATA,
                               lpBuffersIn->dwBufferTotal,
                               0
                               );
}

inline  BOOL __stdcall
HttpEndRequest(
    IN HINTERNET hRequest,
    OUT INTERNET_BUFFERS * lpBuffersOut OPTIONAL,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    if (lpBuffersOut || dwFlags)
        {
        return ERROR_CALL_NOT_IMPLEMENTED;
        }

    return WinHttpReceiveResponse( hRequest, 0 );
}


#define InternetWriteFile(h,p,cb,pcb) WinHttpWriteData(h,p,cb,pcb)


#define HttpQueryInfo(h,dw,pb,pcb,ndx)\
    WinHttpQueryHeaders(h,dw,((LPCWSTR) pb),pb,pcb,ndx)

#define InternetQueryDataAvailable  WinHttpQueryDataAvailable

#define InternetReadFile(h,p,cb,pcb) WinHttpReadData(h,p,cb,pcb)

#define InternetCloseHandle         WinHttpCloseHandle

inline HINTERNET __stdcall
InternetOpenUrl(
    IN HINTERNET hInternet,
    IN LPCWSTR lpszUrl,
    IN LPCWSTR lpszHeaders OPTIONAL,
    IN DWORD dwHeadersLength,
    IN DWORD dwFlags,
    IN DWORD_PTR dwContext
    )
{
    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
    return NULL;
}


// InternetSetOption values

#define INTERNET_FIRST_OPTION                        WINHTTP_FIRST_OPTION
#define INTERNET_OPTION_CALLBACK                     WINHTTP_OPTION_CALLBACK
#define INTERNET_OPTION_RESOLVE_TIMEOUT              WINHTTP_OPTION_RESOLVE_TIMEOUT
#define INTERNET_OPTION_CONNECT_TIMEOUT              WINHTTP_OPTION_CONNECT_TIMEOUT
#define INTERNET_OPTION_CONNECT_RETRIES              WINHTTP_OPTION_CONNECT_RETRIES
#define INTERNET_OPTION_SEND_TIMEOUT                 WINHTTP_OPTION_SEND_TIMEOUT
#define INTERNET_OPTION_RECEIVE_TIMEOUT              WINHTTP_OPTION_RECEIVE_TIMEOUT
#define INTERNET_OPTION_HANDLE_TYPE                  WINHTTP_OPTION_HANDLE_TYPE
#define INTERNET_OPTION_READ_BUFFER_SIZE             WINHTTP_OPTION_READ_BUFFER_SIZE
#define INTERNET_OPTION_WRITE_BUFFER_SIZE            WINHTTP_OPTION_WRITE_BUFFER_SIZE
#define INTERNET_OPTION_PARENT_HANDLE                WINHTTP_OPTION_PARENT_HANDLE
#define INTERNET_OPTION_REQUEST_FLAGS                WINHTTP_OPTION_REQUEST_FLAGS
#define INTERNET_OPTION_EXTENDED_ERROR               WINHTTP_OPTION_EXTENDED_ERROR
#define INTERNET_OPTION_SECURITY_FLAGS               WINHTTP_OPTION_SECURITY_FLAGS
#define INTERNET_OPTION_SECURITY_CERTIFICATE_STRUCT  WINHTTP_OPTION_SECURITY_CERTIFICATE_STRUCT
#define INTERNET_OPTION_URL                          WINHTTP_OPTION_URL
#define INTERNET_OPTION_SECURITY_KEY_BITNESS         WINHTTP_OPTION_SECURITY_KEY_BITNESS
#define INTERNET_OPTION_PROXY                        WINHTTP_OPTION_PROXY
#define INTERNET_OPTION_VERSION                      WINHTTP_OPTION_VERSION
#define INTERNET_OPTION_USER_AGENT                   WINHTTP_OPTION_USER_AGENT
#define INTERNET_OPTION_CONTEXT_VALUE                WINHTTP_OPTION_CONTEXT_VALUE
#define INTERNET_OPTION_CLIENT_CERT_CONTEXT          WINHTTP_OPTION_CLIENT_CERT_CONTEXT
#define INTERNET_OPTION_POLICY                       WINHTTP_OPTION_POLICY
#define INTERNET_OPTION_REQUEST_PRIORITY             WINHTTP_OPTION_REQUEST_PRIORITY
#define INTERNET_OPTION_HTTP_VERSION                 WINHTTP_OPTION_HTTP_VERSION
#define INTERNET_OPTION_ERROR_MASK                   WINHTTP_OPTION_ERROR_MASK
#define INTERNET_OPTION_CONTROL_SEND_TIMEOUT         WINHTTP_OPTION_SEND_TIMEOUT
#define INTERNET_OPTION_CONTROL_RECEIVE_TIMEOUT      WINHTTP_OPTION_RECEIVE_TIMEOUT
#define INTERNET_OPTION_DATA_SEND_TIMEOUT            WINHTTP_OPTION_SEND_TIMEOUT
#define INTERNET_OPTION_DATA_RECEIVE_TIMEOUT         WINHTTP_OPTION_RECEIVE_TIMEOUT
#define INTERNET_OPTION_CODEPAGE                     WINHTTP_OPTION_CODEPAGE
#define INTERNET_OPTION_MAX_CONNS_PER_SERVER         WINHTTP_OPTION_MAX_CONNS_PER_SERVER
#define INTERNET_OPTION_MAX_CONNS_PER_1_0_SERVER     WINHTTP_OPTION_MAX_CONNS_PER_1_0_SERVER
#define INTERNET_OPTION_PER_CONNECTION_OPTION        WINHTTP_OPTION_PER_CONNECTION_OPTION
#define INTERNET_OPTION_DIGEST_AUTH_UNLOAD           WINHTTP_OPTION_DIGEST_AUTH_UNLOAD
#define INTERNET_LAST_OPTION                         WINHTTP_LAST_OPTION

// status callback

#define INTERNET_ASYNC_RESULT                        WINHTTP_ASYNC_RESULT
#define LPINTERNET_ASYNC_RESULT                      LPWINHTTP_ASYNC_RESULT

#define INTERNET_STATUS_RESOLVING_NAME               WINHTTP_STATUS_RESOLVING_NAME
#define INTERNET_STATUS_NAME_RESOLVED                WINHTTP_STATUS_NAME_RESOLVED
#define INTERNET_STATUS_CONNECTING_TO_SERVER         WINHTTP_STATUS_CONNECTING_TO_SERVER
#define INTERNET_STATUS_CONNECTED_TO_SERVER          WINHTTP_STATUS_CONNECTED_TO_SERVER
#define INTERNET_STATUS_SENDING_REQUEST              WINHTTP_STATUS_SENDING_REQUEST
#define INTERNET_STATUS_REQUEST_SENT                 WINHTTP_STATUS_REQUEST_SENT
#define INTERNET_STATUS_RECEIVING_RESPONSE           WINHTTP_STATUS_RECEIVING_RESPONSE
#define INTERNET_STATUS_RESPONSE_RECEIVED            WINHTTP_STATUS_RESPONSE_RECEIVED
#define INTERNET_STATUS_CLOSING_CONNECTION           WINHTTP_STATUS_CLOSING_CONNECTION
#define INTERNET_STATUS_CONNECTION_CLOSED            WINHTTP_STATUS_CONNECTION_CLOSED
#define INTERNET_STATUS_HANDLE_CREATED               WINHTTP_STATUS_HANDLE_CREATED
#define INTERNET_STATUS_HANDLE_CLOSING               WINHTTP_STATUS_HANDLE_CLOSING
#define INTERNET_STATUS_DETECTING_PROXY              WINHTTP_STATUS_DETECTING_PROXY
#define INTERNET_STATUS_REQUEST_COMPLETE             WINHTTP_STATUS_REQUEST_COMPLETE
#define INTERNET_STATUS_REDIRECT                     WINHTTP_STATUS_REDIRECT
#define INTERNET_STATUS_INTERMEDIATE_RESPONSE        WINHTTP_STATUS_INTERMEDIATE_RESPONSE

#define INTERNET_STATUS_CALLBACK                     WINHTTP_STATUS_CALLBACK
#define LPINTERNET_STATUS_CALLBACK                   LPWINHTTP_STATUS_CALLBACK
#define INTERNET_INVALID_STATUS_CALLBACK             WINHTTP_INVALID_STATUS_CALLBACK
#define INTERNET_NO_CALLBACK                         0

// flags

#define INTERNET_FLAG_PRAGMA_NO_CACHE                WINHTTP_FLAG_REFRESH
#define INTERNET_FLAG_DONT_CACHE                     WINHTTP_FLAG_REFRESH
#define INTERNET_FLAG_SECURE                         WINHTTP_FLAG_SECURE
#define INTERNET_FLAG_NO_UI                          0
#define INTERNET_FLAG_RELOAD                          0



// handle types

#define INTERNET_HANDLE_TYPE_INTERNET           WINHTTP_HANDLE_TYPE_SESSION
#define INTERNET_HANDLE_TYPE_CONNECT_HTTP       WINHTTP_HANDLE_TYPE_CONNECT
#define INTERNET_HANDLE_TYPE_HTTP_REQUEST       WINHTTP_HANDLE_TYPE_REQUEST


#define HTTP_ADDREQ_INDEX_MASK        WINHTTP_ADDREQ_INDEX_MASK
#define HTTP_ADDREQ_FLAGS_MASK        WINHTTP_ADDREQ_FLAGS_MASK
#define HTTP_ADDREQ_FLAG_ADD_IF_NEW   WINHTTP_ADDREQ_FLAG_ADD_IF_NEW
#define HTTP_ADDREQ_FLAG_ADD          WINHTTP_ADDREQ_FLAG_ADD
#define HTTP_ADDREQ_FLAG_REPLACE      WINHTTP_ADDREQ_FLAG_REPLACE
#define HTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA       WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA
#define HTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON   WINHTTP_ADDREQ_FLAG_COALESCE_WITH_SEMICOLON
#define HTTP_ADDREQ_FLAG_COALESCE                  WINHTTP_ADDREQ_FLAG_COALESCE_WITH_COMMA


#define HTTP_QUERY_MIME_VERSION                 WINHTTP_QUERY_MIME_VERSION
#define HTTP_QUERY_CONTENT_TYPE                 WINHTTP_QUERY_CONTENT_TYPE
#define HTTP_QUERY_CONTENT_TRANSFER_ENCODING    WINHTTP_QUERY_CONTENT_TRANSFER_ENCODING
#define HTTP_QUERY_CONTENT_ID                   WINHTTP_QUERY_CONTENT_ID
#define HTTP_QUERY_CONTENT_DESCRIPTION          WINHTTP_QUERY_CONTENT_DESCRIPTION
#define HTTP_QUERY_CONTENT_LENGTH               WINHTTP_QUERY_CONTENT_LENGTH
#define HTTP_QUERY_CONTENT_LANGUAGE             WINHTTP_QUERY_CONTENT_LANGUAGE
#define HTTP_QUERY_ALLOW                        WINHTTP_QUERY_ALLOW
#define HTTP_QUERY_PUBLIC                       WINHTTP_QUERY_PUBLIC
#define HTTP_QUERY_DATE                         WINHTTP_QUERY_DATE
#define HTTP_QUERY_EXPIRES                      WINHTTP_QUERY_EXPIRES
#define HTTP_QUERY_LAST_MODIFIED                WINHTTP_QUERY_LAST_MODIFIED
#define HTTP_QUERY_MESSAGE_ID                   WINHTTP_QUERY_MESSAGE_ID
#define HTTP_QUERY_URI                          WINHTTP_QUERY_URI
#define HTTP_QUERY_DERIVED_FROM                 WINHTTP_QUERY_DERIVED_FROM
#define HTTP_QUERY_COST                         WINHTTP_QUERY_COST
#define HTTP_QUERY_LINK                         WINHTTP_QUERY_LINK
#define HTTP_QUERY_PRAGMA                       WINHTTP_QUERY_PRAGMA
#define HTTP_QUERY_VERSION                      WINHTTP_QUERY_VERSION
#define HTTP_QUERY_STATUS_CODE                  WINHTTP_QUERY_STATUS_CODE
#define HTTP_QUERY_STATUS_TEXT                  WINHTTP_QUERY_STATUS_TEXT
#define HTTP_QUERY_RAW_HEADERS                  WINHTTP_QUERY_RAW_HEADERS
#define HTTP_QUERY_RAW_HEADERS_CRLF             WINHTTP_QUERY_RAW_HEADERS_CRLF
#define HTTP_QUERY_CONNECTION                   WINHTTP_QUERY_CONNECTION
#define HTTP_QUERY_ACCEPT                       WINHTTP_QUERY_ACCEPT
#define HTTP_QUERY_ACCEPT_CHARSET               WINHTTP_QUERY_ACCEPT_CHARSET
#define HTTP_QUERY_ACCEPT_ENCODING              WINHTTP_QUERY_ACCEPT_ENCODING
#define HTTP_QUERY_ACCEPT_LANGUAGE              WINHTTP_QUERY_ACCEPT_LANGUAGE
#define HTTP_QUERY_AUTHORIZATION                WINHTTP_QUERY_AUTHORIZATION
#define HTTP_QUERY_CONTENT_ENCODING             WINHTTP_QUERY_CONTENT_ENCODING
#define HTTP_QUERY_FORWARDED                    WINHTTP_QUERY_FORWARDED
#define HTTP_QUERY_FROM                         WINHTTP_QUERY_FROM
#define HTTP_QUERY_IF_MODIFIED_SINCE            WINHTTP_QUERY_IF_MODIFIED_SINCE
#define HTTP_QUERY_LOCATION                     WINHTTP_QUERY_LOCATION
#define HTTP_QUERY_ORIG_URI                     WINHTTP_QUERY_ORIG_URI
#define HTTP_QUERY_REFERER                      WINHTTP_QUERY_REFERER
#define HTTP_QUERY_RETRY_AFTER                  WINHTTP_QUERY_RETRY_AFTER
#define HTTP_QUERY_SERVER                       WINHTTP_QUERY_SERVER
#define HTTP_QUERY_TITLE                        WINHTTP_QUERY_TITLE
#define HTTP_QUERY_USER_AGENT                   WINHTTP_QUERY_USER_AGENT
#define HTTP_QUERY_WWW_AUTHENTICATE             WINHTTP_QUERY_WWW_AUTHENTICATE
#define HTTP_QUERY_PROXY_AUTHENTICATE           WINHTTP_QUERY_PROXY_AUTHENTICATE
#define HTTP_QUERY_ACCEPT_RANGES                WINHTTP_QUERY_ACCEPT_RANGES
#define HTTP_QUERY_SET_COOKIE                   WINHTTP_QUERY_SET_COOKIE
#define HTTP_QUERY_COOKIE                       WINHTTP_QUERY_COOKIE
#define HTTP_QUERY_REQUEST_METHOD               WINHTTP_QUERY_REQUEST_METHOD
#define HTTP_QUERY_REFRESH                      WINHTTP_QUERY_REFRESH
#define HTTP_QUERY_CONTENT_DISPOSITION          WINHTTP_QUERY_CONTENT_DISPOSITION
#define HTTP_QUERY_AGE                          WINHTTP_QUERY_AGE
#define HTTP_QUERY_CACHE_CONTROL                WINHTTP_QUERY_CACHE_CONTROL
#define HTTP_QUERY_CONTENT_BASE                 WINHTTP_QUERY_CONTENT_BASE
#define HTTP_QUERY_CONTENT_LOCATION             WINHTTP_QUERY_CONTENT_LOCATION
#define HTTP_QUERY_CONTENT_MD5                  WINHTTP_QUERY_CONTENT_MD5
#define HTTP_QUERY_CONTENT_RANGE                WINHTTP_QUERY_CONTENT_RANGE
#define HTTP_QUERY_ETAG                         WINHTTP_QUERY_ETAG
#define HTTP_QUERY_HOST                         WINHTTP_QUERY_HOST
#define HTTP_QUERY_IF_MATCH                     WINHTTP_QUERY_IF_MATCH
#define HTTP_QUERY_IF_NONE_MATCH                WINHTTP_QUERY_IF_NONE_MATCH
#define HTTP_QUERY_IF_RANGE                     WINHTTP_QUERY_IF_RANGE
#define HTTP_QUERY_IF_UNMODIFIED_SINCE          WINHTTP_QUERY_IF_UNMODIFIED_SINCE
#define HTTP_QUERY_MAX_FORWARDS                 WINHTTP_QUERY_MAX_FORWARDS
#define HTTP_QUERY_PROXY_AUTHORIZATION          WINHTTP_QUERY_PROXY_AUTHORIZATION
#define HTTP_QUERY_RANGE                        WINHTTP_QUERY_RANGE
#define HTTP_QUERY_TRANSFER_ENCODING            WINHTTP_QUERY_TRANSFER_ENCODING
#define HTTP_QUERY_UPGRADE                      WINHTTP_QUERY_UPGRADE
#define HTTP_QUERY_VARY                         WINHTTP_QUERY_VARY
#define HTTP_QUERY_VIA                          WINHTTP_QUERY_VIA
#define HTTP_QUERY_WARNING                      WINHTTP_QUERY_WARNING
#define HTTP_QUERY_EXPECT                       WINHTTP_QUERY_EXPECT
#define HTTP_QUERY_PROXY_CONNECTION             WINHTTP_QUERY_PROXY_CONNECTION
#define HTTP_QUERY_UNLESS_MODIFIED_SINCE        WINHTTP_QUERY_UNLESS_MODIFIED_SINCE
#define HTTP_QUERY_ECHO_REQUEST                 WINHTTP_QUERY_ECHO_REQUEST
#define HTTP_QUERY_ECHO_REPLY                   WINHTTP_QUERY_ECHO_REPLY
#define HTTP_QUERY_ECHO_HEADERS                 WINHTTP_QUERY_ECHO_HEADERS
#define HTTP_QUERY_ECHO_HEADERS_CRLF            WINHTTP_QUERY_ECHO_HEADERS_CRLF
#define HTTP_QUERY_PROXY_SUPPORT                WINHTTP_QUERY_PROXY_SUPPORT
#define HTTP_QUERY_AUTHENTICATION_INFO          WINHTTP_QUERY_AUTHENTICATION_INFO
#define HTTP_QUERY_MAX                          WINHTTP_QUERY_MAX
#define HTTP_QUERY_CUSTOM                       WINHTTP_QUERY_CUSTOM
#define HTTP_QUERY_FLAG_REQUEST_HEADERS         WINHTTP_QUERY_FLAG_REQUEST_HEADERS
#define HTTP_QUERY_FLAG_SYSTEMTIME              WINHTTP_QUERY_FLAG_SYSTEMTIME
#define HTTP_QUERY_FLAG_NUMBER                  WINHTTP_QUERY_FLAG_NUMBER

#define ERROR_INTERNET_FORCE_RETRY              ERROR_WINHTTP_RESEND_REQUEST
#define ERROR_HTTP_HEADER_NOT_FOUND             ERROR_WINHTTP_HEADER_NOT_FOUND
#define ERROR_INTERNET_CONNECTION_RESET         ERROR_WINHTTP_CONNECTION_ERROR


#define INTERNET_ERROR_BASE WINHTTP_ERROR_BASE

#define ERROR_INTERNET_INTERNAL_ERROR           (INTERNET_ERROR_BASE + 4)
#define ERROR_INTERNET_SEC_CERT_DATE_INVALID    (INTERNET_ERROR_BASE + 37)
#define ERROR_INTERNET_SEC_CERT_CN_INVALID      (INTERNET_ERROR_BASE + 38)
#define ERROR_INTERNET_INVALID_CA               (INTERNET_ERROR_BASE + 45)
#define ERROR_INTERNET_CLIENT_AUTH_NOT_SETUP    (INTERNET_ERROR_BASE + 46)
#define ERROR_INTERNET_SEC_CERT_ERRORS          (INTERNET_ERROR_BASE + 55)
#define ERROR_INTERNET_SEC_CERT_NO_REV          (INTERNET_ERROR_BASE + 56)
#define ERROR_INTERNET_SEC_CERT_REV_FAILED      (INTERNET_ERROR_BASE + 57)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\ccred.cpp ===
#include "stdafx.h"

LPCWSTR g_CredentialBlobDescription = L"BITS job credentials";

//------------------------------------------------------------------------

CEncryptedBlob::CEncryptedBlob(
    void *  Buffer,
    size_t  Length,
    LPCWSTR Description
    )
    : m_Length( Length )
{
    m_Blob.pbData = 0;
    m_Blob.cbData = 0;

    DATA_BLOB blobIn;
    blobIn.pbData = reinterpret_cast<BYTE *>( Buffer );
    blobIn.cbData = Length;

    // Encrypt the data.

    if (!CryptProtectData( &blobIn,
                           Description,
                           NULL,
                           NULL,
                           NULL,
                           CRYPTPROTECT_UI_FORBIDDEN,
                           &m_Blob))
        {
        ThrowLastError();
        }
}

CEncryptedBlob::CEncryptedBlob()
{
    m_Length = 0;
    m_Blob.cbData = 0;
    m_Blob.pbData = 0;
}

CEncryptedBlob::~CEncryptedBlob()
{
    if (m_Blob.pbData)
        {
        LocalFree( m_Blob.pbData );
        }
}

void
CEncryptedBlob::Decrypt(
    void * Buffer,
    size_t Length
    )
{
    if (Length < m_Length)
        {
        THROW_HRESULT( E_INVALIDARG );
        }

    DATA_BLOB blobOut;

    // Decrypt the data.

    if (!CryptUnprotectData( &m_Blob,
                             NULL,
                             NULL,
                             NULL,
                             NULL,
                             CRYPTPROTECT_UI_FORBIDDEN,
                             &blobOut))
        {
        ThrowLastError();
        }

    ASSERT( blobOut.cbData == Length );

    memcpy( Buffer, blobOut.pbData, Length );

    LocalFree( blobOut.pbData );
}

void CEncryptedBlob::Serialize( HANDLE hFile )
{
    SafeWriteFile( hFile, m_Length );
    SafeWriteFile( hFile, m_Blob.cbData );
    SafeWriteFile( hFile, m_Blob.pbData, m_Blob.cbData );
}

void CEncryptedBlob::Unserialize( HANDLE hFile )
{
    SafeReadFile( hFile, &m_Length );
    SafeReadFile( hFile, &m_Blob.cbData );

    m_Blob.pbData = static_cast<BYTE *> (LocalAlloc( LMEM_FIXED, m_Blob.cbData ));
    if (m_Blob.pbData == NULL)
        {
        throw ComError( E_OUTOFMEMORY );
        }

    SafeReadFile( hFile, m_Blob.pbData, m_Blob.cbData );
}

//------------------------------------------------------------------------

CEncryptedCredentials::CEncryptedCredentials( const BG_AUTH_CREDENTIALS & cred )
{
    size_t Length = CAuthCredentialsMarshaller::Size( &cred );

    auto_ptr<char> Buffer( new char[ Length ] );

    CMarshalCursor Cursor( Buffer.get(), Length );

    CAuthCredentialsMarshaller m1( Cursor, &cred );

    m_Blob = new CEncryptedBlob( Buffer.get(), Length, g_CredentialBlobDescription );
}

CEncryptedCredentials::~CEncryptedCredentials()
{
    delete m_Blob;
}

BG_AUTH_CREDENTIALS * CEncryptedCredentials::Decrypt()
{
    BG_AUTH_CREDENTIALS * cred = 0;

    size_t Length = m_Blob->GetLength();
    auto_ptr<char> Buffer( new char[ Length ] );

    m_Blob->Decrypt( Buffer.get(), Length );

    CMarshalCursor Cursor( Buffer.get(), Length );

    CAuthCredentialsUnmarshaller m1( Cursor, &cred );

    return cred;
}

//------------------------------------------------------------------------

CCredentialsContainer::CCredentialsContainer()
{
}

CCredentialsContainer::~CCredentialsContainer()
{
    Clear();
}

void
CCredentialsContainer::Clear()
{
    Dictionary::iterator iter;

    //
    // Keep deleting the first element until the map is empty.
    //
    while (iter = m_Dictionary.begin(), (iter != m_Dictionary.end()))
        {
        CEncryptedCredentials * cred = iter->second;

        m_Dictionary.erase( iter );

        delete cred;
        }
}

HRESULT
CCredentialsContainer::Update(
    const BG_AUTH_CREDENTIALS * Credentials
    )
{
    try
        {
        KEY Key = MakeKey( Credentials->Target, Credentials->Scheme );

        CEncryptedCredentials * OldCredentials = m_Dictionary[ Key ];
        auto_ptr<CEncryptedCredentials> NewCredentials(new CEncryptedCredentials( *Credentials ));

        m_Dictionary[ Key ] = NewCredentials.get();

        NewCredentials.release();
        delete OldCredentials;

        return S_OK;
        }
    catch( ComError err )
        {
        return err.Error();
        }
}

HRESULT
CCredentialsContainer::Remove(
    BG_AUTH_TARGET Target,
    BG_AUTH_SCHEME Scheme
    )
{
    try
        {
        KEY Key = MakeKey( Target, Scheme );

        CEncryptedCredentials * OldCredentials = m_Dictionary[ Key ];

        m_Dictionary[ Key ] = 0;

        delete OldCredentials;

        if (OldCredentials == NULL)
            {
            return S_FALSE;
            }

        return S_OK;
        }
    catch( ComError err )
        {
        return err.Error();
        }
}

size_t CCredentialsContainer::GetSizeEstimate(
    const BG_AUTH_CREDENTIALS * Credentials
    ) const
{
    const Overhead = 1000;

    //
    // accurate sizing is expensive, so do something cheap and conservative.
    //

    size_t Size = Overhead;

    Size += CUnicodeStringMarshaller::Size( Credentials->Credentials.Basic.UserName );
    Size += CUnicodeStringMarshaller::Size( Credentials->Credentials.Basic.Password );

    return Size;
}

HRESULT CCredentialsContainer::Find(
    BG_AUTH_TARGET Target,
    BG_AUTH_SCHEME Scheme,
    BG_AUTH_CREDENTIALS ** pCredentials
    ) const
{
    *pCredentials = 0;

    KEY Key = MakeKey( Target, Scheme );

    try
        {
        // This is what we want, except that it doesn't work on a const container:
        // CEncryptedCredentials * cred = m_Dictionary[ Key ];

        CEncryptedCredentials * cred = 0;

        Dictionary::iterator iter = m_Dictionary.find( Key );

        if (iter != m_Dictionary.end())
            {
            cred = iter->second;
            }

        if (!cred)
            {
            return S_FALSE;
            }

        *pCredentials = cred->Decrypt();
        return S_OK;
        }
    catch( ComError err )
        {
        return err.Error();
        }
}

BG_AUTH_CREDENTIALS * CCredentialsContainer::FindFirst( Cookie & cookie ) const
{
    cookie = m_Dictionary.begin();
    return FindNext( cookie );
}

BG_AUTH_CREDENTIALS * CCredentialsContainer::FindNext( Cookie & cookie ) const
{
    while (cookie != m_Dictionary.end() && cookie->second == NULL)
        {
        ++cookie;
        }

    if (cookie == m_Dictionary.end())
        {
        return NULL;
        }

    CEncryptedCredentials * EncryptedCredentials = cookie->second;

    BG_AUTH_CREDENTIALS * Credentials = EncryptedCredentials->Decrypt();

    ++cookie;
    return Credentials;
}

void
CCredentialsContainer::Serialize( HANDLE hFile )
{
    Dictionary::iterator iter;

    long count = 0;

    for ( iter = m_Dictionary.begin(); iter != m_Dictionary.end(); ++iter)
        {
        KEY Key = iter->first;
        CEncryptedCredentials * cred = iter->second;

        if (cred)
            {
            count++;
            }
        }

    SafeWriteFile( hFile, count );

    for ( iter = m_Dictionary.begin(); iter != m_Dictionary.end(); ++iter)
        {
        KEY Key = iter->first;
        CEncryptedCredentials * cred = iter->second;

        if (!cred)
            {
            continue;
            }

        SafeWriteFile( hFile, Key );
        cred->Serialize( hFile );
        }
}

void
CCredentialsContainer::Unserialize( HANDLE hFile )
{
    long count;

    SafeReadFile( hFile, &count );

    while (count-- > 0)
        {
        KEY Key;
        auto_ptr<CEncryptedCredentials> cred( new CEncryptedCredentials );

        SafeReadFile( hFile, &Key );
        cred->Unserialize( hFile );

        m_Dictionary[ Key ] = cred.get();

        cred.release();
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\caddress.h ===
#pragma once
#include "winsock2.h"
#include <stllock.h>

class CIpAddressMonitor
/*

    This is a class to monitor the number of active networks on the local machine.
    It does so by using the Winsock 2.0 SIO_ADDRESS_LIST_CHANGE ioctl.  Currently it
    only monitors IP addresses, but it could monitor other networks that conform to
    the Winsock model.

*/
{
public:

    CIpAddressMonitor();
    ~CIpAddressMonitor();

    typedef void (CALLBACK * LISTEN_CALLBACK_FN)( PVOID arg );

    HRESULT
    Listen(
        LISTEN_CALLBACK_FN fn,
        PVOID              arg
        );

    void     CancelListen();

    bool     IsListening();

    long     GetAddressCount();

protected:

    CCritSec    m_Mutex;

    long        m_AddressCount;

    SOCKET      m_ListenSocket;

    OVERLAPPED  m_Overlapped;

    LISTEN_CALLBACK_FN m_CallbackFn;
    PVOID       m_CallbackArg;

    //--------------------------------------------------------------------

    HRESULT CreateListenSocket();

    HRESULT UpdateAddressCount();

    static void CALLBACK
    ListenCompletionRoutine(
        IN DWORD dwError,
        IN DWORD cbTransferred,
        IN LPWSAOVERLAPPED lpOverlapped,
        IN DWORD dwFlags
        );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\caddress.cpp ===
#include "stdafx.h"
#include "caddress.h"

#if !defined( BITS_V12_ON_NT4 )
#include "caddress.tmh"
#endif

CIpAddressMonitor::CIpAddressMonitor() :
    m_AddressCount( -1 ),
    m_ListenSocket( INVALID_SOCKET ),
    m_CallbackFn ( NULL ),
    m_CallbackArg( NULL )
{
    m_Overlapped.Internal = 0;

    WSADATA data;

    DWORD s = WSAStartup( MAKEWORD( 2, 0 ), &data );

    if (s)
        {
        THROW_HRESULT( HRESULT_FROM_WIN32( s ));
        }

    THROW_HRESULT( CreateListenSocket() );
}

CIpAddressMonitor::~CIpAddressMonitor()
{
    CancelListen();

    if (m_ListenSocket != INVALID_SOCKET)
        {
        closesocket( m_ListenSocket );
        }

    WSACleanup();
}

HRESULT
CIpAddressMonitor::CreateListenSocket()
{
    //
    // Create an overlapped socket.
    //
    m_ListenSocket = WSASocket( AF_INET,
                                SOCK_STREAM,
                                IPPROTO_TCP,
                                NULL,           // no explicit protocol info
                                NULL,           // no group
                                WSA_FLAG_OVERLAPPED
                                );

    if (m_ListenSocket == INVALID_SOCKET)
        {
        return HRESULT_FROM_WIN32( WSAGetLastError() );
        }

    return S_OK;
}

bool
CIpAddressMonitor::IsListening()
{
    return (m_Overlapped.Internal == STATUS_PENDING);
}

long
CIpAddressMonitor::GetAddressCount()
{
    if (m_AddressCount == -1)
        {
        UpdateAddressCount();

        //  if this failed, m_AddressCount may still be -1.
        }
    return m_AddressCount;
}

HRESULT
CIpAddressMonitor::Listen(
    LISTEN_CALLBACK_FN fn,
    PVOID arg
    )
{
    LogInfo("begin listen");
    m_Mutex.Enter();

    //
    // Only one listen at a time.
    //
    if (IsListening())
        {
        m_Mutex.Leave();
        LogInfo("already listening");
        return S_FALSE;
        }

    if (m_ListenSocket == INVALID_SOCKET)
        {
        HRESULT hr = CreateListenSocket();

        if (FAILED(hr))
            {
            m_Mutex.Leave();
            LogInfo("failed %x", hr);
            return hr;
            }
        }

    //
    // Listen for address list changes.
    //
    DWORD bytes;
    if (SOCKET_ERROR == WSAIoctl( m_ListenSocket,
                                  SIO_ADDRESS_LIST_CHANGE,
                                  NULL,                 // no in buffer
                                  0,                    // no in buffer
                                  NULL,                 // no out buffer
                                  0,                    // no out buffer,
                                  &bytes,
                                  &m_Overlapped,
                                  CIpAddressMonitor::ListenCompletionRoutine
                                  ))
        {
        if (WSAGetLastError() != ERROR_IO_PENDING)
            {
            HRESULT HrError = HRESULT_FROM_WIN32( WSAGetLastError() );
            m_Mutex.Leave();
            LogInfo("failed %x", HrError);
            return HrError;
            }
        }

    //
    // Note our success.
    //
    m_CallbackFn = fn;
    m_CallbackArg = arg;

    m_Mutex.Leave();
    LogInfo("end listen");
    return S_OK;
}

void CALLBACK
CIpAddressMonitor::ListenCompletionRoutine(
    IN DWORD dwError,
    IN DWORD cbTransferred,
    IN LPWSAOVERLAPPED lpOverlapped,
    IN DWORD dwFlags
    )
{
    CIpAddressMonitor * obj = CONTAINING_RECORD( lpOverlapped, CIpAddressMonitor, m_Overlapped );

    LogInfo("completion routine, object %p, err %d", obj, dwError );

    if (dwError == 0)
        {
        obj->m_Mutex.Enter();

        obj->UpdateAddressCount();

        PVOID arg = obj->m_CallbackArg;
        LISTEN_CALLBACK_FN fn = obj->m_CallbackFn;

        obj->m_Mutex.Leave();

        if (fn)
            {
            fn( arg );
            }
        }
}

void
CIpAddressMonitor::CancelListen()
{
    LogInfo("begin cancel");

    m_Mutex.Enter();

    if (!IsListening())
        {
        m_Mutex.Leave();
        LogInfo("no need to cancel");
        return;
        }

    //
    // Must wait for the I/O to be completed or aborted, since m_Overlapped
    // is written to in both cases.
    //
    CancelIo( HANDLE(m_ListenSocket) );

    long count = 0;
    while (m_Overlapped.Internal == STATUS_PENDING)
        {
        if (0 == (count % 100) )
            {
            LogInfo("waiting %d times...", count);
            }

        SleepEx( 1, TRUE );
        ++count;
        }

    closesocket( m_ListenSocket );
    m_ListenSocket = INVALID_SOCKET;

    m_Mutex.Leave();

    //
    // The overlapped operation is no longer pending, but the APC may still be queued.
    // Allow it to run.
    //
    SleepEx( 1, TRUE );

    LogInfo("end cancel");
}

HRESULT
CIpAddressMonitor::UpdateAddressCount()
{
    //
    // First call gets the required buffer size...
    //
    DWORD bytes;
    WSAIoctl( m_ListenSocket,
              SIO_ADDRESS_LIST_QUERY,
              NULL,                 // no in buffer
              0,                    // no in buffer
              NULL,                 // no out buffer
              0,                    // no out buffer,
              &bytes,
              NULL,                 // no OVERLAPPED
              NULL                  // no completion routine
              );

    if (WSAGetLastError() != WSAEFAULT)
        {
        m_AddressCount = -1;
        return HRESULT_FROM_WIN32( WSAGetLastError());
        }

    auto_ptr<char> Buffer;

    try
        {
        Buffer = auto_ptr<char>( new char[ bytes ] );
        }
    catch( ComError Error )
        {
        return Error.Error();
        }

    SOCKET_ADDRESS_LIST * List = reinterpret_cast<SOCKET_ADDRESS_LIST *>(Buffer.get());

    //
    // ...second call gets the data.
    //
    if (SOCKET_ERROR == WSAIoctl( m_ListenSocket,
                                  SIO_ADDRESS_LIST_QUERY,
                                  NULL,
                                  0,
                                  List,
                                  bytes,
                                  &bytes,
                                  NULL,
                                  NULL
                                  ))
        {
        m_AddressCount = -1;
        return HRESULT_FROM_WIN32( WSAGetLastError());
        }

    m_AddressCount = List->iAddressCount;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\cerror.cpp ===
#include "stdafx.h"

#if !defined(BITS_V12_ON_NT4)
#include "cerror.tmh"
#endif

void
CJobError::Set(
    CJob  *     job,
    ULONG       FileIndex,
    QMErrInfo * ErrInfo
    )
{
    m_ErrorSet  = true;
    m_job       = job;
    m_FileIndex = FileIndex;
    m_ErrInfo   = *ErrInfo;
}

void
CJobError::ClearError()
{
    m_ErrorSet  = false;
    m_job       = 0;
    m_FileIndex = 0;
    memset( &m_ErrInfo, 0, sizeof(m_ErrInfo));
}

CJobError::CJobError()
{
    ClearError();
}

CFileExternal *
CJobError::CreateFileExternal() const
{
    return m_job->_GetFileIndex( m_FileIndex )->CreateExternalInterface();
}


void
CJobError::GetOldInterfaceErrors(
    DWORD *pdwWin32Result,
    DWORD *pdwTransportResult ) const
{

    if (!IsErrorSet())
        {
        *pdwWin32Result = *pdwTransportResult = 0;
        return;
        }

    if ( GetStyle() == ERROR_STYLE_WIN32 )
        {
        *pdwWin32Result = GetCode();
        }
    else if ( GetStyle() == ERROR_STYLE_HRESULT &&
              ( (GetCode() & 0xffff0000) == 0x80070000 )  )
        {
        // If this is a win32 wrapped as an HRESULT, unwrap it.
        *pdwWin32Result = (GetCode() & 0x0000ffff);
        }

    if ( (GetSource() & COMPONENT_MASK) == COMPONENT_TRANS )
        {
        *pdwTransportResult = GetCode();
        }
    else
        {
        *pdwTransportResult = 0;
        }

}



HRESULT
CJobError::Serialize(
    HANDLE hFile
    ) const
{

    //
    // If this function changes, be sure that the metadata extension
    // constants are adequate.
    //


    if (!m_ErrorSet)
        {
        BOOL TrueBool = FALSE;
        SafeWriteFile( hFile, TrueBool );
        return S_OK;
        }

    BOOL FalseBool = TRUE;
    SafeWriteFile( hFile, FalseBool );
    SafeWriteFile( hFile, m_FileIndex );
    SafeWriteFile( hFile, m_ErrInfo.Code );
    SafeWriteFile( hFile, m_ErrInfo.Style );
    SafeWriteFile( hFile, m_ErrInfo.Source );
    SafeWriteFile( hFile, m_ErrInfo.result );
    SafeWriteFile( hFile, m_ErrInfo.Description );

    return S_OK;
}

void
CJobError::Unserialize(
    HANDLE hFile,
    CJob * job
    )
{
    BOOL ReadBool;
    SafeReadFile( hFile, &ReadBool );

    if (!ReadBool)
        {
        ClearError();
        return;
        }

    m_ErrorSet = true;
    SafeReadFile( hFile, &m_FileIndex );
    SafeReadFile( hFile, &m_ErrInfo.Code );
    SafeReadFile( hFile, &m_ErrInfo.Style );
    SafeReadFile( hFile, &m_ErrInfo.Source );
    SafeReadFile( hFile, &m_ErrInfo.result );
    SafeReadFile( hFile, &m_ErrInfo.Description );

    CFile * file = job->_GetFileIndex( m_FileIndex );
    if (!file)
        {
        throw ComError( HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) );
        }

    m_job = job;
}

//------------------------------------------------------------------------

CJobErrorExternal::CJobErrorExternal() :
    m_Context(BG_ERROR_CONTEXT_NONE),
    m_Code(S_OK),
    m_FileExternal(NULL)
{
}

CJobErrorExternal::CJobErrorExternal( CJobError const * JobError ) :
    m_Context( BG_ERROR_CONTEXT_UNKNOWN ),
    m_Code( S_OK ),
    m_FileExternal( NULL )
{
    try
        {
        m_FileExternal = JobError->CreateFileExternal();

        // Map source into a context
        ERROR_SOURCE Source = JobError->GetSource();
        switch(Source & COMPONENT_MASK)
            {
            case COMPONENT_QMGR:
                switch(Source & SUBCOMP_MASK)
                    {
                    case SUBCOMP_QMGR_FILE:
                        m_Context = BG_ERROR_CONTEXT_LOCAL_FILE;
                        break;
                    case SUBCOMP_QMGR_QUEUE:
                        m_Context = BG_ERROR_CONTEXT_GENERAL_QUEUE_MANAGER;
                        break;
                    case SUBCOMP_QMGR_NOTIFY:
                        m_Context = BG_ERROR_CONTEXT_QUEUE_MANAGER_NOTIFICATION;
                        break;
                    default:
                        ASSERT(0);
                    }
                 break;
            case COMPONENT_TRANS:

                if (Source == SOURCE_HTTP_SERVER_APP)
                    {
                    m_Context = BG_ERROR_CONTEXT_REMOTE_APPLICATION;
                    }
                else
                    {
                    m_Context = BG_ERROR_CONTEXT_REMOTE_FILE;
                    }
                 break;
            default:
                m_Context = BG_ERROR_CONTEXT_NONE;
                break;
            }

        // map code into a HRESULT
        switch( JobError->GetStyle() )
            {
            case ERROR_STYLE_NONE:
                ASSERT(0);
                m_Code = JobError->GetCode();
                break;;
            case ERROR_STYLE_HRESULT:
                m_Code = JobError->GetCode();
                break;
            case ERROR_STYLE_WIN32:
                m_Code = HRESULT_FROM_WIN32( JobError->GetCode() );
                break;
            case ERROR_STYLE_HTTP:
                m_Code = MAKE_HRESULT( SEVERITY_ERROR, 0x19, JobError->GetCode() );
                break;
            default:
                ASSERT(0);
                m_Code = JobError->GetCode();
                break;
            }
        }
    catch (ComError err)
        {
        SafeRelease( m_FileExternal );
        }
}


CJobErrorExternal::~CJobErrorExternal()
{
    SafeRelease( m_FileExternal );
}

STDMETHODIMP
CJobErrorExternal::GetErrorInternal(
    BG_ERROR_CONTEXT *pContext,
    HRESULT *pCode
    )
{
    HRESULT Hr = S_OK;
    LogPublicApiBegin( "pContext %p, pCode %p", pContext, pCode );

    ASSERT( pContext );
    ASSERT( pCode );

    *pContext = m_Context;
    *pCode = m_Code;

    LogPublicApiEnd( "pContext %p(%u), pCode %p(%u)", pContext, pContext ? *pContext : 0, pCode, pCode ? *pCode : 0 );
    return Hr;
}

STDMETHODIMP
CJobErrorExternal::GetFileInternal(
    IBackgroundCopyFile ** pVal
    )
{
    HRESULT Hr = S_OK;
    LogPublicApiBegin( "pVal %p", pVal );

    if (!m_FileExternal)
        {
        *pVal = NULL;
        Hr = BG_E_FILE_NOT_AVAILABLE;
        }
    else
        {
        m_FileExternal->AddRef();
        *pVal = m_FileExternal;
        }

    LogPublicApiEnd( "pVal %p(%p)", pVal, *pVal );
    return Hr;
}

STDMETHODIMP
CJobErrorExternal::GetProtocolInternal( LPWSTR *pProtocol )
{
    HRESULT Hr = S_OK;
    LogPublicApiBegin( "pProtocol %p", pProtocol );

    *pProtocol = NULL;
    if ( !m_FileExternal )
        {
        Hr = BG_E_PROTOCOL_NOT_AVAILABLE;
        }
    else
        {
        Hr = m_FileExternal->GetRemoteName( pProtocol );
        if (SUCCEEDED(Hr))
            {
            // replace the : with a '\0'
            WCHAR *pColon = wcsstr( *pProtocol, L":" );

            // Shouldn't happen since the name should have been verified
            // during the AddFile.
            ASSERT( pColon );

            if ( pColon )
                {
                *pColon = L'\0';
                }
            }
        }

    LogPublicApiEnd( "pProtocol %p(%p,%S)", pProtocol, *pProtocol, (*pProtocol ? *pProtocol : L"NULL") );
    return Hr;
}

STDMETHODIMP
CJobErrorExternal::GetErrorDescriptionInternal(
    DWORD LanguageId,
    LPWSTR *pErrorDescription
    )
{
    HRESULT Hr = S_OK;
    LogPublicApiBegin( "LanguageId %u, pErrorDescription %p", LanguageId, pErrorDescription );
    Hr = g_Manager->GetErrorDescription( m_Code, LanguageId, pErrorDescription );
    LogPublicApiEnd( "LanguageId %u, pErrorDescription %p(%S)", LanguageId, pErrorDescription,
                     (*pErrorDescription ? *pErrorDescription : L"NULL") );
    return Hr;
}

STDMETHODIMP
CJobErrorExternal::GetErrorContextDescriptionInternal(
    DWORD LanguageId,
    LPWSTR *pContextDescription
    )
{
    HRESULT Hr = S_OK;
    LogPublicApiBegin( "LanguageId %u, pErrorDescription %p", LanguageId, pContextDescription );

    HRESULT hMappedError = BG_E_ERROR_CONTEXT_UNKNOWN;
    switch( m_Context )
        {
        case BG_ERROR_CONTEXT_NONE:
            hMappedError = BG_S_ERROR_CONTEXT_NONE;
            break;
        case BG_ERROR_CONTEXT_UNKNOWN:
            hMappedError = BG_E_ERROR_CONTEXT_UNKNOWN;
            break;
        case BG_ERROR_CONTEXT_GENERAL_QUEUE_MANAGER:
            hMappedError = BG_E_ERROR_CONTEXT_GENERAL_QUEUE_MANAGER;
            break;
        case BG_ERROR_CONTEXT_QUEUE_MANAGER_NOTIFICATION:
            hMappedError = BG_E_ERROR_CONTEXT_QUEUE_MANAGER_NOTIFICATION;
        case BG_ERROR_CONTEXT_LOCAL_FILE:
            hMappedError = BG_E_ERROR_CONTEXT_LOCAL_FILE;
            break;
        case BG_ERROR_CONTEXT_REMOTE_FILE:
            hMappedError = BG_E_ERROR_CONTEXT_REMOTE_FILE;
            break;
        case BG_ERROR_CONTEXT_GENERAL_TRANSPORT:
            hMappedError = BG_E_ERROR_CONTEXT_GENERAL_TRANSPORT;
            break;
        default:
            ASSERT(0);
            break;
        }

    Hr = g_Manager->GetErrorDescription( hMappedError, LanguageId, pContextDescription );

    LogPublicApiEnd( "LanguageId %u, pContextDescription %p(%S)",
                     LanguageId, pContextDescription,
                     (*pContextDescription ? *pContextDescription : L"NULL" ) );
    return Hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\cerror.h ===
class CJobError
{
public:

    CJobError();

    UINT64 GetCode() const
    {
        return m_ErrInfo.Code;
    }

    ERROR_STYLE GetStyle() const
    {
        return m_ErrInfo.Style;
    }

    ERROR_SOURCE GetSource() const
    {
        return m_ErrInfo.Source;
    }

    CFileExternal * CreateFileExternal() const;

    ULONG GetFileIndex() const
    {
        return m_FileIndex;
    }

    void GetOldInterfaceErrors(
        DWORD *pdwWin32Result,
        DWORD *pdwTransportResult ) const;

    void Set(
        CJob  *         Job,
        ULONG           FileIndex,
        QMErrInfo *     ErrInfo
        );

    bool IsErrorSet() const
        {
        return m_ErrorSet;
        }

    void ClearError();

    HRESULT Serialize( HANDLE hFile ) const;

    void Unserialize( HANDLE hFile, CJob * job );

protected:

    bool            m_ErrorSet;
    ULONG           m_FileIndex;
    CJob *          m_job;
    QMErrInfo       m_ErrInfo;

};

class CJobErrorExternal : public CSimpleExternalIUnknown<IBackgroundCopyError>
{
public:

    // All external methods are read only so no locks are needed.

    // IBackgroundCopyError methods

    HRESULT STDMETHODCALLTYPE GetErrorInternal(
        /* [ in, out, unique ] */ BG_ERROR_CONTEXT *pContext,
        /* [ in, out, unique ] */ HRESULT *pCode );

    HRESULT STDMETHODCALLTYPE GetError(
        /* [ in, out, unique ] */ BG_ERROR_CONTEXT *pContext,
        /* [ in, out, unique ] */ HRESULT *pCode )
    {
        EXTERNAL_FUNC_WRAP( GetErrorInternal( pContext, pCode ) )
    }


    HRESULT STDMETHODCALLTYPE GetFileInternal(
        /* [ in, out, unique ] */ IBackgroundCopyFile ** pVal );

    HRESULT STDMETHODCALLTYPE GetFile(
        /* [ in, out, unique ] */ IBackgroundCopyFile ** pVal )
    {
        EXTERNAL_FUNC_WRAP( GetFileInternal( pVal ) )
    }

    // Retusn a human readable description of the error.
    // Use CoTaskMemAlloc to free the description.
    HRESULT STDMETHODCALLTYPE GetErrorDescriptionInternal(
        /* [in] */ DWORD LanguageId,
        /* [out,ref] */ LPWSTR *pErrorDescription );

    HRESULT STDMETHODCALLTYPE GetErrorDescription(
        /* [in] */ DWORD LanguageId,
        /* [out,ref] */ LPWSTR *pErrorDescription )
    {
        EXTERNAL_FUNC_WRAP( GetErrorDescriptionInternal( LanguageId, pErrorDescription ) )
    }


    // Return a human readable description of the error context.
    // Use CoTaskMemAlloc to free the description.
    HRESULT STDMETHODCALLTYPE GetErrorContextDescriptionInternal(
        /* [in] */ DWORD LanguageId,
        /* [out,ref] */ LPWSTR *pErrorDescription );

    HRESULT STDMETHODCALLTYPE GetErrorContextDescription(
        /* [in] */ DWORD LanguageId,
        /* [out,ref] */ LPWSTR *pErrorDescription )
    {
        EXTERNAL_FUNC_WRAP( GetErrorContextDescriptionInternal( LanguageId, pErrorDescription ) )
    }


    HRESULT STDMETHODCALLTYPE GetProtocolInternal(
        /* [out,ref] */ LPWSTR *pProtocol );

    HRESULT STDMETHODCALLTYPE GetProtocol(
        /* [out,ref] */ LPWSTR *pProtocol )
    {
        EXTERNAL_FUNC_WRAP( GetProtocolInternal( pProtocol ) )
    }

    // other member functions

    CJobErrorExternal( CJobError const * JobError );

    CJobErrorExternal( );

protected:

    virtual ~CJobErrorExternal();

    BG_ERROR_CONTEXT m_Context;
    HRESULT          m_Code;
    CFileExternal *  m_FileExternal;

    HRESULT GetErrorDescription(
        HRESULT hResult,
        DWORD LanguageId,
        LPWSTR *pErrorDescription );

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\cenum.h ===
template<class B, class T, class P>
class CEnum : public CSimpleExternalIUnknown<B>
{
public:

    // External callable methods

    // IEnum methods

    HRESULT STDMETHODCALLTYPE NextInternal(
        /* [in] */ ULONG celt,
        /* [length_is][size_is][out] */ T rgelt[],
        /* [out] */ ULONG *pceltFetched);

    HRESULT STDMETHODCALLTYPE Next(
        /* [in] */ ULONG celt,
        /* [length_is][size_is][out] */ T rgelt[],
        /* [out] */ ULONG *pceltFetched)
    {
        EXTERNAL_FUNC_WRAP( NextInternal( celt, rgelt, pceltFetched ) )
    }


    HRESULT STDMETHODCALLTYPE SkipInternal(
        /* [in] */ ULONG celt);

    HRESULT STDMETHODCALLTYPE Skip(
        /* [in] */ ULONG celt)
    {
        EXTERNAL_FUNC_WRAP( SkipInternal( celt ) )
    }

    HRESULT STDMETHODCALLTYPE ResetInternal( void );

    HRESULT STDMETHODCALLTYPE Reset( void )
    {
        EXTERNAL_FUNC_WRAP( ResetInternal() )
    }

    HRESULT STDMETHODCALLTYPE CloneInternal(
        /* [out] */ B **ppenum);

    HRESULT STDMETHODCALLTYPE Clone(
        /* [out] */ B **ppenum)
    {
        EXTERNAL_FUNC_WRAP( CloneInternal( ppenum ) )
    }

    HRESULT STDMETHODCALLTYPE GetCountInternal(
        /* [out] */ ULONG *puCount);

    HRESULT STDMETHODCALLTYPE GetCount(
        /* [out] */ ULONG *puCount)
    {
        EXTERNAL_FUNC_WRAP( GetCountInternal( puCount ) )
    }

    // other methods

    void CheckMagicValue();

    // internal methods

    CEnum();

    void
    Add(
        T Item
        );

protected:

    virtual ~CEnum();

    typedef vector<T> CItemList;

    DWORD       m_magic;
    PVOID       m_stack[4];

    CSharedLock m_mutex;
    CItemList   m_items;
    CItemList::size_type   m_CurrentIndex;
    P           m_ItemPolicy;

};

template <class T>
class CEnumIterfaceCopyPolicy
{
public:
    void Init(T * & InitItem ) { InitItem = NULL; }
    void Copy(T * & DestItem, T * SourceItem )
    {
        DestItem = SourceItem;
        DestItem->AddRef();
    }
    void Destroy(T * & DestroyItem )
    {
        DestroyItem->Release();
        Init( DestroyItem );
    }
};

template <class T>
class CEnumItemCopyPolicy
{
public:
    void Init(T & InitItem ) { memset( &InitItem, 0, sizeof(InitItem) ); }
    void Copy(T & DestItem, T SourceItem ) { DestItem = SourceItem; }
    void Destroy(T & DestroyItem ) { Init( DestroyItem ); }
};

template< class B, class T >
class CEnumInterface : public CEnum<B,T*,CEnumIterfaceCopyPolicy<T> >
{
};


template< class B, class T>
class CEnumItem : public CEnum<B,T,CEnumItemCopyPolicy<T> >
{
};


class CEnumJobs : public CEnumInterface<IEnumBackgroundCopyJobs,IBackgroundCopyJob>
{
public:
    CEnumJobs();
};

class CEnumFiles : public CEnumInterface<IEnumBackgroundCopyFiles,IBackgroundCopyFile>
{
public:
    CEnumFiles();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\ccred.h ===
#include <wincrypt.h>
#include <map>

//
// abstraction of CryptEncodeBlob/CryptDecodeBlob
//

class CEncryptedBlob
{
public:

    CEncryptedBlob(
        void *  Buffer,
        size_t  Length,
        LPCWSTR Description
        );

    CEncryptedBlob();

    //
    // used when unserializing
    //
    ~CEncryptedBlob();

    size_t GetLength()
    {
        return m_Length;
    }

    void
    Decrypt(
        void * Buffer,
        size_t Length
        );

    void Serialize( HANDLE hFile );
    void Unserialize( HANDLE hFile );

protected:

    DATA_BLOB       m_Blob;
    size_t          m_Length;

};

class CEncryptedCredentials
{
public:

    CEncryptedCredentials( const BG_AUTH_CREDENTIALS & cred );
    ~CEncryptedCredentials();

    //
    // used by unserialize
    //
    CEncryptedCredentials()
    {
        m_Blob = 0;
    }

    BG_AUTH_CREDENTIALS * Decrypt();

    void Serialize( HANDLE hFile )
    {
        if (m_Blob)
            {
            SafeWriteFile( hFile, true );
            m_Blob->Serialize( hFile );
            }
        else
            {
            SafeWriteFile( hFile, false );
            }
    }

    void Unserialize( HANDLE hFile )
    {
        bool b;

        SafeReadFile( hFile, &b );

        if (b)
            {
            m_Blob = new CEncryptedBlob;
            m_Blob->Unserialize( hFile );
            }
    }

protected:

    CEncryptedBlob * m_Blob;

};


//
// a set of (encrypted) credentials
//
class CCredentialsContainer
{
    typedef DWORD KEY;

    typedef std::map<KEY, CEncryptedCredentials *> Dictionary;

public:

    typedef Dictionary::iterator Cookie;

    CCredentialsContainer();
    ~CCredentialsContainer();

    void Clear();

    HRESULT Update( const BG_AUTH_CREDENTIALS * Credentials );

    HRESULT Remove( BG_AUTH_TARGET Target, BG_AUTH_SCHEME Scheme );

    size_t GetSizeEstimate( const BG_AUTH_CREDENTIALS * Credentials ) const;

    HRESULT Find( BG_AUTH_TARGET Target, BG_AUTH_SCHEME Scheme, BG_AUTH_CREDENTIALS ** pCredentials ) const;

    BG_AUTH_CREDENTIALS * FindFirst( Cookie & cookie ) const throw( ComError );
    BG_AUTH_CREDENTIALS * FindNext( Cookie & cookie ) const throw( ComError );

    void Serialize( HANDLE hFile );
    void Unserialize( HANDLE hFile );

protected:

    Dictionary m_Dictionary;

    //--------------------------------------------------------------------

    inline KEY MakeKey( BG_AUTH_TARGET Target, BG_AUTH_SCHEME Scheme ) const
    {
        return (WORD(Scheme) << 16) | WORD(Target);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\cenum.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    cenum.cpp

Abstract :

    CPP files to enumeration abstraction.

Author :

Revision History :

 ***********************************************************************/

#include "stdafx.h"
#if !defined( BITS_V12_ON_NT4 )
#include "cenum.tmh"
#endif

#define MAGIC_ACTIVE    0x44446666
#define MAGIC_INACTIVE  0x55553333

template<class B, class T, class P>
CEnum<B,T,P>::CEnum() :
m_CurrentIndex(0),
    m_magic( MAGIC_ACTIVE )
{
    memset( m_stack, 0, sizeof(m_stack) );
}

template<class B, class T, class P>
HRESULT
CEnum<B,T,P>::NextInternal(
    ULONG   celt,
    T       rgelt[],
    ULONG * pceltFetched
    )
{
    CheckMagicValue();

    ULONG i;
    HRESULT Hr = S_OK;

    CAutoExclusiveLock LockHolder(m_mutex);

    LogPublicApiBegin( "celt %u, rgelt %p, pceltFetched %p", celt, rgelt, pceltFetched );

    ULONG Fetched = 0;

    try
    {
        for (unsigned int c=0; c<celt; c++)
            m_ItemPolicy.Init( rgelt[c] );

        if ( !pceltFetched && (1 != celt) )
            {
            LogWarning("Return count pointer is NULL, but requested count isn't 1" );
            throw ComError( E_INVALIDARG );
            }

        for (i=0; ( i < celt ) && ( m_CurrentIndex < m_items.size() ); i++, m_CurrentIndex++)
            {

            m_ItemPolicy.Copy( rgelt[i], m_items[m_CurrentIndex] );

            Fetched++;
            }

        if ( pceltFetched )
            {
            *pceltFetched = Fetched;
            }

        if ( Fetched != celt )
            {
            Hr = S_FALSE;
            }
    }

    catch ( ComError exception )
        {
        Hr = exception.Error();
        }

    LogPublicApiEnd( "celt %u, rgelt %p, pceltFetched %p(%u)", celt, rgelt, pceltFetched, pceltFetched ? *pceltFetched : 1 );

    return Hr;
}

template<class B, class T, class P>
HRESULT
CEnum<B,T,P>::CloneInternal(
    B **ppEnum
    )
{
    CheckMagicValue();

    HRESULT Hr = S_OK;
    CEnum<B,T,P> * pEnum = NULL;

    CAutoExclusiveLock LockHolder( m_mutex );

    LogPublicApiBegin( "ppEnum %p", ppEnum );

    try
        {
        pEnum = new CEnum<B,T,P>;

        for (CItemList::iterator iter = m_items.begin(); iter != m_items.end(); ++iter)
            {
            pEnum->Add( *iter );
            }

        pEnum->m_CurrentIndex = m_CurrentIndex;
        }
    catch ( ComError exception )
        {
        delete pEnum;
        pEnum = NULL;

        Hr = exception.Error();
        }

    *ppEnum = pEnum;

    LogPublicApiEnd( "ppEnum %p(%p)", ppEnum, *ppEnum );

    return Hr;

}

template<class B, class T, class P>
void
CEnum<B, T,P>::Add(
    T item
    )
{
    CheckMagicValue();

    CAutoExclusiveLock LockHolder( m_mutex );

    T MyItem;

    try
        {
        m_ItemPolicy.Copy( MyItem, item );
        m_items.push_back( MyItem );
        }
    catch( ComError Error )
        {
        m_ItemPolicy.Destroy( MyItem );
        throw;
        }
}

template<class B, class T, class P>
HRESULT
CEnum<B,T,P>::GetCountInternal(
    ULONG * pCount
    )
{
    CheckMagicValue();

    HRESULT Hr = S_OK;

    CAutoSharedLock LockHolder( m_mutex );

    LogPublicApiBegin( "pCount %p", pCount );

    *pCount = m_items.size();

    LogPublicApiEnd( "pCount %p(%u)", pCount, *pCount );
    return Hr;
}

template<class B, class T, class P>
HRESULT
CEnum<B, T, P>::ResetInternal()
{
    CheckMagicValue();

    HRESULT Hr = S_OK;

    CAutoExclusiveLock LockHolder( m_mutex );

    LogPublicApiBegin( " " );

    m_CurrentIndex = 0;

    LogPublicApiEnd( " " );
    return Hr;
}

template<class B, class T, class P>
HRESULT
CEnum<B, T, P>::SkipInternal(
    ULONG celt
    )
{
    CheckMagicValue();

    HRESULT Hr = S_OK;

    CAutoExclusiveLock LockHolder( m_mutex );

    LogPublicApiBegin( "celt %u", celt );

    while(celt)
        {
        if ( m_CurrentIndex >= m_items.size() )
            break; // Hit the end of the list
        m_CurrentIndex++;
        --celt;
        }

    if (celt)
        {
        LogWarning( "Attempt to skip too many elements." );
        Hr = S_FALSE;
        }

    LogPublicApiEnd(  "celt %u", celt );

    return Hr;
}

template<class B, class T, class P>
CEnum<B,T,P>::~CEnum()
{
    CheckMagicValue();

    m_magic = MAGIC_INACTIVE;

    for (CItemList::const_iterator iter = m_items.begin(); iter != m_items.end(); ++iter)
        {
        T Item = (*iter);
        m_ItemPolicy.Destroy( Item );
        }
}

template<class B, class T, class P>
void CEnum<B,T,P>::CheckMagicValue()
{
    ASSERT( m_magic == MAGIC_ACTIVE );
}


CEnumJobs::CEnumJobs() :
    CEnumInterface<IEnumBackgroundCopyJobs,IBackgroundCopyJob>()
{}

CEnumFiles::CEnumFiles() :
    CEnumInterface<IEnumBackgroundCopyFiles,IBackgroundCopyFile>()
{}


CEnumOldGroups::CEnumOldGroups() :
    CEnumItem<IEnumBackgroundCopyGroups,GUID>( )
{}

CEnumOldJobs::CEnumOldJobs() :
    CEnumItem<IEnumBackgroundCopyJobs1,GUID>( )
{}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\cfile.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    cjob.cpp

Abstract :

    Main code file for handling jobs and files.

Author :

Revision History :

 ***********************************************************************/

#include "stdafx.h"
#if !defined(BITS_V12_ON_NT4)
#include "cfile.tmh"
#endif

//------------------------------------------------------------------------

StringHandle
BITSGetVolumePathName(
    const WCHAR * FileName )
{

#if defined( BITS_V12_ON_NT4 )

    WCHAR VolumePath[4];

    if ( !(
             ( FileName[0] >= L'A' && FileName[0] <= L'Z') ||
             ( FileName[0] >= L'a' && FileName[0] <= L'z')
          ) ||
         ( FileName[1] != L':' ) ||
         ( FileName[2] != L'\\' ) )
        {
        LogError( "%s doesn't appear to start with a drive letter", FileName );
        throw ComError( HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER ) );
        }

    VolumePath[0] = FileName[0];
    VolumePath[1] = FileName[1];
    VolumePath[2] = FileName[2];
    VolumePath[3] = '\0';

    return StringHandle( VolumePath );

#else

    // Call get full path name to get the
    // required buffer size

    DWORD dwBufferLength =
        GetFullPathName(
            FileName,
            0,
            NULL,
            NULL );

    if ( !dwBufferLength )
        {
        DWORD dwError = GetLastError();
        LogError( "GetFullPathName failed, error %!winerr!", dwError );
        throw ComError( HRESULT_FROM_WIN32( dwError ) );
        }

    auto_ptr<WCHAR> VolumePathName( new WCHAR[ dwBufferLength + 1 ] );

    BOOL bResult =
        GetVolumePathName(
            FileName,
            VolumePathName.get(),
            dwBufferLength + 1 );

    if ( !bResult )
        {
        DWORD dwError = GetLastError();
        LogError( "GetVolumePathName failed, error %!winerr!", dwError );
        throw ComError( HRESULT_FROM_WIN32( dwError ) );
        }

    return StringHandle( VolumePathName.get() );

#endif

}

StringHandle
BITSGetVolumeNameForVolumeMountPoint(
    const WCHAR * VolumeMountPoint )
{

#if defined( BITS_V12_ON_NT4 )

    return BITSGetVolumePathName( VolumeMountPoint );

#else

    WCHAR VolumeName[50]; // 50 is listed in MSDN

    BOOL bResult =
        GetVolumeNameForVolumeMountPoint(
            VolumeMountPoint,
            VolumeName,
            50 );

    if ( !bResult )
        {
        DWORD dwError = GetLastError();
        LogError( "GetVolumeNameForVolumeMountPoint failed, error %!winerr!", dwError );
        throw ComError( HRESULT_FROM_WIN32( dwError ) );
        }

    return StringHandle( VolumeName );

#endif

}

DWORD
BITSGetVolumeSerialNumber(
    const WCHAR * VolumePath )
{
    DWORD VolumeSerialNumber;

    BOOL bResult =
        GetVolumeInformation(
            VolumePath,                 // root directory
            NULL,                       // volume name buffer
            0,                          // length of name buffer
            &VolumeSerialNumber,        // volume serial number
            NULL,                       // maximum file name length
            NULL,                       // file system options
            NULL,                       // file system name buffer
            0                           // length of file system name buffer
            );

    if ( !bResult )
        {
        DWORD dwError = GetLastError();
        LogError( "GetVolumeInformation failed, error %!winerr!", dwError );
        throw ComError( HRESULT_FROM_WIN32( dwError ) );
        }

    return VolumeSerialNumber;

}

StringHandle
BITSGetTempFileName(
    const WCHAR *PathName,
    const WCHAR *Prefix,
    UINT Unique )
{

    auto_ptr<WCHAR> TempBuffer( new WCHAR[MAX_PATH+1] );

    UINT Result =
        GetTempFileName(
            PathName,
            Prefix,
            Unique,
            TempBuffer.get() );

    if ( !Result )
        {
        DWORD dwError = GetLastError();
        LogError( "GetTempFileName( '%S', '%S' ) failed, error %!winerr!", PathName, Prefix, dwError );
        throw ComError( HRESULT_FROM_WIN32( dwError ) );
        }

    StringHandle ReturnVal;

    try
    {
        ReturnVal = TempBuffer.get();
    }
    catch( ComError Error )
    {
        LogError( "Out of memory returning temp filename, deleting temp file" );
        DeleteFile( TempBuffer.get() );
        throw;
    }

    return ReturnVal;
}

StringHandle
BITSCrackFileName(
    const WCHAR * RawFileName,
    StringHandle & ReturnFileName )
{

    DWORD FullPathSize =
        GetFullPathName( RawFileName,
                         0,
                         NULL,
                         NULL );

    DWORD dwAllocSize = FullPathSize;
    if ( !FullPathSize )
        {
        DWORD dwError = GetLastError();
        LogError( "GetFullPathName failed, error %!winerr!", dwError );
        throw ComError( HRESULT_FROM_WIN32( dwError ) );
        }

    if ( FullPathSize > MAX_PATH )
        {
        // Fail large paths until the code can be cleanup up
        LogError( "Path larger then MAX_PATH, failing" );
        throw ComError( E_INVALIDARG );
        }

    auto_ptr<WCHAR> FullPath( new WCHAR[ dwAllocSize ] );

    WCHAR *FilePointer = NULL;
    FullPathSize =
        GetFullPathName( RawFileName,
                         dwAllocSize,
                         FullPath.get(),
                         &FilePointer
                         );

    if (FullPathSize == 0 ||
        FullPathSize > dwAllocSize)
        {
        LogError( "GetFullPathName failed " );
        throw ComError( E_INVALIDARG );
        }

    if ( !FilePointer ||
         (*FilePointer == L'\0') ||
         (FilePointer == FullPath.get()))
        {
        throw ComError( E_INVALIDARG );
        }

    auto_ptr<WCHAR> DirectoryName( new WCHAR[ dwAllocSize ] );
    auto_ptr<WCHAR> FileName( new WCHAR[ dwAllocSize ] );

    memcpy( DirectoryName.get(), FullPath.get(), (char*)FilePointer - (char*)FullPath.get() );
    (DirectoryName.get())[ ((char*)FilePointer - (char*)FullPath.get()) / sizeof(WCHAR) ] = L'\0';

    THROW_HRESULT( StringCchCopy( FileName.get(), dwAllocSize, FilePointer ));

    FilePointer = NULL;

    ReturnFileName = FileName.get();
    return StringHandle( DirectoryName.get() );

}

StringHandle
BITSCreateTempFile(
    StringHandle Directory
    )
{
    StringHandle TempFileName;

    TempFileName = BITSGetTempFileName( Directory, L"BITS", 0 ); //throw ComError

    //
    // Make sure the client can create the temp file.
    //
    HANDLE hFile;

    hFile = CreateFile( TempFileName,
                        GENERIC_WRITE,
                        0,                              // no file sharing
                        NULL,                           // generic security descriptor
                        CREATE_ALWAYS,
                        FILE_FLAG_WRITE_THROUGH | FILE_ATTRIBUTE_HIDDEN,
                        NULL                            // no template file
                        );

    if (hFile == INVALID_HANDLE_VALUE)
        {
        ThrowLastError();
        }

    CloseHandle( hFile );

    return TempFileName;
}


HRESULT
BITSCheckFileWritability(
    LPCWSTR name
    )
{
    HANDLE hFile;
    hFile = CreateFile( name,
                        GENERIC_WRITE,
                        0,                              // no file sharing
                        NULL,                           // generic security descriptor
                        OPEN_EXISTING,
                        0,
                        NULL                            // no template file
                        );

    if (hFile == INVALID_HANDLE_VALUE && GetLastError() != ERROR_FILE_NOT_FOUND)
        {
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    if (hFile != INVALID_HANDLE_VALUE)
        {
        if (GetFileType( hFile ) != FILE_TYPE_DISK)
            {
            CloseHandle( hFile );
            return E_INVALIDARG;
            }

        CloseHandle( hFile );
        }

    return S_OK;
}
HRESULT
BITSCheckFileReadability(
    LPCWSTR name
    )
{
    HANDLE hFile;
    hFile = CreateFile( name,
                        GENERIC_READ,
                        FILE_SHARE_READ,      // no file sharing
                        NULL,                           // generic security descriptor
                        OPEN_EXISTING,
                        0,
                        NULL                            // no template file
                        );

    if (hFile == INVALID_HANDLE_VALUE)
        {
        return HRESULT_FROM_WIN32( GetLastError() );
        }

    if (GetFileType( hFile ) != FILE_TYPE_DISK)
        {
        CloseHandle( hFile );
        return E_INVALIDARG;
        }

    CloseHandle( hFile );
    return S_OK;
}

CFile::CFile(
    CJob*   Job,
    BG_JOB_TYPE FileType,
    StringHandle RemoteName,
    StringHandle LocalName
    )
{
    m_Job = Job;
    m_RemoteName = RemoteName;
    m_LocalName = LocalName;
    m_BytesTransferred = 0;
    m_BytesTotal = BG_SIZE_UNKNOWN;
    m_Completed = false;

    if (!VerifyRemoteName( RemoteName ))
        {
        throw ComError( E_INVALIDARG );
        }

    HRESULT hr = VerifyLocalName( LocalName, FileType );
    if (FAILED(hr))
        {
        throw ComError( hr );
        }
}

// private constructor used during unserialization
// It initializes only the transient data.
CFile::CFile(
    CJob*   Job
    )
{
    m_Job = Job;
    m_BytesTotal = 0;
    m_BytesTransferred = 0;
    m_Completed = false;
}

CFile::~CFile()
{
}

//----------------------------------------------

CFileExternal *
CFile::CreateExternalInterface()
{
    return new CFileExternal( this, m_Job->GetExternalInterface() );
}

HRESULT
CFile::GetLocalName(
    LPWSTR *pVal
    ) const
{
    *pVal = MidlCopyString( m_LocalName );

    return (*pVal) ? S_OK : E_OUTOFMEMORY;
}

HRESULT
CFile::GetRemoteName(
    LPWSTR *pVal
    ) const
{
    *pVal = MidlCopyString( m_RemoteName );

    return (*pVal) ? S_OK : E_OUTOFMEMORY;
}

void
CFile::GetProgress(
    BG_FILE_PROGRESS * s
    ) const
{
    s->BytesTransferred = m_BytesTransferred;
    s->BytesTotal       = m_BytesTotal;
    s->Completed        = m_Completed;
}

HRESULT
CFile::Serialize(
    HANDLE hFile
    )
{
    //
    // If this function changes, be sure that the metadata extension
    // constants are adequate.
    //


    // not needed for download jobs, and serializing it would be incompatible
    // with BITS 1.0.
    //
    if (m_Job->GetType() != BG_JOB_TYPE_DOWNLOAD)
        {
        SafeWriteFile( hFile, m_LocalFileTime );
        }

    SafeWriteStringHandle( hFile, m_LocalName );
    SafeWriteStringHandle( hFile, m_RemoteName );
    SafeWriteStringHandle( hFile, m_TemporaryName );

    SafeWriteFile( hFile, m_BytesTransferred );
    SafeWriteFile( hFile, m_BytesTotal );
    SafeWriteFile( hFile, m_Completed );

    // Drive info
    SafeWriteStringHandle( hFile, m_VolumePath );
    SafeWriteStringHandle( hFile, m_CanonicalVolumePath );
    SafeWriteFile( hFile, m_DriveType );
    SafeWriteFile( hFile, m_VolumeSerialNumber );

    return S_OK;
}

CFile *
CFile::Unserialize(
    HANDLE  hFile,
    CJob*   Job
    )
{
    CFile * file = NULL;

    try
        {
        file = new CFile(Job);

        if (Job->GetType() != BG_JOB_TYPE_DOWNLOAD)
            {
            SafeReadFile( hFile, &file->m_LocalFileTime );
            }

        file->m_LocalName = SafeReadStringHandle( hFile );
        file->m_RemoteName = SafeReadStringHandle( hFile );
        file->m_TemporaryName = SafeReadStringHandle( hFile );

        SafeReadFile( hFile, &file->m_BytesTransferred );
        SafeReadFile( hFile, &file->m_BytesTotal );
        SafeReadFile( hFile, &file->m_Completed );

        file->m_VolumePath = SafeReadStringHandle( hFile );
        file->m_CanonicalVolumePath = SafeReadStringHandle( hFile );
        SafeReadFile( hFile, &file->m_DriveType );
        SafeReadFile( hFile, &file->m_VolumeSerialNumber );
        }
    catch ( ComError Error )
        {
        delete file;

        throw;
        }

    return file;
}

inline HRESULT
CFile::CheckClientAccess(
    DWORD RequestedAccess
    ) const
{
    return m_Job->CheckClientAccess( RequestedAccess );
}

HRESULT
CFile::VerifyLocalFileName(
    LPCWSTR name,
    BG_JOB_TYPE FileType
    )
{
    if (name == NULL)
        {
        return E_INVALIDARG;
        }

    //
    // Make sure the client can create a file there.
    //

    HRESULT Hr = S_OK;

    try
        {
        DWORD s;
        BOOL bResult;

        if (!IsAbsolutePath( name ))
            throw ComError( E_INVALIDARG );

        if ( wcsncmp( name, L"\\\\?\\", 4 ) == 0 )
            throw ComError( E_INVALIDARG );

        if (FileType == BG_JOB_TYPE_DOWNLOAD)
            {
            HRESULT hr;

            hr = BITSCheckFileWritability( name );
            if (FAILED(hr))
                {
                throw ComError( hr );
                }
            }
        else
            {
            //
            // See if the client can read the destination file.
            //
            auto_HANDLE<NULL> hFile;

            hFile = CreateFile( name,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,           // gneeric security descriptor
                                OPEN_EXISTING,
                                0,
                                NULL            // no template file
                                );

            if (hFile.get() == INVALID_HANDLE_VALUE)
                {
                ThrowLastError();
                }

            if (GetFileType( hFile.get() ) != FILE_TYPE_DISK)
                {
                throw ComError( E_INVALIDARG );
                }
            }

        //
        // Success.
        //
        Hr = S_OK;
        }
    catch ( ComError exception )
        {
        Hr = exception.Error();
        }

    return Hr;
}

HRESULT
CFile::VerifyLocalName(
    LPCWSTR name,
    BG_JOB_TYPE FileType
    )
{
    if (name == NULL)
        {
        return E_INVALIDARG;
        }

    //
    // Make sure the client can create a file there.
    //

    HRESULT Hr = S_OK;

    try
        {
        DWORD s;
        BOOL bResult;

        if (!IsAbsolutePath( name ))
            throw ComError( E_INVALIDARG );

        if ( wcsncmp( name, L"\\\\?\\", 4 ) == 0 )
            throw ComError( E_INVALIDARG );

        StringHandle FileName;
        StringHandle DirectoryName =
            BITSCrackFileName(
                name,
                FileName ); // throws ComError

        StringHandle VolumePath =
            BITSGetVolumePathName(
                DirectoryName ); // throws ComError

        UINT DriveType = GetDriveType( VolumePath );

        BOOL bIsRemote = IsDriveTypeRemote( DriveType );

        StringHandle CanonicalPath;
        DWORD VolumeSerialNumber = 0;

        if ( !bIsRemote )
            {

            CanonicalPath =
                BITSGetVolumeNameForVolumeMountPoint(
                    VolumePath ); // throw ComError

            VolumeSerialNumber =
                BITSGetVolumeSerialNumber( CanonicalPath ); //throws ComError

            }

        m_VolumePath            = VolumePath;
        m_CanonicalVolumePath   = CanonicalPath;
        m_DriveType             = DriveType;
        m_VolumeSerialNumber    = VolumeSerialNumber;

        if (FileType == BG_JOB_TYPE_DOWNLOAD)
            {
            HRESULT hr;

            m_TemporaryName = BITSCreateTempFile( DirectoryName );

            hr = BITSCheckFileWritability( name );
            if (FAILED(hr))
                {
                DeleteFile( m_TemporaryName );
                throw ComError( hr );
                }
            }
        else
            {
            //
            // See if the client can read the destination file.
            //
            auto_HANDLE<NULL> hFile;

            hFile = CreateFile( name,
                                GENERIC_READ,
                                FILE_SHARE_READ,                // no file sharing
                                NULL,                           // generic security descriptor
                                OPEN_EXISTING,
                                0,
                                NULL                            // no template file
                                );

            if (hFile.get() == INVALID_HANDLE_VALUE)
                {
                ThrowLastError();
                }

            LARGE_INTEGER size;
            if (!GetFileSizeEx( hFile.get(), &size ))
                {
                ThrowLastError();
                }

            m_BytesTotal = size.QuadPart;

            BY_HANDLE_FILE_INFORMATION info;

            if (!GetFileInformationByHandle( hFile.get(), &info ))
                {
                ThrowLastError();
                }

            m_LocalFileTime = info.ftLastWriteTime;
            }

        //
        // Success.
        //
        Hr = S_OK;
        }
    catch ( ComError exception )
        {
        Hr = exception.Error();
        }

    return Hr;
}

HRESULT
CFile::ValidateAccessForUser(
    SidHandle sid,
    bool fWrite
    )
{
    try
        {

        StringHandle CanonicalPath;
        DWORD VolumeSerialNumber = 0;
        UINT DriveType = 0;

        CNestedImpersonation imp( sid );

        StringHandle VolumePath =
            BITSGetVolumePathName( m_LocalName );

        DriveType = GetDriveType( VolumePath );

        bool bIsRemote = IsDriveTypeRemote( DriveType );

        if ( !bIsRemote )
            {

            CanonicalPath =
                BITSGetVolumeNameForVolumeMountPoint( VolumePath );

            // Need to stop impersonating at this point since registration
            // for notifications doesn't seem to tolerate impersonating callers

            imp.Revert();

#if !defined( BITS_V12_ON_NT4 )
            THROW_HRESULT( g_Manager->IsVolumeLocked( CanonicalPath ));
#endif

            VolumeSerialNumber =
                BITSGetVolumeSerialNumber( CanonicalPath );

            }

        bool bValid =
            ( _wcsicmp( VolumePath, m_VolumePath ) == 0 ) &&
            ( _wcsicmp( CanonicalPath, m_CanonicalVolumePath ) == 0 ) &&
            ( m_DriveType == DriveType ) &&
            ( m_VolumeSerialNumber == VolumeSerialNumber );

        if ( !bValid )
            return BG_E_NEW_OWNER_DIFF_MAPPING;

        // Revalidate access to the file.  There are three cases:
        //
        // 1.file is not renamed: test the temporary file and local file.
        // 2. Mars job, file is renamed: test the local file
        // 3. new job, file is renamed: no test; the app owns the local file

        HANDLE hFile;
        HRESULT hr;

        imp.Impersonate();

        if (IsCompleted())
            {
            if (m_Job->GetOldExternalGroupInterface())
                {
                //
                // case 2
                //
                hr = BITSCheckFileWritability( m_LocalName );
                if (hr == E_ACCESSDENIED)
                    {
                    hr = BG_E_NEW_OWNER_NO_FILE_ACCESS;
                    }

                THROW_HRESULT( hr );
                }
            else
                {
                //
                // case 3
                //
                }
            }
        else
            {
            //
            // case 1
            //
            if (fWrite)
                {
                hr = BITSCheckFileWritability( m_TemporaryName );
                if (hr == E_ACCESSDENIED)
                    {
                    hr = BG_E_NEW_OWNER_NO_FILE_ACCESS;
                    }

                THROW_HRESULT( hr );

                hr = BITSCheckFileWritability( m_LocalName );
                if (hr == E_ACCESSDENIED)
                    {
                    hr = BG_E_NEW_OWNER_NO_FILE_ACCESS;
                    }

                THROW_HRESULT( hr );
                }
            else
                {
                hr = BITSCheckFileReadability( m_LocalName );
                if (hr == E_ACCESSDENIED)
                    {
                    hr = BG_E_NEW_OWNER_NO_FILE_ACCESS;
                    }

                THROW_HRESULT( hr );
                }
            }

        return S_OK;
        }
    catch( ComError Error )
        {
        return Error.Error();
        }
}

bool
CFile::ValidateDriveInfo(
    HANDLE hToken,
    QMErrInfo & ErrInfo
    )
{
    try
        {
        StringHandle CanonicalPath;
        DWORD VolumeSerialNumber = 0;
        UINT DriveType = 0;

        CNestedImpersonation imp( hToken );

        StringHandle VolumePath =
           BITSGetVolumePathName( m_LocalName ); // throws ComError

        DriveType = GetDriveType( VolumePath );

        bool bIsRemote = IsDriveTypeRemote( DriveType );

        if ( !bIsRemote )
            {
            CanonicalPath =
                BITSGetVolumeNameForVolumeMountPoint(
                    VolumePath ); // throws ComError

            // Need to stop impersonating at this point since registration
            // for notifications doesn't seem to tolerate impersonating callers

            imp.Revert();

#if !defined( BITS_V12_ON_NT4 )
            THROW_HRESULT( g_Manager->IsVolumeLocked( CanonicalPath ));
#endif

            VolumeSerialNumber =
                BITSGetVolumeSerialNumber( CanonicalPath ); //throws ComError
            }

        bool bValid =
           ( _wcsicmp( VolumePath, m_VolumePath ) == 0 ) &&
           ( _wcsicmp( CanonicalPath, m_CanonicalVolumePath ) == 0 ) &&
           ( m_DriveType == DriveType ) &&
           ( m_VolumeSerialNumber == VolumeSerialNumber );

        if ( !bValid )
            {
            imp.Revert();

            g_Manager->OnDiskChange( m_CanonicalVolumePath, m_VolumeSerialNumber );

            ErrInfo.Set( SOURCE_QMGR_FILE, ERROR_STYLE_HRESULT, BG_E_VOLUME_CHANGED, "Volume has changed");
            ErrInfo.result = QM_FILE_FATAL_ERROR;
            return false;
            }
        }
    catch( ComError Error )
        {
        HRESULT Hr = Error.Error();
        LogWarning( "Transient error while reading volume info for %ls, hr %!winerr!",
                   (const WCHAR*)m_LocalName, Hr );

        if ( Hr == HRESULT_FROM_WIN32( ERROR_ACCESS_DENIED ) )
            {
            LogWarning( "Volume info APIs returned access denied, assume locked volume." );
            Hr = BG_E_DESTINATION_LOCKED;
            }

        ErrInfo.Set( SOURCE_QMGR_FILE, ERROR_STYLE_HRESULT, Hr, "Volume has changed");
        ErrInfo.result = QM_FILE_TRANSIENT_ERROR;

        return false;
        }

    return true;
}

bool
CFile::OnDiskChange(
    const WCHAR *CanonicalVolume,
    DWORD VolumeSerialNumber )
{
    bool bFail =
        ( _wcsicmp( m_CanonicalVolumePath, CanonicalVolume ) == 0 ) &&
        ( VolumeSerialNumber == m_VolumeSerialNumber );

    if (!bFail)
        return true;

    LogWarning( "Failing job %p, to do disk change affecting file %ls",
                m_Job, (const WCHAR*)m_LocalName );

    QMErrInfo   ErrInfo;
    ErrInfo.Set( SOURCE_QMGR_FILE, ERROR_STYLE_HRESULT, BG_E_VOLUME_CHANGED, "Volume has changed");
    m_Job->FileFatalError( &ErrInfo );

    return false;
}

bool
CFile::OnDismount(
    const WCHAR *CanonicalVolume )
{
    bool bFail =
        ( _wcsicmp( m_CanonicalVolumePath, CanonicalVolume ) == 0 );

    if (!bFail)
        return true;

    LogWarning( "Failing job %p, to do dismount affecting file %ls",
                m_Job, (const WCHAR*)m_LocalName );

    QMErrInfo   ErrInfo;
    ErrInfo.Set( SOURCE_QMGR_FILE, ERROR_STYLE_HRESULT, BG_E_VOLUME_CHANGED, "Volume has changed");
    m_Job->FileFatalError( &ErrInfo );

    return false;
}

bool CFile::Transfer(
    HANDLE hToken,
    BG_JOB_PRIORITY priority,
    const PROXY_SETTINGS & ProxySettings,
    const CCredentialsContainer * Credentials,
    QMErrInfo & ErrInfo
    )
{
    // Check if the destination is locked or changed.
    if (!ValidateDriveInfo( hToken, ErrInfo ))
        {
        return true;
        }

    if (m_BytesTransferred == m_BytesTotal)
        {
        ErrInfo.result = QM_FILE_DONE;
        return true;
        }

    //
    // Release the global lock while the download is in progress.
    //
    g_Manager->m_TaskScheduler.UnlockWriter();

    LogDl( "Download starting." );

    g_Manager->m_pPD->Download( m_RemoteName,
                                m_TemporaryName,
                                m_BytesTransferred,
                                this,
                                &ErrInfo,
                                hToken,
                                priority,
                                &ProxySettings,
                                Credentials,
                                m_Job->GetHostId()
                                );

    LogDl( "Download Ended." );

    ErrInfo.Log();

    switch (ErrInfo.result)
        {
        case QM_FILE_ABORTED:

            //
            // If the abort was due to quantum timeout, don't poke the workitem.
            //
            if (g_Manager->m_TaskScheduler.PollAbort())
                {
                g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
                }
            break;

        case QM_IN_PROGRESS:         ASSERT( ErrInfo.result != QM_IN_PROGRESS ); break;
        case QM_SERVER_FILE_CHANGED: ChangedOnServer(); break;
        case QM_FILE_TRANSIENT_ERROR:

#if !defined( BITS_V12_ON_NT4 )
            //
            // Map any connection failure to BG_E_NETWORK_DISCONNECTED, if no nets are active.
            //
            if (g_Manager->m_NetworkMonitor.GetAddressCount() == 0)
                {
                ErrInfo.Set( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, BG_E_NETWORK_DISCONNECTED, NULL );
                }
#else
            break;
#endif

        }

    //
    // Take the writer lock, since the caller expects it to be taken
    // upon return.
    //
    while (g_Manager->m_TaskScheduler.LockWriter() )
        {
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        ErrInfo.result = QM_FILE_ABORTED;
        }

    if (ErrInfo.result == QM_FILE_ABORTED)
        {
        return false;
        }

    return true;
}

bool
CFile::UploaderProgress(
    UINT64 BytesTransferred
    )
{
    ASSERT( g_Manager->m_TaskScheduler.IsWriter() );

    m_BytesTransferred = BytesTransferred;

    m_Job->UpdateProgress( BytesTransferred, m_BytesTotal );

    bool bAbortQuantumExpired = g_Manager->CheckForQuantumTimeout();

    return bAbortQuantumExpired;
}

bool
CFile::DownloaderProgress(
    UINT64 BytesTransferred,
    UINT64 BytesTotal
    )
{
    if ( g_Manager->m_TaskScheduler.LockWriter() )
        {
        // Cancel was requested, notify downloader.
        return true;
        }

    m_BytesTransferred = BytesTransferred;
    m_BytesTotal       = BytesTotal;

    m_Job->UpdateProgress( BytesTransferred, BytesTotal );

    bool bAbortQuantumExpired = g_Manager->CheckForQuantumTimeout();

    g_Manager->m_TaskScheduler.UnlockWriter();

    return bAbortQuantumExpired;
}

bool
CFile::PollAbort()
{
    if (g_Manager->m_TaskScheduler.PollAbort() ||
        g_Manager->CheckForQuantumTimeout())
        {
        return true;
        }

    return false;
}

BOOL
CFile::VerifyRemoteName(
    LPCWSTR name
    )
{
    if (name == NULL)
        {
        return FALSE;
        }

    if ( ( 0 != wcsncmp(name, L"http://", 7)) &&
         ( 0 != wcsncmp(name, L"https://", 8)) )
        {
        return FALSE;
        }

    if (( wcslen(name) > INTERNET_MAX_URL_LENGTH))
        return FALSE;

    return TRUE;
}

HRESULT
CFile::MoveTempFile()
{
    LogInfo( "commit: moving '%S' to '%S'", (const WCHAR*)m_TemporaryName, (const WCHAR*)m_LocalName );

    ASSERT( !m_Completed );

    DWORD dwFileAttributes =
        GetFileAttributes( (const WCHAR*)m_TemporaryName );

    if ( (DWORD)-1 == dwFileAttributes )
        {
        DWORD dwError = GetLastError();
        LogError( "GetFileAttributes error %!winerr!%", dwError );
        return HRESULT_FROM_WIN32( dwError );
        }

    if (!SetFileAttributes( m_TemporaryName, FILE_ATTRIBUTE_NORMAL ))
        {
        DWORD dwError = GetLastError();
        LogError( "SetFileAttributes error %d", dwError );
        return HRESULT_FROM_WIN32( dwError );
        }

    DWORD dwError;
    for( int c=3; c > 0; c-- )
        {
        if ( MoveFileEx( m_TemporaryName, m_LocalName, MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED ) )
            {
            LogInfo( "file moved ok.");
            m_Completed = true;
            return S_OK;
            }

        dwError = GetLastError();
        LogError( "Unable to move file '%S' to '%S' due to %!winerr!, sleeping",
                  (const WCHAR*) m_TemporaryName, (const WCHAR*)m_LocalName, dwError );

        Sleep( 50 );
        }

    LogError( "Timed out renaming temp file" );

    // Attemp to reset the attributes on the file.
    SetFileAttributes( (const WCHAR*)m_TemporaryName, dwFileAttributes );
    return HRESULT_FROM_WIN32( dwError );
}

HRESULT
CFile::DeleteTempFile()
{
    if (!DeleteFile( m_TemporaryName ))
        {
        return HRESULT_FROM_WIN32( GetLastError());
        }

    return S_OK;
}

void
CFile::ChangedOnServer()
{
    LogError( "deleting '%S' since it was changed on the server", (const WCHAR*)m_TemporaryName );

    DeleteTempFile();

    m_BytesTransferred = 0;
    m_Completed = false;
    m_BytesTotal = BG_SIZE_UNKNOWN;
}

void
CFile::DiscoverBytesTotal(
    HANDLE Token,
    const PROXY_SETTINGS & ProxySettings,
    const CCredentialsContainer * Credentials,
    QMErrInfo & ErrorInfo
    )
{
    UINT64       FileSize;
    FILETIME     FileTime;

    LogDl( "Retrieving remote infomation for %ls", m_RemoteName );

    g_Manager->m_TaskScheduler.UnlockWriter();

    g_Manager->m_pPD->GetRemoteFileInformation(
        Token,
        m_RemoteName,
        &FileSize,
        &FileTime,
        &ErrorInfo,
        &ProxySettings,
        Credentials,
        m_Job->GetHostId()
         );

    {
    bool fCancelled = false;

    while (g_Manager->m_TaskScheduler.LockWriter() )
        {
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        fCancelled = true;
        }

    if (fCancelled)
        {
        ErrorInfo.result = QM_FILE_ABORTED;
        }
    }

    LogDl("result was %d", ErrorInfo.result );

    switch (ErrorInfo.result)
        {
        case QM_FILE_DONE:            m_BytesTotal = FileSize;  break;
        case QM_IN_PROGRESS:          ASSERT( 0 );              break;
        case QM_SERVER_FILE_CHANGED:  ChangedOnServer();        break;
        }
}

HANDLE
CFile::OpenLocalFileForUpload()
{
    return NULL;
}

HRESULT
CFile::SetLocalFileTime( FILETIME Time )
/*
    This is used as a special case to set the file time of a zero-length file, since
    the normal download path is skipped.
*/
{
    try
        {
        auto_HANDLE<NULL> hFile = CreateFile( m_TemporaryName,
                                GENERIC_READ | GENERIC_WRITE,
                                0,
                                NULL,
                                OPEN_ALWAYS,
                                FILE_ATTRIBUTE_HIDDEN,
                                NULL );

        if ( hFile.get() == INVALID_HANDLE_VALUE )
            {
            ThrowLastError();
            }

        if (!SetFileTime( hFile.get(), &Time, &Time, &Time ) )
            {
            ThrowLastError();
            }

        return S_OK;
        }
    catch ( ComError err )
        {
        LogError( "error %x setting creation time", err.Error() );
        return err.Error();
        }
}

//------------------------------------------------------------------------

typedef CLockedReadPointer<CFile, BG_JOB_READ> CLockedFileReadPointer;
typedef CLockedWritePointer<CFile, BG_JOB_WRITE> CLockedFileWritePointer;


CFileExternal::CFileExternal(
    CFile * file,
    CJobExternal * JobExternal
    )
    : m_ServiceInstance( g_ServiceInstance ),
      m_refs(1),
      m_file( file ),
      m_JobExternal( JobExternal )
{
    m_JobExternal->AddRef();
}

CFileExternal::~CFileExternal()
{
    SafeRelease( m_JobExternal );
}

STDMETHODIMP
CFileExternal::QueryInterface(
    REFIID iid,
    void** ppvObject
    )
{
    BEGIN_EXTERNAL_FUNC

    HRESULT Hr = S_OK;
    *ppvObject = NULL;

    if ((iid == IID_IUnknown) || (iid == IID_IBackgroundCopyFile))
        {
        *ppvObject = (IBackgroundCopyFile *)this;
        AddRef();
        }
    else
        {
        Hr = E_NOINTERFACE;
        }

    LogRef( "iid %!guid!, hr %x", &iid, Hr );
    return Hr;

    END_EXTERNAL_FUNC
}

ULONG
CFileExternal::AddRef()
{
    BEGIN_EXTERNAL_FUNC

    ULONG newrefs = InterlockedIncrement(&m_refs);

    LogRef("refs %d", newrefs);

    return newrefs;

    END_EXTERNAL_FUNC
}

ULONG
CFileExternal::Release()
{
    BEGIN_EXTERNAL_FUNC

    ULONG newrefs = InterlockedDecrement(&m_refs);

    LogRef("refs %d", newrefs);

    if (0 == newrefs)
        {
        delete this;
        }

    return newrefs;

    END_EXTERNAL_FUNC
}

STDMETHODIMP
CFileExternal::GetRemoteNameInternal(
    /* [out] */ LPWSTR *pVal
    )
{
    CLockedFileReadPointer LockedPointer(m_file);
    LogPublicApiBegin( "pVal %p", pVal );

    HRESULT Hr = LockedPointer.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedPointer->GetRemoteName( pVal );
        }

    LogPublicApiEnd( "pVal %p(%S) ", pVal, SUCCEEDED(Hr) ? *pVal : L"?" );
    return Hr;
}

STDMETHODIMP
CFileExternal::GetLocalNameInternal(
    /* [out] */ LPWSTR *pVal
    )
{
    CLockedFileReadPointer LockedPointer(m_file);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedPointer.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedPointer->GetLocalName( pVal );
        }
    LogPublicApiEnd( "pVal %p(%S) ", pVal, SUCCEEDED(Hr) ? *pVal : L"?" );
    return Hr;
}

STDMETHODIMP
CFileExternal::GetProgressInternal(
    /* [out] */ BG_FILE_PROGRESS *pVal
    )
{
    CLockedFileReadPointer LockedPointer(m_file);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedPointer.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        LockedPointer->GetProgress( pVal );
        }
    LogPublicApiEnd( "pVal %p", pVal );
    return Hr;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\cfile.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    cjob.h

Abstract :

    Main header file for files.

Author :

Revision History :

 ***********************************************************************/

class CFile;
class CJob;
class CFileExternal;
class CJobExternal;

class CFileExternal : public IBackgroundCopyFile
{
public:

    friend CFile;

    // IUnknown Methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    ULONG _stdcall AddRef(void);
    ULONG _stdcall Release(void);

    // IBackgroundCopyFile methods

    HRESULT STDMETHODCALLTYPE GetRemoteNameInternal(
        /* [out] */ LPWSTR *pVal);

    HRESULT STDMETHODCALLTYPE GetRemoteName(
        /* [out] */ LPWSTR *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetRemoteNameInternal( pVal ) )
    }

    HRESULT STDMETHODCALLTYPE GetLocalNameInternal(
        /* [out] */ LPWSTR *pVal);

    HRESULT STDMETHODCALLTYPE GetLocalName(
        /* [out] */ LPWSTR *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetLocalNameInternal( pVal ) )
    }

    HRESULT STDMETHODCALLTYPE GetProgressInternal(
        /* [out] */ BG_FILE_PROGRESS *pVal);

    HRESULT STDMETHODCALLTYPE GetProgress(
        /* [out] */ BG_FILE_PROGRESS *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetProgressInternal( pVal ) )
    }

    // other methods

    CFileExternal(
        CFile * file,
        CJobExternal * JobExternal
        );

    ~CFileExternal();

private:

    long m_refs;
    long m_ServiceInstance;

    CFile *         m_file;
    CJobExternal *  m_JobExternal;
};

class CFile : public ITransferCallback
{
public:

    friend CFileExternal;

    // ITransferCallback methods

    virtual bool
    DownloaderProgress(
        UINT64 BytesTransferred,
        UINT64 BytesTotal
        );

    virtual bool PollAbort();

    virtual bool
    UploaderProgress(
        UINT64 BytesTransferred
        );

    // other methods

    CFile(
        CJob*   Job,
        BG_JOB_TYPE FileType,
        StringHandle RemoteName,
        StringHandle LocalName
        );

    virtual ~CFile();

    bool Transfer( HANDLE                       hToken,
                   BG_JOB_PRIORITY              priority,
                   const PROXY_SETTINGS &       ProxySettings,
                   const CCredentialsContainer *Credentials,
                   QMErrInfo                  & ErrInfo
                   );

    void
    DiscoverBytesTotal(
        HANDLE Token,
        const PROXY_SETTINGS & ProxySettings,
        const CCredentialsContainer * Credentials,
        QMErrInfo & ErrorInfo
        );

    HRESULT GetRemoteName( LPWSTR *pVal ) const;

    HRESULT GetLocalName( LPWSTR *pVal ) const;

    const StringHandle & GetRemoteName() const
    {
        return m_RemoteName;
    }

    const StringHandle & GetLocalName() const
    {
        return m_LocalName;
    }

    const StringHandle & GetTemporaryName() const
    {
        return m_TemporaryName;
    }

    void GetProgress( BG_FILE_PROGRESS *pVal ) const;

    HRESULT Serialize( HANDLE hFile );
    static CFile * Unserialize( HANDLE hFile, CJob* Job );

    UINT64 _GetBytesTransferred() const
    {
        return m_BytesTransferred;
    }

    UINT64 _GetBytesTotal() const
    {
       return m_BytesTotal;
    }

    void SetBytesTotal( UINT64 BytesTotal )
    {
        m_BytesTotal = BytesTotal;
    }

    void SetBytesTransferred( UINT64 BytesTransferred )
    {
        m_BytesTransferred = BytesTransferred;
    }

    bool IsCompleted()
    {
        return m_Completed;
    }

    bool ReceivedAllData()
    {
        return (m_BytesTotal == m_BytesTransferred);
    }

    CFileExternal * CreateExternalInterface();

    CJob* GetJob() const
    {
        return m_Job;
    }

    HRESULT CheckClientAccess(
        IN DWORD RequestedAccess
        ) const;

    HRESULT MoveTempFile();
    HRESULT DeleteTempFile();

    HRESULT VerifyLocalName( LPCWSTR name, BG_JOB_TYPE JobType );
    BOOL    VerifyRemoteName( LPCWSTR name );

    static HRESULT VerifyLocalFileName( LPCWSTR name, BG_JOB_TYPE JobType );

    bool IsCanonicalVolume( const WCHAR *CanonicalVolume )
    {
        return ( _wcsicmp( m_CanonicalVolumePath, CanonicalVolume ) == 0 );
    }

    HRESULT ValidateAccessForUser( SidHandle sid, bool fWrite );

    bool ValidateDriveInfo( HANDLE hToken, QMErrInfo & ErrInfo );

    bool OnDiskChange(  const WCHAR *CanonicalVolume, DWORD VolumeSerialNumber );
    bool OnDismount(  const WCHAR *CanonicalVolume );

    void ChangedOnServer();

    static bool IsDriveTypeRemote( UINT DriveType )
    {
        return
            ( DriveType == DRIVE_UNKNOWN ) ||
            ( DriveType == DRIVE_NO_ROOT_DIR ) ||
            ( DriveType == DRIVE_REMOTE );
    }

    static bool IsAbsolutePath( const WCHAR * Path )
    {
        bool ret;

        if ( (Path [0] == L'\\' && Path[1] == L'\\') ||
             (iswalpha ( Path [0] ) && Path [1] == L':' && Path[ 2 ] == L'\\') ) {
            ret = true;
        } else {
            ret = false;
        }
        return ret;
    }

    DWORD GetSizeEstimate()
    {
        //
        // Serialize() will store five file paths and five constants
        //
        return (5 * MAX_PATH * sizeof(WCHAR)) + 5 * sizeof( UINT64 );
    }

    HANDLE OpenLocalFileForUpload() throw( ComError );

    HRESULT SetLocalFileTime( FILETIME Time );

private:

    CFile(
        CJob*   Job
        );

    StringHandle    m_RemoteName;
    StringHandle    m_LocalName;
    StringHandle    m_TemporaryName;

    FILETIME        m_LocalFileTime;

    UINT64          m_BytesTotal;
    UINT64          m_BytesTransferred;

    bool            m_Completed;

    CJob *          m_Job;

    // Drive information
    StringHandle    m_VolumePath;
    StringHandle    m_CanonicalVolumePath;
    UINT            m_DriveType;
    DWORD           m_VolumeSerialNumber;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\cjob.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    cjob.cpp

Abstract :

    Main code file for handling jobs and files.

Author :

Revision History :

 ***********************************************************************/

#include "stdafx.h"
#include <malloc.h>
#include <numeric>
#include <functional>
#include <algorithm>
#include <sddl.h>

#if !defined(BITS_V12_ON_NT4)
#include "cjob.tmh"
#endif

// infinite retry wait time
//
#define INFINITE_RETRY_DELAY UINT64(-1)

//
// This is the number of seconds to keep trying to cancel an upload session in progress.
//
#define UPLOAD_CANCEL_TIMEOUT (24 * 60 * 60)

#define DEFAULT_JOB_TIMEOUT_TIME (90 * 24 * 60 * 60)

#define PROGRESS_SERIALIZE_INTERVAL (30 * NanoSec100PerSec)

// largest reply blob that can be returned via GetReplyData
//
#define MAX_EASY_REPLY_DATA (1024 * 1024)

void CJob::OnNetworkDisconnect()
{
    if (m_state == BG_JOB_STATE_QUEUED ||
        m_state == BG_JOB_STATE_TRANSIENT_ERROR)
        {
        QMErrInfo err;

        err.Set( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, BG_E_NETWORK_DISCONNECTED, NULL );
        err.result = QM_FILE_TRANSIENT_ERROR;

        FileTransientError( &err );
        }
}

void CJob::OnNetworkConnect()
{
    if (m_state == BG_JOB_STATE_TRANSIENT_ERROR)
        {
        SetState( BG_JOB_STATE_QUEUED );
        ScheduleModificationCallback();
        }
}
//------------------------------------------------------------------------

CJob::CJob()
    :
        m_ExternalInterface( new CJobExternal),
        m_state( BG_JOB_STATE_SUSPENDED ),
        m_NotifyPointer( NULL ),
        m_sd( NULL ),
        m_CurrentFile( 0 ),
        m_OldExternalJobInterface( NULL ),
        m_OldExternalGroupInterface( NULL )
{
    //
    // constructor has succeeded; allow CJobExternal to manage our lifetime.
    //
    GetExternalInterface()->SetInterfaceClass(this);
}

CJob::CJob(
    LPCWSTR     DisplayName,
    BG_JOB_TYPE Type,
    REFGUID     JobId,
    SidHandle   NotifySid
    ) :
        m_ExternalInterface( new CJobExternal),
        m_id( JobId ),
        m_name( DisplayName ),
        m_type( Type ),
        m_priority( BG_JOB_PRIORITY_NORMAL ),
        m_state( BG_JOB_STATE_SUSPENDED ),
        m_retries( 0 ),
        m_NotifySid( NotifySid ),
        m_NotifyPointer( NULL ),
        m_sd( NULL ),
        m_CurrentFile( 0 ),
        m_MinimumRetryDelay( g_GlobalInfo->m_DefaultMinimumRetryDelay ),
        m_NoProgressTimeout( g_GlobalInfo->m_DefaultNoProgressTimeout ),
        m_OldExternalJobInterface( NULL ),
        m_OldExternalGroupInterface( NULL ),
        m_TransferCompletionTime( UINT64ToFILETIME( 0 )),
        m_SerializeTime( UINT64ToFILETIME( 0 )),
        m_NotifyFlags( BG_NOTIFY_JOB_TRANSFERRED | BG_NOTIFY_JOB_ERROR ),
        m_fGroupNotifySid( FALSE )
{
    LogInfo( "new job %p : ID is %!guid!, external %p", this, &m_id, m_ExternalInterface );

    GetSystemTimeAsFileTime( &m_CreationTime );

    m_ModificationTime = m_CreationTime;
    m_LastAccessTime   = m_CreationTime;

    // we don't support group SIDs yet.
    //        THROW_HRESULT( IsGroupSid( m_NotifySid, &m_fGroupNotifySid ))

    m_sd = new CJobSecurityDescriptor( NotifySid );

    //
    // constructor has succeeded; allow CJobExternal to manage our lifetime.
    //
    GetExternalInterface()->SetInterfaceClass(this);
}


CJob::~CJob()
{
    //
    // This should be redundant, but let's be safe.
    //
    g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobModificationItem *> (this)  );

    CancelWorkitems();

    delete m_sd;

    for (CFileList::iterator iter = m_files.begin(); iter != m_files.end(); ++iter)
        {
        delete (*iter);
        }

    m_files.clear();

    if (g_LastServiceControl != SERVICE_CONTROL_SHUTDOWN)
        {
        SafeRelease( m_NotifyPointer );
        }
}

void CJob::UnlinkFromExternalInterfaces()
{
    //
    // These objects np longer control the CJob's lifetime...
    //
    if (m_ExternalInterface)
        {
        m_ExternalInterface->SetInterfaceClass( NULL );
        }

    if (m_OldExternalJobInterface)
        {
        m_OldExternalJobInterface->SetInterfaceClass( NULL );
        }

    if (m_OldExternalGroupInterface)
        {
        m_OldExternalGroupInterface->SetInterfaceClass( NULL );
        }

    //
    // ...and the CJob no longer holds a reference to them.
    //
    SafeRelease( m_ExternalInterface );
    SafeRelease( m_OldExternalJobInterface );
    SafeRelease( m_OldExternalGroupInterface );
}

void
CJob::HandleAddFile()
{

    if ( m_state == BG_JOB_STATE_TRANSFERRED )
        {
        SetState( BG_JOB_STATE_QUEUED );

        m_TransferCompletionTime = UINT64ToFILETIME( 0 );

        g_Manager->m_TaskScheduler.CancelWorkItem( (CJobRetryItem *) this );
        g_Manager->m_TaskScheduler.CancelWorkItem( (CJobCallbackItem *) this );
        g_Manager->m_TaskScheduler.CancelWorkItem( (CJobNoProgressItem *) this );
        }

    UpdateModificationTime();

    // restart the downloader if its running.
    g_Manager->RetaskJob( this );
}

//
// Returns E_INVALIDARG if one of the filesets has
//      - local name is blank
//      - local name contains invalid characters
//      - remote name is blank
//      - remote name has invalid format
//
// Returns CO_E_NOT_SUPPORTED if
//      - remote URL contains unsupported protocol
//
HRESULT
CJob::AddFileSet(
    IN  ULONG cFileCount,
    IN  BG_FILE_INFO *pFileSet
    )
{
    ULONG FirstNewIndex = m_files.size();

    try
        {
        ULONG i;

        g_Manager->ExtendMetadata( ( METADATA_FOR_FILE * cFileCount ) + METADATA_PADDING );

        for (i=0; i < cFileCount; ++i)
            {
            THROW_HRESULT( AddFile( pFileSet[i].RemoteName,
                                    pFileSet[i].LocalName,
                                    false
                                    ));
            }

        HandleAddFile();

        return S_OK;
        }
    catch ( ComError exception )
        {
        // remove all the files that were successful
        // This assumes that new files are added at the back of the sequence.
        //

        m_files.Delete( m_files.begin() + FirstNewIndex, m_files.end() );
        g_Manager->ShrinkMetadata();

        return exception.Error();
        }
}

HRESULT
CJob::AddFile(
    IN     LPCWSTR RemoteName,
    IN     LPCWSTR LocalName,
    IN     bool SingleAdd
    )
{
    HRESULT hr = S_OK;
    CFile * file = NULL;

    //
    // This check must be completed outside the try..except; otherwise
    // the attempt to add a 2nd file would delete the generated reply file
    // for the 1st file.
    //
    if (m_type != BG_JOB_TYPE_DOWNLOAD && m_files.size() > 0)
        {
        return E_INVALIDARG;
        }

    try
        {
        if ( !RemoteName || !LocalName )
            THROW_HRESULT( E_INVALIDARG );

        LogInfo("job %p addfile( %S, %S )", this, RemoteName, LocalName );

        if ( ( _GetState() == BG_JOB_STATE_CANCELLED ) ||
             ( _GetState() == BG_JOB_STATE_ACKNOWLEDGED ) )
            throw ComError( BG_E_INVALID_STATE );

        if ( SingleAdd )
            g_Manager->ExtendMetadata( METADATA_FOR_FILE + METADATA_PADDING );

        //
        // Impersonate the user while checking file access.
        //
        CNestedImpersonation imp;

        imp.SwitchToLogonToken();

        file = new CFile( this, m_type, RemoteName, LocalName );

        // WARNING: if you change this, also update the cleanup logic in AddFileSet.
        //
        m_files.push_back( file );

        //
        // Try to create the default reply file.  Ignore error, because the app
        // may be planning to set the reply file somewhere else.
        //
        if (m_type == BG_JOB_TYPE_UPLOAD_REPLY)
            {
            ((CUploadJob *) this)->GenerateReplyFile( false );
            }
        }
    catch ( ComError exception )
        {
        delete file;
        file = NULL;

        if (m_type == BG_JOB_TYPE_UPLOAD_REPLY)
            {
            ((CUploadJob *) this)->DeleteGeneratedReplyFile();
            ((CUploadJob *) this)->ClearOwnFileNameBit();
            }

        if ( SingleAdd )
            g_Manager->ShrinkMetadata();

        hr = exception.Error();
        }

    if ( SUCCEEDED(hr) && SingleAdd )
        {
        HandleAddFile();
        }

    return hr;
}

HRESULT
CJob::SetDisplayName(
    LPCWSTR Val
    )
{
    return SetLimitedString( m_name, Val, MAX_DISPLAYNAME );
}

HRESULT
CJob::GetDisplayName(
    LPWSTR * pVal
    ) const
{
    *pVal = MidlCopyString( m_name );

    return (*pVal) ? S_OK : E_OUTOFMEMORY;
}

HRESULT
CJob::SetDescription(
    LPCWSTR Val
    )
{
    return SetLimitedString( m_description, Val, MAX_DESCRIPTION );
}

HRESULT
CJob::GetDescription(
    LPWSTR *pVal
    ) const
{
    *pVal = MidlCopyString( m_description );

    return (*pVal) ? S_OK : E_OUTOFMEMORY;
}

HRESULT
CJob::SetNotifyCmdLine(
    LPCWSTR Val
    )
{
    return SetLimitedString( m_NotifyCmdLine, Val, MAX_NOTIFY_CMD_LINE );
}

HRESULT
CJob::GetNotifyCmdLine(
    LPWSTR *pVal
    ) const
{
    *pVal = MidlCopyString( m_NotifyCmdLine );

    return (*pVal) ? S_OK : E_OUTOFMEMORY;
}

HRESULT
CJob::SetProxySettings(
    BG_JOB_PROXY_USAGE ProxyUsage,
    LPCWSTR ProxyList,
    LPCWSTR ProxyBypassList
    )
{
    HRESULT hr = S_OK;

    if ( ProxyUsage != BG_JOB_PROXY_USAGE_PRECONFIG &&
         ProxyUsage != BG_JOB_PROXY_USAGE_NO_PROXY &&
         ProxyUsage != BG_JOB_PROXY_USAGE_OVERRIDE )
        {
        return E_INVALIDARG;
        }

    if ( BG_JOB_PROXY_USAGE_PRECONFIG == ProxyUsage ||
         BG_JOB_PROXY_USAGE_NO_PROXY == ProxyUsage )
        {

        if ( NULL != ProxyList ||
             NULL != ProxyBypassList )
            return E_INVALIDARG;

        }
    else
        {
        // BG_PROXY_USAGE_OVERRIDE == ProxyUsage
        if ( NULL == ProxyList )
            return E_INVALIDARG;
        }

    try
        {
        //
        // Allocate space for the new proxy settings.
        //
        CAutoString ProxyListTemp(NULL);
        CAutoString ProxyBypassListTemp(NULL);

        g_Manager->ExtendMetadata();

        if ( ProxyList )
            {
            if ( wcslen( ProxyList ) > MAX_PROXYLIST )
                throw ComError( BG_E_PROXY_LIST_TOO_LARGE );

            ProxyListTemp = CAutoString( CopyString( ProxyList ));
            }

        if ( ProxyBypassList )
           {
           if ( wcslen( ProxyBypassList ) > MAX_PROXYBYPASSLIST )
               throw ComError( BG_E_PROXY_BYPASS_LIST_TOO_LARGE );

           ProxyBypassListTemp = CAutoString( CopyString( ProxyBypassList ));
           }

        //
        // Swap the old proxy settings for the new ones.
        //
        delete[] m_ProxySettings.ProxyList;
        delete[] m_ProxySettings.ProxyBypassList;

        m_ProxySettings.ProxyUsage = ProxyUsage;
        m_ProxySettings.ProxyList = ProxyListTemp.release();
        m_ProxySettings.ProxyBypassList = ProxyBypassListTemp.release();

        //
        // Interrupt the download so that the settings are in force immediately.
        //
        g_Manager->RetaskJob( this );

        UpdateModificationTime();
        return S_OK;
        }
    catch( ComError error )
        {
        g_Manager->ShrinkMetadata();
        return error.Error();
        }
}

HRESULT
CJob::GetProxySettings(
    BG_JOB_PROXY_USAGE *pProxyUsage,
    LPWSTR *pProxyList,
    LPWSTR *pProxyBypassList
    ) const
{
    HRESULT Hr = S_OK;

    *pProxyUsage      = m_ProxySettings.ProxyUsage;
    *pProxyList       = NULL;
    *pProxyBypassList = NULL;

    try
    {
         if ( m_ProxySettings.ProxyList )
             {
             *pProxyList = MidlCopyString( m_ProxySettings.ProxyList );
             if (!*pProxyList)
                 throw ComError( E_OUTOFMEMORY );
             }

         if ( m_ProxySettings.ProxyBypassList )
             {
             *pProxyBypassList = MidlCopyString( m_ProxySettings.ProxyBypassList );
             if (!*pProxyBypassList)
                 throw ComError( E_OUTOFMEMORY );
             }
    }
    catch( ComError exception )
    {
        Hr = exception.Error();
        CoTaskMemFree( *pProxyList );
        CoTaskMemFree( *pProxyBypassList );

        *pProxyList = *pProxyBypassList = NULL;
    }

    return Hr;
}

void
CJob::GetTimes(
    BG_JOB_TIMES * s
    ) const
{
    s->CreationTime             = m_CreationTime;
    s->ModificationTime         = m_ModificationTime;
    s->TransferCompletionTime   = m_TransferCompletionTime;
}

void
CJob::GetProgress(
    BG_JOB_PROGRESS * s
    ) const
{

    s->BytesTransferred = 0;
    s->BytesTotal       = 0;

    CFileList::const_iterator iter;

    for (iter = m_files.begin(); iter != m_files.end(); ++iter)
        {
        BG_FILE_PROGRESS s2;

        (*iter)->GetProgress( &s2 );

        s->BytesTransferred += s2.BytesTransferred;

        if (s2.BytesTotal != BG_SIZE_UNKNOWN &&
            s->BytesTotal != BG_SIZE_UNKNOWN )
            {
            s->BytesTotal += s2.BytesTotal;
            }
        else
            {
            s->BytesTotal = BG_SIZE_UNKNOWN;
            }
        }

    s->FilesTransferred = m_CurrentFile;
    s->FilesTotal       = m_files.size();
}

HRESULT
CJob::GetOwner(
    LPWSTR * pVal
    ) const
{
    wchar_t * buf;
    wchar_t * str;

    if (!ConvertSidToStringSid( m_NotifySid.get(), &str))
        {
        return HRESULT_FROM_WIN32( GetLastError());
        }

    *pVal = MidlCopyString( str );

    LocalFree( str );

    return (*pVal) ? S_OK : E_OUTOFMEMORY;
}

HRESULT
CJob::SetPriority(
    BG_JOB_PRIORITY Val
    )
{
    if (Val > BG_JOB_PRIORITY_LOW ||
        Val < BG_JOB_PRIORITY_FOREGROUND)
        {
        return E_NOTIMPL;
        }

    if (Val == m_priority)
        {
        return S_OK;
        }

    m_priority = Val;

    g_Manager->RetaskJob( this );

    UpdateModificationTime();

    return S_OK;
}

HRESULT
CJob::SetNotifyFlags(
    ULONG Val
    )
{

    // Note, this flag will have no affect on a callback already in progress.

    if ( Val & ~(BG_NOTIFY_JOB_TRANSFERRED | BG_NOTIFY_JOB_ERROR | BG_NOTIFY_DISABLE | BG_NOTIFY_JOB_MODIFICATION ) )
        {
        return E_NOTIMPL;
        }

    m_NotifyFlags = Val;

    UpdateModificationTime();
    return S_OK;
}

HRESULT
CJob::SetNotifyInterface(
    IUnknown * Val
    )
{

    // Note, this flag may not have any affect on a callback already in progress.

    IBackgroundCopyCallback *pICB = NULL;

    if ( Val )
        {
        try
            {

#if !defined( BITS_V12_ON_NT4 )

            CNestedImpersonation imp;

            imp.SwitchToLogonToken();

            THROW_HRESULT( SetStaticCloaking( Val ) );
#endif

            THROW_HRESULT( Val->QueryInterface( __uuidof(IBackgroundCopyCallback),
                                                (void **) &pICB ) );
#if !defined( BITS_V12_ON_NT4 )

            // All callbacks should happen in the context of the
            // person who set the interface pointer.

            HRESULT Hr = SetStaticCloaking( pICB );

            if ( FAILED( Hr ) )
                {
                SafeRelease( pICB );
                throw ComError( Hr );
                }
#endif

            }
        catch( ComError Error )
            {
            return Error.Error();
            }
        }

    // Release the old pointer if it exists
    SafeRelease( m_NotifyPointer );
    m_NotifyPointer = pICB;

    return S_OK;
}

HRESULT
CJob::GetNotifyInterface(
    IUnknown ** ppVal
    ) const
{
    try
        {
        CNestedImpersonation imp;

        if (m_NotifyPointer)
            {
            m_NotifyPointer->AddRef();
            }

        *ppVal = m_NotifyPointer;

        return S_OK;
        }
    catch ( ComError err )
        {
        *ppVal = NULL;
        return err.Error();
        }
}

// CJob::TestNotifyInterface()
//
// See if a notification interface is provide, if so, test it to see if it is
// valid. If so, then return TRUE, else return FALSE.
BOOL
CJob::TestNotifyInterface()
{
    BOOL fValidNotifyInterface = TRUE;

    try
        {
        CNestedImpersonation imp;
        IUnknown *pPrevIntf = NULL;

        // Ok, see if there was a previously registered interface, and if
        // there is, see if it's still valid.
        if (m_NotifyPointer)
            {
            m_NotifyPointer->AddRef();
            if ( (FAILED(m_NotifyPointer->QueryInterface(IID_IUnknown,(void**)&pPrevIntf)))
                ||(pPrevIntf == NULL) )
                {
                fValidNotifyInterface = FALSE;
                }
            else
                {
                fValidNotifyInterface = TRUE;
                pPrevIntf->Release();
                }
            m_NotifyPointer->Release();
            }
        else
            {
            fValidNotifyInterface = FALSE;
            }
        }
    catch( ComError err )
        {
        fValidNotifyInterface = FALSE;
        }

    return fValidNotifyInterface;
}

HRESULT
CJob::GetMinimumRetryDelay(
    ULONG * pVal
    ) const
{
    *pVal = m_MinimumRetryDelay;
    return S_OK;
}

HRESULT
CJob::SetMinimumRetryDelay(
    ULONG Val
    )
{
    m_MinimumRetryDelay = Val;

    g_Manager->m_TaskScheduler.RescheduleDelayedTask(
        (CJobRetryItem *)this,
        (UINT64)m_MinimumRetryDelay * (UINT64) NanoSec100PerSec);

    UpdateModificationTime();
    return S_OK;
}

HRESULT
CJob::GetNoProgressTimeout(
    ULONG * pVal
    ) const
{
    *pVal = m_NoProgressTimeout;
    return S_OK;
}

HRESULT
CJob::SetNoProgressTimeout(
    ULONG Val
    )
{
    m_NoProgressTimeout = Val;

    g_Manager->m_TaskScheduler.RescheduleDelayedTask(
        (CJobNoProgressItem *)this,
        (UINT64)m_NoProgressTimeout * (UINT64) NanoSec100PerSec);

    UpdateModificationTime();
    return S_OK;
}

HRESULT
CJob::GetErrorCount(
    ULONG * pVal
    ) const
{
    *pVal = m_retries;
    return S_OK;
}


HRESULT
CJob::IsVisible()
{
    HRESULT hr;

    hr = CheckClientAccess( BG_JOB_READ );

    if (hr == S_OK)
        {
        return S_OK;
        }

    if (hr == E_ACCESSDENIED)
        {
        return S_FALSE;
        }

    return hr;
}

bool
CJob::IsOwner(
    SidHandle sid
    )
{
    return (sid == m_NotifySid);
}

void CJob::SetState( BG_JOB_STATE state )
{
    if (m_state == state)
        {
        return;
        }

    LogInfo("job %p state %d -> %d", this, m_state, state);
    m_state = state;

    bool ShouldClearError = false;

    switch( state )
    {
        case BG_JOB_STATE_QUEUED:
        case BG_JOB_STATE_CONNECTING:
            ShouldClearError = false;
            break;

        case BG_JOB_STATE_TRANSFERRING:
        case BG_JOB_STATE_SUSPENDED:
            ShouldClearError = true;
            break;

        case BG_JOB_STATE_ERROR:
        case BG_JOB_STATE_TRANSIENT_ERROR:
            ShouldClearError = false;
            break;

        case BG_JOB_STATE_TRANSFERRED:
        case BG_JOB_STATE_ACKNOWLEDGED:
        case BG_JOB_STATE_CANCELLED:
            ShouldClearError = true;
            break;

        default:
            ASSERT(0);
            break;
    }

    if (ShouldClearError)
       m_error.ClearError();

    if (state != BG_JOB_STATE_TRANSIENT_ERROR)
        {
        g_Manager->m_TaskScheduler.CancelWorkItem( (CJobRetryItem *) this );
        }

    UpdateModificationTime( false );
}



GENERIC_MAPPING CJob::s_AccessMapping =
{
    STANDARD_RIGHTS_READ,
    STANDARD_RIGHTS_WRITE,
    STANDARD_RIGHTS_EXECUTE,
    STANDARD_RIGHTS_ALL
};

HRESULT
CJob::CheckClientAccess(
    IN DWORD RequestedAccess
    ) const
/*

    Checks the current thread's access to this group.  The token must allow impersonation.

    RequestedAccess lists the standard access bits that the client needs.

*/
{
    HRESULT hr = S_OK;
    BOOL fSuccess = FALSE;
    DWORD AllowedAccess = 0;
    HANDLE hToken = 0;

    //
    // Convert generic bits into specific bits.
    //
    MapGenericMask( &RequestedAccess, &s_AccessMapping );

    try
        {

        if ( ( RequestedAccess & ~BG_JOB_READ ) &&
             ( ( m_state == BG_JOB_STATE_CANCELLED ) || ( m_state == BG_JOB_STATE_ACKNOWLEDGED ) ) )
            {
            LogError("Denying non-read access since job/file is cancelled or acknowledged");
            throw ComError(BG_E_INVALID_STATE);
            }

        CNestedImpersonation imp;

        hr = IsRemoteUser();

        if (FAILED(hr) )
            throw ComError( hr );

        if ( S_OK == hr )
            throw ComError( BG_E_REMOTE_NOT_SUPPORTED );

        THROW_HRESULT(
            m_sd->CheckTokenAccess( imp.QueryToken(),
                                    RequestedAccess,
                                    &AllowedAccess,
                                    &fSuccess
                                    ));

        if (!fSuccess || AllowedAccess != RequestedAccess)
            {
            LogWarning( "denied access %s 0x%x", fSuccess ? "TRUE" : "FALSE", AllowedAccess );

            throw ComError( E_ACCESSDENIED );
            }

        hr = S_OK;
        }
    catch (ComError exception)
        {
        hr = exception.Error();
        }

    if (hToken)
        {
        CloseHandle( hToken );
        }

    return hr;
}

bool
CJob::IsCallbackEnabled(
    DWORD bit
    )
{
    //
    // Only one bit, please.
    //
    ASSERT( 0 == (bit & (bit-1)) );

    if ((m_NotifyFlags & bit) == 0 ||
        (m_NotifyFlags & BG_NOTIFY_DISABLE))
        {
        return false;
        }

    if (m_OldExternalGroupInterface)
        {
        IBackgroundCopyCallback1 * pif = m_OldExternalGroupInterface->GetNotificationPointer();

        if (pif == NULL)
            {
            return false;
            }

        pif->Release();
        }
    else
        {
        if (m_NotifyPointer == NULL && m_NotifyCmdLine.Size() == 0)
            {
            return false;
            }
        }

    return true;
}

void
CJob::ScheduleCompletionCallback(
    DWORD Seconds
    )
{
    //
    // See whether any notification regime has been established.
    // The callback procedure will check this again, in case something has changed
    // between queuing the workitem and dispatching it.
    //
    if (!IsCallbackEnabled( BG_NOTIFY_JOB_TRANSFERRED ))
        {
        LogInfo("completion callback is not enabled");
        return;
        }

    if (g_Manager->m_TaskScheduler.IsWorkItemInScheduler( static_cast<CJobCallbackItem *>(this) ))
        {
        LogInfo("callback is already scheduled");
        return;
        }

    g_Manager->ScheduleDelayedTask( (CJobCallbackItem *) this, Seconds );
}

void
CJob::ScheduleErrorCallback(
    DWORD Seconds
    )
{
    //
    // See whether any notification regime has been established.
    // The callback procedure will check this again, in case something has changed
    // between queuing the workitem and dispatching it.
    //
    if (!IsCallbackEnabled( BG_NOTIFY_JOB_ERROR ))
        {
        LogInfo("error callback is not enabled");
        return;
        }

    if (g_Manager->m_TaskScheduler.IsWorkItemInScheduler( static_cast<CJobCallbackItem *>(this) ))
        {
        LogInfo("callback is already scheduled");
        return;
        }

    g_Manager->ScheduleDelayedTask( (CJobCallbackItem *) this, Seconds );
}

HRESULT
CJob::DeleteTemporaryFiles()
{
    return S_OK;
}

void
CJob::JobTransferred()
{
    // the file list is done
    SetState( BG_JOB_STATE_TRANSFERRED );

    g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobNoProgressItem *>( this ));

    SetCompletionTime();

    ScheduleCompletionCallback();
}

void
CJob::Transfer()
{
    HRESULT hr;
    auto_HANDLE<NULL> AutoToken;

#if !defined( BITS_V12_ON_NT4 )
    if( LogLevelEnabled( LogFlagInfo ) )
       {
       LogDl( "current job: %!guid!", &m_id );
       }
#endif

    //
    // Get a copy of the user's token.
    //
    HANDLE      hToken = NULL;
    hr = g_Manager->CloneUserToken( GetOwnerSid(), ANY_SESSION, &hToken );

    if (FAILED(hr))
        {
        if (hr == HRESULT_FROM_WIN32( ERROR_NOT_LOGGED_ON ))
            {
            LogDl( "job owner is not logged on");

            // move the group off the main list.
            g_Manager->MoveJobOffline( this );

            MoveToInactiveState();
            ScheduleModificationCallback();
            }
        else
            {
            QMErrInfo ErrInfo;

            ErrInfo.Set( SOURCE_QMGR_QUEUE, ERROR_STYLE_HRESULT, hr, "CloneUserToken" );

            LogError( "download : unable to get token %!winerr!", hr);

            FileTransientError( &ErrInfo );
            }

        g_Manager->m_TaskScheduler.CompleteWorkItem();
        return;
        }

    AutoToken = hToken;

    //
    // Download the current file.
    //
    QMErrInfo ErrInfo;
    long tries = 0;

    bool bThrottle = ShouldThrottle();

    LogDl( "Throttling %s", bThrottle ? "enabled" : "disabled" );

    if (bThrottle)
        {
        // ignore errors
        //
        (void) SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_IDLE );
        }

    if (m_state != BG_JOB_STATE_TRANSFERRING)
        {
        SetState( BG_JOB_STATE_CONNECTING );
        ScheduleModificationCallback();
        }

    if (!VerifyFileSizes( hToken ))
        {
        goto restore_thread;
        }

    ASSERT( GetCurrentFile() );     // if no more files, it shouldn't be the current job

retry:
    ErrInfo.Clear();

    if (!GetCurrentFile()->Transfer( hToken,
                                     m_priority,
                                     m_ProxySettings,
                                     &m_Credentials,
                                     ErrInfo ))
        {
        goto restore_thread;
        }

    //
    // Interpret the download result.
    //
    switch (ErrInfo.result)
        {
        case QM_FILE_TRANSIENT_ERROR: FileTransientError( &ErrInfo ); break;
        case QM_FILE_DONE:            FileComplete();                 break;
        case QM_FILE_FATAL_ERROR:     FileFatalError( &ErrInfo );     break;
        case QM_FILE_ABORTED:         break;
        default:                      ASSERT( 0 && "unhandled download result" ); break;

        case QM_SERVER_FILE_CHANGED:
            {
            FileChangedOnServer();

            if (++tries < 3)
                {
                goto retry;
                }

            g_Manager->AppendOnline( this );
            break;
            }
        }

restore_thread:

    if (bThrottle)
        {
        while (!SetThreadPriority( GetCurrentThread(), THREAD_PRIORITY_NORMAL ))
            {
            Sleep(100);
            }
        }
}

void
CJob::FileComplete()
{
    if ( GetOldExternalJobInterface() )
        {
        // Need to rename the files as they are completed for Mars.
        HRESULT Hr = GetCurrentFile()->MoveTempFile();
        if (FAILED(Hr))
            {
            QMErrInfo ErrorInfo;
            ErrorInfo.Set( SOURCE_QMGR_FILE, ERROR_STYLE_HRESULT, Hr, "Unable to rename file" );
            FileFatalError( &ErrorInfo );
            return;
            }
        }

    ++m_CurrentFile;

    if (m_CurrentFile == m_files.size())
        {
        JobTransferred();
        g_Manager->Serialize();
        }
    else
        {
        // more files to download
        UpdateModificationTime();
        }
}

bool CJob::VerifyFileSizes(
    HANDLE hToken
    )
{
    if ( AreRemoteSizesKnown() )
        {
        return true;
        }

    try
        {
        // retrieve file infomation on the file list.
        // Ignore any errors.
        LogDl("Need to retrieve file sizes before download can start");

        auto_ptr<CUnknownFileSizeList> pFileSizeList = auto_ptr<CUnknownFileSizeList>( GetUnknownFileSizeList() );

        QMErrInfo   ErrInfo;

        //
        // Release the global lock while the download is in progress.
        //
        g_Manager->m_TaskScheduler.UnlockWriter();

        LogDl( "UpdateRemoteSizes starting..." );

        g_Manager->UpdateRemoteSizes( pFileSizeList.get(),
                                      hToken,
                                      &ErrInfo,
                                      &m_ProxySettings,
                                      &m_Credentials
                                      );

        LogDl( "UpdateRemoteSizes complete." );

        ErrInfo.Log();

        ASSERT( ErrInfo.result != QM_IN_PROGRESS );

        bool fSuccessful = (ErrInfo.result != QM_FILE_ABORTED);

        //
        // Take the writer lock, since the caller expects it to be taken
        // upon return.
        //
        while (g_Manager->m_TaskScheduler.LockWriter() )
            {
            g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
            fSuccessful = false;
            }

        return fSuccessful;
        }
    catch (ComError err)
        {
        LogWarning("caught exception %u", err.Error() );
        return false;
        }
}

bool CJob::IsRunning()
{
    if (m_state == BG_JOB_STATE_TRANSFERRING ||
        m_state == BG_JOB_STATE_CONNECTING)
        {
        return true;
        }

    return false;
}


bool CJob::IsRunnable()
{
    if (m_state == BG_JOB_STATE_TRANSFERRING ||
        m_state == BG_JOB_STATE_CONNECTING   ||
        m_state == BG_JOB_STATE_QUEUED )
        {
        return true;
        }

    return false;
}

void
CJob::FileTransientError(
    QMErrInfo * ErrInfo
    )
{
    LogWarning( "job %p transient failure, interrupt count = %d", this, m_retries );

    if (_GetState() == BG_JOB_STATE_TRANSFERRING)
        {
        ++m_retries;
        }

    SetState( BG_JOB_STATE_TRANSIENT_ERROR );
    RecordError( ErrInfo );

#if !defined( BITS_V12_ON_NT4 )
    if (g_Manager->m_NetworkMonitor.GetAddressCount() > 0)
        {
#endif
        g_Manager->ScheduleDelayedTask( (CJobRetryItem *) this, m_MinimumRetryDelay );
#if !defined( BITS_V12_ON_NT4 )
        }
#endif

    if ( m_NoProgressTimeout != INFINITE &&
        !g_Manager->m_TaskScheduler.IsWorkItemInScheduler((CJobNoProgressItem *) this))
        {
        g_Manager->ScheduleDelayedTask( (CJobNoProgressItem *) this, m_NoProgressTimeout );
        }

    UpdateModificationTime();
}

bool
CJob::RecordError(
    QMErrInfo * ErrInfo
    )
{
    m_error.Set( this, m_CurrentFile, ErrInfo );
    return true;
}

void
CJob::FileFatalError(
    QMErrInfo * ErrInfo
    )
{
    // If ErrInfo is NULL, use the current error.

    if ( BG_JOB_STATE_TRANSFERRING == m_state )
        {
        ++m_retries;
        }

    g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobNoProgressItem *>(this) );
    g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobCallbackItem *>(this) );

    SetState( BG_JOB_STATE_ERROR );

    if ( ErrInfo )
        {
        RecordError( ErrInfo );
        }

    ScheduleErrorCallback();
    g_Manager->Serialize();
}

void CJob::OnRetryJob()
{
    if (g_Manager->m_TaskScheduler.LockWriter() )
        {
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        return;
        }

    g_Manager->m_TaskScheduler.CompleteWorkItem();

    ASSERT( m_state == BG_JOB_STATE_TRANSIENT_ERROR );

    SetState( BG_JOB_STATE_QUEUED );

    UpdateModificationTime();

    g_Manager->ScheduleAnotherGroup();

    g_Manager->m_TaskScheduler.UnlockWriter();
}

void CJob::RetryNow()
{
    MoveToInactiveState();
    UpdateModificationTime( false );

    //
    // Normally UpdateModificationTime() would do these things for us,
    // but we chose not to serialize.
    //
    if (g_Manager->m_TaskScheduler.IsWorkItemInScheduler( (CJobInactivityTimeout *) this))
        {
        g_Manager->m_TaskScheduler.CancelWorkItem( (CJobInactivityTimeout *) this );
        g_Manager->m_TaskScheduler.InsertDelayedWorkItem( (CJobInactivityTimeout *) this, g_GlobalInfo->m_JobInactivityTimeout );
        }

    ScheduleModificationCallback();
}

void CJob::OnNoProgress()
{
    LogInfo("job %p no-progress timeout", this);

    if (g_Manager->m_TaskScheduler.LockWriter() )
        {
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        return;
        }

    //
    // Make sure the downloader thread isn't using the job.
    // Otherwise MoveActiveJobToListEnd may get confused.
    //
    switch (m_state)
        {
        case BG_JOB_STATE_TRANSFERRING:
            {
            // The job is making progress, after all.
            //
            g_Manager->m_TaskScheduler.CompleteWorkItem();

            g_Manager->m_TaskScheduler.UnlockWriter();
            return;
            }

        case BG_JOB_STATE_CONNECTING:
            {
            g_Manager->InterruptDownload();
            break;
            }
        }

    g_Manager->m_TaskScheduler.CompleteWorkItem();

    FileFatalError( NULL );

    g_Manager->ScheduleAnotherGroup();

    g_Manager->m_TaskScheduler.UnlockWriter();
}

void CJob::UpdateProgress(
    UINT64 BytesTransferred,
    UINT64 BytesTotal
    )
{
    SetState( BG_JOB_STATE_TRANSFERRING );

    g_Manager->m_TaskScheduler.CancelWorkItem( (CJobNoProgressItem *) this );

    ScheduleModificationCallback();

    //
    // To avoid hammering the disk,
    // don't serialize every interim progress notification.
    //
    FILETIME time;
    GetSystemTimeAsFileTime( &time );

    if (FILETIMEToUINT64(time) - FILETIMEToUINT64(m_SerializeTime) > PROGRESS_SERIALIZE_INTERVAL )
        {
        UpdateModificationTime();
        }
}

void CJob::OnInactivityTimeout()
{
    if (g_Manager->m_TaskScheduler.LockWriter() )
        {
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        return;
        }

    g_Manager->m_TaskScheduler.CompleteWorkItem();

    Cancel();

    g_Manager->m_TaskScheduler.UnlockWriter();
}

BOOL IsInterfacePointerDead(
    IUnknown * punk,
    HRESULT hr
    )
{
    if (hr == MAKE_HRESULT( SEVERITY_ERROR, FACILITY_WIN32, RPC_S_SERVER_UNAVAILABLE ))
        {
        return TRUE;
        }

    return FALSE;
}


void CJob::OnMakeCallback()
/*++

Description:

    Used to notify the client app of job completion or a non-recoverable error.
    Impersonates the user, CoCreates a notification object, and calls the method.
    If the call fails, the fn posts a delayed task to retry.

At entry:

        m_method:       the method to call
        m_notifysid:    the user to impersonate
        m_error:        (if m_method is CM_ERROR)    the error that halted the job
                        (if m_method is CM_COMPLETE) zero
        m_RetryTime:    sleep time before retrying after a failed notification attempt

At exit:


--*/

{
    //
    // check for cancel, and take a reference so the job cannot be deleted
    // while this precedure is using it.
    //
    if (g_Manager->m_TaskScheduler.LockReader())
        {
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        return;
        }

    bool OldInterface = (m_OldExternalGroupInterface != NULL);

    GetExternalInterface()->AddRef();

    g_Manager->m_TaskScheduler.UnlockReader();

    //
    // Need to have this item out of the queue before the call,
    // otherwise an incoming CompleteJob() call may block trying to remove it
    // from the task scheduler queue.
    // Also prevents CancelWorkItem calls from interfering with our mutex access.
    //
    g_Manager->m_TaskScheduler.CompleteWorkItem();

    if (OldInterface)
        {
        if (FAILED(OldInterfaceCallback()))
            {
            RescheduleCallback();
            }
        }
    else
        {
        if (FAILED(InterfaceCallback()) &&
            FAILED(CmdLineCallback()))
            {
            RescheduleCallback();
            }
        }

    GetExternalInterface()->Release();
}

HRESULT
CJob::RescheduleCallback()
{
    if (g_Manager->m_TaskScheduler.LockWriter() )
        {
        LogInfo( "callback was cancelled" );
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        return S_FALSE;
        }

    switch (m_state)
        {
        case BG_JOB_STATE_TRANSFERRED:
            {
            ScheduleCompletionCallback( m_MinimumRetryDelay );
            break;
            }

        case BG_JOB_STATE_ERROR:
            {
            ScheduleErrorCallback( m_MinimumRetryDelay );
            break;
            }

        default:
            {
            LogInfo("callback failed; job state is %d so no retry is planned", m_state );
            }
        }

    g_Manager->m_TaskScheduler.UnlockWriter();

    return S_OK;
}

void
CJob::OnModificationCallback()
{
    if (g_Manager->m_TaskScheduler.LockWriter() )
        {
        LogInfo( "Modification call cancelled, ack cancel" );
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        return;
        }

    if (!IsCallbackEnabled( BG_NOTIFY_JOB_MODIFICATION ))
        {
        LogInfo( "Modification call cancelled via flag/interface change" );
        m_ModificationsPending = 0;
        g_Manager->m_TaskScheduler.CancelWorkItem(
            g_Manager->m_TaskScheduler.GetCurrentWorkItem());
        GetExternalInterface()->Release();

        g_Manager->m_TaskScheduler.UnlockWriter();
        return;
        }

    IBackgroundCopyCallback *pICB = m_NotifyPointer;
    pICB->AddRef();

    g_Manager->m_TaskScheduler.UnlockWriter();

    HRESULT Hr = pICB->JobModification( GetExternalInterface(), 0 );

    LogInfo( "JobModification call complete, result %!winerr!", Hr );

    SafeRelease( pICB );

    if (g_Manager->m_TaskScheduler.LockWriter() )
        {
        LogInfo( "Modification work item canceled before lock reaquire" );
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        return;
        }

    g_Manager->m_TaskScheduler.CompleteWorkItem();

    m_ModificationsPending--;

    if ( FAILED(Hr) && IsInterfacePointerDead( m_NotifyPointer, Hr ) )
       {
       LogInfo( "Modification interface pointer is dead, no more modifications" );
       m_ModificationsPending = 0;
       }

    if ( m_ModificationsPending )
        {
        LogInfo( "%u more modification callbacks pending, reinsert work item", m_ModificationsPending );
        g_Manager->m_TaskScheduler.InsertWorkItem( static_cast<CJobModificationItem*>(this) );
        }
    else
        {
        LogInfo( "no more modification callbacks pending, release interface ref" );
        GetExternalInterface()->Release();
        }

    g_Manager->m_TaskScheduler.UnlockWriter();

}

void
CJob::ScheduleModificationCallback()
{

    // Requires writer lock

    //
    // The old interface doesn't support this.
    //
    if (m_OldExternalGroupInterface)
        {
        return;
        }

    if (!IsCallbackEnabled( BG_NOTIFY_JOB_MODIFICATION ))
        {
        return;
        }

   if ( !m_ModificationsPending )
       {
       LogInfo( "New modification callback, adding work item for job %p", this );
       GetExternalInterface()->AddRef();
       g_Manager->m_TaskScheduler.InsertWorkItem( static_cast<CJobModificationItem*>(this) );
       }

   m_ModificationsPending++;
   min( m_ModificationsPending, 0x7FFFFFFE );
   LogInfo( "Added modification callback, new count of %u for job %p", m_ModificationsPending, this );
}

HRESULT
CJob::InterfaceCallback()
{
    bool bLocked = true;
    HRESULT hr;
    IBackgroundCopyCallback * pICB = 0;
    IBackgroundCopyError *    pJobErrorExternal = 0;

    try
        {
        CallbackMethod method;
        IBackgroundCopyJob * pJobExternal = 0;

        {
        HoldReaderLock lock ( g_Manager->m_TaskScheduler );

        pJobExternal = GetExternalInterface();

        //
        // It is possible that the job state changed after the callback was queued.
        // Make the callback based on the current job state.
        //
        if (!m_NotifyPointer)
            {
            LogInfo( "Notification pointer for job %p is NULL, skipping callback", this );
            return E_FAIL;
            }

        switch (m_state)
            {
            case BG_JOB_STATE_TRANSFERRED:
                {
                if (!IsCallbackEnabled( BG_NOTIFY_JOB_TRANSFERRED ))
                    {
                    LogInfo("error callback is not enabled");
                    return S_OK;
                    }

                method = CM_COMPLETE;
                break;
                }

            case BG_JOB_STATE_ERROR:
                {
                ASSERT( m_error.IsErrorSet() );

                if (!IsCallbackEnabled( BG_NOTIFY_JOB_ERROR ))
                    {
                    LogInfo("error callback is not enabled");
                    return S_OK;
                    }

                method = CM_ERROR;
                pJobErrorExternal = new CJobErrorExternal( &m_error );
                break;
                }

            default:
                {
                LogInfo("callback has become irrelevant, job state is %d", m_state );
                return S_OK;
                }
            }

        pICB = m_NotifyPointer;
        pICB->AddRef();
        }

        //
        // Free from the mutex, make the call.
        //
        switch (method)
            {
            case CM_COMPLETE:
                LogInfo( "callback : job %p completion", this );
                hr = pICB->JobTransferred( pJobExternal );
                break;

            case CM_ERROR:
                LogInfo( "callback : job %p error", this );
                hr = pICB->JobError( pJobExternal, pJobErrorExternal );

                break;

            default:
                LogError( "job %p: invalid callback type 0x%x", this, method );
                hr = S_OK;
                break;
            }

        LogInfo("callback completed with 0x%x", hr);

        //
        // Clear the notification pointer if it is unusable.
        //
        if (FAILED(hr))
            {
            HoldWriterLock lock ( g_Manager->m_TaskScheduler );

            if (m_NotifyPointer && IsInterfacePointerDead( m_NotifyPointer, hr ))
                {
                m_NotifyPointer->Release();
                m_NotifyPointer = NULL;
                }

            throw ComError( hr );
            }

        hr = S_OK;
        }
    catch ( ComError exception )
        {
        LogWarning( "exception %x while dispatching callback", exception.Error() );
        hr = exception.Error();
        }

    SafeRelease( pJobErrorExternal );
    SafeRelease( pICB );

    return hr;
}

HRESULT
CJob::CmdLineCallback()
{
    ASSERT( GetOldExternalGroupInterface() == 0 );

    HRESULT hr;
    CUser * user = 0;

    try
        {
        StringHandle CmdLine;

        {
        HoldReaderLock lock ( g_Manager->m_TaskScheduler );

        switch (m_state)
            {
            case BG_JOB_STATE_TRANSFERRED:
                {
                if (!IsCallbackEnabled( BG_NOTIFY_JOB_TRANSFERRED ))
                    {
                    LogInfo("error callback is not enabled");
                    return S_OK;
                    }

                break;
                }

            case BG_JOB_STATE_ERROR:
                {
                ASSERT( m_error.IsErrorSet() );

                if (!IsCallbackEnabled( BG_NOTIFY_JOB_ERROR ))
                    {
                    LogInfo("error callback is not enabled");
                    return S_OK;
                    }

                break;
                }

            default:
                {
                LogInfo("callback has become irrelevant, job state is %d", m_state );
                return S_OK;
                }
            }

        CmdLine = m_NotifyCmdLine;
        }

        //
        // Free from the mutex, launch the application.
        //
        user = g_Manager->m_Users.FindUser( GetOwnerSid(), ANY_SESSION );
        if (!user)
            {
            throw ComError( HRESULT_FROM_WIN32( ERROR_NOT_LOGGED_ON ));
            }

        THROW_HRESULT( user->LaunchProcess( CmdLine ) );

        hr = S_OK;
        }
    catch ( ComError err )
        {
        LogWarning( "exception %x while launching callback process", err.Error() );
        hr = err.Error();
        }

    if (user)
        {
        user->DecrementRefCount();
        }

    return hr;
}

HRESULT
CJob::OldInterfaceCallback()
{

   HRESULT Hr = S_OK;
   IBackgroundCopyCallback1 *pICB = NULL;
   IBackgroundCopyGroup *pGroup = NULL;
   IBackgroundCopyJob1 *pJob = NULL;

   try
        {
        CallbackMethod method;
        DWORD dwCurrentFile = 0;
        DWORD dwRetries = 0;
        DWORD dwWin32Result = 0;
        DWORD dwTransportResult = 0;

        {
        CLockedJobReadPointer LockedJob(this);

        pGroup = GetOldExternalGroupInterface();
        ASSERT( pGroup );
        pGroup->AddRef();

        //
        // It is possible that the job state changed after the callback was queued.
        // Make the callback based on the current job state.
        //
        pICB = GetOldExternalGroupInterface()->GetNotificationPointer();
        if (!pICB)
            {
            return S_FALSE;
            }

        switch (m_state)
            {
            case BG_JOB_STATE_TRANSFERRED:
                {
                if (!IsCallbackEnabled( BG_NOTIFY_JOB_TRANSFERRED ))
                    {
                    LogInfo("error callback is not enabled");
                    return S_OK;
                    }

                method = CM_COMPLETE;
                break;
                }

            case BG_JOB_STATE_ERROR:
                {
                ASSERT( m_error.IsErrorSet() );

                if (!IsCallbackEnabled( BG_NOTIFY_JOB_ERROR ))
                    {
                    LogInfo("error callback is not enabled");
                    return S_OK;
                    }

                method = CM_ERROR;

                pJob = GetOldExternalJobInterface();
                pJob->AddRef();

                dwCurrentFile = m_error.GetFileIndex();
                m_error.GetOldInterfaceErrors( &dwWin32Result, &dwTransportResult );
                THROW_HRESULT( GetErrorCount(&dwRetries) );
                break;
                }

            default:
                {
                LogInfo("callback has become irrelevant, job state is %d", m_state );
                return S_OK;
                }
            }
        }

        // Outside of lock, do the callback
        switch( method )
            {
            case CM_ERROR:
                THROW_HRESULT( pICB->OnStatus(pGroup, pJob, dwCurrentFile,
                                              QM_STATUS_GROUP_ERROR | QM_STATUS_GROUP_SUSPENDED,
                                              dwRetries,
                                              dwWin32Result,
                                              dwTransportResult) );
                break;
            case CM_COMPLETE:
                THROW_HRESULT( pICB->OnStatus(pGroup, NULL, -1, QM_STATUS_GROUP_COMPLETE, 0, 0, 0));

                GetOldExternalGroupInterface()->SetNotificationPointer( __uuidof(IBackgroundCopyCallback1),
                                                                        NULL );

                break;
            default:
                ASSERT(0);
                throw ComError( E_FAIL );
            }

        Hr = S_OK;
        }

    catch ( ComError exception )
        {
        LogWarning( "exception %x while dispatching callback", exception.Error() );
        Hr = exception.Error();
        }

   SafeRelease( pICB );
   SafeRelease( pGroup );
   SafeRelease( pJob );

   return Hr;
}
//
// Pause all activity on the job.  The service will take no action until one of
// Resume(), Cancel(), Complete() is called.
//
// if already suspended, just returns S_OK.
//
HRESULT
CJob::Suspend()
{
    return g_Manager->SuspendJob( this );
}

//
// Enable downloading for this job.
//
// if already running, just returns S_OK.
//
HRESULT
CJob::Resume()
{
    if (IsEmpty())
        {
        return BG_E_EMPTY;
        }

    switch (m_state)
        {
        case BG_JOB_STATE_SUSPENDED:
            {
            CFile * file = GetCurrentFile();
            if (!file)
                {
                // job was already transferred when it was suspended
                JobTransferred();
                return S_OK;
                }
            }

            // fall through here

        case BG_JOB_STATE_TRANSIENT_ERROR:
        case BG_JOB_STATE_ERROR:

            MoveToInactiveState();

            if (IsRunnable())
                {
                g_Manager->AppendOnline( this );
                }

            g_Manager->ScheduleAnotherGroup();
            UpdateModificationTime();

            return S_OK;

        case BG_JOB_STATE_CONNECTING:
        case BG_JOB_STATE_TRANSFERRING:
        case BG_JOB_STATE_QUEUED:
        case BG_JOB_STATE_TRANSFERRED: // no-op
            {
            return S_OK;
            }

        case BG_JOB_STATE_CANCELLED:
        case BG_JOB_STATE_ACKNOWLEDGED:
            {
            return BG_E_INVALID_STATE;
            }

        default:
            {
            ASSERT( 0 );
            return S_OK;
            }
        }

    ASSERT( 0 );
    return S_OK;
}

//
// Permanently stop the job.  The service will delete the job metadata and downloaded files.
//
HRESULT
CJob::Cancel()
{
    HRESULT Hr = S_OK;

    switch (m_state)
        {
        case BG_JOB_STATE_CONNECTING:
        case BG_JOB_STATE_TRANSFERRING:
            {
            g_Manager->InterruptDownload();
            // OK to fall through here
            }

        case BG_JOB_STATE_SUSPENDED:
        case BG_JOB_STATE_ERROR:
        case BG_JOB_STATE_QUEUED:
        case BG_JOB_STATE_TRANSIENT_ERROR:
        case BG_JOB_STATE_TRANSFERRED:
            {
            // abandon temporary files
            RETURN_HRESULT( Hr = RemoveTemporaryFiles() );

            SetState( BG_JOB_STATE_CANCELLED );

            RemoveFromManager();

            return Hr;
            }

        case BG_JOB_STATE_CANCELLED:
        case BG_JOB_STATE_ACKNOWLEDGED:
            {
            return BG_E_INVALID_STATE;
            }

        default:
            {
            ASSERT( 0 );
            return Hr;
            }
        }

    ASSERT( 0 );
    return Hr;
}

//
// Acknowledges receipt of the job-complete notification.  The service will delete
// the job metadata and leave the downloaded files.
//
HRESULT
CJob::Complete( )
{
    HRESULT hr;

    switch (m_state)
        {
        case BG_JOB_STATE_CONNECTING:
        case BG_JOB_STATE_TRANSFERRING:
        case BG_JOB_STATE_QUEUED:
        case BG_JOB_STATE_TRANSIENT_ERROR:

            Suspend();
            // OK to fall through here

        case BG_JOB_STATE_SUSPENDED:
        case BG_JOB_STATE_ERROR:
        case BG_JOB_STATE_TRANSFERRED:

            hr = S_OK;

            // move downloaded files to final destination(skip for Mars)
            if ( !GetOldExternalJobInterface() )
                {
                RETURN_HRESULT( hr = CommitTemporaryFiles() );
                }

            // hr may be S_OK, or BG_S_PARTIAL_COMPLETE.

            SetState( BG_JOB_STATE_ACKNOWLEDGED );

            RemoveFromManager();

            return hr;

        case BG_JOB_STATE_CANCELLED:
        case BG_JOB_STATE_ACKNOWLEDGED:
            {
            return BG_E_INVALID_STATE;
            }

        default:
            {
            ASSERT( 0 );
            return BG_E_INVALID_STATE;
            }
        }

    ASSERT(0);
    return BG_E_INVALID_STATE;
}


HRESULT
CJob::CommitTemporaryFiles()
{
    HRESULT Hr = S_OK;

    try
        {
        bool fPartial = false;
        CNestedImpersonation imp( GetOwnerSid() );

        CFileList::iterator iter;

        LogInfo("commit job %p", this );

        //
        // First loop, rename completed temp files.
        //
        SIZE_T FilesMoved = 0;
        for (iter = m_files.begin(); iter != m_files.end(); ++iter, FilesMoved++)
            {
            if (false == (*iter)->IsCompleted())
                {
                if ((*iter)->ReceivedAllData())
                    {
                    //
                    // Retain the first error encountered.
                    //
                    HRESULT LastResult = (*iter)->MoveTempFile();

                    if (FAILED(LastResult))
                        {
                        LogError( "commit: failed 0x%x", LastResult );
                        if (Hr == S_OK)
                            {
                            Hr = LastResult;
                            }
                        }
                    }
                else
                    {
                    fPartial = true;
                    LogInfo("commit: skipping partial file '%S'", (const WCHAR*)(*iter)->GetLocalName());
                    }
                }
            else
                {
                LogInfo("commit: skipping previously completed file '%S'", (const WCHAR*)(*iter)->GetLocalName());
                }
            }

        if (SUCCEEDED(Hr))
            {

            bool fErrorOnDelete = false;

            //
            // Second loop, delete incomplete temp files
            //
            for( iter = m_files.begin(); iter != m_files.end(); ++iter )
                {
                if (false == (*iter)->IsCompleted())
                    {
                    HRESULT HrDelete = (*iter)->DeleteTempFile();
                    if (FAILED(HrDelete))
                        fErrorOnDelete = true;
                    }
                }

            if ( fErrorOnDelete )
                Hr = BG_S_UNABLE_TO_DELETE_FILES;

            //
            // Return S_OK if all files are returned, otherwise BG_S_PARTIAL_COMPLETE.
            //
            if (fPartial)
                {
                Hr = BG_S_PARTIAL_COMPLETE;
                }

            }
        }
    catch ( ComError exception )
        {
        Hr = exception.Error();
        LogError( "commit: exception 0x%x", Hr );
        }

    //
    // If commitment failed, the job will not be deleted.
    // Update its modification time, and schedule the modification callback.
    //
    if (FAILED(Hr))
        {
        UpdateModificationTime();
        }

    return Hr;
}

HRESULT
CJob::RemoveTemporaryFilesPart2()
{

    bool bErrorOnDelete = false;

    CFileList::iterator iter;

    for (iter = m_files.begin(); iter != m_files.end(); ++iter)
        {
        HRESULT Hr = (*iter)->DeleteTempFile();
        if ( FAILED( Hr ) )
            bErrorOnDelete = true;
        }

    return bErrorOnDelete ? BG_S_UNABLE_TO_DELETE_FILES : S_OK;

}

HRESULT
CJob::RemoveTemporaryFiles()
{

    // Since the temporary files may be on a network drive
    // we need to impersonate the user before deleteing the file.
    // Unfortunatly, this itsn't always possible since the user
    // may also be be logged on and we still want to allow
    // adminstrators to cancel the job.

    try
    {
        CNestedImpersonation imp( GetOwnerSid() );
        return RemoveTemporaryFilesPart2();
    }
    catch( ComError Error )
    {
        return RemoveTemporaryFilesPart2();
    }

}

void
CJob::SetCompletionTime( const FILETIME *pftCompletionTime )
{
    FILETIME ftCurrentTime;
    if ( !pftCompletionTime )
        {
        GetSystemTimeAsFileTime( &ftCurrentTime );
        pftCompletionTime = &ftCurrentTime;
        }

    m_TransferCompletionTime = *pftCompletionTime;

    SetModificationTime( pftCompletionTime );
}

void
CJob::SetModificationTime( const FILETIME *pftModificationTime )
{
    FILETIME ftCurrentTime;
    if ( !pftModificationTime )
        {
        GetSystemTimeAsFileTime( &ftCurrentTime );
        pftModificationTime = &ftCurrentTime;
        }

    m_ModificationTime = *pftModificationTime;
}

void
CJob::SetLastAccessTime( const FILETIME *pftModificationTime )
{
    FILETIME ftCurrentTime;
    if ( !pftModificationTime )
        {
        GetSystemTimeAsFileTime( &ftCurrentTime );
        pftModificationTime = &ftCurrentTime;
        }

    m_LastAccessTime = *pftModificationTime;
}

void
CJob::OnDiskChange(
    const WCHAR *CanonicalVolume,
    DWORD VolumeSerialNumber )
{
    switch(m_state)
        {
        case BG_JOB_STATE_QUEUED:
        case BG_JOB_STATE_CONNECTING:
        case BG_JOB_STATE_TRANSFERRING:
        break;

        case BG_JOB_STATE_SUSPENDED:
        case BG_JOB_STATE_ERROR:
        return;

        case BG_JOB_STATE_TRANSIENT_ERROR:
        break;

        case BG_JOB_STATE_TRANSFERRED:
        case BG_JOB_STATE_ACKNOWLEDGED:
        case BG_JOB_STATE_CANCELLED:
        return;

        default:
            ASSERTMSG("Invalid job state", 0);
        }

    for (CFileList::iterator iter = m_files.begin(); iter != m_files.end(); ++iter)
        {
        if (!(*iter)->OnDiskChange( CanonicalVolume, VolumeSerialNumber ))
            {
            // If one file fails, the whole job fails.
            return;
            }
        }
}

void
CJob::OnDismount(
    const WCHAR *CanonicalVolume )
{
    switch(m_state)
        {
        case BG_JOB_STATE_QUEUED:
        case BG_JOB_STATE_CONNECTING:
        case BG_JOB_STATE_TRANSFERRING:
        break;

        case BG_JOB_STATE_SUSPENDED:
        case BG_JOB_STATE_ERROR:
        return;

        case BG_JOB_STATE_TRANSIENT_ERROR:
        break;

        case BG_JOB_STATE_TRANSFERRED:
        case BG_JOB_STATE_ACKNOWLEDGED:
        case BG_JOB_STATE_CANCELLED:
        return;

        default:
            ASSERTMSG("Invalid job state", 0);
        }

    for (CFileList::iterator iter = m_files.begin(); iter != m_files.end(); ++iter)
        {
        if (!(*iter)->OnDismount( CanonicalVolume ))
            {
            // If one file fails, the whole job fails.
            return;
            }
        }
}

bool
CJob::OnDeviceLock(
    const WCHAR * CanonicalVolume
    )
{
    if ( IsRunnable() )
        {
        if ( IsTransferringToDrive( CanonicalVolume ) )
            {
            if (IsRunning() )
                {
                g_Manager->InterruptDownload();
                }

            QMErrInfo ErrorInfo;
            ErrorInfo.Set( SOURCE_QMGR_FILE, ERROR_STYLE_HRESULT , BG_E_DESTINATION_LOCKED, "Destination is locked");
            FileTransientError( &ErrorInfo );

            return true;
            }
        }

    return false;
}

bool
CJob::OnDeviceUnlock(
    const WCHAR * CanonicalVolume
    )
{
    if ( BG_JOB_STATE_TRANSIENT_ERROR == m_state )
        {
        const CJobError *Error = GetError();

        ASSERT( Error );

        if ( ( Error->GetCode() == BG_E_DESTINATION_LOCKED ) &&
             ( Error->GetStyle() == ERROR_STYLE_HRESULT ) )
            {
            if ( IsTransferringToDrive( CanonicalVolume ) )
                {
                RetryNow();
                return true;
                }
            }
        }

    return false;
}

HRESULT
CJob::AssignOwnership(
    SidHandle sid
    )
{
    // If we are being called by the current
    // owner, then we have nothing to do.

    if ( sid == m_NotifySid )
        return S_OK;

    if ( IsRunning() )
        {
        g_Manager->InterruptDownload();
        }

    // revalidate access to all the local files

    HRESULT Hr = S_OK;

    for (CFileList::iterator iter = m_files.begin(); iter != m_files.end(); ++iter)
        {
        Hr = (*iter)->ValidateAccessForUser( sid,
                                             (m_type == BG_JOB_TYPE_DOWNLOAD) ? true : false );

        if (FAILED(Hr))
            {
            g_Manager->ScheduleAnotherGroup();
            return Hr;
            }
        }

    // actually reassign ownership

    CJobSecurityDescriptor *newsd = NULL;

    try
        {
        g_Manager->ExtendMetadata();

        newsd = new CJobSecurityDescriptor( sid );

        // replace the old notify sid and SECURITY_DESCRIPTOR
        delete m_sd;

        m_sd = newsd;
        m_NotifySid = sid;

        m_Credentials.Clear();

        //
        // Move the job to the online list if necessary.
        //
        g_Manager->ResetOnlineStatus( this, sid );

        //
        // Serialize and notify the client app of changes.
        //
        UpdateModificationTime();

        g_Manager->ScheduleAnotherGroup();
        return Hr;
        }
    catch( ComError Error )
        {
        Hr = Error.Error();
        delete newsd;
        g_Manager->ScheduleAnotherGroup();
        g_Manager->ShrinkMetadata();
        return Hr;
        }
}

void
CJob::MoveToInactiveState()
{

#if !defined( BITS_V12_ON_NT4 )
    if (g_Manager->m_NetworkMonitor.GetAddressCount() > 0)
        {
#endif
        SetState( BG_JOB_STATE_QUEUED );
#if !defined( BITS_V12_ON_NT4 )
        }
    else
        {
        QMErrInfo err;

        err.Set( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, BG_E_NETWORK_DISCONNECTED, NULL );
        err.result = QM_FILE_TRANSIENT_ERROR;

        if (_GetState() == BG_JOB_STATE_TRANSFERRING)
            {
            ++m_retries;
            }

        SetState( BG_JOB_STATE_TRANSIENT_ERROR );
        RecordError( &err );

        if ( m_NoProgressTimeout != INFINITE &&
            !g_Manager->m_TaskScheduler.IsWorkItemInScheduler((CJobNoProgressItem *) this))
            {
            g_Manager->ScheduleDelayedTask( (CJobNoProgressItem *) this, m_NoProgressTimeout );
            }
        }

#endif

}


CUnknownFileSizeList*
CJob::GetUnknownFileSizeList()
{
    auto_ptr<CUnknownFileSizeList> pList( new CUnknownFileSizeList );

    if (m_type == BG_JOB_TYPE_DOWNLOAD)
        {
        for(CFileList::iterator iter = m_files.begin(); iter != m_files.end(); iter++ )
             {
             if ( (*iter)->_GetBytesTotal() == -1 )
                 {
                 if (!pList->Add( (*iter), (*iter)->GetRemoteName() ) )
                     {
                     throw ComError( E_OUTOFMEMORY );
                     }
                 }
             }
        }

    return pList.release();
}

void
CJob::UpdateModificationTime(
    bool   fNotify
    )
{
    FILETIME ftCurrentTime;

    GetSystemTimeAsFileTime( &ftCurrentTime );

    SetModificationTime( &ftCurrentTime );

    UpdateLastAccessTime( );

    if (fNotify)
        {
        if (g_Manager->m_TaskScheduler.IsWorkItemInScheduler( (CJobInactivityTimeout *) this))
            {
            g_Manager->m_TaskScheduler.CancelWorkItem( (CJobInactivityTimeout *) this );
            g_Manager->m_TaskScheduler.InsertDelayedWorkItem( (CJobInactivityTimeout *) this, g_GlobalInfo->m_JobInactivityTimeout );
            }

        ScheduleModificationCallback();
        g_Manager->Serialize();
        }
}

void
CJob::UpdateLastAccessTime(
    )
{
    FILETIME ftCurrentTime;

    GetSystemTimeAsFileTime( &ftCurrentTime );

    SetLastAccessTime( &ftCurrentTime );
}

void CJob::CancelWorkitems()
{
    ASSERT( g_Manager );

    //
    // While the job-modification item is pending, it keeps a separate ref to the job.
    // The other work items share a single ref.
    //
    // g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobModificationItem *> (this)  );

    g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobInactivityTimeout *> (this) );
    g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobNoProgressItem *> (this)    );
    g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobCallbackItem *> (this)      );
    g_Manager->m_TaskScheduler.CancelWorkItem( static_cast<CJobRetryItem *> (this)         );
}

void
CJob::RemoveFromManager()
{
    //
    // The job is dead, except perhaps for a few references held by app threads.
    // Ensure that no more action is taken on this job.
    //
    CancelWorkitems();

    //
    // If the job is not already removed from the job list, remove it
    // and remove the refcount for the job's membership in the list.
    //
    if (g_Manager->RemoveJob( this ))
        {
        g_Manager->ScheduleAnotherGroup();
        g_Manager->Serialize();
        NotifyInternalDelete();
        }
}

HRESULT
CJob::SetLimitedString(
    StringHandle & destination,
    const LPCWSTR Val,
    SIZE_T limit
    )
{
    try
        {
        StringHandle name = Val;

        name.Truncate( limit );

        UpdateString( destination, name );

        return S_OK;
        }
    catch ( ComError err )
        {
        return err.Error();
        }
}

HRESULT
CJob::UpdateString(
    StringHandle & destination,
    const StringHandle & Val
    )
{
    try
        {
        if ( destination.Size() < Val.Size() )
            g_Manager->ExtendMetadata( sizeof(wchar_t) * (Val.Size() - destination.Size()) );

        destination = Val;

        UpdateModificationTime();

        return S_OK;
        }
    catch ( ComError err )
        {
        g_Manager->ShrinkMetadata();

        return err.Error();
        }
}

//------------------------------------------------------------------------

// Change the GUID  when an incompatible Serialize change is made.

GUID JobGuid_v1_5 = { /* 85e5c459-ef86-4fcd-8ea0-5b4f00d27e35 */
    0x85e5c459,
    0xef86,
    0x4fcd,
    {0x8e, 0xa0, 0x5b, 0x4f, 0x00, 0xd2, 0x7e, 0x35}
  };

GUID JobGuid_v1_0 = { /* 5770fca4-cf9f-4513-8737-972b4ea1265d */
    0x5770fca4,
    0xcf9f,
    0x4513,
    {0x87, 0x37, 0x97, 0x2b, 0x4e, 0xa1, 0x26, 0x5d}
  };

GUID UploadJobGuid_v1_5 = { /* ebc54f55-23b0-4b1a-aa3f-936c0b0fd5b3 */
    0xebc54f55,
    0x23b0,
    0x4b1a,
    {0xaa, 0x3f, 0x93, 0x6c, 0x0b, 0x0f, 0xd5, 0xb3}
  };

/* static */
CJob *
CJob::UnserializeJob(
    HANDLE hFile
    )
{
#define JOB_DOWNLOAD_V1_5   0
#define JOB_UPLOAD_V1_5     1
#define JOB_DOWNLOAD_V1     2

    const GUID * JobGuids[] = { &JobGuid_v1_5, &UploadJobGuid_v1_5, &JobGuid_v1_0, NULL };

    CJob * job = NULL;

    try
        {
        int Type = SafeReadGuidChoice( hFile, JobGuids );
        switch (Type)
            {
            case JOB_DOWNLOAD_V1:   job = new CJob;        break;
            case JOB_DOWNLOAD_V1_5: job = new CJob;        break;
            case JOB_UPLOAD_V1_5:   job = new CUploadJob;  break;

            default: THROW_HRESULT( E_FAIL );
            }

        // rewind  to the front of the GUID
        //
        SetFilePointer( hFile, -1 * LONG(sizeof(GUID)), NULL, FILE_CURRENT );

        job->Unserialize( hFile, Type );
        }
    catch( ComError err )
        {
        if (job)
            {
            job->UnlinkFromExternalInterfaces();
            delete job;
            }

        throw;
        }

    return job;
}

HRESULT
CJob::Serialize(
    HANDLE hFile
    )
{
    //
    // If this function changes, be sure that the metadata extension
    // constants are adequate.
    //

    SafeWriteBlockBegin( hFile, JobGuid_v1_5 );

    long Was_m_refs = 0;
    SafeWriteFile( hFile, Was_m_refs );

    SafeWriteFile( hFile, m_priority );
    SafeWriteFile( hFile, IsRunning() ? BG_JOB_STATE_QUEUED : m_state );
    SafeWriteFile( hFile, m_type );
    SafeWriteFile( hFile, m_id );

    SafeWriteStringHandle( hFile, m_name );
    SafeWriteStringHandle( hFile, m_description );
    SafeWriteStringHandle( hFile, m_NotifyCmdLine );

    SafeWriteSid( hFile, m_NotifySid );

    SafeWriteFile( hFile, m_NotifyFlags );
    SafeWriteFile( hFile, m_fGroupNotifySid );
    SafeWriteFile( hFile, m_CurrentFile );

    m_sd->Serialize( hFile );
    m_files.Serialize( hFile );

    m_error.Serialize( hFile );

    SafeWriteFile( hFile, m_retries );
    SafeWriteFile( hFile, m_MinimumRetryDelay );
    SafeWriteFile( hFile, m_NoProgressTimeout );

    SafeWriteFile( hFile, m_CreationTime );
    SafeWriteFile( hFile, m_LastAccessTime );
    SafeWriteFile( hFile, m_ModificationTime );
    SafeWriteFile( hFile, m_TransferCompletionTime );

    if ( GetOldExternalGroupInterface() )
        {
        SafeWriteFile( hFile, (bool)true );
        GetOldExternalGroupInterface()->Serialize( hFile );
        }
    else
        {
        SafeWriteFile( hFile, (bool)false );
        }

    SafeWriteFile( hFile, m_method );

    ((CJobInactivityTimeout *) this)->Serialize( hFile );
    ((CJobNoProgressItem *) this)->Serialize( hFile );
    ((CJobCallbackItem *) this)->Serialize( hFile );
    ((CJobRetryItem *) this)->Serialize( hFile );

    SafeWriteFile( hFile, m_ProxySettings.ProxyUsage );
    SafeWriteFile( hFile, m_ProxySettings.ProxyList );
    SafeWriteFile( hFile, m_ProxySettings.ProxyBypassList );

    m_Credentials.Serialize( hFile );

    SafeWriteBlockEnd( hFile, JobGuid_v1_5 );

    GetSystemTimeAsFileTime( &m_SerializeTime );
    return S_OK;
}

void
CJob::Unserialize(
    HANDLE hFile,
    int Type
    )
{
    try
        {
        LogInfo("job : unserializing %p", this);

        SafeReadBlockBegin( hFile, (Type != JOB_DOWNLOAD_V1) ? JobGuid_v1_5 : JobGuid_v1_0 );

        long Was_m_refs = 0;
        SafeReadFile( hFile, &Was_m_refs );

        SafeReadFile( hFile, &m_priority );
        SafeReadFile( hFile, &m_state );
        SafeReadFile( hFile, &m_type );
        SafeReadFile( hFile, &m_id );

        m_name = SafeReadStringHandle( hFile );
        m_description = SafeReadStringHandle( hFile );

        if (Type != JOB_DOWNLOAD_V1)
            {
            m_NotifyCmdLine = SafeReadStringHandle( hFile );
            }

        SafeReadSid( hFile, m_NotifySid );

        SafeReadFile( hFile, &m_NotifyFlags );
        SafeReadFile( hFile, &m_fGroupNotifySid );
        SafeReadFile( hFile, &m_CurrentFile );

        m_sd = CJobSecurityDescriptor::Unserialize( hFile );
        m_files.Unserialize( hFile, this );

        m_error.Unserialize( hFile, this );

        SafeReadFile( hFile, &m_retries );
        SafeReadFile( hFile, &m_MinimumRetryDelay );
        SafeReadFile( hFile, &m_NoProgressTimeout );

        SafeReadFile( hFile, &m_CreationTime );
        SafeReadFile( hFile, &m_LastAccessTime );
        SafeReadFile( hFile, &m_ModificationTime );
        SafeReadFile( hFile, &m_TransferCompletionTime );

        bool bHasOldExternalGroupInterface = false;
        SafeReadFile( hFile, &bHasOldExternalGroupInterface );

        if (bHasOldExternalGroupInterface)
            {
            COldGroupInterface *OldGroup = COldGroupInterface::UnSerialize( hFile, this );
            SetOldExternalGroupInterface( OldGroup );
            }

        SafeReadFile( hFile, &m_method );

        ((CJobInactivityTimeout *) this)->Unserialize( hFile );
        ((CJobNoProgressItem *) this)->Unserialize( hFile );
        ((CJobCallbackItem *) this)->Unserialize( hFile );
        ((CJobRetryItem *) this)->Unserialize( hFile );

        SafeReadFile( hFile, &m_ProxySettings.ProxyUsage );
        SafeReadFile( hFile, &m_ProxySettings.ProxyList );
        SafeReadFile( hFile, &m_ProxySettings.ProxyBypassList );

        if (Type != JOB_DOWNLOAD_V1)
            {
            m_Credentials.Unserialize( hFile );
            }

        SafeReadBlockEnd( hFile, (Type != JOB_DOWNLOAD_V1) ? JobGuid_v1_5 : JobGuid_v1_0 );
        }
    catch( ComError Error )
        {
        LogError("invalid job data");
        throw;
        }
}

CUploadJob::CUploadJob(
    LPCWSTR     DisplayName,
    BG_JOB_TYPE Type,
    REFGUID     JobId,
    SidHandle   NotifySid
    )
    : CJob( DisplayName, Type, JobId, NotifySid ),
      m_ReplyFile( 0 )
{
}

CUploadJob::~CUploadJob()
{
    delete m_ReplyFile;
}

HRESULT
CUploadJob::Serialize(
    HANDLE hFile
    )
{
    LogInfo("serializing upload job %p", this);

    SafeWriteBlockBegin( hFile, UploadJobGuid_v1_5 );

    CJob::Serialize( hFile );

    // additional data not in a download job
    //
    m_UploadData.Serialize( hFile );

    SafeWriteFile( hFile, m_fOwnReplyFileName );
    SafeWriteStringHandle( hFile, m_ReplyFileName );

    if (m_ReplyFile)
        {
        SafeWriteFile( hFile, true );
        m_ReplyFile->Serialize( hFile );
        }
    else
        {
        SafeWriteFile( hFile, false );
        }

    SafeWriteBlockEnd( hFile, UploadJobGuid_v1_5 );

    return S_OK;
}

void
CUploadJob::Unserialize(
    HANDLE hFile,
    int Type
    )
{
    ASSERT( Type == JOB_UPLOAD_V1_5 );

    LogInfo("unserializing upload job %p", this);

    SafeReadBlockBegin( hFile, UploadJobGuid_v1_5 );

    CJob::Unserialize( hFile, Type );

    // additional data not in a download job
    //
    m_UploadData.Unserialize( hFile );

    SafeReadFile( hFile, &m_fOwnReplyFileName );
    m_ReplyFileName = SafeReadStringHandle( hFile );

    bool fReplyFile;
    SafeReadFile( hFile, &fReplyFile );

    if (fReplyFile)
        {
        m_ReplyFile = CFile::Unserialize( hFile, this );
        }

    SafeReadBlockEnd( hFile, UploadJobGuid_v1_5 );

    if (m_state == BG_JOB_STATE_CANCELLED ||
        m_state == BG_JOB_STATE_ACKNOWLEDGED)
        {
        if (g_Manager->m_TaskScheduler.IsWorkItemInScheduler(static_cast<CJobRetryItem *>(this)))
            {
            m_UploadData.fSchedulable = false;
            }
        }
}

UPLOAD_DATA::UPLOAD_DATA()
{
    State = UPLOAD_STATE_CREATE_SESSION;
    fSchedulable = true;

    memset( &SessionId,  0, sizeof( GUID ));
    memset( &Protocol, 0, sizeof( GUID ));

    HostId = NULL;
    HostIdFallbackTimeout = 0xFFFFFFFF;

    memset( &HostIdNoProgressStartTime, 0, sizeof(HostIdNoProgressStartTime) );
}

UPLOAD_DATA::~UPLOAD_DATA()
{
}

void
UPLOAD_DATA::SetUploadState(
    UPLOAD_STATE NewState
    )
{
    if (State != NewState)
        {
        LogInfo( "upload state: %d -> %d", State, NewState );
        State = NewState;
        }
}

void
UPLOAD_DATA::Serialize(
    HANDLE hFile
    )
{
    SafeWriteFile( hFile, State );
    SafeWriteFile( hFile, SessionId );
    SafeWriteFile( hFile, Protocol );

    SafeWriteStringHandle( hFile, ReplyUrl );
    SafeWriteStringHandle( hFile, HostId );
    SafeWriteFile( hFile, HostIdFallbackTimeout );
    SafeWriteFile( hFile, HostIdNoProgressStartTime );

}

void
UPLOAD_DATA::Unserialize(
    HANDLE hFile
    )
{

    SafeReadFile( hFile, &State );
    SafeReadFile( hFile, &SessionId );
    SafeReadFile( hFile, &Protocol );

    ReplyUrl = SafeReadStringHandle( hFile );
    HostId   = SafeReadStringHandle( hFile );
    SafeReadFile( hFile, &HostIdFallbackTimeout );
    SafeReadFile( hFile, &HostIdNoProgressStartTime );

    fSchedulable = true;

}

void CUploadJob::Transfer()
{
}

HRESULT
CUploadJob::Complete()
{
    HRESULT hr;

    switch (m_state)
        {
        case BG_JOB_STATE_TRANSFERRED:

            hr = S_OK;

            RETURN_HRESULT( hr = CommitReplyFile() );

            // hr may be S_OK, or BG_S_PARTIAL_COMPLETE.

            SetState( BG_JOB_STATE_ACKNOWLEDGED );

            RemoveFromManager();

            return hr;

        default:
            {
            return BG_E_INVALID_STATE;
            }
        }

    ASSERT(0);
    return BG_E_INVALID_STATE;
}

HRESULT
CUploadJob::Cancel()
{
    HRESULT Hr = S_OK;

    switch (m_state)
        {
        case BG_JOB_STATE_CONNECTING:
        case BG_JOB_STATE_TRANSFERRING:
            {
            g_Manager->InterruptDownload();
            // OK to fall through here
            }

        case BG_JOB_STATE_SUSPENDED:
        case BG_JOB_STATE_ERROR:
        case BG_JOB_STATE_QUEUED:
        case BG_JOB_STATE_TRANSIENT_ERROR:
        case BG_JOB_STATE_TRANSFERRED:
            {
            RETURN_HRESULT( Hr = RemoveReplyFile() );

            // Hr may be BG_S_UNABLE_TO_REMOVE_FILES

            SetState( BG_JOB_STATE_CANCELLED );

            //
            // If the close-session exchange has not happened yet,
            // begin a cancel-session exchange.
            //
            if (SessionInProgress())
                {
                LogInfo("job %p: upload session in state %d, cancelling", this, m_UploadData.State );

                g_Manager->m_TaskScheduler.CancelWorkItem( (CJobCallbackItem *) this );

                SetNoProgressTimeout( UPLOAD_CANCEL_TIMEOUT );

                m_UploadData.SetUploadState( UPLOAD_STATE_CANCEL_SESSION );

                g_Manager->ScheduleAnotherGroup();
                g_Manager->Serialize();
                }
            else
                {
                RemoveFromManager();
                }

            return Hr;
            }

        case BG_JOB_STATE_CANCELLED:
        case BG_JOB_STATE_ACKNOWLEDGED:
            {
            return BG_E_INVALID_STATE;
            }

        default:
            {
            ASSERT( 0 );
            return Hr;
            }
        }

    ASSERT( 0 );
    return Hr;
}

void
CUploadJob::FileComplete()
{
    //
    // The downloader successfully completed one of three things:
    //
    // 1. job type is UPLOAD. The file was uploaded and the session closed.
    // 2. job type is UPLOAD_REPLY.  The file was uploaded, reply downloaded, and session closed.
    // 3. either job type; an early Cancel required the job to cancel the session.
    //
    switch (m_state)
        {
        case BG_JOB_STATE_CANCELLED:
        case BG_JOB_STATE_ACKNOWLEDGED:
            {
            ASSERT (m_UploadData.State == UPLOAD_STATE_CLOSED || m_UploadData.State == UPLOAD_STATE_CANCELLED);

            RemoveFromManager();
            break;
            }

        default:
            {
            ++m_CurrentFile;

            JobTransferred();
            g_Manager->Serialize();
            }
        }
}

void
CUploadJob::UpdateProgress(
    UINT64 BytesTransferred,
    UINT64 BytesTotal
    )
{

    memset( &GetUploadData().HostIdNoProgressStartTime, 0,
            sizeof( GetUploadData().HostIdNoProgressStartTime ) );

    CJob::UpdateProgress( BytesTransferred, BytesTotal );

}

bool
CUploadJob::CheckHostIdFallbackTimeout()
{

    if ( GetUploadData().HostIdFallbackTimeout != 0xFFFFFFFF )
        {

        UINT64 HostIdNoProgressStartTime = FILETIMEToUINT64( GetUploadData().HostIdNoProgressStartTime );

        if ( HostIdNoProgressStartTime )
            {

            UINT64 TimeoutTime = HostIdNoProgressStartTime +
                GetUploadData().HostIdFallbackTimeout * NanoSec100PerSec;


            if ( TimeoutTime < HostIdNoProgressStartTime )
                return true; //wraparound


            FILETIME CurrentTimeAsFileTime;
            GetSystemTimeAsFileTime( &CurrentTimeAsFileTime );

            UINT64 CurrentTime = FILETIMEToUINT64( CurrentTimeAsFileTime );

            if ( CurrentTime > TimeoutTime )
                return true;

            }

        }

    return false;

}

void
CUploadJob::FileFatalError(
    QMErrInfo * ErrInfo
    )
{
    switch (m_state)
        {
        case BG_JOB_STATE_CANCELLED:
        case BG_JOB_STATE_ACKNOWLEDGED:
            {
            ASSERT (m_UploadData.State == UPLOAD_STATE_CLOSE_SESSION || m_UploadData.State == UPLOAD_STATE_CANCEL_SESSION);

            RemoveFromManager();
            break;
            }

        default:
            {

            if ( CheckHostIdFallbackTimeout() )
                {
                LogError( "Reverting back to main URL since the timeout has expired" );
                FileTransientError( ErrInfo );
                return;
                }

            CJob::FileFatalError( ErrInfo );
            }
        }
}

void
CUploadJob::FileTransientError(
    QMErrInfo * ErrInfo
    )
{

    bool ShouldRevertToOriginalURL = CheckHostIdFallbackTimeout();

    if ( ShouldRevertToOriginalURL )
        {

        LogError( "Reverting back to main URL since the timeout has expired" );

        GetUploadData().HostId = StringHandle();
        GetUploadData().HostIdFallbackTimeout = 0xFFFFFFFF;

        }

    switch (m_state)
        {
        case BG_JOB_STATE_CANCELLED:
        case BG_JOB_STATE_ACKNOWLEDGED:
            {
            LogWarning( "job %p transient failure in state %d", this, m_state );

#if !defined( BITS_V12_ON_NT4 )
            if (g_Manager->m_NetworkMonitor.GetAddressCount() > 0)
                {
#endif
                g_Manager->ScheduleDelayedTask( (CJobRetryItem *) this, m_MinimumRetryDelay );
#if !defined( BITS_V12_ON_NT4 )
                }
#endif

            m_UploadData.fSchedulable = false;
            break;
            }

        default:
            {
            CJob::FileTransientError( ErrInfo );
            }
        }

    if ( ShouldRevertToOriginalURL )
        {
        if ( g_Manager->m_TaskScheduler.IsWorkItemInScheduler((CJobNoProgressItem *) this))
            {
            g_Manager->m_TaskScheduler.RescheduleDelayedTask( (CJobNoProgressItem *) this, 0 );
            }
        }
    else if ( GetUploadData().HostIdFallbackTimeout != 0xFFFFFFFF &&
              !FILETIMEToUINT64( GetUploadData().HostIdNoProgressStartTime ) )
        {
        GetSystemTimeAsFileTime( &GetUploadData().HostIdNoProgressStartTime );
        }
}

void CUploadJob::OnRetryJob()
{
    if (g_Manager->m_TaskScheduler.LockWriter() )
        {
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        return;
        }

    if (m_state == BG_JOB_STATE_TRANSIENT_ERROR)
        {
        SetState( BG_JOB_STATE_QUEUED );

        UpdateModificationTime();
        }
    else if (m_state == BG_JOB_STATE_CANCELLED ||
             m_state == BG_JOB_STATE_ACKNOWLEDGED)
        {
        m_UploadData.fSchedulable = true;
        g_Manager->AppendOnline( this );
        }

    g_Manager->m_TaskScheduler.CompleteWorkItem();

    g_Manager->ScheduleAnotherGroup();

    g_Manager->m_TaskScheduler.UnlockWriter();
}

void CUploadJob::OnInactivityTimeout()
{
    if (g_Manager->m_TaskScheduler.LockWriter() )
        {
        g_Manager->m_TaskScheduler.AcknowledgeWorkItemCancel();
        return;
        }

    g_Manager->m_TaskScheduler.CompleteWorkItem();

    RemoveFromManager();

    g_Manager->m_TaskScheduler.UnlockWriter();
}

void CUploadJob::OnNetworkDisconnect()
{
    switch (m_state)
        {
        case BG_JOB_STATE_QUEUED:
        case BG_JOB_STATE_TRANSIENT_ERROR:
            {
            QMErrInfo err;

            err.Set( SOURCE_HTTP_CLIENT_CONN, ERROR_STYLE_HRESULT, BG_E_NETWORK_DISCONNECTED, NULL );
            err.result = QM_FILE_TRANSIENT_ERROR;

            FileTransientError( &err );
            break;
            }

        case BG_JOB_STATE_CANCELLED:
        case BG_JOB_STATE_ACKNOWLEDGED:
            {
            m_UploadData.fSchedulable = false;
            break;
            }
        }
}

void CUploadJob::OnNetworkConnect()
{
    if (m_state == BG_JOB_STATE_TRANSIENT_ERROR)
        {
        SetState( BG_JOB_STATE_QUEUED );
        ScheduleModificationCallback();
        }
    else if (m_state == BG_JOB_STATE_ACKNOWLEDGED ||
             m_state == BG_JOB_STATE_CANCELLED)
        {
        m_UploadData.fSchedulable = true;
        }
}

bool CUploadJob::IsRunnable()
{
    switch (m_state)
        {
        case BG_JOB_STATE_SUSPENDED:
        case BG_JOB_STATE_ERROR:
        case BG_JOB_STATE_TRANSIENT_ERROR:

            return false;

        default:

            if (m_UploadData.fSchedulable &&
                m_UploadData.State != UPLOAD_STATE_CLOSED &&
                m_UploadData.State != UPLOAD_STATE_CANCELLED )
                {
                return true;
                }

            return false;
        }
}

HRESULT
CUploadJob::RemoveReplyFile()
{
    //
    // Since the temporary files may be on a network drive
    // we need to impersonate the user before deleting the file.
    // Unfortunately, this isn't always possible since the user
    // may also be be logged on and we still want to allow
    // administrators to cancel the job.
    //
    CSaveThreadToken save;
    auto_HANDLE<NULL> token;

    if (S_OK == g_Manager->CloneUserToken( GetOwnerSid(), ANY_SESSION, token.GetWritePointer() ))
        {
        ImpersonateLoggedOnUser( token.get() );
        }

    //
    // Delete the reply file, if it was created by BITS.
    // Delete the temporary reply file
    //
    HRESULT Hr;
    HRESULT FinalHr = S_OK;

    if (FAILED( DeleteGeneratedReplyFile() ))
        {
        FinalHr = BG_S_UNABLE_TO_DELETE_FILES;
        }

    m_fOwnReplyFileName = false;

    if (m_ReplyFile)
        {
        Hr = m_ReplyFile->DeleteTempFile();

        if (FAILED(Hr))
            {
            FinalHr = BG_S_UNABLE_TO_DELETE_FILES;
            }
        }

    return FinalHr;
}

HRESULT
CUploadJob::CommitReplyFile()
{
    // Since the temporary files may be on a network drive
    // we need to impersonate the user before deleting the file.
    // Unfortunately, this isn't always possible since the user
    // may also be be logged on and we still want to allow
    // administrators to complete the job.
    CSaveThreadToken save;
    auto_HANDLE<NULL> token;

    if (S_OK == g_Manager->CloneUserToken( GetOwnerSid(), ANY_SESSION, token.GetWritePointer() ))
        {
        ImpersonateLoggedOnUser( token.get() );
        }

    //
    // Commit the reply file if it is complete.
    // Otherwise, clean it up.
    //
    if (m_ReplyFile && m_ReplyFile->ReceivedAllData())
        {
        RETURN_HRESULT( m_ReplyFile->MoveTempFile() );
        }
    else
        {
        LogInfo("commit reply: skipping partial file '%S'",
                m_ReplyFile ? (const WCHAR*) m_ReplyFile->GetLocalName() : L"(null)");

        RemoveReplyFile();

        return BG_S_PARTIAL_COMPLETE;
        }

    return S_OK;
}

//------------------------------------------------------------------------

GUID FileListStorageGuid = { /* 7756da36-516f-435a-acac-44a248fff34d */
    0x7756da36,
    0x516f,
    0x435a,
    {0xac, 0xac, 0x44, 0xa2, 0x48, 0xff, 0xf3, 0x4d}
  };

HRESULT
CJob::CFileList::Serialize(
    HANDLE hFile
    )
{

    //
    // If this function changes, be sure that the metadata extension
    // constants are adequate.
    //

    iterator iter;

    SafeWriteBlockBegin( hFile, FileListStorageGuid );

    DWORD count = size();

    SafeWriteFile( hFile, count );

    for (iter=begin(); iter != end(); ++iter)
        {
        (*iter)->Serialize( hFile );
        }

    SafeWriteBlockEnd( hFile, FileListStorageGuid );

    return S_OK;
}

void
CJob::CFileList::Unserialize(
    HANDLE hFile,
    CJob*  Job
    )
{
    DWORD i, count;

    SafeReadBlockBegin( hFile, FileListStorageGuid );

    SafeReadFile( hFile, &count );

    for (i=0; i < count; ++i)
        {
        CFile * file = CFile::Unserialize( hFile, Job );

        push_back( file );
        }

    SafeReadBlockEnd( hFile, FileListStorageGuid );

}

void
CJob::CFileList::Delete(
    CFileList::iterator Initial,
    CFileList::iterator Terminal
    )
{
    //
    // delete the CFile objects
    //
    iterator iter = Initial;

    while (iter != Terminal)
        {
        CFile * file = (*iter);

        ++iter;

        delete file;
        }

    //
    // erase them from the dictionary
    //
    erase( Initial, Terminal );
}


//------------------------------------------------------------------------

HRESULT CLockedJobWritePointer::ValidateAccess()
{
    HRESULT hr = CLockedWritePointer<CJob, BG_JOB_WRITE>::ValidateAccess();

    if (SUCCEEDED(hr))
        {
        m_Pointer->UpdateLastAccessTime();
        }

    return hr;
}

HRESULT CLockedJobReadPointer::ValidateAccess()
{
    HRESULT hr = CLockedReadPointer<CJob, BG_JOB_READ>::ValidateAccess();

    if (SUCCEEDED(hr))
        {
        ((CJob *) m_Pointer)->UpdateLastAccessTime();
        }

    return hr;
}


CJobExternal::CJobExternal()
    : m_ServiceInstance( g_ServiceInstance ),
      pJob( NULL ),
      m_refs(1)
{
}

CJobExternal::~CJobExternal()
{
    //
    // Delete the underlying job object, unless it was already deleted when the service stopped.
    //
    if (g_ServiceInstance != m_ServiceInstance ||
        g_ServiceState    != MANAGER_ACTIVE)
        {
        return;
        }

    delete pJob;
}

STDMETHODIMP
CJobExternal::QueryInterface(
    REFIID iid,
    void** ppvObject
    )
{
    BEGIN_EXTERNAL_FUNC

    HRESULT Hr = S_OK;
    *ppvObject = NULL;

    if (iid == __uuidof(IUnknown)
        || iid == __uuidof(IBackgroundCopyJob)
#if !defined( BITS_V12 )
        || iid == __uuidof(IBackgroundCopyJob2)
#endif
        )
        {
        *ppvObject = (IBackgroundCopyJob2 *) this;
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else
        {
        Hr = E_NOINTERFACE;
        }

    LogRef( "job %p, iid %!guid!, Hr %x", pJob, &iid, Hr );
    return Hr;

    END_EXTERNAL_FUNC
}

ULONG
CJobExternal::AddRef()
{
    BEGIN_EXTERNAL_FUNC

    ULONG newrefs = InterlockedIncrement(&m_refs);

    LogRef( "job %p, refs = %d", pJob, newrefs );

    return newrefs;

    END_EXTERNAL_FUNC

}

ULONG
CJobExternal::Release()
{
    BEGIN_EXTERNAL_FUNC

    ULONG newrefs = InterlockedDecrement(&m_refs);

    LogRef( "job %p, refs = %d", pJob, newrefs );

    if (newrefs == 0)
        {
        delete this;
        }

    return newrefs;

    END_EXTERNAL_FUNC
}


STDMETHODIMP
CJobExternal::AddFileSetInternal(
    /* [in] */ ULONG cFileCount,
    /* [size_is][in] */ BG_FILE_INFO *pFileSet
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "cFileCount %u, pFileSet %p", cFileCount, pFileSet );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->AddFileSet( cFileCount, pFileSet );
        }

    LogPublicApiEnd( "cFileCount %u, pFileSet %p", cFileCount, pFileSet );
    return Hr;
}

STDMETHODIMP
CJobExternal::AddFileInternal(
    /* [in] */ LPCWSTR RemoteUrl,
    /* [in] */ LPCWSTR LocalName
    )
{

    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "RemoteUrl %S, LocalName %S", RemoteUrl, LocalName );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->AddFile( RemoteUrl, LocalName, true );
        }
    LogPublicApiEnd( "RemoteUrl %S, LocalName %S", RemoteUrl, LocalName );
    return Hr;

}

STDMETHODIMP
CJobExternal::EnumFilesInternal(
    /* [out] */ IEnumBackgroundCopyFiles **ppEnum
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "ppEnum %p", ppEnum );
    HRESULT Hr = S_OK;

    CEnumFiles *pEnum = NULL;
    try
        {

        *ppEnum = NULL;

        THROW_HRESULT( LockedJob.ValidateAccess());

        pEnum = new CEnumFiles;

        for (CJob::CFileList::const_iterator iter = LockedJob->m_files.begin();
             iter != LockedJob->m_files.end(); ++iter)
            {
            CFileExternal * file = (*iter)->CreateExternalInterface();

            pEnum->Add( file );

            file->Release();
            }

        *ppEnum = pEnum;

        Hr = S_OK;
        }

    catch ( ComError exception )
        {
        Hr = exception.Error();
        SafeRelease( pEnum );
        }

    LogPublicApiEnd( "ppEnum %p(%p)", ppEnum, *ppEnum );
    return Hr;
}

STDMETHODIMP
CJobExternal::SuspendInternal(
    void
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( " " );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->Suspend();
        }
    LogPublicApiEnd( " " );
    return Hr;
}

STDMETHODIMP
CJobExternal::ResumeInternal(
    void
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( " " );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->Resume();
        }
    LogPublicApiEnd( " " );
    return Hr;
}

STDMETHODIMP
CJobExternal::CancelInternal(
    void
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( " " );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->Cancel();
        }
    LogPublicApiEnd( " " );
    return Hr;
}

STDMETHODIMP
CJobExternal::CompleteInternal(
    void
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( " " );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->Complete();
        }
    LogPublicApiEnd( " " );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetIdInternal(
    /* [out] */ GUID *pVal
    )
{
CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "GetId pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        *pVal = LockedJob->GetId();
        }
    LogPublicApiEnd( "pVal %p(%!guid!)", pVal, pVal );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetTypeInternal(
    /* [out] */ BG_JOB_TYPE *pVal
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        *pVal = LockedJob->GetType();
        }
    LogPublicApiEnd( "pVal %p(%u)", pVal, *pVal );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetProgressInternal(
    /* [out] */ BG_JOB_PROGRESS *pVal
    )
{

    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        LockedJob->GetProgress( pVal );
        }
    LogPublicApiEnd( "pVal %p", pVal );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetTimesInternal(
    /* [out] */ BG_JOB_TIMES *pVal
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        LockedJob->GetTimes( pVal );
        }
    LogPublicApiEnd( "pVal %p", pVal );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetStateInternal(
    /* [out] */ BG_JOB_STATE *pVal
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        *pVal = LockedJob->_GetState();
        }
    LogPublicApiEnd( "state %d", *pVal );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetErrorInternal(
    /* [out] */ IBackgroundCopyError **ppError
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "ppError %p", ppError );

    *ppError = NULL;

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        const CJobError *Error = LockedJob->GetError();

        if ( !Error )
            {
            Hr = BG_E_ERROR_INFORMATION_UNAVAILABLE;
            }
        else
            {
            try
                {
                *ppError = new CJobErrorExternal( Error );
                Hr = S_OK;
                }
            catch ( ComError err )
                {
                Hr = err.Error();
                }
            }
        }
    LogPublicApiEnd( "pError %p", *ppError );
    return Hr;
}

STDMETHODIMP
CJobExternal::SetDisplayNameInternal(
    /* [in] */ LPCWSTR Val
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "Val %S", Val );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetDisplayName( Val );
        }
    LogPublicApiEnd( "Val %S", Val );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetDisplayNameInternal(
    /* [out] */ LPWSTR *pVal
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetDisplayName( pVal );
        }
    LogPublicApiEnd( "pVal %p(%S)", pVal, SUCCEEDED(Hr) ? *pVal : L"?" );
    return Hr;
}

STDMETHODIMP
CJobExternal::SetDescriptionInternal(
    /* [in] */ LPCWSTR Val
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "Val %S", Val );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetDescription( Val );
        }
    LogPublicApiEnd( "Val %S", Val );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetDescriptionInternal(
    /* [out] */ LPWSTR *pVal
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin("pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetDescription( pVal );
        }
    LogPublicApiEnd("pVal %p(%S)", pVal, SUCCEEDED(Hr) ? *pVal : L"?" );
    return Hr;
}

STDMETHODIMP
CJobExternal::SetPriorityInternal(
    /* [in] */ BG_JOB_PRIORITY Val
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin("Val %u", Val);
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetPriority( Val );
        }
    LogPublicApiEnd("Val %u", Val );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetPriorityInternal(
     /* [out] */ BG_JOB_PRIORITY *pVal
     )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        *pVal = LockedJob->_GetPriority();
        }
    LogPublicApiEnd( "pVal %p(%u)", pVal, *pVal );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetOwnerInternal(
    /* [out] */ LPWSTR *pVal
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetOwner( pVal );
        }
    LogPublicApiEnd( "pVal %p(%S)", pVal, SUCCEEDED(Hr) ? *pVal : L"?" );
    return Hr;
}

STDMETHODIMP
CJobExternal::SetNotifyFlagsInternal(
    /* [in] */ ULONG Val
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "Val %u", Val );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetNotifyFlags( Val );
        }
    LogPublicApiEnd( "Val %u", Val );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetNotifyFlagsInternal(
    /* [out] */ ULONG *pVal
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        *pVal = LockedJob->GetNotifyFlags();
        }
    LogPublicApiEnd( "pVal %p(%u)", pVal, *pVal );
    return Hr;
}

STDMETHODIMP
CJobExternal::SetNotifyInterfaceInternal(
    /* [in] */ IUnknown * Val
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "Val %p", Val );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        BOOL  fValidNotifyInterface = pJob->TestNotifyInterface();

        Hr = pJob->SetNotifyInterface( Val );

        // If there was no previous notification interface (or it's
        // no longer valid) and the job is already in the Transferred
        // state or fatal error state then go ahead and do the callback:
        if ((SUCCEEDED(Hr))&&(Val)&&(!fValidNotifyInterface))
            {
            if (pJob->_GetState() == BG_JOB_STATE_TRANSFERRED)
                {
                pJob->ScheduleCompletionCallback();
                }
            else if (pJob->_GetState() == BG_JOB_STATE_ERROR)
                {
                pJob->ScheduleErrorCallback();
                }
            }
        }

    LogPublicApiEnd( "Val %p", Val );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetNotifyInterfaceInternal(
    /* [out] */ IUnknown ** pVal
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetNotifyInterface( pVal );
        }
    LogPublicApiEnd( "pVal %p", pVal );
    return Hr;
}

STDMETHODIMP
CJobExternal::SetMinimumRetryDelayInternal(
    /* [in] */ ULONG Seconds
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "Seconds %u", Seconds );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetMinimumRetryDelay( Seconds );
        }
    LogPublicApiEnd( "Seconds %u", Seconds );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetMinimumRetryDelayInternal(
    /* [out] */ ULONG *Seconds
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "Seconds %p", Seconds );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetMinimumRetryDelay( Seconds );
        }
    LogPublicApiEnd( "Seconds %p(%u)", Seconds, *Seconds );
    return Hr;
}

STDMETHODIMP
CJobExternal::SetNoProgressTimeoutInternal(
    /* [in] */ ULONG Seconds
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "Seconds %u", Seconds );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetNoProgressTimeout( Seconds );
        }
    LogPublicApiEnd( "Seconds %u", Seconds );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetNoProgressTimeoutInternal(
    /* [out] */ ULONG *Seconds
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "Seconds %p", Seconds );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetNoProgressTimeout( Seconds );
        }
    LogPublicApiEnd( "Seconds %p(%u)", Seconds, *Seconds );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetErrorCountInternal(
    /* [out] */ ULONG * Retries
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "retries %p", Retries );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetErrorCount( Retries );
        }
    LogPublicApiEnd( "retries %p(%u)", Retries, *Retries );
    return Hr;
}

STDMETHODIMP
CJobExternal::SetProxySettingsInternal(
    BG_JOB_PROXY_USAGE ProxyUsage,
    LPCWSTR ProxyList,
    LPCWSTR ProxyBypassList
    )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "ProxyUsage %u, ProxyList %S, ProxyBypassList %S",
                       ProxyUsage,
                       ProxyList ? ProxyList : L"NULL",
                       ProxyBypassList ? ProxyBypassList : L"NULL" );

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetProxySettings( ProxyUsage, ProxyList, ProxyBypassList );
        }

    LogPublicApiEnd( "ProxyUsage %u, ProxyList %S, ProxyBypassList %S",
                     ProxyUsage,
                     ProxyList ? ProxyList : L"NULL",
                     ProxyBypassList ? ProxyBypassList : L"NULL" );
    return Hr;
}

STDMETHODIMP
CJobExternal::GetProxySettingsInternal(
    BG_JOB_PROXY_USAGE *pProxyUsage,
    LPWSTR *pProxyList,
    LPWSTR *pProxyBypassList
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin( "pProxyUsage %p, pProxyList %p, pProxyBypassList %p",
                       pProxyUsage, pProxyList, pProxyBypassList );

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetProxySettings( pProxyUsage, pProxyList, pProxyBypassList );
        }

    LogPublicApiEnd( "pProxyUsage %p, pProxyList %p, pProxyBypassList %p",
                     pProxyUsage, pProxyList, pProxyBypassList );

    return Hr;
}

STDMETHODIMP
CJobExternal::TakeOwnershipInternal()
{
    LogPublicApiBegin( " " );

    CLockedJobWritePointer LockedJob(pJob);

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->AssignOwnership( GetThreadClientSid() );
        }

    LogPublicApiEnd( " " );

    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobExternal::SetNotifyCmdLineInternal(
     LPCWSTR Val
     )
{
    CLockedJobWritePointer LockedJob(pJob);
    LogPublicApiBegin( "Val %S", Val );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetNotifyCmdLine( Val );
        }
    LogPublicApiEnd( "Val %S", Val );
    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobExternal::GetNotifyCmdLineInternal(
    LPWSTR *pVal
    )
{
    CLockedJobReadPointer LockedJob(pJob);
    LogPublicApiBegin("pVal %p", pVal );
    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetNotifyCmdLine( pVal );
        }
    LogPublicApiEnd("pVal %p(%S)", pVal, SUCCEEDED(Hr) ? *pVal : L"?" );
    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobExternal::GetReplyProgressInternal(
    BG_JOB_REPLY_PROGRESS *pProgress
    )
{
    LogPublicApiBegin( " " );

    CLockedJobReadPointer LockedJob(pJob);

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetReplyProgress( pProgress );
        }

    LogPublicApiEnd( "%I64d of %I64d transferred", pProgress->BytesTransferred, pProgress->BytesTotal );
    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobExternal::GetReplyDataInternal(
    byte **ppBuffer,
    ULONG *pLength
    )
{
    LogPublicApiBegin( " " );

    CLockedJobReadPointer LockedJob(pJob);

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetReplyData( ppBuffer, pLength );
        }

    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobExternal::SetReplyFileNameInternal(
    LPCWSTR Val
    )
{
    LogPublicApiBegin( "file '%S'", Val ? Val : L"(null)");

    CLockedJobWritePointer LockedJob(pJob);

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetReplyFileName( Val );
        }

    LogPublicApiEnd( " " );

    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobExternal::GetReplyFileNameInternal(
    LPWSTR *pReplyFileName
    )
{
    LogPublicApiBegin( " " );

    //
    // This can modify the job, if the reply file name is not yet created.
    //
    CLockedJobReadPointer LockedJob(pJob);

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->GetReplyFileName( pReplyFileName );
        }

    LogPublicApiEnd( "file '%S'", *pReplyFileName ? *pReplyFileName : L"(null)" );
    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobExternal::SetCredentialsInternal(
    BG_AUTH_CREDENTIALS * Credentials
    )
{
    LogPublicApiBegin( "cred %p, target %d, scheme %d", Credentials, Credentials->Target, Credentials->Scheme );

    CLockedJobWritePointer LockedJob(pJob);

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->SetCredentials( Credentials );
        }

    LogPublicApiEnd( " " );

    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobExternal::RemoveCredentialsInternal(
    BG_AUTH_TARGET Target,
    BG_AUTH_SCHEME Scheme
    )
{
    LogPublicApiBegin( "target %d, scheme %d", Target, Scheme );

    CLockedJobWritePointer LockedJob(pJob);

    HRESULT Hr = LockedJob.ValidateAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = LockedJob->RemoveCredentials( Target, Scheme );
        }

    LogPublicApiEnd( " " );

    return Hr;
}

HRESULT
CJob::SetReplyFileName(
    LPCWSTR Val
    )
{
    return E_NOTIMPL;
}

HRESULT
CUploadJob::SetReplyFileName(
    LPCWSTR Val
    )
{
    if (m_type != BG_JOB_TYPE_UPLOAD_REPLY)
        {
        return E_NOTIMPL;
        }

    if (m_ReplyFile)
        {
        return BG_E_INVALID_STATE;
        }

    if (Val)
        {
        RETURN_HRESULT( CFile::VerifyLocalFileName( Val, BG_JOB_TYPE_DOWNLOAD ));
        }

    try
        {
        StringHandle name = Val;

        //
        // Impersonate the user while checking file access.
        //
        CNestedImpersonation imp;

        imp.SwitchToLogonToken();

        //
        // Four cases:
        //
        // 1. new name NULL, old name NULL:
        //    no change
        //
        // 2. new name NULL, old name non-NULL:
        //    overwrite the file name, set ownership correctly.  No need to
        //    delete the old file because it wasn't created yet.
        //
        // 3. new name non-NULL, old name NULL:
        //    overwrite the file name, set ownership correctly.  Delete the
        //    temporary old file name.
        //
        // 4. new name non-NULL, old name non-NULL:
        //    overwrite the file name.  no file to delete.
        //
        if (name.Size() > 0)
            {
            THROW_HRESULT( BITSCheckFileWritability( name ));

            DeleteGeneratedReplyFile();

            THROW_HRESULT( UpdateString( m_ReplyFileName, name));

            m_fOwnReplyFileName = false;
            }
        else
            {
            THROW_HRESULT( UpdateString( m_ReplyFileName, name));

            (void) GenerateReplyFile( false );
            }

        g_Manager->Serialize();

        return S_OK;
        }
    catch ( ComError err )
        {
        return err.Error();
        }
}

HRESULT
CJob::GetReplyFileName(
    LPWSTR * pVal
    ) const
{
    return E_NOTIMPL;
}

HRESULT
CUploadJob::GetReplyFileName(
    LPWSTR * pVal
    ) const
{
    if (m_ReplyFileName.Size() == 0)
        {
        *pVal = NULL;
        return S_OK;
        }

    *pVal = MidlCopyString( m_ReplyFileName );

    return (*pVal) ? S_OK : E_OUTOFMEMORY;
}

HRESULT
CJob::GetReplyProgress(
    BG_JOB_REPLY_PROGRESS *pProgress
    ) const
{
    return E_NOTIMPL;
}

HRESULT
CUploadJob::GetReplyProgress(
    BG_JOB_REPLY_PROGRESS *pProgress
    ) const
{
    if (m_type != BG_JOB_TYPE_UPLOAD_REPLY)
        {
        return E_NOTIMPL;
        }

    if (m_ReplyFile)
        {
        pProgress->BytesTotal       = m_ReplyFile->_GetBytesTotal();
        pProgress->BytesTransferred = m_ReplyFile->_GetBytesTransferred();
        }
    else
        {
        pProgress->BytesTotal       = BG_SIZE_UNKNOWN;
        pProgress->BytesTransferred = 0;
        }

    return S_OK;
}

HRESULT
CUploadJob::Resume()
{
    if (m_type == BG_JOB_TYPE_UPLOAD_REPLY)
        {
        RETURN_HRESULT( GenerateReplyFile(true ) );
        }

    return CJob::Resume();
}

HRESULT
CUploadJob::GenerateReplyFile(
    bool fSerialize
    )
{
    if (0 != wcscmp( m_ReplyFileName, L"" ))
        {
        return S_OK;
        }

    //
    // Gotta create a reply file name.
    //
    try
        {
        if (IsEmpty())
            {
            return BG_E_EMPTY;
            }

        g_Manager->ExtendMetadata();

        //
        // Impersonate the user while checking file access.
        //
        CNestedImpersonation imp;

        imp.SwitchToLogonToken();

        StringHandle Ignore;
        StringHandle Directory = BITSCrackFileName( GetUploadFile()->GetLocalName(),
                                                    Ignore );

        m_ReplyFileName = BITSCreateTempFile( Directory );

        m_fOwnReplyFileName = true;

        if (fSerialize)
            {
            g_Manager->Serialize();
            }

        return S_OK;
        }
    catch ( ComError err )
        {
        g_Manager->ShrinkMetadata();
        return err.Error();
        }
}

HRESULT
CUploadJob::DeleteGeneratedReplyFile()
{
    if (m_fOwnReplyFileName)
        {
        if (!DeleteFile( m_ReplyFileName ))
            {
            DWORD s = GetLastError();

            LogWarning("unable to delete generated reply file '%S', %!winerr!", LPCWSTR(m_ReplyFileName), s);

            return HRESULT_FROM_WIN32( s );
            }
        }

    return S_OK;
}

void
CUploadJob::SetReplyFile(
    CFile * file
    )
{
    try
        {
        g_Manager->ExtendMetadata( file->GetSizeEstimate() );

        m_ReplyFile = file;

        g_Manager->Serialize();
        }
    catch ( ComError err )
        {
        g_Manager->ShrinkMetadata();
        throw;
        }
}


HRESULT
CJob::GetReplyData(
    byte **ppBuffer,
    ULONG *pLength
    ) const
{
    return E_NOTIMPL;
}

HRESULT
CUploadJob::GetReplyData(
    byte **ppBuffer,
    ULONG *pLength
    ) const
{
    return E_NOTIMPL;
}

HRESULT
CJob::SetCredentials(
    BG_AUTH_CREDENTIALS * Credentials
    )
{
    try
        {
        CNestedImpersonation imp;

        imp.SwitchToLogonToken();

        g_Manager->ExtendMetadata( m_Credentials.GetSizeEstimate( Credentials ));

        THROW_HRESULT( m_Credentials.Update( Credentials ));

        g_Manager->Serialize();
        return S_OK;
        }
    catch ( ComError err )
        {
        g_Manager->ShrinkMetadata();
        return err.Error();
        }
}

HRESULT
CJob::RemoveCredentials(
    BG_AUTH_TARGET Target,
    BG_AUTH_SCHEME Scheme
    )
{
    try
        {
        CNestedImpersonation imp;

        imp.SwitchToLogonToken();

        HRESULT hr = m_Credentials.Remove( Target, Scheme );

        THROW_HRESULT( hr );

        g_Manager->Serialize();

        return hr;  // may be S_FALSE if the credential was never in the collection
        }
    catch ( ComError err )
        {
        return err.Error();
        }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\cjob.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    cjob.h

Abstract :

    Main header file for handling jobs and files.

Author :

Revision History :

 ***********************************************************************/
#include "qmgrlib.h"
#include <vector>
#include <list>
#include <xstring>
#include <stllock.h>
#include "clist.h"

//
// Job Specific Access Rights.
//

#define BG_JOB_QUERY_PROP       (0x0001)
#define BG_JOB_SET_PROP         (0x0002)
#define BG_JOB_NOTIFY           (0x0004)
#define BG_JOB_MANAGE           (0x0008)

#define BG_JOB_ALL_ACCESS   ( BG_JOB_QUERY_PROP |\
                              BG_JOB_SET_PROP   |\
                              BG_JOB_NOTIFY     |\
                              BG_JOB_MANAGE )

#define BG_JOB_READ         ( STANDARD_RIGHTS_READ |\
                              BG_JOB_QUERY_PROP )

#define BG_JOB_WRITE        ( STANDARD_RIGHTS_WRITE |\
                              BG_JOB_SET_PROP       |\
                              BG_JOB_NOTIFY         |\
                              BG_JOB_MANAGE )

#define BG_JOB_EXECUTE      ( STANDARD_RIGHTS_EXECUTE )


class CFile;
class CJob;
class CJobError;
class CEnumJobs;
class CEnumFiles;
class CJobManager;
class CJobExternal;
class CFileExternal;

class CJobInactivityTimeout : public TaskSchedulerWorkItem
{
public:
    virtual void OnInactivityTimeout() = 0;
    virtual void OnDispatch() { return OnInactivityTimeout(); }
};

class CJobNoProgressItem : public TaskSchedulerWorkItem
{
public:
    virtual void OnNoProgress() = 0;
    virtual void OnDispatch() { return OnNoProgress(); }
};

class CJobCallbackItem : public TaskSchedulerWorkItem
{
public:
    virtual void OnMakeCallback() = 0;
    virtual void OnDispatch() { return OnMakeCallback(); }

protected:

    enum CallbackMethod
        {
        CM_COMPLETE,
        CM_ERROR
        }
    m_method;
};

class CJobRetryItem : public TaskSchedulerWorkItem
{
public:
    virtual void OnRetryJob() = 0;
    virtual void OnDispatch() { return OnRetryJob(); }
};

class CJobModificationItem : public TaskSchedulerWorkItem
{
public:
    virtual void OnModificationCallback() = 0;
    virtual void OnDispatch() { return OnModificationCallback(); }
    ULONG m_ModificationsPending;

    CJobModificationItem() :
        m_ModificationsPending(0) {}
};

class CLockedJobReadPointer : public CLockedReadPointer<CJob, BG_JOB_READ>
{
public:

    CLockedJobReadPointer( CJob * job) : CLockedReadPointer<CJob, BG_JOB_READ>( job )
    {
    }

    HRESULT ValidateAccess();
};

class CLockedJobWritePointer : public CLockedWritePointer<CJob, BG_JOB_WRITE>
{
public:

    CLockedJobWritePointer( CJob * job) : CLockedWritePointer<CJob, BG_JOB_WRITE>( job )
    {
    }

    HRESULT ValidateAccess();
};

//------------------------------------------------------------------------

class CJobExternal : public IBackgroundCopyJob2
{

friend CJob;

public:

    // IUnknown Methods
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    ULONG _stdcall AddRef(void);
    ULONG _stdcall Release(void);

    // IBackgroundCopyJob methods

    HRESULT STDMETHODCALLTYPE AddFileSetInternal(
        /* [in] */ ULONG cFileCount,
        /* [size_is][in] */ BG_FILE_INFO *pFileSet);

    HRESULT STDMETHODCALLTYPE AddFileSet(
        /* [in] */ ULONG cFileCount,
        /* [size_is][in] */ BG_FILE_INFO *pFileSet)
    {
        EXTERNAL_FUNC_WRAP( AddFileSetInternal( cFileCount, pFileSet ) )
    }


    HRESULT STDMETHODCALLTYPE AddFileInternal(
        /* [in] */ LPCWSTR RemoteUrl,
        /* [in] */ LPCWSTR LocalName);

    HRESULT STDMETHODCALLTYPE AddFile(
        /* [in] */ LPCWSTR RemoteUrl,
        /* [in] */ LPCWSTR LocalName)
    {
        EXTERNAL_FUNC_WRAP( AddFileInternal( RemoteUrl, LocalName ) )
    }


    HRESULT STDMETHODCALLTYPE EnumFilesInternal(
        /* [out] */ IEnumBackgroundCopyFiles **pEnum);

    HRESULT STDMETHODCALLTYPE EnumFiles(
        /* [out] */ IEnumBackgroundCopyFiles **ppEnum
        )
    {
        EXTERNAL_FUNC_WRAP( EnumFilesInternal( ppEnum ) )
    }

    HRESULT STDMETHODCALLTYPE SuspendInternal( void);

    HRESULT STDMETHODCALLTYPE Suspend( void)
    {
        EXTERNAL_FUNC_WRAP( SuspendInternal() )
    }


    HRESULT STDMETHODCALLTYPE ResumeInternal( void);

    HRESULT STDMETHODCALLTYPE Resume( void)
    {
        EXTERNAL_FUNC_WRAP( ResumeInternal() )
    }


    HRESULT STDMETHODCALLTYPE CancelInternal( void);

    HRESULT STDMETHODCALLTYPE Cancel( void)
    {
        EXTERNAL_FUNC_WRAP( CancelInternal() )
    }


    HRESULT STDMETHODCALLTYPE CompleteInternal( void);

    HRESULT STDMETHODCALLTYPE Complete( void)
    {
        EXTERNAL_FUNC_WRAP( CompleteInternal() )
    }

    HRESULT STDMETHODCALLTYPE GetIdInternal(
        /* [out] */ GUID *pVal);

    HRESULT STDMETHODCALLTYPE GetId(
        /* [out] */ GUID *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetIdInternal( pVal ) )
    }


    HRESULT STDMETHODCALLTYPE GetTypeInternal(
        /* [out] */ BG_JOB_TYPE *pVal);

    HRESULT STDMETHODCALLTYPE GetType(
        /* [out] */ BG_JOB_TYPE *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetTypeInternal( pVal ) )
    }


    HRESULT STDMETHODCALLTYPE GetProgressInternal(
        /* [out] */ BG_JOB_PROGRESS *pVal);

    HRESULT STDMETHODCALLTYPE GetProgress(
        /* [out] */ BG_JOB_PROGRESS *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetProgressInternal( pVal ) )
    }


    HRESULT STDMETHODCALLTYPE GetTimesInternal(
        /* [out] */ BG_JOB_TIMES *pVal);

    HRESULT STDMETHODCALLTYPE GetTimes(
        /* [out] */ BG_JOB_TIMES *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetTimesInternal( pVal ) )
    }


    HRESULT STDMETHODCALLTYPE GetStateInternal(
        /* [out] */ BG_JOB_STATE *pVal);

    HRESULT STDMETHODCALLTYPE GetState(
        /* [out] */ BG_JOB_STATE *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetStateInternal( pVal ) )
    }


    HRESULT STDMETHODCALLTYPE GetErrorInternal(
        /* [out] */ IBackgroundCopyError **ppError);

    HRESULT STDMETHODCALLTYPE GetError(
        /* [out] */ IBackgroundCopyError **ppError)
    {
        EXTERNAL_FUNC_WRAP( GetErrorInternal( ppError ) )
    }


    HRESULT STDMETHODCALLTYPE GetOwnerInternal(
        /* [out] */ LPWSTR *pVal);

    HRESULT STDMETHODCALLTYPE GetOwner(
        /* [out] */ LPWSTR *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetOwnerInternal( pVal ) )
    }


    HRESULT STDMETHODCALLTYPE SetDisplayNameInternal(
        /* [in] */ LPCWSTR Val);

    HRESULT STDMETHODCALLTYPE SetDisplayName(
        /* [in] */ LPCWSTR Val)
    {
        EXTERNAL_FUNC_WRAP( SetDisplayNameInternal( Val ) )
    }

    HRESULT STDMETHODCALLTYPE GetDisplayNameInternal(
        /* [out] */ LPWSTR *pVal);

    HRESULT STDMETHODCALLTYPE GetDisplayName(
        /* [out] */ LPWSTR *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetDisplayNameInternal( pVal ) )
    }

    HRESULT STDMETHODCALLTYPE SetDescriptionInternal(
        /* [in] */ LPCWSTR Val);

    HRESULT STDMETHODCALLTYPE SetDescription(
        /* [in] */ LPCWSTR Val)
    {
        EXTERNAL_FUNC_WRAP( SetDescriptionInternal( Val ) )
    }


    HRESULT STDMETHODCALLTYPE GetDescriptionInternal(
        /* [out] */ LPWSTR *pVal);

    HRESULT STDMETHODCALLTYPE GetDescription(
        /* [out] */ LPWSTR *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetDescriptionInternal( pVal ) )
    }


    HRESULT STDMETHODCALLTYPE SetPriorityInternal(
        /* [in] */ BG_JOB_PRIORITY Val);

    HRESULT STDMETHODCALLTYPE SetPriority(
        /* [in] */ BG_JOB_PRIORITY Val)
    {
        EXTERNAL_FUNC_WRAP( SetPriorityInternal( Val ) )
    }


    HRESULT STDMETHODCALLTYPE GetPriorityInternal(
        /* [out] */ BG_JOB_PRIORITY *pVal);

    HRESULT STDMETHODCALLTYPE GetPriority(
        /* [out] */ BG_JOB_PRIORITY *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetPriorityInternal( pVal ) )
    }


    HRESULT STDMETHODCALLTYPE SetNotifyFlagsInternal(
        /* [in] */ ULONG Val);

    HRESULT STDMETHODCALLTYPE SetNotifyFlags(
        /* [in] */ ULONG Val)
    {
        EXTERNAL_FUNC_WRAP( SetNotifyFlagsInternal( Val ) )
    }


    HRESULT STDMETHODCALLTYPE GetNotifyFlagsInternal(
        /* [out] */ ULONG *pVal);

    HRESULT STDMETHODCALLTYPE GetNotifyFlags(
        /* [out] */ ULONG *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetNotifyFlagsInternal( pVal ) )
    }


    HRESULT STDMETHODCALLTYPE
    SetNotifyInterfaceInternal(
        IUnknown * Val
        );

    HRESULT STDMETHODCALLTYPE
    SetNotifyInterface(
        IUnknown * Val
        )
    {
        EXTERNAL_FUNC_WRAP( SetNotifyInterfaceInternal( Val ) )
    }


    HRESULT STDMETHODCALLTYPE
    GetNotifyInterfaceInternal(
        IUnknown ** ppVal
        );

    HRESULT STDMETHODCALLTYPE
    GetNotifyInterface(
        IUnknown ** ppVal
        )
    {
        EXTERNAL_FUNC_WRAP( GetNotifyInterfaceInternal( ppVal ) )
    }


    HRESULT STDMETHODCALLTYPE SetMinimumRetryDelayInternal(
        /* [in] */ ULONG Seconds);

    HRESULT STDMETHODCALLTYPE SetMinimumRetryDelay(
        /* [in] */ ULONG Seconds)
    {
        EXTERNAL_FUNC_WRAP( SetMinimumRetryDelayInternal( Seconds ) )
    }


    HRESULT STDMETHODCALLTYPE GetMinimumRetryDelayInternal(
        /* [out] */ ULONG *Seconds);

    HRESULT STDMETHODCALLTYPE GetMinimumRetryDelay(
        /* [out] */ ULONG *Seconds)
    {
        EXTERNAL_FUNC_WRAP( GetMinimumRetryDelayInternal( Seconds ) )
    }


    HRESULT STDMETHODCALLTYPE SetNoProgressTimeoutInternal(
        /* [in] */ ULONG Seconds);

    HRESULT STDMETHODCALLTYPE SetNoProgressTimeout(
        /* [in] */ ULONG Seconds)
    {
        EXTERNAL_FUNC_WRAP( SetNoProgressTimeoutInternal( Seconds ) )
    }

    HRESULT STDMETHODCALLTYPE GetNoProgressTimeoutInternal(
        /* [out] */ ULONG *Seconds);

    HRESULT STDMETHODCALLTYPE GetNoProgressTimeout(
        /* [out] */ ULONG *Seconds)
    {
        EXTERNAL_FUNC_WRAP( GetNoProgressTimeoutInternal( Seconds ) )
    }


    HRESULT STDMETHODCALLTYPE GetErrorCountInternal(
        /* [out] */ ULONG *Errors);

    HRESULT STDMETHODCALLTYPE GetErrorCount(
        /* [out] */ ULONG *Errors)
    {
        EXTERNAL_FUNC_WRAP( GetErrorCountInternal( Errors ) )
    }


    HRESULT STDMETHODCALLTYPE SetProxySettingsInternal(
       /* [in] */ BG_JOB_PROXY_USAGE ProxyUsage,
       /* [in] */ LPCWSTR ProxyList,
       /* [in] */ LPCWSTR ProxyBypassList );

    HRESULT STDMETHODCALLTYPE SetProxySettings(
       /* [in] */ BG_JOB_PROXY_USAGE ProxyUsage,
       /* [in] */ LPCWSTR ProxyList,
       /* [in] */ LPCWSTR ProxyBypassList )
    {
       EXTERNAL_FUNC_WRAP( SetProxySettingsInternal( ProxyUsage, ProxyList, ProxyBypassList ) )
    }


    HRESULT STDMETHODCALLTYPE GetProxySettingsInternal(
       /* [out] */ BG_JOB_PROXY_USAGE *pProxyUsage,
       /* [out] */ LPWSTR *pProxyList,
       /* [out] */ LPWSTR *pProxyBypassList );

    HRESULT STDMETHODCALLTYPE GetProxySettings(
       /* [out] */ BG_JOB_PROXY_USAGE *pProxyUsage,
       /* [out] */ LPWSTR *pProxyList,
       /* [out] */ LPWSTR *pProxyBypassList )
    {
        EXTERNAL_FUNC_WRAP( GetProxySettingsInternal( pProxyUsage, pProxyList, pProxyBypassList ) )
    }



    HRESULT STDMETHODCALLTYPE TakeOwnershipInternal();

    HRESULT STDMETHODCALLTYPE TakeOwnership()
    {
        EXTERNAL_FUNC_WRAP( TakeOwnershipInternal( ) )
    }

    // IBackgroundCopyJob2 methods (external)

    HRESULT STDMETHODCALLTYPE SetNotifyCmdLine(
        /* [in] */ LPCWSTR Val)
    {
        EXTERNAL_FUNC_WRAP( SetNotifyCmdLineInternal( Val ) );
    }

    HRESULT STDMETHODCALLTYPE GetNotifyCmdLine(
        /* [out] */ LPWSTR *pVal)
    {
        EXTERNAL_FUNC_WRAP( GetNotifyCmdLineInternal( pVal ) );
    }

    HRESULT STDMETHODCALLTYPE GetReplyProgress(
        /* [in] */ BG_JOB_REPLY_PROGRESS *pProgress)
    {
        EXTERNAL_FUNC_WRAP( GetReplyProgressInternal( pProgress) );
    }

    HRESULT STDMETHODCALLTYPE GetReplyData(
        /* [size_is][size_is][out] */ byte **ppBuffer,
        /* [unique][out][in] */ ULONG *pLength)
    {
        EXTERNAL_FUNC_WRAP( GetReplyDataInternal(ppBuffer, pLength) );
    }

    HRESULT STDMETHODCALLTYPE SetReplyFileName(
        /* [unique][in] */ LPCWSTR ReplyFileName)
    {
        EXTERNAL_FUNC_WRAP( SetReplyFileNameInternal( ReplyFileName) );
    }

    HRESULT STDMETHODCALLTYPE GetReplyFileName(
        /* [out] */ LPWSTR *pReplyFileName)
    {
        EXTERNAL_FUNC_WRAP( GetReplyFileNameInternal( pReplyFileName) );
    }

    HRESULT STDMETHODCALLTYPE SetCredentials(
        /* [unique][switch_is][in] */ BG_AUTH_CREDENTIALS *pCredentials)
    {
        EXTERNAL_FUNC_WRAP( SetCredentialsInternal( pCredentials ) );
    }

    HRESULT STDMETHODCALLTYPE RemoveCredentials(
        /* [unique][switch_is][in] */ BG_AUTH_TARGET Target,
                                      BG_AUTH_SCHEME Scheme )
    {
        EXTERNAL_FUNC_WRAP( RemoveCredentialsInternal( Target, Scheme ) );
    }


    // internal versions of IBackgroundCopyJob2 methods

    HRESULT STDMETHODCALLTYPE SetNotifyCmdLineInternal(
        /* [in] */ LPCWSTR Val);

    HRESULT STDMETHODCALLTYPE GetNotifyCmdLineInternal(
        /* [out] */ LPWSTR *pVal);

    HRESULT STDMETHODCALLTYPE GetReplyProgressInternal(
        /* [in] */ BG_JOB_REPLY_PROGRESS *pProgress);

    HRESULT STDMETHODCALLTYPE GetReplyDataInternal(
        /* [size_is][size_is][out] */ byte **ppBuffer,
        /* [unique][out][in] */ ULONG *pLength);

    HRESULT STDMETHODCALLTYPE SetReplyFileNameInternal(
        /* [unique][in] */ LPCWSTR ReplyFileName);

    HRESULT STDMETHODCALLTYPE GetReplyFileNameInternal(
        /* [out] */ LPWSTR *pReplyFileName);

    HRESULT STDMETHODCALLTYPE SetCredentialsInternal(
        /* [unique][switch_is][in] */ BG_AUTH_CREDENTIALS *pCredentials);

    HRESULT STDMETHODCALLTYPE RemoveCredentialsInternal(
        /* [unique][switch_is][in] */ BG_AUTH_TARGET Target,
                                      BG_AUTH_SCHEME Scheme );

    // Other methods

    CJobExternal();
    ~CJobExternal();

private:

    CJob *pJob;

    long m_refs;

    long m_ServiceInstance;

    void SetInterfaceClass(
        CJob *pVal
        )
    {
        pJob = pVal;
    }

    void NotifyInternalDelete()
    {
        // Release the internal refcount
        Release();
    }

};

class CUnknownFileSizeItem
{
public:
    CFile *const    m_file;
    StringHandle    m_url;

    CUnknownFileSizeItem(
        CFile *pFile,
        StringHandle URL ) :
    m_file( pFile ),
    m_url( URL )
    {
    }
};

class CUnknownFileSizeList : public list<CUnknownFileSizeItem>
{
public:
    bool Add( CFile *pFile, const StringHandle & URL )
    {
        try
        {
            push_back( CUnknownFileSizeItem( pFile, URL ) );
        }
        catch( ComError Error )
        {
            return false;
        }
        return true;
    }
};

class COldJobInterface;
class COldGroupInterface;

class CJob :
            public IntrusiveList<CJob>::Link,
            public CJobInactivityTimeout,
            public CJobRetryItem,
            public CJobCallbackItem,
            public CJobNoProgressItem,
            public CJobModificationItem
{

friend class CGroupList;
friend class CJobExternal;
friend class COldJobInterface;
friend class COldGroupInterface;

public:

    void    HandleAddFile();

    HRESULT AddFileSet(
        /* [in] */ ULONG cFileCount,
        /* [size_is][in] */ BG_FILE_INFO *pFileSet
        );

    HRESULT AddFile(
        /* [in] */ LPCWSTR RemoteUrl,
        /* [in] */ LPCWSTR LocalName,
        bool SingleAdd );

    virtual HRESULT Suspend();

    virtual HRESULT Resume();

    virtual HRESULT Cancel();

    virtual HRESULT Complete();

    GUID GetId() const
    {
        return m_id;
    }

    BG_JOB_TYPE GetType() const
    {
        return m_type;
    }

    void GetProgress(
        /* [out] */ BG_JOB_PROGRESS *pVal) const;

    void GetTimes(
        /* [out] */ BG_JOB_TIMES *pVal) const;

    HRESULT SetDisplayName(
        /* [in] */ LPCWSTR Val);

    HRESULT GetDisplayName(
        /* [out] */ LPWSTR *pVal) const;

    HRESULT SetDescription(
        /* [in] */ LPCWSTR Val);

    HRESULT GetDescription(
        /* [out] */ LPWSTR *pVal) const;

    HRESULT SetPriority(
        /* [in] */ BG_JOB_PRIORITY Val);

    HRESULT GetOwner(
        /* [out] */ LPWSTR *pVal) const;

    HRESULT SetNotifyFlags(
        /* [in] */ ULONG Val);

    ULONG GetNotifyFlags() const
    {
        return m_NotifyFlags;
    }

    HRESULT
    SetNotifyInterface(
        IUnknown * Val
        );

    HRESULT
    GetNotifyInterface(
        IUnknown ** ppVal
        ) const;

    BOOL
    TestNotifyInterface();

    HRESULT SetMinimumRetryDelay(
        /* [in] */ ULONG Seconds);

    HRESULT GetMinimumRetryDelay(
        /* [out] */ ULONG *Seconds) const;

    HRESULT SetNoProgressTimeout(
        /* [in] */ ULONG Seconds);

    HRESULT GetNoProgressTimeout(
        /* [out] */ ULONG *Seconds) const;

    HRESULT STDMETHODCALLTYPE GetErrorCount(
        /* [out] */ ULONG *Errors) const;


    HRESULT
    SetProxySettings(
        BG_JOB_PROXY_USAGE ProxyUsage,
        LPCWSTR ProxyList,
        LPCWSTR ProxyBypassList
        );

    HRESULT
    GetProxySettings(
        BG_JOB_PROXY_USAGE *pProxyUsage,
        LPWSTR *pProxyList,
        LPWSTR *pProxyBypassList
        ) const;

    HRESULT AssignOwnership( SidHandle sid );

    virtual HRESULT
    GetReplyProgress(
        BG_JOB_REPLY_PROGRESS *pProgress
        ) const;

    virtual HRESULT
    GetReplyFileName(
        LPWSTR * pVal
        ) const;

    virtual HRESULT
    SetReplyFileName(
        LPCWSTR Val
        );

    virtual HRESULT
    GetReplyData(
        byte **ppBuffer,
        ULONG *pLength
        ) const;

    virtual HRESULT
    SetNotifyCmdLine(
        LPCWSTR Val
        );

    virtual HRESULT
    GetNotifyCmdLine(
        LPWSTR *pVal
        ) const;

    HRESULT
    SetCredentials(
        BG_AUTH_CREDENTIALS *pCredentials
        );

    HRESULT
    RemoveCredentials(
        BG_AUTH_TARGET Target,
        BG_AUTH_SCHEME Scheme
        );

    // CJobCallbackItem methods

    void OnMakeCallback();

    // CJobRetryItem methods

    virtual void OnRetryJob();

    // CJobInactivityTimeout methods

    virtual void OnInactivityTimeout();

    // CJobNoProgressItem methods

    virtual void OnNoProgress();

    // CJobModificationItem methods
    virtual void OnModificationCallback();

    // other methods

    virtual void OnNetworkConnect();
    virtual void OnNetworkDisconnect();

    void RemoveFromManager();
    void CancelWorkitems();

    // TaskSchedulerWorkItem

    SidHandle GetSid()
    {
        return m_NotifySid;
    }


    bool
    IsCallbackEnabled(
        DWORD bit
        );

    void ScheduleModificationCallback();

    CJob(
        LPCWSTR     Name,
        BG_JOB_TYPE Type,
        REFGUID     JobId,
        SidHandle   NotifySid
        );

protected:

    bool
    RecordError(
        QMErrInfo * ErrInfo
        );


    //
    // used only by unserialize
    //
    CJob();

public:

    virtual ~CJob();

    BG_JOB_PRIORITY _GetPriority() const
    {
        return m_priority;
    }

    BG_JOB_STATE _GetState() const
    {
        return m_state;
    }

    void SetState( BG_JOB_STATE state );

    inline SidHandle GetOwnerSid()
    {
        return m_sd->GetOwnerSid();
    }

    BOOL IsIncomplete() const
    {
        if (m_state < BG_JOB_STATE_TRANSFERRED)
            {
            return TRUE;
            }

        return FALSE;
    }

    bool ShouldThrottle() const
    {
        return (m_priority!=BG_JOB_PRIORITY_FOREGROUND);
    }

    HRESULT DeleteFileIndex( ULONG index );

    HRESULT IsVisible();

    bool IsOwner( SidHandle user );

    virtual bool IsRunning();
    virtual bool IsRunnable();
    virtual void Transfer();

    virtual void
    FileComplete();

    virtual void
    FileTransientError(
        QMErrInfo * ErrInfo
        );

    virtual void
    FileFatalError(
        QMErrInfo * ErrInfo
        );

    virtual void
    FileChangedOnServer()
    {
        UpdateModificationTime();
    }

    virtual void UpdateProgress(
        UINT64 BytesTransferred,
        UINT64 BytesTotal
        );

    void  JobTransferred();

    HRESULT CommitTemporaryFiles();
    HRESULT RemoveTemporaryFiles();
    HRESULT RemoveTemporaryFilesPart2();

    void
    UpdateModificationTime(
        bool   fReplace = TRUE
        );

    void
    UpdateLastAccessTime(
        );

    void SetCompletionTime( const FILETIME *pftCompletionTime = 0 );
    void SetModificationTime( const FILETIME *pftModificationTime = 0 );
    void SetLastAccessTime( const FILETIME *pftModificationTime = 0 );

    CFile * GetCurrentFile() const
    {
        if (m_CurrentFile < m_files.size())
            {
            return m_files[ m_CurrentFile ];
            }
        else
            {
            return NULL;
            }
    }

    bool IsTransferringToDrive( const WCHAR *CanonicalVolume )
    {
        CFile *CurrentFile = GetCurrentFile();
        if ( !CurrentFile )
            return false;

        if ( CurrentFile->IsCanonicalVolume( CanonicalVolume ) )
            return true;
        else
            return false;
    }

    BOOL IsEmpty() const
    {
        if (m_files.size() == 0)
            {
            return TRUE;
            }

        return FALSE;
    }

    CFile * _GetFileIndex( ULONG index ) const
    {
        if (index >= m_files.size())
            {
            return NULL;
            }

        return m_files[ index ];
    }

    virtual HRESULT Serialize( HANDLE hFile );

    virtual void Unserialize( HANDLE hFile, int Type );

    static CJob * UnserializeJob( HANDLE hFile );

    CJobExternal* GetExternalInterface()
    {
        return m_ExternalInterface;
    }

    COldGroupInterface *GetOldExternalGroupInterface()
    {
        return m_OldExternalGroupInterface;
    }

    void SetOldExternalGroupInterface( COldGroupInterface *GroupInterface )
    {
        ASSERT( !m_OldExternalGroupInterface );
        m_OldExternalGroupInterface = GroupInterface;
    }

    COldJobInterface *GetOldExternalJobInterface() const
    {
        return m_OldExternalJobInterface;
    }

    void SetOldExternalJobInterface( COldJobInterface *JobInterface )
    {
        ASSERT( !m_OldExternalJobInterface );
        m_OldExternalJobInterface = JobInterface;
    }

    void UnlinkFromExternalInterfaces();

    void NotifyInternalDelete()
    {
        GetExternalInterface()->NotifyInternalDelete();
    }

    ULONG AddRef(void)
    {
        return GetExternalInterface()->AddRef();
    }

    ULONG Release(void)
    {
        return GetExternalInterface()->Release();
    }

    HRESULT CheckClientAccess(
        IN DWORD RequestedAccess
        ) const;


    void ScheduleCompletionCallback(
        DWORD Seconds = 0
        );

    void ScheduleErrorCallback(
        DWORD Seconds = 0
        );

    void RetryNow();
    void MoveToInactiveState();

    const CJobError *GetError() const
    {
        if ( !m_error.IsErrorSet() )
            return NULL;

        return &m_error;
    }

    //--------------------------------------------------------------------

    class CFileList : public vector<CFile *>
    {
    public:

        HRESULT Serialize( HANDLE hFile );
        void    Unserialize( HANDLE hFile, CJob* Job );

        void    Delete( iterator Initial, iterator Terminal );
    };

    BG_JOB_PRIORITY     m_priority;
    BG_JOB_STATE        m_state;
    BG_JOB_TYPE         m_type;

    void OnDiskChange(   const WCHAR *CanonicalVolume, DWORD VolumeSerialNumber );
    void OnDismount(     const WCHAR *CanonicalVolume );
    bool OnDeviceLock(   const WCHAR *CanonicalVolume );
    bool OnDeviceUnlock( const WCHAR *CanonicalVolume );

    bool AreRemoteSizesKnown()
    {
        for(CFileList::iterator iter = m_files.begin(); iter != m_files.end(); iter++ )
            {
            if ( (*iter)->_GetBytesTotal() == -1 )
                return false;
            }
        return true;
    }

    bool
    VerifyFileSizes(
        HANDLE hToken
        );

    CUnknownFileSizeList* GetUnknownFileSizeList() throw( ComError );

    const PROXY_SETTINGS & QueryProxySettings() const
    {
        return m_ProxySettings;
    }


    const CCredentialsContainer & QueryCredentialsList() const
    {
        return m_Credentials;
    }

    virtual StringHandle GetHostId() const
    {
        return StringHandle();
    }

    virtual DWORD GetHostIdFallbackTimeout() const
    {
        return 0xFFFFFFFF;
    }


protected:

    GUID                m_id;
    StringHandle        m_name;
    StringHandle        m_description;
    StringHandle        m_appid;

    SidHandle           m_NotifySid;
    IBackgroundCopyCallback * m_NotifyPointer;
    DWORD               m_NotifyFlags;
    BOOL                m_fGroupNotifySid;

    StringHandle        m_NotifyCmdLine;
    long                m_NotifyLaunchAttempts;

    CJobSecurityDescriptor * m_sd;

    ULONG               m_CurrentFile;
    CFileList           m_files;

    CJobError           m_error;

    ULONG               m_retries;
    ULONG               m_MinimumRetryDelay;
    ULONG               m_NoProgressTimeout;

    FILETIME            m_CreationTime;
    FILETIME            m_LastAccessTime;
    FILETIME            m_ModificationTime;
    FILETIME            m_TransferCompletionTime;

    FILETIME            m_SerializeTime;

    CJobExternal *      m_ExternalInterface;

    static GENERIC_MAPPING s_AccessMapping;

    COldGroupInterface *m_OldExternalGroupInterface;
    COldJobInterface   *m_OldExternalJobInterface;

    PROXY_SETTINGS m_ProxySettings;

    CCredentialsContainer m_Credentials;

    //--------------------------------------------------------------------

    HRESULT DeleteTemporaryFiles();

    HRESULT InterfaceCallback();
    HRESULT CmdLineCallback();
    HRESULT RescheduleCallback();

    HRESULT OldInterfaceCallback();

    HRESULT
    UpdateString(
        StringHandle & destination,
        const StringHandle & Val
        );

    HRESULT
    SetLimitedString(
        StringHandle & destination,
        LPCWSTR Val,
        SIZE_T limit
        );
};

class CUploadJob : public CJob
{
public:
    virtual HRESULT Serialize(HANDLE hFile);
    virtual void Unserialize(HANDLE hFile, int Type);

    CUploadJob(
        LPCWSTR     Name,
        BG_JOB_TYPE Type,
        REFGUID     JobId,
        SidHandle   NotifySid
        );

    CUploadJob() : m_ReplyFile( 0 )
    {
    }

    virtual ~CUploadJob();

    virtual HRESULT Resume();
    virtual HRESULT Cancel();
    virtual HRESULT Complete();

    UPLOAD_DATA & GetUploadData() { return m_UploadData; }

    CFile * GetUploadFile() { return m_files[ 0 ]; }

    virtual StringHandle GetHostId() const
    {
        return m_UploadData.HostId;
    }

    virtual DWORD GetHostIdFallbackTimeout() const
    {
        return m_UploadData.HostIdFallbackTimeout;
    }

    virtual bool IsRunnable();
    virtual void Transfer();

    virtual void
    FileComplete();

    virtual void
    FileTransientError(
        QMErrInfo * ErrInfo
        );

    virtual void
    FileFatalError(
        QMErrInfo * ErrInfo
        );

    virtual void OnRetryJob();
    virtual void OnInactivityTimeout();

    virtual void OnNetworkConnect();
    virtual void OnNetworkDisconnect();

    bool SessionInProgress()
    {
        if (m_UploadData.State > UPLOAD_STATE_CREATE_SESSION &&
            m_UploadData.State < UPLOAD_STATE_CLOSED)
            {
            return true;
            }

        return false;
    }

    void SetReplyFile( CFile * file ) throw( ComError );
    CFile * QueryReplyFile()  { return m_ReplyFile; }

    StringHandle QueryReplyFileName() { return m_ReplyFileName; }

    HRESULT GenerateReplyFile( bool fSerialize );

    HRESULT DeleteGeneratedReplyFile();

    HRESULT RemoveReplyFile();

    HRESULT CommitReplyFile();

    virtual HRESULT
    GetReplyProgress(
        BG_JOB_REPLY_PROGRESS *pProgress
        ) const;

    virtual HRESULT
    GetReplyFileName(
        LPWSTR * pVal
        ) const;

    virtual HRESULT
    SetReplyFileName(
        LPCWSTR Val
        );

    virtual HRESULT
    GetReplyData(
        byte **ppBuffer,
        ULONG *pLength
        ) const;

    // This is a hack because CJob cannot access a protected member of CUploadJob
    //
    void ClearOwnFileNameBit() { m_fOwnReplyFileName = false; }

    virtual void UpdateProgress(
        UINT64 BytesTransferred,
        UINT64 BytesTotal
        );

    bool CheckHostIdFallbackTimeout();

protected:

    UPLOAD_DATA     m_UploadData;
    CFile *         m_ReplyFile;
    StringHandle    m_ReplyFileName;
    bool            m_fOwnReplyFileName;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\clist.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    clist.h

Abstract :

    Header file for IntrusiveList.

Author :

Revision History :

 ***********************************************************************/

#ifndef __CLIST_H__
#define __CLIST_H__

template<class T> class IntrusiveList
{
public:

    struct Link
    {
        Link * m_left;
        Link * m_right;
        IntrusiveList * m_list;

        Link()
        {
            m_left = this;
            m_right = this;
            m_list = NULL;
        }

        void prepend( Link & val )
        {
            ASSERT( val.m_left  == &val );
            ASSERT( val.m_right == &val );
            ASSERT( val.m_list  == NULL );

            ASSERT( m_list != NULL );

            val.m_right = this;
            val.m_left  = m_left;
            val.m_list  = m_list;

            val.m_right->m_left = &val;
            val.m_left->m_right = &val;
        }

        void excise()
        {
            if (m_list == NULL)
                {
                ASSERT( m_left  == this );
                ASSERT( m_right == this );
                return;
                }

            m_right->m_left = m_left;
            m_left->m_right = m_right;

            m_left  = this;
            m_right = this;
            m_list  = NULL;
        }

    };

    class iterator
    {
    public:

        iterator() : m_current(0)
        {
        }

        iterator operator--()
        {
            m_current = m_current->m_left;
            return *this;
        }

        iterator operator--(int)
        {
            // postfix operator

            iterator temp = *this;

            -- *this;

            return temp;
        }

        iterator operator-(int count)
        {
            iterator temp = *this;

            while (count > 0)
                {
                --temp;
                }

            return temp;
        }

        iterator operator+(int count)
        {
            iterator temp = *this;

            while (count > 0)
                {
                ++temp;
                }

            return temp;
        }

        iterator operator++()
        {
            // prefix operator

            m_current = m_current->m_right;
            return *this;
        }

        iterator operator++(int)
        {
            // postfix operator

            iterator temp = *this;

            ++ *this;

            return temp;
        }

        T & operator*()
        {
            return *static_cast<T *> ( m_current );
        }

        T * operator->()
        {
            return &(**this);
        }

        bool operator==(const iterator& _X) const
        {
        return (m_current == _X.m_current);
        }

        bool operator!=(const iterator& _X) const
        {
        return !(*this == _X);
        }

        iterator( Link * p ) : m_current( p )
        {
        }

        Link * next()
        {
            return m_current->m_right;
        }

        Link * prev()
        {
            return m_current->m_left;
        }

        void prepend( Link & val )
        {
            m_current->prepend( val );
        }

        void excise()
        {
            m_current->excise();
        }

    protected:

        Link * m_current;

    };

    //--------------------------------------------------------------------

    IntrusiveList() : m_size(0)
    {
        m_head.m_list = this;
    }

    iterator begin()
    {
        return ++iterator( &m_head );
    }

    iterator end()
    {
        return iterator( &m_head );
    }

    iterator push( T& val )
    {
        return insert( begin(), val );
    }

    iterator push_back( T& val )
    {
        return insert( end(), val );
    }

    iterator insert( iterator pos,  T & val)
    {
        pos.prepend( val );
        ++m_size;

        return iterator( &val );
    }

    size_t erase( T & val )
    {
        if (val.m_list != this)
            {
            return 0;
            }

        val.excise();
        --m_size;

        return 1;
    }

    void erase( iterator & pos )
    {
        if (pos == end())
            {
            return;
            }

        pos.excise();
        --m_size;
    }

    void erase(iterator pos, iterator term)
    {
        while (pos != term)
            {
            erase(pos++);
            }
    }

    iterator find( const T& val )
    {
        for (iterator iter=begin(); iter != end(); ++iter)
            {
            if (&(*iter) == &val)
                {
                return iter;
                }
            }

        return end();
    }

    void clear()
    {
        erase( begin(), end() );
    }

    size_t size()
    {
        if (m_size == 0)
            {
            ASSERT( begin() == end() );
            }
        else
            {
            ASSERT( begin() != end() );
            }

        return m_size;
    }

    bool empty()
    {
        if (m_size == 0)
            {
            ASSERT( begin() == end() );
            }
        else
            {
            ASSERT( begin() != end() );
            }

        return (size() == 0);
    }

protected:

    Link        m_head;
    size_t      m_size;

};

#endif // __CLIST_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\cmanager.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    cmanager.h

Abstract :

    Header file for the CJobManager interface.

Author :

Revision History :

 ***********************************************************************/

#pragma once

#include "qmgrlib.h"
#include <list>
#include "clist.h"
#include "logontable.h"
#include "drizcpat.h"
#include "bitstest.h"
#include <map>

using namespace std;

class CJob;
class CJobManagerFactory;
class CJobManager;
class CJobManagerExternal;

class CJobList : public IntrusiveList<CJob>
{
public:

    BOOL
    Add(
        CJob * job
        );

    CJob *
    Find(
        REFGUID id
        );

    BOOL
    Remove(
        CJob * job
        );

    ~CJobList();

    void Serialize( HANDLE hFile );
    void Unserialize( HANDLE hFile );
    void Clear();

    typedef IntrusiveList<CJob>::iterator iterator;

};

class CJobManagerExternal  : public IBackgroundCopyManager,
                             public IClassFactory,
                             public IBitsTest1
{
public:

    friend CJobManager;

    // IUnknown methods
    //
    STDMETHOD(QueryInterface)(REFIID iid, void** ppvObject);
    ULONG __stdcall AddRef(void);
    ULONG __stdcall Release(void);

    // IBackgroundCopyManager methods

    HRESULT STDMETHODCALLTYPE CreateJobInternal(
        /* [in] */ LPCWSTR DisplayName,
        /* [in] */ BG_JOB_TYPE Type,
        /* [out] */ GUID *pJobId,
        /* [out] */ IBackgroundCopyJob **ppJob);

    HRESULT STDMETHODCALLTYPE CreateJob(
        /* [in] */ LPCWSTR DisplayName,
        /* [in] */ BG_JOB_TYPE Type,
        /* [out] */ GUID *pJobId,
        /* [out] */ IBackgroundCopyJob **ppJob)
    {
        EXTERNAL_FUNC_WRAP( CreateJobInternal( DisplayName, Type, pJobId, ppJob ) )
    }

    HRESULT STDMETHODCALLTYPE GetJobInternal(
        /* [in] */ REFGUID jobID,
        /* [out] */ IBackgroundCopyJob **ppJob);

    HRESULT STDMETHODCALLTYPE GetJob(
        /* [in] */ REFGUID jobID,
        /* [out] */ IBackgroundCopyJob **ppJob)
    {
        EXTERNAL_FUNC_WRAP( GetJobInternal( jobID, ppJob ) )
    }


    HRESULT STDMETHODCALLTYPE EnumJobsInternal(
        /* [in] */ DWORD dwFlags,
        /* [out] */ IEnumBackgroundCopyJobs **ppEnum);

    HRESULT STDMETHODCALLTYPE EnumJobs(
        /* [in] */ DWORD dwFlags,
        /* [out] */ IEnumBackgroundCopyJobs **ppEnum)
    {
        EXTERNAL_FUNC_WRAP( EnumJobsInternal( dwFlags, ppEnum ) )
    }

    HRESULT STDMETHODCALLTYPE GetErrorDescriptionInternal(
        /* [in] */ HRESULT hResult,
        /* [in] */ DWORD LanguageId,
        /* [out] */ LPWSTR *pErrorDescription );

    HRESULT STDMETHODCALLTYPE GetErrorDescription(
        /* [in] */ HRESULT hResult,
        /* [in] */ DWORD LanguageId,
        /* [out] */ LPWSTR *pErrorDescription )
    {
        EXTERNAL_FUNC_WRAP( GetErrorDescriptionInternal( hResult, LanguageId, pErrorDescription ) )
    }

    // IClassFactory methods

    HRESULT __stdcall CreateInstance(IUnknown* pUnkOuter, REFIID iid, void** ppvObject);
    HRESULT __stdcall LockServer(BOOL fLock);

    // IBitsTest1 methods

    virtual HRESULT STDMETHODCALLTYPE GetBitsDllPath(
        /* [out] */ LPWSTR *pVal);

protected:

    long m_ServiceInstance;

    CJobManager *m_pJobManager;
    long m_refs;

    CJobManagerExternal();

    void SetInterfaceClass(
        CJobManager *pVal
        )
    {
        m_pJobManager = pVal;
    }

    void NotifyInternalDelete()
    {
        // Release the internal refcount
        Release();
    }
};

#if !defined( BITS_V12_ON_NT4 )

class CDeviceNotificationController
{
public:
    virtual ~CDeviceNotificationController();

    // General message cracker
    DWORD OnDeviceEvent( DWORD dwEventType, LPVOID lpEventData );

    // Event methods
    virtual void OnDeviceLock( const WCHAR *CanonicalVolume ) = 0;
    virtual void OnDeviceUnlock( const WCHAR *CanonicalVolume ) = 0;
    virtual void OnDismount( const WCHAR *CanonicalVolume ) = 0;

    HRESULT RegisterNotification( const WCHAR *CanonicalVolume );
    HRESULT IsVolumeLocked( const WCHAR *CanonicalVolume );

private:

    class CDriveNotify
        {
    public:
        HDEVNOTIFY m_hDeviceNotify;
        StringHandle m_CanonicalName;
        LONG m_LockCount;
        CDriveNotify( HDEVNOTIFY hDeviceNotify,
                      StringHandle CanonicalName ) :
            m_hDeviceNotify( hDeviceNotify ),
            m_CanonicalName( CanonicalName ),
            m_LockCount( 0 )
            {
            }
        };
    typedef map<HDEVNOTIFY, CDriveNotify*> CHandleToNotify;
    typedef map<StringHandle, CDriveNotify*> CCanonicalVolumeToNotify;

    CHandleToNotify m_HandleToNotify;
    CCanonicalVolumeToNotify m_CanonicalVolumeToNotify;
    void DeleteNotify( CDriveNotify *pNotify );
};

#endif

class CJobManager : public TaskSchedulerWorkItem,
#if !defined( BITS_V12_ON_NT4 )
                    private CDeviceNotificationController,
#endif
                    public CQmgrStateFiles
{
public:

    friend CJobManagerExternal;
    friend COldQmgrInterface;

    HRESULT
    CreateJob(
        LPCWSTR     DisplayName,
        BG_JOB_TYPE Type,
        GUID        Id,
        SidHandle   sid,
        CJob  **    ppJob,
        bool        OldStyleJob = false
        );

    // Returns NULL if job not found
    HRESULT GetJob(
        REFGUID jobID,
        CJob ** ppJob
        );

    //
    // TaskSchedulerWorkItem methods
    //
    void OnDispatch() { TransferCurrentJob(); }

    SidHandle GetSid()
    {
        return g_GlobalInfo->m_LocalSystemSid;
    }

#if !defined( BITS_V12_ON_NT4 )
    // CDeviceNotificationController methods

    DWORD OnDeviceEvent( DWORD dwEventType, LPVOID lpEventData )
    {
         LockWriter();
         DWORD dwResult = CDeviceNotificationController::OnDeviceEvent( dwEventType, lpEventData );
         UnlockWriter();
         return dwResult;
    }
#endif

    //
    // additional functions
    //

    CJobManager();
    virtual ~CJobManager();

    //
    // Notification that a user has logged on.
    //
    void SYNCHRONIZED_WRITE
    UserLoggedOn(
        SidHandle sid
        );

    //
    // Notification that a user has logged off.
    //
    void SYNCHRONIZED_WRITE
    UserLoggedOff(
        SidHandle sid
        );

    //
    // Notification that there was a change in the number of active network adapters.
    //
    void OnNetworkChange();

    //
    // Adjust the job's online/offline state after its owner changes.
    //
    void
    ResetOnlineStatus(
        CJob *pJob,
        SidHandle sid
        );

    void ScheduleDelayedTask(
        TaskSchedulerWorkItem * task,
        ULONG SecondsOfDelay
        )
    {
        FILETIME TimeToRun = GetTimeAfterDelta( (UINT64) NanoSec100PerSec * SecondsOfDelay );

        m_TaskScheduler.InsertWorkItem( task, &TimeToRun );
    }

    void TaskThread();

    HRESULT SuspendJob ( CJob * job );
    HRESULT ResumeJob  ( CJob * job );
    HRESULT CancelJob  ( CJob * job );
    HRESULT CompleteJob( CJob * job );

    HRESULT Serialize();
    HRESULT Unserialize();

    bool LockReader()
    {
        return m_TaskScheduler.LockReader();
    }
    void UnlockReader()
    {
        m_TaskScheduler.UnlockReader();
    }

    bool LockWriter()
    {
        return m_TaskScheduler.LockWriter();
    }

    void UnlockWriter()
    {
        m_TaskScheduler.UnlockWriter();
    }

    //
    // recalculates which job should be downloading and kicks the download thread if necessary.
    //
    void ScheduleAnotherGroup( bool fInsertNetworkDelay = false );

    void MoveJobOffline(
        CJob * job
        );

    void AppendOnline(
        CJob * job
        );

    void Shutdown();

    HRESULT
    CloneUserToken(
        SidHandle psid,
        DWORD     session,
        HANDLE *  pToken
        );

    bool IsUserLoggedOn( SidHandle psid );

    HRESULT RegisterClassObjects();

    void RevokeClassObjects();

    //--------------------------------------------------------------------

    CJobManagerExternal* GetExternalInterface()
    {
        return m_ExternalInterface;
    }

    COldQmgrInterface* GetOldExternalInterface()
    {
        return m_OldQmgrInterface;
    }

    void NotifyInternalDelete()
    {
        GetExternalInterface()->NotifyInternalDelete();
    }

    HRESULT
    GetErrorDescription(
        HRESULT hResult,
        DWORD LanguageId,
        LPWSTR *pErrorDescription );

    Downloader *        m_pPD;
    TaskScheduler       m_TaskScheduler;

    void OnDiskChange(  const WCHAR *CanonicalVolume, DWORD VolumeSerialNumber );

#if !defined( BITS_V12_ON_NT4 )

    HRESULT IsVolumeLocked( const WCHAR *CanonicalPath )
    {
        return CDeviceNotificationController::IsVolumeLocked( CanonicalPath );
    }

#endif

    void RetaskJob( CJob *pJob );

    void InterruptDownload();

    void MoveJobToInactiveState( CJob * job );

    bool RemoveJob( CJob * job )
    {
        if (m_OnlineJobs.Remove( job ))
            {
            return true;
            }

        if (m_OfflineJobs.Remove( job ))
            {
            return true;
            }

        return false;
    }

private:

    CJob *              m_CurrentJob;

    HMODULE             m_hWininet;
    HANDLE              m_hQuantumTimer;

    // cookies from CoRegisterClassObject.
    // used later to unregister.
    //
    DWORD               m_ComId_1_5;
    DWORD               m_ComId_1_0;
    DWORD               m_ComId_0_5;

    CJobList            m_OnlineJobs;
    CJobList            m_OfflineJobs;

    CJobManagerExternal * m_ExternalInterface;
    COldQmgrInterface   * m_OldQmgrInterface;

public:
    CLoggedOnUsers      m_Users;

#if !defined( BITS_V12_ON_NT4 )
    CIpAddressMonitor   m_NetworkMonitor;
#endif

private:

    //--------------------------------------------------------------------

    HRESULT
    GetCurrentGroupAndToken(
        HANDLE * pToken
        );

    void TransferCurrentJob();

    void ChooseCurrentJob();

    void Cleanup();

    // Returns the runing or queued jobs that have
    // a priority >= current priority.
    size_t MoveActiveJobToListEnd( CJob *pJob );

    void SetQuantumTimeout();

public:
    bool CheckForQuantumTimeout();

    void UpdateRemoteSizes(
        CUnknownFileSizeList *pUnknownFileSizeList,
        HANDLE hToken,
        QMErrInfo *pErrorInfo,
        const PROXY_SETTINGS * ProxySettings,
        const CCredentialsContainer * Credentials
        );

private:

    // Event methods
    void OnDeviceLock( const WCHAR *CanonicalVolume );
    void OnDeviceUnlock( const WCHAR *CanonicalVolume );
    void OnDismount( const WCHAR *CanonicalVolume );

    // methods for dealing with network topology changes
    //
    static void CALLBACK
    NetworkChangeCallback(
        PVOID arg
        );

    void MarkJobsWithNetDisconnected();
    void ReactivateTransientErrorJobs();

};

class CLockedJobManagerReadPointer
    {
    CJobManager * const m_Pointer;
public:
    CLockedJobManagerReadPointer( CJobManager * Pointer) :
       m_Pointer(Pointer)
    { m_Pointer->LockReader(); }
    ~CLockedJobManagerReadPointer()
    { m_Pointer->UnlockReader(); }
    CJobManager * operator->() const { return m_Pointer; }
    HRESULT ValidateAccess() { return DenyRemoteAccess(); }
    };

class CLockedJobManagerWritePointer
    {
    CJobManager * const m_Pointer;
public:
    CLockedJobManagerWritePointer( CJobManager * Pointer) :
        m_Pointer(Pointer)
    { m_Pointer->LockWriter(); }
    ~CLockedJobManagerWritePointer()
    { m_Pointer->UnlockWriter(); }
    CJobManager * operator->() const { return m_Pointer; }
    HRESULT ValidateAccess() { return DenyRemoteAccess(); }
    };

extern CJobManagerFactory * g_ManagerFactory;
extern CJobManager * g_Manager;

// SENS logon notification

void ActivateSensLogonNotification();
void DeactiveateSensLogonNotification();

extern MANAGER_STATE g_ServiceState;
extern long          g_ServiceInstance;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\cmanager.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    cmgr.cpp

Abstract :

    implements CJobManager

Author :

Revision History :

 ***********************************************************************/


#include "stdafx.h"
#include <dbt.h>
#include <ioevent.h>
#include <malloc.h>

#if !defined(BITS_V12_ON_NT4)
#include "cmanager.tmh"
#endif

//
// If DownloadCurrentFile fails with TRANSIENT_ERROR, the downloader will sleep for this many seconds.
//
const DWORD DELAY_AFTER_TRANSIENT_ERROR = 60;

//
// After a network-alive notification, we wait this long before attempting a download.
//
const UINT64 NETWORK_INIT_TOLERANCE_SECS = 60;   // in seconds

//------------------------------------------------------------------------

CJobManager * g_Manager;

extern SERVICE_STATUS_HANDLE ghServiceHandle;

//------------------------------------------------------------------------

void GetGuidString( GUID Guid, wchar_t pStr[] )
{
    if (!StringFromGUID2( Guid, pStr, MAX_GUID_CHARS ))
        {
        wcsncpy( pStr, L"(can't convert)", MAX_GUID_CHARS );
        }
}

long g_cCalls = 0;
//
// COM uses this to determine when a DLL can unload safely.
//
long g_cLocks = 0;

HRESULT GlobalLockServer(BOOL fLock)
{

#if !defined( BITS_V12_ON_NT4 )
    if (WPP_LEVEL_ENABLED(LogFlagRefCount))
        {
        LogInfo("%d", fLock );
        }
#endif

    if (fLock)
        InterlockedIncrement(&g_cLocks);
    else
        InterlockedDecrement(&g_cLocks);

    return S_OK;
}

//
// The job manager.
//

MANAGER_STATE g_ServiceState    = MANAGER_INACTIVE;
long          g_ServiceInstance = 0;


CJobManager::CJobManager() :
    m_ComId_0_5( 0 ),
    m_ComId_1_0( 0 ),
    m_ComId_1_5( 0 ),
    m_hWininet(NULL),
    m_pPD( NULL ),
    m_CurrentJob( NULL ),
    m_Users( m_TaskScheduler ),
    m_ExternalInterface( new CJobManagerExternal ),
    m_OldQmgrInterface( new COldQmgrInterface ),
    m_hQuantumTimer(NULL)
{
    try
        {
        QMErrInfo   ErrInfo;

        // use manual reset to insure that we are reseting it when
        // the downloader task is reinserted.
        m_hQuantumTimer = CreateWaitableTimer( NULL, TRUE, NULL );
        if ( !m_hQuantumTimer )
            {
            throw ComError( HRESULT_FROM_WIN32( GetLastError()));
            }

#if !defined( BITS_V12_ON_NT4 )
        THROW_HRESULT( m_NetworkMonitor.Listen( NetworkChangeCallback, this ));
#endif

        //
        // Create the HTTP downloader.
        //
        THROW_HRESULT( CreateHttpDownloader( &m_pPD, &ErrInfo ));

        GetExternalInterface()->SetInterfaceClass( this );
        GetOldExternalInterface()->SetInterfaceClass( this );
        }
    catch( ComError Error )
        {
        Cleanup();
        throw;
        }
}

HRESULT
CJobManager::RegisterClassObjects()
{
    try
        {
        g_ServiceState = MANAGER_ACTIVE;

        THROW_HRESULT(
            CoRegisterClassObject(CLSID_BackgroundCopyManager1_5,
                                  (LPUNKNOWN) static_cast<IClassFactory *>(GetExternalInterface() ),
                                  CLSCTX_LOCAL_SERVER,
                                  REGCLS_MULTIPLEUSE,
                                  &m_ComId_1_5 ) );

        THROW_HRESULT(
            CoRegisterClassObject(CLSID_BackgroundCopyManager,
                                  (LPUNKNOWN) static_cast<IClassFactory *>(GetExternalInterface() ),
                                  CLSCTX_LOCAL_SERVER,
                                  REGCLS_MULTIPLEUSE,
                                  &m_ComId_1_0 ) );

        THROW_HRESULT(
            CoRegisterClassObject(CLSID_BackgroundCopyQMgr,
                                  (LPUNKNOWN) static_cast<IClassFactory *>(GetOldExternalInterface() ),
                                  CLSCTX_LOCAL_SERVER,
                                  REGCLS_MULTIPLEUSE,
                                  &m_ComId_0_5 ) );

        return S_OK;
        }
    catch ( ComError error )
        {
        RevokeClassObjects();
        return error.Error();
        }
}

void
CJobManager::RevokeClassObjects()
{
    if (m_ComId_1_5)
        {
        CoRevokeClassObject( m_ComId_1_5 );
        m_ComId_1_5 = 0;
        }

    if (m_ComId_1_0)
        {
        CoRevokeClassObject( m_ComId_1_0 );
        m_ComId_1_0 = 0;
        }

    if (m_ComId_0_5)
        {
        CoRevokeClassObject( m_ComId_0_5 );
        m_ComId_0_5 = 0;
        }
}

void CJobManager::Cleanup()
{
    RevokeClassObjects();

    if (m_pPD)
        {
        DeleteHttpDownloader( m_pPD );
        m_pPD = NULL;
        }

    if (m_hWininet)
        {
        FreeLibrary(m_hWininet);
        m_hWininet = NULL;
        }

    if ( m_hQuantumTimer )
        {
        CloseHandle( m_hQuantumTimer );
        m_hQuantumTimer = NULL;
        }

    LogInfo( "cleanup: marking manager inactive" );

    g_ServiceState = MANAGER_INACTIVE;
}

CJobManager::~CJobManager()
{
    Cleanup();
}

void
CJobManager::Shutdown()
{
    g_ServiceState = MANAGER_TERMINATING;

    // 1. Block creation of new manager proxies.

    LogInfo( "shutdown: revoking class objects" );

    RevokeClassObjects();

    m_TaskScheduler.KillBackgroundTasks();

#if !defined( BITS_V12_ON_NT4 )

    // 1.5 halt network-change notification

    m_NetworkMonitor.CancelListen();

#endif

    // 5. Wait for calls in progress to finish.

    // releasing the reference for the hook thread, added during the constructor.
    //
    LogInfo("release: internal usage");
    NotifyInternalDelete();

    while (ActiveCallCount() > 0)
        {
        Sleep(50);
        }

    LogInfo( "shutdown: finished" );
}


void
CJobManager::TaskThread()
{
    HANDLE hWorkItemAvailable = m_TaskScheduler.GetWaitableObject();

    while (1)
        {
        DWORD dwRet = MsgWaitForMultipleObjectsEx( 1,
                                                   &hWorkItemAvailable,
                                                   INFINITE,
                                                   QS_ALLINPUT,
                                                   MWMO_ALERTABLE
                                                   );

        switch ( dwRet )
            {
            case WAIT_OBJECT_0:
                m_TaskScheduler.DispatchWorkItem();
                break;
            case WAIT_OBJECT_0 + 1:
                // There is one or more window message available. Dispatch them
                MSG msg;

                while (PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
                    {
                    if ( msg.message == WM_QUIT )
                        return;

                    TranslateMessage(&msg);
                    DispatchMessage(&msg);

                    if (WaitForSingleObject(hWorkItemAvailable, 0) == WAIT_OBJECT_0)
                        m_TaskScheduler.DispatchWorkItem();
                    }
                break;

            case WAIT_IO_COMPLETION:
                //
                // an APC fired.
                //
                break;

            default:
                Sleep( 20 * 1000 );
                break;
            }
        }
}

//------------------------------------------------------------------------

HRESULT
CJobManager::CreateJob(
    LPCWSTR     DisplayName,
    BG_JOB_TYPE Type,
    GUID        Id,
    SidHandle   sid,
    CJob  **    ppJob,
    bool        OldStyleJob
    )
{
    HRESULT Hr = S_OK;
    *ppJob = NULL;
    //
    // create the job
    //
    try
        {
        if (Type != BG_JOB_TYPE_DOWNLOAD
#if !defined(BITS_V12)
            && Type != BG_JOB_TYPE_UPLOAD
            && Type != BG_JOB_TYPE_UPLOAD_REPLY
#endif
            )
            {
            throw ComError( E_NOTIMPL );
            }

        // Do not allow duplicate guids
        if ( m_OnlineJobs.Find( Id ) ||
             m_OfflineJobs.Find( Id ) )
            throw ComError( E_INVALIDARG );

        auto_ptr<WCHAR> TempDisplayName(NULL);
        DisplayName = TruncateString( DisplayName, MAX_DISPLAYNAME, TempDisplayName );

        ExtendMetadata();

        if (Type == BG_JOB_TYPE_DOWNLOAD)
            {
            *ppJob = new CJob( DisplayName, Type, Id, sid );

            if ( OldStyleJob )
                {
                COldGroupInterface *pOldGroup = new COldGroupInterface( *ppJob );

                (*ppJob)->SetOldExternalGroupInterface( pOldGroup );
                }
            }
        else
            {
            *ppJob = new CUploadJob( DisplayName, Type, Id, sid );
            }

        m_OnlineJobs.Add( *ppJob );

        m_TaskScheduler.InsertDelayedWorkItem( static_cast<CJobInactivityTimeout *>(*ppJob),
                                               g_GlobalInfo->m_JobInactivityTimeout
                                               );
        Serialize();
        }
    catch( ComError exception )
    {
        Hr = exception.Error();

        if (*ppJob)
            {
            (*ppJob)->UnlinkFromExternalInterfaces();
            delete *ppJob;
            *ppJob = NULL;
            }

        ShrinkMetadata();
    }

    return Hr;
}

HRESULT
CJobManager::GetJob(
    REFGUID id,
    CJob ** ppJob
    )
{
    *ppJob = NULL;

    CJob * job = m_OnlineJobs.Find( id );
    if (job != NULL)
        {
        if (S_OK != job->IsVisible())
            {
            return E_ACCESSDENIED;
            }

        job->UpdateLastAccessTime();
        *ppJob = job;
        return S_OK;
        }

    job = m_OfflineJobs.Find( id );
    if (job != NULL)
        {
        if (S_OK != job->IsVisible())
            {
            return E_ACCESSDENIED;
            }

        job->UpdateLastAccessTime();
        *ppJob = job;
        return S_OK;
        }

    return BG_E_NOT_FOUND;
}

HRESULT
CJobManager::SuspendJob(
    CJob * job
    )
{
    BG_JOB_STATE state = job->_GetState();

    switch (state)
        {
        case BG_JOB_STATE_SUSPENDED:
            {
            return S_OK;
            }

        case BG_JOB_STATE_CONNECTING:
        case BG_JOB_STATE_TRANSFERRING:

            InterruptDownload();
            // OK to fall through here

        case BG_JOB_STATE_TRANSFERRED:

            m_TaskScheduler.CancelWorkItem( static_cast<CJobCallbackItem *>(job) );

            // fall through

        case BG_JOB_STATE_QUEUED:
        case BG_JOB_STATE_TRANSIENT_ERROR:
        case BG_JOB_STATE_ERROR:

            m_TaskScheduler.CancelWorkItem( static_cast<CJobNoProgressItem *>(job) );

            job->SetState( BG_JOB_STATE_SUSPENDED );
            job->UpdateModificationTime();

            ScheduleAnotherGroup();
            return S_OK;

        case BG_JOB_STATE_CANCELLED:
        case BG_JOB_STATE_ACKNOWLEDGED:
            {
            return BG_E_INVALID_STATE;
            }

        default:
            {
            ASSERT( 0 );
            return S_OK;
            }
        }

    ASSERT( 0 );
    return S_OK;
}

bool
CJobManager::IsUserLoggedOn( SidHandle sid )
{
    CUser * user = m_Users.FindUser( sid, ANY_SESSION );

    if (!user)
        {
        return false;
        }

    user->DecrementRefCount();

    return true;
}

HRESULT
CJobManager::CloneUserToken(
    SidHandle sid,
    DWORD     session,
    HANDLE *  pToken
    )
{
    CUser * user = m_Users.FindUser( sid, session );

    if (!user)
        {
        return HRESULT_FROM_WIN32( ERROR_NOT_LOGGED_ON );
        }

    HRESULT hr = user->CopyToken( pToken );

    user->DecrementRefCount();

    return hr;
}

void CJobManager::TransferCurrentJob()
{
    LogDl("***********START********************");

    if (m_TaskScheduler.LockWriter() )
        {
        m_TaskScheduler.AcknowledgeWorkItemCancel();
        return;
        }

    if (NULL == m_CurrentJob)
        {
        LogDl( "no more items" );
        }
    else
        {
        LogDl("transferring job %p", m_CurrentJob);
        m_CurrentJob->Transfer();
        }

    // It's OK if the item has already been completed.
    //
    m_TaskScheduler.CompleteWorkItem();

    ScheduleAnotherGroup();

    m_TaskScheduler.UnlockWriter();

    LogDl("************END*********************");
}

void CJobManager::MoveJobOffline(
    CJob * job
    )
{
    m_OnlineJobs.Remove( job );
    m_OfflineJobs.Add( job );
}

void CJobManager::AppendOnline(
    CJob * job
    )
//
// moves a job to the end of the active list.
//
{
    if (!m_OnlineJobs.Remove( job ))
        {
        m_OfflineJobs.Remove( job );
        }

    m_OnlineJobs.Add( job );
}

void
CJobManager::UpdateRemoteSizes(
    CUnknownFileSizeList *pUnknownFileSizeList,
    HANDLE hToken,
    QMErrInfo *pErrorInfo,
    const PROXY_SETTINGS *ProxySettings,
    const CCredentialsContainer * Credentials
     )
{

    for(CUnknownFileSizeList::iterator iter = pUnknownFileSizeList->begin();
        iter != pUnknownFileSizeList->end(); iter++ )
        {

        CFile *pFile        = iter->m_file;
        const WCHAR *pURL   = (const WCHAR*)iter->m_url;

        pErrorInfo->Clear();


        LogDl( "Retrieving remote infomation for %ls", pURL );


        UINT64 FileSize;
        FILETIME FileTime;

        m_pPD->GetRemoteFileInformation(
            hToken,
            pURL,
            &FileSize,
            &FileTime,
            pErrorInfo,
            ProxySettings,
            Credentials
            );

        // If we can't get the size for one file, skip that file
        // and move to other files in the file.

        if (pErrorInfo->result != QM_FILE_DONE )
            {
            LogWarning( "Unable to retrieve remote information for %ls", pURL );
            continue;
            }

        // Update size in file.

        if ( m_TaskScheduler.LockWriter() )
            {
            m_TaskScheduler.AcknowledgeWorkItemCancel();
            pErrorInfo->result = QM_FILE_ABORTED;
            return;
            }

        pFile->SetBytesTotal( FileSize );

        //
        // A zero-length file will not be downloading any info, so it skips the normal path
        // for setting the correct creation time. Set it here.
        //
        if (FileSize == 0 &&
            (FileTime.dwLowDateTime != 0 || FileTime.dwHighDateTime != 0))
            {
            DWORD err = pFile->SetLocalFileTime( FileTime );

            if (err)
                {
                pErrorInfo->result = QM_FILE_TRANSIENT_ERROR;
                pErrorInfo->Set( SOURCE_QMGR_FILE, ERROR_STYLE_WIN32, err, NULL );
                }
            }

        m_TaskScheduler.UnlockWriter();

        }

}

void
CJobManager::InterruptDownload()
{
    LogInfo( "Interrupting download...\n");

    // Cancel the downloader workitem.  CancelWorkItem
    // should ignore the request if the a download isn't running or pending.
    // Writer lock required!!!!!

    m_TaskScheduler.CancelWorkItem( this );

    // Now you must call ScheduleAnotherGroup, in order for the downloader to download anything.
}

void
CJobManager::ScheduleAnotherGroup(
    bool fInsertNetworkDelay
    )
/*++

Description:

    Called by any thread to make sure that the highest-priority available job is being downloaded.
    It finds the highest-priority job that is in the QUEUED or RUNNING state.
    If this job is different from the current download job, the current job is cancelled and
    the new job is started.  If no job is currently running, the new job is started.

    Starting the new job requires interrupting the download thread.

At entry:

    m_CurrentJob is the job being downloaded
    If the downloader thread is active, then the manager's work item is in the scheduler.
    Otherwise it is not.

At exit:

    the best available job to download is in m_CurrentJob, or NULL if none available
    If a job is available, the work item is in the task scheduler.


--*/
{
    CJob *pOldCurrentJob = m_CurrentJob;

    if (IsServiceShuttingDown())
        {
        LogInfo("no job scheduled; service is shutting down.");
        m_CurrentJob = NULL;
        }
    else
        {
        //
        // Choose the best candidate, which may be the old current job.
        //
        ChooseCurrentJob();

        #if DBG

        // do some validation checking on the queue

        ULONG RunningJobs = 0;

        for (CJobList::iterator iter = m_OnlineJobs.begin(); iter != m_OnlineJobs.end(); ++iter)
            {
            if ( iter->IsRunning() )
                RunningJobs++;
            }

        if (m_CurrentJob == NULL)
            {
            ASSERT( RunningJobs == 0 );
            }
        else
            {
            // zero if the download item is queued, one if running
            //
            ASSERT( RunningJobs == 0 || RunningJobs == 1 );
            }

        #endif
        }

    if (m_CurrentJob)
        {

        if ( m_CurrentJob != pOldCurrentJob )
            m_TaskScheduler.CancelWorkItem( this );

        if (!m_TaskScheduler.IsWorkItemInScheduler( this ))
            {
            if (fInsertNetworkDelay)
                {
                m_TaskScheduler.InsertDelayedWorkItem( this,
                                                       NETWORK_INIT_TOLERANCE_SECS * NanoSec100PerSec );
                }
            else
                {
                m_TaskScheduler.InsertWorkItem( this );
                }
            }
        }
    else
        {
        m_TaskScheduler.CancelWorkItem( this );
        }
}

void
CJobManager::ChooseCurrentJob()
{
    CJob * NewJob = NULL;

#if !defined( BITS_V12_ON_NT4 )
    if (m_NetworkMonitor.GetAddressCount() == 0)
        {
        NewJob = NULL;
        }
    else
        {
#endif
        // Look at all the jobs and choose the best one
        for (CJobList::iterator iter = m_OnlineJobs.begin(); iter != m_OnlineJobs.end(); ++iter)
            {
            if (iter->IsRunnable())
                {
                BG_JOB_PRIORITY priority = iter->_GetPriority();

                if ( !NewJob || ( priority < NewJob->_GetPriority() ) )
                    {
                    NewJob = &(*iter);
                    }
                }
            }
#if !defined( BITS_V12_ON_NT4 )
        }
#endif

    LogInfo( "scheduler: current=%p   new=%p", m_CurrentJob, NewJob );

    if (m_CurrentJob == NewJob)
        {
        return;
        }

    if ( m_CurrentJob )
        {
        LogInfo( "scheduler: current priority %u", m_CurrentJob->_GetPriority() );

        //
        // an inactive job goes to QUEUED state if we have network connectivity,
        // TRANSIENT_ERROR state otherwise.
        //
        if ( m_CurrentJob->IsRunning() )
            {
            m_CurrentJob->MoveToInactiveState();
            m_CurrentJob->ScheduleModificationCallback();
            }
        }

    if ( NewJob )
        {
        LogInfo( "scheduler: new priority %u", NewJob->_GetPriority() );
        SetQuantumTimeout();
        }

    m_CurrentJob = NewJob;
}

void
CJobManager::RetaskJob( CJob *pJob )
{
    if ( pJob->IsRunning() )
        {
        InterruptDownload();
        }

    ScheduleAnotherGroup();
}

void CALLBACK
CJobManager::NetworkChangeCallback(
    PVOID arg
    )
{
    reinterpret_cast<CJobManager *>(arg)->OnNetworkChange();
}

void
CJobManager::OnNetworkChange()
{

#if !defined( BITS_V12_ON_NT4 )

    if (g_ServiceState == MANAGER_TERMINATING)
        {
        LogInfo("network change: manager terminating");
        return;
        }

    LogInfo("network adapters changed: now %d active", m_NetworkMonitor.GetAddressCount());

    if (m_NetworkMonitor.GetAddressCount() > 0)
        {
        ReactivateTransientErrorJobs();
        }
    else
        {
        MarkJobsWithNetDisconnected();
        }

    {
    HoldWriterLock lock( &m_TaskScheduler );

    //
    // The previous proxy data is  incorrect if we have switched from a corporate net to roaming or vice-versa..
    //
    g_ProxyCache->Clear();

    ScheduleAnotherGroup();
    }

    for (int i=1; i <= 3; ++i)
        {
        HRESULT hr;

        hr = m_NetworkMonitor.Listen( NetworkChangeCallback, this );
        if (SUCCEEDED(hr))
            {
            return;
            }

        LogError( "re-listen failed %x", hr);
        Sleep( 1000 );
        }

#endif

}

void
CJobManager::MarkJobsWithNetDisconnected()
{
    HoldWriterLock lock( &m_TaskScheduler );

    for (CJobList::iterator iter=m_OnlineJobs.begin(); iter != m_OnlineJobs.end(); ++iter)
        {
        iter->OnNetworkDisconnect();
        }

    for (CJobList::iterator iter=m_OfflineJobs.begin(); iter != m_OfflineJobs.end(); ++iter)
        {
        iter->OnNetworkDisconnect();
        }

    ScheduleAnotherGroup();
}


void
CJobManager::ReactivateTransientErrorJobs()
{
    HoldWriterLock lock( &m_TaskScheduler );

    for (CJobList::iterator iter=m_OnlineJobs.begin(); iter != m_OnlineJobs.end(); ++iter)
        {
        iter->OnNetworkConnect();
        }

    for (CJobList::iterator iter=m_OfflineJobs.begin(); iter != m_OfflineJobs.end(); ++iter)
        {
        iter->OnNetworkConnect();
        }

    ScheduleAnotherGroup( true );
}

void
CJobManager::UserLoggedOn(
    SidHandle sid
    )
{
    HoldWriterLock LockHolder( &m_TaskScheduler );

    CJobList::iterator iter = m_OfflineJobs.begin();

    while (iter != m_OfflineJobs.end())
        {
        if (false == iter->IsOwner( sid ))
            {
            ++iter;
            continue;
            }

        LogInfo("manager : moving job %p to online list", &(*iter) );

        //
        // move the job to the online list.
        //
        CJobList::iterator next = iter;

        ++next;

        m_OfflineJobs.erase( iter );
        m_OnlineJobs.push_back( *iter );

        iter = next;
        }

    //
    // Make sure a group is running.
    //
    ScheduleAnotherGroup();
}

void
CJobManager::UserLoggedOff(
    SidHandle sid
    )
{
    bool fReschedule = false;

    HoldWriterLock LockHolder( &m_TaskScheduler );

    //
    // If a job is in progress and the user owns it, cancel it.
    //
    if (m_CurrentJob &&
        m_CurrentJob->IsOwner( sid ))
        {
        InterruptDownload();
        fReschedule = true;
        }

    //
    // Move all the user's jobs into the offline list.
    //
    CJobList::iterator iter = m_OnlineJobs.begin();

    while (iter != m_OnlineJobs.end())
        {
        //
        // Skip over other users' job.
        // Also skip over the currently downloading job, which will be handled by the download thread.
        //
        if (false == iter->IsOwner( sid ) ||
            &(*iter) == m_CurrentJob)
            {
            ++iter;
            continue;
            }

        LogInfo("manager : moving job %p to offline list", &(*iter) );

/*
this should't ever be true, since we skip over m_CurrentJob.

        if (iter->IsRunning() )
            {
            iter->MoveToInactiveState();
            }
*/      ASSERT( false == iter->IsRunning() );

        //
        // move the job to the online list.
        //
        CJobList::iterator next = iter;

        ++next;

        m_OnlineJobs.erase( iter );
        m_OfflineJobs.push_back( *iter );

        iter = next;
        }

    if (fReschedule)
        {
        ScheduleAnotherGroup();
        }
}

void
CJobManager::ResetOnlineStatus(
    CJob *pJob,
    SidHandle sid
    )
//
// Called when a job owner changes.  This fn checks whether the job needs to be moved
// from the offline list to the online list.  (If the job needs to move from the online
// list to the offline list, the downloader thread will take care of it when the job
// becomes the current job.)
//
{

    if ( IsUserLoggedOn( sid ) &&
         m_OfflineJobs.Remove( pJob ) )
        {
        m_OnlineJobs.Add( pJob );
        }
}

size_t
CJobManager::MoveActiveJobToListEnd(
    CJob *pJob
    )
{

#if !defined( BITS_V12_ON_NT4 )
    if (m_NetworkMonitor.GetAddressCount() == 0)
        {
        // if the net is disconnected, no need to rearrange jobs.
        //
        return 1;
        }
#endif

    ASSERT( m_TaskScheduler.IsWriter() );

    // Returns the number of queue or running jobs with a higher or same priority as ourself.

    ASSERT( pJob->IsRunnable() );

    size_t PossibleActiveJobs = 0;

    CJobList::iterator jobpos = m_OnlineJobs.end();

    for (CJobList::iterator iter = m_OnlineJobs.begin(); iter != m_OnlineJobs.end(); ++iter)
        {
        if ( iter->IsRunnable() &&
             iter->_GetPriority() <= pJob->_GetPriority() )
            {
            PossibleActiveJobs++;
            }

        if ( &(*iter) == pJob )
            {
            jobpos = iter;
            }
        }

    //
    // If the job is online, and another job can be pushed to the front,
    // push our job to the back.
    //
    if ( PossibleActiveJobs > 1 && jobpos != m_OnlineJobs.end())
        {
        // move job to the end of the list.
        m_OnlineJobs.erase( jobpos );

        m_OnlineJobs.push_back( *pJob );
        }
    else if (jobpos == m_OnlineJobs.end())
        {
        LogWarning("resuming an offline job");
        }

    return PossibleActiveJobs;
}

void
CJobManager::SetQuantumTimeout()
{
   LARGE_INTEGER QuantumTime;
   QuantumTime.QuadPart = -g_GlobalInfo->m_TimeQuantaLength;

   BOOL bResult =
   SetWaitableTimer(
       m_hQuantumTimer,
       &QuantumTime,
       0,
       NULL,
       NULL,
       FALSE );
   ASSERT( bResult );
}

bool
CJobManager::CheckForQuantumTimeout()
{

    DWORD dwResult =
        WaitForSingleObject( m_hQuantumTimer, 0 );

    if ( WAIT_OBJECT_0 != dwResult)
        {
        // The timer didn't expire, so we have nothing to do.
        return false;
        }

    // The timeout fired so we need to move the current job
    // to the end of the list and signal the downloader to abort.
    // Do not cancel the current work item and do not change the current
    // job. Just let the downloader exit and let it call ScheduleAnotherGroup
    // to switch jobs if needed.

    // Special case.  If only one RUNNING or QUEUED job exists in the list with
    // a priority >= our own, then we have no reason to switch tasks.
    // Just reset the timer and continue.

    bool fTookWriter = false;

    if (!m_TaskScheduler.IsWriter())
        {
        if (m_TaskScheduler.LockWriter() )
            {
            // cancelled; can't tell whether there is more than one job - assume the worst.
            return true;
            }

        fTookWriter = true;
        }

    ASSERT( m_CurrentJob );
    size_t PossibleActiveJobs = MoveActiveJobToListEnd( m_CurrentJob );

    if (fTookWriter)
        {
        m_TaskScheduler.UnlockWriter();
        }

    if ( 1 == PossibleActiveJobs )
        {

        LogInfo( "Time quantum fired, but nothing else can run.  Ignoring and resetting timer.");

        SetQuantumTimeout();

        return false;

        }

    LogInfo( "Time quantum fired, moving job to the end of the queue.");
    return true; // signal downloader to abort
}

extern HMODULE g_hInstance;

HRESULT
CJobManager::GetErrorDescription(
    HRESULT hResult,
    DWORD LanguageId,
    LPWSTR *pErrorDescription )
{
    // Do not allow 0 for now, untill propagation of thread error is investigated more.
    if (!LanguageId)
        {
        return E_INVALIDARG;
        }

    TCHAR *pBuffer = NULL;

    //
    // Use the following search path to find the message.
    //
    // 1. This DLL
    // 2. wininet.dll
    // 3. the system

    DWORD dwSize =
        FormatMessage(
            FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
            g_hInstance,
            (DWORD)hResult,
            LanguageId,
            (LPTSTR)&pBuffer,
            0,
            NULL );

    if ( !dwSize )
        {

        if ( GetLastError() == ERROR_OUTOFMEMORY )
            {
            return HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
            }

        {

#if defined( USE_WININET )
        if (!m_hWininet)
            {
            m_hWininet =
                LoadLibraryEx( _T("wininet.dll"), NULL, LOAD_LIBRARY_AS_DATAFILE );
            }
#else
        if (!m_hWininet)
            {
            m_hWininet =
                LoadLibraryEx( _T("winhttp.dll"), NULL, LOAD_LIBRARY_AS_DATAFILE );
            }
#endif


        if ( m_hWininet )
            {

            dwSize =
                FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_IGNORE_INSERTS,
                    m_hWininet,
                    (DWORD)(0x0000FFFF & (hResult)),
                    LanguageId,
                    (LPTSTR)&pBuffer,
                    0,
                    NULL );

            if ( !dwSize && ( GetLastError() == ERROR_OUTOFMEMORY ) )
                {
                return HRESULT_FROM_WIN32( ERROR_OUTOFMEMORY );
                }

            }


        }

        if ( !dwSize )
            {

            dwSize =
                FormatMessage(
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    (DWORD)hResult,
                    LanguageId,
                    (LPTSTR)&pBuffer,
                    0,
                    NULL );


            if (!dwSize)
                {
                return HRESULT_FROM_WIN32( GetLastError() );
                }

            }

        }

    ++dwSize;       // needs to include trailing NULL

    ASSERT( pBuffer );

#if !defined(_UNICODE)
#error need to add ASCII to unicode conversion here
#else

    *pErrorDescription = MidlCopyString( pBuffer );

    LocalFree( pBuffer );

    return (*pErrorDescription) ? S_OK : E_OUTOFMEMORY;
#endif
}

// {C82BF713-9940-4a12-9F1A-3AAEBD894EEA}
static const GUID PriorityQueuesStorage =
{ 0xc82bf713, 0x9940, 0x4a12, { 0x9f, 0x1a, 0x3a, 0xae, 0xbd, 0x89, 0x4e, 0xea } };


HRESULT
CJobManager::Serialize()
{

    //
    // If this function changes, be sure that the metadata extension
    // constants are adequate.
    //

    HRESULT hr;

    try
    {
        //
        // Serialization requires the thread to run in local-system context.
        // If the thread is impersonating a COM client, it must revert.
        //
        CSaveThreadToken tok;

        RevertToSelf();

        // The service should automatically start if any groups
        // are in the waiting/Running state or a logged off user has groups.
        bool bAutomaticStart;
        bAutomaticStart = (m_OnlineJobs.size() > 0) || (m_OfflineJobs.size() > 0);

        LogSerial("Need to set service to %s start", bAutomaticStart ? "auto" : "manual" );
        if ( bAutomaticStart )
            {
            // If we can't set the service to autostart, it's a fatal error.
            // Fail the serialize at this point.
            THROW_HRESULT( SetServiceStartup( bAutomaticStart ) );
            }

        CQmgrWriteStateFile StateFile( *this );

        HANDLE hFile = StateFile.GetHandle();

        SafeWriteBlockBegin( hFile, PriorityQueuesStorage );

        m_OnlineJobs.Serialize( hFile );
        m_OfflineJobs.Serialize( hFile );

        SafeWriteBlockEnd( hFile, PriorityQueuesStorage );

        StateFile.CommitFile();

        if ( !bAutomaticStart )
            {
            // If we can't set the service to manual, its not a big deal.  The worst
            // that should happen is we start when we really don't need to.
            hr = SetServiceStartup( bAutomaticStart );
            if ( !SUCCEEDED( hr ) )
                {
                LogWarning("Couldn't set service startup to manual, ignoring. Hr 0x%8.8X", hr );
                }
            }

        LogSerial( "finished");
        hr = S_OK;
    }

    catch( ComError Error )
    {
       LogWarning("Error %u writing metadata\n", Error.Error() );
       hr = Error.Error();
    }

    return hr;
}

HRESULT
CJobManager::Unserialize()
{
    HRESULT hr;

    try
        {
        BOOL fIncludeLogoffList;
        CQmgrReadStateFile StateFile( *this );

        HANDLE hFile = StateFile.GetHandle();

        SafeReadBlockBegin( hFile, PriorityQueuesStorage );

        //
        // In the Serialize() code, the first is online jobs and the second is offline.
        // When unserializing, the set of logged-in users is likely to be different, so
        // we pull them all in and then lazily move them to the offline list.
        //
        m_OnlineJobs.Unserialize( hFile );
        m_OnlineJobs.Unserialize( hFile );

        SafeReadBlockEnd( hFile, PriorityQueuesStorage );

        StateFile.ValidateEndOfFile();

        hr = S_OK;
        }
    catch( ComError err )
        {
        //
        // File corruption is reason to delete the group data and start fresh.
        // Other errors, like out-of-memory, are not.
        //
        LogError( "Error %u reading metadata", err.Error() );

        hr = err.Error();

        if (hr == HRESULT_FROM_WIN32( ERROR_INVALID_PARAMETER ) ||
            hr == HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ))
            {
            LogSerial("clearing job list");

            m_OnlineJobs.Clear();
            m_OfflineJobs.Clear();
            hr = S_OK;
            }
        }

    return hr;
}

void
CJobManager::OnDeviceLock(
    const WCHAR *CanonicalVolume )
{
    bool fChanged = false;

    // Look at all the jobs and move the ones for this drive to the
    // transient error state.
    for (CJobList::iterator iter = m_OnlineJobs.begin(); iter != m_OnlineJobs.end(); ++iter)
        {
        fChanged |= iter->OnDeviceLock( CanonicalVolume );
        }

    if (fChanged)
        {
        ScheduleAnotherGroup();
        Serialize();
        }
}

void
CJobManager::OnDeviceUnlock(
    const WCHAR *CanonicalVolume )
{
    bool fChanged = false;

    // Look at all the jobs and retry the ones that are in the transient error state
    // do to this drive being locked.
    for (CJobList::iterator iter = m_OnlineJobs.begin(); iter != m_OnlineJobs.end(); ++iter)
        {
        fChanged |= iter->OnDeviceUnlock( CanonicalVolume );
        }

    if (fChanged)
        {
        ScheduleAnotherGroup();
        Serialize();
        }
}

void
CJobManager::OnDiskChange(
    const WCHAR *CanonicalVolume,
    DWORD VolumeSerialNumber )
{

    for (CJobList::iterator iter = m_OnlineJobs.begin(); iter != m_OnlineJobs.end(); ++iter)
        {
        iter->OnDiskChange( CanonicalVolume, VolumeSerialNumber );
        }
    ScheduleAnotherGroup();
    Serialize();
}

void
CJobManager::OnDismount(
    const WCHAR *CanonicalVolume )
{
    for (CJobList::iterator iter = m_OnlineJobs.begin(); iter != m_OnlineJobs.end(); ++iter)
        {
        iter->OnDismount( CanonicalVolume );
        }
    ScheduleAnotherGroup();
    Serialize();
}


BOOL
CJobList::Add(
    CJob * job
    )
//
// adds a single group to the list.
//
{
    push_back( *job );

    return TRUE;
}

CJob *
CJobList::Find(
    REFGUID id
    )
{
    iterator iter;

    for (iter=begin(); iter != end(); ++iter)
        {
        GUID jobid = iter->GetId();

        if (id == jobid)
            {
            return &(*iter);
            }
        }

    return NULL;
}

BOOL
CJobList::Remove(
    CJob * job
    )
//
// removes a single group to the list.  Quite inefficient for large lists.
//
{
    iterator iter;

    for (iter=begin(); iter != end(); ++iter)
        {
        if (job == &(*iter))
            {
            erase( iter );

            return TRUE;
            }
        }

    return FALSE;
}

void
CJobList::Clear()
{
    iterator iter;

    while ((iter=begin()) != end())
        {
        CJob * job = &(*iter);

        erase( iter );

        job->Release();
        }
}

// {005F4447-BDA9-44ba-9851-C47BB6C07ACE}
static const GUID GroupListStorageGuid =
{ 0x5f4447, 0xbda9, 0x44ba, { 0x98, 0x51, 0xc4, 0x7b, 0xb6, 0xc0, 0x7a, 0xce } };

void
CJobList::Serialize( HANDLE hFile )
{
    DWORD dwNumberOfGroups = 0;

    dwNumberOfGroups = size();

    SafeWriteBlockBegin( hFile, GroupListStorageGuid );
    SafeWriteFile( hFile, dwNumberOfGroups );

    iterator iter;
    for (iter=begin(); iter != end(); ++iter)
        {
        iter->Serialize(hFile);
        }

    SafeWriteBlockEnd( hFile, GroupListStorageGuid );
}

void
CJobList::Unserialize(
    HANDLE hFile
    )
{
    SafeReadBlockBegin( hFile, GroupListStorageGuid );

    DWORD dwNumberOfGroups;
    SafeReadFile( hFile, &dwNumberOfGroups );

    for (int i = 0; i < dwNumberOfGroups; i++)
        {
        CJob * job = NULL;

        try
            {
            job = CJob::UnserializeJob( hFile );

            push_back( *job );

            LogSerial( "added job %p to queue %p, priority %d",
                       job, this, job->_GetPriority() );
            }
        catch ( ComError err )
            {
            LogError( "error in joblist unserialize 0x%x", err.Error() );
            throw;
            }
        }

    SafeReadBlockEnd( hFile, GroupListStorageGuid );

}

CJobList::~CJobList()
{
    ASSERT( g_ServiceState != MANAGER_ACTIVE );

    iterator iter;

    while ( (iter=begin()) != end() )
        {
        CJob * job = &(*iter);

        LogInfo("deleting job %p", job );

        iter.excise();

        job->UnlinkFromExternalInterfaces();
        delete job;
        }
}

CJobManagerExternal::CJobManagerExternal() :
    m_ServiceInstance( g_ServiceInstance ),
    m_refs(1),
    m_pJobManager( NULL )
{
}

STDMETHODIMP
CJobManagerExternal::QueryInterface(
    REFIID iid,
    void** ppvObject
    )
{
    BEGIN_EXTERNAL_FUNC

    HRESULT Hr = S_OK;
    *ppvObject = NULL;

    if (iid == IID_IUnknown)
        {
        *ppvObject = static_cast<IBackgroundCopyManager *>(this);

        LogInfo("mgr: QI for IUnknown");
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else if (iid == IID_IBackgroundCopyManager)
        {
        *ppvObject = static_cast<IBackgroundCopyManager *>(this);

        LogInfo("mgr: QI for IManager");
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else if (iid == IID_IClassFactory)
        {
        *ppvObject = static_cast<IClassFactory *>(this);

        LogInfo("mgr: QI for IFactory");
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else if (iid == __uuidof(IBitsTest1))
        {
        *ppvObject = static_cast<IBitsTest1 *>(this);

        LogInfo("mgr: QI for IFactory");
        ((IUnknown *)(*ppvObject))->AddRef();
        }
    else
        {
        Hr = E_NOINTERFACE;
        }

    LogRef( "iid %!guid!, Hr %x", &iid, Hr );
    return Hr;

    END_EXTERNAL_FUNC
}

ULONG
CJobManagerExternal::AddRef()
{
    BEGIN_EXTERNAL_FUNC;

    ULONG newrefs = InterlockedIncrement(&m_refs);

    LogRef( "new refs = %d", newrefs );

    return newrefs;

    END_EXTERNAL_FUNC;
}

ULONG
CJobManagerExternal::Release()
{
    BEGIN_EXTERNAL_FUNC;

    ULONG newrefs = InterlockedDecrement(&m_refs);

    LogRef( "new refs = %d", newrefs );

    if (newrefs == 0)
        {
        delete this;
        }

    return newrefs;

    END_EXTERNAL_FUNC;
}

/************************************************************************************
IClassFactory Implementation
************************************************************************************/
HRESULT CJobManagerExternal::CreateInstance(IUnknown* pUnkOuter, REFIID iid, void** ppvObject)
{
    BEGIN_EXTERNAL_FUNC

    HRESULT hr = S_OK;

    if (pUnkOuter != NULL)
    {
        hr = CLASS_E_NOAGGREGATION;
    }
    else
    {
        if ((iid == IID_IBackgroundCopyManager) || (iid == IID_IUnknown))
        {
            hr = QueryInterface(iid, ppvObject);
        }
        else
        {
            hr = E_NOTIMPL;
        }
    }

    LogRef( "iid %!guid!, Hr %x, object at %p", &iid, hr, *ppvObject );

    return hr;

    END_EXTERNAL_FUNC
}

HRESULT CJobManagerExternal::LockServer(BOOL fLock)
{
    BEGIN_EXTERNAL_FUNC

    LogRef( "LockServer(%d)", fLock);

    return GlobalLockServer( fLock );

    END_EXTERNAL_FUNC
}

/************************************************************************************
IBackgroundCopyManager Implementation
************************************************************************************/
HRESULT STDMETHODCALLTYPE
CJobManagerExternal::CreateJobInternal (
    /* [in] */ LPCWSTR DisplayName,
    /* [in] */ BG_JOB_TYPE Type,
    /* [out] */ GUID *pJobId,
    /* [out] */ IBackgroundCopyJob **ppJob)
{
    CLockedJobManagerWritePointer LockedJobManager(m_pJobManager );
    LogPublicApiBegin( "DisplayName %S, Type %u", DisplayName, Type );

    HRESULT Hr = S_OK;
    CJob * job = NULL;
    //
    // create the job
    //
    try
        {
        Hr = LockedJobManager.ValidateAccess();
        if (FAILED(Hr))
            throw ComError( Hr );

        //
        // validate parameters
        //
        if (DisplayName == NULL ||
            pJobId      == NULL ||
            ppJob       == NULL)
            {
            throw ComError( E_INVALIDARG );
            }

        *ppJob = NULL;

        GUID Id;

        if (0 !=UuidCreate( &Id ))
            {
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ));
            }

        THROW_HRESULT( LockedJobManager->CreateJob( DisplayName, Type, Id, GetThreadClientSid(), &job ));

        *ppJob = job->GetExternalInterface();
        (*ppJob)->AddRef();

        *pJobId = Id;
        Hr = S_OK;
        }

    catch( ComError exception )
        {
        Hr = exception.Error();
        memset(pJobId, 0, sizeof(*pJobId) );
        }

    LogPublicApiEnd( "pJobId %p(%!guid!), ppJob %p(%p)",
                     pJobId, pJobId, ppJob, *ppJob );
    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobManagerExternal::GetJobInternal(
    /* [in] */ REFGUID jobID,
    /* [out] */ IBackgroundCopyJob **ppJob)
{
    CLockedJobManagerReadPointer LockedJobManager(m_pJobManager);
    LogPublicApiBegin( "jobID %!guid!", &jobID );

    HRESULT Hr = LockedJobManager.ValidateAccess();

    if (SUCCEEDED( Hr ) )
        {
        Hr = BG_E_NOT_FOUND;
        *ppJob = NULL;

        CJob *pJob = NULL;

        Hr = LockedJobManager->GetJob( jobID, &pJob );
        if (SUCCEEDED(Hr))
            {
            *ppJob = pJob->GetExternalInterface();
            (*ppJob)->AddRef();
            Hr = S_OK;
            }
        }

    LogPublicApiEnd( "jobID %!guid!, pJob %p", &jobID, *ppJob );
    return Hr;
}

HRESULT STDMETHODCALLTYPE
CJobManagerExternal::EnumJobsInternal(
    /* [in] */ DWORD dwFlags,
    /* [out] */ IEnumBackgroundCopyJobs **ppEnum)
{
    HRESULT Hr = S_OK;

    CLockedJobManagerReadPointer LockedJobManager(m_pJobManager );
    LogPublicApiBegin( "dwFlags %u, ppEnum %p", dwFlags, ppEnum );

    *ppEnum = NULL;

    CEnumJobs *pEnum = NULL;

    try
        {
        THROW_HRESULT( LockedJobManager.ValidateAccess() );

        if ( dwFlags & ~(BG_JOB_ENUM_ALL_USERS) )
            {
            throw ComError(E_NOTIMPL);
            }

        bool bHideJobs = !( dwFlags & BG_JOB_ENUM_ALL_USERS );

        if (!bHideJobs)
            THROW_HRESULT( DenyNonAdminAccess() );

        SidHandle sid;

        if (bHideJobs)
            {
            sid = GetThreadClientSid();
            }

        pEnum = new CEnumJobs;

        for (CJobList::iterator iter = LockedJobManager->m_OnlineJobs.begin();
             iter != LockedJobManager->m_OnlineJobs.end();
             ++iter)
            {

            if ( bHideJobs )
                {
                if (!iter->IsOwner( sid ))
                    {
                    continue;
                    }
                }

            pEnum->Add( iter->GetExternalInterface() );
            }

        for (CJobList::iterator iter = LockedJobManager->m_OfflineJobs.begin();
             iter != LockedJobManager->m_OfflineJobs.end();
             ++iter)
            {

            if ( bHideJobs )
                {
                if (!iter->IsOwner( sid ))
                    {
                    continue;
                    }
                }

            pEnum->Add( iter->GetExternalInterface() );
            }

        *ppEnum = pEnum;
        }

    catch( ComError exception )
        {
        Hr = exception.Error();
        SafeRelease( pEnum );
        }

    LogPublicApiEnd( "dwFlags %u, ppEnum %p(%p)", dwFlags, ppEnum, *ppEnum );
    return Hr;
}

STDMETHODIMP
CJobManagerExternal::GetErrorDescriptionInternal(
    HRESULT hResult,
    DWORD LanguageId,
    LPWSTR *pErrorDescription
    )
{
    HRESULT Hr = S_OK;
    LogPublicApiBegin( "hResult %!winerr!, LanguageId %u, pErrorDescription %p", hResult, LanguageId, pErrorDescription );
    *pErrorDescription = NULL;

    Hr = DenyRemoteAccess();
    if (SUCCEEDED(Hr))
        {
        Hr = g_Manager->GetErrorDescription( hResult, LanguageId, pErrorDescription );
        }

    LogPublicApiEnd( "hResult %!winerr!, LanguageId %u, pErrorDescription %p(%S)", hResult, LanguageId, pErrorDescription,
                     (*pErrorDescription ? *pErrorDescription : L"NULL") );
    return Hr;
}


STDMETHODIMP
CJobManagerExternal::GetBitsDllPath(
    LPWSTR *pVal
    )
{
    HRESULT Hr = S_OK;

    *pVal = NULL;

    Hr = DenyRemoteAccess();
    if (SUCCEEDED(Hr))
        {
        *pVal = (LPWSTR) CoTaskMemAlloc((1+MAX_PATH)*sizeof(wchar_t));
        if (*pVal == NULL)
            {
            Hr = E_OUTOFMEMORY;
            }
        else
            {
            if (!GetModuleFileName( g_hInstance, *pVal, 1+MAX_PATH))
                {
                Hr = HRESULT_FROM_WIN32( GetLastError() );
                CoTaskMemFree( *pVal );
                }
            }
        }

    LogPublicApiEnd( "hResult %!winerr!, path (%S)", Hr, (*pVal ? *pVal : L"NULL") );
    return Hr;
}

#if !defined( BITS_V12_ON_NT4 )

CDeviceNotificationController::~CDeviceNotificationController()
{
    for( CHandleToNotify::iterator iter = m_HandleToNotify.begin(); iter != m_HandleToNotify.end(); iter++ )
        {
        UnregisterDeviceNotification( iter->second->m_hDeviceNotify );
        delete iter->second;
        }
}

void
CDeviceNotificationController::DeleteNotify(
    CDriveNotify *pNotify
    )
{
    RTL_VERIFY( m_HandleToNotify.erase(  pNotify->m_hDeviceNotify ) );
    RTL_VERIFY( m_CanonicalVolumeToNotify.erase( pNotify->m_CanonicalName ) );
    UnregisterDeviceNotification( pNotify->m_hDeviceNotify );
    ASSERT( NULL != pNotify );
    delete pNotify;
}


DWORD
CDeviceNotificationController::OnDeviceEvent(
    DWORD dwEventType,
    LPVOID lpEventData )
{
    switch( dwEventType )
        {
        case DBT_CUSTOMEVENT:
            {

            PDEV_BROADCAST_HANDLE pdev = (PDEV_BROADCAST_HANDLE)lpEventData;

            LogInfo( "Received DBT_CUSTOMEVENT(%!guid!) event for handle %p",
                     &pdev->dbch_eventguid, pdev->dbch_hdevnotify );

            CHandleToNotify::iterator iter = m_HandleToNotify.find( pdev->dbch_hdevnotify );
            if ( m_HandleToNotify.end() == iter )
                {
                LogWarning("DBT_CUSTOMEVENT(%!guid!) received for unknown notify handle %p",
                           &pdev->dbch_eventguid, pdev->dbch_hdevnotify );
                return NO_ERROR;
                }
            CDriveNotify *pNotify = iter->second;
            ASSERT( pNotify );

            if ( ( GUID_IO_VOLUME_LOCK == pdev->dbch_eventguid ) ||
                 ( GUID_IO_VOLUME_DISMOUNT == pdev->dbch_eventguid ) )
            {
                  LogInfo( "GUID_IO_VOLUME_LOCK or _VOLUME_DISMOUNT received for drive %ls, new lockcount %d",
                           (const WCHAR*)pNotify->m_CanonicalName, pNotify->m_LockCount + 1 );

                  if ( !(pNotify->m_LockCount++) )
                      OnDeviceLock( pNotify->m_CanonicalName );

                  return NO_ERROR;
            }
            else if ( ( GUID_IO_VOLUME_UNLOCK == pdev->dbch_eventguid ) ||
                      ( GUID_IO_VOLUME_LOCK_FAILED == pdev->dbch_eventguid ) ||
                      ( GUID_IO_VOLUME_DISMOUNT_FAILED == pdev->dbch_eventguid ) )
                {

                LogInfo( "GUID_IO_VOLUME_UNLOCK, _LOCK_FAILED or _DISMOUNT_FAILED received for drive %ls",
                         (const WCHAR*)pNotify->m_CanonicalName);

                // UNLOCK, LOCK_FAILED and DISMOUNT_FAILED all mean that the volume is unlocked
                // regardless of the number of previous locks/dismounts.

                pNotify->m_LockCount = 0;
                OnDeviceUnlock( pNotify->m_CanonicalName );

                return NO_ERROR;
                }
            else
                {

                LogWarning("Received unknown DBT_CUSTOMEVENT(%!guid!) event for handle %p",
                           &pdev->dbch_eventguid, pdev->dbch_hdevnotify );
                return NO_ERROR;

                }

            }

        case DBT_DEVICEQUERYREMOVE:
        case DBT_DEVICEQUERYREMOVEFAILED:
        case DBT_DEVICEREMOVEPENDING:
        case DBT_DEVICEREMOVECOMPLETE:
        {
            PDEV_BROADCAST_HANDLE pdev = (PDEV_BROADCAST_HANDLE)lpEventData;
            LogInfo( "Received devicechange event %u received for handle %p", dwEventType, pdev->dbch_hdevnotify );

            CHandleToNotify::iterator iter = m_HandleToNotify.find( pdev->dbch_hdevnotify );
            if ( m_HandleToNotify.end() == iter )
                {
                LogWarning("device change event received for unknown notify handle %p", pdev->dbch_hdevnotify );
                return NO_ERROR;
                }
            CDriveNotify *pNotify = iter->second;
            ASSERT( pNotify );

            switch( dwEventType )
                {

                case DBT_DEVICEQUERYREMOVE:
                    LogInfo( "DBT_DEVICEQUERYREMOVE received for drive %ls, new lockcount %d",
                             (const WCHAR*)pNotify->m_CanonicalName, pNotify->m_LockCount + 1 );
                    if ( !(pNotify->m_LockCount++) )
                        OnDeviceLock( pNotify->m_CanonicalName );

                    return NO_ERROR;

                case DBT_DEVICEQUERYREMOVEFAILED:
                    LogInfo( "DBT_DEVICEQUERYREMOVEFAILED received for drive %ls, new lockcount %d",
                             (const WCHAR*)pNotify->m_CanonicalName, (pNotify->m_LockCount <= 0) ? 0 : (pNotify->m_LockCount - 1) );

                    if ( 1 == pNotify->m_LockCount )
                        OnDeviceUnlock( pNotify->m_CanonicalName );

                    if ( pNotify->m_LockCount <= 1 )
                        pNotify->m_LockCount = 0;
                    return NO_ERROR;

                case DBT_DEVICEREMOVECOMPLETE:
                case DBT_DEVICEREMOVEPENDING:
                    LogInfo( "DBT_DEVICEREMOVECOMPLETE or DBT_DEVICEREMOVEPENDING received for drive %ls, failing jobs",
                             ( const WCHAR*) pNotify->m_CanonicalName );
                    OnDismount( pNotify->m_CanonicalName );
                    DeleteNotify( pNotify );
                    return NO_ERROR;

                default:
                    ASSERT(0);
                    return NO_ERROR;
                }

        }

        default:
            LogInfo( "Unknown device event %u", dwEventType );
            return NO_ERROR;
        }
}

HRESULT
CDeviceNotificationController::IsVolumeLocked(
    const WCHAR *CanonicalVolume
    )
{

    HRESULT Hr = S_OK;
    try
    {
        CCanonicalVolumeToNotify::iterator iter = m_CanonicalVolumeToNotify.find( CanonicalVolume );
        if ( m_CanonicalVolumeToNotify.end() == iter )
            {
            LogInfo( "Canonical volume %ls has not been registered, register now\n", CanonicalVolume );

            //
            // Register for device-lock notification.  If it fails, it is of small consequence:
            // if CHKDSK and BITS try to access a file simultanteously, the job would go into
            // ERROR state instead of TRANSIENT_ERROR state.
            //
            Hr = RegisterNotification( CanonicalVolume );
            if (FAILED(Hr))
                {
                LogWarning("unable to register: 0x%x", Hr);
                }

            Hr = S_OK;
            }
        else
            {
            CDriveNotify *pNotify = iter->second;
            if ( pNotify->m_LockCount )
                throw ComError( BG_E_DESTINATION_LOCKED );
            }
    }
    catch(ComError Error)
    {
        Hr = Error.Error();
    }
    return Hr;
}

HRESULT
CDeviceNotificationController::RegisterNotification(
    const WCHAR *CanonicalVolume
    )
{
    HRESULT Hr = S_OK;
    HANDLE hDriveHandle = INVALID_HANDLE_VALUE;
    HDEVNOTIFY hNotify = NULL;
    CDriveNotify *pNotify = NULL;

    StringHandle wCanonicalVolume;

    try
    {
        wCanonicalVolume = CanonicalVolume;

        CCanonicalVolumeToNotify::iterator iter = m_CanonicalVolumeToNotify.find( wCanonicalVolume );
        if ( m_CanonicalVolumeToNotify.end() != iter )
            {
            LogInfo( "Canonical volume %ls has already been registered, nothing to do.", CanonicalVolume );
            return S_OK;
            }

        // Need to remove the trailing / from the volume name.
        ASSERTMSG( "Canonical name has an unexpected size", wCanonicalVolume.Size() );

        CAutoString TempVolumePath = CAutoString( CopyString( wCanonicalVolume ));

        ASSERT( wCanonicalVolume.Size() > 0 );
        TempVolumePath.get()[ wCanonicalVolume.Size() - 1 ] = L'\0';

        hDriveHandle =
            CreateFile( TempVolumePath.get(),
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL );
        if ( INVALID_HANDLE_VALUE == hDriveHandle )
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );

        DEV_BROADCAST_HANDLE DbtHandle;
        memset( &DbtHandle, 0, sizeof(DbtHandle) );

        DbtHandle.dbch_size = sizeof(DEV_BROADCAST_HANDLE);
        DbtHandle.dbch_devicetype = DBT_DEVTYP_HANDLE;
        DbtHandle.dbch_handle = hDriveHandle;

        hNotify =
            RegisterDeviceNotification( (HANDLE) ghServiceHandle,
                                         &DbtHandle,
                                         DEVICE_NOTIFY_SERVICE_HANDLE );

        if ( !hNotify )
            throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
        CloseHandle( hDriveHandle );
        hDriveHandle = NULL;

        pNotify = new CDriveNotify( hNotify, CanonicalVolume );
        if ( !pNotify )
            throw ComError( E_OUTOFMEMORY );

        RTL_VERIFY( m_CanonicalVolumeToNotify.insert( CCanonicalVolumeToNotify::value_type( wCanonicalVolume, pNotify ) ).second );
        RTL_VERIFY( m_HandleToNotify.insert( CHandleToNotify::value_type( hNotify, pNotify ) ).second );


    }
    catch(ComError Error)
    {
        Hr = Error.Error();
    }
    if ( FAILED(Hr) )
        {

        if ( hNotify )
            UnregisterDeviceNotification( hNotify );
        if ( hDriveHandle != INVALID_HANDLE_VALUE )
            CloseHandle( hDriveHandle );

        if ( pNotify )
            {
            m_CanonicalVolumeToNotify.erase( wCanonicalVolume );
            m_HandleToNotify.erase( hNotify );
            delete pNotify;
            }

        }

    return Hr;

}

#endif

HRESULT
SessionLogonCallback(
    DWORD SessionId
    )
{
    return g_Manager->m_Users.LogonSession( SessionId );
}

HRESULT
SessionLogoffCallback(
    DWORD SessionId
    )
{
    return g_Manager->m_Users.LogoffSession( SessionId );
}

#if !defined( BITS_V12_ON_NT4 )

DWORD
DeviceEventCallback(
    DWORD dwEventType,
    LPVOID lpEventData
    )
{
    return g_Manager->OnDeviceEvent( dwEventType, lpEventData );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\csd.h ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    csd.h

Abstract :

    Header file for SID and SECURITY_DESCRIPTOR abstraction.

Author :

Revision History :

 ***********************************************************************/

#pragma once

#include "qmgrlib.h"

HRESULT
IsGroupSid(
    PSID sid,
    BOOL * pGroup
    );

PSID
CopyTokenSid(
    HANDLE Token
    );

HANDLE CopyThreadToken() throw( ComError );

//------------------------------------------------------------------------

class CSaveThreadToken
/*

    A simple class to save and restore the active thread token.
    This allows code to impersonate other users without having to save
    and restore the old token.

    The constructor throws a ComError if it cannot copy the previous thread token.

*/
{
public:

    CSaveThreadToken() throw( ComError )
    {
        m_SavedToken = CopyThreadToken();
    }

    ~CSaveThreadToken()
    {
        RTL_VERIFY( SetThreadToken( NULL, m_SavedToken ));
        if (m_SavedToken)
            {
            RTL_VERIFY(CloseHandle( m_SavedToken ));
            }
    }

protected:

    HANDLE  m_SavedToken;
};


//------------------------------------------------------------------------

class CNestedImpersonation : protected CSaveThreadToken
/*

    A class to impersonate a user.  It saves the old impersonation token, if any,
    during the constructor and restores it in the destructor.

    Revert() restores the old thread token, unlike RevertToSelf() which
    stops impersonating entirely.

    Most member functions throw a ComError exception if an error occurs.

*/
{
public:

    //
    // Impersonate the COM client, using CoImpersonateClient.
    //
    CNestedImpersonation() throw( ComError );

    //
    // Impersonate a particular token.  The token must remain valid for the object's lifetime.
    //
    CNestedImpersonation( HANDLE token ) throw( ComError );

    //
    // Impersonate a logged-on user by SID.  g_Manager must be initialized for this to work.
    //
    CNestedImpersonation( SidHandle sid ) throw( ComError );

    //
    // This is for use with the COM-client constructor.  COM defaults to IDENTIFY-level
    // impersonation, but some of our code requires IMPERSONATE level.  This function
    // gets the COM client's SID and finds a matching token in our logged-on-users list.
    // This becomes the new impersonation token.
    //
    void SwitchToLogonToken() throw( ComError );

    //
    // the destructor restores the previous impersonation context.
    //
    ~CNestedImpersonation()
    {
        Revert();

        if (m_ImpersonationToken && m_fDeleteToken)
            {
            CloseHandle( m_ImpersonationToken );
            }
    }

    //
    // Impersonates the new token.
    //
    void Impersonate() throw( ComError )
    {
        if (!m_fImpersonated)
            {
            if (!ImpersonateLoggedOnUser( m_ImpersonationToken ))
                throw ComError( HRESULT_FROM_WIN32( GetLastError() ) );
            m_fImpersonated = true;
            }
    }

    //
    // Restores the old impersonation context.
    //
    void Revert()
    {
        if (m_fImpersonated)
            {
            RTL_VERIFY( SetThreadToken( NULL, m_SavedToken ));
            m_fImpersonated = false;
            }
    }

    //
    // Returns a copy of the SID associated with the impersonation token.
    //
    SidHandle CopySid() throw( ComError )
    {
        if (m_Sid.get() == NULL)
            {
            m_Sid = CopyTokenSid( m_ImpersonationToken );
            }

        return m_Sid;
    }

    //
    // Returns the original impersonation token.  Not a copy !
    //
    HANDLE QueryToken()
    {
        return m_ImpersonationToken;
    }

    //
    // Gets the Terminal Services session ID.
    //
    DWORD GetSession() throw( ComError );


protected:

    bool        m_fDeleteToken;
    bool        m_fImpersonated;

    HANDLE      m_ImpersonationToken;

    SidHandle   m_Sid;
};

//------------------------------------------------------------------------

class CJobSecurityDescriptor
{
public:

    CJobSecurityDescriptor( SidHandle sid );

    ~CJobSecurityDescriptor();

    HRESULT Clone( CJobSecurityDescriptor ** );

    inline HRESULT
    AddAce(
        PSID sid,
        BOOL fGroupSid,
        DWORD access
        );

    inline HRESULT
    RemoveAce(
        PSID sid,
        BOOL fGroupSid
        );

    HRESULT
    CheckTokenAccess(
        HANDLE hToken,
        DWORD RequestedAccess,
        DWORD * pAllowedAccess,
        BOOL * pSuccess
        );

    inline SidHandle GetOwnerSid()
    {
        return m_sdOwnerSid;
    }

    HRESULT Serialize( HANDLE hFile );
    static  CJobSecurityDescriptor * Unserialize( HANDLE hFile );

private:

    HRESULT
    CJobSecurityDescriptor::_ModifyAcl(
        PSID sid,
        BOOL fGroupSid,
        DWORD access,
        BOOL  fAdd
        );

    CJobSecurityDescriptor( PSECURITY_DESCRIPTOR pSD,
                            SidHandle owner,
                            SidHandle group,
                            PACL pAcl
                            );

    PSECURITY_DESCRIPTOR m_sd;

    SidHandle   m_sdOwnerSid;
    SidHandle   m_sdGroupSid;
    PACL        m_Dacl;

    static GENERIC_MAPPING s_AccessMapping;
};

HRESULT
CJobSecurityDescriptor::AddAce(
    PSID sid,
    BOOL fGroupSid,
    DWORD access
    )
{
    return _ModifyAcl( sid, fGroupSid, access, TRUE );
}


HRESULT
CJobSecurityDescriptor::RemoveAce(
    PSID sid,
    BOOL fGroupSid
    )
{
    return _ModifyAcl( sid, fGroupSid, 0, FALSE );
}

HRESULT
CheckClientGroupMembership(
    SidHandle group
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\services\drizzle\newjob\csd.cpp ===
/************************************************************************

Copyright (c) 2000 - 2000 Microsoft Corporation

Module Name :

    csd.cpp

Abstract :

    Main code file for SID and SECURITY_DESCRIPTOR abstraction.

Author :

Revision History :

 ***********************************************************************/

#include "stdafx.h"
#include <accctrl.h>
#include <malloc.h>
#include <aclapi.h>

#if !defined(BITS_V12_ON_NT4)
#include "csd.tmh"
#endif

//------------------------------------------------------------------------

CNestedImpersonation::CNestedImpersonation(
    SidHandle sid
    )
    : m_Sid( sid ),
      m_ImpersonationToken( NULL ),
      m_fImpersonated( false ),
      m_fDeleteToken( true )
{
    try
        {
        THROW_HRESULT( g_Manager->CloneUserToken( m_Sid, ANY_SESSION, &m_ImpersonationToken ));

        Impersonate();
        }
    catch( ComError Error )
        {
        Revert();

        if (m_ImpersonationToken && m_fDeleteToken)
            {
            CloseHandle( m_ImpersonationToken );
            }

        throw;
        }
}

CNestedImpersonation::CNestedImpersonation(
    HANDLE token
    )
    : m_ImpersonationToken( token ),
      m_fImpersonated( false ),
      m_fDeleteToken( false )
{
    Impersonate();
}

CNestedImpersonation::CNestedImpersonation()
    : m_ImpersonationToken( NULL ),
      m_fImpersonated( false ),
      m_fDeleteToken( true )
{
    //
    // Failure will cause the base object's destructor to restore the old thread token.
    //

    try
        {
        HRESULT hr = CoImpersonateClient();

        switch (hr)
            {
            case S_OK:
                {
                m_fImpersonated = true;
                m_ImpersonationToken = CopyThreadToken();

#if defined(BITS_V12_ON_NT4)
                RTL_VERIFY( SUCCEEDED( CoRevertToSelf() ) );
                m_fImpersonated = false;
                RTL_VERIFY( SetThreadToken( NULL, m_ImpersonationToken ) );
                m_fImpersonated = true;
#endif
                break;
                }

            case RPC_E_CALL_COMPLETE:
                {
                m_ImpersonationToken = CopyThreadToken();
                if (m_ImpersonationToken)
                    {
                    //
                    // thread was already impersonating someone when it called the BITS routine.
                    //
                    m_fImpersonated = true;
                    }
                else
                    {
                    //
                    // Thread is not impersonating.  Impersonate the process owner.
                    //
                    if (!ImpersonateSelf( SecurityImpersonation ))
                        {
                        throw ComError( HRESULT_FROM_WIN32( GetLastError() ));
                        }

                    m_fImpersonated = true;
                    m_ImpersonationToken = CopyThreadToken();
                    }
                break;
                }

            default:
                throw ComError( hr );
            }
        }
    catch( ComError err )
        {
        if (m_ImpersonationToken)
            {
            CloseHandle( m_ImpersonationToken );
            m_ImpersonationToken = NULL;
            }

        throw;
        }
}

void
CNestedImpersonation::SwitchToLogonToken()
{
    HANDLE token = m_ImpersonationToken;

    SidHandle sid = CopyTokenSid( m_ImpersonationToken );

    THROW_HRESULT( g_Manager->CloneUserToken( sid,
                                              GetSession(),
                                              &m_ImpersonationToken ));

    m_fImpersonated = false;

    if (m_fDeleteToken)
        {
        CloseHandle( token );
        }

    m_fDeleteToken = true;

    Impersonate();
}

DWORD
CNestedImpersonation::GetSession()
{

#if defined(BITS_V12_ON_NT4)
    return 0;
#else
    DWORD session;
    DWORD used;

    if (!GetTokenInformation( m_ImpersonationToken,
                              TokenSessionId,
                              &session,
                              sizeof(DWORD),
                              &used))
        {
        ThrowLastError();
        }

    return sessio