DED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _LAND_H
#define _LAND_H

#include "DeleBase.h"

class CLandBasedVehicle : public CDelegationBase {
public:
    CLandBasedVehicle() { }
    
    virtual ~CLandBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Land-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LANDICON; }
    
private:
    enum { IDM_NEW_LAND = 2 };
    
    // {2974380E-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _LAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\nodes\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
	static TCHAR error[64];

	switch (verb) {
    case MMC_VERB_NONE:
		return _T("NONE");
    case MMC_VERB_OPEN:
		return _T("OPEN");
    case MMC_VERB_COPY:
		return _T("COPY");
    case MMC_VERB_PASTE:
		return _T("PASTE");
    case MMC_VERB_DELETE:
		return _T("DELETE");
    case MMC_VERB_PROPERTIES:
		return _T("PROPERTIES");
    case MMC_VERB_RENAME:
		return _T("RENAME");
    case MMC_VERB_REFRESH:
		return _T("REFRESH");
    case MMC_VERB_PRINT:
		return _T("PRINT");
    case MMC_VERB_CUT:
		return _T("CUT");
	default:
		wsprintf(error, _T("Unknown verb id %d"), verb);
		return error;
	}
}

void MMCN_Crack(BOOL bComponentData, 
                IDataObject *pDataObject,
				IComponentData *pCompData,
				IComponent *pComp,
                MMC_NOTIFY_TYPE event, 
				LPARAM arg, 
				LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
	TCHAR message[256] = {0};

	if (bComponentData == TRUE)
		OutputDebugString(_T("IComponentData::Notify( "));
	else
		OutputDebugString(_T("IComponent::Notify( "));

	wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
	OutputDebugString(message);

    switch (event)	{
		case MMCN_ACTIVATE:
			wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
			break;

		case MMCN_ADD_IMAGES:
			wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_BTN_CLICK:
			wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
			break;

		case MMCN_COLUMN_CLICK:
			wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,	 param);
			break;

		case MMCN_COLUMNS_CHANGED:
			wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
			break;

		case MMCN_CONTEXTHELP:
			wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
			break;

		case MMCN_CONTEXTMENU:
			wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
			break;

		case MMCN_CUTORMOVE:
			wsprintf(message, _T("MMCN_CUTORMOVE\n"));
			break;

		case MMCN_DBLCLICK:
			wsprintf(message, _T("MMCN_DBLCLICK\n"));
			break;

		case MMCN_DELETE:
			wsprintf(message, _T("MMCN_DELETE\n"));
			break;

		case MMCN_DESELECT_ALL:
			wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
			break;

		case MMCN_EXPAND:
			wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_EXPANDSYNC:
			wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
			break;

		case MMCN_FILTERBTN_CLICK:
			wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
			break;

		case MMCN_FILTER_CHANGE:
			wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
			break;

		case MMCN_HELP:
			wsprintf(message, _T("MMCN_HELP\n"));
			break;

		case MMCN_INITOCX:
			wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
			break;

		case MMCN_LISTPAD:
			wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
			break;

		case MMCN_MENU_BTNCLICK:
			wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
			break;

		case MMCN_MINIMIZED:
			wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
			break;

		case MMCN_PASTE:
			wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
			break;

		case MMCN_PRELOAD:
			wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_PRINT:
			wsprintf(message, _T("MMCN_PRINT\n"));
			break;

		case MMCN_PROPERTY_CHANGE:
			wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
			break;

		case MMCN_QUERY_PASTE:
			wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
			break;

		case MMCN_REFRESH:
			wsprintf(message, _T("MMCN_REFRESH\n"));
			break;

		case MMCN_REMOVE_CHILDREN:
			wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_RENAME:
			wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
			break;

		case MMCN_RESTORE_VIEW:
			wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
			break;

		case MMCN_SELECT:
			wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
			break;

		case MMCN_SHOW:
			wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_SNAPINHELP:
			wsprintf(message, _T("MMCN_SNAPINHELP\n"));
			break;

		case MMCN_VIEW_CHANGE:
			wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
			break;
	}

	if (message[0] != 0)
		OutputDebugString(message);
	else
		OutputDebugString(_T("unknown event\n"));

#endif
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\nodes\people.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _PEOPLE_H
#define _PEOPLE_H

#include "DeleBase.h"

class CBicycle : public CDelegationBase {
public:
    CBicycle(int i) : id(i) { }
    virtual ~CBicycle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CBicycleFolder : public CDelegationBase {
public:
    CBicycleFolder();
    virtual ~CBicycleFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Bicycles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CSkateboard : public CDelegationBase {
public:
    CSkateboard(int i) : id(i) { }
    virtual ~CSkateboard() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CSkateboardFolder : public CDelegationBase {
public:
    CSkateboardFolder();
    virtual ~CSkateboardFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Skateboards"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CIceSkate : public CDelegationBase {
public:
    CIceSkate(int i) : id(i) { }
    virtual ~CIceSkate() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CIceSkateFolder : public CDelegationBase {
public:
    CIceSkateFolder();
    virtual ~CIceSkateFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Ice Skates"); }
    virtual void GetChildColumnInfo(RESULTDATAITEM *rdi);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }

	virtual CDelegationBase *GetChildPtr(int index) { 
		return (index < NUMBER_OF_CHILDREN) ? children[index] : NULL;
	}

    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions);
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 5000 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CPeoplePoweredVehicle : public CDelegationBase {
public:
    CPeoplePoweredVehicle();
    virtual ~CPeoplePoweredVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("People-powered Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_PEOPLE = 1 };
    
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 3 };
    CDelegationBase *children[3];
};

#endif // _PEOPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\nodes\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent, IResultOwnerData
{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    
    class CComponentData *m_pComponentData;
    class CDelegationBase *m_pLastNode;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);

        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE FindItem( 
            /* [in] */ LPRESULTFINDINFO pFindInfo,
            /* [out] */ int __RPC_FAR *pnFoundIndex);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CacheHint( 
            /* [in] */ int nStartIndex,
            /* [in] */ int nEndIndex);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SortItems( 
            /* [in] */ int nColumn,
            /* [in] */ DWORD dwSortOptions,
            /* [in] */ LPARAM lUserParam);
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\nodes\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
    
}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
// 
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure 
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure  
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;
    
    CDelegationBase *base = GetBaseNodeObject();
    
    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking
    
    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

		MAKE_WIDEPTR_FROMTSTR(wszName, pszName);
        
		// get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);
        
        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();
        
        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);
        
        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;
        
        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }
    
    pStream->Release();
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
// 
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer 
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}
   
    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    
    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));
    
    if (!stgmedium.hGlobal)	{
        hr = E_OUTOFMEMORY;
    }
    
    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );
    
    // stgmedium now has the data we need 
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }
    
    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);
    
    return pSDO;
    
} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\nodes\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\nodes\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual void GetChildColumnInfo(RESULTDATAITEM *rdi) { }
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;

	virtual CDelegationBase *GetChildPtr(int index) { return NULL; }
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnRename(LPOLESTR pszNewName) { return S_FALSE; }
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    virtual HRESULT OnRefresh() { return S_FALSE; }

public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\nodes\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDB_SMOPEN                      111
#define IDB_SMBMP                       112
#define IDB_LGBMP                       113
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\nodes\sky.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Sky.h"

const GUID CSkyBasedVehicle::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSkyBasedVehicle implementation
//
//
HRESULT CSkyBasedVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
	HRESULT hr;
	IUnknown *pUnk = NULL;
	IMessageView *pMessageView = NULL;

	hr = pConsole->QueryResultView(&pUnk);

	if (SUCCEEDED(hr)) {
		hr = pUnk->QueryInterface(IID_IMessageView, (void **)&pMessageView);

		if (SUCCEEDED(hr)) {
			pMessageView->SetIcon(Icon_Information);
			pMessageView->SetTitleText(L"Sky-based vehicles");
			pMessageView->SetBodyText(L"Sky-based vehicles have no child nodes.");

			pMessageView->Release();
		}

		pUnk->Release();
	}

	return S_FALSE;
}

HRESULT CSkyBasedVehicle::GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions)
{
    // error message control
	LPOLESTR lpOleStr = NULL;
	HRESULT hr = StringFromCLSID(CLSID_MessageView, &lpOleStr);
    *ppViewType = lpOleStr;

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\nodes\sky.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include "DeleBase.h"

class CSkyBasedVehicle : public CDelegationBase {
public:
    CSkyBasedVehicle() { }
    
    virtual ~CSkyBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Sky-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }

public:
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions);

private:
    enum { IDM_NEW_SKY = 3 };
    
    // {2974380F-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\nodes\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { NUMBER_OF_CHILDREN = 5 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};



#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\nodes\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {6BB32802-92E6-11d2-9967-0080C7DCB3DC}
DEFINE_GUID(CLSID_CComponentData, 
            0x6bb32802, 0x92e6, 0x11d2, 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc);

// {73A37F60-92E6-11d2-9967-0080C7DCB3DC}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0x73a37f60, 0x92e6, 0x11d2, 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED

        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);

    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);

    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);

    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);

    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);

    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription(
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];

    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));

    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider(
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion(
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage(
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;

    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;

    *hSmallImageOpen = m_hSmallImageOpen;

    *cMask = RGB(0, 128, 128);

    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
        MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
        *lpDest = wszStr;


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\nodes\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5
#define INDEX_BACKGROUND    6

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout, FALSE);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\nodes\people.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "People.h"

const GUID CPeoplePoweredVehicle::thisGuid = { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

const GUID CBicycleFolder::thisGuid = { 0xef163732, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboardFolder::thisGuid = { 0xef163733, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkateFolder::thisGuid = { 0xf6c660b0, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };

const GUID CBicycle::thisGuid = { 0xef163734, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboard::thisGuid = { 0xef163735, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkate::thisGuid = { 0xf6c660b1, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };


//==============================================================
//
// CPeoplePoweredVehicle implementation
//
//
CPeoplePoweredVehicle::CPeoplePoweredVehicle() 
{ 
    children[0] = new CBicycleFolder;
    children[1] = new CSkateboardFolder;
    children[2] = new CIceSkateFolder;
}

CPeoplePoweredVehicle::~CPeoplePoweredVehicle() 
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        delete children[n];
}

HRESULT CPeoplePoweredVehicle::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |   // relativeID is valid
                SDI_CHILDREN;     // cChildren is valid
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}

CBicycleFolder::CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CBicycle(n + 1);
    }
}

CBicycleFolder::~CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CBicycleFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        // insert items here
        RESULTDATAITEM rdi;
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid
                
                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];
                
                hr = pResultData->InsertItem( &rdi );
                
                _ASSERT( SUCCEEDED(hr) );
            }
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

CIceSkateFolder::CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CIceSkate(n + 1);
    }
}

CIceSkateFolder::~CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CIceSkateFolder::GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) 
{ 
    *ppViewType = NULL;
    *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;
    
    return S_OK; 
}

void CIceSkateFolder::GetChildColumnInfo(RESULTDATAITEM *rdi) 
{ 
    if (rdi->mask & RDI_STR) {
		LPCTSTR pszT = children[rdi->nIndex]->GetDisplayName(rdi->nCol);
		MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
		rdi->str = pszW;
	}

    if (rdi->mask & RDI_IMAGE)
        rdi->nImage = children[rdi->nIndex]->GetBitmapIndex(); 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CIceSkateFolder::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}

HRESULT CIceSkateFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            hr = pResultData->SetItemCount( NUMBER_OF_CHILDREN, 0 );
            _ASSERT( SUCCEEDED(hr) );
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

CSkateboardFolder::CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSkateboard(n + 1);
    }
}

CSkateboardFolder::~CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSkateboardFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                      ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        // insert items here
        RESULTDATAITEM rdi;
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid
                
                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];
                
                hr = pResultData->InsertItem( &rdi );
                
                _ASSERT( SUCCEEDED(hr) );
            }
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

const _TCHAR *CBicycle::GetDisplayName(int nCol) 
{
    _TCHAR buf[128];
    
    wsprintf(buf, _T("Bicycle #%d"), id);
    
    _TCHAR *pszCol = 
        static_cast<_TCHAR *>(CoTaskMemAlloc((_tcslen(buf) + 1) * sizeof(WCHAR)));
    _tcscpy(pszCol, buf);
    
    return pszCol;
}

const _TCHAR *CSkateboard::GetDisplayName(int nCol) 
{
    _TCHAR buf[128];
    
    wsprintf(buf, _T("Skateboard #%d"), id);
    
    _TCHAR *pszCol = 
        static_cast<_TCHAR *>(CoTaskMemAlloc((_tcslen(buf) + 1) * sizeof(WCHAR)));
    _tcscpy(pszCol, buf);
    
    return pszCol;
}

const _TCHAR *CIceSkate::GetDisplayName(int nCol) 
{
    _TCHAR buf[128];
    
    wsprintf(buf, _T("Ice Skate #%d"), id);
    
    _TCHAR *pszCol = 
        static_cast<_TCHAR *>(CoTaskMemAlloc((_tcslen(buf) + 1) * sizeof(WCHAR)));
    _tcscpy(pszCol, buf);
    
    return pszCol;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\nodes\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

#include "Space.h"
#include "Sky.h"
#include "People.h"
#include "Land.h"
#include "Backgrnd.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
    children[0] = new CPeoplePoweredVehicle;
    children[1] = new CLandBasedVehicle;
    children[2] = new CSkyBasedVehicle;
    children[3] = new CSpaceVehicle;
    children[4] = new CBackgroundFolder;
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }

	if (m_pBMapSm != NULL)
		DeleteObject(m_pBMapSm);

	if (m_pBMapLg != NULL)
		DeleteObject(m_pBMapLg);
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |
                SDI_CHILDREN;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = (n == 0); // only the first child has children
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\nodes\space.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SPACE_H
#define _SPACE_H

#include "DeleBase.h"

class CRocket : public CDelegationBase {
public:
    CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload);
    virtual ~CRocket();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnRename(LPOLESTR pszNewName);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
    
private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    int    nId;
    enum ROCKET_STATUS {RUNNING, PAUSED, STOPPED} iStatus;
};

class CSpaceVehicle : public CDelegationBase {
public:
    CSpaceVehicle();
    
    virtual ~CSpaceVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Future Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    enum { IDM_NEW_SPACE = 4 };
    
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CRocket *children[NUMBER_OF_CHILDREN];
};

#endif // _SPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

                MAKE_WIDEPTR_FROMTSTR(wszName, pszName);

                // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\nodes\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule, 
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;
    
    assert(dwResult != 0) ;
    
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    assert(SUCCEEDED(hr)) ;

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
	_tcscat(szKey, pszCLSID) ;
    
    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;
    
    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    
    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

	MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
	_tcscat(szKey, pszT) ;
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);

   
    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);
    
    if (fSupportExtensions) {
        // Build the key NodeType 
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);
        
        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);
    
    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;
    
    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // free the memory
    CoTaskMemFree(wszCLSID);
    
    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }
    
    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }
    
    // Close the child.
    RegCloseKey(hKeyChild) ;
    
    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\nodes\space.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Space.h"
#include "Comp.h"

const GUID CSpaceVehicle::thisGuid = { 0x29743810, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CRocket::thisGuid = { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSpaceVehicle implementation
//
//
CSpaceVehicle::CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CRocket(_T("Rocket"), n+1, 500000, 265, 75000);
    }
}

CSpaceVehicle::~CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;
    
    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    
    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );
        
        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );
        
        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Rocket Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Rocket Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Rocket Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Rocket Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Status", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        
        // insert items here
        RESULTDATAITEM rdi;
        
        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );
        
        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid
                
                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];
                
                hr = pResultData->InsertItem( &rdi );
                
                _ASSERT( SUCCEEDED(hr) );
            }
        }
        
        pHeaderCtrl->Release();
        pResultData->Release();
    }
    
    return hr;
}

//==============================================================
//
// CRocket implementation
//
//
CRocket::CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload) 
: szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED)
{ 
    if (szName) {
        this->szName = new _TCHAR[(_tcslen(szName) + 1) * sizeof(_TCHAR)];
        _tcscpy(this->szName, szName);
    }
    
    this->nId = id;
    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;
}

CRocket::~CRocket() 
{
    if (szName)
        delete [] szName;
}

const _TCHAR *CRocket::GetDisplayName(int nCol) 
{
    _TCHAR buf[128];
    
    switch (nCol) {
    case 0:
        wsprintf(buf, _T("%s (#%d)"), szName ? szName : _T(""), nId);
        break;
        
    case 1:
        wsprintf(buf, _T("%ld metric tons"), lWeight);
        break;
        
    case 2:
        wsprintf(buf, _T("%ld meters"), lHeight);
        break;
        
    case 3:
        wsprintf(buf, _T("%ld kilos"), lPayload);
        break;
        
    case 4:
        wsprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") : 
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;
        
    }
    
    _TCHAR *pszCol = 
        static_cast<_TCHAR *>(CoTaskMemAlloc((_tcslen(buf) + 1) * sizeof(WCHAR)));
    _tcscpy(pszCol, buf);
    
    return pszCol;
}

HRESULT CRocket::OnRename(LPOLESTR pszNewName)
{
    if (szName) {
        delete [] szName;
        szName = NULL;
    }
    
    MAKE_TSTRPTR_FROMWIDE(ptrname, pszNewName);
    szName = new _TCHAR[(_tcslen(ptrname) + 1) * sizeof(_TCHAR)];
    _tcscpy(szName, ptrname);
    
    return S_OK;
}

HRESULT CRocket::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsoleVerb *pConsoleVerb;
    
    HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
    _ASSERT(SUCCEEDED(hr));
    
    hr = pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);
    
    pConsoleVerb->Release();
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent,
IExtendPropertySheet2
{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
            
            //////////////////////////////////
            // Interface IExtendPropertySheet2
            //////////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ LONG_PTR handle,
            /* [in] */ LPDATAOBJECT lpIDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
            /* [in] */ LPDATAOBJECT lpDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
            /* [in] */ LPDATAOBJECT lpIDataObject,
            /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
            /* [out] */ HBITMAP __RPC_FAR *lphHeader,
            /* [out] */ HPALETTE __RPC_FAR *lphPalette,
            /* [out] */ BOOL __RPC_FAR *bStretch);
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL)
{
    OBJECT_CREATED
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IExtendPropertySheet) ||
        IsEqualIID(riid, IID_IExtendPropertySheet2))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
    MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)      {
    case MMCN_SHOW:
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SELECT:
        hr = base->OnSelect(m_ipConsole, (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));
        break;

    case MMCN_RENAME:
        hr = base->OnRename((LPOLESTR)param);
        break;
    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CComponent::CreatePropertyPages(
                                        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                        /* [in] */ LONG_PTR handle,
                                        /* [in] */ LPDATAOBJECT lpIDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->CreatePropertyPages(lpProvider, handle);
}

HRESULT CComponent::QueryPagesFor(
                                  /* [in] */ LPDATAOBJECT lpDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();

    return base->HasPropertySheets();
}

HRESULT CComponent::GetWatermarks(
                                  /* [in] */ LPDATAOBJECT lpIDataObject,
                                  /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                  /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                  /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                  /* [out] */ BOOL __RPC_FAR *bStretch)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->GetWatermarks(lphWatermark, lphHeader, lphPalette, bStretch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_pStaticNode = new CStaticNode;
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IExtendPropertySheet) ||
        IsEqualIID(riid, IID_IExtendPropertySheet2))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);
    //else if (IsEqualIID(riid, IID_IExtendPropertySheet))
    //    *ppv = static_cast<IExtendPropertySheet *>(this);
    else if (IsEqualIID(riid, IID_IPersistStream))
        *ppv = static_cast<IPersistStream *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );

    hr = pImageList->ImageListSetStrip( (long *)m_pStaticNode->m_pBMapSm, // pointer to a handle
        (long *)m_pStaticNode->m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );

    pImageList->Release();

    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
    {
    case MMCN_EXPAND:
        hr = base->OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
        break;
    }

    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName();
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CComponentData::CreatePropertyPages(
                                            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                            /* [in] */ LONG_PTR handle,
                                            /* [in] */ LPDATAOBJECT lpIDataObject)
{
    return m_pStaticNode->CreatePropertyPages(lpProvider, handle);
}

HRESULT CComponentData::QueryPagesFor(
                                      /* [in] */ LPDATAOBJECT lpDataObject)
{
    return m_pStaticNode->HasPropertySheets();
}

HRESULT CComponentData::GetWatermarks(
                                      /* [in] */ LPDATAOBJECT lpIDataObject,
                                      /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                      /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                      /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                      /* [out] */ BOOL __RPC_FAR *bStretch)
{
    return m_pStaticNode->GetWatermarks(lphWatermark, lphHeader, lphPalette, bStretch);
}

///////////////////////////////
// Interface IPersistStream
///////////////////////////////
HRESULT CComponentData::GetClassID(
                                   /* [out] */ CLSID __RPC_FAR *pClassID)
{
    *pClassID = m_pStaticNode->getNodeType();

    return S_OK;
}

HRESULT CComponentData::IsDirty( void)
{
    return m_pStaticNode->isDirty() == true ? S_OK : S_FALSE;
}

HRESULT CComponentData::Load(
                             /* [unique][in] */ IStream __RPC_FAR *pStm)
{
    void *snapInData = m_pStaticNode->getData();
    ULONG dataSize = m_pStaticNode->getDataSize();

    return pStm->Read(snapInData, dataSize, NULL);
}

HRESULT CComponentData::Save(
                             /* [unique][in] */ IStream __RPC_FAR *pStm,
                             /* [in] */ BOOL fClearDirty)
{
    void *snapInData = m_pStaticNode->getData();
    ULONG dataSize = m_pStaticNode->getDataSize();

    if (fClearDirty)
        m_pStaticNode->clearDirty();

    return pStm->Write(snapInData, dataSize, NULL);
}

HRESULT CComponentData::GetSizeMax(
                                   /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize)
{
    return m_pStaticNode->getDataSize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\land.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Land.h"

const GUID CLandBasedVehicle::thisGuid = { 0x2974380e, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CLandBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\land.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _LAND_H
#define _LAND_H

#include "DeleBase.h"

class CLandBasedVehicle : public CDelegationBase {
public:
    CLandBasedVehicle() { }
    
    virtual ~CLandBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Land-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LANDICON; }
    
private:
    enum { IDM_NEW_LAND = 2 };
    
    // {2974380E-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _LAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
        static TCHAR error[64];

        switch (verb) {
    case MMC_VERB_NONE:
                return _T("NONE");
    case MMC_VERB_OPEN:
                return _T("OPEN");
    case MMC_VERB_COPY:
                return _T("COPY");
    case MMC_VERB_PASTE:
                return _T("PASTE");
    case MMC_VERB_DELETE:
                return _T("DELETE");
    case MMC_VERB_PROPERTIES:
                return _T("PROPERTIES");
    case MMC_VERB_RENAME:
                return _T("RENAME");
    case MMC_VERB_REFRESH:
                return _T("REFRESH");
    case MMC_VERB_PRINT:
                return _T("PRINT");
    case MMC_VERB_CUT:
                return _T("CUT");
        default:
                wsprintf(error, _T("Unknown verb id %d"), verb);
                return error;
        }
}

void MMCN_Crack(BOOL bComponentData,
                IDataObject *pDataObject,
                                IComponentData *pCompData,
                                IComponent *pComp,
                MMC_NOTIFY_TYPE event,
                                LPARAM arg,
                                LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
        TCHAR message[256] = {0};

        if (bComponentData == TRUE)
                OutputDebugString(_T("IComponentData::Notify( "));
        else
                OutputDebugString(_T("IComponent::Notify( "));

        wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
        OutputDebugString(message);

    switch (event)      {
                case MMCN_ACTIVATE:
                        wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
                        break;

                case MMCN_ADD_IMAGES:
                        wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_BTN_CLICK:
                        wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
                        break;

                case MMCN_COLUMN_CLICK:
                        wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,       param);
                        break;

                case MMCN_COLUMNS_CHANGED:
                        wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
                        break;

                case MMCN_CONTEXTHELP:
                        wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
                        break;

                case MMCN_CONTEXTMENU:
                        wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
                        break;

                case MMCN_CUTORMOVE:
                        wsprintf(message, _T("MMCN_CUTORMOVE\n"));
                        break;

                case MMCN_DBLCLICK:
                        wsprintf(message, _T("MMCN_DBLCLICK\n"));
                        break;

                case MMCN_DELETE:
                        wsprintf(message, _T("MMCN_DELETE\n"));
                        break;

                case MMCN_DESELECT_ALL:
                        wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
                        break;

                case MMCN_EXPAND:
                        wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_EXPANDSYNC:
                        wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
                        break;

                case MMCN_FILTERBTN_CLICK:
                        wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
                        break;

                case MMCN_FILTER_CHANGE:
                        wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
                        break;

                case MMCN_HELP:
                        wsprintf(message, _T("MMCN_HELP\n"));
                        break;

                case MMCN_INITOCX:
                        wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
                        break;

                case MMCN_LISTPAD:
                        wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
                        break;

                case MMCN_MENU_BTNCLICK:
                        wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
                        break;

                case MMCN_MINIMIZED:
                        wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
                        break;

                case MMCN_PASTE:
                        wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
                        break;

                case MMCN_PRELOAD:
                        wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_PRINT:
                        wsprintf(message, _T("MMCN_PRINT\n"));
                        break;

                case MMCN_PROPERTY_CHANGE:
                        wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
                        break;

                case MMCN_QUERY_PASTE:
                        wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
                        break;

                case MMCN_REFRESH:
                        wsprintf(message, _T("MMCN_REFRESH\n"));
                        break;

                case MMCN_REMOVE_CHILDREN:
                        wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_RENAME:
                        wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
                        break;

                case MMCN_RESTORE_VIEW:
                        wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
                        break;

                case MMCN_SELECT:
                        wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
                        break;

                case MMCN_SHOW:
                        wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_SNAPINHELP:
                        wsprintf(message, _T("MMCN_SNAPINHELP\n"));
                        break;

                case MMCN_VIEW_CHANGE:
                        wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
                        break;
        }

        if (message[0] != 0)
                OutputDebugString(message);
        else
                OutputDebugString(_T("unknown event\n"));

#endif
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData,
IExtendPropertySheet2,  // 2 for wizard 
IPersistStream

{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        //////////////////////////////////
        // Interface IExtendPropertySheet2
        //////////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
        /* [in] */ LONG_PTR handle,
        /* [in] */ LPDATAOBJECT lpIDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
        /* [in] */ LPDATAOBJECT lpDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
        /* [in] */ LPDATAOBJECT lpIDataObject,
        /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
        /* [out] */ HBITMAP __RPC_FAR *lphHeader,
        /* [out] */ HPALETTE __RPC_FAR *lphPalette,
        /* [out] */ BOOL __RPC_FAR *bStretch);
        
        ///////////////////////////////
        // Interface IPersistStream
        ///////////////////////////////
        virtual HRESULT STDMETHODCALLTYPE GetClassID( 
        /* [out] */ CLSID __RPC_FAR *pClassID);
        
        virtual HRESULT STDMETHODCALLTYPE IsDirty( void);
    
    virtual HRESULT STDMETHODCALLTYPE Load( 
        /* [unique][in] */ IStream __RPC_FAR *pStm);
        
        virtual HRESULT STDMETHODCALLTYPE Save( 
        /* [unique][in] */ IStream __RPC_FAR *pStm,
        /* [in] */ BOOL fClearDirty);
        
        virtual HRESULT STDMETHODCALLTYPE GetSizeMax( 
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize);
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\people.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _PEOPLE_H
#define _PEOPLE_H

#include "DeleBase.h"

class CBicycle : public CDelegationBase {
public:
    CBicycle(int i) : id(i) { }
    virtual ~CBicycle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CBicycleFolder : public CDelegationBase {
public:
    CBicycleFolder();
    virtual ~CBicycleFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Bicycles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CSkateboard : public CDelegationBase {
public:
    CSkateboard(int i) : id(i) { }
    virtual ~CSkateboard() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CSkateboardFolder : public CDelegationBase {
public:
    CSkateboardFolder();
    virtual ~CSkateboardFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Skateboards"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CIceSkate : public CDelegationBase {
public:
    CIceSkate(int i) : id(i) { }
    virtual ~CIceSkate() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CIceSkateFolder : public CDelegationBase {
public:
    CIceSkateFolder();
    virtual ~CIceSkateFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Ice Skates"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CPeoplePoweredVehicle : public CDelegationBase {
public:
    CPeoplePoweredVehicle();
    virtual ~CPeoplePoweredVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("People-powered Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_PEOPLE = 1 };
    
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 3 };
    CDelegationBase *children[3];
};

#endif // _PEOPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\sky.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Sky.h"

const GUID CSkyBasedVehicle::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSkyBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\sky.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include "DeleBase.h"

class CSkyBasedVehicle : public CDelegationBase {
public:
    CSkyBasedVehicle() { }
    
    virtual ~CSkyBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Sky-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }
    
private:
    enum { IDM_NEW_SKY = 3 };
    
    // {2974380F-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;


//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE), m_handle(NULL) 
{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
        #define IDM_BUTTON1    0x100
        #define IDM_BUTTON2    0x101

        extern HINSTANCE g_hinst;
        extern ULONG g_uObjects;

        #define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
        #define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

        // uncomment the following #define to enable message cracking
        // #define MMC_CRACK_MESSAGES
        void MMCN_Crack(BOOL bComponentData,
                                        IDataObject *pDataObject,
                                        IComponentData *pCompData,
                                        IComponent *pComp,
                                        MMC_NOTIFY_TYPE event,
                                        LPARAM arg,
                                        LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\people.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "People.h"

const GUID CPeoplePoweredVehicle::thisGuid = { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

const GUID CBicycleFolder::thisGuid = { 0xef163732, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboardFolder::thisGuid = { 0xef163733, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkateFolder::thisGuid = { 0xf6c660b0, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };

const GUID CBicycle::thisGuid = { 0xef163734, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboard::thisGuid = { 0xef163735, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkate::thisGuid = { 0xf6c660b1, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };


//==============================================================
//
// CPeoplePoweredVehicle implementation
//
//
CPeoplePoweredVehicle::CPeoplePoweredVehicle()
{
    children[0] = new CBicycleFolder;
    children[1] = new CSkateboardFolder;
    children[2] = new CIceSkateFolder;
}

CPeoplePoweredVehicle::~CPeoplePoweredVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        delete children[n];
}

HRESULT CPeoplePoweredVehicle::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;

    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |   // relativeID is valid
                SDI_CHILDREN;     // cChildren is valid

            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;

            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );

            children[n]->SetHandle((HANDLE)sdi.ID);

            _ASSERT( SUCCEEDED(hr) );
        }
    }

    return S_OK;
}

CBicycleFolder::CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CBicycle(n + 1);
    }
}

CBicycleFolder::~CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CBicycleFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                children[n]->SetHandle((HANDLE)rdi.itemID);

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CIceSkateFolder::CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CIceSkate(n + 1);
    }
}

CIceSkateFolder::~CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CIceSkateFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                children[n]->SetHandle((HANDLE)rdi.itemID);

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CSkateboardFolder::CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSkateboard(n + 1);
    }
}

CSkateboardFolder::~CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSkateboardFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                      ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                children[n]->SetHandle((HANDLE)rdi.itemID);

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

const _TCHAR *CBicycle::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Bicycle #%d"), id);

    return buf;
}

const _TCHAR *CSkateboard::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Skateboard #%d"), id);

    return buf;
}

const _TCHAR *CIceSkate::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Ice Skate #%d"), id);

    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDB_WATERMARK                   3
#define IDB_HEADER                      4
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDS_PST_ROCKET                  10
#define IDD_PROPPAGE_LARGE              107
#define IDI_ICON1                       108
#define IDB_SMOPEN                      111
#define IDB_SMBMP                       112
#define IDB_LGBMP                       113
#define IDI_PSI_ROCKET                  114
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDC_ROCKET_NAME                 1000
#define IDC_ROCKET_HEIGHT               1001
#define IDC_ROCKET_WEIGHT               1002
#define IDC_ROCKET_PAYLOAD              1003
#define IDC_ROCKET_STATUS               1005
#define IDB_ROCKET                      10004
#define IDB_CAR                         10005
#define IDB_PLANE                       10006
#define IDB_BIKE                        10007
#define IDB_ROCKET2                     10008
#define IDB_CAR2                        10009
#define IDB_PLANE2                      10010
#define IDB_BIKE2                       10011
#define IDB_CLOSED2                     10012
#define IDB_OPEN2                       10013
#define IDB_CLOSED                      10014
#define IDB_OPEN                        10015
#define IDD_CHOOSER_CHOOSE_MACHINE      10016
#define IDC_CHOOSER_STATIC              10017
#define IDC_CHOOSER_GROUP_TARGET_MACHINE 10018
#define IDC_CHOOSER_RADIO_LOCAL_MACHINE 10019
#define IDC_CHOOSER_RADIO_SPECIFIC_MACHINE 10020
#define IDC_CHOOSER_EDIT_MACHINE_NAME   10021
#define IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES 10022
#define IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME 10023
#define IDS_CHOOSER_INVALID_COMPUTERNAME 10024
#define IDS_SELECT_COMPUTER             10025
#define IDS_UNABLE_TO_OPEN_COMPUTER_SELECTOR 10026
#define IDS_COMPUTER_BROWSER_CAPTION    10027
#define ID_FILE_PROPERTYSHEET           10028
#define IDS_PST_LANDBASED               10028
#define ID_FILE_DASH                    10029
#define ID_FILE_EXIT                    10030

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        5
#define _APS_NEXT_COMMAND_VALUE         40031
#define _APS_NEXT_CONTROL_VALUE         40031
#define _APS_NEXT_SYMED_VALUE           40031
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    virtual const HANDLE GetHandle() { return m_handle; }
    virtual SetHandle(HANDLE handle) { m_handle = handle; }
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnRename(LPOLESTR pszNewName) { return S_FALSE; }
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider,
        LONG_PTR handle) { return S_FALSE; }
    virtual HRESULT HasPropertySheets() { return S_FALSE; }
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
        HBITMAP *lphHeader,
        HPALETTE *lphPalette,
        BOOL *bStretch) { return S_FALSE; }
    
public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    HANDLE m_handle;
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    assert(dwResult != 0) ;

    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    assert(SUCCEEDED(hr)) ;

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
        _tcscat(szKey, pszCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

        MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
        _tcscat(szKey, pszT) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,         // Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);


    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);

    if (fSupportExtensions) {
        // Build the key NodeType
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);

        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }

    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);

    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;

    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // free the memory
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\ppgeext\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED

        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);

    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);

    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);

    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);

    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);

    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription(
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];

    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));

    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider(
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion(
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage(
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;

    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;

    *hSmallImageOpen = m_hSmallImageOpen;

    *cMask = RGB(0, 128, 128);

    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
        MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
        *lpDest = wszStr;


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\ppgeext\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {C3F68021-94F3-11d2-9967-0080C7DCB3DC}
DEFINE_GUID(CLSID_CComponentData, 
            0xc3f68021, 0x94f3, 0x11d2, 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc);

// {CC288C90-94F3-11d2-9967-0080C7DCB3DC}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0xcc288c90, 0x94f3, 0x11d2, 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\ppgeext\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {CONTEXTEXTENSION = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\space.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include <windows.h>
#include "Space.h"
#include "Comp.h"
#include "resource.h"

const GUID CSpaceVehicle::thisGuid = { 0x29743810, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CRocket::thisGuid = { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSpaceVehicle implementation
//
//
CSpaceVehicle::CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CRocket(_T("Rocket"), n+1, 500000, 265, 75000);
    }
}

CSpaceVehicle::~CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Rocket Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Rocket Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Rocket Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Rocket Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Status", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                children[n]->SetHandle((HANDLE)rdi.itemID);

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

//==============================================================
//
// CRocket implementation
//
//
CRocket::CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload)
: szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED)
{
    if (szName) {
        this->szName = new _TCHAR[(_tcslen(szName) + 1) * sizeof(_TCHAR)];
        _tcscpy(this->szName, szName);
    }

    this->nId = id;
    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;
}

CRocket::~CRocket()
{
    if (szName)
        delete [] szName;
}

const _TCHAR *CRocket::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    switch (nCol) {
    case 0:
        _stprintf(buf, _T("%s (#%d)"), szName ? szName : _T(""), nId);
        break;

    case 1:
        _stprintf(buf, _T("%ld metric tons"), lWeight);
        break;

    case 2:
        _stprintf(buf, _T("%ld meters"), lHeight);
        break;

    case 3:
        _stprintf(buf, _T("%ld kilos"), lPayload);
        break;

    case 4:
        _stprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") :
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;

    }

    return buf;
}

HRESULT CRocket::OnRename(LPOLESTR pszNewName)
{
    if (szName) {
        delete [] szName;
        szName = NULL;
    }

    MAKE_TSTRPTR_FROMWIDE(ptrname, pszNewName);
    szName = new _TCHAR[(_tcslen(ptrname) + 1) * sizeof(_TCHAR)];
    _tcscpy(szName, ptrname);

    return S_OK;
}

HRESULT CRocket::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsoleVerb *pConsoleVerb;

    HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
    _ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    pConsoleVerb->Release();

    return S_OK;
}

BOOL CALLBACK CRocket::DialogProc(
                                  HWND hwndDlg,  // handle to dialog box
                                  UINT uMsg,     // message
                                  WPARAM wParam, // first message parameter
                                  LPARAM lParam  // second message parameter
                                  )
{
    static CRocket *pRocket = NULL;

    switch (uMsg) {
    case WM_INITDIALOG:
        pRocket = reinterpret_cast<CRocket *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);

        SetDlgItemText(hwndDlg, IDC_ROCKET_NAME, pRocket->szName);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_HEIGHT, pRocket->lHeight, FALSE);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_WEIGHT, pRocket->lWeight, FALSE);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_PAYLOAD, pRocket->lPayload, FALSE);

        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 0, (LPARAM)_T("Running")) );
        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 1, (LPARAM)_T("Paused")) );
        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 2, (LPARAM)_T("Stopped")) );

        SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_SETCURSEL, (WPARAM)pRocket->iStatus, 0);

        break;

    case WM_COMMAND:
        if (HIWORD(wParam) == EN_CHANGE ||
            HIWORD(wParam) == CBN_SELCHANGE)
            SendMessage(GetParent(hwndDlg), PSM_CHANGED, (WPARAM)hwndDlg, 0);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *) lParam)->code) {
        case PSN_APPLY:
            if (pRocket->szName) {
                delete [] pRocket->szName;
                pRocket->szName = NULL;
            }

            {
                int n = SendDlgItemMessage(hwndDlg, IDC_ROCKET_NAME, WM_GETTEXTLENGTH, 0, 0);
                if (n != 0) {
                    pRocket->szName = new _TCHAR[n + 1];
                    GetDlgItemText(hwndDlg, IDC_ROCKET_NAME, pRocket->szName, n + 1);
                }
            }
            pRocket->lHeight = GetDlgItemInt(hwndDlg, IDC_ROCKET_HEIGHT, NULL, FALSE);
            pRocket->lWeight = GetDlgItemInt(hwndDlg, IDC_ROCKET_WEIGHT, NULL, FALSE);
            pRocket->lPayload = GetDlgItemInt(hwndDlg, IDC_ROCKET_PAYLOAD, NULL, FALSE);

            pRocket->iStatus = (ROCKET_STATUS)SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_GETCURSEL, 0, 0);


            return PSNRET_NOERROR;
        }
        break;
    }

    return DefWindowProc(hwndDlg, uMsg, wParam, lParam);
}


HRESULT CRocket::HasPropertySheets()
{
    return S_OK;
}

HRESULT CRocket::CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle)
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEICONID;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_LARGE);
    psp.pfnDlgProc = DialogProc;
    psp.lParam = reinterpret_cast<LPARAM>(this);
    psp.pszTitle = MAKEINTRESOURCE(IDS_PST_ROCKET);
    psp.pszIcon = MAKEINTRESOURCE(IDI_PSI_ROCKET);

    hPage = CreatePropertySheetPage(&psp);
    _ASSERT(hPage);

    return lpProvider->AddPage(hPage);
}

HRESULT CRocket::GetWatermarks(HBITMAP *lphWatermark,
                               HBITMAP *lphHeader,
                               HPALETTE *lphPalette,
                               BOOL *bStretch)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\ppgeext\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#define INDEX_SUN 6
#define INDEX_SNOW 7
#define INDEX_RAIN 8
#define INDEX_CLOUD 9
#define INDEX_WORLD 10
#define INDEX_THUNDER 11


#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\space.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SPACE_H
#define _SPACE_H

#include "DeleBase.h"

class CRocket : public CDelegationBase {
public:
    CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload);
    virtual ~CRocket();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnRename(LPOLESTR pszNewName);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
    
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle);
    virtual HRESULT HasPropertySheets();
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
        HBITMAP *lphHeader,
        HPALETTE *lphPalette,
        BOOL *bStretch);
    
private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    int    nId;
    enum ROCKET_STATUS {RUNNING, PAUSED, STOPPED} iStatus;
    
    static BOOL CALLBACK CRocket::DialogProc(
        HWND hwndDlg,  // handle to dialog box
        UINT uMsg,     // message
        WPARAM wParam, // first message parameter
        LPARAM lParam  // second message parameter
        );
    
};

class CSpaceVehicle : public CDelegationBase {
public:
    CSpaceVehicle();
    
    virtual ~CSpaceVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Future Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    enum { IDM_NEW_SPACE = 4 };
    
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CRocket *children[NUMBER_OF_CHILDREN];
};

#endif // _SPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <Shlwapi.h>
#include <Shlobj.H>

#include "StatNode.h"

#include "Space.h"
#include "Sky.h"
#include "People.h"
#include "Land.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
    children[0] = new CPeoplePoweredVehicle;
    children[1] = new CLandBasedVehicle;
    children[2] = new CSkyBasedVehicle;
    children[3] = new CSpaceVehicle;
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (GetHandle() == NULL) {
        SetHandle((HANDLE)parent);
    }
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT	  |
                SDI_CHILDREN;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = (n == 0); // only the first child has children
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            children[n]->SetHandle((HANDLE)sdi.ID);
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}

HRESULT CStaticNode::CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle)
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;
    
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_CHOOSER_CHOOSE_MACHINE);
    psp.pfnDlgProc = DialogProc;
    psp.lParam = reinterpret_cast<LPARAM>(&snapInData);
    psp.pszTitle = MAKEINTRESOURCE(IDS_SELECT_COMPUTER);
    
    hPage = CreatePropertySheetPage(&psp);
    _ASSERT(hPage);
    
    return lpProvider->AddPage(hPage);
}

HRESULT CStaticNode::HasPropertySheets()
{
    return S_OK;
}

HRESULT CStaticNode::GetWatermarks(HBITMAP *lphWatermark,
                                   HBITMAP *lphHeader,
                                   HPALETTE *lphPalette,
                                   BOOL *bStretch)
{
    *lphHeader = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_HEADER), IMAGE_BITMAP, 0, 0, 0);
    *lphWatermark = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_WATERMARK), IMAGE_BITMAP, 0, 0, 0);
    *bStretch = FALSE;
    
    return S_OK;
}

BOOL CALLBACK CStaticNode::DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static privateData *pData = NULL;
    static HWND m_hwndCheckboxOverride;
    
    switch (uMsg)
    {
    case WM_INITDIALOG:
        pData = reinterpret_cast<privateData *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);
        
        SendDlgItemMessage(hwndDlg, IDC_CHOOSER_RADIO_LOCAL_MACHINE, BM_SETCHECK, pData->m_fIsRadioLocalMachine, 0L);
        SendDlgItemMessage(hwndDlg, IDC_CHOOSER_RADIO_SPECIFIC_MACHINE, BM_SETCHECK, !pData->m_fIsRadioLocalMachine, 0L);
        
        EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSER_EDIT_MACHINE_NAME), !pData->m_fIsRadioLocalMachine);
        EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES), !pData->m_fIsRadioLocalMachine);
        
        m_hwndCheckboxOverride = ::GetDlgItem(hwndDlg, IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME);
        
        // fill in the supplied machine name (could be us, need to check here first)
        if (*pData->m_host != '\0') 
        {
            ::SetWindowText(GetDlgItem(hwndDlg, IDC_CHOOSER_EDIT_MACHINE_NAME), pData->m_host);
            ::SendMessage(GetDlgItem(hwndDlg, IDC_CHOOSER_RADIO_SPECIFIC_MACHINE), BM_CLICK, 0, 0);
        }
        
        
        return TRUE;
        
    case WM_COMMAND:
        switch (wParam) 
        {
        case IDC_CHOOSER_RADIO_LOCAL_MACHINE:
            pData->m_fIsRadioLocalMachine = TRUE;
            EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSER_EDIT_MACHINE_NAME), FALSE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES), FALSE);
            break;
            
        case IDC_CHOOSER_RADIO_SPECIFIC_MACHINE:
            pData->m_fIsRadioLocalMachine = FALSE;
            EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSER_EDIT_MACHINE_NAME), TRUE);
            EnableWindow(GetDlgItem(hwndDlg, IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES), TRUE);
            break;
            
        case IDC_CHOOSER_BUTTON_BROWSE_MACHINENAMES:
            {
                // Fall back to IE-style browser
                BROWSEINFO bi;
                LPITEMIDLIST lpItemIdList;
                LPMALLOC lpMalloc;
                
                if (SUCCEEDED(SHGetSpecialFolderLocation(hwndDlg, CSIDL_NETWORK, &lpItemIdList)))
                {
                    _TCHAR szBrowserCaption[MAX_PATH];
                    LoadString(g_hinst, IDS_COMPUTER_BROWSER_CAPTION, szBrowserCaption, sizeof(szBrowserCaption));
                    
                    bi.hwndOwner = hwndDlg; 
                    bi.pidlRoot = lpItemIdList; 
                    bi.pszDisplayName = pData->m_host; 
                    bi.lpszTitle = szBrowserCaption; 
                    bi.ulFlags = BIF_BROWSEFORCOMPUTER | BIF_EDITBOX; 
                    bi.lpfn = NULL; 
                    bi.lParam = NULL; 
                    bi.iImage = NULL; 
                    
                    if (SHBrowseForFolder(&bi) != NULL) 
                    {
                        if (*pData->m_host != '\0') 
                        {
                            ::SetWindowText(GetDlgItem(hwndDlg, 
                                IDC_CHOOSER_EDIT_MACHINE_NAME), pData->m_host);
                        }
                    }
                    
                    if (SUCCEEDED(SHGetMalloc(&lpMalloc))) 
                    {
                        lpMalloc->Free(lpItemIdList);
                        lpMalloc->Release();
                    }
                }
            }
            break;
            
        case IDC_CHOOSER_CHECK_OVERRIDE_MACHINE_NAME:
            break;
        }
        break;
        
        case WM_NOTIFY:
            switch (((LPNMHDR)lParam)->code) {
            case PSN_SETACTIVE: 
                PropSheet_SetWizButtons(GetParent(hwndDlg), PSWIZB_FINISH);
                break;
                
            case PSN_WIZFINISH: 
                if (pData->m_fIsRadioLocalMachine) {
                    // Return empty string to caller
                    *pData->m_host = '\0';
                } else {
                    // Get the machine name from the edit window
                    GetWindowText(GetDlgItem(hwndDlg, IDC_CHOOSER_EDIT_MACHINE_NAME), 
                        pData->m_host, sizeof(pData->m_host));
                }
                
                // Save the override flag if the caller asked for it
                pData->m_fAllowOverrideMachineNameOut = 
                    SendMessage(m_hwndCheckboxOverride, BM_GETCHECK, 0, 0) == BST_CHECKED ? TRUE : FALSE;
                
                break;
            }
            
            break;
    }
    
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\openserv\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256] = {0};
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        
        if (*snapInData.m_host != 0) {
            _tcscat(szDisplayName, _T(" ("));
            _tcscat(szDisplayName, snapInData.m_host);
            _tcscat(szDisplayName, _T(")"));
        }
        
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle);
    virtual HRESULT HasPropertySheets();
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
        HBITMAP *lphHeader,
        HPALETTE *lphPalette,
        BOOL *bStretch);
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    struct privateData {
        _TCHAR m_host[MAX_PATH];
        BOOL m_fIsRadioLocalMachine;
        BOOL m_fAllowOverrideMachineNameOut;
        bool m_isDirty;
        
        privateData() : m_isDirty(false) {
            ZeroMemory(m_host, sizeof(m_host));
            m_fIsRadioLocalMachine = TRUE;
            m_fAllowOverrideMachineNameOut = FALSE;
        }
    } snapInData;
    
    static BOOL CALLBACK DialogProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    public:
        LONG getDataSize() { return sizeof(privateData); }
        void *getData() { return &snapInData; }
        bool isDirty() { return snapInData.m_isDirty; }
        void clearDirty() { snapInData.m_isDirty = false; };
        
        _TCHAR *getHost() { return *snapInData.m_host == 0 ? NULL : snapInData.m_host; }
};



#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\ppgeext\extend.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _EXTEND_H
#define _EXTEND_H

struct EXTENSION_NODE
{
    GUID	GUID;
    _TCHAR	szDescription[256];
};

enum EXTENSION_TYPE
{
    NameSpaceExtension,
        ContextMenuExtension, 
        ToolBarExtension,
        PropertySheetExtension,
        TaskExtension,
        DynamicExtension,
        DummyExtension
};

struct EXTENDER_NODE
{
    EXTENSION_TYPE	eType;
    GUID			guidNode;
    GUID			guidExtension;
    _TCHAR			szDescription[256];
};

#endif // _EXTEND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\ppgeext\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout);		// Class Id for About Class


HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED

        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);

    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);

    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);

    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);

    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);

    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription(
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];

    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));

    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider(
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion(
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage(
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;

    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;

    *hSmallImageOpen = m_hSmallImageOpen;

    *cMask = RGB(0, 128, 128);

    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
        MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
        *lpDest = wszStr;


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\ppgeext\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "globals.h"
#include "resource.h"
#include "guids.h"
#include "basesnap.h"
#include "PPgeExt.h"
#include "About.h"
#include "Registry.h"
#include "Extend.h"

// our globals
HINSTANCE g_hinst;


BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CPropSheetExtension) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CPropSheetExtension)
        pFactory = new CClassFactory(CClassFactory::CONTEXTEXTENSION);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (CONTEXTEXTENSION == m_factoryType) {
        pObj = new CPropSheetExtension();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CPropSheetExtension, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CPropSheetExtension, szSnapInName, CLSID_CSnapinAbout);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CPropSheetExtension) == S_OK)
        return UnregisterSnapin(CLSID_CPropSheetExtension);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout, FALSE);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\ppgeext\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
        #define IDM_BUTTON1    0x100
        #define IDM_BUTTON2    0x101

        extern HINSTANCE g_hinst;
        extern ULONG g_uObjects;

        #define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
        #define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\ppgeext\ppgeext.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "PPgeExt.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CPropSheetExtension::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CPropSheetExtension::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CPropSheetExtension::s_cfSnapInCLSID = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);

CPropSheetExtension::CPropSheetExtension() : m_cref(0)
{
    OBJECT_CREATED
}

CPropSheetExtension::~CPropSheetExtension()
{
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CPropSheetExtension::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IExtendPropertySheet *>(this);
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
        *ppv = static_cast<IExtendPropertySheet *>(this);
    
    if (*ppv) 
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CPropSheetExtension::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CPropSheetExtension::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    
    return m_cref;
}

BOOL CALLBACK CPropSheetExtension::DialogProc(
                                              HWND hwndDlg,  // handle to dialog box
                                              UINT uMsg,     // message
                                              WPARAM wParam, // first message parameter
                                              LPARAM lParam  // second message parameter
                                              )
{
    static CPropSheetExtension *pThis = NULL;
    
    switch (uMsg) {
    case WM_INITDIALOG:
        pThis = reinterpret_cast<CPropSheetExtension *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);
        
        break;
        
    case WM_COMMAND:
        if (HIWORD(wParam) == EN_CHANGE ||
            HIWORD(wParam) == CBN_SELCHANGE)
            SendMessage(GetParent(hwndDlg), PSM_CHANGED, (WPARAM)hwndDlg, 0);
        break;
        
    case WM_DESTROY:
        // we don't free the notify handle for property sheets
        // MMCFreeNotifyHandle(pThis->m_ppHandle);
        break;
        
    case WM_NOTIFY:
        switch (((NMHDR *) lParam)->code) {
        case PSN_APPLY:
            // don't notify the primary snap-in that Apply
            // has been hit...
            // MMCPropertyChangeNotify(pThis->m_ppHandle, (long)pThis);
            return PSNRET_NOERROR;
        }
        break;
    }
    
    return DefWindowProc(hwndDlg, uMsg, wParam, lParam);
}

///////////////////////////////
// Interface IExtendPropertySheet
///////////////////////////////
HRESULT CPropSheetExtension::CreatePropertyPages( 
                                                 /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                                 /* [in] */ LONG_PTR handle,
                                                 /* [in] */ LPDATAOBJECT lpIDataObject)
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;
    
    // we don't cache this handle like in a primary snap-in
    // the handle value here is always 0
    // m_ppHandle = handle;
    
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEICONID;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_LARGE);
    psp.pfnDlgProc = DialogProc;
    psp.lParam = reinterpret_cast<LPARAM>(this);
    psp.pszTitle = MAKEINTRESOURCE(IDS_PST_ROCKET_EXT);
    psp.pszIcon = MAKEINTRESOURCE(IDI_PSI_ROCKET);
    
    hPage = CreatePropertySheetPage(&psp);
    _ASSERT(hPage);
    
    HRESULT hr = lpProvider->AddPage(hPage);
    return hr;
}

HRESULT CPropSheetExtension::QueryPagesFor( 
                                           /* [in] */ LPDATAOBJECT lpDataObject)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\ppgeext\ppgeext.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _CPropSheetExtension_H_
#define _CPropSheetExtension_H_

#include <tchar.h>
#include <mmc.h>

class CPropSheetExtension : public IExtendPropertySheet
{
    
private:
    ULONG				m_cref;
    
    // clipboard format
    static UINT s_cfDisplayName;
    static UINT s_cfSnapInCLSID;
    static UINT s_cfNodeType;
    
public:
    CPropSheetExtension();
    ~CPropSheetExtension();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IExtendPropertySheet
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
        /* [in] */ LONG_PTR handle,
        /* [in] */ LPDATAOBJECT lpIDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
        /* [in] */ LPDATAOBJECT lpDataObject);
        
private:
    LONG_PTR m_ppHandle;
    
    static BOOL CALLBACK DialogProc(HWND hwndDlg,  // handle to dialog box
        UINT uMsg,     // message
        WPARAM wParam, // first message parameter
        LPARAM lParam  // second message parameter
        );
    
    
    ///////////////////////////////
    // Private IDataObject support bits
    ///////////////////////////////
    HRESULT ExtractData( IDataObject* piDataObject,
        CLIPFORMAT   cfClipFormat,
        BYTE*        pbData,
        DWORD        cbData )
    {
        HRESULT hr = S_OK;
        
        FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
        
        stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);
        do // false loop
        {
            if (NULL == stgmedium.hGlobal)
            {
                hr = E_OUTOFMEMORY;
                break;
            }
            hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
            if ( FAILED(hr) )
            {
                break;
            }
            
            BYTE* pbNewData = reinterpret_cast<BYTE*>(stgmedium.hGlobal);
            if (NULL == pbNewData)
            {
                hr = E_UNEXPECTED;
                break;
            }
            ::memcpy( pbData, pbNewData, cbData );
        } while (FALSE); // false loop
        
        if (NULL != stgmedium.hGlobal)
        {
            ::GlobalFree(stgmedium.hGlobal);
        }
        return hr;
    } // ExtractData()
    
    HRESULT ExtractString( IDataObject *piDataObject,
        CLIPFORMAT   cfClipFormat,
        _TCHAR       *pstr,
        DWORD        cchMaxLength)
    {
        return ExtractData( piDataObject, cfClipFormat, (PBYTE)pstr, cchMaxLength );
    }
    
    HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin )
    {
        return ExtractData( piDataObject, s_cfSnapInCLSID, (PBYTE)pclsidSnapin, sizeof(CLSID) );
    }
    
    HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType )
    {
        return ExtractData( piDataObject, s_cfNodeType, (PBYTE)pguidObjectType, sizeof(GUID) );
    }
};

#endif _CPropSheetExtension_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent,
IExtendPropertySheet2
{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
            
            //////////////////////////////////
            // Interface IExtendPropertySheet2
            //////////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ LONG_PTR handle,
            /* [in] */ LPDATAOBJECT lpIDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
            /* [in] */ LPDATAOBJECT lpDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
            /* [in] */ LPDATAOBJECT lpIDataObject,
            /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
            /* [out] */ HBITMAP __RPC_FAR *lphHeader,
            /* [out] */ HPALETTE __RPC_FAR *lphPalette,
            /* [out] */ BOOL __RPC_FAR *bStretch);
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\ppgeext\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {CFCDC9F3-C50E-11d2-952B-00C04FB92EC2}
DEFINE_GUID(CLSID_CPropSheetExtension, 
            0xcfcdc9f3, 0xc50e, 0x11d2, 0x95, 0x2b, 0x0, 0xc0, 0x4f, 0xb9, 0x2e, 0xc2);
// {CFCDC9F7-C50E-11d2-952B-00C04FB92EC2}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0xcfcdc9f7, 0xc50e, 0x11d2, 0x95, 0x2b, 0x0, 0xc0, 0x4f, 0xb9, 0x2e, 0xc2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\ppgeext\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>
#include "Registry.h"
#include "Extend.h"
#include "GUIDs.h"
#include "globals.h"

// if not standalone comment out next line
//#define STANDALONE

// list all nodes that are extendable here
// List the GUID and then the description
// terminate with a NULL, NULL set.
EXTENSION_NODE _ExtendableNodes[] = {
    {NULL, NULL}
};

// list all of the nodes that we extend
EXTENDER_NODE _NodeExtensions[] = {
    {PropertySheetExtension,
    {0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28}},
    {0xcfcdc9f3, 0xc50e, 0x11d2, {0x95, 0x2b, 0x0, 0xc0, 0x4f, 0xb9, 0x2e, 0xc2}},
    _T("Extension to the Rocket Node")},

    {DummyExtension,
    NULL,
    NULL,
    NULL}
};

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

BOOL setSnapInExtensionNode(const _TCHAR* szSnapID,
                            const _TCHAR* szNodeID,
                            const _TCHAR* szDescription);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    assert(dwResult != 0) ;

    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    assert(SUCCEEDED(hr)) ;

    MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
        _tcscat(szKey, pszCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

    MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
    _tcscat(szKey, pszT) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout)         // Class Id for About Class

{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    LPOLESTR wszExtendCLSID = NULL;
    LPOLESTR wszNodeCLSID = NULL;
    EXTENSION_NODE *pExtensionNode;
    EXTENDER_NODE *pNodeExtension;
    _TCHAR szKeyBuf[1024] ;
    HKEY hKey;

    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

    MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
    MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);


    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;

#ifdef STANDALONE
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
#endif

    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);

    // register each of the node types in _ExtendableNodes as an extendable node
    for (pExtensionNode = &(_ExtendableNodes[0]);*pExtensionNode->szDescription;pExtensionNode++)
    {
        hr = StringFromCLSID(pExtensionNode->GUID, &wszExtendCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszExtendCLSID, wszExtendCLSID);
        setSnapInExtensionNode(pszCLSID, pszExtendCLSID, pExtensionNode->szDescription);
        CoTaskMemFree(wszExtendCLSID);
    }

    // register each of the node extensions
    for (pNodeExtension = &(_NodeExtensions[0]);*pNodeExtension->szDescription;pNodeExtension++)
    {
        hr = StringFromCLSID(pNodeExtension->guidNode, &wszExtendCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszExtendCLSID, wszExtendCLSID);
        _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes\\"));
        _tcscat(szKeyBuf, pszExtendCLSID);

        switch (pNodeExtension->eType) {
        case NameSpaceExtension:
            _tcscat(szKeyBuf, _T("\\Extensions\\NameSpace"));
            break;
        case ContextMenuExtension:
            _tcscat(szKeyBuf, _T("\\Extensions\\ContextMenu"));
            break;
        case ToolBarExtension:
            _tcscat(szKeyBuf, _T("\\Extensions\\ToolBar"));
            break;
        case PropertySheetExtension:
            _tcscat(szKeyBuf, _T("\\Extensions\\PropertySheet"));
            break;
        case TaskExtension:
            _tcscat(szKeyBuf, _T("\\Extensions\\Task"));
            break;
        case DynamicExtension:
            _tcscat(szKeyBuf, _T("\\Dynamic Extensions"));
        default:
            break;
        }

        // Create and open key and subkey.
        long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
            szKeyBuf,
            0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, NULL,
            &hKey, NULL) ;

        if (lResult != ERROR_SUCCESS)
        {
            return FALSE ;
        }

        hr = StringFromCLSID(pNodeExtension->guidExtension, &wszNodeCLSID);
        assert(SUCCEEDED(hr));

        MAKE_TSTRPTR_FROMWIDE(pszNodeCLSID, wszNodeCLSID);
        // Set the Value.
        if (pNodeExtension->szDescription != NULL)
        {
            RegSetValueEx(hKey, pszNodeCLSID, 0, REG_SZ,
                (BYTE *)pNodeExtension->szDescription,
                (_tcslen(pNodeExtension->szDescription)+1)*sizeof(_TCHAR)) ;
        }

        RegCloseKey(hKey) ;

        CoTaskMemFree(wszExtendCLSID);
        CoTaskMemFree(wszNodeCLSID);
    }


    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);

    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;

    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

	//Uncomment following for loop to unregister all extendable node types
	//Note that if a snap-in's extendable node types are unregistered,
	//any extension snap-ins for these node types will have to be re-registered
	//in order to rebuild their entries under the SOFTWARE\Microsoft\MMC\NodeTypes key

/*
    // Unregister each of the node types in _ExtendableNodes as an extendable node
	// Note that this snap-in does not register any extendable node types

    EXTENSION_NODE *pNode;
	LPOLESTR wszExtendCLSID = NULL;

    for (pNode = &(_ExtendableNodes[0]);*pNode->szDescription;pNode++)
    {
        hr = StringFromCLSID(pNode->GUID, &wszExtendCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszExtendCLSID, wszExtendCLSID);

        // Load the buffer with the Snap-In Location
        _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes\\"));
        // Copy keyname into buffer.
        _tcscat(szKeyBuf, pszExtendCLSID);
        recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
        CoTaskMemFree(wszExtendCLSID);
    }

*/

    // free the memory
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

BOOL setSnapInExtensionNode(const _TCHAR* szSnapID,
                            const _TCHAR* szNodeID,
                            const _TCHAR* szDescription)
{
    HKEY hKey;
    _TCHAR szSnapNodeKeyBuf[1024] ;
    _TCHAR szMMCNodeKeyBuf[1024];

    // Load the buffer with the Snap-In Location
    _tcscpy(szSnapNodeKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns\\"));
    // add in the clisid into buffer.
    _tcscat(szSnapNodeKeyBuf, szSnapID) ;
    _tcscat(szSnapNodeKeyBuf, _T("\\NodeTypes\\"));
    _tcscat(szSnapNodeKeyBuf, szNodeID) ;

    // Load the buffer with the NodeTypes Location
    _tcscpy(szMMCNodeKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes\\"));
    _tcscat(szMMCNodeKeyBuf, szNodeID) ;

    // Create and open the Snapin Key.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szSnapNodeKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szDescription != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szDescription,
            (_tcslen(szDescription)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;

    // Create and open the NodeTypes Key.
    lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szMMCNodeKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szDescription != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szDescription,
            (_tcslen(szDescription)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;

    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

                MAKE_WIDEPTR_FROMTSTR(wszName, pszName);

                // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\ppgeext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDD_PROPPAGE_LARGE              10
#define IDS_PST_ROCKET_EXT              10
#define IDI_ICON1                       108
#define IDI_PSI_ROCKET                  114
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_SMOPEN                      124
#define IDB_SMBMP                       125
#define IDB_LGBMP                       126
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015
#define ID_BUTTON40016                  40016
#define ID_BUTTON40017                  40017
#define ID_BUTTON40018                  40018
#define ID_BUTTON40019                  40019
#define ID_BUTTON40020                  40020
#define ID_BUTTON40021                  40021
#define ID_BUTTON40022                  40022
#define ID_BUTTON40023                  40023
#define ID_BUTTON40024                  40024
#define ID_BUTTON40025                  40025
#define ID_BUTTON40026                  40026
#define EDIT1                           40027
#define EDIT2                           40028
#define EDIT3                           40029
#define EDIT4                           40030
#define COMBO1                          40031

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        127
#define _APS_NEXT_COMMAND_VALUE         40032
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;


//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE) 
{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
        #define IDM_BUTTON1    0x100
        #define IDM_BUTTON2    0x101

        extern HINSTANCE g_hinst;
        extern ULONG g_uObjects;

        #define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
        #define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

        // uncomment the following #define to enable message cracking
        // #define MMC_CRACK_MESSAGES
        void MMCN_Crack(BOOL bComponentData,
                                        IDataObject *pDataObject,
                                        IComponentData *pCompData,
                                        IComponent *pComp,
                                        MMC_NOTIFY_TYPE event,
                                        LPARAM arg,
                                        LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\land.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Land.h"

const GUID CLandBasedVehicle::thisGuid = { 0x2974380e, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CLandBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\land.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _LAND_H
#define _LAND_H

#include "DeleBase.h"

class CLandBasedVehicle : public CDelegationBase {
public:
    CLandBasedVehicle() { }
    
    virtual ~CLandBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Land-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LANDICON; }
    
private:
    enum { IDM_NEW_LAND = 2 };
    
    // {2974380E-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _LAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
        static TCHAR error[64];

        switch (verb) {
    case MMC_VERB_NONE:
                return _T("NONE");
    case MMC_VERB_OPEN:
                return _T("OPEN");
    case MMC_VERB_COPY:
                return _T("COPY");
    case MMC_VERB_PASTE:
                return _T("PASTE");
    case MMC_VERB_DELETE:
                return _T("DELETE");
    case MMC_VERB_PROPERTIES:
                return _T("PROPERTIES");
    case MMC_VERB_RENAME:
                return _T("RENAME");
    case MMC_VERB_REFRESH:
                return _T("REFRESH");
    case MMC_VERB_PRINT:
                return _T("PRINT");
    case MMC_VERB_CUT:
                return _T("CUT");
        default:
                wsprintf(error, _T("Unknown verb id %d"), verb);
                return error;
        }
}

void MMCN_Crack(BOOL bComponentData,
                IDataObject *pDataObject,
                                IComponentData *pCompData,
                                IComponent *pComp,
                MMC_NOTIFY_TYPE event,
                                LPARAM arg,
                                LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
        TCHAR message[256] = {0};

        if (bComponentData == TRUE)
                OutputDebugString(_T("IComponentData::Notify( "));
        else
                OutputDebugString(_T("IComponent::Notify( "));

        wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
        OutputDebugString(message);

    switch (event)      {
                case MMCN_ACTIVATE:
                        wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
                        break;

                case MMCN_ADD_IMAGES:
                        wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_BTN_CLICK:
                        wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
                        break;

                case MMCN_COLUMN_CLICK:
                        wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,       param);
                        break;

                case MMCN_COLUMNS_CHANGED:
                        wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
                        break;

                case MMCN_CONTEXTHELP:
                        wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
                        break;

                case MMCN_CONTEXTMENU:
                        wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
                        break;

                case MMCN_CUTORMOVE:
                        wsprintf(message, _T("MMCN_CUTORMOVE\n"));
                        break;

                case MMCN_DBLCLICK:
                        wsprintf(message, _T("MMCN_DBLCLICK\n"));
                        break;

                case MMCN_DELETE:
                        wsprintf(message, _T("MMCN_DELETE\n"));
                        break;

                case MMCN_DESELECT_ALL:
                        wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
                        break;

                case MMCN_EXPAND:
                        wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_EXPANDSYNC:
                        wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
                        break;

                case MMCN_FILTERBTN_CLICK:
                        wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
                        break;

                case MMCN_FILTER_CHANGE:
                        wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
                        break;

                case MMCN_HELP:
                        wsprintf(message, _T("MMCN_HELP\n"));
                        break;

                case MMCN_INITOCX:
                        wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
                        break;

                case MMCN_LISTPAD:
                        wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
                        break;

                case MMCN_MENU_BTNCLICK:
                        wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
                        break;

                case MMCN_MINIMIZED:
                        wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
                        break;

                case MMCN_PASTE:
                        wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
                        break;

                case MMCN_PRELOAD:
                        wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_PRINT:
                        wsprintf(message, _T("MMCN_PRINT\n"));
                        break;

                case MMCN_PROPERTY_CHANGE:
                        wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
                        break;

                case MMCN_QUERY_PASTE:
                        wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
                        break;

                case MMCN_REFRESH:
                        wsprintf(message, _T("MMCN_REFRESH\n"));
                        break;

                case MMCN_REMOVE_CHILDREN:
                        wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_RENAME:
                        wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
                        break;

                case MMCN_RESTORE_VIEW:
                        wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
                        break;

                case MMCN_SELECT:
                        wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
                        break;

                case MMCN_SHOW:
                        wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_SNAPINHELP:
                        wsprintf(message, _T("MMCN_SNAPINHELP\n"));
                        break;

                case MMCN_VIEW_CHANGE:
                        wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
                        break;
        }

        if (message[0] != 0)
                OutputDebugString(message);
        else
                OutputDebugString(_T("unknown event\n"));

#endif
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\people.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _PEOPLE_H
#define _PEOPLE_H

#include "DeleBase.h"

class CBicycle : public CDelegationBase {
public:
    CBicycle(int i) : id(i) { }
    virtual ~CBicycle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CBicycleFolder : public CDelegationBase {
public:
    CBicycleFolder();
    virtual ~CBicycleFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Bicycles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CSkateboard : public CDelegationBase {
public:
    CSkateboard(int i) : id(i) { }
    virtual ~CSkateboard() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CSkateboardFolder : public CDelegationBase {
public:
    CSkateboardFolder();
    virtual ~CSkateboardFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Skateboards"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CIceSkate : public CDelegationBase {
public:
    CIceSkate(int i) : id(i) { }
    virtual ~CIceSkate() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CIceSkateFolder : public CDelegationBase {
public:
    CIceSkateFolder();
    virtual ~CIceSkateFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Ice Skates"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CPeoplePoweredVehicle : public CDelegationBase {
public:
    CPeoplePoweredVehicle();
    virtual ~CPeoplePoweredVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("People-powered Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_PEOPLE = 1 };
    
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 3 };
    CDelegationBase *children[3];
};

#endif // _PEOPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_pStaticNode = new CStaticNode;
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);

    // first things first, make sure that when MMC
    // asks if we do property sheets, that we actually
    // say "yes"
    else if (IsEqualIID(riid, IID_IExtendPropertySheet) ||
        IsEqualIID(riid, IID_IExtendPropertySheet2))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );

    hr = pImageList->ImageListSetStrip( (long *)m_pStaticNode->m_pBMapSm, // pointer to a handle
        (long *)m_pStaticNode->m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );

    pImageList->Release();

    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
    {
    case MMCN_EXPAND:
        hr = base->OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
        break;
    }

    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName();
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CComponentData::CreatePropertyPages(
                                            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                            /* [in] */ LONG_PTR handle,
                                            /* [in] */ LPDATAOBJECT lpIDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->CreatePropertyPages(lpProvider, handle);
}

HRESULT CComponentData::QueryPagesFor(
                                      /* [in] */ LPDATAOBJECT lpDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();

    return base->HasPropertySheets();
}

HRESULT CComponentData::GetWatermarks(
                                      /* [in] */ LPDATAOBJECT lpIDataObject,
                                      /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                      /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                      /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                      /* [out] */ BOOL __RPC_FAR *bStretch)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->GetWatermarks(lphWatermark, lphHeader, lphPalette, bStretch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData, IExtendPropertySheet2
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        //////////////////////////////////
        // Interface IExtendPropertySheet2
        //////////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
        /* [in] */ LONG_PTR handle,
        /* [in] */ LPDATAOBJECT lpIDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
        /* [in] */ LPDATAOBJECT lpDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
        /* [in] */ LPDATAOBJECT lpIDataObject,
        /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
        /* [out] */ HBITMAP __RPC_FAR *lphHeader,
        /* [out] */ HPALETTE __RPC_FAR *lphPalette,
        /* [out] */ BOOL __RPC_FAR *bStretch);
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\sky.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Sky.h"

const GUID CSkyBasedVehicle::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSkyBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL)
{
    OBJECT_CREATED
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);

    // first things first, make sure that when MMC
    // asks if we do property sheets, that we actually
    // say "yes"
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);
    else if (IsEqualIID(riid, IID_IExtendPropertySheet2))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
        MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;
    CDelegationBase *base = NULL;

    // we need to watch for property change and delegate it
    // a little differently, we're actually going to send
    // the CDelegationBase object pointer in the property page
    // PSN_APPLY handler via MMCPropPageNotify()
    if (MMCN_PROPERTY_CHANGE != event) {
        if (NULL == lpDataObject)
            return S_FALSE;

        base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();
    } else {
        base = (CDelegationBase *)param;
    }

    switch (event)      {
    case MMCN_SHOW:
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SELECT:
        hr = base->OnSelect(m_ipConsole, (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));
        break;

    case MMCN_RENAME:
        hr = base->OnRename((LPOLESTR)param);
        break;

    // handle the property change notification if we need to do anything
    // special with it
    case MMCN_PROPERTY_CHANGE:
        hr = base->OnPropertyChange(m_ipConsole);
        break;
    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CComponent::CreatePropertyPages(
                                        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                        /* [in] */ LONG_PTR handle,
                                        /* [in] */ LPDATAOBJECT lpIDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->CreatePropertyPages(lpProvider, handle);
}

HRESULT CComponent::QueryPagesFor(
                                  /* [in] */ LPDATAOBJECT lpDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();

    return base->HasPropertySheets();
}

HRESULT CComponent::GetWatermarks(
                                  /* [in] */ LPDATAOBJECT lpIDataObject,
                                  /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                  /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                  /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                  /* [out] */ BOOL __RPC_FAR *bStretch)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->GetWatermarks(lphWatermark, lphHeader, lphPalette, bStretch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;


// {6C26B387-E3F7-4a7c-BD2A-DD4D596CDE86}
DEFINE_GUID(CLSID_CComponentData, 
0x6c26b387, 0xe3f7, 0x4a7c, 0xbd, 0x2a, 0xdd, 0x4d, 0x59, 0x6c, 0xde, 0x86);


// {9E6D45FD-C65D-4d1e-89A5-81E3A842F3AA}
DEFINE_GUID(CLSID_CSnapinAbout, 
0x9e6d45fd, 0xc65d, 0x4d1e, 0x89, 0xa5, 0x81, 0xe3, 0xa8, 0x42, 0xf3, 0xaa);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\sky.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include "DeleBase.h"

class CSkyBasedVehicle : public CDelegationBase {
public:
    CSkyBasedVehicle() { }
    
    virtual ~CSkyBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Sky-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }
    
private:
    enum { IDM_NEW_SKY = 3 };
    
    // {2974380F-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\people.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "People.h"

const GUID CPeoplePoweredVehicle::thisGuid = { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

const GUID CBicycleFolder::thisGuid = { 0xef163732, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboardFolder::thisGuid = { 0xef163733, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkateFolder::thisGuid = { 0xf6c660b0, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };

const GUID CBicycle::thisGuid = { 0xef163734, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboard::thisGuid = { 0xef163735, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkate::thisGuid = { 0xf6c660b1, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };


//==============================================================
//
// CPeoplePoweredVehicle implementation
//
//
CPeoplePoweredVehicle::CPeoplePoweredVehicle()
{
    children[0] = new CBicycleFolder;
    children[1] = new CSkateboardFolder;
    children[2] = new CIceSkateFolder;
}

CPeoplePoweredVehicle::~CPeoplePoweredVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        delete children[n];
}

HRESULT CPeoplePoweredVehicle::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;

    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |   // relativeID is valid
                SDI_CHILDREN;     // cChildren is valid

            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;

            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );

            _ASSERT( SUCCEEDED(hr) );
        }
    }

    return S_OK;
}

CBicycleFolder::CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CBicycle(n + 1);
    }
}

CBicycleFolder::~CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CBicycleFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CIceSkateFolder::CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CIceSkate(n + 1);
    }
}

CIceSkateFolder::~CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CIceSkateFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CSkateboardFolder::CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSkateboard(n + 1);
    }
}

CSkateboardFolder::~CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSkateboardFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                      ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

const _TCHAR *CBicycle::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Bicycle #%d"), id);

    return buf;
}

const _TCHAR *CSkateboard::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Skateboard #%d"), id);

    return buf;
}

const _TCHAR *CIceSkate::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Ice Skate #%d"), id);

    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnRename(LPOLESTR pszNewName) { return S_FALSE; }
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider,
        LONG_PTR handle) { return S_FALSE; }
    virtual HRESULT HasPropertySheets() { return S_FALSE; }
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
        HBITMAP *lphHeader,
        HPALETTE *lphPalette,
        BOOL *bStretch) { return S_FALSE; }
    
    virtual HRESULT OnPropertyChange(IConsole *pConsole) { return S_OK; }
    
public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDI_PSI_LANDBASED               2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDS_PST_ROCKET                  10
#define IDS_PST_LANDBASED               11
#define IDD_PROPPAGE_LARGE              107
#define IDI_ICON1                       108
#define IDB_SMOPEN                      111
#define IDB_SMBMP                       112
#define IDB_LGBMP                       113
#define IDI_PSI_ROCKET                  114
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDC_ROCKET_NAME                 1000
#define IDC_ROCKET_HEIGHT               1001
#define IDC_ROCKET_WEIGHT               1002
#define IDC_ROCKET_PAYLOAD              1003
#define IDC_ROCKET_STATUS               1005
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1008
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    assert(dwResult != 0) ;

    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    assert(SUCCEEDED(hr)) ;

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
        _tcscat(szKey, pszCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

        MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
        _tcscat(szKey, pszT) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,         // Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);


    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);

    if (fSupportExtensions) {
        // Build the key NodeType
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);

        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }

    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);

    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;

    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // free the memory
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};



#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

#include "Space.h"
#include "Sky.h"
#include "People.h"
#include "Land.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
    children[0] = new CPeoplePoweredVehicle;
    children[1] = new CLandBasedVehicle;
    children[2] = new CSkyBasedVehicle;
    children[3] = new CSpaceVehicle;
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT	  |
                SDI_CHILDREN;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = (n == 0); // only the first child has children
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\space.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SPACE_H
#define _SPACE_H

#include "DeleBase.h"

class CRocket : public CDelegationBase {
public:
    CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload);
    virtual ~CRocket();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnRename(LPOLESTR pszNewName);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
    
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle);
    virtual HRESULT HasPropertySheets();
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
        HBITMAP *lphHeader,
        HPALETTE *lphPalette,
        BOOL *bStretch);
    
    virtual HRESULT OnPropertyChange(IConsole *pConsole);
    
private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    int    nId;
    enum ROCKET_STATUS {RUNNING, PAUSED, STOPPED} iStatus;
    
    LONG_PTR m_ppHandle;
    
    static BOOL CALLBACK DialogProc(
        HWND hwndDlg,  // handle to dialog box
        UINT uMsg,     // message
        WPARAM wParam, // first message parameter
        LPARAM lParam  // second message parameter
        );
    
};

class CSpaceVehicle : public CDelegationBase {
public:
    CSpaceVehicle();
    
    virtual ~CSpaceVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Future Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    enum { IDM_NEW_SPACE = 4 };
    
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CRocket *children[NUMBER_OF_CHILDREN];
};

#endif // _SPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\proppage\space.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include <windows.h>
#include "Space.h"
#include "Comp.h"
#include "resource.h"

const GUID CSpaceVehicle::thisGuid = { 0x29743810, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CRocket::thisGuid = { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSpaceVehicle implementation
//
//
CSpaceVehicle::CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CRocket(_T("Rocket"), n+1, 500000, 265, 75000);
    }
}

CSpaceVehicle::~CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Rocket Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Rocket Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Rocket Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Rocket Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Status", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

//==============================================================
//
// CRocket implementation
//
//
CRocket::CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload)
: szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED)
{
    if (szName) {
        this->szName = new _TCHAR[(_tcslen(szName) + 1) * sizeof(_TCHAR)];
        _tcscpy(this->szName, szName);
    }

    this->nId = id;
    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;

    m_ppHandle = 0;
}

CRocket::~CRocket()
{
    if (szName)
        delete [] szName;
}

const _TCHAR *CRocket::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    switch (nCol) {
    case 0:
        _stprintf(buf, _T("%s (#%d)"), szName ? szName : _T(""), nId);
        break;

    case 1:
        _stprintf(buf, _T("%ld metric tons"), lWeight);
        break;

    case 2:
        _stprintf(buf, _T("%ld meters"), lHeight);
        break;

    case 3:
        _stprintf(buf, _T("%ld kilos"), lPayload);
        break;

    case 4:
        _stprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") :
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;

    }

    return buf;
}

HRESULT CRocket::OnRename(LPOLESTR pszNewName)
{
    if (szName) {
        delete [] szName;
        szName = NULL;
    }

    MAKE_TSTRPTR_FROMWIDE(ptrname, pszNewName);
    szName = new _TCHAR[(_tcslen(ptrname) + 1) * sizeof(_TCHAR)];
    _tcscpy(szName, ptrname);

    return S_OK;
}

// handle anything special when the user clicks Apply or Ok
// on the property sheet.  This sample directly accesses the
// operated-on object, so there's nothing special to do when the user presses Ok.
// when the user presses Apply, we update the currently selected result item
HRESULT CRocket::OnPropertyChange(IConsole *pConsole)
{

    //redraw the item 
    IResultData *pResultData = NULL;

	HRESULT hr;

	hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
	_ASSERT( SUCCEEDED(hr) );	

	HRESULTITEM myhresultitem;	
	
	//lparam == this. See CSpaceVehicle::OnShow
	hr = pResultData->FindItemByLParam( (LPARAM)this, &myhresultitem );
	_ASSERT( SUCCEEDED(hr) ); 

	hr = pResultData->UpdateItem( myhresultitem );     
	_ASSERT( SUCCEEDED(hr) );    
	
    pResultData->Release();
	
	
	return S_OK;
}

HRESULT CRocket::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsoleVerb *pConsoleVerb;

    HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
    _ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);

    // can't get to properties (via the standard methods) unless
    // we tell MMC to display the Properties menu item and
    // toolbar button, this wil give the user a visual cue that
    // there's "something" to do
    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    pConsoleVerb->Release();

    return S_OK;
}

// Implement the dialog proc
BOOL CALLBACK CRocket::DialogProc(
                                  HWND hwndDlg,  // handle to dialog box
                                  UINT uMsg,     // message
                                  WPARAM wParam, // first message parameter
                                  LPARAM lParam  // second message parameter
                                  )
{
    static CRocket *pRocket = NULL;

    switch (uMsg) {
    case WM_INITDIALOG:
        // catch the "this" pointer so we can actually operate on the object
        pRocket = reinterpret_cast<CRocket *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);

        SetDlgItemText(hwndDlg, IDC_ROCKET_NAME, pRocket->szName);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_HEIGHT, pRocket->lHeight, FALSE);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_WEIGHT, pRocket->lWeight, FALSE);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_PAYLOAD, pRocket->lPayload, FALSE);

        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 0, (LPARAM)_T("Running")) );
        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 1, (LPARAM)_T("Paused")) );
        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 2, (LPARAM)_T("Stopped")) );

        SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_SETCURSEL, (WPARAM)pRocket->iStatus, 0);

        break;

    case WM_COMMAND:
        // turn the Apply button on
        if (HIWORD(wParam) == EN_CHANGE ||
            HIWORD(wParam) == CBN_SELCHANGE)
            SendMessage(GetParent(hwndDlg), PSM_CHANGED, (WPARAM)hwndDlg, 0);
        break;

    case WM_DESTROY:
        // tell MMC that we're done with the property sheet (we got this
        // handle in CreatePropertyPages
        MMCFreeNotifyHandle(pRocket->m_ppHandle);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *) lParam)->code) {
        case PSN_APPLY:
            // update the information
            if (pRocket->szName) {
                delete [] pRocket->szName;
                pRocket->szName = NULL;
            }

            {
                int n = SendDlgItemMessage(hwndDlg, IDC_ROCKET_NAME, WM_GETTEXTLENGTH, 0, 0);
                if (n != 0) {
                    pRocket->szName = new _TCHAR[n + 1];
                    GetDlgItemText(hwndDlg, IDC_ROCKET_NAME, pRocket->szName, n + 1);
                }
            }
            pRocket->lHeight = GetDlgItemInt(hwndDlg, IDC_ROCKET_HEIGHT, NULL, FALSE);
            pRocket->lWeight = GetDlgItemInt(hwndDlg, IDC_ROCKET_WEIGHT, NULL, FALSE);
            pRocket->lPayload = GetDlgItemInt(hwndDlg, IDC_ROCKET_PAYLOAD, NULL, FALSE);

            pRocket->iStatus = (ROCKET_STATUS)SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_GETCURSEL, 0, 0);

            // ask MMC to send us a message (on the main thread) so
            // we know the Apply button was clicked.
            HRESULT hr = MMCPropertyChangeNotify(pRocket->m_ppHandle, (long)pRocket);

            _ASSERT(SUCCEEDED(hr));

            return PSNRET_NOERROR;
        }
        break;
    }

    return DefWindowProc(hwndDlg, uMsg, wParam, lParam);
}


HRESULT CRocket::HasPropertySheets()
{
    // say "yes" when MMC asks if we have pages
    return S_OK;
}

HRESULT CRocket::CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle)
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;

    // cache this handle so we can call MMCPropertyChangeNotify
    m_ppHandle = handle;

    // create the property page for this node.
    // NOTE: if your node has multiple pages, put the following
    // in a loop and create multiple pages calling
    // lpProvider->AddPage() for each page.
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEICONID;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_LARGE);
    psp.pfnDlgProc = DialogProc;
    psp.lParam = reinterpret_cast<LPARAM>(this);
    psp.pszTitle = MAKEINTRESOURCE(IDS_PST_ROCKET);
    psp.pszIcon = MAKEINTRESOURCE(IDI_PSI_ROCKET);


    hPage = CreatePropertySheetPage(&psp);
    _ASSERT(hPage);

    return lpProvider->AddPage(hPage);
}

HRESULT CRocket::GetWatermarks(HBITMAP *lphWatermark,
                               HBITMAP *lphHeader,
                               HPALETTE *lphPalette,
                               BOOL *bStretch)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\simple\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    CClassFactory();
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\simple\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if (rclsid != CLSID_CComponentData)
        return CLASS_E_CLASSNOTAVAILABLE;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = new CClassFactory();
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}

CClassFactory::CClassFactory()
: m_cref(0)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    pObj = new CComponentData();
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    if (RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName) == S_OK)
        return RegisterSnapin(CLSID_CComponentData, szSnapInName, IID_NULL, FALSE);
    else
        return E_FAIL;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\simple\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\simple\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
    
}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
// 
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure 
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure  
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;
    
    CDelegationBase *base = GetBaseNodeObject();
    
    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking
    
    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

		MAKE_WIDEPTR_FROMTSTR(wszName, pszName);
        
		// get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);
        
        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();
        
        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);
        
        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;
        
        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }
    
    pStream->Release();
    
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
// 
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer 
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}
    
    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };
    
    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));
    
    if (!stgmedium.hGlobal)	{
        hr = E_OUTOFMEMORY;
    }
    
    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );
    
    // stgmedium now has the data we need 
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }
    
    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);
    
    return pSDO;
    
} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\simple\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\simple\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
	#define IDM_BUTTON1    0x100
	#define IDM_BUTTON2    0x101

	extern HINSTANCE g_hinst;
	extern ULONG g_uObjects;

	#define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
	#define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

	// uncomment the following #define to enable message cracking
	// #define MMC_CRACK_MESSAGES
	void MMCN_Crack(BOOL bComponentData, 
					IDataObject *pDataObject, 
					IComponentData *pCompData,
					IComponent *pComp,
					MMC_NOTIFY_TYPE event, 
					LPARAM arg, 
					LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\simple\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL)
{
    OBJECT_CREATED
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
    
}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize( 
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;
    
    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();
    
    return hr;
}

STDMETHODIMP CComponent::Notify( 
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
	MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    return S_FALSE;
}

STDMETHODIMP CComponent::Destroy( 
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }
    
    return S_OK;
}

STDMETHODIMP CComponent::QueryDataObject( 
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;
    
    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);
    
    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType( 
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;
    
    //
    // Ask for default listview.
    //
    if (base == NULL) {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);
    
    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo( 
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
			LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
			MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

STDMETHODIMP CComponent::CompareObjects( 
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();
    
    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;
    
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\simple\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\simple\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include <objidl.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData,
IPersistStream
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        
        ///////////////////////////////
        // Interface IPersistStream
        ///////////////////////////////
        virtual HRESULT STDMETHODCALLTYPE GetClassID( 
        /* [out] */ CLSID __RPC_FAR *pClassID);
        
        virtual HRESULT STDMETHODCALLTYPE IsDirty( void);
    
    virtual HRESULT STDMETHODCALLTYPE Load( 
        /* [unique][in] */ IStream __RPC_FAR *pStm);
        
        virtual HRESULT STDMETHODCALLTYPE Save( 
        /* [unique][in] */ IStream __RPC_FAR *pStm,
        /* [in] */ BOOL fClearDirty);
        
        virtual HRESULT STDMETHODCALLTYPE GetSizeMax( 
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize);
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\simple\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
	static TCHAR error[64];

	switch (verb) {
    case MMC_VERB_NONE:
		return _T("NONE");
    case MMC_VERB_OPEN:
		return _T("OPEN");
    case MMC_VERB_COPY:
		return _T("COPY");
    case MMC_VERB_PASTE:
		return _T("PASTE");
    case MMC_VERB_DELETE:
		return _T("DELETE");
    case MMC_VERB_PROPERTIES:
		return _T("PROPERTIES");
    case MMC_VERB_RENAME:
		return _T("RENAME");
    case MMC_VERB_REFRESH:
		return _T("REFRESH");
    case MMC_VERB_PRINT:
		return _T("PRINT");
    case MMC_VERB_CUT:
		return _T("CUT");
	default:
		wsprintf(error, _T("Unknown verb id %d"), verb);
		return error;
	}
}

void MMCN_Crack(BOOL bComponentData, 
                IDataObject *pDataObject,
				IComponentData *pCompData,
				IComponent *pComp,
                MMC_NOTIFY_TYPE event, 
				LPARAM arg, 
				LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
	TCHAR message[256] = {0};

	if (bComponentData == TRUE)
		OutputDebugString(_T("IComponentData::Notify( "));
	else
		OutputDebugString(_T("IComponent::Notify( "));

	wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
	OutputDebugString(message);

    switch (event)	{
		case MMCN_ACTIVATE:
			wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
			break;

		case MMCN_ADD_IMAGES:
			wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_BTN_CLICK:
			wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
			break;

		case MMCN_COLUMN_CLICK:
			wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,	 param);
			break;

		case MMCN_COLUMNS_CHANGED:
			wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
			break;

		case MMCN_CONTEXTHELP:
			wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
			break;

		case MMCN_CONTEXTMENU:
			wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
			break;

		case MMCN_CUTORMOVE:
			wsprintf(message, _T("MMCN_CUTORMOVE\n"));
			break;

		case MMCN_DBLCLICK:
			wsprintf(message, _T("MMCN_DBLCLICK\n"));
			break;

		case MMCN_DELETE:
			wsprintf(message, _T("MMCN_DELETE\n"));
			break;

		case MMCN_DESELECT_ALL:
			wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
			break;

		case MMCN_EXPAND:
			wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_EXPANDSYNC:
			wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
			break;

		case MMCN_FILTERBTN_CLICK:
			wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
			break;

		case MMCN_FILTER_CHANGE:
			wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
			break;

		case MMCN_HELP:
			wsprintf(message, _T("MMCN_HELP\n"));
			break;

		case MMCN_INITOCX:
			wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
			break;

		case MMCN_LISTPAD:
			wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
			break;

		case MMCN_MENU_BTNCLICK:
			wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
			break;

		case MMCN_MINIMIZED:
			wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
			break;

		case MMCN_PASTE:
			wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
			break;

		case MMCN_PRELOAD:
			wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_PRINT:
			wsprintf(message, _T("MMCN_PRINT\n"));
			break;

		case MMCN_PROPERTY_CHANGE:
			wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
			break;

		case MMCN_QUERY_PASTE:
			wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
			break;

		case MMCN_REFRESH:
			wsprintf(message, _T("MMCN_REFRESH\n"));
			break;

		case MMCN_REMOVE_CHILDREN:
			wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
			break;

		case MMCN_RENAME:
			wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
			break;

		case MMCN_RESTORE_VIEW:
			wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
			break;

		case MMCN_SELECT:
			wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
			break;

		case MMCN_SHOW:
			wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
			break;

		case MMCN_SNAPINHELP:
			wsprintf(message, _T("MMCN_SNAPINHELP\n"));
			break;

		case MMCN_VIEW_CHANGE:
			wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
			break;
	}

	if (message[0] != 0)
		OutputDebugString(message);
	else
		OutputDebugString(_T("unknown event\n"));

#endif
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\simple\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent
{
private:
    ULONG				m_cref;
    
    IConsole*			m_ipConsole;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\simple\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED

        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);

    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);

    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);

    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);

    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);

    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription(
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];

    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));

    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider(
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion(
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage(
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;

    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;

    *hSmallImageOpen = m_hSmallImageOpen;

    *cMask = RGB(0, 128, 128);

    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
        MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
        *lpDest = wszStr;


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout, FALSE);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\simple\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED
        
        m_pStaticNode = new CStaticNode;
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }
    
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IPersistStream))
        *ppv = static_cast<IPersistStream *>(this);
    
    if (*ppv) 
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    
    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize( 
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT hr = S_FALSE;
    
    //
    // Get pointer to namespace interface
    // First try to get pointer to IConsoleNameSpace2. If that fails, we are in
    // MMC1.0, so get pointer to IConsoleNameSpace instead
    //

    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace2, (void **)&m_ipConsoleNameSpace);

    if (S_OK == hr)
    {
        //We are in MMC 1.1 or higher. QI for IConsole2
        hr = pUnknown->QueryInterface(IID_IConsole2, (void **)&m_ipConsole);
    }
    else //We are in MMC 1.0
    {
        hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
        if (FAILED(hr))
            return hr;

        hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    }

    return hr;
}

HRESULT CComponentData::CreateComponent( 
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent) 
{
    *ppComponent = NULL;
    
    CComponent *pComponent = new CComponent(this);
    
    if (NULL == pComponent)
        return E_OUTOFMEMORY;
    
    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify( 
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
	MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    //Notify doesn't handle any notifications from MMC, so return E_NOTIMPL
    return E_NOTIMPL;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }
    
    if (m_ipConsole) {
        m_ipConsole->Release(); 
        m_ipConsole = NULL;
    }
    
    return S_OK;
}

HRESULT CComponentData::QueryDataObject( 
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject) 
{
    CDataObject *pObj = NULL;
    
    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);
    
    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo( 
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;
    
    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
			LPCTSTR pszT = base->GetDisplayName();
			MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }
    
    return hr;
}

HRESULT CComponentData::CompareObjects( 
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();
    
    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;
    
    return S_FALSE;
}

///////////////////////////////
// Interface IPersistStream
///////////////////////////////
HRESULT CComponentData::GetClassID( 
                                   /* [out] */ CLSID __RPC_FAR *pClassID)
{
    *pClassID = m_pStaticNode->getNodeType();
    
    return S_OK;
}

HRESULT CComponentData::IsDirty( void)
{
    return m_pStaticNode->isDirty() == true ? S_OK : S_FALSE;
}

HRESULT CComponentData::Load( 
                             /* [unique][in] */ IStream __RPC_FAR *pStm)
{
    void *snapInData = m_pStaticNode->getData();
    ULONG dataSize = m_pStaticNode->getDataSize();
    
    return pStm->Read(snapInData, dataSize, NULL);
}

HRESULT CComponentData::Save( 
                             /* [unique][in] */ IStream __RPC_FAR *pStm,
                             /* [in] */ BOOL fClearDirty)
{
    void *snapInData = m_pStaticNode->getData();
    ULONG dataSize = m_pStaticNode->getDataSize();
    
    if (fClearDirty)
        m_pStaticNode->clearDirty();
    
    return pStm->Write(snapInData, dataSize, NULL);
}

HRESULT CComponentData::GetSizeMax( 
                                   /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbSize)
{
    return m_pStaticNode->getDataSize();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\simple\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
}

CStaticNode::~CStaticNode()
{
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\simple\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
{ 
}

CDelegationBase::~CDelegationBase() 
{ 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_pStaticNode = new CStaticNode;
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );

    hr = pImageList->ImageListSetStrip( (long *)m_pStaticNode->m_pBMapSm, // pointer to a handle
        (long *)m_pStaticNode->m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );

    pImageList->Release();

    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
    {
    case MMCN_EXPAND:
        hr = base->OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
        break;
    }

    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName();
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\simple\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {1BA53C00-232F-11d2-9007-00C04F98BC0B}
DEFINE_GUID(CLSID_CComponentData, 
            0x1ba53c00, 0x232f, 0x11d2, 0x90, 0x7, 0x0, 0xc0, 0x4f, 0x98, 0xbc, 0xb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

                MAKE_WIDEPTR_FROMTSTR(wszName, pszName);

                // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\simple\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        108
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\simple\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions for MMCN_* go here
    
private:
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    struct privateData {
        _TCHAR host[MAX_PATH];
        bool isDirty;
        
        privateData() : isDirty(false) {
            ZeroMemory(host, sizeof(host));
        }
    } snapInData;
    
    public:
        LONG getDataSize() { return sizeof(privateData); }
        void *getData() { return &snapInData; }
        bool isDirty() { return snapInData.isDirty; }
        void clearDirty() { snapInData.isDirty = false; };
};

#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>
#include <tchar.h>
#include "EnumTASK.h"
#include "globals.h"

class CComponent : public IComponent,
IExtendTaskPad
{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    IConsole2*		m_ipConsole2;
    
    //store the view type: standard or taskpad
    BOOL m_bTaskpadView;
    //store the user's view type preference.
    BOOL m_bIsTaskpadPreferred;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
            
            ///////////////////////////////
            // Interface IComponent
            ///////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TaskNotify( 
            /* [in] */ IDataObject __RPC_FAR *pdo,
            /* [in] */ VARIANT __RPC_FAR *arg,
            /* [in] */ VARIANT __RPC_FAR *param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumTasks( 
            /* [in] */ IDataObject __RPC_FAR *pdo,
            /* [string][in] */ LPOLESTR szTaskGroup,
            /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppEnumTASK);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTitle( 
            /* [string][in] */ LPOLESTR pszGroup,
            /* [string][out] */ LPOLESTR __RPC_FAR *pszTitle);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDescriptiveText( 
            /* [string][in] */ LPOLESTR pszGroup,
            /* [string][out] */ LPOLESTR __RPC_FAR *pszDescriptiveText);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetBackground( 
            /* [string][in] */ LPOLESTR pszGroup,
            /* [out] */ MMC_TASK_DISPLAY_OBJECT __RPC_FAR *pTDO);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetListPadInfo( 
            /* [string][in] */ LPOLESTR pszGroup,
            /* [out] */ MMC_LISTPAD_INFO __RPC_FAR *lpListPadInfo);
            
    private:
        LPOLESTR OleDuplicateString(LPOLESTR lpStr) {
            LPOLESTR tmp = static_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(lpStr) + 1)  * sizeof(WCHAR)));
            wcscpy(tmp, lpStr);
            
            return tmp;
        }
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\simple\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule, 
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;
    
    assert(dwResult != 0) ;
    
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    assert(SUCCEEDED(hr)) ;

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
	_tcscat(szKey, pszCLSID) ;
    
    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;
    
    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    
    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

	MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
	_tcscat(szKey, pszT) ;
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

   
    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);

    if (IID_NULL != clsidAbout) {
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);
		MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);
	}
    
    if (fSupportExtensions) {
        // Build the key NodeType 
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);
        
        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);
    
    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;
    
    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // free the memory
    CoTaskMemFree(wszCLSID);
    
    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }
    
    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }
    
    // Close the child.
    RegCloseKey(hKeyChild) ;
    
    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\land.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Land.h"

const GUID CLandBasedVehicle::thisGuid = { 0x2974380e, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CLandBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\land.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _LAND_H
#define _LAND_H

#include "DeleBase.h"

class CLandBasedVehicle : public CDelegationBase {
public:
    CLandBasedVehicle() { }
    
    virtual ~CLandBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Land-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LANDICON; }
    
private:
    enum { IDM_NEW_LAND = 2 };
    
    // {2974380E-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _LAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL), m_ipConsole2(NULL),
m_bTaskpadView(FALSE), m_bIsTaskpadPreferred(FALSE)
{
    OBJECT_CREATED
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IExtendTaskPad))
        *ppv = static_cast<IExtendTaskPad *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    hr = m_ipConsole->QueryInterface(IID_IConsole2,
        reinterpret_cast<void**>(&m_ipConsole2));

    _ASSERT( NULL != m_ipConsole2 );

    hr = m_ipConsole2->IsTaskpadViewPreferred();
    m_bIsTaskpadPreferred = (hr == S_OK) ? TRUE : FALSE;

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
    MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
	{
    case MMCN_SHOW:
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SELECT:
        hr = base->OnSelect(m_ipConsole, (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));
        break;

    case MMCN_RENAME:
        hr = base->OnRename((LPOLESTR)param);
        break;

    case MMCN_LISTPAD:
        hr = base->OnListpad(m_ipConsole, (BOOL)arg);
        break;
    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////
// Interface IComponent
///////////////////////////////
HRESULT CComponent::TaskNotify(
                               /* [in] */ IDataObject __RPC_FAR *pdo,
                               /* [in] */ VARIANT __RPC_FAR *arg,
                               /* [in] */ VARIANT __RPC_FAR *param)
{
    CDelegationBase *base = GetOurDataObject(pdo)->GetBaseNodeObject();

    return base->TaskNotify(m_ipConsole, arg, param);
}

HRESULT CComponent::EnumTasks(
                              /* [in] */ IDataObject __RPC_FAR *pdo,
                              /* [string][in] */ LPOLESTR szTaskGroup,
                              /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppEnumTASK)
{
    CDelegationBase *base = GetOurDataObject(pdo)->GetBaseNodeObject();

    // GetTaskList will allocate the entire task structure, it's
    // up to the enumerator to free the list when destroyed
    LONG nCount;
    MMC_TASK *tasks = base->GetTaskList(szTaskGroup, &nCount);

    if (tasks != NULL) {
        CEnumTASK *pTask = new CEnumTASK(tasks, nCount);

        if (pTask) {
            reinterpret_cast<IUnknown *>(pTask)->AddRef();
            HRESULT hr = pTask->QueryInterface (IID_IEnumTASK, (void **)ppEnumTASK);
            reinterpret_cast<IUnknown *>(pTask)->Release();

            return hr;
        }
    }

    return S_OK;
}


HRESULT CComponent::GetTitle(
                             /* [string][in] */ LPOLESTR pszGroup,
                             /* [string][out] */ LPOLESTR __RPC_FAR *pszTitle)
{
    CDelegationBase *base = (CDelegationBase *)wcstoul(pszGroup, NULL, 16);

    if (NULL == base)
            return S_FALSE;

    return base->GetTaskpadTitle(pszTitle);
}

HRESULT CComponent::GetDescriptiveText(
                                       /* [string][in] */ LPOLESTR pszGroup,
                                       /* [string][out] */ LPOLESTR __RPC_FAR *pszDescriptiveText)
{
        CDelegationBase *base = (CDelegationBase *)wcstoul(pszGroup, NULL, 16);

        if (NULL == base)
                return S_FALSE;

    return base->GetTaskpadDescription(pszDescriptiveText);
}

HRESULT CComponent::GetBackground(
                                  /* [string][in] */ LPOLESTR pszGroup,
                                  /* [out] */ MMC_TASK_DISPLAY_OBJECT __RPC_FAR *pTDO)
{
        CDelegationBase *base = (CDelegationBase *)wcstoul(pszGroup, NULL, 16);

        if (NULL == base)
                return S_FALSE;

    return base->GetTaskpadBackground(pTDO);
}

HRESULT CComponent::GetListPadInfo(
                                   /* [string][in] */ LPOLESTR pszGroup,
                                   /* [out] */ MMC_LISTPAD_INFO __RPC_FAR *lpListPadInfo)
{
        CDelegationBase *base = (CDelegationBase *)wcstoul(pszGroup, NULL, 16);

        if (NULL == base)
                return S_FALSE;

    return base->GetListpadInfo(lpListPadInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;


//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE)

{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
        static TCHAR error[64];

        switch (verb) {
    case MMC_VERB_NONE:
                return _T("NONE");
    case MMC_VERB_OPEN:
                return _T("OPEN");
    case MMC_VERB_COPY:
                return _T("COPY");
    case MMC_VERB_PASTE:
                return _T("PASTE");
    case MMC_VERB_DELETE:
                return _T("DELETE");
    case MMC_VERB_PROPERTIES:
                return _T("PROPERTIES");
    case MMC_VERB_RENAME:
                return _T("RENAME");
    case MMC_VERB_REFRESH:
                return _T("REFRESH");
    case MMC_VERB_PRINT:
                return _T("PRINT");
    case MMC_VERB_CUT:
                return _T("CUT");
        default:
                wsprintf(error, _T("Unknown verb id %d"), verb);
                return error;
        }
}

void MMCN_Crack(BOOL bComponentData,
                IDataObject *pDataObject,
                                IComponentData *pCompData,
                                IComponent *pComp,
                MMC_NOTIFY_TYPE event,
                                LPARAM arg,
                                LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
        TCHAR message[256] = {0};

        if (bComponentData == TRUE)
                OutputDebugString(_T("IComponentData::Notify( "));
        else
                OutputDebugString(_T("IComponent::Notify( "));

        wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
        OutputDebugString(message);

    switch (event)      {
                case MMCN_ACTIVATE:
                        wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
                        break;

                case MMCN_ADD_IMAGES:
                        wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_BTN_CLICK:
                        wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
                        break;

                case MMCN_COLUMN_CLICK:
                        wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,       param);
                        break;

                case MMCN_COLUMNS_CHANGED:
                        wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
                        break;

                case MMCN_CONTEXTHELP:
                        wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
                        break;

                case MMCN_CONTEXTMENU:
                        wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
                        break;

                case MMCN_CUTORMOVE:
                        wsprintf(message, _T("MMCN_CUTORMOVE\n"));
                        break;

                case MMCN_DBLCLICK:
                        wsprintf(message, _T("MMCN_DBLCLICK\n"));
                        break;

                case MMCN_DELETE:
                        wsprintf(message, _T("MMCN_DELETE\n"));
                        break;

                case MMCN_DESELECT_ALL:
                        wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
                        break;

                case MMCN_EXPAND:
                        wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_EXPANDSYNC:
                        wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
                        break;

                case MMCN_FILTERBTN_CLICK:
                        wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
                        break;

                case MMCN_FILTER_CHANGE:
                        wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
                        break;

                case MMCN_HELP:
                        wsprintf(message, _T("MMCN_HELP\n"));
                        break;

                case MMCN_INITOCX:
                        wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
                        break;

                case MMCN_LISTPAD:
                        wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
                        break;

                case MMCN_MENU_BTNCLICK:
                        wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
                        break;

                case MMCN_MINIMIZED:
                        wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
                        break;

                case MMCN_PASTE:
                        wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
                        break;

                case MMCN_PRELOAD:
                        wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_PRINT:
                        wsprintf(message, _T("MMCN_PRINT\n"));
                        break;

                case MMCN_PROPERTY_CHANGE:
                        wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
                        break;

                case MMCN_QUERY_PASTE:
                        wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
                        break;

                case MMCN_REFRESH:
                        wsprintf(message, _T("MMCN_REFRESH\n"));
                        break;

                case MMCN_REMOVE_CHILDREN:
                        wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_RENAME:
                        wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
                        break;

                case MMCN_RESTORE_VIEW:
                        wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
                        break;

                case MMCN_SELECT:
                        wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
                        break;

                case MMCN_SHOW:
                        wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_SNAPINHELP:
                        wsprintf(message, _T("MMCN_SNAPINHELP\n"));
                        break;

                case MMCN_VIEW_CHANGE:
                        wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
                        break;
        }

        if (message[0] != 0)
                OutputDebugString(message);
        else
                OutputDebugString(_T("unknown event\n"));

#endif
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\enumtask.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _ENUMTASK_H
#define _ENUMTASK_H

#include <mmc.h>

class CEnumTASK : public IEnumTASK
{
public:
    CEnumTASK(MMC_TASK *pTaskList, ULONG nTasks);
    virtual ~CEnumTASK();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IEnumTASK
    ///////////////////////////////
    virtual HRESULT STDMETHODCALLTYPE Next( 
        /* [in] */ ULONG celt,
        /* [length_is][size_is][out] */ MMC_TASK __RPC_FAR *rgelt,
        /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
        /* [in] */ ULONG celt);
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void);
    
    virtual HRESULT STDMETHODCALLTYPE Clone( 
        /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppenum);
        
private:
    MMC_TASK *m_pTaskList;
    ULONG m_TaskCount;
    ULONG m_CurrTask;
    
    ULONG m_cref;
};

#endif // _ENUMTASK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\enumtask.cpp ===
// EnumTASK.cpp: implementation of the CEnumTASK class.
//
//////////////////////////////////////////////////////////////////////

#include "EnumTASK.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CEnumTASK::CEnumTASK(MMC_TASK *pTaskList, ULONG nTasks)
    : m_pTaskList(pTaskList), m_TaskCount(nTasks), m_CurrTask(0)
{
}

CEnumTASK::~CEnumTASK()
{
    if (m_pTaskList)
        delete [] m_pTaskList;
}

STDMETHODIMP CEnumTASK::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IEnumTASK *>(this);
    else if (IsEqualIID(riid, IID_IEnumTASK))
        *ppv = static_cast<IEnumTASK *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CEnumTASK::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CEnumTASK::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
    
}

HRESULT CEnumTASK::Next( 
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ MMC_TASK __RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched)
{
    *pceltFetched = 0;

	if (m_CurrTask < m_TaskCount) {
		if (rgelt != NULL) {
			CopyMemory(rgelt, &m_pTaskList[m_CurrTask++], sizeof(MMC_TASK));
			*pceltFetched = 1;
		}
	}

    return (*pceltFetched != 0) ? S_OK : S_FALSE;
}

HRESULT CEnumTASK::Skip( 
    /* [in] */ ULONG celt)
{
    return E_NOTIMPL;
}

HRESULT CEnumTASK::Reset( void)
{
    m_CurrTask = 0;

    return S_OK;
}

HRESULT CEnumTASK::Clone( 
    /* [out] */ IEnumTASK __RPC_FAR *__RPC_FAR *ppenum)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnRename(LPOLESTR pszNewName) { return S_FALSE; }
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    virtual HRESULT OnListpad(IConsole *pConsole, BOOL bAttaching) { return S_FALSE; }

	// taskpad support
    virtual HRESULT TaskNotify(IConsole *pConsole, VARIANT *v1, VARIANT *v2) { return S_FALSE; }
    virtual MMC_TASK *GetTaskList(LPOLESTR szTaskGroup, LONG *nCount) { return NULL; }
	virtual HRESULT GetTaskpadTitle(LPOLESTR *pszTitle) { return S_FALSE; }
	virtual HRESULT GetTaskpadDescription(LPOLESTR *pszDescription) { return S_FALSE; }
	virtual HRESULT GetTaskpadBackground(MMC_TASK_DISPLAY_OBJECT *pTDO) { return S_FALSE; }
	virtual HRESULT GetListpadInfo(MMC_LISTPAD_INFO *lpListPadInfo) { return S_FALSE; }
    
public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\sky.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Sky.h"

const GUID CSkyBasedVehicle::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSkyBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\sky.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include "DeleBase.h"

class CSkyBasedVehicle : public CDelegationBase {
public:
    CSkyBasedVehicle() { }
    
    virtual ~CSkyBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Sky-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }
    
private:
    enum { IDM_NEW_SKY = 3 };
    
    // {2974380F-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {C83216B2-A4E5-11d2-970B-0080C7DCB3DC}
DEFINE_GUID(CLSID_CComponentData, 
            0xc83216b2, 0xa4e5, 0x11d2, 0x97, 0xb, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc);

// {CED3C801-A4E5-11d2-970B-0080C7DCB3DC}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0xced3c801, 0xa4e5, 0x11d2, 0x97, 0xb, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
        #define IDM_BUTTON1    0x100
        #define IDM_BUTTON2    0x101

        extern HINSTANCE g_hinst;
        extern ULONG g_uObjects;

        #define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
        #define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

        // uncomment the following #define to enable message cracking
        // #define MMC_CRACK_MESSAGES
        void MMCN_Crack(BOOL bComponentData,
                                        IDataObject *pDataObject,
                                        IComponentData *pCompData,
                                        IComponent *pComp,
                                        MMC_NOTIFY_TYPE event,
                                        LPARAM arg,
                                        LPARAM param);

		LPOLESTR CreateResourcePath(HINSTANCE hInst, LPOLESTR szResource);      
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};



#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

#include "Space.h"
#include "Sky.h"
#include "People.h"
#include "Land.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
    children[0] = new CPeoplePoweredVehicle;
    children[1] = new CLandBasedVehicle;
    children[2] = new CSkyBasedVehicle;
    children[3] = new CSpaceVehicle;
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT	  |
                SDI_CHILDREN;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = (n == 0); // only the first child has children
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    assert(dwResult != 0) ;

    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    assert(SUCCEEDED(hr)) ;

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
        _tcscat(szKey, pszCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

        MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
        _tcscat(szKey, pszT) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,         // Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);


    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);

    if (fSupportExtensions) {
        // Build the key NodeType
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);

        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }

    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);

    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;

    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // free the memory
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDB_SMOPEN                      111
#define IDB_SMBMP                       112
#define IDB_LGBMP                       113
#define IDB_BITMAP1                     114
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\people.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <windows.h>
#include <commctrl.h>
#include <stdio.h>
#include "People.h"

const GUID CPeoplePoweredVehicle::thisGuid = { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

const GUID CBicycleFolder::thisGuid = { 0xef163732, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboardFolder::thisGuid = { 0xef163733, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkateFolder::thisGuid = { 0xf6c660b0, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };

const GUID CBicycle::thisGuid = { 0xef163734, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboard::thisGuid = { 0xef163735, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkate::thisGuid = { 0xf6c660b1, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };


//---------------------------------------------------------------------------
//  Creates a string with the format  
//    "res://<Path to this object>/<path to resource>
//
//  It is up to the caller to make sure the memory allocated with 
//  CoTaskMemAlloc for the string is freed.
//  If null is passed in the first parameter, the path to MMC.EXE will be
//  returned, if the instance handle is passed the returned path will point
//  the Snap-in dll.
//
LPOLESTR CreateResourcePath
( 
  HINSTANCE hInst,         //[in] Global instance handle
  LPOLESTR szResource      //[in] Path to stored resource
)
{ 
   _TCHAR szBuffer[MAX_PATH];
            
   ZeroMemory(szBuffer, sizeof(szBuffer));
            
   _tcscpy(szBuffer, _T("res://"));
            
   _TCHAR *szTemp = szBuffer + _tcslen(szBuffer);
   GetModuleFileName(hInst, szTemp, sizeof(szBuffer) - _tcslen(szBuffer));
            
   _tcscat(szBuffer, _T("/"));
   MAKE_TSTRPTR_FROMWIDE(szname, szResource);
   _tcscat(szBuffer, szname);
            
   MAKE_WIDEPTR_FROMTSTR(wszname, szBuffer);
   LPOLESTR szOutBuffer = static_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(wszname) + 1)  * sizeof(WCHAR)));

   wcscpy(szOutBuffer, wszname);
            
   return szOutBuffer;

} //end CreateResoucePath()


static LPOLESTR OleDuplicateString(LPOLESTR lpStr) {
    LPOLESTR tmp = static_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(lpStr) + 1)  * sizeof(WCHAR)));
    wcscpy(tmp, lpStr);

    return tmp;
}


//==============================================================
//
// CPeoplePoweredVehicle implementation
//
//
CPeoplePoweredVehicle::CPeoplePoweredVehicle()
{
    children[0] = new CBicycleFolder;
    children[1] = new CSkateboardFolder;
    children[2] = new CIceSkateFolder;
}

CPeoplePoweredVehicle::~CPeoplePoweredVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        delete children[n];
}

HRESULT CPeoplePoweredVehicle::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;

    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |   // relativeID is valid
                SDI_CHILDREN;     // cChildren is valid

            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;

            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );

            _ASSERT( SUCCEEDED(hr) );
        }
    }

    return S_OK;
}

CBicycleFolder::CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CBicycle(n + 1);
    }
}

CBicycleFolder::~CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CBicycleFolder::GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions)
{
	TCHAR taskpad[1024];
    TCHAR szThis[16];

    _ultot((unsigned long)this, szThis, 16);
	_tcscpy(taskpad, _T("horizontal.htm#"));
    _tcscat(taskpad, szThis);
    MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, taskpad);

	*ppViewType = CreateResourcePath( NULL, pszW );

    *pViewOptions = MMC_VIEW_OPTIONS_NONE;
    return S_OK;
}

MMC_TASK *CBicycleFolder::GetTaskList(LPOLESTR szTaskGroup, LONG *nCount)
{
    *nCount = 5;

    MMC_TASK *tasks = new MMC_TASK[*nCount];

    for (int t = 0; t < *nCount; t++) {
        tasks[t].sDisplayObject.eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
        tasks[t].sDisplayObject.uBitmap.szMouseOverBitmap = CreateResourcePath(g_hinst, L"buttonover.bmp");
        tasks[t].sDisplayObject.uBitmap.szMouseOffBitmap = CreateResourcePath(g_hinst, L"buttonoff.bmp");

        switch (t) {
        case 0:
            tasks[t].szText = OleDuplicateString(L"Tune bicycle");
            tasks[t].szHelpString = OleDuplicateString(L"Click here to Tune bicycle");

            break;
        case 1:
            tasks[t].szText = OleDuplicateString(L"Ride bicycle");
            tasks[t].szHelpString = OleDuplicateString(L"Click here to ride bicycle");

            break;
        case 2:
            tasks[t].szText = OleDuplicateString(L"Stop riding bicycle");
            tasks[t].szHelpString = OleDuplicateString(L"Click here to stop riding bicycle");

            break;
        case 3:
            tasks[t].szText = OleDuplicateString(L"Purchase bicycle");
            tasks[t].szHelpString = OleDuplicateString(L"Click here to purchase bicycle");

        case 4:
            tasks[t].szText = OleDuplicateString(L"Sell bicycle");
            tasks[t].szHelpString = OleDuplicateString(L"Click here to sell bicycle");

            break;
        }

        tasks[t].eActionType = MMC_ACTION_ID;
        tasks[t].nCommandID = t;
    }

    return tasks;
}

HRESULT CBicycleFolder::TaskNotify(IConsole *pConsole, VARIANT *v1, VARIANT *v2)
{
    RESULTDATAITEM rdi;
    IResultData *pResultData;

    ZeroMemory(&rdi, sizeof(RESULTDATAITEM));

    HRESULT hr = S_OK;

    hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);

    if (SUCCEEDED(hr)) {

        rdi.mask = RDI_STATE | RDI_PARAM;  // Use selected state to get param.
        rdi.nState = LVIS_SELECTED | LVIS_FOCUSED;
        rdi.nIndex = -1;  // Start looking for selected item from top of list view

        hr = pResultData->GetNextItem(&rdi);

        pResultData->Release();
    }

    if (SUCCEEDED(hr)) {
        _TCHAR buf[256];

        switch (v1->lVal) {
        case 0:
            wsprintf(buf, _T("Bicycle %d tuned."), rdi.nIndex);

            break;
        case 1:
            wsprintf(buf, _T("Riding bicycle %d."), rdi.nIndex);

            break;
        case 2:
            wsprintf(buf, _T("Not riding bicycle %d."), rdi.nIndex);

            break;
        case 3:
            wsprintf(buf, _T("Bicycle %d purchased."), rdi.nIndex);

            break;
        case 4:
            wsprintf(buf, _T("Bicycle %d sold."), rdi.nIndex);

            break;
        case 102:
            wsprintf(buf, _T("Special bicycle task choosen (%d)."), rdi.nIndex);

            break;
        }

        MessageBox(NULL, buf, _T("Task Notification"), MB_OK | MB_ICONINFORMATION);
    }

    return hr;
}

HRESULT CBicycleFolder::GetTaskpadTitle(LPOLESTR *pszTitle)
{
        *pszTitle = OleDuplicateString(L"Bicycle Tasks");
        return S_OK;
}

HRESULT CBicycleFolder::GetTaskpadDescription(LPOLESTR *pszDescription)
{
        *pszDescription = OleDuplicateString(L"This is a sample task pad for bicycle nodes");
        return S_OK;
}

HRESULT CBicycleFolder::GetTaskpadBackground(MMC_TASK_DISPLAY_OBJECT *pTDO)
{
        pTDO->eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
        pTDO->uBitmap.szMouseOverBitmap = CreateResourcePath(g_hinst, L"bicycle.bmp");
        return S_OK;
}

HRESULT CBicycleFolder::GetListpadInfo(MMC_LISTPAD_INFO *lpListPadInfo)
{
        lpListPadInfo->szTitle = OleDuplicateString(L"Bicycle");
        lpListPadInfo->szButtonText = OleDuplicateString(L"Special");
        lpListPadInfo->nCommandID = 102;
        return S_OK;
}

HRESULT CBicycleFolder::OnListpad(IConsole *pConsole, BOOL bAttaching)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    IImageList  *pImageList  = NULL;

    if (bAttaching) {
        hr = pConsole->QueryResultImageList(&pImageList);
        _ASSERT( SUCCEEDED(hr) );

        hr = pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
                                           (long *)m_pBMapLg, // pointer to a handle
                                           0, // index of the first image in the strip
                                           RGB(0, 128, 128)  // color of the icon mask
            );
        _ASSERT( SUCCEEDED(hr) );

        pImageList->Release();

        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Bicycle License      ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CIceSkateFolder::CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CIceSkate(n + 1);
    }
}

CIceSkateFolder::~CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CIceSkateFolder::GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions)
{
	
	TCHAR taskpad[1024];
    TCHAR szThis[16];

    _ultot((unsigned long)this, szThis, 16);
	_tcscpy(taskpad, _T("listpad.htm#"));
    _tcscat(taskpad, szThis);
    MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, taskpad);

	*ppViewType = CreateResourcePath( NULL, pszW );

    *pViewOptions = MMC_VIEW_OPTIONS_NONE;
    return S_OK;
}

MMC_TASK *CIceSkateFolder::GetTaskList(LPOLESTR szTaskGroup, LONG *nCount)
{
    *nCount = 4;

    MMC_TASK *tasks = new MMC_TASK[*nCount];

    for (int t = 0; t < *nCount; t++) {
        tasks[t].sDisplayObject.eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
        tasks[t].sDisplayObject.uBitmap.szMouseOverBitmap = CreateResourcePath(g_hinst, L"buttonover.bmp");
        tasks[t].sDisplayObject.uBitmap.szMouseOffBitmap = CreateResourcePath(g_hinst, L"buttonoff.bmp");

        switch (t) {
        case 0:
            tasks[t].szText = OleDuplicateString(L"Sharpen Skate");
            tasks[t].szHelpString = OleDuplicateString(L"Click here to Sharpen skate");

            break;
        case 1:
            tasks[t].szText = OleDuplicateString(L"Tighten skate laces");
            tasks[t].szHelpString = OleDuplicateString(L"Click here to Tighten skate");

            break;
        case 2:
            tasks[t].szText = OleDuplicateString(L"Wear skate");
            tasks[t].szHelpString = OleDuplicateString(L"Click here to Wear skate");

            break;
        case 3:
            tasks[t].szText = OleDuplicateString(L"Remove skate");
            tasks[t].szHelpString = OleDuplicateString(L"Click here to Remove skate");

            break;
        }

        tasks[t].eActionType = MMC_ACTION_ID;
        tasks[t].nCommandID = t;
    }

    return tasks;
}

HRESULT CIceSkateFolder::TaskNotify(IConsole *pConsole, VARIANT *v1, VARIANT *v2)
{
    RESULTDATAITEM rdi;
    IResultData *pResultData;

    ZeroMemory(&rdi, sizeof(RESULTDATAITEM));

    HRESULT hr = S_OK;

    hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);

    if (SUCCEEDED(hr)) {

        rdi.mask = RDI_STATE | RDI_PARAM;  // Use selected state to get param.
        rdi.nState = LVIS_SELECTED | LVIS_FOCUSED;
        rdi.nIndex = -1;  // Start looking for selected item from top of list view

        hr = pResultData->GetNextItem(&rdi);

        pResultData->Release();
    }

    if (SUCCEEDED(hr)) {
        _TCHAR buf[256];

        switch (v1->lVal) {
        case 0:
            wsprintf(buf, _T("Skate %d sharpened."), rdi.nIndex);

            break;
        case 1:
            wsprintf(buf, _T("Skate %d tightened."), rdi.nIndex);

            break;
        case 2:
            wsprintf(buf, _T("Wearing skate %d."), rdi.nIndex);

            break;
        case 3:
            wsprintf(buf, _T("Skate %d removed."), rdi.nIndex);

            break;
        case 101:
            wsprintf(buf, _T("Special skate task choosen (%d)."), rdi.nIndex);

            break;
        }

        MessageBox(NULL, buf, _T("Task Notification"), MB_OK | MB_ICONINFORMATION);
    }

    return hr;
}

HRESULT CIceSkateFolder::GetTaskpadTitle(LPOLESTR *pszTitle)
{
        *pszTitle = OleDuplicateString(L"Iceskate Tasks");
        return S_OK;
}

HRESULT CIceSkateFolder::GetTaskpadDescription(LPOLESTR *pszDescription)
{
        *pszDescription = OleDuplicateString(L"This is a sample task pad for ice skate nodes");
        return S_OK;
}

HRESULT CIceSkateFolder::GetTaskpadBackground(MMC_TASK_DISPLAY_OBJECT *pTDO)
{
        pTDO->eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
        pTDO->uBitmap.szMouseOverBitmap = CreateResourcePath(g_hinst, L"iceskate.bmp");
        return S_OK;
}

HRESULT CIceSkateFolder::GetListpadInfo(MMC_LISTPAD_INFO *lpListPadInfo)
{
        lpListPadInfo->szTitle = OleDuplicateString(L"Ice Skates");
        lpListPadInfo->szButtonText = OleDuplicateString(L"Special");
        lpListPadInfo->nCommandID = 101;
        return S_OK;
}

HRESULT CIceSkateFolder::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsole2 *pConsole2;
    HRESULT hr = S_OK;

    if (TRUE == bSelect) {
        hr = pConsole->QueryInterface(IID_IConsole2, (void **)&pConsole2);

        if (SUCCEEDED(hr)) {
            hr = pConsole2->SetStatusText(L"Hello, you've selected the ice skate folder");
            pConsole2->Release();
        }
    }

    return hr;
}

HRESULT CIceSkateFolder::OnListpad(IConsole *pConsole, BOOL bAttaching)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;
    IImageList  *pImageList  = NULL;

    if (bAttaching) {
        hr = pConsole->QueryResultImageList(&pImageList);
        _ASSERT( SUCCEEDED(hr) );

        hr = pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
                                           (long *)m_pBMapLg, // pointer to a handle
                                           0, // index of the first image in the strip
                                           RGB(0, 128, 128)  // color of the icon mask
            );
        _ASSERT( SUCCEEDED(hr) );

        pImageList->Release();

        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Sharpness           ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

HRESULT CIceSkate::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    bSelected = bSelect ? true : false;

    return S_FALSE;
}

CSkateboardFolder::CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSkateboard(n + 1);
    }
}

CSkateboardFolder::~CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSkateboardFolder::GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions)
{
	TCHAR taskpad[1024];
    TCHAR szThis[16];

    _ultot((unsigned long)this, szThis, 16);
	_tcscpy(taskpad, _T("default.htm#"));
    _tcscat(taskpad, szThis);
    MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, taskpad);

	*ppViewType = CreateResourcePath( NULL, pszW );

    *pViewOptions = MMC_VIEW_OPTIONS_NONE;
    return S_OK; 
}

MMC_TASK *CSkateboardFolder::GetTaskList(LPOLESTR szTaskGroup, LONG *nCount)
{
    *nCount = 4;

    _TCHAR buf[256];
    MMC_TASK *tasks = new MMC_TASK[*nCount];

    for (int t = 0; t < *nCount; t++) {
        tasks[t].sDisplayObject.eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
        tasks[t].sDisplayObject.uBitmap.szMouseOverBitmap = CreateResourcePath(g_hinst, L"buttonover.bmp");
        tasks[t].sDisplayObject.uBitmap.szMouseOffBitmap = CreateResourcePath(g_hinst, L"buttonoff.bmp");

        _stprintf(buf, _T("Task #%d"), t);
        MAKE_WIDEPTR_FROMTSTR(wszText, buf);
        tasks[t].szText = OleDuplicateString(wszText);

        _stprintf(buf, _T("Click here to start task #%d"), t);
        MAKE_WIDEPTR_FROMTSTR(wszHelpString, buf);
        tasks[t].szHelpString = OleDuplicateString(wszHelpString);

        tasks[t].eActionType = MMC_ACTION_ID;
        tasks[t].nCommandID = t;
    }

    return tasks;
}

HRESULT CSkateboardFolder::TaskNotify(IConsole *pConsole, VARIANT *v1, VARIANT *v2)
{
    _TCHAR buf[256];

    wsprintf(buf, _T("Skateboard task %ld has been selected."), v1->lVal);

    MessageBox(NULL, buf, _T("Task Notification"), MB_OK | MB_ICONINFORMATION);

    return S_OK;
}

HRESULT CSkateboardFolder::GetTaskpadTitle(LPOLESTR *pszTitle)
{
        *pszTitle = OleDuplicateString(L"Skateboard Tasks");
        return S_OK;
}

HRESULT CSkateboardFolder::GetTaskpadDescription(LPOLESTR *pszDescription)
{
        *pszDescription = OleDuplicateString(L"This is a sample task pad for skateboard nodes");
        return S_OK;
}

HRESULT CSkateboardFolder::GetTaskpadBackground(MMC_TASK_DISPLAY_OBJECT *pTDO)
{
        pTDO->eDisplayType = MMC_TASK_DISPLAY_TYPE_BITMAP;
        pTDO->uBitmap.szMouseOverBitmap = CreateResourcePath(g_hinst, L"skateboard.bmp");
        return S_OK;
}

HRESULT CSkateboardFolder::GetListpadInfo(MMC_LISTPAD_INFO *lpListPadInfo)
{
        return S_FALSE;
}

const _TCHAR *CBicycle::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    if (nCol == 0) {
        _stprintf(buf, _T("Bicycle #%d"), id);
    } else if (nCol == 1) {
        _stprintf(buf, _T("%ld"), (long)this);
    }

    return buf;
}

const _TCHAR *CSkateboard::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Skateboard #%d"), id);

    return buf;
}

const _TCHAR *CIceSkate::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    if (nCol == 0) {
        _stprintf(buf, _T("Ice Skate #%d"), id);
    } else if (nCol == 1) {
        _stprintf(buf, _T("Sharpness %ld"), (long)this);
    }

    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\people.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _PEOPLE_H
#define _PEOPLE_H

#include "DeleBase.h"

class CBicycle : public CDelegationBase {
public:
    CBicycle(int i) : id(i) { }
    virtual ~CBicycle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CBicycleFolder : public CDelegationBase {
public:
    CBicycleFolder();
    virtual ~CBicycleFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Bicycles (horizontal listpad)"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions);
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnListpad(IConsole *pConsole, BOOL bAttaching);

	// taskpad support
    virtual HRESULT TaskNotify(IConsole *pConsole, VARIANT *v1, VARIANT *v2);
    virtual MMC_TASK *GetTaskList(LPOLESTR szTaskGroup, LONG *nCount);
	virtual HRESULT GetTaskpadTitle(LPOLESTR *pszTitle);
	virtual HRESULT GetTaskpadDescription(LPOLESTR *pszDescription);
	virtual HRESULT GetTaskpadBackground(MMC_TASK_DISPLAY_OBJECT *pTDO);
	virtual HRESULT GetListpadInfo(MMC_LISTPAD_INFO *lpListPadInfo);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CSkateboard : public CDelegationBase {
public:
    CSkateboard(int i) : id(i) { }
    virtual ~CSkateboard() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CSkateboardFolder : public CDelegationBase {
public:
    CSkateboardFolder();
    virtual ~CSkateboardFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Skateboards (taskpad)"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions);
    
public:
	// taskpad support
    virtual HRESULT TaskNotify(IConsole *pConsole, VARIANT *v1, VARIANT *v2);
    virtual MMC_TASK *GetTaskList(LPOLESTR szTaskGroup, LONG *nCount);
	virtual HRESULT GetTaskpadTitle(LPOLESTR *pszTitle);
	virtual HRESULT GetTaskpadDescription(LPOLESTR *pszDescription);
	virtual HRESULT GetTaskpadBackground(MMC_TASK_DISPLAY_OBJECT *pTDO);
	virtual HRESULT GetListpadInfo(MMC_LISTPAD_INFO *lpListPadInfo);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CIceSkate : public CDelegationBase {
public:
    CIceSkate(int i) : id(i), bSelected(false) { }
    virtual ~CIceSkate() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
    bool bSelected;
    
public:
    bool IsSelected() const { return bSelected; }
};

class CIceSkateFolder : public CDelegationBase {
public:
    CIceSkateFolder();
    virtual ~CIceSkateFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Ice Skates (listpad)"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions);
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnListpad(IConsole *pConsole, BOOL bAttaching);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);

	// taskpad support
    virtual HRESULT TaskNotify(IConsole *pConsole, VARIANT *v1, VARIANT *v2);
    virtual MMC_TASK *GetTaskList(LPOLESTR szTaskGroup, LONG *nCount);
	virtual HRESULT GetTaskpadTitle(LPOLESTR *pszTitle);
	virtual HRESULT GetTaskpadDescription(LPOLESTR *pszDescription);
	virtual HRESULT GetTaskpadBackground(MMC_TASK_DISPLAY_OBJECT *pTDO);
	virtual HRESULT GetListpadInfo(MMC_LISTPAD_INFO *lpListPadInfo);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CIceSkate *children[NUMBER_OF_CHILDREN];
};

class CPeoplePoweredVehicle : public CDelegationBase {
public:
    CPeoplePoweredVehicle();
    virtual ~CPeoplePoweredVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("People-powered Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_PEOPLE = 1 };
    
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 3 };
    CDelegationBase *children[3];
};

#endif // _PEOPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\space.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "Space.h"
#include "Comp.h"

const GUID CSpaceVehicle::thisGuid = { 0x29743810, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CRocket::thisGuid = { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSpaceVehicle implementation
//
//
CSpaceVehicle::CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CRocket(_T("Rocket"), n+1, 500000, 265, 75000);
    }
}

CSpaceVehicle::~CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Rocket Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Rocket Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Rocket Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Rocket Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Status", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

//==============================================================
//
// CRocket implementation
//
//
CRocket::CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload)
: szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED)
{
    if (szName) {
        this->szName = new _TCHAR[(_tcslen(szName) + 1) * sizeof(_TCHAR)];
        _tcscpy(this->szName, szName);
    }

    this->nId = id;
    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;
}

CRocket::~CRocket()
{
    if (szName)
        delete [] szName;
}

const _TCHAR *CRocket::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    switch (nCol) {
    case 0:
        _stprintf(buf, _T("%s (#%d)"), szName ? szName : _T(""), nId);
        break;

    case 1:
        _stprintf(buf, _T("%ld metric tons"), lWeight);
        break;

    case 2:
        _stprintf(buf, _T("%ld meters"), lHeight);
        break;

    case 3:
        _stprintf(buf, _T("%ld kilos"), lPayload);
        break;

    case 4:
        _stprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") :
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;

    }

    return buf;
}

HRESULT CRocket::OnRename(LPOLESTR pszNewName)
{
    if (szName) {
        delete [] szName;
        szName = NULL;
    }

    MAKE_TSTRPTR_FROMWIDE(ptrname, pszNewName);
    szName = new _TCHAR[(_tcslen(ptrname) + 1) * sizeof(_TCHAR)];
    _tcscpy(szName, ptrname);

    return S_OK;
}

HRESULT CRocket::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsoleVerb *pConsoleVerb;

    HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
    _ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetVerbState(MMC_VERB_RENAME, HIDDEN, FALSE);
    hr = pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);

    pConsoleVerb->Release();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\tbarext\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED
        
        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);
    
    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    
    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);
    
    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);
    
    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);
    
    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);
    
    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;
    
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);
    
    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;
    
}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription( 
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];
    
    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));
    
    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider( 
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion( 
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage( 
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;
    
    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage( 
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;
    
    *hSmallImageOpen = m_hSmallImageOpen;
    
    *cMask = RGB(0, 128, 128);
    
    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
	MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
	*lpDest = wszStr;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\taskpads\space.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SPACE_H
#define _SPACE_H

#include "DeleBase.h"

class CRocket : public CDelegationBase {
public:
    CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload);
    virtual ~CRocket();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnRename(LPOLESTR pszNewName);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
    
private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    int    nId;
    enum {RUNNING, PAUSED, STOPPED} iStatus;
};

class CSpaceVehicle : public CDelegationBase {
public:
    CSpaceVehicle();
    
    virtual ~CSpaceVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Future Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    enum { IDM_NEW_SPACE = 4 };
    
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CRocket *children[NUMBER_OF_CHILDREN];
};

#endif // _SPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\tbarext\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\tbarext\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {TOOLBAREXTENSION = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\tbarext\extend.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _EXTEND_H
#define _EXTEND_H

struct EXTENSION_NODE
{
    GUID	GUID;
    _TCHAR	szDescription[256];
};

enum EXTENSION_TYPE
{
    NameSpaceExtension,
        ContextMenuExtension, 
        ToolBarExtension,
        PropertySheetExtension,
        TaskExtension,
        DynamicExtension,
		DummyExtension
};

struct EXTENDER_NODE
{
    EXTENSION_TYPE	eType;
    GUID			guidNode;
    GUID			guidExtension;
    _TCHAR			szDescription[256];
};

#endif // _EXTEND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\tbarext\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
	#define IDM_BUTTON1    0x100
	#define IDM_BUTTON2    0x101

	extern HINSTANCE g_hinst;
	extern ULONG g_uObjects;

	#define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
	#define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\tbarext\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "globals.h"
#include "resource.h"
#include "guids.h"
#include "basesnap.h"
#include "tbarExt.h"
#include "About.h"
#include "Registry.h"
#include "Extend.h"

// our globals
HINSTANCE g_hinst;


BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CToolBarExtension) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CToolBarExtension)
        pFactory = new CClassFactory(CClassFactory::TOOLBAREXTENSION);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (TOOLBAREXTENSION == m_factoryType) {
        pObj = new CToolBarExtension();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CToolBarExtension, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CToolBarExtension, szSnapInName, CLSID_CSnapinAbout);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CToolBarExtension) == S_OK)
        return UnregisterSnapin(CLSID_CToolBarExtension);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\tbarext\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#define INDEX_SUN 6
#define INDEX_SNOW 7
#define INDEX_RAIN 8
#define INDEX_CLOUD 9
#define INDEX_WORLD 10
#define INDEX_THUNDER 11


#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED

        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);

    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);

    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);

    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);

    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);

    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription(
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];

    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));

    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider(
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion(
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));
}


STDMETHODIMP CSnapinAbout::GetSnapinImage(
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;

    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;

    *hSmallImageOpen = m_hSmallImageOpen;

    *cMask = RGB(0, 128, 128);

    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
        MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
        *lpDest = wszStr;


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\tbarext\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDR_TOOLBAR1                    112
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_SMOPEN                      124
#define IDB_SMBMP                       125
#define IDB_LGBMP                       126
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015
#define ID_BUTTON40016                  40016
#define ID_BUTTON40017                  40017
#define ID_BUTTON40018                  40018
#define ID_BUTTON40019                  40019
#define ID_BUTTON40020                  40020
#define ID_BUTTON40021                  40021
#define ID_BUTTONSTART                  40021
#define ID_BUTTON40022                  40022
#define ID_BUTTONPAUSE                  40022
#define ID_BUTTON40023                  40023
#define ID_BUTTONSTOP                   40023
#define ID_BUTTON40024                  40024
#define ID_BUTTON40025                  40025
#define ID_BUTTON40026                  40026

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        127
#define _APS_NEXT_COMMAND_VALUE         40027
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\tbarext\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;


// {20E42DD2-5CCF-11d3-9147-00C04F65B3F9}
DEFINE_GUID(CLSID_CToolBarExtension, 
0x20e42dd2, 0x5ccf, 0x11d3, 0x91, 0x47, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9);


// {3E66FCD0-5CCF-11d3-9147-00C04F65B3F9}
DEFINE_GUID(CLSID_CSnapinAbout, 
0x3e66fcd0, 0x5ccf, 0x11d3, 0x91, 0x47, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout, FALSE);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\tbarext\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "Extend.h"
#include "globals.h"

// list all of the nodes that we extend

EXTENDER_NODE _NodeExtensions[] = {
    {ToolBarExtension,
    {0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28}},
    {0x20e42dd2, 0x5ccf, 0x11d3, {0x91, 0x47, 0x0, 0xc0, 0x4f, 0x65, 0xb3, 0xf9}},
    _T("Extension to the Vehicle Node Toolbar")},

    {DummyExtension,
    NULL,
    NULL,
    NULL}
};

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule, 
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;
    
    assert(dwResult != 0) ;
    
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    assert(SUCCEEDED(hr)) ;

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
	_tcscat(szKey, pszCLSID) ;
    
    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;
    
    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    
    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

	MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
	_tcscat(szKey, pszT) ;
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    
    return S_OK ;
}

//
// Register the snap-in in the registry.
//

HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    LPOLESTR wszExtendCLSID = NULL;
    LPOLESTR wszNodeCLSID = NULL;
    EXTENDER_NODE *pNodeExtension;
    _TCHAR szKeyBuf[1024] ;
    HKEY hKey;


    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;
    
    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);

   
    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);
    
    if (fSupportExtensions) {
        // Build the key NodeType 
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);
        
        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }

    // register each of the node extensions
    for (pNodeExtension = &(_NodeExtensions[0]);*pNodeExtension->szDescription;pNodeExtension++)
    {
        hr = StringFromCLSID(pNodeExtension->guidNode, &wszExtendCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszExtendCLSID, wszExtendCLSID);
        _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\NodeTypes\\"));
        _tcscat(szKeyBuf, pszExtendCLSID);

        switch (pNodeExtension->eType) {
        case ToolBarExtension:
            _tcscat(szKeyBuf, _T("\\Extensions\\ToolBar"));
            break;
        default:
            break;
        }

        // Create and open key and subkey.
        long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
            szKeyBuf,
            0, NULL, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, NULL,
            &hKey, NULL) ;

        if (lResult != ERROR_SUCCESS)
        {
            return FALSE ;
        }

        hr = StringFromCLSID(pNodeExtension->guidExtension, &wszNodeCLSID);
        assert(SUCCEEDED(hr));

        MAKE_TSTRPTR_FROMWIDE(pszNodeCLSID, wszNodeCLSID);
        // Set the Value.
        if (pNodeExtension->szDescription != NULL)
        {
            RegSetValueEx(hKey, pszNodeCLSID, 0, REG_SZ,
                (BYTE *)pNodeExtension->szDescription,
                (_tcslen(pNodeExtension->szDescription)+1)*sizeof(_TCHAR)) ;
        }

        RegCloseKey(hKey) ;

        CoTaskMemFree(wszExtendCLSID);
        CoTaskMemFree(wszNodeCLSID);
    }


    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);
    
    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;
    
    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
	MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);
    
    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
	       (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.
    
    // free the memory
    CoTaskMemFree(wszCLSID);
    
    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }
    
    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }
    
    // Close the child.
    RegCloseKey(hKeyChild) ;
    
    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;
    
    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));
    
    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;
    
    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }
    
    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf, 
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL, 
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }
    
    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ, 
            (BYTE *)szValue, 
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }
    
    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\tbarext\tbarext.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _CToolBarExtension_H_
#define _CToolBarExtension_H_

#include <tchar.h>
#include <mmc.h>

class CToolBarExtension : public IExtendControlbar
{
    
private:
    ULONG			m_cref;

    IControlbar*    m_ipControlBar;
    IToolbar*       m_ipToolbar;

    enum STATUS {RUNNING, PAUSED, STOPPED} iStatus;

    HRESULT ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType );
    HRESULT ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin );
    HRESULT ExtractString( IDataObject *piDataObject,CLIPFORMAT cfClipFormat, WCHAR *pstr, DWORD cchMaxLength);
    HRESULT ExtractData( IDataObject *piDataObject,CLIPFORMAT cfClipFormat, BYTE *pbData, DWORD cbData );

	HRESULT SetToolbarButtons(STATUS iVehicleStatus);
    
    // clipboard format
    static UINT s_cfDisplayName;
    static UINT s_cfSnapInCLSID;
    static UINT s_cfNodeType;
    
public:
    CToolBarExtension();
    ~CToolBarExtension();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IExtendControlBar
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControlbar( 
    /* [in] */ LPCONTROLBAR pControlbar);
            
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ControlbarNotify( 
    /* [in] */ MMC_NOTIFY_TYPE event,
    /* [in] */ LPARAM arg,
    /* [in] */ LPARAM param);

	public:
    IToolbar *getToolbar() { return m_ipToolbar; }
};


#endif _CToolBarExtension_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\tbarext\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

                MAKE_WIDEPTR_FROMTSTR(wszName, pszName);

                // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\tbarext\tbarext.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "tbarExt.h"
#include "globals.h"
#include "resource.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "resource.h"
#include <stdio.h>

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))


// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

// These are the clipboard formats that we must supply at a minimum.
// mmc.h actually defined these. We can make up our own to use for
// other reasons. We don't need any others at this time.
UINT CToolBarExtension::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CToolBarExtension::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CToolBarExtension::s_cfSnapInCLSID = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);


CToolBarExtension::CToolBarExtension() : m_cref(0), m_ipControlBar(NULL), 
										 m_ipToolbar(NULL) 
{
    OBJECT_CREATED
}

CToolBarExtension::~CToolBarExtension()
{
    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CToolBarExtension::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IExtendControlbar *>(this);
    else if (IsEqualIID(riid, IID_IExtendControlbar))
        *ppv = static_cast<IExtendControlbar *>(this);
    
    if (*ppv) 
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }
    
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CToolBarExtension::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CToolBarExtension::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    
    return m_cref;
}

HRESULT CToolBarExtension::ExtractData( IDataObject* piDataObject,
                                           CLIPFORMAT   cfClipFormat,
                                           BYTE*        pbData,
                                           DWORD        cbData )
{
    HRESULT hr = S_OK;
    
    FORMATETC formatetc = {cfClipFormat, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    STGMEDIUM stgmedium = {TYMED_HGLOBAL, NULL};
    
    stgmedium.hGlobal = ::GlobalAlloc(GPTR, cbData);
    do // false loop
    {
        if (NULL == stgmedium.hGlobal)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
        hr = piDataObject->GetDataHere( &formatetc, &stgmedium );
        if ( FAILED(hr) )
        {
            break;
        }
        
        BYTE* pbNewData = reinterpret_cast<BYTE*>(stgmedium.hGlobal);
        if (NULL == pbNewData)
        {
            hr = E_UNEXPECTED;
            break;
        }
        ::memcpy( pbData, pbNewData, cbData );
    } while (FALSE); // false loop
    
    if (NULL != stgmedium.hGlobal)
    {
        ::GlobalFree(stgmedium.hGlobal);
    }
    return hr;
} // ExtractData()

HRESULT CToolBarExtension::ExtractString( IDataObject *piDataObject,
                                             CLIPFORMAT   cfClipFormat,
                                             WCHAR       *pstr,
                                             DWORD        cchMaxLength)
{
    return ExtractData( piDataObject, cfClipFormat, (PBYTE)pstr, cchMaxLength );
}

HRESULT CToolBarExtension::ExtractSnapInCLSID( IDataObject* piDataObject, CLSID* pclsidSnapin )
{
    return ExtractData( piDataObject, s_cfSnapInCLSID, (PBYTE)pclsidSnapin, sizeof(CLSID) );
}

HRESULT CToolBarExtension::ExtractObjectTypeGUID( IDataObject* piDataObject, GUID* pguidObjectType )
{
    return ExtractData( piDataObject, s_cfNodeType, (PBYTE)pguidObjectType, sizeof(GUID) );
}

///////////////////////////////
// Interface IExtendControlBar
///////////////////////////////
static MMCBUTTON SnapinButtons1[] =
{
    { 0, ID_BUTTONSTART, TBSTATE_ENABLED, TBSTYLE_GROUP, L"Extension - Start Vehicle", L"Extension - Start Vehicle" },
    { 1, ID_BUTTONPAUSE, TBSTATE_ENABLED, TBSTYLE_GROUP, L"Extension - Pause Vehicle", L"Extension - Pause Vehicle"},
    { 2, ID_BUTTONSTOP,  TBSTATE_ENABLED, TBSTYLE_GROUP, L"Extension - Stop Vehicle",  L"Extension - Stop Vehicle" },
};

HRESULT CToolBarExtension::SetControlbar(
                                  /* [in] */ LPCONTROLBAR pControlbar)
{
    HRESULT hr = S_OK;

	//
    //  Clean up
    //

    // if we've got a cached toolbar, release it
    if (m_ipToolbar) {
        m_ipToolbar->Release();
        m_ipToolbar = NULL;
    }

    // if we've got a cached control bar, release it
    if (m_ipControlBar) {
        m_ipControlBar->Release();
        m_ipControlBar = NULL;
    }

    //
    // Install new pieces if necessary
    //

    // if a new one came in, cache and AddRef
    if (pControlbar) {
        m_ipControlBar = pControlbar;
        m_ipControlBar->AddRef();

        hr = m_ipControlBar->Create(TOOLBAR,  // type of control to be created
            dynamic_cast<IExtendControlbar *>(this),
            reinterpret_cast<IUnknown **>(&m_ipToolbar));
        _ASSERT(SUCCEEDED(hr));

        // add the bitmap to the toolbar
        HBITMAP hbmp = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_TOOLBAR1));
        hr = m_ipToolbar->AddBitmap(3, hbmp, 16, 16, RGB(0, 128, 128)); // NOTE, hardcoded value 3
        _ASSERT(SUCCEEDED(hr));

        // Add the buttons to the toolbar
        hr = m_ipToolbar->AddButtons(ARRAYLEN(SnapinButtons1), SnapinButtons1);
        _ASSERT(SUCCEEDED(hr));
    }

    return hr;
}

HRESULT CToolBarExtension::ControlbarNotify(
                                     /* [in] */ MMC_NOTIFY_TYPE event,
                                     /* [in] */ LPARAM arg,
                                     /* [in] */ LPARAM param)
{

    _TCHAR pszMsg[255];

	BYTE *pbVehicleStatus = NULL;
    
	HRESULT hr = S_OK;
 
    if (event == MMCN_SELECT) {

		BOOL bScope = (BOOL) LOWORD(arg);
        BOOL bSelect = (BOOL) HIWORD(arg);

		if (bSelect) {

			// Always make sure the toolbar is attached
			hr = m_ipControlBar->Attach(TOOLBAR, m_ipToolbar);

			// Set button states

			//fake value to set toolbar button states
			iStatus = RUNNING;
			SetToolbarButtons(iStatus);

		} else {
			// Always make sure the toolbar is detached
			hr = m_ipControlBar->Detach(m_ipToolbar);
		}

    } else if (event == MMCN_BTN_CLICK) {
		//the arg parameter contains the data object from the primary
		//snap-in. Use it to get the display name of the currently selected item
        WCHAR pszName[255];
		HRESULT hr = ExtractString(reinterpret_cast<IDataObject *>(arg), s_cfDisplayName, pszName, sizeof(pszName));
        MAKE_TSTRPTR_FROMWIDE(ptrname, pszName);

		switch ((int)param)
		{
		case ID_BUTTONSTART:
			iStatus = RUNNING;
			break;

		case ID_BUTTONPAUSE:
			iStatus = PAUSED;
			break;

		case ID_BUTTONSTOP:
			iStatus = STOPPED;
			break;
		}
			

		_stprintf(pszMsg, _T("%s selected and extension button %s pressed"), ptrname, 
			(long)param == ID_BUTTONSTART ? _T("1") :
		(long)param == ID_BUTTONPAUSE ? _T("2") :
		(long)param == ID_BUTTONSTOP ? _T("3") : _T("!!!unknown command!!!"));

		
        ::MessageBox(NULL, pszMsg, _T("Messagebox from Toolbar Extension"), MB_OK|MB_ICONEXCLAMATION);

		//Reset toolbar button states
		SetToolbarButtons(iStatus);

    }

    return hr;
}

HRESULT CToolBarExtension::SetToolbarButtons(STATUS iVehicleStatus)
{

	HRESULT hr = S_OK;
	
	switch (iVehicleStatus)
	{
	case RUNNING:
		m_ipToolbar->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, TRUE);
		m_ipToolbar->SetButtonState(ID_BUTTONSTART, ENABLED, FALSE);
		m_ipToolbar->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, FALSE);
		m_ipToolbar->SetButtonState(ID_BUTTONPAUSE, ENABLED, TRUE);
		m_ipToolbar->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, FALSE);
		m_ipToolbar->SetButtonState(ID_BUTTONSTOP, ENABLED, TRUE);
		break;

	case PAUSED:
		m_ipToolbar->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, FALSE);
		m_ipToolbar->SetButtonState(ID_BUTTONSTART, ENABLED, TRUE);
		m_ipToolbar->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, TRUE);
		m_ipToolbar->SetButtonState(ID_BUTTONPAUSE, ENABLED, FALSE);
		m_ipToolbar->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, FALSE);
		m_ipToolbar->SetButtonState(ID_BUTTONSTOP, ENABLED, TRUE);
		break;

	case STOPPED:
		m_ipToolbar->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, FALSE);
		m_ipToolbar->SetButtonState(ID_BUTTONSTART, ENABLED, TRUE);
		m_ipToolbar->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, FALSE);
		m_ipToolbar->SetButtonState(ID_BUTTONPAUSE, ENABLED, TRUE);
		m_ipToolbar->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, TRUE);
		m_ipToolbar->SetButtonState(ID_BUTTONSTOP, ENABLED, FALSE);
		break;
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
        #define IDM_BUTTON1    0x100
        #define IDM_BUTTON2    0x101

        extern HINSTANCE g_hinst;
        extern ULONG g_uObjects;

        #define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
        #define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

        // uncomment the following #define to enable message cracking
        // #define MMC_CRACK_MESSAGES
        void MMCN_Crack(BOOL bComponentData,
                                        IDataObject *pDataObject,
                                        IComponentData *pCompData,
                                        IComponent *pComp,
                                        MMC_NOTIFY_TYPE event,
                                        LPARAM arg,
                                        LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent,
IExtendControlbar

{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    IDisplayHelp*	m_ipDisplayHelp;
    IControlbar*    m_ipControlBar;
    IToolbar*       m_ipToolbar;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
            
            ///////////////////////////////
            // Interface IExtendControlBar
            ///////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetControlbar( 
            /* [in] */ LPCONTROLBAR pControlbar);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE ControlbarNotify( 
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
    public:
        IToolbar *getToolbar() { return m_ipToolbar; }
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\land.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Land.h"

const GUID CLandBasedVehicle::thisGuid = { 0x2974380e, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CLandBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_pStaticNode = new CStaticNode;

    TCHAR tmpHelpFile[MAX_PATH];

    GetWindowsDirectory(tmpHelpFile, sizeof(tmpHelpFile));
    _tcscat(tmpHelpFile, _T("\\HELP\\"));
    LoadString(g_hinst, IDS_HELPFILE, &tmpHelpFile[_tcslen(tmpHelpFile)], MAX_PATH - _tcslen(tmpHelpFile));

	MAKE_WIDEPTR_FROMTSTR(wszHelpFile, tmpHelpFile);
	wcscpy(m_HelpFile, wszHelpFile);
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_ISnapinHelp))
        *ppv = static_cast<ISnapinHelp*>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );

    hr = pImageList->ImageListSetStrip( (long *)m_pStaticNode->m_pBMapSm, // pointer to a handle
        (long *)m_pStaticNode->m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );

    pImageList->Release();

    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
    {
    case MMCN_EXPAND:
        hr = base->OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
        break;
    }

    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName();
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////
// Interface ISnapinHelp
///////////////////////////////
HRESULT CComponentData::GetHelpTopic(
                                     /* [out] */ LPOLESTR *lpCompiledHelpFile)
{
    *lpCompiledHelpFile = static_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(m_HelpFile) + 1) * sizeof(WCHAR)));
    
    wcscpy(*lpCompiledHelpFile, m_HelpFile);
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData,
ISnapinHelp
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
    WCHAR            m_HelpFile[MAX_PATH];
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        ///////////////////////////////
        // Interface ISnapinHelp
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetHelpTopic( 
        /* [out] */ LPOLESTR __RPC_FAR *lpCompiledHelpFile);
        
public:
    // CComponent *getComponent() { return m_pComponent; }
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
        static TCHAR error[64];

        switch (verb) {
    case MMC_VERB_NONE:
                return _T("NONE");
    case MMC_VERB_OPEN:
                return _T("OPEN");
    case MMC_VERB_COPY:
                return _T("COPY");
    case MMC_VERB_PASTE:
                return _T("PASTE");
    case MMC_VERB_DELETE:
                return _T("DELETE");
    case MMC_VERB_PROPERTIES:
                return _T("PROPERTIES");
    case MMC_VERB_RENAME:
                return _T("RENAME");
    case MMC_VERB_REFRESH:
                return _T("REFRESH");
    case MMC_VERB_PRINT:
                return _T("PRINT");
    case MMC_VERB_CUT:
                return _T("CUT");
        default:
                wsprintf(error, _T("Unknown verb id %d"), verb);
                return error;
        }
}

void MMCN_Crack(BOOL bComponentData,
                IDataObject *pDataObject,
                                IComponentData *pCompData,
                                IComponent *pComp,
                MMC_NOTIFY_TYPE event,
                                LPARAM arg,
                                LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
        TCHAR message[256] = {0};

        if (bComponentData == TRUE)
                OutputDebugString(_T("IComponentData::Notify( "));
        else
                OutputDebugString(_T("IComponent::Notify( "));

        wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
        OutputDebugString(message);

    switch (event)      {
                case MMCN_ACTIVATE:
                        wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
                        break;

                case MMCN_ADD_IMAGES:
                        wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_BTN_CLICK:
                        wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
                        break;

                case MMCN_COLUMN_CLICK:
                        wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,       param);
                        break;

                case MMCN_COLUMNS_CHANGED:
                        wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
                        break;

                case MMCN_CONTEXTHELP:
                        wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
                        break;

                case MMCN_CONTEXTMENU:
                        wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
                        break;

                case MMCN_CUTORMOVE:
                        wsprintf(message, _T("MMCN_CUTORMOVE\n"));
                        break;

                case MMCN_DBLCLICK:
                        wsprintf(message, _T("MMCN_DBLCLICK\n"));
                        break;

                case MMCN_DELETE:
                        wsprintf(message, _T("MMCN_DELETE\n"));
                        break;

                case MMCN_DESELECT_ALL:
                        wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
                        break;

                case MMCN_EXPAND:
                        wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_EXPANDSYNC:
                        wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
                        break;

                case MMCN_FILTERBTN_CLICK:
                        wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
                        break;

                case MMCN_FILTER_CHANGE:
                        wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
                        break;

                case MMCN_HELP:
                        wsprintf(message, _T("MMCN_HELP\n"));
                        break;

                case MMCN_INITOCX:
                        wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
                        break;

                case MMCN_LISTPAD:
                        wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
                        break;

                case MMCN_MENU_BTNCLICK:
                        wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
                        break;

                case MMCN_MINIMIZED:
                        wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
                        break;

                case MMCN_PASTE:
                        wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
                        break;

                case MMCN_PRELOAD:
                        wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_PRINT:
                        wsprintf(message, _T("MMCN_PRINT\n"));
                        break;

                case MMCN_PROPERTY_CHANGE:
                        wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
                        break;

                case MMCN_QUERY_PASTE:
                        wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
                        break;

                case MMCN_REFRESH:
                        wsprintf(message, _T("MMCN_REFRESH\n"));
                        break;

                case MMCN_REMOVE_CHILDREN:
                        wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_RENAME:
                        wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
                        break;

                case MMCN_RESTORE_VIEW:
                        wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
                        break;

                case MMCN_SELECT:
                        wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
                        break;

                case MMCN_SHOW:
                        wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_SNAPINHELP:
                        wsprintf(message, _T("MMCN_SNAPINHELP\n"));
                        break;

                case MMCN_VIEW_CHANGE:
                        wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
                        break;
        }

        if (message[0] != 0)
                OutputDebugString(message);
        else
                OutputDebugString(_T("unknown event\n"));

#endif
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

#define ARRAYLEN(x) (sizeof(x) / sizeof((x)[0]))

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_ipDisplayHelp = NULL;
    m_ipControlBar  = NULL;
    m_ipToolbar     = NULL;
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IExtendControlbar))
        *ppv = static_cast<IExtendControlbar *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    hr = m_ipConsole->QueryInterface(IID_IDisplayHelp, (void **)&m_ipDisplayHelp);

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
    MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)      {
    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SELECT:
        // We do not set any standard verbs now.
        break;

    case MMCN_SHOW:
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    case MMCN_CONTEXTHELP:
        hr = base->OnShowContextHelp(m_ipDisplayHelp, m_pComponentData->m_HelpFile);
        break;
    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    if (m_ipDisplayHelp) {
        m_ipDisplayHelp->Release();
        m_ipDisplayHelp = NULL;
    }

    if (m_ipToolbar) {
        m_ipToolbar->Release();
        m_ipToolbar = NULL;
    }

    if (m_ipControlBar) {
        m_ipControlBar->Release();
        m_ipControlBar = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////
// Interface IExtendControlBar
///////////////////////////////
static MMCBUTTON SnapinButtons1[] =
{
    { 0, ID_BUTTONSTART, TBSTATE_ENABLED, TBSTYLE_GROUP, L"Start Vehicle", L"Start Vehicle" },
    { 1, ID_BUTTONPAUSE, TBSTATE_ENABLED, TBSTYLE_GROUP, L"Pause Vehicle", L"Pause Vehicle"},
    { 2, ID_BUTTONSTOP,  TBSTATE_ENABLED, TBSTYLE_GROUP, L"Stop Vehicle",  L"Stop Vehicle" },
};

HRESULT CComponent::SetControlbar(
                                  /* [in] */ LPCONTROLBAR pControlbar)
{
    HRESULT hr = S_OK;

    //
    //  Clean up
    //

    // if we've got a cached toolbar, release it
    if (m_ipToolbar) {
        m_ipToolbar->Release();
        m_ipToolbar = NULL;
    }

    // if we've got a cached control bar, release it
    if (m_ipControlBar) {
        m_ipControlBar->Release();
        m_ipControlBar = NULL;
    }


    //
    // Install new pieces if necessary
    //

    // if a new one came in, cache and AddRef
    if (pControlbar) {
        m_ipControlBar = pControlbar;
        m_ipControlBar->AddRef();

        hr = m_ipControlBar->Create(TOOLBAR,  // type of control to be created
            dynamic_cast<IExtendControlbar *>(this),
            reinterpret_cast<IUnknown **>(&m_ipToolbar));
        _ASSERT(SUCCEEDED(hr));

        // The IControlbar::Create AddRefs the toolbar object it created
        // so no need to do any addref on the interface.

        // add the bitmap to the toolbar
        HBITMAP hbmp = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_TOOLBAR1));
        hr = m_ipToolbar->AddBitmap(3, hbmp, 16, 16, RGB(0, 128, 128)); // NOTE, hardcoded value 3
        _ASSERT(SUCCEEDED(hr));

        // Add the buttons to the toolbar
        hr = m_ipToolbar->AddButtons(ARRAYLEN(SnapinButtons1), SnapinButtons1);
        _ASSERT(SUCCEEDED(hr));
    }

    return hr;
}

HRESULT CComponent::ControlbarNotify(
                                     /* [in] */ MMC_NOTIFY_TYPE event,
                                     /* [in] */ LPARAM arg,
                                     /* [in] */ LPARAM param)
{
    HRESULT hr = S_OK;

    if (event == MMCN_SELECT) {
        BOOL bScope = (BOOL) LOWORD(arg);
        BOOL bSelect = (BOOL) HIWORD(arg);

        CDelegationBase *base = GetOurDataObject(reinterpret_cast<IDataObject *>(param))->GetBaseNodeObject();
        hr = base->OnSetToolbar(this, m_ipControlBar, m_ipToolbar, bScope, bSelect);
    } else if (event == MMCN_BTN_CLICK) {
        CDelegationBase *base = GetOurDataObject(reinterpret_cast<IDataObject *>(arg))->GetBaseNodeObject();
        hr = base->OnToolbarCommand(this, m_ipConsole, (MMC_CONSOLE_VERB)param);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"
#include "Comp.h"
#include "CompData.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;

//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE) 
{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}

HRESULT CDelegationBase::OnShowContextHelp(IDisplayHelp *m_ipDisplayHelp, LPOLESTR helpFile)
{ 
    WCHAR topicName[MAX_PATH];
    
    wcscpy(topicName, helpFile);
    
    // we should read this from a resource file
    wcscat(topicName, L"::/default.htm");
    
    LPOLESTR pszTopic = static_cast<LPOLESTR>(CoTaskMemAlloc((wcslen(topicName) + 1) * sizeof(WCHAR)));
    
    wcscpy(pszTopic, topicName);
    
    return m_ipDisplayHelp->ShowTopic(pszTopic);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CComponent;
class CComponentData;

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnSelect(CComponent *pComponent, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnShowContextHelp(IDisplayHelp *m_ipDisplayHelp, LPOLESTR helpFile);
    virtual HRESULT OnToolbarCommand(CComponent *pComponent, IConsole *pConsole, MMC_CONSOLE_VERB verb) { return S_FALSE; }
    virtual HRESULT OnSetToolbar(CComponent *pComponent, IControlbar *pControlbar, IToolbar *pToolbar, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    virtual HRESULT OnButtonClicked(CComponent *pComponent) { return S_FALSE;}
    
public:
    void SetComponentData(CComponentData *pComponentData) { m_pComponentData = pComponentData; }
    
public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
public:
    CComponentData *m_pComponentData;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\sky.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Sky.h"

const GUID CSkyBasedVehicle::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSkyBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\land.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _LAND_H
#define _LAND_H

#include "DeleBase.h"

class CLandBasedVehicle : public CDelegationBase {
public:
    CLandBasedVehicle(CComponentData *pComponentData = NULL)
    { m_pComponentData = pComponentData; }
    
    virtual ~CLandBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Land-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LANDICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    
private:
    enum { IDM_NEW_LAND = 2 };
    
    // {2974380E-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _LAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\people.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "People.h"

const GUID CPeoplePoweredVehicle::thisGuid = { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

const GUID CBicycleFolder::thisGuid = { 0xef163732, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboardFolder::thisGuid = { 0xef163733, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkateFolder::thisGuid = { 0xf6c660b0, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };

const GUID CBicycle::thisGuid = { 0xef163734, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboard::thisGuid = { 0xef163735, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkate::thisGuid = { 0xf6c660b1, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };


//==============================================================
//
// CPeoplePoweredVehicle implementation
//
//
CPeoplePoweredVehicle::CPeoplePoweredVehicle(CComponentData *pComponentData)
{
    m_pComponentData = pComponentData;

    children[0] = new CBicycleFolder;
    children[1] = new CSkateboardFolder;
    children[2] = new CIceSkateFolder;
}

CPeoplePoweredVehicle::~CPeoplePoweredVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        delete children[n];
}

HRESULT CPeoplePoweredVehicle::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;

    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |   // relativeID is valid
                SDI_CHILDREN;     // cChildren is valid

            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;

            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );

            _ASSERT( SUCCEEDED(hr) );
        }
    }

    return S_OK;
}

CBicycleFolder::CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CBicycle(n + 1);
    }
}

CBicycleFolder::~CBicycleFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CBicycleFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CIceSkateFolder::CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CIceSkate(n + 1);
    }
}

CIceSkateFolder::~CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CIceSkateFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

CSkateboardFolder::CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSkateboard(n + 1);
    }
}

CSkateboardFolder::~CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSkateboardFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                      ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

const _TCHAR *CBicycle::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Bicycle #%d"), id);

    return buf;
}

const _TCHAR *CSkateboard::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Skateboard #%d"), id);

    return buf;
}

const _TCHAR *CIceSkate::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Ice Skate #%d"), id);

    return buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\people.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _PEOPLE_H
#define _PEOPLE_H

#include "DeleBase.h"

class CBicycle : public CDelegationBase {
public:
    CBicycle(int i) : id(i) { }
    virtual ~CBicycle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CBicycleFolder : public CDelegationBase {
public:
    CBicycleFolder();
    virtual ~CBicycleFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Bicycles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CSkateboard : public CDelegationBase {
public:
    CSkateboard(int i) : id(i) { }
    virtual ~CSkateboard() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CSkateboardFolder : public CDelegationBase {
public:
    CSkateboardFolder();
    virtual ~CSkateboardFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Skateboards"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CIceSkate : public CDelegationBase {
public:
    CIceSkate(int i) : id(i) { }
    virtual ~CIceSkate() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CIceSkateFolder : public CDelegationBase {
public:
    CIceSkateFolder();
    virtual ~CIceSkateFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Ice Skates"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CPeoplePoweredVehicle : public CDelegationBase {
public:
    CPeoplePoweredVehicle(CComponentData *pComponentData = NULL);
    virtual ~CPeoplePoweredVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("People-powered Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_PEOPLE = 1 };
    
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 3 };
    CDelegationBase *children[3];
};

#endif // _PEOPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    assert(dwResult != 0) ;

    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    assert(SUCCEEDED(hr)) ;

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
        _tcscat(szKey, pszCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

        MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
        _tcscat(szKey, pszT) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,         // Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);


    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);

    if (fSupportExtensions) {
        // Build the key NodeType
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);

        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }

    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);

    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;

    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // free the memory
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

// {88249524-8AD1-11d2-8A0B-000021473128}
DEFINE_GUID(CLSID_CComponentData, 
            0x88249524, 0x8ad1, 0x11d2, 0x8a, 0xb, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28);

// {88249526-8AD1-11d2-8A0B-000021473128}
DEFINE_GUID(CLSID_CSnapinAbout, 
            0x88249526, 0x8ad1, 0x11d2, 0x8a, 0xb, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\about.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "About.h"
#include "resource.h"
#include "globals.h"
#include <crtdbg.h>

CSnapinAbout::CSnapinAbout()
: m_cref(0)
{
    OBJECT_CREATED

        m_hSmallImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMBMP), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);
    m_hLargeImage = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_LGBMP), IMAGE_BITMAP, 32, 32, LR_LOADTRANSPARENT);

    m_hSmallImageOpen = (HBITMAP)LoadImage(g_hinst, MAKEINTRESOURCE(IDB_SMOPEN), IMAGE_BITMAP, 16, 16, LR_LOADTRANSPARENT);

    m_hAppIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_ICON1));
}

CSnapinAbout::~CSnapinAbout()
{
    if (m_hSmallImage != NULL)
        FreeResource(m_hSmallImage);

    if (m_hLargeImage != NULL)
        FreeResource(m_hLargeImage);

    if (m_hSmallImageOpen != NULL)
        FreeResource(m_hSmallImageOpen);

    if (m_hAppIcon != NULL)
        FreeResource(m_hAppIcon);

    m_hSmallImage = NULL;
    m_hLargeImage = NULL;
    m_hSmallImageOpen = NULL;
    m_hAppIcon = NULL;

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CSnapinAbout::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<ISnapinAbout *>(this);
    else if (IsEqualIID(riid, IID_ISnapinAbout))
        *ppv = static_cast<ISnapinAbout *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CSnapinAbout::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CSnapinAbout::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface ISnapinAbout
///////////////////////////////
STDMETHODIMP CSnapinAbout::GetSnapinDescription(
                                                /* [out] */ LPOLESTR *lpDescription)
{
    _TCHAR szDesc[MAX_PATH];

    LoadString(g_hinst, IDS_SNAPINDESC, szDesc, sizeof(szDesc));

    return AllocOleStr(lpDescription, szDesc);
}


STDMETHODIMP CSnapinAbout::GetProvider(
                                       /* [out] */ LPOLESTR *lpName)
{
    return AllocOleStr(lpName, _T("Copyright  1998 Microsoft Corporation"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinVersion(
                                            /* [out] */ LPOLESTR *lpVersion)
{
    return AllocOleStr(lpVersion, _T("1.0"));;
}


STDMETHODIMP CSnapinAbout::GetSnapinImage(
                                          /* [out] */ HICON *hAppIcon)
{
    *hAppIcon = m_hAppIcon;

    if (*hAppIcon == NULL)
        return E_FAIL;
    else
        return S_OK;
}


STDMETHODIMP CSnapinAbout::GetStaticFolderImage(
                                                /* [out] */ HBITMAP *hSmallImage,
                                                /* [out] */ HBITMAP *hSmallImageOpen,
                                                /* [out] */ HBITMAP *hLargeImage,
                                                /* [out] */ COLORREF *cMask)
{
    *hSmallImage = m_hSmallImage;
    *hLargeImage = m_hLargeImage;

    *hSmallImageOpen = m_hSmallImageOpen;

    *cMask = RGB(0, 128, 128);

    if (*hSmallImage == NULL || *hLargeImage == NULL || *hSmallImageOpen == NULL)
        return E_FAIL;
    else
        return S_OK;
}

// this allocates a chunk of memory using CoTaskMemAlloc and copies our chars into it
HRESULT CSnapinAbout::AllocOleStr(LPOLESTR *lpDest, _TCHAR *szBuffer)
{
        MAKE_WIDEPTR_FROMTSTR_ALLOC(wszStr, szBuffer);
        *lpDest = wszStr;


    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\help source\mmcsample.h ===
//
// MMCSample.h
//
//   Contains header information for HTML API calls
//  so that our sample MMC snap-ins can find help information
//
#define HELP_STEPONE    101
#define HELP_STEPTWO    102
#define HELP_STEPTHREE  103
#define HELP_STEPFOUR   104

#define HELP_DEFAULT    0
#define HELP_INTRO      1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resources.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDI_ICON1                       108
#define IDR_TOOLBAR1                    112
#define IDB_SMOPEN                      116
#define IDB_SMBMP                       117
#define IDB_LGBMP                       118
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015
#define ID_COMMAND_COMMAND1             40016
#define ID_COMMAND_COMMAND2             40017
#define ID_COMMAND_COMMAND3             40018
#define ID_COMMAND_COMMAND4             40020
#define ID_BUTTONSTART                  40021
#define ID_BUTTONPAUSE                  40022
#define ID_BUTTONSTOP                   40023


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        119
#define _APS_NEXT_COMMAND_VALUE         40024
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\about.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPABOUT_H_
#define _SAMPABOUT_H_

#include <tchar.h>
#include <mmc.h>

class CSnapinAbout : public ISnapinAbout
{
private:
    ULONG				m_cref;
    HBITMAP				m_hSmallImage;
    HBITMAP				m_hLargeImage;
    HBITMAP				m_hSmallImageOpen;
    HICON				m_hAppIcon;
    
public:
    CSnapinAbout();
    ~CSnapinAbout();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface ISnapinAbout
    ///////////////////////////////
    STDMETHODIMP GetSnapinDescription( 
        /* [out] */ LPOLESTR *lpDescription);
        
        STDMETHODIMP GetProvider( 
        /* [out] */ LPOLESTR *lpName);
        
        STDMETHODIMP GetSnapinVersion( 
        /* [out] */ LPOLESTR *lpVersion);
        
        STDMETHODIMP GetSnapinImage( 
        /* [out] */ HICON *hAppIcon);
        
        STDMETHODIMP GetStaticFolderImage( 
        /* [out] */ HBITMAP *hSmallImage,
        /* [out] */ HBITMAP *hSmallImageOpen,
        /* [out] */ HBITMAP *hLargeImage,
        /* [out] */ COLORREF *cMask);
        
        ///////////////////////////////
        // Private Interface 
        ///////////////////////////////
private:
    HRESULT	CSnapinAbout::AllocOleStr(
        LPOLESTR *lpDest, 
        _TCHAR *szBuffer);
};

#endif _SAMPABOUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\basesnap.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <olectl.h>
#include <initguid.h>
#include "guids.h"
#include "basesnap.h"
#include "Comp.h"
#include "CompData.h"
#include "About.h"
#include "Registry.h"

// our globals
HINSTANCE g_hinst;

BOOL WINAPI DllMain(HINSTANCE hinstDLL, 
                    DWORD fdwReason, 
                    void* lpvReserved)
{
    
    if (fdwReason == DLL_PROCESS_ATTACH) {
        g_hinst = hinstDLL;
    }
    
    return TRUE;
}


STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj)
{
    if ((rclsid != CLSID_CComponentData) && (rclsid != CLSID_CSnapinAbout))
        return CLASS_E_CLASSNOTAVAILABLE;
    
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // We can only hand out IUnknown and IClassFactory pointers.  Fail
    // if they ask for anything else.
    if (!IsEqualIID(riid, IID_IUnknown) && !IsEqualIID(riid, IID_IClassFactory))
        return E_NOINTERFACE;
    
    CClassFactory *pFactory = NULL;
    
    // make the factory passing in the creation function for the type of object they want
    if (rclsid == CLSID_CComponentData)
        pFactory = new CClassFactory(CClassFactory::COMPONENT);
    else if (rclsid == CLSID_CSnapinAbout)
        pFactory = new CClassFactory(CClassFactory::ABOUT);
    
    if (NULL == pFactory)
        return E_OUTOFMEMORY;
    
    HRESULT hr = pFactory->QueryInterface(riid, ppvObj);
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    if (g_uObjects == 0 && g_uSrvLock == 0)
        return S_OK;
    else
        return S_FALSE;
}


CClassFactory::CClassFactory(FACTORY_TYPE factoryType)
: m_cref(0), m_factoryType(factoryType)
{
    OBJECT_CREATED
}

CClassFactory::~CClassFactory()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CClassFactory::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;
    
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IClassFactory *>(this);
    else
        if (IsEqualIID(riid, IID_IClassFactory))
            *ppv = static_cast<IClassFactory *>(this);
        
        if (*ppv)
        {
            reinterpret_cast<IUnknown *>(*ppv)->AddRef();
            return S_OK;
        }
        
        return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CClassFactory::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CClassFactory::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;
}

STDMETHODIMP CClassFactory::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID * ppvObj)
{
    HRESULT  hr;
    void* pObj;
    
    if (!ppvObj)
        return E_FAIL;
    
    *ppvObj = NULL;
    
    // Our object does does not support aggregation, so we need to
    // fail if they ask us to do aggregation.
    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;
    
    if (COMPONENT == m_factoryType) {
        pObj = new CComponentData();
    } else {
        pObj = new CSnapinAbout();
    }
    
    if (!pObj)
        return E_OUTOFMEMORY;
    
    // QueryInterface will do the AddRef() for us, so we do not
    // do it in this function
    hr = ((LPUNKNOWN)pObj)->QueryInterface(riid, ppvObj);
    
    if (FAILED(hr))
        delete pObj;
    
    return hr;
}

STDMETHODIMP CClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        InterlockedIncrement((LONG *)&g_uSrvLock);
    else
        InterlockedDecrement((LONG *)&g_uSrvLock);
    
    return S_OK;
}

//////////////////////////////////////////////////////////
//
// Exported functions
//


//
// Server registration
//
STDAPI DllRegisterServer()
{
    HRESULT hr = SELFREG_E_CLASS;
    _TCHAR szName[256];
    _TCHAR szSnapInName[256];
    
    LoadString(g_hinst, IDS_NAME, szName, sizeof(szName));
    LoadString(g_hinst, IDS_SNAPINNAME, szSnapInName, sizeof(szSnapInName));
    
    _TCHAR szAboutName[256];
    
    LoadString(g_hinst, IDS_ABOUTNAME, szAboutName, sizeof(szAboutName));
    
    // register our CoClasses
    hr = RegisterServer(g_hinst, 
        CLSID_CComponentData, 
        szName);
    
    if SUCCEEDED(hr)
        hr = RegisterServer(g_hinst, 
        CLSID_CSnapinAbout, 
        szAboutName);
    
    // place the registry information for SnapIns
    if SUCCEEDED(hr)
        hr = RegisterSnapin(CLSID_CComponentData, szSnapInName, CLSID_CSnapinAbout, FALSE);
    
    return hr;
}


STDAPI DllUnregisterServer()
{
    if (UnregisterServer(CLSID_CComponentData) == S_OK)
        return UnregisterSnapin(CLSID_CComponentData);
    else
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\sky.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include "DeleBase.h"

class CSkyBasedVehicle : public CDelegationBase {
public:
    CSkyBasedVehicle(CComponentData *pComponentData = NULL)
    { m_pComponentData = pComponentData;  }
    
    virtual ~CSkyBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Sky-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    
private:
    enum { IDM_NEW_SKY = 3 };
    
    // {2974380F-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\space.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include "Space.h"
#include "Comp.h"

const GUID CSpaceVehicle::thisGuid = { 0x29743810, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CRocket::thisGuid = { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSpaceVehicle implementation
//
//
CSpaceVehicle::CSpaceVehicle(CComponentData *pComponentData)
{
    m_pComponentData = pComponentData;

    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CRocket(pComponentData);
        children[n]->Initialize(_T("Vehicle"), 500000, 265, 75000);
    }
}

CSpaceVehicle::~CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Rocket Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Rocket Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Rocket Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Rocket Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Status", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

//==============================================================
//
// CRocket implementation
//
//
CRocket::CRocket(CComponentData *pComponentData)
: szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED)
{
    m_pComponentData = pComponentData;
}

CRocket::~CRocket()
{
    if (szName)
        delete [] szName;
}

void CRocket::Initialize(_TCHAR *szName, LONG lWeight, LONG lHeight, LONG lPayload)
{
    if (szName) {
        this->szName = new _TCHAR[_tcslen(szName) + 1];
        _tcscpy(this->szName, szName);
    }

    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;
}

const _TCHAR *CRocket::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    switch (nCol) {
    case 0:
        _tcscpy(buf, szName ? szName : _T(""));
        break;

    case 1:
        _stprintf(buf, _T("%ld metric tons"), lWeight);
        break;

    case 2:
        _stprintf(buf, _T("%ld meters"), lHeight);
        break;

    case 3:
        _stprintf(buf, _T("%ld kilos"), lPayload);
        break;

    case 4:
        _stprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") :
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;

    }

    return buf;
}

HRESULT CRocket::OnSelect(CComponent *pComponent, BOOL bScope, BOOL bSelect)
{
    if (bSelect) {
        switch (iStatus)
        {
        case RUNNING:
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, ENABLED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, ENABLED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, ENABLED, TRUE);
            break;

        case PAUSED:
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, ENABLED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, ENABLED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, ENABLED, TRUE);
            break;

        case STOPPED:
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, ENABLED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, FALSE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, ENABLED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, TRUE);
            pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, ENABLED, FALSE);
            break;
        }
    }

    return S_OK;
}

HRESULT CRocket::OnButtonClicked(CComponent *pComponent)
{
    switch (iStatus)
    {
    case RUNNING:
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, TRUE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, ENABLED, FALSE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, FALSE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, ENABLED, TRUE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, FALSE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, ENABLED, TRUE);
        break;

    case PAUSED:
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, FALSE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, ENABLED, TRUE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, TRUE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, ENABLED, FALSE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, FALSE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, ENABLED, TRUE);
        break;

    case STOPPED:
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, BUTTONPRESSED, FALSE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTART, ENABLED, TRUE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, BUTTONPRESSED, FALSE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONPAUSE, ENABLED, TRUE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, BUTTONPRESSED, TRUE);
        pComponent->getToolbar()->SetButtonState(ID_BUTTONSTOP, ENABLED, FALSE);
        break;
    }

    return S_OK;
}

HRESULT CRocket::OnSetToolbar(CComponent *pComponent, IControlbar *pControlbar, IToolbar *pToolbar, BOOL bScope, BOOL bSelect)
{
    HRESULT hr = S_OK;

    if (bSelect) {
        // Always make sure the menuButton is attached
        hr = pControlbar->Attach(TOOLBAR, pToolbar);
        hr = OnSelect(pComponent, bScope, bSelect);
    } else {
        // Always make sure the toolbar is detached
        hr = pControlbar->Detach(pToolbar);
    }

    return hr;
}

HRESULT CRocket::OnToolbarCommand(CComponent *pComponent, IConsole *pConsole, MMC_CONSOLE_VERB verb)
{
    _TCHAR szVehicle[128];

    switch (verb)
    {
    case ID_BUTTONSTART:
            iStatus = RUNNING;
        break;

    case ID_BUTTONPAUSE:
        iStatus = PAUSED;
        break;

    case ID_BUTTONSTOP:
        iStatus = STOPPED;
        break;
    }

    wsprintf(szVehicle, _T("Vehicle %s has been %s"), szName,
        (long)verb == ID_BUTTONSTART ? _T("started") :
    (long)verb == ID_BUTTONPAUSE ? _T("paused") :
    (long)verb == ID_BUTTONSTOP ? _T("stopped") : _T("!!!unknown command!!!"));

    int ret = 0;
    MAKE_WIDEPTR_FROMTSTR_ALLOC(wszVehicle, szVehicle);
    pConsole->MessageBox(wszVehicle,
        L"Vehicle command", MB_OK | MB_ICONINFORMATION, &ret);

    OnButtonClicked(pComponent);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\basesnap.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#ifndef _BASESNAP_H_
#define _BASESNAP_H_

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppvObj);
STDAPI DllCanUnloadNow(void);

ULONG g_uObjects = 0;
ULONG g_uSrvLock = 0;

class CClassFactory : public IClassFactory
{
private:
    ULONG	m_cref;
    
public:
    enum FACTORY_TYPE {COMPONENT = 0, ABOUT = 1};
    
    CClassFactory(FACTORY_TYPE factoryType);
    ~CClassFactory();
    
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    STDMETHODIMP CreateInstance(LPUNKNOWN, REFIID, LPVOID *);
    STDMETHODIMP LockServer(BOOL);
    
private:
    FACTORY_TYPE m_factoryType;
};

#endif _BASESNAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\comp.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMP_H_
#define _SAMPCOMP_H_

#include <mmc.h>

class CComponent : public IComponent,
IExtendPropertySheet2
{
private:
    ULONG				m_cref;
    
    IConsole*		m_ipConsole;
    
    class CComponentData *m_pComponentData;
    
    public:
        CComponent(CComponentData *parent);
        ~CComponent();
        
        ///////////////////////////////
        // Interface IUnknown
        ///////////////////////////////
        STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        
        ///////////////////////////////
        // Interface IComponent
        ///////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
            /* [in] */ LPCONSOLE lpConsole);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ LPDATAOBJECT lpDataObject,
            /* [in] */ MMC_NOTIFY_TYPE event,
            /* [in] */ LPARAM arg,
            /* [in] */ LPARAM param);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ MMC_COOKIE cookie);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
            /* [in] */ MMC_COOKIE cookie,
            /* [in] */ DATA_OBJECT_TYPES type,
            /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetResultViewType( 
            /* [in] */ MMC_COOKIE cookie,
            /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
            /* [out] */ long __RPC_FAR *pViewOptions);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
            /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
            /* [in] */ LPDATAOBJECT lpDataObjectA,
            /* [in] */ LPDATAOBJECT lpDataObjectB);
            
            //////////////////////////////////
            // Interface IExtendPropertySheet2
            //////////////////////////////////
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
            /* [in] */ LONG_PTR handle,
            /* [in] */ LPDATAOBJECT lpIDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
            /* [in] */ LPDATAOBJECT lpDataObject);
            
            virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
            /* [in] */ LPDATAOBJECT lpIDataObject,
            /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
            /* [out] */ HBITMAP __RPC_FAR *lphHeader,
            /* [out] */ HPALETTE __RPC_FAR *lphPalette,
            /* [out] */ BOOL __RPC_FAR *bStretch);
};

#endif _SAMPCOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\compdata.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "CompData.h"
#include "DataObj.h"
#include "resource.h"
#include <crtdbg.h>

CComponentData::CComponentData()
: m_cref(0), m_ipConsoleNameSpace(NULL), m_ipConsole(NULL)
{
    OBJECT_CREATED

        m_pStaticNode = new CStaticNode;
}

CComponentData::~CComponentData()
{
    if (m_pStaticNode) {
        delete m_pStaticNode;
    }

    OBJECT_DESTROYED
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CComponentData::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponentData *>(this);
    else if (IsEqualIID(riid, IID_IComponentData))
        *ppv = static_cast<IComponentData *>(this);

    // first things first, make sure that when MMC
    // asks if we do property sheets, that we actually
    // say "yes"
    else if (IsEqualIID(riid, IID_IExtendPropertySheet) ||
        IsEqualIID(riid, IID_IExtendPropertySheet2))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponentData::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponentData::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        // we need to decrement our object count in the DLL
        delete this;
        return 0;
    }

    return m_cref;
}

///////////////////////////////
// Interface IComponentData
///////////////////////////////
HRESULT CComponentData::Initialize(
                                   /* [in] */ LPUNKNOWN pUnknown)
{
    HRESULT      hr;

    //
    // Get pointer to name space interface
    //
    hr = pUnknown->QueryInterface(IID_IConsoleNameSpace, (void **)&m_ipConsoleNameSpace);
    _ASSERT( S_OK == hr );

    //
    // Get pointer to console interface
    //
    hr = pUnknown->QueryInterface(IID_IConsole, (void **)&m_ipConsole);
    _ASSERT( S_OK == hr );

    IImageList *pImageList;
    m_ipConsole->QueryScopeImageList(&pImageList);
    _ASSERT( S_OK == hr );

    hr = pImageList->ImageListSetStrip( (long *)m_pStaticNode->m_pBMapSm, // pointer to a handle
        (long *)m_pStaticNode->m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );

    pImageList->Release();

    return S_OK;
}

HRESULT CComponentData::CreateComponent(
                                        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent)
{
    *ppComponent = NULL;

    CComponent *pComponent = new CComponent(this);

    if (NULL == pComponent)
        return E_OUTOFMEMORY;

    return pComponent->QueryInterface(IID_IComponent, (void **)ppComponent);
}

HRESULT CComponentData::Notify(
                               /* [in] */ LPDATAOBJECT lpDataObject,
                               /* [in] */ MMC_NOTIFY_TYPE event,
                               /* [in] */ LPARAM arg,
                               /* [in] */ LPARAM param)
{
    MMCN_Crack(TRUE, lpDataObject, this, NULL, event, arg, param);

    HRESULT hr = S_FALSE;

	//Get our data object. If it is NULL, we return with S_FALSE.
	//See implementation of GetOurDataObject() to see how to
	//handle special data objects.
	CDataObject *pDataObject = GetOurDataObject(lpDataObject);
	if (NULL == pDataObject)
		return S_FALSE;
	
	CDelegationBase *base = pDataObject->GetBaseNodeObject();

    switch (event)
    {
    case MMCN_EXPAND:
        hr = base->OnExpand(m_ipConsoleNameSpace, m_ipConsole, (HSCOPEITEM)param);
        break;
    }

    return hr;
}

HRESULT CComponentData::Destroy( void)
{
    // Free interfaces
    if (m_ipConsoleNameSpace) {
        m_ipConsoleNameSpace->Release();
        m_ipConsoleNameSpace = NULL;
    }

    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}

HRESULT CComponentData::QueryDataObject(
                                        /* [in] */ MMC_COOKIE cookie,
                                        /* [in] */ DATA_OBJECT_TYPES type,
                                        /* [out] */ LPDATAOBJECT *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

HRESULT CComponentData::GetDisplayInfo(
                                       /* [out][in] */ SCOPEDATAITEM *pScopeDataItem)
{
    HRESULT hr = S_FALSE;

    // if they are asking for the SDI_STR we have one of those to give
    if (pScopeDataItem->lParam) {
        CDelegationBase *base = (CDelegationBase *)pScopeDataItem->lParam;
        if (pScopeDataItem->mask & SDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName();
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pScopeDataItem->displayname = pszW;
        }

        if (pScopeDataItem->mask & SDI_IMAGE) {
            pScopeDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}

HRESULT CComponentData::CompareObjects(
                                       /* [in] */ LPDATAOBJECT lpDataObjectA,
                                       /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CComponentData::CreatePropertyPages(
                                            /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                            /* [in] */ LONG_PTR handle,
                                            /* [in] */ LPDATAOBJECT lpIDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->CreatePropertyPages(lpProvider, handle);
}

HRESULT CComponentData::QueryPagesFor(
                                      /* [in] */ LPDATAOBJECT lpDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();

    return base->HasPropertySheets();
}

HRESULT CComponentData::GetWatermarks(
                                      /* [in] */ LPDATAOBJECT lpIDataObject,
                                      /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                      /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                      /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                      /* [out] */ BOOL __RPC_FAR *bStretch)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->GetWatermarks(lphWatermark, lphHeader, lphPalette, bStretch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\space.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SPACE_H
#define _SPACE_H

#include "DeleBase.h"
#include "CompData.h"

class CRocket : public CDelegationBase {
public:
    CRocket(CComponentData *pComponentData = NULL);
    
    virtual ~CRocket();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
    void Initialize(_TCHAR *szName, LONG lWeight, LONG lHeight, LONG lPayload);
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnSelect(CComponent *pComponent, BOOL bScope, BOOL bSelect);
    virtual HRESULT OnToolbarCommand(CComponent *pComponent, IConsole *pConsole, MMC_CONSOLE_VERB verb);
    virtual HRESULT OnSetToolbar(CComponent *pComponent, IControlbar *pControlbar, IToolbar *pToolbar, BOOL bScope, BOOL bSelect);
    virtual HRESULT OnButtonClicked(CComponent *pComponent);
    
private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    enum {RUNNING, PAUSED, STOPPED} iStatus;
};

class CSpaceVehicle : public CDelegationBase {
public:
    CSpaceVehicle(CComponentData *pComponentData = NULL);
    
    virtual ~CSpaceVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Future Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    enum { IDM_NEW_SPACE = 4 };
    
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CRocket *children[NUMBER_OF_CHILDREN];
};

#endif // _SPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\compdata.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPCOMPDATA_H_
#define _SAMPCOMPDATA_H_

#include <mmc.h>
#include "DeleBase.h"
#include "StatNode.h"
#include "Comp.h"

class CComponentData : public IComponentData, IExtendPropertySheet2
{
    friend class CComponent;
    
private:
    ULONG				m_cref;
    LPCONSOLE			m_ipConsole;
    LPCONSOLENAMESPACE	m_ipConsoleNameSpace;
    
    CStaticNode     *m_pStaticNode;
    
public:
    CComponentData();
    ~CComponentData();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // Interface IComponentData
    ///////////////////////////////
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( 
        /* [in] */ LPUNKNOWN pUnknown);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateComponent( 
        /* [out] */ LPCOMPONENT __RPC_FAR *ppComponent);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
        /* [in] */ LPDATAOBJECT lpDataObject,
        /* [in] */ MMC_NOTIFY_TYPE event,
        /* [in] */ LPARAM arg,
        /* [in] */ LPARAM param);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Destroy( void);
    
    virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryDataObject( 
        /* [in] */ MMC_COOKIE cookie,
        /* [in] */ DATA_OBJECT_TYPES type,
        /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetDisplayInfo( 
        /* [out][in] */ SCOPEDATAITEM __RPC_FAR *pScopeDataItem);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CompareObjects( 
        /* [in] */ LPDATAOBJECT lpDataObjectA,
        /* [in] */ LPDATAOBJECT lpDataObjectB);
        
        //////////////////////////////////
        // Interface IExtendPropertySheet2
        //////////////////////////////////
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreatePropertyPages( 
        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
        /* [in] */ LONG_PTR handle,
        /* [in] */ LPDATAOBJECT lpIDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE QueryPagesFor( 
        /* [in] */ LPDATAOBJECT lpDataObject);
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetWatermarks( 
        /* [in] */ LPDATAOBJECT lpIDataObject,
        /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
        /* [out] */ HBITMAP __RPC_FAR *lphHeader,
        /* [out] */ HPALETTE __RPC_FAR *lphPalette,
        /* [out] */ BOOL __RPC_FAR *bStretch);
};

#endif _SAMPCOMPDATA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\dataobj.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DataObj.h"
#include "guids.h"
#include "DeleBase.h"

//
// This is the minimum set of clipboard formats we must implement.
// MMC uses these to get necessary information from our snapin about
// our nodes.
//

// we need to do this to get around MMC.IDL - it explicitly defines
// the clipboard formats as WCHAR types...
#define _T_CCF_DISPLAY_NAME _T("CCF_DISPLAY_NAME")
#define _T_CCF_NODETYPE _T("CCF_NODETYPE")
#define _T_CCF_SZNODETYPE _T("CCF_SZNODETYPE")
#define _T_CCF_SNAPIN_CLASSID _T("CCF_SNAPIN_CLASSID")

#define _T_CCF_INTERNAL_SNAPIN _T("{2479DB32-5276-11d2-94F5-00C04FB92EC2}")

    // These are the clipboard formats that we must supply at a minimum.
    // mmc.h actually defined these. We can make up our own to use for
    // other reasons. We don't need any others at this time.
UINT CDataObject::s_cfDisplayName = RegisterClipboardFormat(_T_CCF_DISPLAY_NAME);
UINT CDataObject::s_cfNodeType    = RegisterClipboardFormat(_T_CCF_NODETYPE);
UINT CDataObject::s_cfSZNodeType  = RegisterClipboardFormat(_T_CCF_SZNODETYPE);
UINT CDataObject::s_cfSnapinClsid = RegisterClipboardFormat(_T_CCF_SNAPIN_CLASSID);
UINT CDataObject::s_cfInternal    = RegisterClipboardFormat(_T_CCF_INTERNAL_SNAPIN);


CDataObject::CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context)
: m_lCookie(cookie), m_context(context), m_cref(0)
{
}

CDataObject::~CDataObject()
{
}

///////////////////////
// IUnknown implementation
///////////////////////

STDMETHODIMP CDataObject::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IDataObject *>(this);
    else if (IsEqualIID(riid, IID_IDataObject))
        *ppv = static_cast<IDataObject *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataObject::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CDataObject::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

/////////////////////////////////////////////////////////////////////////////
// IDataObject implementation
//
HRESULT CDataObject::GetDataHere(
                                 FORMATETC *pFormatEtc,     // [in]  Pointer to the FORMATETC structure
                                 STGMEDIUM *pMedium         // [out] Pointer to the STGMEDIUM structure
                                 )
{
    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    IStream *pStream = NULL;

    CDelegationBase *base = GetBaseNodeObject();

    HRESULT hr = CreateStreamOnHGlobal( pMedium->hGlobal, FALSE, &pStream );
    if ( FAILED(hr) )
        return hr;                       // Minimal error checking

    hr = DV_E_FORMATETC;                 // Unknown format

    if (cf == s_cfDisplayName) {
        const _TCHAR *pszName = base->GetDisplayName();

                MAKE_WIDEPTR_FROMTSTR(wszName, pszName);

                // get length of original string and convert it accordingly
        ULONG ulSizeofName = lstrlen(pszName);
        ulSizeofName++;                      // Count null character
        ulSizeofName *= sizeof(WCHAR);

        hr = pStream->Write(wszName, ulSizeofName, NULL);
    } else if (cf == s_cfNodeType) {
        const GUID *pGUID = (const GUID *)&base->getNodeType();

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfSZNodeType) {
        LPOLESTR szGuid;
        hr = StringFromCLSID(base->getNodeType(), &szGuid);

        if (SUCCEEDED(hr)) {
            hr = pStream->Write(szGuid, wcslen(szGuid), NULL);
            CoTaskMemFree(szGuid);
        }
    } else if (cf == s_cfSnapinClsid) {
        const GUID *pGUID = NULL;
        pGUID = &CLSID_CComponentData;

        hr = pStream->Write(pGUID, sizeof(GUID), NULL);
    } else if (cf == s_cfInternal) {
        // we are being asked to get our this pointer from the IDataObject interface
        // only our own snap-in objects will know how to do this.
        CDataObject *pThis = this;
        hr = pStream->Write( &pThis, sizeof(CDataObject*), NULL );
    }

    pStream->Release();

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Global helper functions to help work with dataobjects and
// clipboard formats


//---------------------------------------------------------------------------
//  Returns the current object based on the s_cfInternal clipboard format
//
CDataObject* GetOurDataObject (
                               LPDATAOBJECT lpDataObject      // [in] IComponent pointer
                               )
{
    HRESULT       hr      = S_OK;
    CDataObject *pSDO     = NULL;

	// check to see if the data object is a special data object.
	if ( IS_SPECIAL_DATAOBJECT (lpDataObject) )
	{
		//Code for handling a special data object goes here.

		//Note that the MMC SDK samples do not handle
		//special data objects, so we exit if we get one.
		return NULL;
	}

    STGMEDIUM stgmedium = { TYMED_HGLOBAL,  NULL  };
    FORMATETC formatetc = { CDataObject::s_cfInternal, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL };

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc( GMEM_SHARE, sizeof(CDataObject *));

    if (!stgmedium.hGlobal)     {
        hr = E_OUTOFMEMORY;
    }

    if SUCCEEDED(hr)
        // Attempt to get data from the object
        hr = lpDataObject->GetDataHere( &formatetc, &stgmedium );

    // stgmedium now has the data we need
    if (SUCCEEDED(hr))  {
        pSDO = *(CDataObject **)(stgmedium.hGlobal);
    }

    // if we have memory free it
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);

    return pSDO;

} // end GetOurDataObject()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\dataobj.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SAMPDATAOBJECT_H_
#define _SAMPDATAOBJECT_H_

#include <mmc.h>
#include "DeleBase.h"

class CDataObject : public IDataObject
{
private:
    ULONG				m_cref;
    MMC_COOKIE			m_lCookie;
    DATA_OBJECT_TYPES   m_context;
    
public:
    CDataObject(MMC_COOKIE cookie, DATA_OBJECT_TYPES context);
    ~CDataObject();
    
    ///////////////////////////////
    // Interface IUnknown
    ///////////////////////////////
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    
    ///////////////////////////////
    // IDataObject methods 
    ///////////////////////////////
    STDMETHODIMP GetDataHere (FORMATETC *pformatetc, STGMEDIUM *pmedium);
    
    // The rest are not implemented
    STDMETHODIMP GetData (LPFORMATETC lpFormatetcIn, LPSTGMEDIUM lpMedium)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumFormatEtc (DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
    { return E_NOTIMPL; };
    
    STDMETHODIMP QueryGetData (LPFORMATETC lpFormatetc) 
    { return E_NOTIMPL; };
    
    STDMETHODIMP GetCanonicalFormatEtc (LPFORMATETC lpFormatetcIn, LPFORMATETC lpFormatetcOut)
    { return E_NOTIMPL; };
    
    STDMETHODIMP SetData (LPFORMATETC lpFormatetc, LPSTGMEDIUM lpMedium, BOOL bRelease)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DAdvise (LPFORMATETC lpFormatetc, DWORD advf, LPADVISESINK pAdvSink, LPDWORD pdwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP DUnadvise (DWORD dwConnection)
    { return E_NOTIMPL; };
    
    STDMETHODIMP EnumDAdvise (LPENUMSTATDATA* ppEnumAdvise)
    { return E_NOTIMPL; };
    
    ///////////////////////////////
    // Custom Methods
    ///////////////////////////////
    
    CDelegationBase *GetBaseNodeObject() {
        return (CDelegationBase *)m_lCookie;
    }
    
    DATA_OBJECT_TYPES GetContext() {
        return m_context;
    }
    
public:
    // clipboard formats
    static UINT s_cfSZNodeType;
    static UINT s_cfDisplayName;
    static UINT s_cfNodeType;
    static UINT s_cfSnapinClsid;
    static UINT s_cfInternal;
    
};

HRESULT ExtractFromDataObject(IDataObject *lpDataObject,UINT cf,ULONG cb,HGLOBAL *phGlobal);
CDataObject* GetOurDataObject(IDataObject *lpDataObject);
BOOL IsMMCMultiSelectDataObject(IDataObject *lpDataObject);

#endif _SAMPDATAOBJECT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\delebase.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "DeleBase.h"

const GUID CDelegationBase::thisGuid = { 0x2974380b, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

HBITMAP CDelegationBase::m_pBMapSm = NULL;
HBITMAP CDelegationBase::m_pBMapLg = NULL;


//==============================================================
//
// CDelegationBase implementation
//
//
CDelegationBase::CDelegationBase() 
: bExpanded(FALSE) 
{ 
    if (NULL == m_pBMapSm || NULL == m_pBMapLg)
        LoadBitmaps(); 
}

CDelegationBase::~CDelegationBase() 
{ 
}

// CDelegationBase::AddImages sets up the collection of images to be displayed
// by the IComponent in the result pane as a result of its MMCN_SHOW handler
HRESULT CDelegationBase::OnAddImages(IImageList *pImageList, HSCOPEITEM hsi) 
{
    return pImageList->ImageListSetStrip((long *)m_pBMapSm, // pointer to a handle
        (long *)m_pBMapLg, // pointer to a handle
        0, // index of the first image in the strip
        RGB(0, 128, 128)  // color of the icon mask
        );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\delebase.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _BRANCHES_H
#define _BRANCHES_H

#include <mmc.h>
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "LocalRes.h"

class CDelegationBase {
public:
    CDelegationBase();
    virtual ~CDelegationBase();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) = 0;
    virtual const GUID & getNodeType() { _ASSERT(FALSE); return IID_NULL; }
    
    virtual const LPARAM GetCookie() { return reinterpret_cast<LPARAM>(this); }
    virtual const int GetBitmapIndex() = 0;
    
    virtual HRESULT GetResultViewType(LPOLESTR *ppViewType, long *pViewOptions) { return S_FALSE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent) { return S_FALSE; }
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem) { return S_FALSE; }
    virtual HRESULT OnAddImages(IImageList *pImageList, HSCOPEITEM hsi);
    virtual HRESULT OnRename(LPOLESTR pszNewName) { return S_FALSE; }
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect) { return S_FALSE; }
    
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider,
        LONG_PTR handle) { return S_FALSE; }
    virtual HRESULT HasPropertySheets() { return S_FALSE; }
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
        HBITMAP *lphHeader,
        HPALETTE *lphPalette,
        BOOL *bStretch) { return S_FALSE; }
    
    virtual HRESULT OnPropertyChange(IConsole *pConsole) { return S_OK; }
    
public:
    static HBITMAP m_pBMapSm;
    static HBITMAP m_pBMapLg;
    
protected:
    static void LoadBitmaps() {
        m_pBMapSm = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_SMICONS));
        m_pBMapLg = LoadBitmap(g_hinst, MAKEINTRESOURCE(IDR_LGICONS));
    }
    
    BOOL bExpanded;
    
private:
    // {2974380B-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _BRANCHES_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\globals.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _MMC_GLOBALS_H
#define _MMC_GLOBALS_H

#include <tchar.h>

#ifndef STRINGS_ONLY
        #define IDM_BUTTON1    0x100
        #define IDM_BUTTON2    0x101

        extern HINSTANCE g_hinst;
        extern ULONG g_uObjects;

        #define OBJECT_CREATED InterlockedIncrement((long *)&g_uObjects);
        #define OBJECT_DESTROYED InterlockedDecrement((long *)&g_uObjects);

        // uncomment the following #define to enable message cracking
        // #define MMC_CRACK_MESSAGES
        void MMCN_Crack(BOOL bComponentData,
                                        IDataObject *pDataObject,
                                        IComponentData *pCompData,
                                        IComponent *pComp,
                                        MMC_NOTIFY_TYPE event,
                                        LPARAM arg,
                                        LPARAM param);
#endif

//=--------------------------------------------------------------------------=
// allocates a temporary buffer that will disappear when it goes out of scope
// NOTE: be careful of that -- make sure you use the string in the same or
// nested scope in which you created this buffer. people should not use this
// class directly.  use the macro(s) below.
//
class TempBuffer {
  public:
    TempBuffer(ULONG cBytes) {
        m_pBuf = (cBytes <= 120) ? &m_szTmpBuf : HeapAlloc(GetProcessHeap(), 0, cBytes);
        m_fHeapAlloc = (cBytes > 120);
    }
    ~TempBuffer() {
        if (m_pBuf && m_fHeapAlloc) HeapFree(GetProcessHeap(), 0, m_pBuf);
    }
    void *GetBuffer() {
        return m_pBuf;
    }

  private:
    void *m_pBuf;
    // we'll use this temp buffer for small cases.
    //
    char  m_szTmpBuf[120];
    unsigned m_fHeapAlloc:1;
};

//=--------------------------------------------------------------------------=
// string helpers.
//
// given a _TCHAR, copy it into a wide buffer.
// be careful about scoping when using this macro!
//
// how to use the below two macros:
//
//  ...
//  LPTSTR pszT;
//  pszT = MyGetTStringRoutine();
//  MAKE_WIDEPTR_FROMSTR(pwsz, pszT);
//  MyUseWideStringRoutine(pwsz);
//  ...
#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPWSTR)__TempBuffer##ptrname.GetBuffer(), tstr); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, (LPWSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname); \
    LPWSTR ptrname = (LPWSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#ifdef UNICODE
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenW(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    lstrcpyW((LPWSTR)ptrname, tstr)
#else // ANSI
#define MAKE_WIDEPTR_FROMTSTR_ALLOC(ptrname, tstr) \
    long __l##ptrname = (lstrlenA(tstr) + 1) * sizeof(WCHAR); \
    LPWSTR ptrname = (LPWSTR)CoTaskMemAlloc(__l##ptrname); \
    MultiByteToWideChar(CP_ACP, 0, tstr, -1, ptrname, __l##ptrname)
#endif

//
// similarily for MAKE_TSTRPTR_FROMWIDE.  note that the first param does not
// have to be declared, and no clean up must be done.
//
// * 2 for DBCS handling in below length computation
//
#ifdef UNICODE
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    lstrcpyW((LPTSTR)__TempBuffer##ptrname.GetBuffer(), widestr); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#else // ANSI
#define MAKE_TSTRPTR_FROMWIDE(ptrname, widestr) \
    long __l##ptrname = (wcslen(widestr) + 1) * 2 * sizeof(TCHAR); \
    TempBuffer __TempBuffer##ptrname(__l##ptrname); \
    WideCharToMultiByte(CP_ACP, 0, widestr, -1, (LPSTR)__TempBuffer##ptrname.GetBuffer(), __l##ptrname, NULL, NULL); \
    LPTSTR ptrname = (LPTSTR)__TempBuffer##ptrname.GetBuffer()
#endif

#endif // _MMC_GLOBALS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode(CComponentData *pComponentData = NULL);
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};

#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\toolbar\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

#include "People.h"
#include "Sky.h"
#include "Land.h"
#include "Space.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode(CComponentData *pComponentData)
{
    m_pComponentData = pComponentData;
    
    children[0] = new CPeoplePoweredVehicle(pComponentData);
    children[1] = new CLandBasedVehicle(pComponentData);
    children[2] = new CSkyBasedVehicle(pComponentData);
    children[3] = new CSpaceVehicle(pComponentData);
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT    |
                SDI_CHILDREN;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = (n == 0); // only the first child has children
            // in this sample
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
        
        bExpanded = TRUE;
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\land.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Land.h"

const GUID CLandBasedVehicle::thisGuid = { 0x2974380e, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CLandBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\land.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _LAND_H
#define _LAND_H

#include "DeleBase.h"

class CLandBasedVehicle : public CDelegationBase {
public:
    CLandBasedVehicle() { }
    
    virtual ~CLandBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Land-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_LANDICON; }
    
private:
    enum { IDM_NEW_LAND = 2 };
    
    // {2974380E-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _LAND_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\localres.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __LocalResource_H__
#define __LocalResource_H__

#define INDEX_NONE          -1
#define INDEX_SPACEICON     0
#define INDEX_LANDICON      1
#define INDEX_SKYICON       2
#define INDEX_PEOPLEICON    3
#define INDEX_CLOSEDFOLDER  4
#define INDEX_OPENFOLDER    5

#endif // __LocalResource_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\mmccrack.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <mmc.h>
#include <winuser.h>
#include <tchar.h>

#include "globals.h"

static TCHAR *MMCN_CrackVerb(MMC_CONSOLE_VERB verb)
{
        static TCHAR error[64];

        switch (verb) {
    case MMC_VERB_NONE:
                return _T("NONE");
    case MMC_VERB_OPEN:
                return _T("OPEN");
    case MMC_VERB_COPY:
                return _T("COPY");
    case MMC_VERB_PASTE:
                return _T("PASTE");
    case MMC_VERB_DELETE:
                return _T("DELETE");
    case MMC_VERB_PROPERTIES:
                return _T("PROPERTIES");
    case MMC_VERB_RENAME:
                return _T("RENAME");
    case MMC_VERB_REFRESH:
                return _T("REFRESH");
    case MMC_VERB_PRINT:
                return _T("PRINT");
    case MMC_VERB_CUT:
                return _T("CUT");
        default:
                wsprintf(error, _T("Unknown verb id %d"), verb);
                return error;
        }
}

void MMCN_Crack(BOOL bComponentData,
                IDataObject *pDataObject,
                                IComponentData *pCompData,
                                IComponent *pComp,
                MMC_NOTIFY_TYPE event,
                                LPARAM arg,
                                LPARAM param)
{
#ifdef MMC_CRACK_MESSAGES
        TCHAR message[256] = {0};

        if (bComponentData == TRUE)
                OutputDebugString(_T("IComponentData::Notify( "));
        else
                OutputDebugString(_T("IComponent::Notify( "));

        wsprintf(message, _T("DataObject: %08x, CompData: %08x, Comp: %08x ) - "), pDataObject, pCompData, pComp);
        OutputDebugString(message);

    switch (event)      {
                case MMCN_ACTIVATE:
                        wsprintf(message, _T("MMCN_ACTIVATE\n\tActivate: %d\n"), arg);
                        break;

                case MMCN_ADD_IMAGES:
                        wsprintf(message, _T("MMCN_ADD_IMAGES\n\tImage List: %08x\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_BTN_CLICK:
                        wsprintf(message, _T("MMCN_BTN_CLICK\n\tVerb: %ws\n"), MMCN_CrackVerb((MMC_CONSOLE_VERB)param));
                        break;

                case MMCN_COLUMN_CLICK:
                        wsprintf(message, _T("MMCN_COLUMN_CLICK\n\tColumn: %d\n\tSort Option: %d\n"), arg,       param);
                        break;

                case MMCN_COLUMNS_CHANGED:
                        wsprintf(message, _T("MMCN_COLUMNS_CHANGED\n"));
                        break;

                case MMCN_CONTEXTHELP:
                        wsprintf(message, _T("MMCN_CONTEXTHELP\n"));
                        break;

                case MMCN_CONTEXTMENU:
                        wsprintf(message, _T("MMCN_CONTEXTMENU\n"));
                        break;

                case MMCN_CUTORMOVE:
                        wsprintf(message, _T("MMCN_CUTORMOVE\n"));
                        break;

                case MMCN_DBLCLICK:
                        wsprintf(message, _T("MMCN_DBLCLICK\n"));
                        break;

                case MMCN_DELETE:
                        wsprintf(message, _T("MMCN_DELETE\n"));
                        break;

                case MMCN_DESELECT_ALL:
                        wsprintf(message, _T("MMCN_DESELECT_ALL\n"));
                        break;

                case MMCN_EXPAND:
                        wsprintf(message, _T("MMCN_EXPAND\n\tExpand: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_EXPANDSYNC:
                        wsprintf(message, _T("MMCN_EXPANDSYNC\n"));
                        break;

                case MMCN_FILTERBTN_CLICK:
                        wsprintf(message, _T("MMCN_FILTERBTN_CLICK\n\tColumn: %d\n"), arg);
                        break;

                case MMCN_FILTER_CHANGE:
                        wsprintf(message, _T("MMCN_FILTER_CHANGE\n\tColumn: %d\n"), param);
                        break;

                case MMCN_HELP:
                        wsprintf(message, _T("MMCN_HELP\n"));
                        break;

                case MMCN_INITOCX:
                        wsprintf(message, _T("MMCN_INITOCX\n\tIUnknown: %08x\n"), param);
                        break;

                case MMCN_LISTPAD:
                        wsprintf(message, _T("MMCN_LISTPAD\n\tConnect: %d\n"), arg);
                        break;

                case MMCN_MENU_BTNCLICK:
                        wsprintf(message, _T("MMCN_MENU_BTNCLICK\n"));
                        break;

                case MMCN_MINIMIZED:
                        wsprintf(message, _T("MMCN_MINIMIZED\n\tMinimized: %d\n"), arg);
                        break;

                case MMCN_PASTE:
                        wsprintf(message, _T("MMCN_PASTE\n\tCopy: %d\n"), param == NULL);
                        break;

                case MMCN_PRELOAD:
                        wsprintf(message, _T("MMCN_PRELOAD\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_PRINT:
                        wsprintf(message, _T("MMCN_PRINT\n"));
                        break;

                case MMCN_PROPERTY_CHANGE:
                        wsprintf(message, _T("MMCN_PROPERTY_CHANGE\n\tScope: %d\n\tArg: %08x\n"), arg, param);
                        break;

                case MMCN_QUERY_PASTE:
                        wsprintf(message, _T("MMCN_QUERY_PASTE\n"));
                        break;

                case MMCN_REFRESH:
                        wsprintf(message, _T("MMCN_REFRESH\n"));
                        break;

                case MMCN_REMOVE_CHILDREN:
                        wsprintf(message, _T("MMCN_REMOVE_CHILDREN\n\tScope Item: %08x\n"), arg);
                        break;

                case MMCN_RENAME:
                        wsprintf(message, _T("MMCN_RENAME\n\tNew Name: '%ws'\n"), (LPOLESTR)param);
                        break;

                case MMCN_RESTORE_VIEW:
                        wsprintf(message, _T("MMCN_RESTORE_VIEW\n"));
                        break;

                case MMCN_SELECT:
                        wsprintf(message, _T("MMCN_SELECT\n\tScope: %d\n\tSelect: %08x\n"), LOWORD(arg), HIWORD(arg));
                        break;

                case MMCN_SHOW:
                        wsprintf(message, _T("MMCN_SHOW\n\tShow: %d\n\tScope Item: %08x\n"), arg, param);
                        break;

                case MMCN_SNAPINHELP:
                        wsprintf(message, _T("MMCN_SNAPINHELP\n"));
                        break;

                case MMCN_VIEW_CHANGE:
                        wsprintf(message, _T("MMCN_VIEW_CHANGE\n\tData: %08x\n\tHint: %08x\n"), arg, param);
                        break;
        }

        if (message[0] != 0)
                OutputDebugString(message);
        else
                OutputDebugString(_T("unknown event\n"));

#endif
        return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\registry.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef __Registry_H__
#define __Registry_H__

#include <tchar.h>

// This function will register a component in the Registry.
// The component calls this function from its DllRegisterServer function.
HRESULT RegisterServer(HMODULE hModule, 
                       const CLSID& clsid, 
                       const _TCHAR* szFriendlyName) ;

// This function will unregister a component.  Components
// call this function from their DllUnregisterServer function.
HRESULT UnregisterServer(const CLSID& clsid) ;


// This function will register a Snap-In component.  Components
// call this function from their DllRegisterServer function.
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,		// Class Id for About Class
                       const BOOL fSupportExtensions = FALSE);

HRESULT UnregisterSnapin(const CLSID& clsid);         // Class ID

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\comp.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Comp.h"
#include "DataObj.h"
#include <commctrl.h>        // Needed for button styles...
#include <crtdbg.h>
#include "globals.h"
#include "resource.h"
#include "DeleBase.h"
#include "CompData.h"

CComponent::CComponent(CComponentData *parent)
: m_pComponentData(parent), m_cref(0), m_ipConsole(NULL)
{
    OBJECT_CREATED
}

CComponent::~CComponent()
{
    OBJECT_DESTROYED
}

STDMETHODIMP CComponent::QueryInterface(REFIID riid, LPVOID *ppv)
{
    if (!ppv)
        return E_FAIL;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
        *ppv = static_cast<IComponent *>(this);
    else if (IsEqualIID(riid, IID_IComponent))
        *ppv = static_cast<IComponent *>(this);

    // first things first, make sure that when MMC
    // asks if we do property sheets, that we actually
    // say "yes"
    else if (IsEqualIID(riid, IID_IExtendPropertySheet))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);
    else if (IsEqualIID(riid, IID_IExtendPropertySheet2))
        *ppv = static_cast<IExtendPropertySheet2 *>(this);

    if (*ppv)
    {
        reinterpret_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CComponent::AddRef()
{
    return InterlockedIncrement((LONG *)&m_cref);
}

STDMETHODIMP_(ULONG) CComponent::Release()
{
    if (InterlockedDecrement((LONG *)&m_cref) == 0)
    {
        delete this;
        return 0;
    }
    return m_cref;

}

///////////////////////////////
// Interface IComponent
///////////////////////////////
STDMETHODIMP CComponent::Initialize(
                                    /* [in] */ LPCONSOLE lpConsole)
{
    HRESULT hr = S_OK;

    // Save away all the interfaces we'll need.
    // Fail if we can't QI the required interfaces.

    m_ipConsole = lpConsole;
    m_ipConsole->AddRef();

    return hr;
}

STDMETHODIMP CComponent::Notify(
                                /* [in] */ LPDATAOBJECT lpDataObject,
                                /* [in] */ MMC_NOTIFY_TYPE event,
                                /* [in] */ LPARAM arg,
                                /* [in] */ LPARAM param)
{
        MMCN_Crack(FALSE, lpDataObject, NULL, this, event, arg, param);

    HRESULT hr = S_FALSE;
    CDelegationBase *base = NULL;

    // we need to watch for property change and delegate it
    // a little differently, we're actually going to send
    // the CDelegationBase object pointer in the property page
    // PSN_APPLY handler via MMCPropPageNotify()
    if (MMCN_PROPERTY_CHANGE != event) {
        if (NULL == lpDataObject)
            return S_FALSE;

        base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();
    } else {
        base = (CDelegationBase *)param;
    }

    switch (event)      {
    case MMCN_SHOW:
        hr = base->OnShow(m_ipConsole, (BOOL)arg, (HSCOPEITEM)param);
        break;

    case MMCN_ADD_IMAGES:
        hr = base->OnAddImages((IImageList *)arg, (HSCOPEITEM)param);
        break;

    case MMCN_SELECT:
        hr = base->OnSelect(m_ipConsole, (BOOL)LOWORD(arg), (BOOL)HIWORD(arg));
        break;

    case MMCN_RENAME:
        hr = base->OnRename((LPOLESTR)param);
        break;

    // handle the property change notification if we need to do anything
    // special with it
    case MMCN_PROPERTY_CHANGE:
        hr = base->OnPropertyChange(m_ipConsole);
        break;
    }

    return hr;
}

STDMETHODIMP CComponent::Destroy(
                                 /* [in] */ MMC_COOKIE cookie)
{
    if (m_ipConsole) {
        m_ipConsole->Release();
        m_ipConsole = NULL;
    }

    return S_OK;
}


STDMETHODIMP CComponent::QueryDataObject(
                                         /* [in] */ MMC_COOKIE cookie,
                                         /* [in] */ DATA_OBJECT_TYPES type,
                                         /* [out] */ LPDATAOBJECT __RPC_FAR *ppDataObject)
{
    CDataObject *pObj = NULL;

    if (cookie == 0)
        pObj = new CDataObject((MMC_COOKIE)m_pComponentData->m_pStaticNode, type);
    else
        pObj = new CDataObject(cookie, type);

    if (!pObj)
        return E_OUTOFMEMORY;

    pObj->QueryInterface(IID_IDataObject, (void **)ppDataObject);

    return S_OK;
}

STDMETHODIMP CComponent::GetResultViewType(
                                           /* [in] */ MMC_COOKIE cookie,
                                           /* [out] */ LPOLESTR __RPC_FAR *ppViewType,
                                           /* [out] */ long __RPC_FAR *pViewOptions)
{
    CDelegationBase *base = (CDelegationBase *)cookie;

    //
    // Ask for default listview.
    //
    if (base == NULL)
    {
        *pViewOptions = MMC_VIEW_OPTIONS_NONE;
        *ppViewType = NULL;
    }
    else
        return base->GetResultViewType(ppViewType, pViewOptions);

    return S_OK;
}

STDMETHODIMP CComponent::GetDisplayInfo(
                                        /* [out][in] */ RESULTDATAITEM __RPC_FAR *pResultDataItem)
{
    HRESULT hr = S_OK;
    CDelegationBase *base = NULL;

    // if they are asking for the RDI_STR we have one of those to give

    if (pResultDataItem->lParam) {
        base = (CDelegationBase *)pResultDataItem->lParam;
        if (pResultDataItem->mask & RDI_STR) {
                        LPCTSTR pszT = base->GetDisplayName(pResultDataItem->nCol);
                        MAKE_WIDEPTR_FROMTSTR_ALLOC(pszW, pszT);
            pResultDataItem->str = pszW;
        }

        if (pResultDataItem->mask & RDI_IMAGE) {
            pResultDataItem->nImage = base->GetBitmapIndex();
        }
    }

    return hr;
}


STDMETHODIMP CComponent::CompareObjects(
                                        /* [in] */ LPDATAOBJECT lpDataObjectA,
                                        /* [in] */ LPDATAOBJECT lpDataObjectB)
{
    CDelegationBase *baseA = GetOurDataObject(lpDataObjectA)->GetBaseNodeObject();
    CDelegationBase *baseB = GetOurDataObject(lpDataObjectB)->GetBaseNodeObject();

    // compare the object pointers
    if (baseA->GetCookie() == baseB->GetCookie())
        return S_OK;

    return S_FALSE;
}

///////////////////////////////////
// Interface IExtendPropertySheet2
///////////////////////////////////
HRESULT CComponent::CreatePropertyPages(
                                        /* [in] */ LPPROPERTYSHEETCALLBACK lpProvider,
                                        /* [in] */ LONG_PTR handle,
                                        /* [in] */ LPDATAOBJECT lpIDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->CreatePropertyPages(lpProvider, handle);
}

HRESULT CComponent::QueryPagesFor(
                                  /* [in] */ LPDATAOBJECT lpDataObject)
{
    CDelegationBase *base = GetOurDataObject(lpDataObject)->GetBaseNodeObject();

    return base->HasPropertySheets();
}

HRESULT CComponent::GetWatermarks(
                                  /* [in] */ LPDATAOBJECT lpIDataObject,
                                  /* [out] */ HBITMAP __RPC_FAR *lphWatermark,
                                  /* [out] */ HBITMAP __RPC_FAR *lphHeader,
                                  /* [out] */ HPALETTE __RPC_FAR *lphPalette,
                                  /* [out] */ BOOL __RPC_FAR *bStretch)
{
    CDelegationBase *base = GetOurDataObject(lpIDataObject)->GetBaseNodeObject();

    return base->GetWatermarks(lphWatermark, lphHeader, lphPalette, bStretch);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\sky.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "Sky.h"

const GUID CSkyBasedVehicle::thisGuid = { 0x2974380f, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSkyBasedVehicle implementation
//
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\sky.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SKY_H
#define _SKY_H

#include "DeleBase.h"

class CSkyBasedVehicle : public CDelegationBase {
public:
    CSkyBasedVehicle() { }
    
    virtual ~CSkyBasedVehicle() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Sky-based Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SKYICON; }
    
private:
    enum { IDM_NEW_SKY = 3 };
    
    // {2974380F-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};


#endif // _SKY_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\space.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SPACE_H
#define _SPACE_H

#include "DeleBase.h"

class CRocket : public CDelegationBase {
public:
    CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload);
    virtual ~CRocket();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnRename(LPOLESTR pszNewName);
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
    
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle);
    virtual HRESULT HasPropertySheets();
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
        HBITMAP *lphHeader,
        HPALETTE *lphPalette,
        BOOL *bStretch);
    
    virtual HRESULT OnPropertyChange(IConsole *pConsole);
    
private:
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    _TCHAR *szName;
    LONG   lWeight;
    LONG   lHeight;
    LONG   lPayload;
    int    nId;
    enum ROCKET_STATUS {RUNNING, PAUSED, STOPPED} iStatus;
    
    LONG_PTR m_ppHandle;
    
    static BOOL CALLBACK DialogProc(
        HWND hwndDlg,  // handle to dialog box
        UINT uMsg,     // message
        WPARAM wParam, // first message parameter
        LPARAM lParam  // second message parameter
        );
    
};

class CSpaceVehicle : public CDelegationBase {
public:
    CSpaceVehicle();
    
    virtual ~CSpaceVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Future Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_SPACEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    enum { IDM_NEW_SPACE = 4 };
    
    // {29743810-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CRocket *children[NUMBER_OF_CHILDREN];
};

#endif // _SPACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\statnode.cpp ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include "StatNode.h"

#include "Space.h"
#include "Sky.h"
#include "People.h"
#include "Land.h"

const GUID CStaticNode::thisGuid = { 0x2974380c, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CStaticNode implementation
//
//
CStaticNode::CStaticNode()
{
    children[0] = new CPeoplePoweredVehicle;
    children[1] = new CLandBasedVehicle;
    children[2] = new CSkyBasedVehicle;
    children[3] = new CSpaceVehicle;
}

CStaticNode::~CStaticNode()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CStaticNode::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;
    
    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask = SDI_STR       |   // Displayname is valid
                SDI_PARAM     |   // lParam is valid
                SDI_IMAGE     |   // nImage is valid
                SDI_OPENIMAGE |   // nOpenImage is valid
                SDI_PARENT	  |
                SDI_CHILDREN;
            
            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = (n == 0); // only the first child has children
            
            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );
            
            _ASSERT( SUCCEEDED(hr) );
        }
    }
    
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\people.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//==============================================================;
#include <stdio.h>
#include "People.h"
#include <commctrl.h>
#include <comdef.h>
#include <windowsx.h>

const GUID CPeoplePoweredVehicle::thisGuid = { 0x2974380d, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

const GUID CBicycleFolder::thisGuid =    { 0xef163732, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboardFolder::thisGuid = { 0xef163733, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkateFolder::thisGuid =   { 0xf6c660b0, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };

const GUID CBicycle::thisGuid =    { 0xef163734, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CSkateboard::thisGuid = { 0xef163735, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };
const GUID CIceSkate::thisGuid =   { 0xf6c660b1, 0x9353, 0x11d2, { 0x99, 0x67, 0x0, 0x80, 0xc7, 0xdc, 0xb3, 0xdc } };


#define WM_WMI_CONNECTED WM_APP		// only sent to CBicycleFolder::m_connectHwnd
#define WM_REFRESH_EVENT WM_APP+1   // only sent to CBicycleFolder::m_connectHwnd

//==============================================================
//
// CEventSink implementation
//
class CEventSink : public IWbemObjectSink
{
public:
    CEventSink(HWND hwnd) : m_hwnd(hwnd){}
    ~CEventSink(){};

    STDMETHOD_(SCODE, Indicate)(long lObjectCount,
								IWbemClassObject **pObjArray)
	{
		// Not actually using the pObjArray. Just need a trigger for the 
		// refresh.
		::SendMessage(m_hwnd, WM_REFRESH_EVENT, 0, 0);
		return S_OK;
	}

    STDMETHOD_(SCODE, SetStatus)(long lFlags,
									HRESULT hResult,
									BSTR strParam,
									IWbemClassObject *pObjParam)
	{
		// SetStatus() may be called to indicate that your query becomes
		// invalid or valid again  ussually caused by multithreading 'situations'.
		return S_OK;
	}

    // IUnknown members
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID* ppv)
	{
		if(riid == IID_IUnknown || riid == IID_IWbemObjectSink)
		{
			*ppv = this;

			// you're handing out a copy of yourself so account for it.
			AddRef();
			return S_OK;
		}
		else 
		{
			return E_NOINTERFACE;
		}
	}
    STDMETHODIMP_(ULONG) AddRef(void)
	{
	    return InterlockedIncrement(&m_lRef);
	}
    STDMETHODIMP_(ULONG) Release(void)
	{
		// InterlockedDecrement() helps with thread safety.
		int lNewRef = InterlockedDecrement(&m_lRef);
		// when all the copies are released...
		if(lNewRef == 0)
		{
			// kill thyself.
			delete this;
		}

		return lNewRef;
	}

private:
    long m_lRef;
	HWND m_hwnd;
};

//==============================================================
//
// CPeoplePoweredVehicle implementation
//
//
//----------------------------------------------------------
#define TEMP_BUF 255

bool CBicycleFolder::ErrorString(HRESULT hr, 
								   TCHAR *errMsg, UINT errSize)
{
    TCHAR szError[TEMP_BUF] = {0};
	TCHAR szFacility[TEMP_BUF] = {0};
	IWbemStatusCodeText * pStatus = NULL;

    // initialize buffers.
	memset(errMsg, 0, errSize * sizeof(TCHAR));

	HRESULT hr1 = CoInitialize(NULL);
	SCODE sc1 = CoCreateInstance(CLSID_WbemStatusCodeText, 
								0, CLSCTX_INPROC_SERVER,
								IID_IWbemStatusCodeText, 
								(LPVOID *) &pStatus);

	// loaded OK?
	if(sc1 == S_OK)
	{
		BSTR bstr;
		sc1 = pStatus->GetErrorCodeText(hr, 0, 0, &bstr);
		if(sc1 == S_OK)
		{
#ifdef UNICODE
			wcsncpy(szError, bstr, TEMP_BUF-1);
#else
			wcstombs(szError, bstr, TEMP_BUF-1);
#endif UNICODE
			SysFreeString(bstr);
			bstr = 0;
		}

		sc1 = pStatus->GetFacilityCodeText(hr, 0, 0, &bstr);
		if(sc1 == S_OK)
		{
#ifdef UNICODE
			wcsncpy(szFacility, bstr, TEMP_BUF-1);
#else
			wcstombs(szFacility, bstr, TEMP_BUF-1);
#endif UNICODE
			SysFreeString(bstr);
			bstr = 0;
		}

		// RELEASE
		pStatus->Release();
		pStatus = NULL;
	}
	else
	{
		::MessageBox(NULL, _T("WBEM error features not available. Upgrade WMI to a newer build."),
					 _T("Internal Error"), MB_ICONSTOP|MB_OK);
	}

	// if not msgs returned....
	if(_tcslen(szFacility) == 0 || _tcslen(szError) == 0)
	{
		// format the error nbr as a reasonable default.
		_stprintf(errMsg, _T("Error code: 0x%08X"), hr);
	}
	else
	{
		// format a readable msg.
		_stprintf(errMsg, _T("%s: %s"), szFacility, szError);
	}

	if(hr1 == S_OK)
		CoUninitialize();

	return (SUCCEEDED(sc1) && SUCCEEDED(hr1));
}

CPeoplePoweredVehicle::CPeoplePoweredVehicle()
{
    children[0] = new CBicycleFolder;
    children[1] = new CSkateboardFolder;
    children[2] = new CIceSkateFolder;
}

CPeoplePoweredVehicle::~CPeoplePoweredVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        delete children[n];
}

HRESULT CPeoplePoweredVehicle::OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent)
{
    SCOPEDATAITEM sdi;

    if (!bExpanded) {
        // create the child nodes, then expand them
        for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
            ZeroMemory(&sdi, sizeof(SCOPEDATAITEM) );
            sdi.mask =	SDI_STR       |   // Displayname is valid
						SDI_PARAM     |   // lParam is valid
						SDI_IMAGE     |   // nImage is valid
						SDI_OPENIMAGE |   // nOpenImage is valid
						SDI_PARENT    |   // relativeID is valid
						SDI_CHILDREN;     // cChildren is valid

            sdi.relativeID  = (HSCOPEITEM)parent;
            sdi.nImage      = children[n]->GetBitmapIndex();
            sdi.nOpenImage  = INDEX_OPENFOLDER;
            sdi.displayname = MMC_CALLBACK;
            sdi.lParam      = (LPARAM)children[n];       // The cookie
            sdi.cChildren   = 0;

            HRESULT hr = pConsoleNameSpace->InsertItem( &sdi );

            _ASSERT( SUCCEEDED(hr) );
        }
    }

    return S_OK;
}

CBicycleFolder::CBicycleFolder() :
					m_connectHwnd(0),
					m_threadId(0), m_thread(0), 
					m_doWork(0), m_threadCmd(CT_CONNECT),
					m_running(false), m_ptrReady(0), 
					m_pStream(0), m_realWMI(0),
					m_pResultData(0), m_pStubSink(0),
					m_pUnsecApp(0)
{
    WNDCLASS wndClass;

    ZeroMemory(&wndClass, sizeof(WNDCLASS));

    wndClass.lpfnWndProc = WindowProc; 
    wndClass.lpszClassName = _T("connectthreadwindow"); 
    wndClass.hInstance = g_hinst;

    ATOM atom = RegisterClass(&wndClass);
    m_connectHwnd = CreateWindow(
						_T("connectthreadwindow"),  // pointer to registered class name
						NULL,		 // pointer to window name
						0,			 // window style
						0,           // horizontal position of window
						0,           // vertical position of window
						0,           // window width
						0,           // window height
						NULL,		 // handle to parent or owner window
						NULL,        // handle to menu or child-window identifier
						g_hinst,     // handle to application instance
						(void *)this); // pointer to window-creation data
					
    if (m_connectHwnd)
        SetWindowLong(m_connectHwnd, GWL_USERDATA, (LONG)this);

    InitializeCriticalSection(&m_critSect);
	m_doWork = CreateEvent(NULL, FALSE, FALSE, NULL);
	m_ptrReady = CreateEvent(NULL, FALSE, FALSE, NULL);

    EnterCriticalSection(&m_critSect);
	
	// NOTE: I'm connecting real early. You may want to connect from some other place.
	m_threadCmd = CT_CONNECT;
	SetEvent(m_doWork);
    m_thread = CreateThread(NULL, 0, ThreadProc, (void *)this, 0, &m_threadId);

    LeaveCriticalSection(&m_critSect);
}

CBicycleFolder::~CBicycleFolder()
{
	EmptyChildren();
	if(m_pResultData)
	{
		m_pResultData->Release();
		m_pResultData = 0;
	}

	if(m_pStubSink)
	{
		IWbemServices *service = 0;
		HRESULT hr = GetPtr(&service);
		if(SUCCEEDED(hr))
		{
			service->CancelAsyncCall(m_pStubSink);
			service->Release();
			service = 0;
		}
		m_pStubSink->Release();
		m_pStubSink = NULL;
	}

	if(m_pUnsecApp)
	{
		m_pUnsecApp->Release();
		m_pUnsecApp = 0;
	}

    StopThread();

    if(m_connectHwnd != NULL)
        DestroyWindow(m_connectHwnd);

    UnregisterClass(_T("connectthreadwindow"), NULL);
    DeleteCriticalSection(&m_critSect);
}

void CBicycleFolder::StopThread()
{
    EnterCriticalSection(&m_critSect);
    m_running = false;

    if (m_thread != NULL) 
	{
		m_threadCmd = CT_EXIT;
		SetEvent(m_doWork);
		WaitForSingleObject(m_ptrReady, 10000);

        CloseHandle(m_thread);

        m_thread = NULL;
    }
    LeaveCriticalSection(&m_critSect);
}

LRESULT CALLBACK CBicycleFolder::WindowProc(
								  HWND hwnd,      // handle to window
								  UINT uMsg,      // message identifier
								  WPARAM wParam,  // first message parameter
								  LPARAM lParam)  // second message parameter
{
    CBicycleFolder *pThis = (CBicycleFolder *)GetWindowLong(hwnd, GWL_USERDATA);

    switch (uMsg) 
	{
    case WM_WMI_CONNECTED:
        if(pThis != NULL)
		{
			IWbemServices *service = 0;
			HRESULT hr = pThis->GetPtr(&service);
			if(SUCCEEDED(hr))
			{
				pThis->RegisterEventSink(service);
				pThis->EnumChildren(service);

				// m_pResultData gets set when an onShow has happened. If set, the user already wants
				// to see equipment but the connection was slower than the UI. Catchup now.
				if(pThis->m_pResultData)
					pThis->DisplayChildren();

				// done with the marshaled service ptr.
				service->Release();
				service = 0;
			}
		}
		else
		{
			TCHAR errMsg[255] = {0};
			pThis->ErrorString((HRESULT)wParam, errMsg, 255);

			MessageBox(hwnd, errMsg, _T("WMI Snapin Sample"), MB_OK|MB_ICONSTOP);
		}

        break;

    case WM_REFRESH_EVENT:
        if(pThis != NULL)
		{
			IWbemServices *service = 0;
			HRESULT hr = pThis->GetPtr(&service);
			if(SUCCEEDED(hr))
			{
				pThis->EmptyChildren();
				pThis->EnumChildren(service);
				pThis->DisplayChildren();

				// done with the marshaled service ptr.
				service->Release();
				service = 0;
			}
		}
        break;

	} //endswitch

    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

void CBicycleFolder::RegisterEventSink(IWbemServices *service)
{
	//NOTE: this logic is from the Wmi documentation,
	// "Security Considerations with Asynchronous Calls" so you can
	// follow along.

	// allocate the sink if its not already allocated.
	if(m_pStubSink == 0)
	{
		CEventSink *pEventSink = 0;
		IUnknown* pStubUnk = 0;

		// create the 'real' sink.
		pEventSink = new CEventSink(m_connectHwnd);
		pEventSink->AddRef();

		// create an unsecapp object.
		CoCreateInstance(CLSID_UnsecuredApartment, NULL, 
						  CLSCTX_LOCAL_SERVER, IID_IUnsecuredApartment, 
						  (void**)&m_pUnsecApp);

		// give the 'real' sink to the unsecapp to manage. Get a 'pStubUnk' in return.
		m_pUnsecApp->CreateObjectStub(pEventSink, &pStubUnk);

		// from that pUnk, get a wrapper to your original sink.
		pStubUnk->QueryInterface(IID_IWbemObjectSink, (void **)&m_pStubSink);
		pStubUnk->Release();

		// release the 'real' sink cuz m_pStubSink "owns" it now.
		long ref = pEventSink->Release();
	}

	HRESULT hRes = S_OK;
	BSTR qLang = SysAllocString(L"WQL");
	BSTR query = SysAllocString(L"select * from __InstanceCreationEvent where TargetInstance isa \"Bicycle\"");

	// execute the query. For *Async, the last parm is a sink object
	// that will be sent the resultset instead of returning the normal
	// enumerator object.
	if(SUCCEEDED(hRes = service->ExecNotificationQueryAsync(qLang, query,
															0L, NULL,              
															m_pStubSink)))
	{
		OutputDebugString(_T("Executed filter query\n"));
	}
	else
	{
		OutputDebugString(_T("ExecQuery() failed\n"));

	} //endif ExecQuery()

	SysFreeString(qLang);
	SysFreeString(query);
}

void CBicycleFolder::EmptyChildren(void)
{
	if(m_pResultData)
	{
		HRESULT hr = m_pResultData->DeleteAllRsltItems();

		int last = m_children.GetSize();
		for (int n = 0; n < last; n++)
		{
			if (m_children[n] != NULL)
				delete m_children[n];
		}
		m_children.RemoveAll();
	}
}

bool CBicycleFolder::EnumChildren(IWbemServices *service)
{
	IEnumWbemClassObject *pEnumBikes = NULL;
	HRESULT hr = S_OK;

	// get the list of bicycles...
	if(SUCCEEDED(hr = service->CreateInstanceEnum((bstr_t)L"Bicycle",
											WBEM_FLAG_SHALLOW, 
											NULL, &pEnumBikes))) 
	{
		// NOTE: pBike MUST be set to NULL for Next().
		IWbemClassObject *pBike = NULL;
		CBicycle *pBikeInst = 0;

		ULONG uReturned = 1;

		while((SUCCEEDED(hr = pEnumBikes->Next(-1, 1, &pBike, &uReturned))) && 
				(uReturned != 0))
		{
			// Add the bike...
			pBikeInst = new CBicycle(this, pBike);

			m_children.Add(pBikeInst);

			// Done with this object. pBikeInst "owns" it now.
			if(pBike)
			{ 
				pBike->Release();

				// NOTE: pBike MUST be reset to NULL for Next().
				pBike = NULL;
			} 

		} // endwhile

		// Done with this enumerator.
		if (pEnumBikes)
		{ 
			pEnumBikes->Release(); 
			pEnumBikes = NULL;
		}
	} // endif CreateInstanceEnum()

	return SUCCEEDED(hr);
}

HRESULT CBicycleFolder::GetPtr(IWbemServices **ptr)
{
	HRESULT hr = E_FAIL;
	m_threadCmd = CT_GET_PTR;
	SetEvent(m_doWork);
	WaitForSingleObject(m_ptrReady, 10000);
	
	if(ptr && m_pStream)
	{
		*ptr = 0;
		hr = CoGetInterfaceAndReleaseStream(m_pStream,
											IID_IWbemServices,
											(void**)ptr);
	}
	return hr;
}

DWORD WINAPI CBicycleFolder::ThreadProc(LPVOID lpParameter)
{
    CBicycleFolder *pThis = (CBicycleFolder *)lpParameter;
	HRESULT hr = S_OK;

	CoInitialize(NULL);

	while(true)
	{
		WaitForSingleObject(pThis->m_doWork, -1);

		switch(pThis->m_threadCmd)
		{
		case CT_CONNECT:
			{
				IWbemLocator *pLocator = 0;
				HRESULT hr;

				// Create an instance of the WbemLocator interface.
				hr = CoCreateInstance(CLSID_WbemLocator,
									  NULL, CLSCTX_INPROC_SERVER,
									  IID_IWbemLocator, (LPVOID *)&pLocator);

				if(SUCCEEDED(hr))
				{    
					hr = pLocator->ConnectServer(L"root\\Vehicles",// Network
													NULL,         // User
													NULL,         // Password
													NULL,         // Locale
													0,            // Security Flags
													NULL,         // Authority
													NULL,         // Context
													&pThis->m_realWMI);  // Namespace

					// tell the callback the result of the connection.
					if(pThis->m_connectHwnd)
						PostMessage(pThis->m_connectHwnd, WM_WMI_CONNECTED, hr, 0);
				}
			}
			break;

		case CT_GET_PTR:
			if(pThis->m_realWMI != NULL)
			{
				hr = CoMarshalInterThreadInterfaceInStream(IID_IWbemServices,
															pThis->m_realWMI, 
															&(pThis->m_pStream));
			}

			SetEvent(pThis->m_ptrReady);
			break;

		case CT_EXIT:
			if(pThis->m_realWMI != NULL)
			{
				pThis->m_realWMI->Release();
				pThis->m_realWMI = 0;
			}
			SetEvent(pThis->m_ptrReady);
			return 0;
			break;

		} //endswitch

	} //endwhile(true)

    return 0;
}

HRESULT CBicycleFolder::DisplayChildren(void)
{
    // insert items here
    RESULTDATAITEM rdi;
	HRESULT hr = S_OK;
	int last = m_children.GetSize();
	CBicycle *pBike = 0;

    // create the child nodes, then expand them
    for (int n = 0; n < last; n++) 
	{
		pBike = (CBicycle *)m_children[n];

        ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
        rdi.mask       =	RDI_STR       |   // Displayname is valid
							RDI_IMAGE     |	  // nImage is valid
							RDI_PARAM;        

        rdi.nImage      = pBike->GetBitmapIndex();
        rdi.str         = MMC_CALLBACK;
        rdi.nCol        = 0;
        rdi.lParam      = (LPARAM)pBike;

		if(m_pResultData)
			hr = m_pResultData->InsertItem( &rdi );

        _ASSERT( SUCCEEDED(hr) );
    }
	return hr;
}

HRESULT CBicycleFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;

    if (bShow) 
	{
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&m_pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn(0, L"Name", LVCFMT_LEFT, 150);
        _ASSERT( S_OK == hr );

        hr = pHeaderCtrl->InsertColumn(1, L"Owner", LVCFMT_LEFT, 200);
        _ASSERT( S_OK == hr );

		if(m_pResultData)
		{
			hr = m_pResultData->DeleteAllRsltItems();
			_ASSERT( SUCCEEDED(hr) );

			if(!bExpanded) 
			{
				hr = DisplayChildren();
			}

			pHeaderCtrl->Release();
		}
    }

    return hr;
}

CIceSkateFolder::CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CIceSkate(n + 1);
    }
}

CIceSkateFolder::~CIceSkateFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CIceSkateFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) 
		{
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) 
			{
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |    // Displayname is valid
								 RDI_IMAGE     |	// nImage is valid
								 RDI_PARAM;        

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

//================================================
CSkateboardFolder::CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CSkateboard(n + 1);
    }
}

CSkateboardFolder::~CSkateboardFolder()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSkateboardFolder::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Name                      ", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |    // Displayname is valid
								 RDI_IMAGE     |	// nImage is valid
								 RDI_PARAM;        

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

//=====================================================
const _TCHAR *CSkateboard::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Skateboard #%d"), id);

    return buf;
}

//=====================================================
const _TCHAR *CIceSkate::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    _stprintf(buf, _T("Ice Skate #%d"), id);

    return buf;
}

//========================================
CBicycle::CBicycle(CBicycleFolder *parent, IWbemClassObject *inst) :
					m_parent(parent),
					m_inst(inst)
{
	if(m_inst)
		m_inst->AddRef();
}

// helper values for calling GetDisplayName().
#define NAME_COL 0
#define OWNER_COL 1
#define COLOR_COL 2
#define MATERIAL_COL 3

const _TCHAR *CBicycle::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

	// Get the corresponding property for nCol. This is in-proc local copy 
	//	  so its pretty fast even if IWbemServices is a remote connection.
	if(m_inst)
	{
		VARIANT pVal;
		WCHAR propName[10] = {0};

		VariantInit(&pVal);

		switch(nCol) 
		{
		case 0:
			wcscpy(propName, L"Name");
			break;

		case 1:
			wcscpy(propName, L"Owner");
			break;

		// these wont be needed by MMC but its makes this routine more useful
		// internal to the class.
		case 2:
			wcscpy(propName, L"Color");
			break;

		case 3:
			wcscpy(propName, L"Material");
			break;

		} //endswitch

		if(m_inst->Get(propName, 0L, &pVal, NULL, NULL) == S_OK) 
		{
			bstr_t temp(pVal);
			_tcscpy(buf, (LPTSTR)temp);
		} 

		VariantClear(&pVal);
	} //endif (m_inst)

    return buf;
}

bool CBicycle::GetGirls(void)
{
	VARIANT_BOOL retval = VARIANT_FALSE;
	// Here's how to get/interpret a VT_BOOL property.
	if(m_inst)
	{
		VARIANT pVal;
		if(m_inst->Get(L"Girls", 0L, &pVal, NULL, NULL) == S_OK) 
		{
			retval = V_BOOL(&pVal);
		} 

		VariantClear(&pVal);
	} //endif (m_inst)

    return (retval == VARIANT_TRUE);
}

void CBicycle::LoadSurfaces(HWND hwndDlg, BYTE iSurface)
{
	HWND hCombo = GetDlgItem(hwndDlg, IDC_PEOPLE_SURFACE);
	HRESULT hr = E_FAIL;
	IWbemQualifierSet *qualSet = 0;
	int selected = 0;

	// qualifiers only exist on the class definition. m_inst is a instance.
	IWbemClassObject *pClass = 0;
	IWbemServices *service = 0;

	if(SUCCEEDED(m_parent->GetPtr(&service)))
	{
		hr = service->GetObject((bstr_t)L"Bicycle", 0,0, &pClass, 0);

		if(SUCCEEDED(hr = pClass->GetPropertyQualifierSet((bstr_t)L"Surface", 
															&qualSet)))
		{
			VARIANT vList;
			VariantInit(&vList);
			if(SUCCEEDED(hr = qualSet->Get((bstr_t)L"Values", 0, &vList, 0)))
			{
				SAFEARRAY *pma = V_ARRAY(&vList);
				long lLowerBound = 0, lUpperBound = 0 ;
				UINT idx = 0;

				SafeArrayGetLBound(pma, 1, &lLowerBound);
				SafeArrayGetUBound(pma, 1, &lUpperBound);

				for(long x = lLowerBound; x <= lUpperBound; x++)
				{
					BSTR vSurface;

					SafeArrayGetElement(pma, &x, &vSurface);
					
					// NOTE: taking advantage of the bstr_t's conversion operators.
					// really cleans up the code.
					bstr_t temp(vSurface);

					UINT idx = ComboBox_AddString(hCombo, (LPTSTR)temp);
					ComboBox_SetItemData(hCombo, idx, x);

					// is this the one we want to select?
					if(iSurface == x)
					{
						selected = x;
					}

				} //endfor
				VariantClear(&vList);
				ComboBox_SetCurSel(hCombo, selected);
			}

			qualSet->Release();
			qualSet = 0;
		} //endif GetPropertyQualifierSet()

		service->Release();

	} //endif GetPtr()

}

const TCHAR *CBicycle::ConvertSurfaceValue(BYTE val)
{
	// Convert a enum to a string using the Value{} array.
	static TCHAR temp[128] = {0};

	return temp;
}

HRESULT CBicycle::PutProperty(LPWSTR propName, LPTSTR str)
{
	HRESULT hr = E_FAIL;
	if(m_inst)
	{
		VARIANT pVal;
		bstr_t temp(str);

		VariantInit(&pVal);
		V_BSTR(&pVal) = temp;
		V_VT(&pVal) = VT_BSTR;

		hr = m_inst->Put(propName, 0L, &pVal, 0); 

		VariantClear(&pVal);
	} //endif (m_inst)

    return hr;
}

HRESULT CBicycle::PutProperty(LPWSTR propName, BYTE val)
{
	HRESULT hr = E_FAIL;
	if(m_inst)
	{
		VARIANT pVal;

		VariantInit(&pVal);
		V_UI1(&pVal) = val;
		V_VT(&pVal) = VT_UI1;

		hr = m_inst->Put(propName, 0L, &pVal, 0);

		VariantClear(&pVal);
	} //endif (m_inst)

    return hr;
}

HRESULT CBicycle::PutProperty(LPWSTR propName, bool val)
{
	HRESULT hr = E_FAIL;
	if(m_inst)
	{
		VARIANT pVal;

		VariantInit(&pVal);
		V_BOOL(&pVal) = (val?VARIANT_TRUE: VARIANT_FALSE);
		V_VT(&pVal) = VT_BOOL;

		hr = m_inst->Put(propName, 0L, &pVal, 0);

		VariantClear(&pVal);

	} //endif (m_inst)

    return hr;
}

// handle anything special when the user clicks Apply or Ok
// on the property sheet.  This sample directly accesses the
// operated-on object, so there's nothing special do to...
HRESULT CBicycle::OnPropertyChange()
{
    return S_OK;
}

HRESULT CBicycle::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsoleVerb *pConsoleVerb;

    HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
    _ASSERT(SUCCEEDED(hr));

    // can't get to properties (via the standard methods) unless
    // we tell MMC to display the Properties menu item and
    // toolbar button, this wil give the user a visual cue that
    // there's "something" to do
    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    pConsoleVerb->Release();

    return S_OK;
}

// Implement the dialog proc
BOOL CALLBACK CBicycle::DialogProc(
                                  HWND hwndDlg,  // handle to dialog box
                                  UINT uMsg,     // message
                                  WPARAM wParam, // first message parameter
                                  LPARAM lParam  // second message parameter
                                  )
{
    static CBicycle *pBike = NULL;

    switch (uMsg) 
	{
    case WM_INITDIALOG:
		{
			// catch the "this" pointer so we can actually operate on the object
			pBike = reinterpret_cast<CBicycle *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);

			SetDlgItemText(hwndDlg, IDC_PEOPLE_NAME, pBike->GetDisplayName(NAME_COL));
			SetDlgItemText(hwndDlg, IDC_PEOPLE_COLOR, pBike->GetDisplayName(COLOR_COL));
			SetDlgItemText(hwndDlg, IDC_PEOPLE_MATERIAL, pBike->GetDisplayName(MATERIAL_COL));
			SetDlgItemText(hwndDlg, IDC_PEOPLE_OWNER, pBike->GetDisplayName(OWNER_COL));

			Button_SetCheck(GetDlgItem(hwndDlg, IDC_PEOPLE_GIRLS), 
							(pBike->GetGirls()? BST_CHECKED: BST_UNCHECKED));

			VARIANT pVal;
			VariantInit(&pVal);
			if(SUCCEEDED(pBike->m_inst->Get((bstr_t)L"Surface", 0L, &pVal, NULL, NULL)))
			{
				pBike->m_iSurface = V_UI1(&pVal);
				pBike->LoadSurfaces(hwndDlg, pBike->m_iSurface);
				
				VariantClear(&pVal);
			} 

		}
        break;

    case WM_COMMAND:
        // turn the Apply button on
        if (HIWORD(wParam) == EN_CHANGE ||
            HIWORD(wParam) == CBN_SELCHANGE)
            SendMessage(GetParent(hwndDlg), PSM_CHANGED, (WPARAM)hwndDlg, 0);
        break;

    case WM_DESTROY:
        // tell MMC that we're done with the property sheet (we got this
        // handle in CreatePropertyPages
        MMCFreeNotifyHandle(pBike->m_ppHandle);
        break;

    case WM_NOTIFY:
        
		switch(((NMHDR *)lParam)->code) 
		{
        case PSN_APPLY:
			{
				bool changed = false;
				TCHAR temp[50] = {0};
				HRESULT hr = S_OK;

				HWND hWnd = GetDlgItem(hwndDlg, IDC_PEOPLE_NAME);
				if(hWnd && Edit_GetModify(hWnd))
				{
					GetWindowText(hWnd, temp, 50);
					changed |= SUCCEEDED(pBike->PutProperty(L"Name", temp));
				}

				hWnd = GetDlgItem(hwndDlg, IDC_PEOPLE_COLOR);
				if(hWnd && Edit_GetModify(hWnd))
				{
					GetWindowText(hWnd, temp, 50);
					changed |= SUCCEEDED(pBike->PutProperty(L"Color", temp));
				}

				hWnd = GetDlgItem(hwndDlg, IDC_PEOPLE_MATERIAL);
				if(hWnd && Edit_GetModify(hWnd))
				{
					GetWindowText(hWnd, temp, 50);
					changed |= SUCCEEDED(pBike->PutProperty(L"Material", temp));
				}

				hWnd = GetDlgItem(hwndDlg, IDC_PEOPLE_OWNER);
				if(hWnd && Edit_GetModify(hWnd))
				{
					GetWindowText(hWnd, temp, 50);
					changed |= SUCCEEDED(hr = pBike->PutProperty(L"Owner", temp));
				}

				hWnd = GetDlgItem(hwndDlg, IDC_PEOPLE_SURFACE);

				if(hWnd)
				{
					BYTE newValue = ComboBox_GetCurSel(hWnd);
					if(newValue != pBike->m_iSurface)
					{
						changed |= SUCCEEDED(pBike->PutProperty(L"Surface", newValue));
					}
				}

				hWnd = GetDlgItem(hwndDlg, IDC_PEOPLE_GIRLS);
				if(hWnd)
				{
					bool checked = (Button_GetState(hWnd) & BST_CHECKED);
					bool wasChecked = pBike->GetGirls();
					// did it change?
					if(checked != wasChecked)
					{
						changed |= SUCCEEDED(pBike->PutProperty(L"Girls", checked));
					}
				}

				// if any property changed, write it back to WMI.
				if(changed)
				{
					IWbemServices *service = 0;
					// dialogs run in their own thread so use the marshaling helper
					// get a useable IWbemServices ptr.
					// NOTE: IWbemClassObjects are in-proc so they DONT need to be
					// marshaled.
					if(SUCCEEDED(pBike->m_parent->GetPtr(&service)))
					{
						service->PutInstance(pBike->m_inst, WBEM_FLAG_CREATE_OR_UPDATE, 0, 0);
						service->Release();
			            HRESULT hr = MMCPropertyChangeNotify(pBike->m_ppHandle, (long)pBike);
					}
				}
			}
			break;
        } // endswitch (((NMHDR *)lParam)->code) 

        break;

    } // endswitch (uMsg) 

    return DefWindowProc(hwndDlg, uMsg, wParam, lParam);
}


HRESULT CBicycle::HasPropertySheets()
{
    // say "yes" when MMC asks if we have pages
    return S_OK;
}

HRESULT CBicycle::CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle)
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;

    // cache this handle so we can call MMCPropertyChangeNotify
    m_ppHandle = handle;

    // create the property page for this node.
    // NOTE: if your node has multiple pages, put the following
    // in a loop and create multiple pages calling
    // lpProvider->AddPage() for each page.
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_PEOPLE);
    psp.pfnDlgProc = DialogProc;
    psp.lParam = reinterpret_cast<LPARAM>(this);
    psp.pszTitle = MAKEINTRESOURCE(IDS_BIKE_TITLE);


    hPage = CreatePropertySheetPage(&psp);
    _ASSERT(hPage);

    return lpProvider->AddPage(hPage);
}

HRESULT CBicycle::GetWatermarks(HBITMAP *lphWatermark,
								   HBITMAP *lphHeader,
								   HPALETTE *lphPalette,
								   BOOL *bStretch)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\statnode.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _SNAPINBASE_H
#define _SNAPINBASE_H

#include "DeleBase.h"

class CStaticNode : public CDelegationBase {
public:
    CStaticNode();
    
    virtual ~CStaticNode();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { 
        static _TCHAR szDisplayName[256];
        LoadString(g_hinst, IDS_SNAPINNAME, szDisplayName, sizeof(szDisplayName));
        return szDisplayName; 
    }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_NONE; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { NUMBER_OF_CHILDREN = 4 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
    
    // {2974380C-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
};



#endif // _SNAPINBASE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\people.h ===
//==============================================================;
//
//	This source code is only intended as a supplement to 
//  existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#ifndef _PEOPLE_H
#define _PEOPLE_H

#include "DeleBase.h"
#include <wbemcli.h>
#include "SimpleArray.h"

class CBicycle;
class CEventSink;

class CBicycleFolder : public CDelegationBase {
public:
    CBicycleFolder();
    virtual ~CBicycleFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Bicycles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
	HRESULT GetPtr(IWbemServices **ptr);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
	CSimpleArray<CBicycle *> m_children;

	bool EnumChildren(IWbemServices *service);
	void EmptyChildren(void);
	HRESULT DisplayChildren(void);
	bool ErrorString(HRESULT hr, TCHAR *errMsg, UINT errSize);

	// for the connection thread.
    void StopThread();
    static LRESULT CALLBACK WindowProc(
							  HWND hwnd,      // handle to window
							  UINT uMsg,      // message identifier
							  WPARAM wParam,  // first message parameter
							  LPARAM lParam);   // second message parameter

    static DWORD WINAPI ThreadProc(LPVOID lpParameter);
	void RegisterEventSink(IWbemServices *service);
	IWbemObjectSink *m_pStubSink;
	IUnsecuredApartment *m_pUnsecApp;

    HWND m_connectHwnd;
    DWORD m_threadId;
    HANDLE m_thread;

	HANDLE m_doWork;		// telling the thread to do something.
	int m_threadCmd;		// what command the thread should do.
	#define CT_CONNECT 0
	#define CT_GET_PTR 1
	#define CT_EXIT 2

    CRITICAL_SECTION m_critSect;
    bool m_running;			// thread is processing a command now.

	HANDLE m_ptrReady;		// the thread has done the work.

    IResultData *m_pResultData;
	IStream *m_pStream;
	IWbemServices *m_realWMI;// lives in the background thread. Use marshalling.
};

class CBicycle : public CDelegationBase {
public:
    CBicycle(CBicycleFolder *parent, IWbemClassObject *inst);
    virtual ~CBicycle() 
	{
		if(m_inst)
			m_inst->Release();

		m_inst = 0;
	}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }

public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect);
    
    virtual HRESULT CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle);
    virtual HRESULT HasPropertySheets();
    virtual HRESULT GetWatermarks(HBITMAP *lphWatermark,
									HBITMAP *lphHeader,
									HPALETTE *lphPalette,
									BOOL *bStretch);
    
    virtual HRESULT OnPropertyChange();
    
private:
	CBicycleFolder *m_parent;
    IWbemClassObject *m_inst;

    LONG_PTR m_ppHandle;
    
    static BOOL CALLBACK DialogProc(
						HWND hwndDlg,  // handle to dialog box
						UINT uMsg,     // message
						WPARAM wParam, // first message parameter
						LPARAM lParam);// second message parameter

    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
	bool GetGirls(void);
	const TCHAR *ConvertSurfaceValue(BYTE val);
	HRESULT PutProperty(LPWSTR propName, LPTSTR str);
	HRESULT PutProperty(LPWSTR propName, BYTE val);
	HRESULT PutProperty(LPWSTR propName, bool val);
	void LoadSurfaces(HWND hwndDlg, BYTE iSurface);
	BYTE m_iSurface;
};


class CSkateboard : public CDelegationBase {
public:
    CSkateboard(int i) : id(i) { }
    virtual ~CSkateboard() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CSkateboardFolder : public CDelegationBase {
public:
    CSkateboardFolder();
    virtual ~CSkateboardFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Skateboards"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CIceSkate : public CDelegationBase {
public:
    CIceSkate(int i) : id(i) { }
    virtual ~CIceSkate() {}
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0);
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    int id;
};

class CIceSkateFolder : public CDelegationBase {
public:
    CIceSkateFolder();
    virtual ~CIceSkateFolder();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("Ice Skates"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
public:
    // virtual functions go here (for MMCN_*)
    virtual HRESULT OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem);
    
private:
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 20 };
    CDelegationBase *children[NUMBER_OF_CHILDREN];
};

class CPeoplePoweredVehicle : public CDelegationBase {
public:
    CPeoplePoweredVehicle();
    virtual ~CPeoplePoweredVehicle();
    
    virtual const _TCHAR *GetDisplayName(int nCol = 0) { return _T("People-powered Vehicles"); }
    virtual const GUID & getNodeType() { return thisGuid; }
    virtual const int GetBitmapIndex() { return INDEX_PEOPLEICON; }
    
    virtual HRESULT OnExpand(IConsoleNameSpace *pConsoleNameSpace, IConsole *pConsole, HSCOPEITEM parent);
    
private:
    enum { IDM_NEW_PEOPLE = 1 };
    
    // {2974380D-4C4B-11d2-89D8-000021473128}
    static const GUID thisGuid;
    
    enum { NUMBER_OF_CHILDREN = 3 };
    CDelegationBase *children[3];
};

#endif // _PEOPLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Resource.rc
//
#define IDS_HELPFILE                    1
#define IDS_SNAPINDESC                  2
#define IDI_PSI_LANDBASED               2
#define IDS_NAME                        3
#define IDS_SNAPINNAME                  6
#define IDS_ABOUTNAME                   9
#define IDS_PST_ROCKET                  10
#define IDS_PST_LANDBASED               11
#define IDS_BIKE_TITLE                  12
#define IDD_PROPPAGE_LARGE              107
#define IDI_ICON1                       108
#define IDD_PROPPAGE_PEOPLE             108
#define IDB_SMOPEN                      111
#define IDB_SMBMP                       112
#define IDB_LGBMP                       113
#define IDI_PSI_ROCKET                  114
#define IDR_SMICONS                     120
#define IDR_LGICONS                     121
#define IDC_ROCKET_NAME                 1000
#define IDC_ROCKET_HEIGHT               1001
#define IDC_ROCKET_WEIGHT               1002
#define IDC_ROCKET_PAYLOAD              1003
#define IDC_ROCKET_STATUS               1005
#define IDC_PEOPLE_NAME                 1008
#define IDC_PEOPLE_COLOR                1009
#define IDC_PEOPLE_MATERIAL             1010
#define IDC_PEOPLE_OWNER                1011
#define IDC_PEOPLE_SURFACE              1012
#define IDC_GIRLS                       1013
#define IDC_PEOPLE_GIRLS                1013
#define IDB_ROCKET                      40004
#define IDB_CAR                         40005
#define IDB_PLANE                       40006
#define IDB_BIKE                        40007
#define IDB_ROCKET2                     40008
#define IDB_CAR2                        40009
#define IDB_PLANE2                      40010
#define IDB_BIKE2                       40011
#define IDB_CLOSED2                     40012
#define IDB_OPEN2                       40013
#define IDB_CLOSED                      40014
#define IDB_OPEN                        40015

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        116
#define _APS_NEXT_COMMAND_VALUE         40016
#define _APS_NEXT_CONTROL_VALUE         1014
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\guids.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;


// {40EDBFBE-E4D4-4380-8BFE-AF1D280AB6F4}
DEFINE_GUID(CLSID_CComponentData, 
0x40edbfbe, 0xe4d4, 0x4380, 0x8b, 0xfe, 0xaf, 0x1d, 0x28, 0xa, 0xb6, 0xf4);


// {356DDDA6-310D-4329-82FF-922F91AFDC6A}
DEFINE_GUID(CLSID_CSnapinAbout, 
0x356ddda6, 0x310d, 0x4329, 0x82, 0xff, 0x92, 0x2f, 0x91, 0xaf, 0xdc, 0x6a);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\simplearray.h ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation. 
//
// 
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#if (_ATL_VER < 0x0300)
/////////////////////////////////////////////////////////////////////////////
// Collection helpers - CSimpleArray & CSimpleMap

template <class T>
class CSimpleArray
{
public:
	T* m_aT;
	int m_nSize;
	int m_nAllocSize;

// Construction/destruction
	CSimpleArray() : m_aT(NULL), m_nSize(0), m_nAllocSize(0)
	{ }

	~CSimpleArray()
	{
		RemoveAll();
	}

// Operations
	int GetSize() const
	{
		return m_nSize;
	}
	BOOL Add(T& t)
	{
		if(m_nSize == m_nAllocSize)
		{
			T* aT;
			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);
			aT = (T*)realloc(m_aT, nNewAllocSize * sizeof(T));
			if(aT == NULL)
				return FALSE;
			m_nAllocSize = nNewAllocSize;
			m_aT = aT;
		}
		m_nSize++;
		SetAtIndex(m_nSize - 1, t);
		return TRUE;
	}
	BOOL Remove(T& t)
	{
		int nIndex = Find(t);
		if(nIndex == -1)
			return FALSE;
		return RemoveAt(nIndex);
	}
	BOOL RemoveAt(int nIndex)
	{
		if(nIndex != (m_nSize - 1))
			memmove((void*)&m_aT[nIndex], (void*)&m_aT[nIndex + 1], (m_nSize - (nIndex + 1)) * sizeof(T));
		m_nSize--;
		return TRUE;
	}
	void RemoveAll()
	{
		if(m_aT != NULL)
		{
			free(m_aT);
			m_aT = NULL;
		}
		m_nSize = 0;
		m_nAllocSize = 0;
	}
	T& operator[] (int nIndex) const
	{
		_ASSERT(nIndex >= 0 && nIndex < m_nSize);
		return m_aT[nIndex];
	}
	T* GetData() const
	{
		return m_aT;
	}

// Implementation
	void SetAtIndex(int nIndex, T& t)
	{
		_ASSERT(nIndex >= 0 && nIndex < m_nSize);
		m_aT[nIndex] = t;
	}
	int Find(T& t) const
	{
		for(int i = 0; i < m_nSize; i++)
		{
			if(m_aT[i] == t)
				return i;
		}
		return -1;	// not found
	}
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\registry.cpp ===
//==============================================================;
//
//  This source code is only intended as a supplement to existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;

#include <objbase.h>
#include <assert.h>

#include "Registry.h"

#define STRINGS_ONLY
#include "globals.h"

////////////////////////////////////////////////////////
//
// Internal helper functions prototypes
//

// Set the given key and its value.
BOOL setKeyAndValue(const _TCHAR* pszPath,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue) ;

// Set the given key and its value in the MMC Snapin location
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue);

// Set the given valuename under the key to value
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue);

// Delete szKeyChild and all of its descendents.
LONG recursiveDeleteKey(HKEY hKeyParent, const _TCHAR* szKeyChild) ;

////////////////////////////////////////////////////////
//
// Constants
//

// Size of a CLSID as a string
//const int CLSID_STRING_SIZE = 39 ;

/////////////////////////////////////////////////////////
//
// Public function implementation
//

//
// Register the component in the registry.
//
HRESULT RegisterServer(HMODULE hModule,            // DLL module handle
                       const CLSID& clsid,         // Class ID
                       const _TCHAR* szFriendlyName)       //   IDs
{
    // Get server location.
    _TCHAR szModule[512] ;
    DWORD dwResult =
        ::GetModuleFileName(hModule,
        szModule,
        sizeof(szModule)/sizeof(_TCHAR)) ;

    assert(dwResult != 0) ;

    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    assert(SUCCEEDED(hr)) ;

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;
        _tcscat(szKey, pszCLSID) ;

    // Add the CLSID to the registry.
    setKeyAndValue(szKey, NULL, szFriendlyName) ;

    // Add the server filename subkey under the CLSID key.
    setKeyAndValue(szKey, _T("InprocServer32"), szModule) ;

    // set the threading model
    _tcscat(szKey, _T("\\InprocServer32"));
    setValue(szKey, _T("ThreadingModel"), _T("Apartment"));

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Remove the component from the registry.
//
LONG UnregisterServer(const CLSID& clsid)       //   IDs
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;


    // Build the key CLSID\\{...}
    _TCHAR szKey[64] ;
    _tcscpy(szKey, _T("CLSID\\")) ;

        MAKE_TSTRPTR_FROMWIDE(pszT, wszCLSID);
        _tcscat(szKey, pszT) ;

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_CLASSES_ROOT, szKey) ;
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // Free memory.
    CoTaskMemFree(wszCLSID) ;

    return S_OK ;
}

//
// Register the snap-in in the registry.
//
HRESULT RegisterSnapin(const CLSID& clsid,         // Class ID
                       const _TCHAR* szNameString,   // NameString
                       const CLSID& clsidAbout,         // Class Id for About Class
                       const BOOL fSupportExtensions)
{
    // Get CLSID
    LPOLESTR wszCLSID = NULL ;
    LPOLESTR wszAboutCLSID = NULL;
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID) ;

    if (IID_NULL != clsidAbout)
        hr = StringFromCLSID(clsidAbout, &wszAboutCLSID);

        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszAboutCLSID, wszAboutCLSID);


    // Add the CLSID to the registry.
    setSnapInKeyAndValue(pszCLSID, NULL, _T("NameString"), szNameString) ;
    setSnapInKeyAndValue(pszCLSID, _T("StandAlone"), NULL, NULL);
    if (IID_NULL != clsidAbout)
        setSnapInKeyAndValue(pszCLSID, NULL, _T("About"), pszAboutCLSID);

    if (fSupportExtensions) {
        // Build the key NodeType
        setSnapInKeyAndValue(pszCLSID, _T("NodeTypes"), NULL, NULL);

        _TCHAR szKey[64] ;
        _tcscpy(szKey, pszCLSID) ;
        _tcscat(szKey, _T("\\NodeTypes")) ;
        setSnapInKeyAndValue(szKey, pszCLSID, NULL, NULL);
    }

    // Free memory.
    CoTaskMemFree(wszCLSID) ;
    if (IID_NULL != clsidAbout)
        CoTaskMemFree(wszAboutCLSID);

    return S_OK ;
}

//
// Unregister the snap-in in the registry.
//
HRESULT UnregisterSnapin(const CLSID& clsid)         // Class ID
{
    _TCHAR szKeyBuf[1024];
    LPOLESTR wszCLSID = NULL;

    // Get CLSID
    HRESULT hr = StringFromCLSID(clsid, &wszCLSID);
        MAKE_TSTRPTR_FROMWIDE(pszCLSID, wszCLSID);

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\"));
    _tcscat(szKeyBuf, pszCLSID);

    // Delete the CLSID Key - CLSID\{...}
    LONG lResult = recursiveDeleteKey(HKEY_LOCAL_MACHINE, szKeyBuf);
    assert((lResult == ERROR_SUCCESS) ||
               (lResult == ERROR_FILE_NOT_FOUND)) ; // Subkey may not exist.

    // free the memory
    CoTaskMemFree(wszCLSID);

    return S_OK;
}

//
// Delete a key and all of its descendents.
//
LONG recursiveDeleteKey(HKEY hKeyParent,           // Parent of key to delete
                        const _TCHAR* lpszKeyChild)  // Key to delete
{
    // Open the child.
    HKEY hKeyChild ;
    LONG lRes = RegOpenKeyEx(hKeyParent, lpszKeyChild, 0,
        KEY_ALL_ACCESS, &hKeyChild) ;
    if (lRes != ERROR_SUCCESS)
    {
        return lRes ;
    }

    // Enumerate all of the decendents of this child.
    FILETIME time ;
    _TCHAR szBuffer[256] ;
    DWORD dwSize = 256 ;
    while (RegEnumKeyEx(hKeyChild, 0, szBuffer, &dwSize, NULL,
        NULL, NULL, &time) == S_OK)
    {
        // Delete the decendents of this child.
        lRes = recursiveDeleteKey(hKeyChild, szBuffer) ;
        if (lRes != ERROR_SUCCESS)
        {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild) ;
            return lRes;
        }
        dwSize = 256 ;
    }

    // Close the child.
    RegCloseKey(hKeyChild) ;

    // Delete this child.
    return RegDeleteKey(hKeyParent, lpszKeyChild) ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setKeyAndValue(const _TCHAR* szKey,
                    const _TCHAR* szSubkey,
                    const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, NULL, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Open a key value and set it
//
BOOL setValue(const _TCHAR* szKey,
              const _TCHAR* szValueName,
              const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Copy keyname into buffer.
    _tcscpy(szKeyBuf, szKey) ;

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_CLASSES_ROOT ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szValueName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}

//
// Create a key and set its value.
//   - This helper function was borrowed and modifed from
//     Kraig Brockschmidt's book Inside OLE.
//
BOOL setSnapInKeyAndValue(const _TCHAR* szKey,
                          const _TCHAR* szSubkey,
                          const _TCHAR* szName,
                          const _TCHAR* szValue)
{
    HKEY hKey;
    _TCHAR szKeyBuf[1024] ;

    // Load the buffer with the Snap-In Location
    _tcscpy(szKeyBuf, _T("SOFTWARE\\Microsoft\\MMC\\SnapIns"));

    // Copy keyname into buffer.
    _tcscat(szKeyBuf, _T("\\")) ;
    _tcscat(szKeyBuf, szKey) ;

    // Add subkey name to buffer.
    if (szSubkey != NULL)
    {
        _tcscat(szKeyBuf, _T("\\")) ;
        _tcscat(szKeyBuf, szSubkey ) ;
    }

    // Create and open key and subkey.
    long lResult = RegCreateKeyEx(HKEY_LOCAL_MACHINE ,
        szKeyBuf,
        0, NULL, REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS, NULL,
        &hKey, NULL) ;
    if (lResult != ERROR_SUCCESS)
    {
        return FALSE ;
    }

    // Set the Value.
    if (szValue != NULL)
    {
        RegSetValueEx(hKey, szName, 0, REG_SZ,
            (BYTE *)szValue,
            (_tcslen(szValue)+1)*sizeof(_TCHAR)) ;
    }

    RegCloseKey(hKey) ;
    return TRUE ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\shellext\extract.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       extract.cpp
//
//--------------------------------------------------------------------------

// ExtractIcon.cpp : Implementation of CExtractIcon
#include "stdafx.h"
#include "shlobj.h"
#include "Extract.h"
#include "xmlfile.h"

/* 7A80E4A8-8005-11D2-BCF8-00C04F72C717 */
CLSID CLSID_ExtractIcon = {0x7a80e4a8, 0x8005, 0x11d2, {0xbc, 0xf8, 0x00, 0xc0, 0x4f, 0x72, 0xc7, 0x17} };

/////////////////////////////////////////////////////////////////////////////
// CExtractIcon

STDMETHODIMP
CExtractIcon::Extract(LPCTSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize)
{
    HRESULT hr = S_OK;
    int	nLargeIconSize = LOWORD(nIconSize);
    int nSmallIconSize = HIWORD(nIconSize);

    // extract from the .msc file ONLY if the file is in local storage, NOT in offline storage.
    DWORD	dwFileAttributes = GetFileAttributes(pszFile);
    bool	bUseMSCFile      = (dwFileAttributes != 0xFFFFFFFF) && !(dwFileAttributes & FILE_ATTRIBUTE_OFFLINE);

	CSmartIcon iconLarge;
	CSmartIcon iconSmall;

    if (bUseMSCFile)
    {
		CPersistableIcon persistableIcon;

        // try to read file as if it was XML document first,
        hr = ExtractIconFromXMLFile (pszFile, persistableIcon);

        // if it fails, assume the file has older MSC format (compound document)
        // and try to read it
        if (FAILED (hr))
		{
			USES_CONVERSION;
            hr = persistableIcon.Load (T2CW (pszFile));
		}

		/*
		 * get the large and small icons; if either of these fail,
		 * we'll get default icons below
		 */
		if (SUCCEEDED (hr) &&
			SUCCEEDED (hr = persistableIcon.GetIcon (nLargeIconSize, iconLarge)) &&
			SUCCEEDED (hr = persistableIcon.GetIcon (nSmallIconSize, iconSmall)))
		{
			ASSERT ((iconLarge != NULL) && (iconSmall != NULL));
		}
    }

	/*
	 * use the default icons if the file is offline, or the Load failed
	 */
    if (!bUseMSCFile || FAILED(hr))
    {
		/*
		 * load the large and small icons from our resources
		 */
        iconLarge.Attach ((HICON) LoadImage (_Module.GetModuleInstance(),
											 MAKEINTRESOURCE(IDR_MAINFRAME),
											 IMAGE_ICON,
											 nLargeIconSize,
											 nLargeIconSize,
											 LR_DEFAULTCOLOR));

        iconSmall.Attach ((HICON) LoadImage (_Module.GetModuleInstance(),
											 MAKEINTRESOURCE(IDR_MAINFRAME),
											 IMAGE_ICON,
											 nSmallIconSize,
											 nSmallIconSize,
											 LR_DEFAULTCOLOR));
    }

	/*
	 * if we successfully got the large and small icons, return them
	 * to the shell (which will take responsibility for their destruction)
	 */
	if ((iconLarge != NULL) && (iconSmall != NULL))
	{
		*phiconLarge = iconLarge.Detach();
		*phiconSmall = iconSmall.Detach();
		hr = S_OK;
	}
	else
		hr = E_FAIL;

    return (hr);
}

STDMETHODIMP
CExtractIcon::GetIconLocation(UINT uFlags, LPTSTR szIconFile, UINT cchMax, LPINT piIndex, UINT *pwFlags)
{
    _tcscpy(szIconFile, (LPCTSTR)m_strIconFile);
    *piIndex = 0;
    *pwFlags = GIL_NOTFILENAME | GIL_PERINSTANCE | GIL_DONTCACHE;

    return NOERROR;
}

STDMETHODIMP
CExtractIcon::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    m_strIconFile = pszFileName;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\shellext\extract.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       extract.h
//
//--------------------------------------------------------------------------

// ExtractIcon.h : Declaration of the CExtractIcon

#ifndef __EXTRACTICON_H_
#define __EXTRACTICON_H_

#include "mmcshext.h"       // main symbols
#include "picon.h"

#ifdef ASSERT
#undef ASSERT
#endif
#define ASSERT(e)        // get rid of the assert symbol.

#include "cstr.h"

extern CLSID CLSID_ExtractIcon;

/////////////////////////////////////////////////////////////////////////////
// CExtractIcon
class ATL_NO_VTABLE CExtractIcon : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CExtractIcon, &CLSID_ExtractIcon>,
    public IExtractIcon,
    public IPersistFile
{
public:
    CExtractIcon()
    {
    }

    // IExtractIcon
    STDMETHOD(Extract)          (LPCTSTR pszFile, UINT nIconIndex, HICON *phiconLarge, HICON *phiconSmall, UINT nIconSize);     
    STDMETHOD(GetIconLocation)  (UINT uFlags, LPTSTR szIconFile, UINT cchMax, LPINT piIndex, UINT *pwFlags);    
    
    // IPersistFile
    STDMETHOD(GetClassID)       (CLSID *pClassID)                           {return E_NOTIMPL;}  
    STDMETHOD(IsDirty)           (void)                                     {return E_NOTIMPL;}
    STDMETHOD(Load)             (LPCOLESTR pszFileName, DWORD dwMode);        
    STDMETHOD(Save)             (LPCOLESTR pszFileName, BOOL fRemember)     {return E_NOTIMPL;}
    STDMETHOD(SaveCompleted)    (LPCOLESTR pszFileName)                     {return E_NOTIMPL;}
    STDMETHOD(GetCurFile)       (LPOLESTR *ppszFileName)                    {return E_NOTIMPL;}


DECLARE_REGISTRY_RESOURCEID(IDR_EXTRACTICON)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CExtractIcon)
    COM_INTERFACE_ENTRY_IID(IID_IExtractIcon, IExtractIcon)
    COM_INTERFACE_ENTRY(IPersistFile)
END_COM_MAP()

private:
    CStr                        m_strIconFile;
};

#endif //__EXTRACTICON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\shellext\hhcwrap.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       hhcwrap.cpp
//
//--------------------------------------------------------------------------

// hhcwrap.cpp : Implementation of CHHCollectionWrapper
#include "stdafx.h"
#include "shlobj.h"
#include "hhcwrap.h"
#include "hcolwrap_i.c"

/////////////////////////////////////////////////////////////////////////////
// CHHCollectionWrapper
//
// This class is a wrapper class for the HTML Help collection class. MMC uses
// this class so that it doesn't have to statically link to hhsetup.dll, which
// implements the collection class.
//
// The wrapper class methods all return an HRESULT. For collection methods that
// return a DWORD result, the wrapper returns E_FAIL or S_OK. For all other
// collection methods the wrapper returns S_OK.
//

STDMETHODIMP CHHCollectionWrapper::Open(LPCOLESTR FileName)
{
    USES_CONVERSION;
    DWORD dw =  m_collection.Open(W2CT(FileName));
    return dw ? E_FAIL : S_OK;
}

STDMETHODIMP CHHCollectionWrapper::Save()
{
    DWORD dw =  m_collection.Save();
    return dw ? E_FAIL : S_OK;
}

STDMETHODIMP CHHCollectionWrapper::Close()
{
    DWORD dw = m_collection.Close();
    return dw ? E_FAIL : S_OK;
}

STDMETHODIMP CHHCollectionWrapper::RemoveCollection(BOOL bRemoveLocalFiles)
{
    m_collection.RemoveCollection(bRemoveLocalFiles);
    return S_OK;
}

STDMETHODIMP CHHCollectionWrapper::SetFindMergedCHMS(BOOL bFind)
{
    m_collection.SetFindMergedCHMS(bFind);
    return S_OK;
}


STDMETHODIMP CHHCollectionWrapper::AddFolder (
    LPCOLESTR szName,
    DWORD Order,
    DWORD *pDWORD,
    LANGID LangId )
{
    USES_CONVERSION;

    m_collection.AddFolder(W2CT(szName), Order, pDWORD, LangId);
    return S_OK;
}


STDMETHODIMP CHHCollectionWrapper::AddTitle (
    LPCOLESTR Id,
    LPCOLESTR FileName,
    LPCOLESTR IndexFile,
    LPCOLESTR Query,
    LPCOLESTR SampleLocation,
    LANGID Lang,
    UINT uiFlags,
    ULONG_PTR pLocation,
    DWORD *pDWORD,
    BOOL bSupportsMerge,
    LPCOLESTR QueryLocation )
{
    USES_CONVERSION;

    m_collection.AddTitle(W2CT(Id), W2CT(FileName), W2CT(IndexFile), W2CT(Query),
                          W2CT(SampleLocation), Lang, uiFlags, (CLocation*)pLocation, pDWORD,
                          bSupportsMerge, W2CT(QueryLocation));

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\samples\sdksamples\wmi\space.cpp ===
//==============================================================;
//
//      This source code is only intended as a supplement to
//  existing Microsoft documentation.
//
//
//
//
//  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
//  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
//  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
//  PURPOSE.
//
//  Copyright (C) 1999 Microsoft Corporation.  All Rights Reserved.
//
//
//
//==============================================================;
#include <stdio.h>
#include <windows.h>
#include "Space.h"
#include "Comp.h"
#include "resource.h"

const GUID CSpaceVehicle::thisGuid = { 0x29743810, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };
const GUID CRocket::thisGuid = { 0x29743811, 0x4c4b, 0x11d2, { 0x89, 0xd8, 0x0, 0x0, 0x21, 0x47, 0x31, 0x28 } };

//==============================================================
//
// CSpaceVehicle implementation
//
//
CSpaceVehicle::CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
        children[n] = new CRocket(_T("Rocket"), n+1, 500000, 265, 75000);
    }
}

CSpaceVehicle::~CSpaceVehicle()
{
    for (int n = 0; n < NUMBER_OF_CHILDREN; n++)
        if (children[n]) {
            delete children[n];
        }
}

HRESULT CSpaceVehicle::OnShow(IConsole *pConsole, BOOL bShow, HSCOPEITEM scopeitem)
{
    HRESULT      hr = S_OK;

    IHeaderCtrl *pHeaderCtrl = NULL;
    IResultData *pResultData = NULL;

    if (bShow) {
        hr = pConsole->QueryInterface(IID_IHeaderCtrl, (void **)&pHeaderCtrl);
        _ASSERT( SUCCEEDED(hr) );

        hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
        _ASSERT( SUCCEEDED(hr) );

        // Set the column headers in the results pane
        hr = pHeaderCtrl->InsertColumn( 0, L"Rocket Class", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 1, L"Rocket Weight", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 2, L"Rocket Height", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 3, L"Rocket Payload", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );
        hr = pHeaderCtrl->InsertColumn( 4, L"Status", 0, MMCLV_AUTO );
        _ASSERT( S_OK == hr );

        // insert items here
        RESULTDATAITEM rdi;

        hr = pResultData->DeleteAllRsltItems();
        _ASSERT( SUCCEEDED(hr) );

        if (!bExpanded) {
            // create the child nodes, then expand them
            for (int n = 0; n < NUMBER_OF_CHILDREN; n++) {
                ZeroMemory(&rdi, sizeof(RESULTDATAITEM) );
                rdi.mask       = RDI_STR       |   // Displayname is valid
                    RDI_IMAGE     |
                    RDI_PARAM;        // nImage is valid

                rdi.nImage      = children[n]->GetBitmapIndex();
                rdi.str         = MMC_CALLBACK;
                rdi.nCol        = 0;
                rdi.lParam      = (LPARAM)children[n];

                hr = pResultData->InsertItem( &rdi );

                _ASSERT( SUCCEEDED(hr) );
            }
        }

        pHeaderCtrl->Release();
        pResultData->Release();
    }

    return hr;
}

//==============================================================
//
// CRocket implementation
//
//
CRocket::CRocket(_TCHAR *szName, int id, LONG lWeight, LONG lHeight, LONG lPayload)
: szName(NULL), lWeight(0), lHeight(0), lPayload(0), iStatus(STOPPED)
{
    if (szName) {
        this->szName = new _TCHAR[(_tcslen(szName) + 1) * sizeof(_TCHAR)];
        _tcscpy(this->szName, szName);
    }

    this->nId = id;
    this->lWeight = lWeight;
    this->lHeight = lHeight;
    this->lPayload = lPayload;

    m_ppHandle = 0;
}

CRocket::~CRocket()
{
    if (szName)
        delete [] szName;
}

const _TCHAR *CRocket::GetDisplayName(int nCol)
{
    static _TCHAR buf[128];

    switch (nCol) {
    case 0:
        _stprintf(buf, _T("%s (#%d)"), szName ? szName : _T(""), nId);
        break;

    case 1:
        _stprintf(buf, _T("%ld metric tons"), lWeight);
        break;

    case 2:
        _stprintf(buf, _T("%ld meters"), lHeight);
        break;

    case 3:
        _stprintf(buf, _T("%ld kilos"), lPayload);
        break;

    case 4:
        _stprintf(buf, _T("%s"),
            iStatus == RUNNING ? _T("running") :
        iStatus == PAUSED ? _T("paused") :
        iStatus == STOPPED ? _T("stopped") : _T("unknown"));
        break;

    }

    return buf;
}

HRESULT CRocket::OnRename(LPOLESTR pszNewName)
{
    if (szName) {
        delete [] szName;
        szName = NULL;
    }

    MAKE_TSTRPTR_FROMWIDE(ptrname, pszNewName);
    szName = new _TCHAR[(_tcslen(ptrname) + 1) * sizeof(_TCHAR)];
    _tcscpy(szName, ptrname);

    return S_OK;
}

// handle anything special when the user clicks Apply or Ok
// on the property sheet.  This sample directly accesses the
// operated-on object, so there's nothing special to do when the user presses Ok.
// when the user presses Apply, we update the currently selected result item
HRESULT CRocket::OnPropertyChange(IConsole *pConsole)
{

    //redraw the item 
    IResultData *pResultData = NULL;

	HRESULT hr;

	hr = pConsole->QueryInterface(IID_IResultData, (void **)&pResultData);
	_ASSERT( SUCCEEDED(hr) );	

	HRESULTITEM myhresultitem;	
	
	//lparam == this. See CSpaceVehicle::OnShow
	hr = pResultData->FindItemByLParam( (LPARAM)this, &myhresultitem );
	_ASSERT( SUCCEEDED(hr) ); 

	hr = pResultData->UpdateItem( myhresultitem );     
	_ASSERT( SUCCEEDED(hr) );    
	
    pResultData->Release();
	
	
	return S_OK;
}

HRESULT CRocket::OnSelect(IConsole *pConsole, BOOL bScope, BOOL bSelect)
{
    IConsoleVerb *pConsoleVerb;

    HRESULT hr = pConsole->QueryConsoleVerb(&pConsoleVerb);
    _ASSERT(SUCCEEDED(hr));

    hr = pConsoleVerb->SetVerbState(MMC_VERB_RENAME, ENABLED, TRUE);

    // can't get to properties (via the standard methods) unless
    // we tell MMC to display the Properties menu item and
    // toolbar button, this wil give the user a visual cue that
    // there's "something" to do
    hr = pConsoleVerb->SetVerbState(MMC_VERB_PROPERTIES, ENABLED, TRUE);

    pConsoleVerb->Release();

    return S_OK;
}

// Implement the dialog proc
BOOL CALLBACK CRocket::DialogProc(
                                  HWND hwndDlg,  // handle to dialog box
                                  UINT uMsg,     // message
                                  WPARAM wParam, // first message parameter
                                  LPARAM lParam  // second message parameter
                                  )
{
    static CRocket *pRocket = NULL;

    switch (uMsg) {
    case WM_INITDIALOG:
        // catch the "this" pointer so we can actually operate on the object
        pRocket = reinterpret_cast<CRocket *>(reinterpret_cast<PROPSHEETPAGE *>(lParam)->lParam);

        SetDlgItemText(hwndDlg, IDC_ROCKET_NAME, pRocket->szName);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_HEIGHT, pRocket->lHeight, FALSE);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_WEIGHT, pRocket->lWeight, FALSE);
        SetDlgItemInt(hwndDlg, IDC_ROCKET_PAYLOAD, pRocket->lPayload, FALSE);

        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 0, (LPARAM)_T("Running")) );
        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 1, (LPARAM)_T("Paused")) );
        _ASSERT( CB_ERR != SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_INSERTSTRING, 2, (LPARAM)_T("Stopped")) );

        SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_SETCURSEL, (WPARAM)pRocket->iStatus, 0);

        break;

    case WM_COMMAND:
        // turn the Apply button on
        if (HIWORD(wParam) == EN_CHANGE ||
            HIWORD(wParam) == CBN_SELCHANGE)
            SendMessage(GetParent(hwndDlg), PSM_CHANGED, (WPARAM)hwndDlg, 0);
        break;

    case WM_DESTROY:
        // tell MMC that we're done with the property sheet (we got this
        // handle in CreatePropertyPages
        MMCFreeNotifyHandle(pRocket->m_ppHandle);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *) lParam)->code) {
        case PSN_APPLY:
            // update the information
            if (pRocket->szName) {
                delete [] pRocket->szName;
                pRocket->szName = NULL;
            }

            {
                int n = SendDlgItemMessage(hwndDlg, IDC_ROCKET_NAME, WM_GETTEXTLENGTH, 0, 0);
                if (n != 0) {
                    pRocket->szName = new _TCHAR[n + 1];
                    GetDlgItemText(hwndDlg, IDC_ROCKET_NAME, pRocket->szName, n + 1);
                }
            }
            pRocket->lHeight = GetDlgItemInt(hwndDlg, IDC_ROCKET_HEIGHT, NULL, FALSE);
            pRocket->lWeight = GetDlgItemInt(hwndDlg, IDC_ROCKET_WEIGHT, NULL, FALSE);
            pRocket->lPayload = GetDlgItemInt(hwndDlg, IDC_ROCKET_PAYLOAD, NULL, FALSE);

            pRocket->iStatus = (ROCKET_STATUS)SendDlgItemMessage(hwndDlg, IDC_ROCKET_STATUS, CB_GETCURSEL, 0, 0);

            // ask MMC to send us a message (on the main thread) so
            // we know the Apply button was clicked.
            HRESULT hr = MMCPropertyChangeNotify(pRocket->m_ppHandle, (long)pRocket);

            _ASSERT(SUCCEEDED(hr));

            return PSNRET_NOERROR;
        }
        break;
    }

    return DefWindowProc(hwndDlg, uMsg, wParam, lParam);
}


HRESULT CRocket::HasPropertySheets()
{
    // say "yes" when MMC asks if we have pages
    return S_OK;
}

HRESULT CRocket::CreatePropertyPages(IPropertySheetCallback *lpProvider, LONG_PTR handle)
{
    PROPSHEETPAGE psp;
    HPROPSHEETPAGE hPage = NULL;

    // cache this handle so we can call MMCPropertyChangeNotify
    m_ppHandle = handle;

    // create the property page for this node.
    // NOTE: if your node has multiple pages, put the following
    // in a loop and create multiple pages calling
    // lpProvider->AddPage() for each page.
    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE | PSP_USEICONID;
    psp.hInstance = g_hinst;
    psp.pszTemplate = MAKEINTRESOURCE(IDD_PROPPAGE_LARGE);
    psp.pfnDlgProc = DialogProc;
    psp.lParam = reinterpret_cast<LPARAM>(this);
    psp.pszTitle = MAKEINTRESOURCE(IDS_PST_ROCKET);
    psp.pszIcon = MAKEINTRESOURCE(IDI_PSI_ROCKET);


    hPage = CreatePropertySheetPage(&psp);
    _ASSERT(hPage);

    return lpProvider->AddPage(hPage);
}

HRESULT CRocket::GetWatermarks(HBITMAP *lphWatermark,
                               HBITMAP *lphHeader,
                               HPALETTE *lphPalette,
                               BOOL *bStretch)
{
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\shellext\mmcshext.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmcshext.cpp
//
//--------------------------------------------------------------------------

// mmcshext.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f mmcshextps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include <shlobj.h>
#include <shlguid.h>
#include "Extract.h"
#include "hhcwrap.h"
#include "picon.h"
#include "modulepath.h"

#include <atlimpl.cpp>

CComModule _Module;

static void RemovePathFromInProcServerEntry (REFCLSID rclsid);

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ExtractIcon, CExtractIcon)
OBJECT_ENTRY(CLSID_HHCollectionWrapper, CHHCollectionWrapper)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    HRESULT hr =  _Module.RegisterServer(FALSE);

    if (hr == S_OK)
    {
        // remove full module path that ATL adds by default
        RemovePathFromInProcServerEntry(CLSID_ExtractIcon);
        RemovePathFromInProcServerEntry(CLSID_HHCollectionWrapper);
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}


static void RemovePathFromInProcServerEntry (REFCLSID rclsid)
{
    // Convert the CLSID to a string
    USES_CONVERSION;
    LPOLESTR lpOleStr;
    HRESULT hr = StringFromCLSID (rclsid, &lpOleStr);
    if (FAILED(hr))
        return;

    if (lpOleStr != NULL)
    {
        // Re-register the InProcServer key without the path
        TCHAR szSubKey[MAX_PATH];

        _tcscpy (szSubKey, _T("CLSID\\"));
        _tcscat (szSubKey, OLE2T(lpOleStr));
        _tcscat (szSubKey, _T("\\InprocServer32"));

        CoTaskMemFree(lpOleStr);

        ::ATL::CRegKey regkey;
        long lRes = regkey.Open(HKEY_CLASSES_ROOT, szSubKey);
        ASSERT(lRes == ERROR_SUCCESS);

        if (lRes == ERROR_SUCCESS)
        {
			CStr strPath = _T("mmcshext.dll");
			
			// try to get absolute path value
			CStr strAbsolute = CModulePath::MakeAbsoluteModulePath( strPath );
			if ( strAbsolute.GetLength() > 0 )
				strPath = strAbsolute;

			// see what type of value we need to put
			DWORD dwValueType = CModulePath::PlatformSupports_REG_EXPAND_SZ_Values() ?
								REG_EXPAND_SZ : REG_SZ;

			lRes = RegSetValueEx( regkey, NULL, 0, dwValueType,
 							     (CONST BYTE *)((LPCTSTR)strPath),
							     (strPath.GetLength() + 1) * sizeof(TCHAR) );

            ASSERT(lRes == ERROR_SUCCESS);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\shellext\mmcshext.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       mmcshext.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by mmcshext.rc
//
#define IDS_PROJNAME                    100
#define IDR_EXTRACTICON                 101
#define IDR_HHCOLLECTIONWRAPPER         102
#define IDR_MAINFRAME                   128

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\shellext\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

#include <ntverp.h>
#include <winver.h>
#include <dlgs.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "MMC Shell Extension DLL"
#define VER_INTERNALNAME_STR            "mmcshext.dll"
#define VER_ORIGINALFILENAME_STR        "mmcshext.dll"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\shellext\hhcwrap.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       hhcwrap.h
//
//--------------------------------------------------------------------------

// hhcwrap.h : Declaration of the class CHHCollectionWrapper

#ifndef __HHCWRAP_H_
#define __HHCWRAP_H_

#include "mmcshext.h"       // main symbols
#include "hcolwrap.h"       // idl generated header
#include <collect.h>

#ifdef ASSERT
#undef ASSERT
#endif
#define ASSERT(e)        // get rid of the assert symbol.


/////////////////////////////////////////////////////////////////////////////
// CHHCollectionWrapper
class ATL_NO_VTABLE CHHCollectionWrapper : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CHHCollectionWrapper, &CLSID_HHCollectionWrapper>,
    public IHHCollectionWrapper
{
public:
    CHHCollectionWrapper()
    {
    }

    STDMETHOD(Open) (LPCOLESTR FileName);

    STDMETHOD(Save)();

    STDMETHOD(Close)();

    STDMETHOD(RemoveCollection) (BOOL bRemoveLocalFiles);

    STDMETHOD(SetFindMergedCHMS) (BOOL bFind);

    
    STDMETHOD(AddFolder) (
        LPCOLESTR szName, 
        DWORD Order, 
        DWORD *pDWORD, 
        LANGID LangId
    );
    
    STDMETHOD(AddTitle) (
        LPCOLESTR Id, 
        LPCOLESTR FileName,
        LPCOLESTR IndexFile, 
        LPCOLESTR Query,
        LPCOLESTR SampleLocation, 
        LANGID Lang, 
        UINT uiFlags,
        ULONG_PTR pLocation,  
        DWORD *pDWORD,
        BOOL bSupportsMerge, 
        LPCOLESTR QueryLocation
    );


DECLARE_REGISTRY_RESOURCEID(IDR_HHCOLLECTIONWRAPPER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CHHCollectionWrapper)
    COM_INTERFACE_ENTRY_IID(IID_IHHCollectionWrapper, IHHCollectionWrapper)
END_COM_MAP()

private:
    CCollection m_collection;
};

#endif //__HHCWRAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\shellext\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc.

!ENDIF

MAJORCOMP=admin
MINORCOMP=MMC

TARGETNAME=mmcshext
TARGETPATH=obj
TARGETTYPE=DYNLINK

DLLENTRY=_DllMainCRTStartup
UMTYPE=windows

WIN32_WINNT_VERSION=0x0400
WIN32_IE_VERSION=0x0500
SUBSYSTEM_VERSION=4.00

USE_NATIVE_EH=1
USE_RTTI=1
USE_VCCOM=1
USE_STL=1
USE_MSVCRT=1
USE_STATIC_ATL=1
ATL_VER=30

!ifdef PrivateBuild_NoLocalSC
C_DEFINES = $(C_DEFINES) -DPrivateBuild_NoLocalSC
!endif

#
# Enable Fusion Build Magic (preprocess the manifest, stick in resources)
#
# The value of SXS_MANIFEST_RESOURCE_ID *must* be 2, to match a hardcoded value
# in WinbasePrivateCreateActCtxForHModule (winbase.inl).
#
SXS_ASSEMBLY_NAME                 = Microsoft.Windows.MMC
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT = 1
SXS_MANIFEST                      = mmcshext.manifest
SXS_MANIFEST_IN_RESOURCES         = 1
SXS_NO_BINPLACE                   = 1
SXS_MANIFEST_RESOURCE_ID          = 2

C_DEFINES = $(C_DEFINES) -DISOLATION_AWARE_ENABLED

#
# Shfusion.lib causes linker warnings. Ignore them.
#
LINKER_FLAGS=$(LINKER_FLAGS) -ignore:4049,4217

# Use LINKLIBS (gets passed first) if: (from build.hlp)
#  You are building a dynamic link.
#  You are exporting something that's defined in some other component library that you also build.
#  In your dirs file in the subdirectory above, you have ordered it so that the component libraries
#     are around before you build the dynamic link.
LINKLIBS = \
	..\..\core\$(CharWidth)\$(O)\uicore.lib

TARGETLIBS = \
	$(SDK_LIB_PATH)\kernel32.lib    \
	$(SDK_LIB_PATH)\user32.lib      \
	$(SDK_LIB_PATH)\gdi32.lib      \
	$(SDK_LIB_PATH)\ole32.lib       \
	$(SDK_LIB_PATH)\oleaut32.lib    \
	$(SDK_LIB_PATH)\advapi32.lib    \
	$(SDK_LIB_PATH)\uuid.lib        \
	$(SDK_LIB_PATH)\comctl32.lib    \
	$(SDK_LIB_PATH)\shell32.lib     \
	$(SDK_LIB_PATH)\hhsetup.lib

DLLDEF=..\mmcshext.def

INCLUDES = \
	..\; 					\
	..\..\types\idl\$(O);	\
	..\..\inc;				\

PRECOMPILED_INCLUDE = ..\stdafx.h
PRECOMPILED_CXX = 1

# This target is required so $O\mmcshext.res doesn't become the default target
# for makefile.def.  We want "all" to be the default target.
#
# We have to go to this effort because sources(.inc) is included very early
# in makefile.def.  makefile.inc is the place where this would naturally go,
# but we don't want to have to maintain this dependency list in
# ansi\makefile.inc and unicode\makefile.inc.
dummytarget:    all

$O\mmcshext.res:            \
    ..\extract.rgs          \
    ..\hhcwrap.rgs          \
    ..\..\conui\res\mmc.ico

SOURCES =    \
    ..\mmcshext.rc   \
    ..\extract.cpp   \
    ..\mmcshext.cpp  \
    ..\hhcwrap.cpp   \
    ..\xmlfile.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\shellext\stdafx.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.h
//
//--------------------------------------------------------------------------

// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__CFE11CCC_8001_11D2_BCF8_00C04F72C717__INCLUDED_)
#define AFX_STDAFX_H__CFE11CCC_8001_11D2_BCF8_00C04F72C717__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__CFE11CCC_8001_11D2_BCF8_00C04F72C717__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\shellext\stdafx.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stdafx.cpp
//
//--------------------------------------------------------------------------

// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

/*
#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\shellext\xmlfile.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 1999
 *
 *  File:      xmlfile.h
 *
 *  Contents:  functions to inspect XML document and extract the app. icon from it
 *
 *  History:   17-Dec-99 audriusz     Created
 *
 *--------------------------------------------------------------------------*/

#ifndef XMLFILE_H_INCLUDED
#define XMLFILE_H_INCLUDED
#pragma once

// this function validates xml document and loads console icon from it if valid
HRESULT ExtractIconFromXMLFile(LPCTSTR lpstrFileName, CPersistableIcon &persistableIcon);


#endif // XMLFILE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\inc\init.cxx ===
/*
 *      init.cxx
 *
 *
 *      Copyright (c) 1998 Microsoft Corporation
 *
 *      PURPOSE:        Initializes/deinitializes all required libraries
 *                              Designed to be included into a target DLL file.
 *
 *
 *      OWNER:          vivekj
 */

//              free functions


BOOL
CMMCFrame::s_fInitialized = FALSE;


/* CMMCFrame::CMMCFrame
 *
 * PURPOSE:             Constructor. Initializes the MMC frame class.
 *
 * PARAMETERS:
 *                void:
 */
CMMCFrame::CMMCFrame(void)
{
}



/* CMMCFrame::~CMMCFrame
 *
 * PURPOSE:             Destructor
 *
 * PARAMETERS: None
 *
 */
CMMCFrame::~CMMCFrame()
{
}




/* CMMCFrame::DeinitInstance
 *
 * PURPOSE:             Deinitializes the particular loaded instance of the DLL.
 *
 * PARAMETERS:
 *                void:
 *
 * RETURNS:
 *              void
 */
void
CMMCFrame::DeinitInstance( void )
{
    CBaseUIFrame::DeinitInstance();
}



/* CMMCFrame::ScInitApplication
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *                void:
 *
 * RETURNS:
 *              SC
 */
SC CMMCFrame::ScInitApplication( void )
{
        SC sc = S_OK;

        sc = ScInitApplicationBaseMMC();
        if (sc)
                goto Error;

Cleanup:
        return sc;

Error:
        TraceError(_T("CMMCFrame::ScInitApplication"), sc);
        goto Cleanup;
}

//
// Must uninitialize things that were initialized in
// ScInitApplication.
//
void CMMCFrame::DeinitApplication(void)
{
}


/* CMMCFrame::ScInitInstance
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *                void:
 *
 * RETURNS:
 *              SC
 */
SC CMMCFrame::ScInitInstance( void )
{
        SC              sc = S_OK;
        DWORD   dwFlags = 0;

        sc = CBaseUIFrame::ScInitInstance();
        if (sc)
                goto Error;

        sc = ScInitInstanceBaseMMC();
        if (sc)
                goto Error;

Cleanup:
        return sc;

Error:
        TraceError(_T("CMMCFrame::ScInitInstance"), sc);
        goto Cleanup;
}






CBaseFrame * PframeCreate( void )
{
        CMMCFrame *             pframe;

        pframe = new CMMCFrame;

        return pframe;
}



/* CMMCFrame::Initialize
 *
 * PURPOSE:             This version of Initialize is designed to be called from the DLL_PROCESS_ATTACH section
 *                              of DllMain. It does simple things like setting global static variables.
 *
 * PARAMETERS:
 *              INSTANCE                            hinst:              The handle to the running instance.
 *              HINSTANCE                           hinstPrev:  The handle to any previous instance.
 *              CBaseFrame::PropSheetProviderType   pspt:               The type of property pages needed.
 *                                                  LPSTR:
 *              int                                 n:
 *
 * RETURNS:
 *              void
 */
void
CMMCFrame::Initialize(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR, int n)
{
        CBaseUIFrame::s_hinst = hinst;
        CBaseFrame::s_hinstPrev = hinstPrev;
}

/*      CMMCFrame::Initialize()
 *
 *      PURPOSE:        Initializes the DLL. Note: This should be called by all DLL entry points
 *                              EXCEPT DLLMain, because it creates new threads, which DLLMain cannot do.
 *                              If it is called from DLLMain, the system will hang.
 *
 *      PARAMETERS:     None
 */
void CMMCFrame::Initialize()
{
        SC sc = S_OK;

        if(!s_fInitialized)
        {
                s_fInitialized = TRUE;

                CBaseFrame::s_pframe = PframeCreate();
                if (!CBaseUIFrame::Pframe())
                {
                        sc = E_OUTOFMEMORY;
                        goto Error;
                }

                if (!CBaseFrame::s_hinstPrev)
                {
                        sc = CBaseUIFrame::Pframe()->ScInitApplication();
                        if (sc)
                                goto Error;
                }

                sc = CBaseUIFrame::Pframe()->ScInitInstance();
                if (sc)
                        goto Error;
        }

Cleanup:
        return;

Error:
        TraceError(_T("CMMCFrame::Initialize"), sc);
        MMCErrorBox(sc);

        if (CBaseUIFrame::Pframe())
        {
                CBaseUIFrame::Pframe()->DeinitInstance();
                CBaseUIFrame::Pframe()->DeinitApplication();
                delete CBaseUIFrame::Pframe();
        }

        goto Cleanup;
}


/* CMMCFrame::Uninitialize
 *
 * PURPOSE:             Uninitialized the DLL, freeing up any resources. This should be
 *                              called from the DLL_PROCESS_DETACH section of DllMain.
 *
 * PARAMETERS: None
 *
 * RETURNS:
 *              void
 */
void
CMMCFrame::Uninitialize()
{
        if(s_fInitialized)      // only uninitialize once
        {

                if (CBaseUIFrame::Pframe())
                {
                        CBaseUIFrame::Pframe()->DeinitInstance();
                        CBaseUIFrame::Pframe()->DeinitApplication();
                        delete CBaseUIFrame::Pframe();
                }
        }

        s_fInitialized = FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\inc\targetdll.cxx ===
/*
 *      targetdll.cxx
 *
 *
 *      Copyright (c) 1998-1999 Microsoft Corporation
 *
 *      PURPOSE:        Implements the DLL entry points.
 *
 *
 *      OWNER:          ptousig
 */
#ifndef _SNAPINLIST_FILE
    #error  _SNAPINLIST_FILE not defined
#endif

#ifndef _FREGISTERTYPELIB
    #define _FREGISTERTYPELIB       TRUE    // define this equal to FALSE to avoid registering the typelib.
#endif  //_FREGISTERTYPELIB

#ifndef SNAPIN_COM_OBJECTS
    #define SNAPIN_COM_OBJECTS
#endif


extern "C"
{
    BOOL WINAPI _CRT_INIT( HANDLE hInstance, DWORD  nReason, LPVOID pReserved );
}

#define  DECLARE_SNAPIN(_snapin)                                                                                                                                                                \
template CComponentDataTemplate<_snapin, CComponent, &CLSID_ComponentData_##_snapin>;                                                   \
typedef  CComponentDataTemplate<_snapin, CComponent, &CLSID_ComponentData_##_snapin> t_ComponentData_##_snapin; \
typedef  CSnapinAboutTemplate<_snapin, &CLSID_SnapinAbout_##_snapin> t_SnapinAbout_##_snapin;

#include _SNAPINLIST_FILE

// Declare the ATL COM object map.
BEGIN_OBJECT_MAP(ObjectMap)

#define DECLARE_SNAPIN(_snapin)                                                                                 \
OBJECT_ENTRY(CLSID_ComponentData_##_snapin,     t_ComponentData_##_snapin)      \
OBJECT_ENTRY(CLSID_SnapinAbout_##_snapin,       t_SnapinAbout_##_snapin)        \

#include _SNAPINLIST_FILE
SNAPIN_COM_OBJECTS
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    SC              sc;

    CBaseFrame::s_hinst = hInstance;

    if (dwReason == DLL_PROCESS_ATTACH)
    {
        //
        // since _CRT_INIT will create global variables/objects we must make sure
        // that it is called before we initialize ourselves.
        //
        if (!_CRT_INIT(hInstance, dwReason, lpReserved ))
        {
            sc = ScFromWin32(::GetLastError());
            goto Error;
        }

        CMMCFrame::Initialize(hInstance, NULL, NULL, SW_RESTORE);
        _Module.Init(ObjectMap, hInstance);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        CMMCFrame::Uninitialize();

        //
        // since _CRT_INIT will destroy global variables/objects we must make sure
        // that it is called after we have unitialized ourselves.
        //
        if (!_CRT_INIT(hInstance, dwReason, lpReserved ))
        {
            sc = ScFromWin32(::GetLastError());
            goto Error;
        }
    }
    else if (!_CRT_INIT(hInstance, dwReason, lpReserved ))
    {
        sc = ScFromWin32(::GetLastError());
        goto Error;
    }


    return TRUE;    // ok

Error:
    MMCErrorBox(sc);
    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    CMMCFrame::Initialize();
    return(_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    CMMCFrame::Initialize();
    return _Module.GetClassObject(rclsid, riid, ppv);
}


HRESULT RegisterSnapins(BOOL fRegister)
{
    HRESULT hr = S_OK;

    // Register/unregister all snapins.
BEGIN_SNAPIN_MAP()
#define DECLARE_SNAPIN(_snapin) SNAPIN_ENTRY(t_ComponentData_##_snapin, fRegister)
#include _SNAPINLIST_FILE
END_SNAPIN_MAP()

return hr;
}


/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    HRESULT hr      = S_OK;
    CMMCFrame::Initialize();
    hr = RegisterSnapins(TRUE);                     // registers all snap-ins.
    if (FAILED(hr))
        goto Error;
    hr = _Module.RegisterServer(_FREGISTERTYPELIB); // registers object, typelib and all interfaces in typelib
    if (hr)
        goto Error;
    CMMCFrame::Uninitialize();                      // hack to avoid a multithreaded uninit in DllMain
Cleanup:
    return hr;
Error:
goto Cleanup;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    HRESULT hr      = S_OK;
    CMMCFrame::Initialize();
    hr = RegisterSnapins(FALSE);    // unregisters all snap-ins.
    if (FAILED(hr))
        goto Error;
    hr = _Module.UnregisterServer();// does not delete the registry keys.
    if (FAILED(hr))
        goto Error;
    CMMCFrame::Uninitialize();                      // hack to avoid a multithreaded uninit in DllMain
Cleanup:
    return hr;
Error:
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\lib\baseatl.cxx ===
#include <headers.hxx>
#include <atliface.h>
#include <atlimpl.cpp>


// The one and only instance of CComModule.
CComModule _Module;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\shellext\xmlfile.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1999 - 1999
 *
 *  File:      xmlfile.cpp
 *
 *  Contents:  Implements extracting console icon from XML file
 *
 *  History:   17-Dec-99 audriusz   Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.h"
#include "shlobj.h"
#include "Extract.h"
#include "base64.h"
#include "xmlfile.h"
#include "strings.h"

//---------------------------------------------------------------------------
// static (private) implementation helpers used thru this file
//---------------------------------------------------------------------------
static bool FindStringInData( LPCSTR &pstrSource, int nBytesPerChar, DWORD &dwCharsLeft, LPCSTR pstrKey);
static HRESULT DecodeBase64Fragment( LPCSTR &pstrSource, int nBytesPerChar, DWORD &dwCharsLeft, HGLOBAL& hgResult);
static HRESULT FindAndReadIconData(LPCSTR &pstrSource, int nBytesPerChar, DWORD &dwCharsLeft, LPCSTR strIconName, HGLOBAL& hglobIcon);
static HRESULT LoadIconFromHGlobal(HGLOBAL hData, HICON& hIcon);
static HRESULT ValidateXMLDocument(LPCSTR &pFileData, DWORD &dwLen, int *piBytesPerEnglishChar = NULL);

// following function is a friend of class CXMLPersistableIcon. If renaming, take this into accnt
static HRESULT LoadIconFromXMLData(LPCSTR pFileData, DWORD dwLen, CPersistableIcon &persistableIcon);


/***************************************************************************\
 *
 * FUNCTION:  FindStringInData
 *
 * PURPOSE:  This function locates the string in provided data
 *           NOTE - it matches first byte only (codepage of UNICODE string is ignored)
 *
 * PARAMETERS:
 *    LPCSTR &pstrSource    - [in/out] - data to search thru / possition
 *                            of the first char following the found match
 *    int nBytesPerChar     - [in] - width of the character
 *                            ( only the first byte of each character will be examined )
 *    DWORD &dwCharsLeft    - [in/out] - init. data len / data left after matching string
 *    LPCSTR pstrKey        - [in] - substring to search
 *
 * RETURNS:
 *    bool  - true if succeeded
 *
\***************************************************************************/

// Following sample illustrates algorithm used for the search.
// we will try to locate "Console" in the string "Microsoft Management Console"

//------------------------------------------------
// Standard search (a la strstr)
//------------------------------------------------
// 1.
//   Microsoft Management Console
//   Console                            <- comparing (fails - move to the next char)
// 2.
//   Microsoft Management Console
//    Console                           <- comparing (fails - move to the next char)
//  ------------------------ (19 steps skipped)
// 22.
//                        Console       <- comparing (succeeds)
//------------------------------------------------
// More inteligent search
//------------------------------------------------
// 1.     ! <- last char in searched seq
//  Microsoft Management Console
//  Console                            <- comparing (fails - last char in searched seq is 'o';
//                                        and 'o' is 3rd character from the end in the key;
//                                        so we can advance by 2 chars to match it)
// 2.     ! <- matching 'o' to last 'o' in the key
//  Microsoft Management Console
//    Console                          <- comparing (fails - last char in searched seq is 't';
//                                        't' is not in the key
//                                        so we can advance by key length (7 chars) to skip it)
// 3.        ! <- pos following the last char in searched seq
//  Microsoft Management Console
//           Console                   <- comparing (fails - last char in searched seq is 'e';
//                                        'e' is last character in the key;
//                                         we still can advance by key length (7 chars) to skip it)
// 4.               ! <- pos following the last char in searched seq
//  Microsoft Management Console
//                  Console            <- comparing (fails)
// 5.                     ! <- match point
//  Microsoft Management Console
//                    Console          <- comparing (fails)
// 6.                       ! <- match point
//  Microsoft Management Console
//                       Console       <- comparing (succeeds)
//------------------------------------------------

static bool
FindStringInData( LPCSTR &pstrSource, int nBytesPerChar, DWORD &dwCharsLeft, LPCSTR pstrKey)
{
    typedef unsigned short KeyLen_t;
    static KeyLen_t nKeyDist[256]; // static - to keep stack small

    // calculate the key length
    DWORD dwKeyLen = strlen(pstrKey);

    // test for empty search key
    if (!dwKeyLen)
        return true; // we always match empty strings

    // test for longer search key than data provided
    if (dwKeyLen > dwCharsLeft)
        return false; // we'll never find longer substrings than the source

    // key length var size is not too big to minimize tho lookup table size
    KeyLen_t nKeyLen = (KeyLen_t)dwKeyLen;

    // recheck here if the key isn't too long
    if ((DWORD)nKeyLen != dwKeyLen) // key len does not fit to our variable -
        return false;               // we do not deel with such a long keys


    // form the table holding minimal character distance from the end of pstrKey
    // It is used for increasing search speed:
    // When key does not match at current location, [instead of trying one location ahead,]
    // algorythm checks the last character in sequence tested with a key (data[keylen-1]).
    // now we check how far this character may be from the end of the key - we will have
    // distance of all key length in case character is not a part of the key.
    // we can safelly advance by that much. Sometimes we'll be positioning the key at whole
    // key_len offsets from previous test position, sometimes less - depending on data.

    // initialize the table. The distance is keylen value for all characters not existing in the key
    for (unsigned i = 0; i < sizeof(nKeyDist)/sizeof(nKeyDist[0]); ++i)
        nKeyDist[i] = nKeyLen;

    // now set minimal distance for characters in the key.
    // Note, that the last character is not included intensionally - to make
    // distance to it equal to whole key length
    for (i = 0; i < nKeyLen - 1; ++i)
        nKeyDist[pstrKey[i]] = nKeyLen - (KeyLen_t)i - 1;

    // we are done with initialization. Time for real work.

    LPCSTR p = pstrSource;             // to speed it up: we use local variables
    DWORD dwLeft = dwCharsLeft;

    while ( 1 )
    {
        // set the pointers to start of inspected sequence
        LPCSTR ke = pstrKey; // pointer to evaluating key char
        LPCSTR pe = p;       // pointer to evaluating source char

        // try to match all characters in the key
        KeyLen_t nToMatch = nKeyLen;
        while ( *pe == *ke )
        {
            --nToMatch;
            pe += nBytesPerChar;
            ++ke;

            // inspect if there still are some chars to match
            if (!nToMatch)
            {
                // we return the possitive answer here
                // change the reference parameters accordingly
                // (pointing right after the string found)
                pstrSource = pe;
                dwCharsLeft = dwLeft - nKeyLen;
                return true;
            }
        }

        // chLastChar is used as an index
        // need to cast the char to unsigned char - else it will
        // not work correctly for values over 127
        // NTRAID#NTBUG9-185761-2000/09/18 AUDRIUSZ
        BYTE chLastChar = p[(nKeyLen - 1) * nBytesPerChar]; // the last char from evaluated source range

        // the key couldn't be found at the position we inspected.
        // we can advance source pointer as far as we can match
        // the position of the last character to any entry in the key
        // or whole key length else.
        // We have a table built for that

        const KeyLen_t nToSkip = nKeyDist[chLastChar];

        if ((DWORD)nToSkip + (DWORD)nKeyLen >= dwLeft)
            return false;   // gone too far... ( couldn't find the match )

        p += (nToSkip * nBytesPerChar);
        dwLeft -= nToSkip;
    }

    // we will not get here anyway...
    return false;
}


/***************************************************************************\
 *
 * METHOD:  DecodeBase64Fragment
 *
 * PURPOSE: decodes base64 data fragment pointed by arguments
 *
 * PARAMETERS:
 *    LPCSTR &pstrSource    - [in/out] - data to decode / possition
 *                            of the first char following the decoded data
 *    int nBytesPerChar     - [in] - width of the character
 *                            ( only the first byte of each character will be examined )
 *    DWORD &dwCharsLeft    - [in/out] - init. data len / data left after skipping converted
 *    HGLOBAL& hgResult     - decoded data
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
static HRESULT
DecodeBase64Fragment( LPCSTR &pstrSource, int nBytesPerChar, DWORD &dwCharsLeft, HGLOBAL& hgResult)
{
    HRESULT hrStatus = S_OK;
    LPCSTR p = pstrSource;
    DWORD  dwLeft = dwCharsLeft;
    const  size_t ICON_ALLOCATION_LEN = 8*1024; // big enough to have 1 allocation in most cases
    LPBYTE pDynamicBuffer = NULL;
    LPBYTE pConversionBuffer = NULL;
    size_t nCharsInDynamicBuffer = 0;
    size_t nDynamicBufferCapacity = 0;
    HGLOBAL hGlobAlloc = NULL;
    ASSERT(hResult == NULL);

    static base64_table conv;

    // convert until done or end is found
    while (1)
    {
        // standard conversion. converts 4 chars (6bit each) to 3 bytes
        BYTE inp[4];
        memset(&inp, 0 ,sizeof(inp));
        // collect 4 characters for conversion, if possible.
        for (int nChars = 0; nChars < 4 && dwLeft && *p != '<' && *p != '='; --dwLeft)
        {
            BYTE bt = conv.map2six(*p);
            p += nBytesPerChar;
            if (bt != 0xff)
                inp[nChars++] = bt;
        }

        // if nothing to convert - we are done
        if (!nChars)
            break;

        // make sure we have enough storage for result
        if (nChars + nCharsInDynamicBuffer > nDynamicBufferCapacity)
        {
            // need to extend the dynamic buffer
            LPBYTE pnewBuffer = (LPBYTE)realloc(pDynamicBuffer, nDynamicBufferCapacity + ICON_ALLOCATION_LEN);

            if (!pnewBuffer)
            {
                hrStatus = E_OUTOFMEMORY;
                goto ON_ERROR;
            }
            // assign new pointer
            pDynamicBuffer = pnewBuffer;
            nDynamicBufferCapacity += ICON_ALLOCATION_LEN;

            pConversionBuffer = &pDynamicBuffer[nCharsInDynamicBuffer];
        }

        // decode and put the staff to the memory;
        int nCharsPut = conv.decode4(inp, nChars, pConversionBuffer);
        // update count & current pointer
        nCharsInDynamicBuffer += nCharsPut;
        pConversionBuffer += nCharsPut;
    }

    // allocate the buffer and store the result data
    // The same buffer is not reused for conversion, because
    // it's assumed to be saffer to load icon from stream, containing only
    // as much data as required ( we would have larger buffer, containing some
    // uninitialized data at the end if returning buffer used for conversion)
    hGlobAlloc = GlobalAlloc(GMEM_MOVEABLE, nCharsInDynamicBuffer);
    if (hGlobAlloc == NULL)
    {
        hrStatus = E_OUTOFMEMORY;
        goto ON_ERROR;
    }

    // if we have characters, copy them to result
    if (nCharsInDynamicBuffer)
    {
        LPVOID pResultStorage = GlobalLock(hGlobAlloc);
        if (pResultStorage == NULL)
        {
            hrStatus = E_OUTOFMEMORY;
            goto ON_ERROR;
        }
        memcpy(pResultStorage, pDynamicBuffer, nCharsInDynamicBuffer);
        GlobalUnlock(hGlobAlloc);
    }

    // assign the memory handle to caller
    hgResult = hGlobAlloc;
    hGlobAlloc = NULL; // assign null to avoid releasing it

    // adjust poiters to start from where we finished the next time
    pstrSource = p;
    dwCharsLeft = dwLeft;

    hrStatus = S_OK;
ON_ERROR:   // note: ok result falls thru as well
    if (hGlobAlloc)
        GlobalFree(hGlobAlloc);
    if (pDynamicBuffer)
        free(pDynamicBuffer);

    return hrStatus;
}

/***************************************************************************\
 *
 * METHOD:  FindAndReadIconData
 *
 * PURPOSE: Function locates Icon data in the xml file data and loads it into HGLOBAL
 *
 * PARAMETERS:
 *    LPCSTR &pstrSource    - [in/out] - data to look thru / possition
 *                            of the first char following the decoded icon data
 *    int nBytesPerChar     - [in] - width of the character
 *                            ( only the first byte of each character will be examined )
 *    DWORD &dwCharsLeft    - [in/out] - init. data len / data left after skipping decoded
 *    LPCSTR strIconName    - [in] name of Icon to locate
 *                          - NOTE: it assumes icon data to be a base64-encoded stream, saved
 *                            as contents of XML element, having IconName as its attribute
 *    HGLOBAL& hglobIcon    - [out] - memory block containing icon data
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
static HRESULT FindAndReadIconData(LPCSTR &pstrSource, int nBytesPerChar, DWORD &dwCharsLeft, LPCSTR strIconName, HGLOBAL& hglobIcon)
{
    ASSERT(hglobIcon == NULL); // we do not free data here, pass null handler!

    // make local vars for efficiency
    DWORD dwLen = dwCharsLeft;
    LPCSTR pstrData = pstrSource;

    // locate the string with the name of icon (assume it's unique enough)
    const bool bIconFound = FindStringInData( pstrData, nBytesPerChar, dwLen, strIconName);
    if (!bIconFound)
        return E_FAIL;

    // now locate the end of tag '>' ( start of the contents )
    const bool bStartFound = FindStringInData( pstrData, nBytesPerChar, dwLen, ">" );
    if (!bStartFound)
        return E_FAIL;

    HRESULT hr = DecodeBase64Fragment( pstrData, nBytesPerChar, dwLen, hglobIcon);
    if (FAILED(hr))
        return hr;

    // update pointers to start from where we finished the next time
    dwCharsLeft = dwLen;
    pstrSource = pstrData;

    return S_OK;
}

/***************************************************************************\
 *
 * METHOD:  LoadIconFromHGlobal
 *
 * PURPOSE: Function extracts HICON from stream contained in HGLOBAL
 *
 * PARAMETERS:
 *    HGLOBAL hData [in] - data to load from
 *    HICON& hIcon  [out] - read icon
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
static HRESULT LoadIconFromHGlobal(HGLOBAL hData, HICON& hIcon)
{
    HRESULT hr = S_OK;

    // create the stream
    IStreamPtr spStream;
    hr = CreateStreamOnHGlobal(hData, FALSE/*do not release*/, &spStream);
    if (FAILED(hr))
        return hr;

    // read the icon as image list
    HIMAGELIST  himl = ImageList_Read (spStream);

    if (!himl)
        return E_FAIL;

    // retrieve icon from image list
    hIcon = ImageList_GetIcon (himl, 0, ILD_NORMAL);

    // destroy image list (no longer need it)
    ImageList_Destroy (himl);
    return S_OK;
}

/***************************************************************************\
 *
 * METHOD:  LoadIconFromXMLData
 *
 * PURPOSE: Loads icon from memory containing file data of XML document
 *
 * PARAMETERS:
 *    LPCSTR pFileData                  - file data suspected to contain XML document
 *    DWORD dwLen                       - the len of input data
 *    CPersistableIcon &persistableIcon - Icon to initialize upon successful loading
 *
 * RETURNS:
 *    HRESULT    - result code (S_OK - icon loaded, error code else)
 *
\***************************************************************************/
static HRESULT LoadIconFromXMLData(LPCSTR pFileData, DWORD dwLen, CPersistableIcon &persistableIcon)
{
    HRESULT hr = S_OK;
    int     nBytesPerChar = 0;

    // check if we recognize the document contents
    hr = ValidateXMLDocument(pFileData,dwLen, &nBytesPerChar);
    if (hr != S_OK) // hr == S_FALSE means format is not recognized
        return E_FAIL;

    // Get required keywords.
    USES_CONVERSION;
    LPCSTR lpcstrLarge = T2CA(XML_ATTR_CONSOLE_ICON_LARGE);
    LPCSTR lpcstrSmall = T2CA(XML_ATTR_CONSOLE_ICON_SMALL);
	HICON  hLargeIcon  = NULL;
	HICON  hSmallIcon  = NULL;

    // try to read large icon first
    HGLOBAL hgLargeIcon = NULL;
    hr = FindAndReadIconData(pFileData, nBytesPerChar, dwLen, lpcstrLarge, hgLargeIcon );
    if (FAILED(hr))
        return hr;

    // try to read small icon ( look behind the large one - it should be there!)
    HGLOBAL hgSmallIcon = NULL;
    hr = FindAndReadIconData( pFileData, nBytesPerChar, dwLen, lpcstrSmall, hgSmallIcon );
    if (FAILED(hr))
        goto ON_ERROR;

    // do get the handles of the icons!
    hr = LoadIconFromHGlobal(hgLargeIcon, hLargeIcon);
    if (FAILED(hr))
        goto ON_ERROR;

    hr = LoadIconFromHGlobal(hgSmallIcon, hSmallIcon);
    if (FAILED(hr))
        goto ON_ERROR;

	persistableIcon.m_icon32.Attach (hLargeIcon);
	persistableIcon.m_icon16.Attach (hSmallIcon);

    // done!
    hr = S_OK;

ON_ERROR:
	if (hLargeIcon && FAILED(hr))
		DestroyIcon(hLargeIcon);
	if (hSmallIcon && FAILED(hr))
		DestroyIcon(hSmallIcon);
    if (hgLargeIcon)
        GlobalFree(hgLargeIcon);
    return hr;
}

/***************************************************************************\
 *
 * METHOD:  ExtractIconFromXMLFile
 *
 * PURPOSE: Loads icon from file containing XML document
 *
 * PARAMETERS:
 *    LPCTSTR lpstrFileName             - name of file to inspect
 *    CPersistableIcon &persistableIcon - Icon to initialize upon successful loading
 *
 * RETURNS:
 *    HRESULT    - result code
 *
\***************************************************************************/
HRESULT ExtractIconFromXMLFile(LPCTSTR lpstrFileName, CPersistableIcon &persistableIcon)
{
    HRESULT hrResult = S_OK;

    // open the file
    HANDLE hFile = CreateFile(lpstrFileName, GENERIC_READ, FILE_SHARE_READ,
                              NULL, OPEN_EXISTING, 0, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
        return hrResult = HRESULT_FROM_WIN32(GetLastError());

    // map data into virtual memory
    HANDLE hMapping = CreateFileMapping(hFile, NULL/*sec*/, PAGE_READONLY,
                                        0/*sizeHi*/, 0/*sizeLo*/, NULL/*szname*/);

    if (hMapping == NULL)
    {
        hrResult = HRESULT_FROM_WIN32(GetLastError());
        CloseHandle(hFile);
        return hrResult;
    }

    // get pointer to physical memory
    LPVOID pData = MapViewOfFile(hMapping, FILE_MAP_READ, 0/*offHi*/, 0/*offLo*/, 0/*len*/);

    if (pData)
    {
        // we are sure here the sizeHi is zero. mapping should fail else
        DWORD dwLen = GetFileSize(hFile, NULL/*pSizeHi*/);

        // try to load icon from mapped data
        hrResult = LoadIconFromXMLData((LPCSTR)pData, dwLen, persistableIcon);

        // we do not need a view any more
        UnmapViewOfFile(pData);
        pData = NULL;
        // fall thru to release handles before return
    }
    else // getting the view failed
    {
        hrResult = HRESULT_FROM_WIN32(GetLastError());
        // fall thru to release handles before return
    }

    CloseHandle(hMapping);
    CloseHandle(hFile);
    return hrResult;
}

/***************************************************************************\
 *
 * METHOD:  ValidateXMLDocument
 *
 * PURPOSE: Validates XML document loaded into memory
 *          NOTE: it's rather __VERY__ weak inspection. it only checks if doc starts with '<'
 *
 * PARAMETERS:
 *    LPCSTR &pFileData         - [in/out] - data to look thru / start of xml documet contents
 *    DWORD &dwLen              - [in/out] - init. data len / data left after skipping header
 *    int *piBytesPerEnglishChar  - [out, optional] - bytes occupied by english character
 *
 * RETURNS:
 *    HRESULT    - (S_FALSE - data does not qualify for XML document)
 *
\***************************************************************************/
static HRESULT
ValidateXMLDocument(LPCSTR &pFileData, DWORD &dwLen, int *piBytesPerEnglishChar /*= NULL*/)
{
    // default to ansi when not sure
    int     nBytesPerChar = 1;

    if (dwLen >= 2)
    {
        // raw UNICODE big endian ?
        if ((unsigned char)pFileData[1] == 0xff && (unsigned char)pFileData[0] == 0xfe)
        {
            // to maintain simplicity of the code, we will treat this like little endian.
            // we just position file pointer incorrectly.
            // since everything we are intersted:
            //          - is in page 0 (xml tags and base 64)
            //          - never is at the end of file ( closing tags expected )
            //          - we do not care about the page of any data
            //  :we can mix the page codes of the elements and pretend dealing w/ little endian
            pFileData += 3; // skip UNICODE signature and first page number
            dwLen -= 3;
            dwLen /= 2;     // we count characters - seems like we have less of them
            nBytesPerChar = 2;
        }
        // raw UNICODE little endian ?
        else if ((unsigned char)pFileData[0] == 0xff && (unsigned char)pFileData[1] == 0xfe)
        {
            pFileData += 2; // skip UNICODE signature
            dwLen -= 2;
            dwLen /= 2;     // we count characters - seems like we have less of them
            nBytesPerChar = 2;
        }
        // compressed UNICODE (UTF 8) ?
        else if (dwLen >= 2 && (unsigned char)pFileData[0] == 0xef
             && (unsigned char)pFileData[1] == 0xbb && (unsigned char)pFileData[2] == 0xbf)
        {
            //just skip signature and treat it as ANSI
            pFileData += 3; // skip UNICODE signature
            dwLen -= 3;
            nBytesPerChar = 1;
        }
    }

    // skip whitespaces
    char ch;
    while (dwLen && (((ch = *pFileData)==' ') || (ch=='\t') || (ch=='\n') || (ch=='\r')))
    {
        pFileData += nBytesPerChar;
        --dwLen;
    }

    // check if we have a valid xml file (it should open with '<')
    if (!dwLen || *pFileData != '<')
        return S_FALSE;

    if (piBytesPerEnglishChar)
        *piBytesPerEnglishChar = nBytesPerChar;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\lib\basesnap.cxx ===
/*
 *      basesnap.cxx
 *
 *
 *      Copyright (c) 1998-1999 Microsoft Corporation
 *
 *      PURPOSE:        Defines CBaseSnapin.
 *
 *
 *      OWNER:          ptousig
 */

#include "headers.hxx"

#include "basesnap.rgs"

// Some substitution strings used to create a registry script on the fly.
#define szDLLName               L"DLLName"
#define szModule                L"Module"
#define szCLSID_Snapin          L"CLSID_Snapin"
#define szCLSID_About           L"CLSID_About"
#define szClassName             L"ClassName"
#define szSnapinName            L"SnapinName"
#define szCLSID_NodeType        L"CLSID_NodeType"

// -----------------------------------------------------------------------------
CBaseSnapin::CBaseSnapin(void)
{
}

// -----------------------------------------------------------------------------
CBaseSnapin::~CBaseSnapin(void)
{
    // Release all of our root items.
    while (m_ilRootItems.empty() == false)
    {
        static_cast<LPDATAOBJECT>(m_ilRootItems.back())->Release();
        m_ilRootItems.pop_back();
    }
}

// -----------------------------------------------------------------------------
// The simple version of Pitem() simply calls the full version.
//
CBaseSnapinItem *CBaseSnapin::Pitem(LPDATAOBJECT lpDataObject, HSCOPEITEM hscopeitem, long cookie)
{
    return Pitem(NULL, NULL, lpDataObject, hscopeitem, cookie);
}


// -----------------------------------------------------------------------------
// The full version of Pitem() attempts to find an existing CBaseSnapinItem
// that matches the given parameters. If it can't find any, it will create
// one.
//
// Note: In order to create a new item, one of the two first parameters must
//               be provided.
//
CBaseSnapinItem *CBaseSnapin::Pitem(
                                   CComponentData *        pComponentData,
                                   CComponent *            pComponent,
                                   LPDATAOBJECT            lpDataObject,
                                   HSCOPEITEM                      hscopeitem,
                                   long                            cookie)
{
    SC sc;
    CBaseSnapinItem *pitem = NULL;
    ItemList::iterator iter;

    // For debugging purposes, I don't want to modify the 'hscopeitem' parameter,
    // so I make a copy of it.
    HSCOPEITEM hscopeitem2 = hscopeitem;

    if (cookie)
    {
        //
        // We can simply cast the cookie into a CBaseSnapinItem *.
        //
        pitem = reinterpret_cast<CBaseSnapinItem *>(cookie);
        ASSERT(dynamic_cast<CBaseSnapinItem *>(pitem));
        goto Cleanup;
    }

    if (hscopeitem2 == 0 && lpDataObject == NULL)
    {
        //
        // We are being asked for the stand-alone root.
        //
        ASSERT(pComponentData);

        pitem = pComponentData->PitemStandaloneRoot();
        if (pitem)
            goto Cleanup;
    }

    if (lpDataObject)
    {
        CLSID clsid;

        //
        // Are we the snapin who created this item ?
        //
        sc = CBaseDataObject::ScGetClassID(lpDataObject, &clsid);
        if (sc)
            goto Error;

        if (::IsEqualCLSID(*PclsidSnapin(), clsid))
        {
            //
            // We created this item, we can simply cast the pointer
            // to a CBaseSnapinItem.
            //
            pitem = dynamic_cast<CBaseSnapinItem *>(lpDataObject);
            ASSERT(pitem);
            goto Cleanup;
        }
    }

    if (lpDataObject && hscopeitem2 == 0)
    {
        //
        // We got an IDataObject *, but we were not given a HSCOPEITEM :-(
        // We'll get it from the CF_EXCHANGE_ADMIN_HSCOPEITEM clipboard format.
        //
        sc = CBaseDataObject::ScGetAdminHscopeitem(lpDataObject, &hscopeitem2);
        if (sc == DV_E_FORMATETC)
        {
            //
            // We don't own this item, we were not given a HSCOPEITEM and it
            // doesn't support CF_EXCHANGE_ADMIN_HSCOPEITEM.
            //
            // $REVIEW (ptousig) Does this ever happen ?
            //
            ASSERT("Does this ever happen ?" && FALSE);
            sc = S_OK;
        }
        else if (sc)
            goto Error;
    }

    // If the user adds the snapin twice in the same console, we will
    // be asked for two root items. If we are being asked for the same root
    // twice, then the "if (hscopeitem2 == 0 && lpDataObject == NULL)" above
    // will have caught it. If we get this far, it means we are being asked
    // for another root item. So we want to search through our existing
    // list of roots only if we have a HSCOPEITEM.
    if (hscopeitem2)
    {
        //
        // We are going to search through our list of existing root items
        // to find one with this HSCOPEITEM.
        // We can't really use a STL map here because the HSCOPEITEM of the items
        // will change after the root is added to the list. Besides, we don't expect
        // more than a handful of roots anyway.
        //
        for (iter = m_ilRootItems.begin(); iter != m_ilRootItems.end(); iter++)
        {
            if ((*iter)->Hscopeitem() == hscopeitem2)
            {
                pitem = *iter;
                goto Cleanup;   // We found it, stop looking
            }
        }
    }

    //
    // If we reach this point it's because we couldn't find this node.
    // So we create a new one and append it to the end of the list.
    //
    sc = ScCreateRootItem(lpDataObject, hscopeitem2, &pitem);
    if (sc)
        goto Error;

    ASSERT(pitem);

    //
    // Initialize the new root
    //
    if (pComponentData)
        pitem->SetComponentData(pComponentData);

    sc = pitem->ScInit(this, NULL, 0, TRUE);
    if (sc)
        goto Error;

    // Add this new item to our list of roots.
    static_cast<LPDATAOBJECT>(pitem)->AddRef();
    m_ilRootItems.push_back(pitem);

    // If this is a standalone root, better tell the component data about it.
    if (hscopeitem2 == 0 && lpDataObject == NULL)
    {
        ASSERT(pComponentData);
        pComponentData->SetPitemStandaloneRoot(pitem);
    }

    if (lpDataObject)
    {
        BOOL fIsOwned = FALSE;
        CNodeType *pnodetype = NULL;

        // $REVIEW (ptousig) There's a better way of doing this.
        // We know we don't own that node, but ScInitializeNamespaceExtension expects
        // a CNodeType so we have to call this to get one.
        sc = ScIsOwnedDataObject(lpDataObject, &fIsOwned, &pnodetype);
        if (sc)
            goto Error;

        // Initialize the root item's code from the dataobject of the parent item.
        pitem->SetIsGhostRoot(TRUE);
        sc = pitem->ScInitializeNamespaceExtension(lpDataObject, hscopeitem2, pnodetype);
        if (sc)
            goto Error;
    }

Cleanup:
    // Make sure this item knows its HSCOPEITEM
    if (hscopeitem2)
        pitem->SetHscopeitem(hscopeitem2);

    ASSERT(pitem);
    return pitem;
Error:
    TraceError(_T("CBaseSnapin::Pitem"), sc);
    MMCErrorBox(sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Returns whether a dataobject is "owned" by this snapin. It does that
// by looking at the list of nodetypes this snapin says it can create, if
// this node is one of these, we assume we own it.
// As a side-effect, this function also returns the nodetype of the node.
//
// $REVIEW (ptousig) This is not an accurate test, we need to use the CCF_SNAPIN_CLASSID.
//
SC CBaseSnapin::ScIsOwnedDataObject(LPDATAOBJECT pdataobject, BOOL *pfIsOwned, CNodeType **ppnodetype)
{
    SC                      sc;
    BOOL            fIsOwned        = FALSE;
    CNodeType * pnodetype   = NULL;
    CLSID           clsid;
    INT                     isnr            = 0;

    ASSERT(pdataobject);
    ASSERT(pfIsOwned);
    ASSERT(ppnodetype);

    // Get the nodetype, in guid format, of the data object.
    sc = CBaseDataObject::ScGetNodeType(pdataobject, &clsid);
    if (sc)
        goto Error;

    for (isnr = 0; isnr < Csnr(); isnr ++)
    {
        if (IsEqualCLSID(*(Psnr(isnr)->pnodetype->PclsidNodeType()), clsid))
        {
            // We found the CLSID, keep track of its nodetype.
            pnodetype = Psnr(isnr)->pnodetype;
            SNRTypes snrtypes = Psnr(isnr)->snrtypes;

            // Do we enumerate nodes of this type? If so, we must be the owner.
            if ((snrtypes & snrEnumSP) || (snrtypes & snrEnumRP) || (snrtypes & snrEnumSM))
                fIsOwned = TRUE;
            break;                                                  // exit the loop.
        }
    }

Cleanup:
    *pfIsOwned      = fIsOwned;
    *ppnodetype     = pnodetype;
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScIsOwnedDataObject"), sc);
    goto Cleanup;
}

#ifdef _DEBUG
// -----------------------------------------------------------------------------
// Debug menu options
//
SnapinMenuItem CBaseSnapin::s_rgmenuitemBase[] =
{
    {IDS_Test, IDS_Test, 0, CCM_INSERTIONPOINTID_PRIMARY_TASK, NULL, 0, dwMenuNeverGray,        dwMenuNeverChecked},
#if 0
    {idsBarfTraces,                 idsBarfTracesStatusText,                        idmBarfTraces,                  CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
    {idsBarfClearDbgScreen, idsBarfClearDbgScreenStatusText,        idmBarfClearDbgScreen,  CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
    {idsBarfSCDescription,  idsBarfSCDescriptionStatusText,         idmBarfSCDescription,   CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
    {NULL,                                  idsBarfSeparatorStatusText,                     idmBarfSeparator1,              CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   MF_SEPARATOR,           dwMenuNeverGray,        dwMenuNeverChecked},
    {idsBarfSettings,               idsBarfSettingsStatusText,                      idmBarfSettings,                CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
    {idsBarfAll,                    idsBarfAllStatusText,                           idmBarfAll,                             CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
    {idsBarfMemoryChkpoint, idsBarfMemoryChkpointStatusText,        idmBarfMemoryChkpoint,  CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
    {idsBarfMemoryDiff,             idsBarfMemoryDiffStatusText,            idmBarfMemoryDiff,              CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
    {idsBarfValidateMemory, idsBarfValidateMemoryStatusText,        idmBarfValidateMemory,  CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
    {idsBarfTotalMemAllocd, idsBarfTotalMemAllocdStatusText,        idmBarfTotalMemAllocd,  CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
    {NULL,                                  idsBarfSeparatorStatusText,                     idmBarfSeparator3,              CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   MF_SEPARATOR,           dwMenuNeverGray,        dwMenuNeverChecked},
    {idsBarfDebugBreak,             idsBarfDebugBreakStatusText,            idmBarfDebugBreak,              CCM_INSERTIONPOINTID_PRIMARY_TASK,      NULL,   dwMenuAlwaysEnable,     dwMenuNeverGray,        dwMenuNeverChecked},
#endif
};

INT CBaseSnapin::s_cMenuItemBase = CMENUITEM(s_rgmenuitemBase);

// -----------------------------------------------------------------------------
SnapinMenuItem *CBaseSnapin::PmenuitemBase(void)
{
    return s_rgmenuitemBase;
}

// -----------------------------------------------------------------------------
INT CBaseSnapin::CMenuItemBase(void)
{
    return s_cMenuItemBase;
}
#endif // _DEBUG

// -----------------------------------------------------------------------------
// This table allows us to map a MMC verb to a specific bit in a dword.
//
VerbMap CBaseSnapin::s_rgverbmap[] =
{
    { vmOpen,               MMC_VERB_OPEN},
    { vmCopy,               MMC_VERB_COPY},
    { vmPaste,              MMC_VERB_PASTE},
    { vmDelete,             MMC_VERB_DELETE},
    { vmProperties, MMC_VERB_PROPERTIES},
    { vmRename,             MMC_VERB_RENAME},
    { vmRefresh,    MMC_VERB_REFRESH},
    { vmPrint,              MMC_VERB_PRINT},
    { vmCut,                MMC_VERB_CUT},
};

// -----------------------------------------------------------------------------
// Accesses a given entry in the VerbMap table.
//
VerbMap *CBaseSnapin::Pverbmap(INT i)
{
    ASSERT(i>=0 && i<Cverbmap());
    return &(s_rgverbmap[i]);
}

// -----------------------------------------------------------------------------
// Returns the number of entries in the VerbMap table.
//
INT CBaseSnapin::Cverbmap(void)
{
    return(sizeof(s_rgverbmap) / sizeof(VerbMap));
}

// -----------------------------------------------------------------------------
// Has the icon information been initialized ?
BOOL CBaseSnapin::s_fBaseSnapinInitialized = FALSE;

// -----------------------------------------------------------------------------
// The bitmaps containing all the icons
WTL::CBitmap CBaseSnapin::s_bmpImage16;
WTL::CBitmap CBaseSnapin::s_bmpImage32;

// -----------------------------------------------------------------------------
// The Registrar
//
CRegistrar CBaseSnapin::s_registrar;

// -----------------------------------------------------------------------------
// Initializes the global bitmaps (once) as well as the per-snapin bitmaps.
//
SC CBaseSnapin::ScInitBitmaps(void)
{
    DECLARE_SC(sc, _T("CBaseSnapin::ScInitBitmaps"));

    // Once for the whole app...
    if (s_fBaseSnapinInitialized == FALSE)
    {
        sc = BmpImage16().LoadBitmap(IDB_NODES16) ? S_OK : E_FAIL;
        if (sc)
            return sc;

        sc = BmpImage32().LoadBitmap(IDB_NODES32) ? S_OK : E_FAIL;
        if (sc)
            return sc;

        s_fBaseSnapinInitialized = TRUE;
    }

	if (BitmapSmall().IsNull())
	{
		sc = BitmapSmall().LoadBitmap(IDB_NODES16) ? S_OK : E_FAIL;
		if (sc)
			return sc;
	}

    if (BitmapLarge().IsNull())
	{
	    sc = BitmapLarge().LoadBitmap(IDB_NODES32) ? S_OK : E_FAIL;
		if (sc)
			return sc;
	}

    if (BitmapStaticSmall().IsNull())
	{
		sc = BitmapStaticSmall().LoadBitmap(IDB_FOLDER16) ? S_OK : E_FAIL;
		if (sc)
			return sc;
	}

    if (BitmapStaticSmallOpen().IsNull())
	{
		sc = BitmapStaticSmallOpen().LoadBitmap(IDB_FOLDER16OP) ? S_OK : E_FAIL;
		if (sc)
			return sc;
	}

    if (BitmapStaticLarge().IsNull())
	{
		sc = BitmapStaticLarge().LoadBitmap(IDB_FOLDER32) ? S_OK : E_FAIL;
		if (sc)
			return sc;
	}

    return sc;
}


inline HBITMAP CopyBitmap (HBITMAP hbm)
{
	return ((HBITMAP) CopyImage ((HANDLE) hbm, IMAGE_BITMAP, 0, 0, 0));
}


// -----------------------------------------------------------------------------
// MMC wants icons to persist in the .msc file.
//
SC CBaseSnapin::ScGetStaticFolderImage(HBITMAP *phSmallImage, HBITMAP *phSmallImageOpen, HBITMAP *phLargeImage, COLORREF *pcMask)
{
    ASSERT(phSmallImage && phSmallImageOpen && phLargeImage && pcMask);

    *phSmallImage     = CopyBitmap (BitmapStaticSmall());
    *phSmallImageOpen = CopyBitmap (BitmapStaticSmallOpen());
    *phLargeImage     = CopyBitmap (BitmapStaticLarge());
    *pcMask           = RGB (255, 0, 255);
    return S_OK;
}

// -----------------------------------------------------------------------------
// Compares two fields for sorting by MMC. This applies to regular result items, i.e. not to virtual
// list snapin items. Our snapins can override the compare and impact the sort. We use a smart compare
// to guess if the field is numeric. If so, we perform a numeric compare.
// Otherwise we use case insensitive string compare.
//
// On input, *pnResult contains the column number to compare.
// On output, *pnResult contains the result of our comparison:
//              -1 means A is smaller than B
//              0 means A is equal to B
//              1 means A is greater than B
//
SC CBaseSnapin::ScCompare(MMC_COOKIE cookieA, MMC_COOKIE cookieB, INT nColumn, INT * pnResult)
{
    // Declarations
    SC                                      sc;                     // execution code
    CBaseSnapinItem *       pitemA  = NULL;                         // snapin item A
    CBaseSnapinItem *       pitemB  = NULL;                         // snapin item B
    tstring                 strBufferA;                             // field A
    tstring                 strBufferB;                             // field B
    LONG                    lValueA = 0;                            // numeric value for field A
    LONG                    lValueB = 0;                            // numeric value for field B

    // Validate data
    ASSERT(pnResult);

    // Check that these cookies are not special cookies
    ASSERT(IS_SPECIAL_COOKIE(cookieA) == FALSE);
    ASSERT(IS_SPECIAL_COOKIE(cookieB) == FALSE);

    // Cast the cookies into snapin items
    pitemA = reinterpret_cast<CBaseSnapinItem *>(cookieA);
    pitemB = reinterpret_cast<CBaseSnapinItem *>(cookieB);

    // Get the fields from the snapin items
    sc = pitemA->ScGetField(pitemA->PcolinfoexDisplay(nColumn)->Dat(), strBufferA);
    if (sc)
        goto Error;
    sc = pitemB->ScGetField(pitemB->PcolinfoexDisplay(nColumn)->Dat(), strBufferB);
    if (sc)
        goto Error;

    ASSERT(FALSE && "Use Dat and compare data type properly");

    // Use the default string compare (case-insensitive)
    *pnResult = _tcsicmp(strBufferA.data(), strBufferB.data());
    if (*pnResult < 0)
        *pnResult = -1;         // string A < string B
    else if (*pnResult > 0)
        *pnResult = 1;
    else
        *pnResult = 0;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScCompare()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScCreateMultiSelectionDataObject
 *
 * PURPOSE:                     Creates a multiselect data object - we store a list of selected object in this special object.
 *
 * PARAMETERS:
 *                                      LPDATAOBJECT *                  ppDataObject                    Pointer to a pointer to the multiselect snapin item to create.
 *                                      CComponent *                    pComponent                              Pointer to the component object.
 *
 * RETURNS:
 *                                      SC                                                                                              Execution code
 */
SC
CBaseSnapin::ScCreateMultiSelectionDataObject(LPDATAOBJECT * ppDataObject, CComponent * pComponent)
{
    // Declarations
    SC                                                                                      sc                                                      ;               // execution code
    HRESULT                                                                         hr                                                      = S_FALSE;              // local execution code
    RESULTDATAITEM                                                          rdi;                                                                            // a selected item
    BOOL                                                                            fFoundASelection                        = FALSE;                // did we find at least one selected item
    CBaseMultiSelectSnapinItem *                            pBaseMultiSelectSnapinItem      = NULL;                 // multiselect dataobject
    // are we processing the first object of the selected object set
    // Data validation
    ASSERT(ppDataObject);
    ASSERT(*ppDataObject == NULL);
    ASSERT(pComponent);

    // Allocate a typed multiselection data object
    sc = ScAllocateMultiSelectionDataObject(&pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;
    ASSERT(pBaseMultiSelectSnapinItem);

    // Assign the snapin - important for some clipboard formats
    pBaseMultiSelectSnapinItem->SetSnapin(this);

    // Identify the selected items
    ::ZeroMemory(&rdi,      sizeof(rdi));
    rdi.nIndex                      = -1;                                                                                                                           // first item requested
    rdi.nState                      = LVIS_SELECTED;                                                                                                        // only the selected items requested
    rdi.mask                        = RDI_STATE | RDI_INDEX | RDI_PARAM;                                                            // state, cookie and index

    // Get the result data interface
    ASSERT(pComponent->IpResultData());                                                                                                             // verify we have an IResultData interface
    while (S_OK == (hr = pComponent->IpResultData()->GetNextItem(&rdi)))
    {
        // Local declarations
        CBaseSnapinItem *       pitem = NULL;

        // Make sure we got a cookie for the item
        ASSERT(rdi.lParam);
        pitem = reinterpret_cast<CBaseSnapinItem *>(rdi.lParam);
        ASSERT(pitem);

        // Add the item to the list managed by our multiselect data object
        ASSERT(pBaseMultiSelectSnapinItem->PivSelectedItems());
        pBaseMultiSelectSnapinItem->PivSelectedItems()->push_back(pitem);

        // Remember we found a selected object
        fFoundASelection = TRUE;
    }
    if (FAILED(hr))
    {
        sc = hr;
        goto Error;
    }

    // Let the component it is in multiselect mode
    *(pComponent->PpMultiSelectSnapinItem()) = pBaseMultiSelectSnapinItem;

    // Make sure we found at least one selected object, otherwise we should never have been called in the first place
    ASSERT(fFoundASelection);

    // Set the result
    *ppDataObject = pBaseMultiSelectSnapinItem;

Cleanup:
    return sc;
Error:
    if (pBaseMultiSelectSnapinItem)
        delete pBaseMultiSelectSnapinItem;
    pBaseMultiSelectSnapinItem = NULL;

    TraceError(_T("CBaseSnapin::ScCreateMultiSelectionDataObject()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScAllocateMultiSelectionDataObject
 *
 * PURPOSE:                     Allocates a multiselect data object - we store a list of selected object in this special object.
 *
 * PARAMETERS:
 *                                      CBaseMultiSelectSnapinItem ** ppBaseMultiSelectSnapinItem       Pointer to a pointer to the multiselect snapin item to allocate.
 *
 * RETURNS:
 *                                      SC                                                                                                                      Execution code
 */
SC
CBaseSnapin::ScAllocateMultiSelectionDataObject(CBaseMultiSelectSnapinItem ** ppBaseMultiSelectSnapinItem)
{
    // Declarations
    SC                                                                                      sc                                                      ;
    t_itemBaseMultiSelectSnapinItem *                       pBaseMultiSelectSnapinItem      = NULL;                 // create multiselect snapin item

    // Data validation
    ASSERT(ppBaseMultiSelectSnapinItem);
    ASSERT(!*ppBaseMultiSelectSnapinItem);

    // Allocate the object
    sc = ScCreateItemQuick(&pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;

    // Assign the result
    *ppBaseMultiSelectSnapinItem = pBaseMultiSelectSnapinItem;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScAllocateMultiSelectionDataObject()"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Returns the version information string for the snapin.
// The output string must be allocated with CoTaskMemAlloc.
//
SC CBaseSnapin::ScGetSnapinVersion(LPOLESTR *lpVersion)
{
    DECLARE_SC(sc, _T("CBaseSnapin::ScGetSnapinVersion"));
    sc = ScCheckPointers(lpVersion);
    if (sc)
        return sc;

    *lpVersion = CoTaskDupString(L"");
	if ((*lpVersion) == NULL)
		return (E_OUTOFMEMORY);

    return sc;
}

SC CBaseSnapin::ScGetProvider(LPOLESTR *lpName)
{
    DECLARE_SC(sc, _T("CBaseSnapin::ScGetProvider"));
    sc = ScCheckPointers(lpName);
    if (sc)
        return sc;

    *lpName = CoTaskDupString(L"Microsoft");
	if ((*lpName) == NULL)
		return (E_OUTOFMEMORY);

    return sc;
}

// -----------------------------------------------------------------------------
// Creates an ATL Registrar script for the snapin and registers/unregisters it.
// If fRegister is TRUE then we are registering, FALSE we are unregistering.
//
SC CBaseSnapin::ScRegister(BOOL fRegister)
{
    SC                      sc ;
    HRESULT         hr = S_OK;
    INT                     i = 0;
    const INT       cchMaxLen = 256;
    TCHAR           szFileName[cchMaxLen];
    CStr            cstrTemp;

    tstring         strVersion;
    const INT       cchMaxRegScript         = 10000;
    tstring         strRegScript;
    tstring         strFmtSnapinRegScript;
    tstring         strSnapinAboutRegScript;
    tstring         strSnapinNodeTypes;
    tstring         strExtensionScript;
    tstring         strPropertySheetScript;
    tstring         strToolBarScript;
    tstring         strNameSpaceScript;
    tstring         strContextMenuScript;
    tstring         strTemp;
    tstring         strSnapinName;
    tstring         strStandalone;


    // Hacks for version, snapin name.

    // Version number eg 6.3523.0.0
    strVersion = _T("6.3523.0.0");

    strSnapinAboutRegScript = szSnapinAboutRegScript + strVersion;
    cstrTemp.Format(szSnapinAboutRegScript, strVersion.data());
    strSnapinAboutRegScript = cstrTemp;

    strSnapinName.LoadString(_Module.GetModuleInstance(), IdsName());
    // strSnapinName = _T("Sample Framework Snapin");

    GetModuleFileName(_Module.GetModuleInstance(), szFileName, cchMaxLen);

    // Create the Standalone key only if we're a standalone snapin.
    if (FStandalone())
        strStandalone = szStandalone;

    // Format all the extension node stuff.
    for (i = 0; i<Csnr(); i++)
    {
        tstring strNodeTypeName;
        CNodeType *pnodetype = Psnr()[i].pnodetype;
        SNRTypes   snrtypes  = Psnr()[i].snrtypes;

        // Get the name of the node type
        if (! pnodetype->StrName().empty())
        {
            strTemp = pnodetype->StrName();
            strNodeTypeName  = pnodetype->StrClsidNodeType();
            strNodeTypeName += _T(" = s '");
            strNodeTypeName += pnodetype->StrName();
            strNodeTypeName += _T("'");
        }
        else
            strNodeTypeName = pnodetype->StrClsidNodeType();

        // Add the ID of the node to the NodeTypes key if we enumerate it.
        tstring strSnapinNodeTypesTemp;

        if ( (snrtypes & snrEnumSP) || (snrtypes & snrEnumRP) || (snrtypes & snrEnumSM))
        {
            // Add the opening brace the first time around.
            if (strSnapinNodeTypes.empty())
                strSnapinNodeTypes = szSnapinNodeTypeOpen;

            cstrTemp.Format(szFmtSnapinNodeType, pnodetype->StrClsidNodeType().data());
            strSnapinNodeTypesTemp = cstrTemp;
            strSnapinNodeTypes    += strSnapinNodeTypesTemp;
        }

        // Needed because this is a for loop.
        strContextMenuScript = _T("");

        // Menu extensions
        if ( snrtypes & snrExtCM)
        {
            cstrTemp.Format(szfmtSingleExtension, szSingleExtension);
            strContextMenuScript  = cstrTemp;
        }

        // Property Page extensions
        strPropertySheetScript = _T("");
        if ( snrtypes & snrExtPS)
        {
            cstrTemp.Format(szfmtSingleExtension, szSingleExtension);
            strPropertySheetScript = cstrTemp;
        }

        // Toolbar extensions
        strToolBarScript = _T("");
        if ( snrtypes & snrExtTB)
        {
            cstrTemp.Format(szfmtSingleExtension, szSingleExtension);
            strToolBarScript = cstrTemp;
        }

        // Namespace extensions
        strNameSpaceScript = _T("");
        if ( snrtypes & snrExtNS)
        {
            cstrTemp.Format(szfmtSingleExtension, szSingleExtension);
            strNameSpaceScript = cstrTemp;
        }

        cstrTemp.Format(szfmtAllExtensions, strNodeTypeName.data(), strNameSpaceScript.data() , strContextMenuScript.data() , strPropertySheetScript.data() , strToolBarScript.data());

        strExtensionScript += cstrTemp;
    }

    // Add a closing brace to the NodeTypes key if needed
    if (! strSnapinNodeTypes.empty())
        strSnapinNodeTypes += szSnapinNodeTypeClose;

    // Need to concatenate these to form the real fmt string!
    strFmtSnapinRegScript  = szfmtSnapinRegScript1;
    strFmtSnapinRegScript += szfmtSnapinRegScript2;

    cstrTemp.Format(strFmtSnapinRegScript.data(), strVersion.data(), strVersion.data(), strStandalone.data(), strSnapinNodeTypes.data(), strExtensionScript.data());

    strRegScript  = strSnapinAboutRegScript;
    strRegScript += cstrTemp;

    USES_CONVERSION;

    // Set all the replacement parameter values.
    // $REVIEW (ptousig) DLLName is always set to Exadmin !!!
    sc = Registrar().ClearReplacements( );
    sc = Registrar().AddReplacement(szDLLName,                                   L"Snapins");
    sc = Registrar().AddReplacement(szModule,                                    T2COLE(szFileName));
    sc = Registrar().AddReplacement(szCLSID_Snapin,                              T2COLE(StrClsidSnapin().data()));
    sc = Registrar().AddReplacement(szCLSID_About,                               T2COLE(StrClsidAbout().data()));
    sc = Registrar().AddReplacement(szClassName,                                 T2COLE(StrClassName().data()));
    sc = Registrar().AddReplacement(szSnapinName,                                T2COLE(strSnapinName.data()));
    sc = Registrar().AddReplacement(szCLSID_NodeType,                    L"");

    if (fRegister)
    {
        LPCOLESTR lpOleStr = T2COLE(strRegScript.data());
        sc = Registrar().StringRegister(lpOleStr);
        if (sc)
            goto Error;
    }
    else
    {
        hr = Registrar().StringUnregister(strRegScript.data());
        if (hr == DISP_E_EXCEPTION)
        {
            //
            // When trying to unregister a snapin that wasn't registered in
            // the first place, the Registrar returns a DISP_E_EXCEPTION.
            // I don't know why, seems to be a bug in the Registrar. Our
            // solution for now is to ignore the error, not very clean but
            // effective. We are un-registering a snapin that wasn't registered
            // anyway.
            //
            hr = S_OK;
        }
        else if (FAILED(hr))
        {
            //
            // Some other error occured
            //
            sc = hr;
            goto Error;
        }
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScRegister"), sc);
    goto Cleanup;
}

#if 0
#ifdef _DEBUG

// -----------------------------------------------------------------------------
// Displays the Traces menu (in debug only)
//
SC CBaseSnapin::ScOnMenuTraces(void)
{
    DoTraceDialog();
    return S_OK;
}


// -----------------------------------------------------------------------------
// Provides a description of a given SC Code (in debug only)
//
SC CBaseSnapin::ScOnMenuSCDescription(void)
{
    CStr            strPrompt(_T("Enter the Status Code (sc)"));
    CSTR            (strAnswer, 10);
    CAskStringDialog        dlg;
    ID                      id;
    SC                      sc;

    dlg.SetPrompt(&strPrompt);
    dlg.SetAnswer(&strAnswer);
    strAnswer.BlankString();
    id = dlg.IdModal();
    if (id != IDOK)
        return(sc = S_OK);

    //
    // Convert the text the user entered into a SC.
    //
    sc = (SC) strAnswer.strtoul(NULL, 16);
    MbbErrorBox(sc);
    return sc;
}


// -----------------------------------------------------------------------------
// Debug stuff (in debug only)
//
SC CBaseSnapin::ScOnMenuMemoryDiff(void)
{
    #ifdef USE_BARFMEM
    CBaseWaitCursor wc;
    CBarfMemory::DumpMarked();
    #endif // USE_BARFMEM
    return S_OK;
}

// -----------------------------------------------------------------------------
// Validates Memory (in debug only)
//
SC CBaseSnapin::ScOnMenuValidateMemory(void)
{
    #ifdef USE_BARFMEM
    CBaseWaitCursor wc;
    //Ensure output even if tagMemoryCorruption not turned on
    Trace(&tagAlways, _T("CBaseSnapin::ScOnMenuValidateMemory() - Validating memory ..."));
    ValidateMemory(&tagAlways);
    Trace(&tagAlways, _T("CBaseSnapin::ScOnMenuValidateMemory() - ... Done validating memory."));
    #endif // USE_BARFMEM
    return S_OK;
}

// -----------------------------------------------------------------------------
// Displays Dialog Box of Total Memory Allocated (in debug only)
//
SC CBaseSnapin::ScOnMenuTotalMemory(void)
{
    #ifdef USE_BARFMEM
    INT                             nAlloc;
    INT                             nBytes;
    CSTR                    (str, cchMaxLine);
    CBaseWaitCursor wc;

    TotalMemory(&nAlloc, &nBytes);
    str.Format(_T("Memory currently allocated:\n\n%d allocations\n%d bytes"), nAlloc, nBytes);
    MbbErrorBox(str.Sz(), MB_OK | MB_ICONINFORMATION);
    #endif // USE_BARFMEM
    return S_OK;
}
#endif
#endif //#if 0

// -----------------------------------------------------------------------------
// Given two pointers to dataObjects, are they the same?
// Returns S_OK if objects A and B are the same, S_FALSE if they are different.
//
// $REVIEW (ptousig) Will there ever be a case where two different
//                                       dataobjects should be considered equal ?
//
SC CBaseSnapin::ScCompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    SC sc = S_FALSE;
    BOOL fOwnedA = FALSE;
    BOOL fOwnedB = FALSE;
    CNodeType *pnodetypeA = NULL;
    CNodeType *pnodetypeB = NULL;

    // Check if one of the pointers is NULL.
    if (!lpDataObjectA || !lpDataObjectB)
    {
        // This happens when one of the objects is new.
        // See bug 117170.
        sc = S_FALSE;
        goto Cleanup;
    }

    if (lpDataObjectA == lpDataObjectB)
    {
        // If both pointers are the same, then obviously they are
        // the same object.
        sc = S_OK;
        goto Cleanup;
    }

    // Do we own both dataobjects.
    sc = ScIsOwnedDataObject(lpDataObjectA, &fOwnedA, &pnodetypeA);
    if (sc)
        goto Error;

    sc = ScIsOwnedDataObject(lpDataObjectB, &fOwnedB, &pnodetypeB);
    if (sc)
        goto Error;

    if (fOwnedA == FALSE || fOwnedB == FALSE)
    {
        // We don't own at least of the dataobjects. They are either
        // different or we are not qualified to compare them.
        sc = S_FALSE;
        goto Cleanup;
    }

    // Since we own both dataobjects, and the pointers are different
    // then we can conclude that they represent different objects.
    sc = S_FALSE;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScCompareObjects"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Handler of AddMenuItems we ask the item for its menu items. And in debug
// mode we add debug menu items if the item wants us to.
//
SC CBaseSnapin::ScAddMenuItems(LPDATAOBJECT lpDataObject, LPCONTEXTMENUCALLBACK ipContextMenuCallback, long *pInsertionAllowed)
{
    // Declarations
    SC                                      sc;
    CBaseSnapinItem *                       pitem                                           = NULL;
    CBaseMultiSelectSnapinItem *            pBaseMultiSelectSnapinItem      = NULL;

    // Data validation
    ASSERT(lpDataObject);
    ASSERT(ipContextMenuCallback);
    ASSERT(pInsertionAllowed);

    // See if we can extract the multi select data object from the composite data object
    sc = CBaseMultiSelectSnapinItem::ScExtractMultiSelectDataObject(this, lpDataObject, &pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;

    // If we actually had a composite data object and we were able to find our multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        // Call ScAddMenuItems for the multiselect object for menu merging
        sc = pBaseMultiSelectSnapinItem->ScAddMenuItems(this, lpDataObject, ipContextMenuCallback, pInsertionAllowed);
        if (sc)
            goto Error;
    }
    else
    {
        // Handle the normal case - PItem() does more work than a simple cast to verify that the snapin item belongs to the snapin etc.
        pitem = Pitem(lpDataObject);
        ASSERT(pitem);

        sc = ScAddMenuItems(pitem, *pInsertionAllowed, ipContextMenuCallback, pitem->Pmenuitem(), pitem->CMenuItem());
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScAddMenuItems"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Constructor for CSnapinContextMenuItem
//
CSnapinContextMenuItem::CSnapinContextMenuItem(void)
{
    // Initialize members
    ::ZeroMemory(&cm, sizeof(cm));
}

// -----------------------------------------------------------------------------
// Destructor for CSnapinContextMenuItemVectorWrapper
//
CSnapinContextMenuItemVectorWrapper::~CSnapinContextMenuItemVectorWrapper(void)
{
    // Declarations
    INT             nIterator       = 0;

    // Go through all the referenced CSnapinContextMenuItem objects and delete them
    for (nIterator=0; nIterator < cmiv.size(); nIterator++)
    {
        if (cmiv[nIterator])
        {
            delete cmiv[nIterator];
            cmiv[nIterator] = NULL;
        }
    }
}

// -----------------------------------------------------------------------------
// Adds menu items to the context menu.
//
SC
CBaseSnapin::ScAddMenuItems(CBaseSnapinItem * pitem, long lInsertionAllowed, LPCONTEXTMENUCALLBACK ipContextMenuCallback, SnapinMenuItem * rgmenuitem, INT cmenuitem)
{
    // Declarations
    SC                                      sc                      ;
    BOOL                            fAllowed        = TRUE;
    INT                                     nIterator       = 0;

    // Data validation
    ASSERT(pitem);
    ASSERT(ipContextMenuCallback);
    // ASSERT(rgmenuitem); sometimes there is no menu

    // Go through the different menu items
    for (nIterator=0; nIterator < cmenuitem; nIterator++)
    {
        // Local declarations
        CSnapinContextMenuItem        cmi;

        // Get the menu item
        sc = ScGetMenuItem(&cmi, pitem, &(rgmenuitem[nIterator]), &fAllowed, lInsertionAllowed);
        if (sc)
            goto Error;

        // If the menu item is allowed, then add it
        if (fAllowed)
        {
            sc = ipContextMenuCallback->AddItem(&(cmi.cm));
            if (sc)
                goto Error;
        }
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScAddMenuItems"), sc);
    goto Cleanup;
};

/* CBaseSnapin::ScGetMenuItem
 *
 * PURPOSE:                     Sets a menu item struct for a particular snapin item and for a particular source menu item of that snapin item.
 *
 * PARAMETERS:
 *                                      CSnapinContextMenuItem *      pcmiReturned                            Menu item struct to set
 *                                      CBaseSnapinItem *       pitem                                           Snapin item from which the source menu item comes
 *                                      MenuItem *                      pMenuItemSource                         Source menu item
 *                                      BOOL *                          pfAllowed                                       TRUE if the menu item allowed?
 *
 * RETURNS:
 *                                      SC                                                                                              Execution code
 */
SC
CBaseSnapin::ScGetMenuItem(CSnapinContextMenuItem * pcmiReturned, CBaseSnapinItem * pitem, SnapinMenuItem * pMenuItemSource, BOOL * pfAllowed, long lInsertionAllowed)
{
    // Declarations
    SC                              sc                                                      ;
    LONG                    fFlags                                          = 0;
    DWORD                   dwFlagsMenuDisable                      = 0;
    DWORD                   dwFlagsMenuGray                         = 0;
    DWORD                   dwFlagsMenuChecked                      = 0;

    // Data validation
    ASSERT(pcmiReturned);
    ASSERT(pitem);
    ASSERT(pMenuItemSource);
    ASSERT(pfAllowed);

    // Set default
    *pfAllowed = TRUE;

    // Get the flags from the snapin item
    dwFlagsMenuDisable      = pitem->DwFlagsMenuDisable();
    dwFlagsMenuGray         = pitem->DwFlagsMenuGray();
    dwFlagsMenuChecked      = pitem->DwFlagsMenuChecked();

    // Disabled means don't show at all. Not the same as MMC's MF_DISABLED.
    if (dwFlagsMenuDisable & pMenuItemSource->dwFlagsDisable)
    {
        *pfAllowed = FALSE;
        goto Cleanup;
    }

    // Check if the menu item should be allowed
    switch (pMenuItemSource->lInsertionPointID)
    {
    case CCM_INSERTIONPOINTID_PRIMARY_TOP:
        *pfAllowed = (lInsertionAllowed & CCM_INSERTIONALLOWED_TOP) != 0;
        break;

    case CCM_INSERTIONPOINTID_PRIMARY_NEW:
    case CCM_INSERTIONPOINTID_3RDPARTY_NEW:
        *pfAllowed = ((lInsertionAllowed & CCM_INSERTIONALLOWED_NEW) != 0) && pitem->FHasComponentData();
        break;

    case CCM_INSERTIONPOINTID_PRIMARY_TASK:
    case CCM_INSERTIONPOINTID_3RDPARTY_TASK:
        *pfAllowed = (lInsertionAllowed & CCM_INSERTIONALLOWED_TASK) != 0;
        break;

    case CCM_INSERTIONPOINTID_PRIMARY_VIEW:
        *pfAllowed = (lInsertionAllowed & CCM_INSERTIONALLOWED_VIEW) != 0;
        break;
    }

    // If the menu item is not to be enabled, then discard
    if (!*pfAllowed)
        goto Cleanup;

    // Set flags
    if (dwFlagsMenuGray & pMenuItemSource->dwFlagsGray)
        fFlags |= MF_GRAYED;
    else
        fFlags |= MF_ENABLED;
    if (dwFlagsMenuChecked & pMenuItemSource->dwFlagsChecked)
        fFlags |= MF_CHECKED;
    else
        fFlags |= MF_UNCHECKED;

    // Set other parameters
    if (pMenuItemSource->idsName)
        pcmiReturned->strName.LoadString(_Module.GetResourceInstance(), pMenuItemSource->idsName);
    if (pMenuItemSource->idsStatusBarText)
        pcmiReturned->strStatusBarText.LoadString(_Module.GetResourceInstance(), pMenuItemSource->idsStatusBarText);

    pcmiReturned->cm.strName                = (LPWSTR)pcmiReturned->strName.data();
    pcmiReturned->cm.strStatusBarText       = (LPWSTR)pcmiReturned->strStatusBarText.data();
    pcmiReturned->cm.lCommandID             = pMenuItemSource->lCommandID;
    pcmiReturned->cm.lInsertionPointID      = pMenuItemSource->lInsertionPointID;
    pcmiReturned->cm.fFlags                 = fFlags;
    pcmiReturned->cm.fSpecialFlags          = pMenuItemSource->fSpecialFlags;

Cleanup:
    return sc;
}

// -----------------------------------------------------------------------------
// Load the icon for the snapin and return it to MMC.
//
SC CBaseSnapin::ScGetSnapinImage(HICON *phAppIcon)
{
    SC sc ;

    ASSERT(phAppIcon);

    if (phAppIcon == NULL)
    {
        sc = E_INVALIDARG;
        goto Error;
    }

    if (Idi() == 0)
    {
        // There is no icon for this snapin
        *phAppIcon = NULL;
        goto Cleanup;
    }

    *phAppIcon = ::LoadIcon(_Module.GetModuleInstance(), MAKEINTRESOURCE(Idi()));
    if (*phAppIcon == NULL)
    {
        sc = ScFromWin32(GetLastError());
        goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScGetSnapinImage"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Release the given item, but only if it is one of the root items.
// Used during MMCN_REMOVE_CHILDREN. We are being told that the item
// that we are "ghosting" is either being destroyed or all of its children
// are being destroyed. In either case, we don't need the ghost item
// anymore.
//
SC CBaseSnapin::ScReleaseIfRootItem(CBaseSnapinItem *pitem)
{
    SC sc ;
    ItemList::iterator iter;

    ASSERT(pitem);

    for (iter = m_ilRootItems.begin(); iter != m_ilRootItems.end(); iter++)
    {
        if (pitem == (*iter))
        {
            m_ilRootItems.erase(iter);
            static_cast<LPDATAOBJECT>(pitem)->Release();
            break;
        }
    }
    return sc;
}

// -----------------------------------------------------------------------------
// Determines whether the specified dataobject is pastable.
//
SC
CBaseSnapin::ScIsPastableDataObject(CBaseSnapinItem * pitemTarget, LPDATAOBJECT lpDataObject, BOOL * pfPastable)
{
    // Declarations
    SC                              sc                              ;
    BOOL                    fPastable               = FALSE;
    CNodeType *             pnodetype               = NULL;
    CLSID                   clsid;
    INT                             isnr                    = 0;

    // Validate parameters
    ASSERT(pitemTarget);
    ASSERT(lpDataObject);
    ASSERT(pfPastable);

    // Is this an MMC node?
    // Get the nodetype, in guid format, of the data object.
    sc = CBaseDataObject::ScGetNodeType(lpDataObject, &clsid);
    if (sc == DV_E_FORMATETC || sc == E_NOTIMPL)
    {
        // Not an MMC Node
        fPastable = FALSE;
        sc = S_FALSE;                                                                                                                   // override the execution code
        goto Cleanup;
    }
    if (sc)
        goto Error;

    // Verify that the snapin item class type is acceptable to the destination
    for (isnr=0; isnr < Csnr(); isnr++)
    {
        // Find a class id match
        if (IsEqualCLSID(*(Psnr(isnr)->pnodetype->PclsidNodeType()), clsid))    // found the CLSID
        {
            // SNR verification
            SNRTypes snrtypes = Psnr(isnr)->snrtypes;

            // $REVIEW (ptousig) So all nodes are pastable ? Sounds to me like
            //                                       snrEnumSP and snrEnumRP shouldn't be in here.
            if ( (snrtypes & snrEnumSP) || (snrtypes & snrEnumRP) || (snrtypes & snrPaste))
                fPastable = TRUE;
            break;                                                  // exit the loop.
        }
    }

    // If it seems we can paste, ask the target item if we can paste here
    if (fPastable)
    {
        sc = pitemTarget->ScOnQueryPaste(lpDataObject, &fPastable);
        if (sc)
            goto Error;
    }

Cleanup:
    // Assign result
    *pfPastable     = fPastable;
    return sc;
Error:
    fPastable = FALSE;
    TraceError(_T("CBaseSnapin::ScIsPastableDataObject()"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Find out which verb should be the default.
//
MMC_CONSOLE_VERB CBaseSnapin::MmcverbDefault(LPDATAOBJECT lpDataObject)
{
    // Ask the item.
    return Pitem(lpDataObject)->MmcverbDefault();
}

// -----------------------------------------------------------------------------
// Find out the verbs that are allowed on this item.
//
SC CBaseSnapin::ScGetVerbs(LPDATAOBJECT lpDataObject, DWORD * pdwVerbs)
{
    // Ask the item.
    return Pitem(lpDataObject)->ScGetVerbs(pdwVerbs);
}


// -----------------------------------------------------------------------------
// Returns the path to the help file for this snapin.
//
SC CBaseSnapin::ScGetHelpTopic(tstring& strCompiledHelpFile)
{
    DECLARE_SC(sc, _T("CBaseSnapin::ScGetHelpTopic"));
    DWORD dwLen = 0;
    const int cchMaxLen = 256;
    TCHAR szFileName[cchMaxLen];

    //
    // Get the full path to the current module
    //
    dwLen = ::GetModuleFileName(_Module.GetModuleInstance() , szFileName, cchMaxLen);
    if (dwLen == 0)
        return (ScFromWin32(GetLastError()));

    strCompiledHelpFile = szFileName;
    //
    // Replace the extension with .CHM
    //
    int nDotPos = strCompiledHelpFile.rfind(_T("."));
    strCompiledHelpFile.erase(nDotPos);
    strCompiledHelpFile += _T(".CHM");

    return sc;
}

// -----------------------------------------------------------------------------
// We are being told that something has changed on the item pointed
// by lParam.
//
SC CBaseSnapin::ScOnPropertyChange(BOOL fScope, LPARAM lParam, IConsoleNameSpace *ipConsoleNameSpace, IConsole *ipConsole)
{
    SC                                      sc                      ;
    LPDATAOBJECT            pdataobject = NULL;
    CBaseSnapinItem *       pitem   = NULL;

    pdataobject = reinterpret_cast<LPDATAOBJECT>(lParam);
    ASSERT(pdataobject);

    pitem = Pitem(pdataobject);
    ASSERT(pitem);

    sc = pitem->ScOnPropertyChange();
    if (sc)
        goto Error;

    if (pitem->FIsContainer())
    {
        // Container items should be updated just once.
        sc = pitem->ScUpdateScopeItem(ipConsoleNameSpace);
        if (sc)
            goto Error;
    }
    else
    {
        // Result item. Need to update the item in all views.
        // Call out to all the views to update themselves.
        sc = ipConsole->UpdateAllViews(pdataobject, 0, ONVIEWCHANGE_UPDATERESULTITEM);
        if (sc)
            goto Error;
    }
Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScOnPropertyChange"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// The user has changed the name of an item.
//
SC CBaseSnapin::ScOnRename(LPDATAOBJECT lpDataObject, const tstring& strNewName, IConsole *ipConsole)
{
    SC               sc= S_FALSE;
    CBaseSnapinItem *pitem = NULL;

    ASSERT(lpDataObject);

    pitem = Pitem(lpDataObject);
    ASSERT(pitem);

    if (strNewName.empty())
    {
        // ScOnQueryPaste should prevent this from ever happening
        sc = E_UNEXPECTED;
        goto Error;
    }

    if (strNewName.length() == 0)
        goto Cleanup;

    // Tell the object to rename
    // If it returns S_FALSE, the rename was not done.
    sc = pitem->ScOnRename(strNewName);
    if (sc)
        goto Error;

    if (sc == S_OK)
    {
        // If this was renamed, reload our children
        sc = ipConsole->UpdateAllViews(static_cast<IDataObject *>(pitem), 0, ONVIEWCHANGE_REFRESHCHILDREN);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScOnRename"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Received on a paste command.
//
// lpDataObject is the node receiving the past command.
// lpDataObjectList are the nodes being pasted.
// ppDataObjectPasted is where we answer the list of nodes that were successfully pasted.
//
SC CBaseSnapin::ScOnPaste(LPDATAOBJECT lpDataObject, LPDATAOBJECT lpDataObjectList, LPDATAOBJECT * ppDataObjectPasted, IConsole * ipConsole)
{
    // Declarations
    SC                                                              sc                                                      ;
    CBaseSnapinItem *                               pitemTarget                                     = NULL;
    DWORD                                                   dwCanCopyCut                            = 0;
    BOOL                                                    fPasted                                         = FALSE;
    CBaseMultiSelectSnapinItem *    pBaseMultiSelectSnapinItem      = NULL;

    // Handle special case
    if (!lpDataObjectList)
    {
        // ScOnQueryPaste should prevent this from ever happening
        sc = E_UNEXPECTED;
        goto Error;
    }

    // Data validation
    ASSERT(lpDataObject);
    ASSERT(lpDataObjectList);
    ASSERT(ipConsole);
    // other parameters can not be ASSERTed

    // Get the target item
    pitemTarget = Pitem(lpDataObject);
    ASSERT(pitemTarget);

    // Determine if this is a multiselect data object
    sc = CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject(lpDataObjectList, &pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;

    // If we received a multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        // Call ScOnPaste for the multiselect object for dispatch
        sc = pBaseMultiSelectSnapinItem->ScOnPaste(this, pitemTarget, lpDataObjectList, ppDataObjectPasted, ipConsole);
        if (sc)
            goto Error;
    }
    else
    {
        // Ask the item to copy the underlying object
        sc = pitemTarget->ScOnPaste(lpDataObjectList, ppDataObjectPasted ? TRUE : FALSE, &fPasted);
        if (sc)
            goto Error;

        // If the object was pasted
        if (fPasted)
        {
            // If this was a cut, we need to return to MMC the items that were pasted
            // (do not delete the dropped item if we are just adding it to a policy)
            if (ppDataObjectPasted && !pitemTarget->FIsPolicy())
			{
                *ppDataObjectPasted = lpDataObjectList;
				(*ppDataObjectPasted)->AddRef();
			}

            // Reload our children
            sc = ipConsole->UpdateAllViews(static_cast<IDataObject *>(pitemTarget), 0, ONVIEWCHANGE_REFRESHCHILDREN);
            if (sc)
                goto Error;
        }
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScOnPaste"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// We need to figure out whether we will allow pasting of this object.
// lpDataObject is the target object.
// lpDataObjectList are the objects being pasted.
//
SC CBaseSnapin::ScOnQueryPaste(LPDATAOBJECT lpDataObject, LPDATAOBJECT lpDataObjectList, LPDWORD pdwFlags)
{
    // Declarations
    SC                                                              sc                                                      ;
    CBaseSnapinItem *                               pitemTarget                                     = NULL;
    BOOL                                                    fCanPaste                                       = FALSE;
    CNodeType               *                               pnodetype                                       = NULL;
    CBaseMultiSelectSnapinItem *    pBaseMultiSelectSnapinItem      = NULL;

    // Data validation
    ASSERT(lpDataObject);
    ASSERT(lpDataObjectList);
    ASSERT(pdwFlags);

    // Get the target item
    pitemTarget = Pitem(lpDataObject);
    ASSERT(pitemTarget);

    // Determine if this is a multiselect data object
    // Determine if this is a multiselect data object
    sc = CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject(lpDataObjectList, &pBaseMultiSelectSnapinItem);
	if (sc == SC(DV_E_FORMATETC) )
	{
		sc = S_FALSE; // Cant paste.
		return sc;
	}

    if (sc)
        goto Error;

    // If we received a multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        // Call ScOnCutOrMove for the multiselect object for dispatch
        sc = pBaseMultiSelectSnapinItem->ScIsPastableDataObject(this, pitemTarget, lpDataObjectList, &fCanPaste);
        if (sc)
            goto Error;
    }
    else
    {
        // Determine if the parse operation is acceptable
        // Here lpDataObjectList is only one item
        sc = ScIsPastableDataObject(pitemTarget, lpDataObjectList, &fCanPaste);
        if (sc)
            goto Error;
    }

    // Determine if we can paste
    if (!fCanPaste)
        sc = S_FALSE;                                                                   // indicate no pasting

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScOnQueryPaste()"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// We need to figure out whether we can handle the given dataobject that is from
// different process.
// lpDataObject is the target object.
// lpDataObjectList are the objects being pasted.
//
SC CBaseSnapin::ScOnCanPasteOutOfProcDataObject(LPBOOL pbCanHandle)
{
    // Declarations
    DECLARE_SC(sc, TEXT("CBaseSnapin::ScOnCanPasteOutOfProcDataObject"));
    sc = ScCheckPointers(pbCanHandle);
    if (sc)
        return sc;

    *pbCanHandle = TRUE;

    return sc;
}

// -----------------------------------------------------------------------------
SC CBaseSnapin::ScOnCutOrMove(LPDATAOBJECT lpDataObjectList, IConsoleNameSpace * ipConsoleNameSpace, IConsole * ipConsole)
{
    // Declarations
    SC                                                              sc                                                      ;
    CBaseSnapinItem *                               pitem                                           = NULL;
    CBaseMultiSelectSnapinItem *    pBaseMultiSelectSnapinItem      = NULL;

    // Data validation
    ASSERT(lpDataObjectList);
    ASSERT(ipConsoleNameSpace);
    ASSERT(ipConsole);

    // Determine if this is a multiselect data object
    sc = CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject(lpDataObjectList, &pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;

    // If we received a multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        // Call ScOnCutOrMove for the multiselect object for dispatch
        sc = pBaseMultiSelectSnapinItem->ScOnCutOrMove(this, lpDataObjectList, ipConsoleNameSpace, ipConsole);
        if (sc)
            goto Error;
    }
    else
    {
        // Handle the normal case - PItem() does more work than a simple cast to verify that the snapin item belongs to the snapin etc.
        pitem = Pitem(lpDataObjectList);
        ASSERT(pitem);

        // Ask the item to delete the underlying object.
        sc = pitem->ScOnCutOrMove();
        if (sc)
            goto Error;
        if (sc == S_FALSE)
            goto Cleanup;

        if (pitem->FIsContainer())
        {
            // Container items need to be deleted from the document
            // Delete the item and everything below it.
            if (pitem->Hscopeitem())
            {
                sc = ipConsoleNameSpace->DeleteItem(pitem->Hscopeitem(), TRUE);
                if (sc)
                    goto Error;
                pitem->SetHscopeitem(0);
            }
        }
        else
        {
            // Leaf items need to be deleted from the views.
            sc = ipConsole->UpdateAllViews(lpDataObjectList, 0, ONVIEWCHANGE_DELETESINGLEITEM);
            if (sc)
                goto Error;
        }

        // Delete this item, MMC is still using it. Below ScDeleteSubTree
		// will release the object so Addref it. We got this through
        // the Pitem() call which just type cast the dataobject.
		pitem->AddRef();
        sc = pitem->ScDeleteSubTree(TRUE);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapin::ScOnCutOrMove"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// This method allows a CComponentData to tell us it is being
// destroyed. Any item referring to this CD as its owner will
// have their owner pointer nulled.
SC CBaseSnapin::ScOwnerDying(CComponentData *pComponentData)
{
    ItemList::iterator iter;
    for (iter = m_ilRootItems.begin(); iter != m_ilRootItems.end(); iter++)
    {
        if ((*iter)->FHasComponentData() && (*iter)->PComponentData() == pComponentData)
            (*iter)->SetComponentData(NULL);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\lib\componentdata.cxx ===
/*
 *      ComponentData.cxx
 *
 *
 *      Copyright (c) 1998-1999 Microsoft Corporation
 *
 *      PURPOSE:        Defines the CComponentData class.
 *
 *
 *      OWNER:          ptousig
 */

#include "headers.hxx"

// -----------------------------------------------------------------------------
CComponentData::CComponentData(CBaseSnapin *psnapin)
{
    Trace(tagBaseSnapinIComponentData, _T("--> CComponentData::CComponentData(psnapin=0x%08X)"), psnapin);

    ASSERT(psnapin);

    m_psnapin = psnapin;
    m_fIsRealComponentData = FALSE;
    m_pitemStandaloneRoot = NULL;

    Trace(tagBaseSnapinIComponentData, _T("<-- CComponentData::CComponentData has constructed 0x%08X"), this);
}

// -----------------------------------------------------------------------------
// Destructor doesn't do anything, but it's useful to have one for debugging
// purposes.
//
CComponentData::~CComponentData(void)
{
    Trace(tagBaseSnapinIComponentData, _T("--> CComponentData::~CComponentData(), this=0x%08X"), this);

    Psnapin()->ScOwnerDying(this);
    if (m_pitemStandaloneRoot)
    {
        Psnapin()->ScReleaseIfRootItem(m_pitemStandaloneRoot);
    }

    Trace(tagBaseSnapinIComponentData, _T("<-- CComponentData::~CComponentData has destructed 0x%08X"), this);
}

// -----------------------------------------------------------------------------
// This version of Pitem() is a shortcut, it forwards the call to the
// CBaseSnapin with the correct CComponentData parameter.
//
CBaseSnapinItem *CComponentData::Pitem( LPDATAOBJECT lpDataObject,
                                        HSCOPEITEM hscopeitem,
                                        long cookie)
{
    return Psnapin()->Pitem(this, NULL, lpDataObject, hscopeitem, cookie);
}

// -----------------------------------------------------------------------------
// The registration routine expects to find this method on the CComponentData
// but the real implementation is on the CBaseSnapin, so we just forward
// the call.
//
SC CComponentData::ScRegister(BOOL fRegister)
{
    CBaseSnapin* pSnapin = Psnapin();
    return pSnapin->ScRegister(fRegister);
}

// -----------------------------------------------------------------------------
// Is called by the MMC to initialize the object. We QueryInterface
// for pointers to the name space and console, which we cache in
// local variables. This is called only once, when the user clicks on
// the snapin.
//
// $REVIEW (ptousig) I am not sure which of interfaces we are allowed to QI
//                                       for from the parameter. The MMC docs are no help (as usual),
//
SC CComponentData::ScInitialize(LPUNKNOWN pUnknown)
{
    SC                              sc = S_OK;
    IImageListPtr   ipScopeImageList;

    ASSERT(pUnknown != NULL);
    ASSERT(m_ipConsoleNameSpace == NULL);

    m_fIsRealComponentData = TRUE;

    sc = Psnapin()->ScInitBitmaps();
    if (sc)
        goto Error;

    // These are CComQIPtr so they will call QueryInterface.
    m_ipConsoleNameSpace = pUnknown;
    m_ipConsole = pUnknown;
    m_ipResultData = pUnknown;
    m_ipPropertySheetProvider = pUnknown;

    // Get a pointer to the scope pane's IImageList.
    sc = m_ipConsole->QueryScopeImageList(&ipScopeImageList);
    if (sc)
        goto Error;

    // Set the icon strip for the scope pane.
    sc = ipScopeImageList->ImageListSetStrip(
                                             reinterpret_cast<long *>(static_cast<HBITMAP>(Psnapin()->BitmapSmall())),
                                             reinterpret_cast<long *>(static_cast<HBITMAP>(Psnapin()->BitmapLarge())),
                                             0, RGB(255, 0, 255));
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScInitialize"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Handles component data event notification.
// See MMC docs for the meaning of 'arg' and 'param'.
//
SC CComponentData::ScNotify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
{
    SC sc = S_OK;

    switch (event)
    {
    case MMCN_BTN_CLICK:
        sc = ScOnButtonClick(lpDataObject, (MMC_CONSOLE_VERB) param);
        break;

    case MMCN_DELETE:
        sc = ScOnDelete(lpDataObject);
        break;

    case MMCN_RENAME:
        sc = Psnapin()->ScOnRename(lpDataObject, reinterpret_cast<LPCTSTR>(param), IpConsole());
        break;

    case MMCN_EXPAND:
        sc = ScOnExpand(lpDataObject, arg != FALSE, param);
        break;

    case MMCN_EXPANDSYNC:
        sc = ScOnExpandSync(lpDataObject, reinterpret_cast<MMC_EXPANDSYNC_STRUCT *>(param));
        break;

    case MMCN_PROPERTY_CHANGE:
        sc = Psnapin()->ScOnPropertyChange(arg != FALSE, param, IpConsoleNameSpace(), IpConsole());
        break;

    case MMCN_REMOVE_CHILDREN:
        sc = ScOnRemoveChildren(lpDataObject, arg);
        break;

    default:
        sc = S_FALSE;
        ASSERT(_T("CComponentData::ScNotify: unimplemented event %x"));
        break;
    }

    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScNotify"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Releases all interfaces.
//
SC CComponentData::ScDestroy(void)
{
    m_ipConsole.Release();
    m_ipConsoleNameSpace.Release();
    m_ipResultData.Release();
    m_ipPropertySheetProvider.Release();

    return S_OK;
}

/*+-------------------------------------------------------------------------*
 *
 * CComponentData::ScQueryDispatch
 *
 * PURPOSE: Dummy implementation. Does nothing.
 *
 * PARAMETERS:
 *    MMC_COOKIE         cookie :
 *    DATA_OBJECT_TYPES  type :
 *    LPDISPATCH*        ppDispatch :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CComponentData::ScQueryDispatch(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDISPATCH* ppDispatch)
{
    DECLARE_SC(sc, TEXT("CComponentData::ScQueryDispatch"));

    CBaseSnapinItem *pitem = NULL;

    // The component data can handle cookie types of CCT_SNAPIN_MANAGER and CCT_SCOPE.
    // CCT_RESULT are handled by CComponent.
    ASSERT(type==CCT_SCOPE);

    //
    // If the cookie does not correspond to a known object, return E_UNEXPECTED.
    // This is correct and is also a workaround for an MMC bug. See X5:74405.
    //
    if (cookie && (Psnapin()->Pcookielist()->find(cookie) == Psnapin()->Pcookielist()->end() ) )
    {
        sc = E_UNEXPECTED;
        return sc;
    }

    pitem = Pitem(NULL, 0, cookie);
    ASSERT(pitem);

    sc = pitem->ScQueryDispatch(cookie, type, ppDispatch);
    if (sc)
        return sc;

    return sc;
}

// -----------------------------------------------------------------------------
// Load information from the first root item.
//
// $REVIEW (ptousig) Why does the root item implement ScLoad() ?
//                                       If a snapin extends two nodes it has two root items, yet
//                                       only one of which will be saved/loaded.
//
SC CComponentData::ScLoad(IStream *pstream)
{
    SC sc = S_OK;

    // Load the snapin's serialized information.
    sc = Psnapin()->ScLoad(pstream);
    if (sc)
        goto Error;

    // Load the root item's serialized information.
    // Only makes sense for standalone snapins.
    sc = Pitem()->ScLoad(pstream);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScLoad"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Determines whether any settings have changed since the last time the file
// was saved.
//
// $REVIEW (ptousig) We are never dirty !!! Shouldn't we ask the Pitem() ?
//
SC CComponentData::ScIsDirty(void)
{
    return S_FALSE;
}

// -----------------------------------------------------------------------------
// If one of the commands added to the context menu is
// subsequently selected, MMC calls Command.
//
// Even though this method "looks" like the one in CComponent,
// the use of the Pitem() shortcut makes them different. This
// version does not pass a component to the real Pitem().
//
SC CComponentData::ScCommand(long nCommandID, LPDATAOBJECT pDataObject)
{
    SC              sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    pitem = Pitem(pDataObject);
    ASSERT(pitem);

    sc = pitem->ScCommand(nCommandID);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScCommand"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Gets display information for a scope pane item
// Warning: This is called very very often (on WM_PAINT) so it is important
// we don't take any high latency actions (ie Network or Disk access).
//
SC CComponentData::ScGetDisplayInfo(LPSCOPEDATAITEM pScopeItem)
{
    SC sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    pitem = Pitem(NULL, 0, pScopeItem->lParam);
    ASSERT(pitem);

    sc = pitem->ScGetDisplayInfo(pScopeItem);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScGetDisplayInfo"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    DECLARE_SC(sc,_T("CComponentData::CompareObjects"));
    Trace(tagBaseSnapinIComponentData, _T("--> %s::IComponentData::CompareObjects(lpDataObjectA=0x%08X, lpDataObjectB=0x%08X), this=0x%08X"), StrSnapinClassName(), lpDataObjectA, lpDataObjectB, this);
    ADMIN_TRY;
    sc=Psnapin()->ScCompareObjects(lpDataObjectA, lpDataObjectB);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentData, _T("<-- %s::IComponentData::CompareObjects is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::GetDisplayInfo(LPSCOPEDATAITEM pItem)
{
    DECLARE_SC(sc,_T("CComponentData::GetDisplayInfo"));
    Trace(tagBaseSnapinIComponentDataGetDisplayInfo, _T("--> %s::IComponentData::GetDisplayInfo(cookie=0x%08X), this=0x%08X"), StrSnapinClassName(), pItem->lParam, this);
    ADMIN_TRY;
    sc=ScGetDisplayInfo(pItem);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentDataGetDisplayInfo, _T("<-- %s::IComponentData::GetDisplayInfo is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::QueryDataObject(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT * ppDataObject)
{
    DECLARE_SC(sc,_T("CComponentData::QueryDataObject"));
    Trace(tagBaseSnapinIComponentDataQueryDataObject, _T("--> %s::IComponentData::QueryDataObject(cookie=0x%08X, type=%s), this=0x%08X"), StrSnapinClassName(), cookie, SzGetDebugNameOfDATA_OBJECT_TYPES(type), this);
    ADMIN_TRY;
    //
    // If we receive E_UNEXPECTED we don't want to call MMCHrFromSc because
    // that will bring up an error message. We don't want an error message
    // in this case because of a known MMC bug (see bug X5:74405).
    // The bug says that we might receive QueryDataObject on items that
    // we were told no longer exists (by MMCN_REMOVE_CHILDREN).
    //
    sc = ScQueryDataObject(cookie, type, ppDataObject);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentDataQueryDataObject, _T("<-- %s::IComponentData::QueryDataObject is returning hr=%s, *ppDataObject=0x%08X"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()), *ppDataObject);
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
{
    DECLARE_SC(sc,_T("CComponentData::Notify"));
    Trace(tagBaseSnapinIComponentData, _T("--> %s::IComponentData::Notify(lpDataObject=0x%08X, event=%s, arg=0x%08X, param=0x%08X), this=0x%08X"), StrSnapinClassName(), lpDataObject, SzGetDebugNameOfMMC_NOTIFY_TYPE(event), arg, param, this);
    ADMIN_TRY;
    sc=ScNotify(lpDataObject, event, arg, param);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentData, _T("<-- %s::IComponentData::Notify is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::CreateComponent(LPCOMPONENT * ppComponent)
{
    DECLARE_SC(sc,_T("CComponentData::CreateComponent"));
    Trace(tagBaseSnapinIComponentData, _T("--> %s::IComponentData::CreateComponent(...), this=0x%08X"), StrSnapinClassName(), this);
    ADMIN_TRY;
    sc=ScCreateComponent(ppComponent);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentData, _T("<-- %s::IComponentData::CreateComponent is returning hr=%s, *ppComponent=0x%08X"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()), *ppComponent);
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::Initialize(LPUNKNOWN pUnknown)
{
    DECLARE_SC(sc,_T("CComponentData::Initialize"));
    Trace(tagBaseSnapinIComponentData, _T("--> %s::IComponentData::Initialize(pUnknown=0x%08X), this=0x%08X"), StrSnapinClassName(), pUnknown, this);
    ADMIN_TRY;
    sc=ScInitialize(pUnknown);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentData, _T("<-- %s::IComponentData::Initialize is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::Destroy(void)
{
    DECLARE_SC(sc,_T("CComponentData::Destroy"));
    Trace(tagBaseSnapinIComponentData, _T("--> %s::IComponentData::Destroy(), , this=0x%08X"), StrSnapinClassName(), this);
    ADMIN_TRY;
    sc=ScDestroy();
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentData, _T("<-- %s::IComponentData::Destroy is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::QueryDispatch(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDISPATCH* ppDispatch)
{
    DECLARE_SC(sc,_T("CComponentData::QueryDispatch"));
    Trace(tagBaseSnapinIComponentData, _T("--> %s::IComponentData::QueryDispatch(), , this=0x%08X"), StrSnapinClassName(), this);
    ADMIN_TRY;
    sc=ScQueryDispatch(cookie, type, ppDispatch);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentData, _T("<-- %s::IComponentData::QueryDispatch is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}


// -----------------------------------------------------------------------------
HRESULT CComponentData::AddMenuItems(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK ipContextMenuCallback, long *pInsertionAllowed)
{
    DECLARE_SC(sc,_T("CComponentData::AddMenuItems"));
    Trace(tagBaseSnapinIExtendContextMenu, _T("--> %s::IExtendContextMenu::AddMenuItems(pDataObject=0x%08X), this=0x%08X"), StrSnapinClassName(), pDataObject, this);
    ADMIN_TRY;
    // By calling Pitem() at this time, we will force the creation of the ghost
    // root node, if necessary.
    Pitem(pDataObject);
    sc=Psnapin()->ScAddMenuItems(pDataObject, ipContextMenuCallback, pInsertionAllowed);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIExtendContextMenu, _T("<-- %s::IExtendContextMenu::AddMenuItems is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    DECLARE_SC(sc,_T("CComponentData::Command"));
    Trace(tagBaseSnapinIExtendContextMenu, _T("--> %s::IExtendContextMenu::Command(nCommandID=%ld, pDataObject=0x%08X), this=0x%08X"), StrSnapinClassName(), nCommandID, pDataObject, this);
    ADMIN_TRY;
    sc=ScCommand(nCommandID, pDataObject);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIExtendContextMenu, _T("<-- %s::IExtendContextMenu::Command is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, long handle, LPDATAOBJECT lpDataObject)
{
    DECLARE_SC(sc,_T("CComponentData::CreatePropertyPages"));
    Trace(tagBaseSnapinIExtendPropertySheet, _T("--> %s::IExtendPropertySheet::CreatePropertyPages(lpDataObject=0x%08X), this=0x%08X"), StrSnapinClassName(), lpDataObject, this);
    ADMIN_TRY;
    // Why are we ignoring E_UNEXPECTED ?
    // Because when we are called by the snapin manager, and the user hits cancel we
    // need to return E_UNEXPECTED to MMC.
    sc = ScCreatePropertyPages(lpProvider, handle, lpDataObject);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIExtendPropertySheet, _T("<-- %s::IExtendPropertySheet::CreatePropertyPages is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    DECLARE_SC(sc,_T("CComponentData::QueryPagesFor"));
    Trace(tagBaseSnapinIExtendPropertySheet, _T("--> %s::IExtendPropertySheet::QueryPagesFor(lpDataObject=0x%08X), this=0x%08X"), StrSnapinClassName(), lpDataObject, this);
    ADMIN_TRY;
    sc=ScQueryPagesFor(lpDataObject);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIExtendPropertySheet, _T("<-- %s::IExtendPropertySheet::QueryPagesFor is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    DECLARE_SC(sc,_T("CComponentData::GetSizeMax"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::GetSizeMax(...), , this=0x%08X"), StrSnapinClassName(), this);
    ADMIN_TRY;
    pcbSize->LowPart = cMaxStreamSizeLow;
    pcbSize->HighPart = cMaxStreamSizeHigh;
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::GetSizeMax is returning hr=%s, (*pcbSize).LowPart=%d"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()), (*pcbSize).LowPart);
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::IsDirty(void)
{
    DECLARE_SC(sc,_T("CComponentData::IsDirty"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::IsDirty(), this=0x%08X"), StrSnapinClassName(), this);
    ADMIN_TRY;
    sc=ScIsDirty();
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::IsDirty is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::Load(IStream *pstream)
{
    DECLARE_SC(sc,_T("CComponentData::Load"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::Load(...), this=0x%08X"), StrSnapinClassName(), this);
    ADMIN_TRY;
    sc=ScLoad(pstream);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::Load is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::Save(IStream *pstream, BOOL fClearDirty)
{
    DECLARE_SC(sc,_T("CComponentData::Save"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::Save(fClearDirty=%S), this=0x%08X"), StrSnapinClassName(), fClearDirty ? "TRUE" : "FALSE", this);
    ADMIN_TRY;
    sc=ScSave(pstream, fClearDirty);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::Save is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::InitNew(void)
{
    DECLARE_SC(sc,_T("CComponentData::InitNew"));
    // We don't have anything to do, but we still want to log the call.
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::InitNew(), this=0x%08X"), StrSnapinClassName(), this);
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::InitNew is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::GetClassID(CLSID *pclsid)
{
    DECLARE_SC(sc,_T("CComponentData::GetClassID"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::GetClassID(...), this=0x%08X"), StrSnapinClassName(), this);
    ADMIN_TRY;
    *pclsid = *(Psnapin()->PclsidSnapin());
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::GetClassID is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CComponentData::Compare(RDCOMPARE * prdc, int * pnResult)
{
    DECLARE_SC(sc,_T("CComponentData::Compare"));
    Trace(tagBaseSnapinIResultDataCompare, _T("--> %s::IResultDataCompare::Compare(cookieA=0x%08X, cookieB=0x%08X), this=0x%08X"), StrSnapinClassName(), prdc->prdch1->cookie, prdc->prdch2->cookie, this);
    ADMIN_TRY;
    ASSERT(pnResult);
    ASSERT(prdc);
    ASSERT(prdc->prdch1);
    ASSERT(prdc->prdch2);
    sc=Psnapin()->ScCompare(prdc->prdch1->cookie, prdc->prdch2->cookie, prdc->nColumn, pnResult);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIResultDataCompare, _T("<-- %s::IResultDataCompare::Compare is returning hr=%s, *pnResult=%d"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()), *pnResult);
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
// Returns the full path of the compiled file (.chm) for the snapin.
//
HRESULT CComponentData::GetHelpTopic(LPOLESTR *lpCompiledHelpFile)
{
    DECLARE_SC(sc,_T("CComponentData::GetHelpTopic"));
    tstring strCompiledHelpFile;
    USES_CONVERSION;

    Trace(tagBaseSnapinISnapinHelp, _T("--> %s::ISnapinHelp::GetHelpTopic(...), this=0x%08X"), StrSnapinClassName(), this);
    ADMIN_TRY;

    if (lpCompiledHelpFile == NULL)
    {
        sc = E_POINTER;
        goto Error;
    }

    // Automatically displays an error box.
    sc = Psnapin()->ScGetHelpTopic(strCompiledHelpFile);
    if (sc)
        goto Error;

    if (strCompiledHelpFile.empty())
    {
        sc=S_FALSE;
    }
    else
    {
        *lpCompiledHelpFile = reinterpret_cast<LPOLESTR>(CoTaskMemAlloc( (strCompiledHelpFile.length()+1)*sizeof(TCHAR)) );
        sc = ScCheckPointers(*lpCompiledHelpFile, E_OUTOFMEMORY);
        if (sc)
            goto Error;

        wcscpy(*lpCompiledHelpFile, T2CW(strCompiledHelpFile.data()) );
    }

    if (sc)
        goto Error;             // an exception was caught

Cleanup:
    Trace(tagBaseSnapinISnapinHelp, _T("<-- %s::ISnapinHelp::GetHelpTopic is returning hr=%s, lpCompiledHelpFile=\"%s\""), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()), strCompiledHelpFile.data());
    return(sc.ToHr());
Error:
    TraceError(_T("CComponentData::GetHelpTopic"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Creates a data object of the appropriate type, and returns the IDataObject interface
// on it
//
SC CComponentData::ScQueryDataObject(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    SC                              sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    // The component data can handle cookie types of CCT_SNAPIN_MANAGER and CCT_SCOPE.
    // CCT_RESULT are handled by CComponent.
    ASSERT(type==CCT_SNAPIN_MANAGER || type==CCT_SCOPE);

    //
    // If the cookie does not correspond to a known object, return E_UNEXPECTED.
    // This is correct and is also a workaround for an MMC bug. See X5:74405.
    //
    if (cookie && (Psnapin()->Pcookielist()->find(cookie) == Psnapin()->Pcookielist()->end() ) )
    {
        sc = E_UNEXPECTED;
        goto Cleanup;
    }

    pitem = Pitem(NULL, 0, cookie);
    ASSERT(pitem);

    sc = pitem->ScQueryDataObject(cookie, type, ppDataObject);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScQueryDataObject"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Handles the MMCN_EXPAND notification sent to IComponentData::Notify
//
SC CComponentData::ScOnExpand(LPDATAOBJECT lpDataObject, BOOL fExpand, HSCOPEITEM hscopeitem)
{
    SC              sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    if (fExpand == FALSE)                                    // do nothing on a "contract"
        goto Cleanup;

    pitem = Pitem(lpDataObject, hscopeitem);
    ASSERT(pitem);

    // Use this opportunity to correlate the CSnapinItem and the HSCOPEITEM.
    // $REVIEW (ptousig) Should be done inside Pitem().
    pitem->SetHscopeitem(hscopeitem);
    pitem->SetComponentData(this);

    if (pitem->PitemChild())
    {
        // We have a list of partial children.  We need to remove
        // them because we are going to ask the snapin to enumerate
        // all of it's children. Do not get rid of this node.
        // This can happen if a node creates new children before it is
        // expanded.
        //
        // $REVIEW (ptousig) Creating a child when the parent is not expanded
        //                                       should simply not add the child.
        //
        sc = pitem->ScDeleteSubTree(FALSE);
        if (sc)
            goto Error;
    }

    // If we're creating the children, make sure there aren't any around.
    ASSERT(pitem->PitemChild() == NULL);

    sc = pitem->ScCreateChildren();
    if (sc)
        goto Error;

    if (pitem->PitemChild())
    {
        // Add or remove children to/from the console.
        sc = pitem->PitemChild()->ScInsertScopeItem(this, fExpand, hscopeitem);
        if (sc)
            goto Error;
    }

    pitem->SetWasExpanded(TRUE);

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScOnExpand"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Called by the MMC to delete the cookies for the entire subtree under a node. This
// is only to clean up allocated objects. Do NOT call IConsoleNameSpace::DeleteItem.
//
SC CComponentData::ScOnRemoveChildren(LPDATAOBJECT lpDataObject, HSCOPEITEM hscopeitem)
{
    SC sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    pitem = Pitem(lpDataObject, hscopeitem);
    ASSERT(pitem);

    // Get rid of the children.
    sc = pitem->ScDeleteSubTree(FALSE);
    if (sc)
        goto Error;

    // Release the given node if it is one of the root nodes
    sc = Psnapin()->ScReleaseIfRootItem(pitem);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScOnRemoveChildren"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Allows a snapin to control whether it will populate the scope pane
// in the background or not.
//
SC CComponentData::ScOnExpandSync(LPDATAOBJECT lpDataObject, MMC_EXPANDSYNC_STRUCT *pmes)
{
    // We don't care.
    return S_OK;
}

// -----------------------------------------------------------------------------
// The user has asked to delete this node.
//
SC CComponentData::ScOnDelete(LPDATAOBJECT pDataObject)
{
    SC                               sc                             = S_OK;
    CBaseSnapinItem *pitem                  = NULL;
    BOOL                     fDeleted               = FALSE;
    BOOL                     fPagesUp               = FALSE;
    tstring                  strMsg;

    pitem = Pitem(pDataObject);
    ASSERT(pitem);

    // The ComponentData should only receive notifications for scope pane items.
    ASSERT(pitem->FIsContainer());

    sc = pitem->ScIsPropertySheetOpen(&fPagesUp);
    if (sc)
        goto Error;

    if (fPagesUp)
    {
        ASSERT(FALSE && "Add below resource");
        //strMsg.LoadString(_Module.GetResourceInstance(), idsPropsUpNoDelete);
        strMsg += (*pitem->PstrDisplayName());
        MMCErrorBox(strMsg.data());
        goto Cleanup;
    }

    // Ask the item to delete the underlying object.
    sc = pitem->ScOnDelete(&fDeleted);
    if (sc)
        goto Error;

    if (fDeleted == FALSE)
        // The item did not want to be deleted.
        goto Cleanup;

    // Container items need to be deleted from the document
    // Delete the item and everything below it.
    sc = IpConsoleNameSpace()->DeleteItem(pitem->Hscopeitem(), TRUE);
    if (sc)
        goto Error;
    pitem->SetHscopeitem(0);

    // At this point, the item exists only in the tree, if at all.
    // Remove it from the tree.
    pitem->Unlink();
    // Get rid of it for good from the tree of items.
    pitem->Pdataobject()->Release();

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScOnDelete"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Toolbar button clicked.
//
SC CComponentData::ScOnButtonClick(LPDATAOBJECT lpDataObject, MMC_CONSOLE_VERB mcvVerb)
{
    return S_OK;
}

// -----------------------------------------------------------------------------
// Used to insert a new item into the tree of items, and, if the item is a container,
// into the namespace as well. The tree and the namespace are document, not view,
// concept. This insertion is done only once.
//
SC CComponentData::ScOnDocumentChangeInsertItem(CBaseSnapinItem *pitemNew)
{
    SC                                      sc                              = S_OK;
    CBaseSnapinItem *       pitemParent             = NULL;

    ASSERT(pitemNew);

    // Insert exactly once.
    if (pitemNew->FInserted())
        goto Cleanup;

    // The parent should have already been filled in
    pitemParent = pitemNew->PitemParent();
    ASSERT(pitemParent);

    if (pitemParent->FIncludesChild(pitemNew) == FALSE)
    {
        sc = pitemParent->ScAddChild(pitemNew);
        if (sc)
            goto Error;
    }

    if (pitemNew->FIsContainer())
    {
        if (pitemParent->FWasExpanded())
        {
            sc = pitemNew->ScInsertScopeItem(this, TRUE, pitemParent->Hscopeitem());
            if (sc)
                goto Error;
        }
    }

    // Only insert the item once.
    pitemNew->SetInserted(TRUE);

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScOnDocumentChangeInsertItem"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Tests whether the given item has already enumerated its children.
//
SC CComponentData::ScWasExpandedOnce(CBaseSnapinItem *pitem, BOOL *pfWasExpanded)
{
    SC sc = S_OK;
    SCOPEDATAITEM sdi;

    if (pitem->Hscopeitem() == 0)
    {
        //
        // If we don't have an HSCOPEITEM then we are not displayed in
        // the scope pane, therefore we have never been expanded (and
        // probably never will).
        //
        *pfWasExpanded = FALSE;
        goto Cleanup;
    }

    //
    // Ask for the state member of SCOPEDATAITEM
    //
    ::ZeroMemory(&sdi, sizeof(SCOPEDATAITEM));
    sdi.mask = SDI_STATE;
    sdi.ID = pitem->Hscopeitem();

    sc = IpConsoleNameSpace()->GetItem(&sdi);
    if (sc)
        goto Error;

    //
    // If the MMC_SCOPE_ITEM_STATE_EXPANDEDONCE is on it means we have
    // been asked to expand ourselves at least once before.
    //
    *pfWasExpanded = (sdi.nState & MMC_SCOPE_ITEM_STATE_EXPANDEDONCE) != 0;

Cleanup:
    return sc;

Error:
    TraceError(_T("CComponentData::ScWasExpandedOnce"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Adds property pages for the given data object, taking into account the context and also
// whether the data object is for a new object that is being created.
//
SC CComponentData::ScCreatePropertyPages(LPPROPERTYSHEETCALLBACK ipPropertySheetCallback, long handle, LPDATAOBJECT pDataObject)
{
    SC              sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    pitem = Pitem(pDataObject);
    ASSERT(pitem);

    if (pitem->FIsSnapinManager())
    {
        sc = pitem->ScCreateSnapinMgrPropertyPages(ipPropertySheetCallback);
        if (sc)
            goto Error;
    }
    else
    {
        // Simple version
        sc = pitem->ScCreatePropertyPages(ipPropertySheetCallback);
        if (sc)
            goto Error;

        // Complete version - for snapins that need all information (like Recipients)
        sc = pitem->ScCreatePropertyPages(ipPropertySheetCallback, handle);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScCreatePropertyPages"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Save information from the first root item.
//
// $REVIEW (ptousig) Why does the root item implement ScSave() ?
//                                       If a snapin extends two nodes it has two root items, yet
//                                       only one of which will be saved/loaded.
//
SC CComponentData::ScSave(IStream *pstream, BOOL fClearDirty)
{
    SC sc = S_OK;

    // Save the snapin's serialized information.
    sc = Psnapin()->ScSave(pstream, fClearDirty);
    if (sc)
        goto Error;

    // Load the root item's serialized information.
    // Only makes sense for standalone snapins.
    sc = Pitem()->ScSave(pstream, fClearDirty);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScSave"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Given a dataobject, determines whether or not pages exist.
// Actually, need to return S_OK here in both cases. If no pages exist
// it is CreatePropertyPages that should return S_FALSE. Sad but true.
//
SC CComponentData::ScQueryPagesFor(LPDATAOBJECT pDataObject)
{
    SC                              sc                      = S_OK;
    CBaseSnapinItem *       pitem           = NULL;

    pitem = Pitem(pDataObject);
    ASSERT(pitem);

    sc = pitem->ScQueryPagesFor();
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponentData::ScQueryPagesFor"), sc);
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\lib\component.cxx ===
/*
 *      Component.cxx
 *
 *
 *      Copyright (c) 1998-1999 Microsoft Corporation
 *
 *      PURPOSE:        Defines the CComponent class.
 *
 *
 *      OWNER:          ptousig
 */

#include "headers.hxx"

// -----------------------------------------------------------------------------
CComponent::CComponent(void)
{
    m_pComponentData                                = NULL;
    m_pitemScopeSelected                    = NULL;
    m_pMultiSelectSnapinItem                = NULL;                 // initially not involved in a multi select
}

// -----------------------------------------------------------------------------
// Destructor doesn't do anything, but it's useful to have one for debugging
// purposes.
//
CComponent::~CComponent(void)
{
}

// -----------------------------------------------------------------------------
// This version of Pitem() is a shortcut, it forwards the call to the
// CBaseSnapin with the correct CComponentData and CComponent parameters.
//
CBaseSnapinItem *CComponent::Pitem(
                                  LPDATAOBJECT lpDataObject,
                                  HSCOPEITEM hscopeitem,
                                  long cookie)
{
    return Psnapin()->Pitem(PComponentData(), this, lpDataObject, hscopeitem, cookie);
}

// -----------------------------------------------------------------------------
// Tells this component who the data is. Called shortly after the construction
// of the object. Why isn't this a parameter of the constructor ? Because ATL
// will always use the default constructor when creating a COM object.
//
void CComponent::SetComponentData(CComponentData *pComponentData)
{
    m_pComponentData = pComponentData;
}


/*+-------------------------------------------------------------------------*
 *
 * CComponent::QueryIComponent2
 *
 * PURPOSE: Determines whether or not to expose the IComponent2 interface on
 *          the object. This is because snapins that implement IComponent2
 *          will not be able to test IComponent::GetResultViewType and the MMCN_RESTORE_VIEW
 *          notification.
 *
 * PARAMETERS:
 *    void*   pv :
 *    REFIID  riid :
 *    LPVOID* ppv :   pointer to the "this" object.
 *    DWORD   dw :
 *
 * RETURNS:
 *    HRESULT WINAPI
 *
 *+-------------------------------------------------------------------------*/
HRESULT WINAPI
CComponent::QueryIComponent2(void* pv, REFIID riid, LPVOID* ppv, DWORD dw)
{
    DECLARE_SC(sc, TEXT("CComponent::QueryIComponent2"));
    sc = ScCheckPointers(ppv);
    if (sc)
        return sc.ToHr();

    *ppv = NULL;

    CComponent *pComponent = reinterpret_cast<CComponent *>(pv);
    if(!pComponent)
        return E_NOINTERFACE;

    sc = ScCheckPointers(pComponent->Psnapin());
    if(sc)
        return E_NOINTERFACE;

    if(pComponent->Psnapin()->FSupportsIComponent2())
    {
        // Cant use QueryInterface as it will cause infinite recursion.
        (*ppv) = (LPVOID)reinterpret_cast<IComponent2*>(pv);
        if (*ppv)
        {
            ((IUnknown*)(*ppv))->AddRef();
            return S_OK;
        }
    }

    return E_NOINTERFACE;
}


// -----------------------------------------------------------------------------
// Is called by the MMC to initialize the object. We QueryInterface
// for pointers to various interfaces, which we cache in
// member variables. This is called only once, when the user clicks on
// the snapin.
//
// $REVIEW (ptousig) I am not sure which of interfaces we are allowed to QI
//                                       for from the parameter. The MMC docs are no help (as usual),
//
SC CComponent::ScInitialize(LPCONSOLE lpConsole)
{
    DECLARE_SC(sc, _T("CComponent::ScInitialize"));

    ASSERT(lpConsole != NULL);
    ASSERT(m_ipConsole == NULL);

    // These are CComQIPtr so they will call QueryInterface.
    m_ipConsole                                     = lpConsole;
    m_ipHeaderCtrl                          = lpConsole;
    m_ipColumnDataPtr                       = lpConsole;
    m_ipResultData                          = lpConsole;
    m_ipPropertySheetProvider       = lpConsole;

    ASSERT( (m_ipConsole != NULL) || (m_ipHeaderCtrl != NULL) || (m_ipResultData!=NULL) || (m_ipPropertySheetProvider!=NULL) );

    // Short circuit the header control pointer back to the MMC
    sc = m_ipConsole->SetHeader(m_ipHeaderCtrl);
    if (sc)
        goto Error;

    // Get the IConsoleVerb interface.
    sc = m_ipConsole->QueryConsoleVerb(&m_ipConsoleVerb);
    if (sc)
        goto Error;

    // Get a pointer to the result pane's IImageList.
    sc = m_ipConsole->QueryResultImageList(&m_ipImageList);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScInitialize"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Handles component event notification.
// See MMC docs for the meaning of 'arg' and 'param'.
//
SC CComponent::ScNotify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
{
    SC sc = S_OK;

    switch (event)
    {
    case MMCN_ACTIVATE:
        sc = ScOnActivate(lpDataObject, arg != FALSE);
        break;

    case MMCN_ADD_IMAGES:
        sc = ScOnAddImages(lpDataObject, reinterpret_cast<IImageList *>(arg), param);
        break;

    case MMCN_BTN_CLICK:
        sc = ScOnButtonClick(lpDataObject, (MMC_CONSOLE_VERB) param);
        break;

    case MMCN_CONTEXTHELP:
        sc = ScOnContextHelp(lpDataObject);
        break;

    case MMCN_DBLCLICK:
        sc = ScOnDoubleClick(lpDataObject);
        break;

    case MMCN_DELETE:
        sc = ScOnDelete(lpDataObject);
        break;

    case MMCN_CUTORMOVE:
        sc = Psnapin()->ScOnCutOrMove(reinterpret_cast<LPDATAOBJECT>(arg), IpConsoleNameSpace(), IpConsole());
        break;

    case MMCN_QUERY_PASTE:
        sc = Psnapin()->ScOnQueryPaste(lpDataObject, reinterpret_cast<LPDATAOBJECT>(arg), reinterpret_cast<LPDWORD>(param));
        break;

    case MMCN_CANPASTE_OUTOFPROC:
        sc = Psnapin()->ScOnCanPasteOutOfProcDataObject(reinterpret_cast<LPBOOL>(param));
        break;

    case MMCN_PASTE:
        sc = Psnapin()->ScOnPaste(lpDataObject, reinterpret_cast<LPDATAOBJECT>(arg), reinterpret_cast<LPDATAOBJECT *>(param), IpConsole());
        break;

    case MMCN_RENAME:
        sc = Psnapin()->ScOnRename(lpDataObject, reinterpret_cast<LPCTSTR>(param), IpConsole());
        break;

    case MMCN_LISTPAD:
        sc = ScOnListPad(lpDataObject, arg != FALSE);
        break;

    case MMCN_PROPERTY_CHANGE:
        sc = Psnapin()->ScOnPropertyChange(arg != FALSE, param, IpConsoleNameSpace(), IpConsole());
        break;

    case MMCN_REFRESH:
        //
        // Undocumented: arg is the HSCOPEITEM
        //
        sc = ScOnRefresh(lpDataObject, arg);
        break;

    case MMCN_SELECT:
        sc = ScOnSelect(lpDataObject, LOWORD(arg) != FALSE, HIWORD(arg) != FALSE);
        break;

    case MMCN_SHOW:
        sc = ScOnShow(lpDataObject, arg != FALSE, param);
        break;

    case MMCN_VIEW_CHANGE:
        sc = ScOnViewChange(lpDataObject, arg, param);
        break;

    case MMCN_INITOCX:
        sc = ScOnInitOCX(lpDataObject, reinterpret_cast<IUnknown*>(param));
        break;

    default:
		sc = S_FALSE;
        ASSERT(_T("CComponent::ScNotify: unimplemented event"));
        break;
    }
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScNotify"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Releases all interfaces.
//
SC CComponent::ScDestroy(void)
{
    if (m_ipConsole)
        // Release the interfaces that we QI'ed
        m_ipConsole->SetHeader(NULL);

    m_ipConsole.Release();
    m_ipHeaderCtrl.Release();
    m_ipColumnDataPtr.Release();
    m_ipResultData.Release();
    m_ipConsoleVerb.Release();
    m_ipImageList.Release();
    m_ipPropertySheetProvider.Release();

    return S_OK;
}

// -----------------------------------------------------------------------------
// MMC wants to know what to display for a given result item.
// Warning: This is called very very often (on WM_PAINT) so it is important
// we don't take any high latency actions (ie Network or Disk access).
//
SC CComponent::ScGetDisplayInfo(LPRESULTDATAITEM pResultItem)
{
    SC                      sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    // We need to figure out which snapin item to route the getdisplayinfo
    if (FVirtualResultsPane())
    {
        // We are displaying virtual items in the results pane.  So
        // we will ask the controlling scope item to get the display
        // info because no "real" item exists in the results pane.
        ASSERT(PitemScopeSelected());

        sc = PitemScopeSelected()->ScGetVirtualDisplayInfo(pResultItem, IpResultData());
        if (sc)
            goto Error;
    }
    else
    {
        // The lParam member of RESULTDATAITEM contains the cookie.
        pitem = Pitem(NULL, 0, pResultItem->lParam);
        ASSERT(pitem);

        sc = pitem->ScGetDisplayInfo(pResultItem);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScGetDisplayInfo"), sc);
    goto Cleanup;
}


/*+-------------------------------------------------------------------------*
 *
 * CComponent::ScQueryDispatch
 *
 * PURPOSE: Returns a dispatch interface for the specified data object.
 *
 * PARAMETERS:
 *    MMC_COOKIE         cookie :
 *    DATA_OBJECT_TYPES  type :
 *    LPDISPATCH*        ppDispatch :
 *
 * RETURNS:
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CComponent::ScQueryDispatch(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDISPATCH* ppDispatch)
{
    DECLARE_SC(sc, TEXT("CComponent::ScQueryDispatch"));
    CBaseSnapinItem *               pitem           = NULL;

    // Determine if we have a special cookie for multiselect
    if (IS_SPECIAL_COOKIE(cookie) && (MMC_MULTI_SELECT_COOKIE == cookie))
    {
        // Make sure we are queried for a multiselect
        ASSERT(CCT_UNINITIALIZED == type);

        // We need to create a special multiselect data object
        ASSERT(Psnapin());

        //NOTE: need to implement multi select dispatch obect
        sc = S_FALSE; //Psnapin()->ScCreateMultiSelectionDataObject(ppDataObject, this);
        if (sc)
            return sc;
    }
    else
    {
        // We are a component, we should only receive result pane cookies.
        ASSERT(type==CCT_RESULT);

        if (FVirtualResultsPane())
        {
            ASSERT(PitemScopeSelected());

            // This function is being asked for a data object for a row in a virtual
            // results pane.  By definition there is no snapin item there.  So we ask
            // the controlling scope item to provide us with a "temporary" data object.
            sc = S_FALSE; //PitemScopeSelected()->ScVirtualQueryDataObject(cookie, type, ppDataObject);
            if (sc)
                return sc;
        }
        else
        {
            // If the cookie does not correspond to a known object, return E_UNEXPECTED.
            // This is correct and is also a workaround for a MMC bug. See bug X5:74405.
            if (cookie && (Psnapin()->Pcookielist()->find(cookie) == Psnapin()->Pcookielist()->end() ) )
            {
                return(sc = E_UNEXPECTED);
            }

            pitem = Pitem(NULL, 0, cookie);
            ASSERT(pitem);

            sc = pitem->ScQueryDispatch(cookie, type, ppDispatch);
            if (sc)
                return sc;
        }
    }


    return sc;
}

SC
CComponent::ScGetResultViewType2(MMC_COOKIE cookie, PRESULT_VIEW_TYPE_INFO pResultViewType)
{
    DECLARE_SC(sc, _T("CComponent::ScGetResultViewType2"));
    CBaseSnapinItem *pitem = NULL;

    ASSERT(pResultViewType);

    pitem = Pitem(NULL, 0, cookie);
    ASSERT(pitem);

    sc = pitem->ScGetResultViewType2(m_ipConsole, pResultViewType);
    if (sc)
        return sc;

    return sc;
}

SC
CComponent::ScRestoreResultView(MMC_COOKIE cookie, RESULT_VIEW_TYPE_INFO* pResultViewType)
{
    DECLARE_SC(sc, _T("CComponent::ScRestoreResultView"));
    CBaseSnapinItem *pitem = NULL;

    ASSERT(pResultViewType);

    pitem = Pitem(NULL, 0, cookie);
    ASSERT(pitem);

    sc = pitem->ScRestoreResultView(pResultViewType);
    if (sc)
        return sc;

    return sc;
}


// -----------------------------------------------------------------------------
// Handles the MMCN_SELECT notification sent to IComponent::Notify. Enables the Properties
// and Refresh verbs. Sets Properties as the default verb.
//
SC CComponent::ScOnSelect(LPDATAOBJECT lpDataObject, BOOL fScope, BOOL fSelect)
{
    // Declarations
    SC                                                      sc                                                      = S_OK;
    DWORD                                           dwVerbs                                         = 0;
    MMC_CONSOLE_VERB                        mmcverbDefault                          = MMC_VERB_NONE;
    INT                                                     i                                                       = 0;
    CBaseSnapinItem *                       pitem                                           = NULL;
    CBaseMultiSelectSnapinItem *pBaseMultiSelectSnapinItem  = NULL;

    // Data validation
    ASSERT(lpDataObject);

    // Determine if this is a multiselect data object
    sc = CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject(lpDataObject, &pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;

    // If we received a multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        // Call ScOnSelect for the multiselect object for dispatch
        sc = pBaseMultiSelectSnapinItem->ScOnSelect(this, lpDataObject, fScope, fSelect);
        if (sc)
            goto Error;
    }
    else
    {
        // Handle the normal case - PItem() does more work than a simple cast to verify that the snapin item belongs to the snapin etc.
        pitem = Pitem(lpDataObject);
        ASSERT(pitem);

        if (pitem->FIsContainer())
        {
            // Enable the Open property             // $REVIEW (dominicp) Why 2 separate calls?
            sc = IpConsoleVerb()->SetVerbState(MMC_VERB_OPEN, ENABLED, TRUE);
            if (sc)
                goto Error;

            // Need to hide it but keep it enabled.
            sc = IpConsoleVerb()->SetVerbState(MMC_VERB_OPEN, HIDDEN, TRUE);
            if (sc)
                goto Error;
        }

        if (fSelect)
        {
            // Get all the required verbs, bitwise-ORed together.
            sc = Psnapin()->ScGetVerbs(lpDataObject, &dwVerbs);
            if (sc)
                goto Error;

            // Loop through the list of verbs, turning on the needed ones.
            for (i=0; i<Psnapin()->Cverbmap(); i++)
            {
                ASSERT(Psnapin()->Pverbmap(i));
                if (dwVerbs & Psnapin()->Pverbmap(i)->verbmask)
                {
                    sc = IpConsoleVerb()->SetVerbState(Psnapin()->Pverbmap(i)->mmcverb, ENABLED, TRUE);
                    if (sc)
                        goto Error;
                }
            }

#ifdef _DEBUG
            if (tagBaseSnapinDebugCopy.FAny())
            {
                sc = IpConsoleVerb()->SetVerbState(MMC_VERB_COPY, ENABLED, TRUE);
                if (sc)
                    goto Error;
            }
#endif

            // Get the default verb.
            mmcverbDefault = Psnapin()->MmcverbDefault(lpDataObject);

            // Set the default verb, which is invoked by double clicking.
            if (mmcverbDefault != MMC_VERB_NONE)
            {
                sc = IpConsoleVerb()->SetDefaultVerb(mmcverbDefault);
                if (sc)
                    goto Error;
            }
        }

        // To call DisplayStatusText for example, we need to get to the IComponent's IConsole2
        // IComponentData's IConsole2 is no good, so we pass 'this'
        sc = pitem->ScOnSelect(this, lpDataObject, fScope, fSelect);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnSelect"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Loads per-view information. We don't have any.
//
SC CComponent::ScLoad(IStream *pstream)
{
    return S_OK;
}

// -----------------------------------------------------------------------------
// If one of the commands added to the context menu is
// subsequently selected, MMC calls Command.
//
// Even though this method "looks" like the one in CComponentData,
// the use of the Pitem() shortcut makes them different. The CComponentData
// version does not pass a component to the real Pitem().
//
SC CComponent::ScCommand(long nCommandID, LPDATAOBJECT lpDataObject)
{
    // Declarations
    SC                                                                      sc                                                      = S_OK;
    CBaseSnapinItem *                                       pitem                                           = NULL;
    CBaseMultiSelectSnapinItem *            pBaseMultiSelectSnapinItem      = NULL;

    // Data validation
    ASSERT(lpDataObject);

    // See if we can extract the multi select data object from the composite data object
    sc = CBaseMultiSelectSnapinItem::ScExtractMultiSelectDataObject(Psnapin(), lpDataObject, &pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;

    // If we actually had a composite data object and we were able to find our multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        // Call ScCommand for the multiselect object for dispatch
        sc = pBaseMultiSelectSnapinItem->ScCommand(this, nCommandID, lpDataObject);
        if (sc)
            goto Error;
    }
    else
    {
        // Handle the normal case - PItem() does more work than a simple cast to verify that the snapin item belongs to the snapin etc.
        pitem = Pitem(lpDataObject);
        ASSERT(pitem);

        sc = pitem->ScCommand(nCommandID, this);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScCommand"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// MMC wants to know the kind of result pane we want.
//
SC CComponent::ScGetResultViewType(long cookie, LPOLESTR *ppViewType, long *pViewOptions)
{
    SC sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    ASSERT(ppViewType);
    ASSERT(pViewOptions);

    pitem = Pitem(NULL, 0, cookie);
    ASSERT(pitem);

    sc = pitem->ScGetResultViewType(ppViewType, pViewOptions);
    if (sc)
        goto Error;

Cleanup:
    return sc;

Error:
    TraceError(_T("CComponent::ScGetResultViewType"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// IResultOwnerData method used to tell a snapin item which rows in
// the result pane it will be asking for soon so they can be cached.
//
SC CComponent::ScCacheHint(INT nStartIndex, INT nEndIndex)
{
    SC sc = S_OK;

    ASSERT(FVirtualResultsPane());
    ASSERT(PitemScopeSelected());

    sc = PitemScopeSelected()->ScCacheHint(nStartIndex, nEndIndex);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScCacheHint"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// IResultOwnerData method used to ask a snapin item sort a virtual list.
//
SC CComponent::ScSortItems(INT nColumn, DWORD dwSortOptions, long lUserParam)
{
    SC sc = S_OK;

    ASSERT(FVirtualResultsPane());
    ASSERT(PitemScopeSelected());

    sc = PitemScopeSelected()->ScSortItems(nColumn, dwSortOptions, lUserParam);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScSortItems"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Are we currently displaying a virtual list in the result pane ?
//
BOOL CComponent::FVirtualResultsPane(void)
{
    // TRUE if an item is currently selected in the scope pane and it says it is virtual.
    return m_pitemScopeSelected && m_pitemScopeSelected->FVirtualResultsPane();
}

// -----------------------------------------------------------------------------
// Determines whether any settings have changed since the last time the file
// was saved.
//
SC CComponent::ScIsDirty(void)
{
    SC              sc = S_OK;
    BOOL    fIsDirty = FALSE;
    INT             i = 0;

    sc = Pitem()->ScIsDirty();
    if (sc == S_FALSE)
        sc = S_OK;
    else if (sc)
        fIsDirty = TRUE;
    else
        goto Error;

Cleanup:
    sc = fIsDirty ? S_OK : S_FALSE;
    return sc;

Error:
    TraceError(_T("CComponent::ScIsDirty"), sc);
    fIsDirty = FALSE;
    goto Cleanup;
}

// -----------------------------------------------------------------------------
HRESULT CComponent::Initialize(LPCONSOLE lpConsole)
{
    DECLARE_SC(sc, _T("CComponent::Initialize"));
    Trace(tagBaseSnapinIComponent, _T("--> %s::IComponent::Initialize(lpConsole=0x%08X)"), StrSnapinClassName(), lpConsole);
    ADMIN_TRY;
    sc = ScInitialize(lpConsole);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponent, _T("<-- %s::IComponent::Initialize is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::Notify(LPDATAOBJECT lpDataObject, MMC_NOTIFY_TYPE event, long arg, long param)
{
    DECLARE_SC(sc, _T("CComponent::Notify"));
    Trace(tagBaseSnapinIComponent, _T("--> %s::IComponent::Notify(lpDataObject=0x%08X, event=%s, arg=0x%08X, param=0x%08X)"), StrSnapinClassName(), lpDataObject, SzGetDebugNameOfMMC_NOTIFY_TYPE(event), arg, param);
    ADMIN_TRY;
    sc=ScNotify(lpDataObject, event, arg, param);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponent, _T("<-- %s::IComponent::Notify is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::Destroy(long cookie)
{
    DECLARE_SC(sc, _T("CComponent::Destroy"));
    Trace(tagBaseSnapinIComponent, _T("--> %s::IComponent::Destroy"), StrSnapinClassName());
    ADMIN_TRY;
    sc=ScDestroy();
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponent, _T("<-- %s::IComponent::Destroy is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::GetResultViewType(long cookie, LPOLESTR *ppViewType, long *pViewOptions)
{
    DECLARE_SC(sc, _T("CComponent::GetResultViewType"));
    Trace(tagBaseSnapinIComponent, _T("--> %s::IComponent::GetResultViewType(cookie=0x%08X)"), StrSnapinClassName(), cookie);
    ADMIN_TRY;
    sc=ScGetResultViewType(cookie, ppViewType, pViewOptions);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponent, _T("<-- %s::IComponent::GetResultViewType is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::QueryDataObject(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT *ppDataObject)
{
    DECLARE_SC(sc, _T("CComponent::QueryDataObject"));
    Trace(tagBaseSnapinIComponentQueryDataObject, _T("--> %s::IComponent::QueryDataObject(cookie=0x%08X, type=%s)"), StrSnapinClassName(), cookie, SzGetDebugNameOfDATA_OBJECT_TYPES(type));
    ADMIN_TRY;
    //
    // If we receive E_UNEXPECTED we don't want to call MMCHrFromSc because
    // that will bring up an error message. We don't want an error message
    // in this case because of a known MMC bug (see bug X5:74405).
    // The bug says that we might receive QueryDataObject on items that
    // we were told no longer exists (by MMCN_REMOVE_CHILDREN).
    //
    sc = ScQueryDataObject(cookie, type, ppDataObject);
    if (sc)
        return sc.ToHr();
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentQueryDataObject, _T("<-- %s::IComponent::QueryDataObject is returning hr=%s, *ppDataObject=0x%08X"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()), *ppDataObject);
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::GetDisplayInfo(RESULTDATAITEM *pResultDataItem)
{
    DECLARE_SC(sc, _T("CComponent::GetDisplayInfo"));
    Trace(tagBaseSnapinIComponentGetDisplayInfo, _T("--> %s::IComponent::GetDisplayInfo(cookie=0x%08X)"), StrSnapinClassName(), pResultDataItem->lParam);
    ADMIN_TRY;
    sc=ScGetDisplayInfo(pResultDataItem);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponentGetDisplayInfo, _T("<-- %s::IComponent::GetDisplayInfo is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::CompareObjects(LPDATAOBJECT lpDataObjectA, LPDATAOBJECT lpDataObjectB)
{
    DECLARE_SC(sc, _T("CComponent::CompareObjects"));
    Trace(tagBaseSnapinIComponent, _T("--> %s::IComponent::CompareObjects(lpDataObjectA=0x%08X, lpDataObjectB=0x%08X)"), StrSnapinClassName(), lpDataObjectA, lpDataObjectB);
    ADMIN_TRY;
    sc=Psnapin()->ScCompareObjects(lpDataObjectA, lpDataObjectB);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIComponent, _T("<-- %s::IComponent::CompareObjects is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}


// -----------------------------------------------------------------------------
HRESULT CComponent::QueryDispatch(MMC_COOKIE cookie, DATA_OBJECT_TYPES type, LPDISPATCH* ppDispatch)
{
    DECLARE_SC(sc, _T("CComponent::QueryDispatch"));
    ADMIN_TRY;
    sc = ScQueryDispatch(cookie, type, ppDispatch);
    ADMIN_CATCH_HR;
    Trace(tagBaseSnapinIComponent, _T("<-- %s::IComponent::QueryDispatch is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::GetResultViewType2(MMC_COOKIE cookie, PRESULT_VIEW_TYPE_INFO pResultViewType)
{
    DECLARE_SC(sc, _T("CComponent::GetResultViewType2"));
    ADMIN_TRY;
    sc = ScGetResultViewType2(cookie, pResultViewType);
    ADMIN_CATCH_HR;
    Trace(tagBaseSnapinIComponent, _T("<-- %s::IComponent::GetResultViewType2 is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::RestoreResultView(MMC_COOKIE cookie, RESULT_VIEW_TYPE_INFO* pResultViewType)
{
    DECLARE_SC(sc, _T("CComponent::RestoreResultView"));
    ADMIN_TRY;
    sc = ScRestoreResultView(cookie, pResultViewType);
    ADMIN_CATCH_HR;
    Trace(tagBaseSnapinIComponent, _T("<-- %s::IComponent::RestoreResultView is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}


// -----------------------------------------------------------------------------
HRESULT CComponent::AddMenuItems(LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK ipContextMenuCallback, long *pInsertionAllowed)
{
    DECLARE_SC(sc, _T("CComponent::AddMenuItems"));
    Trace(tagBaseSnapinIExtendContextMenu, _T("--> %s::IExtendContextMenu::AddMenuItems(pDataObject=0x%08X)"), StrSnapinClassName(), pDataObject);
    ADMIN_TRY;
    sc=Psnapin()->ScAddMenuItems(pDataObject, ipContextMenuCallback, pInsertionAllowed);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIExtendContextMenu, _T("<-- %s::IExtendContextMenu::AddMenuItems is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::Command(long nCommandID, LPDATAOBJECT pDataObject)
{
    DECLARE_SC(sc, _T("CComponent::Command"));
    Trace(tagBaseSnapinIExtendContextMenu, _T("--> %s::IExtendContextMenu::Command(nCommandID=%ld, pDataObject=0x%08X)"), StrSnapinClassName(), nCommandID, pDataObject);
    ADMIN_TRY;
    sc=ScCommand(nCommandID, pDataObject);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIExtendContextMenu, _T("<-- %s::IExtendContextMenu::Command is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::CreatePropertyPages(LPPROPERTYSHEETCALLBACK lpProvider, long handle, LPDATAOBJECT lpDataObject)
{
    DECLARE_SC(sc, _T("CComponent::CreatePropertyPages"));
    Trace(tagBaseSnapinIExtendPropertySheet, _T("--> %s::IExtendPropertySheet::CreatePropertyPages(lpDataObject=0x%08X)"), StrSnapinClassName(), lpDataObject);
    ADMIN_TRY;
    sc = ScCreatePropertyPages(lpProvider, handle, lpDataObject);
    if (sc)
        sc=sc.ToHr();
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIExtendPropertySheet, _T("<-- %s::IExtendPropertySheet::CreatePropertyPages is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::QueryPagesFor(LPDATAOBJECT lpDataObject)
{
    DECLARE_SC(sc, _T("CComponent::QueryPagesFor"));
    Trace(tagBaseSnapinIExtendPropertySheet, _T("--> %s::IExtendPropertySheet::QueryPagesFor(lpDataObject=0x%08X)"), StrSnapinClassName(), lpDataObject);
    ADMIN_TRY;
    sc=ScQueryPagesFor(lpDataObject);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIExtendPropertySheet, _T("<-- %s::IExtendPropertySheet::QueryPagesFor is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    DECLARE_SC(sc, _T("CComponent::GetSizeMax"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::GetSizeMax"), StrSnapinClassName());
    ADMIN_TRY;
    ASSERT(pcbSize);
    pcbSize->LowPart = cMaxStreamSizeLow;
    pcbSize->HighPart = cMaxStreamSizeHigh;
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::GetSizeMax is returning hr=%s, (*pcbSize).LowPart=%d"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()), (*pcbSize).LowPart);
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::IsDirty(void)
{
    DECLARE_SC(sc, _T("CComponent::IsDirty"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::IsDirty"), StrSnapinClassName());
    ADMIN_TRY;
    sc=ScIsDirty();
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::IsDirty is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::Load(IStream *pstream)
{
    DECLARE_SC(sc, _T("CComponent::Load"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::Load"), StrSnapinClassName());
    ADMIN_TRY;
    sc=ScLoad(pstream);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::Load is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::Save(IStream *pstream, BOOL fClearDirty)
{
    DECLARE_SC(sc, _T("CComponent::Save"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::Save(fClearDirty=%S)"), StrSnapinClassName(), fClearDirty ? "TRUE" : "FALSE");
    ADMIN_TRY;
    sc=ScSave(pstream, fClearDirty);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::Save is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::InitNew(void)
{
    DECLARE_SC(sc, _T("CComponent::InitNew"));
    // We don't have anything to do, but we still want to log the call.
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::InitNew"), StrSnapinClassName());
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::InitNew is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::GetClassID(CLSID *pclsid)
{
    DECLARE_SC(sc, _T("CComponent::GetClassID"));
    Trace(tagBaseSnapinIPersistStreamInit, _T("--> %s::IPersistStreamInit::GetClassID"), StrSnapinClassName());
    ADMIN_TRY;
    ASSERT(pclsid);
    *pclsid = *(Psnapin()->PclsidSnapin());
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIPersistStreamInit, _T("<-- %s::IPersistStreamInit::GetClassID is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::CacheHint(int nStartIndex, int nEndIndex)
{
    DECLARE_SC(sc,_T("CComponent::CacheHint"));
    Trace(tagBaseSnapinIResultOwnerData, _T("--> %s::IResultOwnerData::CacheHint(nStartIndex=%d, nEndIndex=%d)"), StrSnapinClassName(), nStartIndex, nEndIndex);
    ADMIN_TRY;
    sc=ScCacheHint(nStartIndex, nEndIndex);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIResultOwnerData, _T("<-- %s::IResultOwnerData::CacheHint is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::SortItems(int nColumn, DWORD dwSortOptions, long lUserParam)
{
    DECLARE_SC(sc,_T("CComponent::SortItems"));
    Trace(tagBaseSnapinIResultOwnerData, _T("--> %s::IResultOwnerData::SortItems"), StrSnapinClassName());
    ADMIN_TRY;
    sc=ScSortItems(nColumn, dwSortOptions, lUserParam);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIResultOwnerData, _T("<-- %s::IResultOwnerData::SortItems is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::FindItem(LPRESULTFINDINFO pFindinfo, int *pnFoundIndex)
{
    DECLARE_SC(sc,_T("CComponent::FindItem"));
    Trace(tagBaseSnapinIResultOwnerData, _T("--> %s::IResultOwnerData::FindItem"), StrSnapinClassName());
    ADMIN_TRY;
    ASSERT(pnFoundIndex);
    sc = ScFindItem(pFindinfo, pnFoundIndex);
    if (! sc)
    // if no error occured -- convert the found item index into the mmc expected return codes
        sc=(*pnFoundIndex != -1) ? S_OK : S_FALSE;
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIResultOwnerData, _T("<-- %s::IResultOwnerData::FindItem is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
HRESULT CComponent::Compare(RDCOMPARE * prdc, int * pnResult)
{
    DECLARE_SC(sc,_T("CComponent::Compare"));
    Trace(tagBaseSnapinIResultDataCompare, _T("--> %s::IResultDataCompare::Compare(cookieA=0x%08X, cookieB=0x%08X)"), StrSnapinClassName(), prdc->prdch1->cookie, prdc->prdch2->cookie);
    ADMIN_TRY;
    ASSERT(pnResult);
    ASSERT(prdc);
    ASSERT(prdc->prdch1);
    ASSERT(prdc->prdch2);
    sc=Psnapin()->ScCompare(prdc->prdch1->cookie, prdc->prdch2->cookie, prdc->nColumn, pnResult);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIResultDataCompare, _T("<-- %s::IResultDataCompare::Compare is returning hr=%s, *pnResult=%d"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()), *pnResult);
    return sc.ToHr();
}

// -----------------------------------------------------------------------------
// IResultOwnerData method used to ask a snapin item to do a find
// in a virtual list.
//
SC CComponent::ScFindItem(LPRESULTFINDINFO pFindinfo, INT *pnFoundIndex)
{
    SC sc = S_OK;

    ASSERT(FVirtualResultsPane());
    ASSERT(PitemScopeSelected());

    sc = PitemScopeSelected()->ScFindItem(pFindinfo, pnFoundIndex);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScFindItem"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Handles the MMCN_DBLCLICK notification sent to IComponent::Notify.
//
SC CComponent::ScOnDoubleClick(LPDATAOBJECT lpDataObject)
{
    // $REVIEW (ptousig) What does S_FALSE mean ?
    return S_FALSE;
}

// -----------------------------------------------------------------------------
// Creates a data object of the appropriate type, and returns the
// IDataObject interface on it.
//
SC CComponent::ScQueryDataObject(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT * ppDataObject)
{
    // Declarations
    SC                                              sc                      = S_OK;
    CBaseSnapinItem *               pitem           = NULL;

    // Determine if we have a special cookie for multiselect
    if (IS_SPECIAL_COOKIE(cookie) && (MMC_MULTI_SELECT_COOKIE == cookie))
    {
        // Make sure we are queried for a multiselect
        ASSERT(CCT_UNINITIALIZED == type);

        // We need to create a special multiselect data object
        ASSERT(Psnapin());
        sc = Psnapin()->ScCreateMultiSelectionDataObject(ppDataObject, this);
        if (sc)
            goto Error;
    }
    else
    {
        // We are a component, we should only receive result pane cookies.
        ASSERT(type==CCT_RESULT);

        if (FVirtualResultsPane())
        {
            ASSERT(PitemScopeSelected());

            // This function is being asked for a data object for a row in a virtual
            // results pane.  By definition there is no snapin item there.  So we ask
            // the controlling scope item to provide us with a "temporary" data object.
            sc = PitemScopeSelected()->ScVirtualQueryDataObject(cookie, type, ppDataObject);
            if (sc)
                goto Error;
        }
        else
        {
            // If the cookie does not correspond to a known object, return E_UNEXPECTED.
            // This is correct and is also a workaround for a MMC bug. See bug X5:74405.
            if (cookie && (Psnapin()->Pcookielist()->find(cookie) == Psnapin()->Pcookielist()->end() ) )
            {
                sc = E_UNEXPECTED;
                goto Cleanup;
            }

            pitem = Pitem(NULL, 0, cookie);
            ASSERT(pitem);

            sc = pitem->ScQueryDataObject(cookie, type, ppDataObject);
            if (sc)
                goto Error;
        }
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScQueryDataObject"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Handles the MMCN_SHOW notification sent to IComponent::Notify. Initializes the
// default list view's headers.
//
SC CComponent::ScOnShow(LPDATAOBJECT lpDataObject, BOOL fSelect, HSCOPEITEM hscopeitem)
{
    SC sc = S_OK;
    BOOL fIsOwned = TRUE;
    CBaseSnapinItem *pitem = NULL;

    pitem = Pitem(lpDataObject, hscopeitem);
    ASSERT(pitem);

    // Since we are selecting/deselecting a scope item we
    // need to update who the selected scope item is.  Note:
    // we dont do this in MMCN_SELECT.  MMCN_SELECT gets called
    // when a results node is being selected.  We aren't tracking
    // the selected RESULTS node but selected SCOPE node.
    SetItemScopeSelected(fSelect ? pitem : NULL);

    // Use this opportunity to correlate the CSnapinItem and the HSCOPEITEM.
    // $REVIEW (ptousig) Should be done inside Pitem().
    pitem->SetHscopeitem(hscopeitem);

    // Set up the list view.
    sc = pitem->ScOnShow(this, fSelect);
    if (sc)
        goto Error;

    // $REVIEW (ptousig) Couldn't we just call ScOnViewChangeUpdateResultItems either way ?
    if (fSelect)
    {
        // Note: this is not a call to UpdateAllViews
        sc = ScOnViewChangeUpdateResultItems(pitem, fSelect);
        if (sc)
            goto Error;
    }
    else
    {
        // This call doesn't do anything.
        sc = pitem->ScRemoveResultItems(IpResultData());
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnShow"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Used to update the description bar
//
SC CComponent::ScOnViewChangeUpdateDescriptionBar(CBaseSnapinItem *pitem)
{
    SC sc = S_OK;

    if (PitemScopeSelected() != pitem)
        goto Cleanup;

    if (pitem->PstrDescriptionBar())
    {
        ASSERT(IpResultData());
        sc = IpResultData()->SetDescBarText((LPTSTR)pitem->PstrDescriptionBar()->data());
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnViewChangeUpdateDescriptionBar"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Used to update an item's result-item children.
//
SC CComponent::ScOnViewChangeUpdateResultItems(CBaseSnapinItem *pitem, BOOL fSelect)
{
    SC                              sc = S_OK;
    CViewItemList   viewitemlist;
    CViewItemListBase::iterator viewitemiter;

    if (PitemScopeSelected() != pitem)
        goto Cleanup;

    if (!pitem->FUsesResultList())
        goto Cleanup;

    if (fSelect)
    {
        // Create a result view.
        viewitemlist.Initialize(pitem, pitem->DatPresort(), pitem->DatSort());

        // Update description text
        if (pitem->PstrDescriptionBar())
        {
            sc = IpResultData()->SetDescBarText((LPTSTR)pitem->PstrDescriptionBar()->data());
            if (sc)
                goto Error;
        }

        // remove all result items because are going to re add them
        // all here.
        sc = IpResultData()->DeleteAllRsltItems();
        if (sc)
            goto Error;

        // if we are selecting and updating the result pane then we
        // are inserting all the result items.  We need to make sure that
        // we are in vlb mode and that the number of vlb items is set
        // by initializing the result view.
        sc = pitem->ScInitializeResultView(this);
        if (sc)
            goto Error;


        // Insert all leaf nodes into the list view.
        for (viewitemiter = viewitemlist.begin(); viewitemiter < viewitemlist.end(); viewitemiter++)
        {
            // Only add non-container, ie leaf, nodes.
            if ((*viewitemiter)->FIsContainer() == FALSE)
            {
                sc = (*viewitemiter)->ScInsertResultItem(this);
                if (sc)
                    goto Error;
            }
        }
    }
    else
    {
        // $REVIEW (ptousig) This could be done from inside "pitem->ScRemoveResultItems".
        sc = IpResultData()->DeleteAllRsltItems();
        if (sc)
            goto Error;

        sc = pitem->ScRemoveResultItems(IpResultData());
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnViewChangeUpdateResultItems"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Called by the MMC upon a call to IConsole->UpdateAllViews().
//
SC CComponent::ScOnViewChange(LPDATAOBJECT lpDataObject, long data, long hint)
{
    SC                                      sc              = S_OK;
    CBaseSnapinItem *       pitem   = NULL;

    pitem = Pitem(lpDataObject);

    switch (hint)
    {
    case ONVIEWCHANGE_DELETEITEMS:
        // Are we being called to delete all items?
        sc = ScOnViewChangeDeleteItems(pitem);
        break;

    case ONVIEWCHANGE_DELETESINGLEITEM:
        sc = ScOnViewChangeDeleteSingleItem(pitem);
        break;

    case ONVIEWCHANGE_INSERTNEWITEM:
        sc = ScOnViewChangeInsertItem(pitem);
        break;

    case ONVIEWCHANGE_UPDATERESULTITEM:
        sc = ScOnViewChangeUpdateItem(pitem);
        break;

    case ONVIEWCHANGE_REFRESHCHILDREN:
        sc = ScOnRefresh(pitem->Pdataobject(), data);
        break;

    case ONVIEWCHANGE_DELETERESULTITEMS:
        sc = ScOnViewChangeUpdateResultItems(pitem, FALSE);
        break;

    case ONVIEWCHANGE_UPDATEDESCRIPTIONBAR:
        sc = ScOnViewChangeUpdateDescriptionBar(pitem);
        break;

    case ONVIEWCHANGE_INSERTRESULTITEMS:
        sc = ScOnViewChangeUpdateResultItems(pitem, TRUE);
        break;

    default:
        sc = ScOnViewChangeHint(pitem, hint);
        break;
    }

    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnViewChange"), sc);
    goto Cleanup;

}


// -----------------------------------------------------------------------------
// Deletes all the items underneath the root. This is typically used to regenerate the tree.
//
SC CComponent::ScOnViewChangeDeleteItems(CBaseSnapinItem *pitem)
{
    SC              sc = S_OK;
    CBaseSnapinItem *pitemRoot = NULL;

    pitemRoot = Pitem();

    // First check that the root item's HSCOPEITEM is non-null.
    // If it is NULL the item was never Expand'ed or Show'ed so OK to ignore.
    if (pitemRoot->Hscopeitem() == 0)
        goto Cleanup;

    // Select the root scope item first.
    ASSERT(pitemRoot->Hscopeitem());
    sc = IpConsole()->SelectScopeItem(pitemRoot->Hscopeitem());
    if (sc)
        goto Error;

    // Delete all items below the root node, not counting the root node itself.
    sc = IpConsoleNameSpace()->DeleteItem(pitemRoot->Hscopeitem(), FALSE);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnViewChangeDeleteItems"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Used to delete a single item. If the item is a container, it is deleted from the namespace [NYI]. If it
// is a leaf, it is deleted from the result view.
//
SC CComponent::ScOnViewChangeDeleteSingleItem(CBaseSnapinItem *pitem)
{
    SC                      sc              = S_OK;
    HRESULTITEM itemID      = NULL;

    // Find out the item ID of the data object.
    sc = IpResultData()->FindItemByLParam((LPARAM) pitem, &itemID);
    if (sc)
    {
        // $REVIEW (ptousig) Why are we ignoring errors ?
        sc = S_OK;
        goto Cleanup;
    }

    // Delete it from the result view.
    sc = IpResultData()->DeleteItem(itemID, 0);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnViewChangeDeleteSingleItem"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Pass a view change notification (that we don't have a predefined handler for)
// to the snapin item.
//
SC CComponent::ScOnViewChangeHint(CBaseSnapinItem *pitem, long hint)
{
    SC sc = S_OK;

    ASSERT(pitem);

    sc = pitem->ScOnViewChangeHint(hint, this);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnViewChangeHint"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Inserts a new item into the namespace/result view. Called when the property sheet for a new item is
// dismissed with OK being pressed.
// The PitemParent() of the node being inserted should already be set.
//
SC CComponent::ScOnViewChangeInsertItem(CBaseSnapinItem *pitem)
{
    SC sc = S_OK;

    // $REVIEW (ptousig) Why is the view inserting the item in the document ?
    //                                       Wouldn't that end up getting executed multiple times ?
    sc = PComponentData()->ScOnDocumentChangeInsertItem(pitem);
    if (sc)
        goto Error;

    if (pitem->FIsContainer() == FALSE)      // leaf items need to be added to every view.
    {
        //
        // If the parent of the new item is the currently selected scope item,
        // then add the new item to the result pane.
        //
        ASSERT(pitem->PitemParent());
        if (PitemScopeSelected() == pitem->PitemParent())
            // $REVIEW (ptousig) Why are we ignoring errors ?
            pitem->ScInsertResultItem(this);
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnViewChangeInsertItem"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Used to update an item when properties on it change.
//
SC CComponent::ScOnViewChangeUpdateItem(CBaseSnapinItem *pitem)
{
    SC sc = S_OK;

    // This works as follows. RESULTDATAITEMS are automatically inserted by the MMC for all scope nodes that
    // are in the result pane (ie container nodes.) RESULTDATAITEMS are inserted by the snapin for leaf nodes.
    // So calling ScUpdateResultItem works correctly for all items that are in the result pane, because it first
    // calls IResultData->FindItemByLParam(), and if that succeeded, calls IResultData->UpdateItem().
    sc = pitem->ScUpdateResultItem(IpResultData());
    if (sc == E_FAIL)
        // the item was not updated because it is not in the list anymore
        sc = S_FALSE;
    else if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnViewChangeUpdateItem"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Handles the MMCN_REFRESH notification.
//
SC CComponent::ScOnRefresh(LPDATAOBJECT lpDataObject, HSCOPEITEM hscopeitem)
{
    SC sc = S_OK;
    BOOL fIsOwned = FALSE;
    CNodeType *pnodetype = NULL;
    CBaseSnapinItem *pitem = NULL;
    CBaseSnapinItem *pCurrent = NULL;
    BOOL fWasExpanded = FALSE;

    // Find out which item was asked to refresh
    pitem = Pitem(lpDataObject, hscopeitem);

    // Is this the notification for the owner of the node or for
    // the extension of a node ?
    sc = Psnapin()->ScIsOwnedDataObject(lpDataObject, &fIsOwned, &pnodetype);
    if (sc)
        goto Error;

    if (fIsOwned)
    {
        // If we have never been expanded before, refresh would be pointless.
        sc = PComponentData()->ScWasExpandedOnce(pitem, &fWasExpanded);
        if (sc)
            goto Error;

        if (fWasExpanded == FALSE)
            goto Cleanup;

        // Remove all visible result items before we delete the pitems behind them
        sc = IpConsole()->UpdateAllViews(lpDataObject, 0, ONVIEWCHANGE_DELETERESULTITEMS);
        if (sc)
            goto Error;

        // Delete children pitems
        sc = pitem->ScDeleteSubTree(FALSE);
        if (sc)
            goto Error;

        // Ask the node that was refreshed to update its data
        sc = pitem->ScOnRefresh();
        if (sc)
            goto Error;
        // Most of our snapins reload data on ScOnPropertyChange
        sc = pitem->ScOnPropertyChange();
        if (sc)
            goto Error;

        // Recreate children with fresh data
        sc = PComponentData()->ScOnExpand(pitem->Pdataobject(), TRUE, pitem->Hscopeitem());
        if (sc)
            goto Error;

        // Add result items back to all instances of the refreshed node that are selected
        sc = IpConsole()->UpdateAllViews(lpDataObject, 0, ONVIEWCHANGE_INSERTRESULTITEMS);
        if (sc)
            goto Error;
    }
    else
    {

        // Delete children
        sc = pitem->ScDeleteSubTree(FALSE);
        if (sc)
            goto Error;

        // Update refreshed items data
        sc = pitem->ScOnRefresh();
        if (sc)
            goto Error;
        // Most of our snapins reload data on ScOnPropertyChange
        sc = pitem->ScOnPropertyChange();
        if (sc)
            goto Error;

        // Recreate children with fresh data
        sc = PComponentData()->ScOnExpand(pitem->Pdataobject(), TRUE, pitem->Hscopeitem());
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;

Error:
    TraceError(_T("CComponent::ScOnRefresh"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// $REVIEW (ptousig) I don't know when this is called.
//
SC CComponent::ScOnListPad(LPDATAOBJECT lpDataObject, BOOL fAttach)
{
    SC sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    pitem = Pitem(lpDataObject);
    ASSERT(pitem);

    sc = pitem->ScOnAddImages(IpImageList());
    if (sc)
        goto Error;

    sc = ScOnShow(lpDataObject, fAttach, pitem->Hscopeitem());
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnExpand"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// The user has asked to delete this node.
//
SC CComponent::ScOnDelete(LPDATAOBJECT lpDataObject)
{
    // Declarations
    SC                 sc = S_OK;
    CBaseSnapinItem *  pitem = NULL;
    BOOL               fDeleted = FALSE;
    BOOL               fPagesUp = FALSE;
    tstring            strMsg;
    CBaseMultiSelectSnapinItem * pBaseMultiSelectSnapinItem      = NULL;

    // Data validation
    ASSERT(lpDataObject);

    // Determine if this is a multiselect data object
    sc = CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject(lpDataObject, &pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;

    // If we received a multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        // Call ScOnDelete for the multiselect object
        sc = pBaseMultiSelectSnapinItem->ScOnDelete(this, lpDataObject);
        if (sc)
            goto Error;
    }
    else
    {
        // Handle the normal case - PItem() does more work than a simple cast to verify that the snapin item belongs to the snapin etc.
        pitem = Pitem(lpDataObject);
        ASSERT(pitem);

        // The Component should only receive notifications for result pane items
        ASSERT(pitem->FIsContainer() == FALSE);

        // Check if property pages are open for the object
        // $REVIEW (dominicp) What if another Administrator has property pages open anyways? Not much point in doing this.
        sc = pitem->ScIsPropertySheetOpen(&fPagesUp, dynamic_cast<IComponent *>(this));
        if (sc)
            goto Error;
        if (fPagesUp)
        {
            ASSERT(FALSE && "Add below resource string");
            //strMsg.LoadString(_Module.GetResourceInstance(), idsPropsUpNoDelete);
            strMsg += (*pitem->PstrDisplayName());
            MMCErrorBox(strMsg.data());
            goto Cleanup;
        }

        // Ask the item to delete the underlying object.
        sc = pitem->ScOnDelete(&fDeleted);
        if (sc)
            goto Error;
        if (fDeleted == FALSE)
            // The item did not want to be deleted.
            goto Cleanup;

        // Leaf items need to be deleted from the views.
        sc = IpConsole()->UpdateAllViews(lpDataObject, 0, ONVIEWCHANGE_DELETESINGLEITEM);
        if (sc)
            goto Error;

        // At this point, the item exists only in the tree, if at all.
        // Remove it from the tree.
        pitem->Unlink();
        // Get rid of it for good from the tree of items.
        pitem->Pdataobject()->Release();
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnDelete"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// The user wants context-sensitive help on the given node.
//
SC CComponent::ScOnContextHelp(LPDATAOBJECT lpDataObject)
{
    SC sc = S_OK;
    tstring strHelpTopic;
    CComQIPtr<IDisplayHelp, &IID_IDisplayHelp> ipDisplayHelp;
    LPOLESTR lpolestr = NULL;
    CBaseSnapinItem *pitem = NULL;
    USES_CONVERSION;

    pitem = Pitem(lpDataObject);
    ASSERT(pitem);

    // Get the name of the compiled help file.
    sc = Psnapin()->ScGetHelpTopic(strHelpTopic);
    if (sc)
        goto Error;

    // Ask the item if it wants to handle this.
    sc = pitem->ScOnContextHelp(strHelpTopic);
    if (sc == S_FALSE)
    {
        // The item refused to handle the request. Default behavior
        // is to append the name of the TOC
        strHelpTopic += szHelpFileTOC;
        sc = S_OK;
    }
    if (sc)
        goto Error;

    // Get an interface pointer to IDisplayHelp
    ipDisplayHelp = IpConsole();
    ASSERT(ipDisplayHelp);

    // Allocate an LPOLESTR
    lpolestr = T2OLE((LPTSTR)strHelpTopic.data());

    // Call ShowTopic to bring up MMC help system.
    // MMC will release the LPOLESTR.
    // $REVIEW (ptousig) If MMC fails we don't know if it released the string or not.
    //                                       For now, I assume that they always do because I prefer to leak
    //                                       memory then to cause a GPF.
    sc = ipDisplayHelp->ShowTopic(lpolestr);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnContextHelp"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Toolbar button clicked.
//
SC CComponent::ScOnButtonClick(LPDATAOBJECT lpDataObject, MMC_CONSOLE_VERB mcvVerb)
{
    return S_OK;
}

// -----------------------------------------------------------------------------
// Adds the result view images to the imagelist.
//
SC CComponent::ScOnAddImages(LPDATAOBJECT lpDataObject, IImageList *ipImageList, HSCOPEITEM hscopeitem)
{
    SC sc = S_OK;
    CBaseSnapinItem *pitem = NULL;

    pitem = Pitem(lpDataObject, hscopeitem);
    ASSERT(pitem);

    sc = pitem->ScOnAddImages(ipImageList);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScOnAddImages"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Called when the window of this view is activated. We don't care.
//
SC CComponent::ScOnActivate(LPDATAOBJECT lpDataObject, BOOL fActivate)
{
    return S_OK;
}

// -----------------------------------------------------------------------------
// Adds property pages for the given data object, taking into account the context and also
// whether the data object is for a new object that is being created.
//
SC CComponent::ScCreatePropertyPages(LPPROPERTYSHEETCALLBACK ipPropertySheetCallback, long handle, LPDATAOBJECT lpDataObject)
{
    // Declarations
    SC                                                              sc                                                      = S_OK;
    CBaseSnapinItem *                               pitem                                           = NULL;
    CBaseMultiSelectSnapinItem *    pBaseMultiSelectSnapinItem      = NULL;

    // Data validation
    ASSERT(lpDataObject);
    ASSERT(ipPropertySheetCallback);

    // Determine if this is a multiselect data object
    sc = CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject(lpDataObject, &pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;

    // If we received a multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        // Call ScCreatePropertyPages for the multiselect object
        sc = pBaseMultiSelectSnapinItem->ScCreatePropertyPages(this, ipPropertySheetCallback, handle, lpDataObject);
        if (sc)
            goto Error;
    }
    else
    {
        // Handle the normal case - PItem() does more work than a simple cast to verify that the snapin item belongs to the snapin etc.
        pitem = Pitem(lpDataObject);    // get the correct CSnapinItem object.
        ASSERT(pitem);

        ASSERT(pitem->FIsSnapinManager() == FALSE);

        // Simple version
        sc = pitem->ScCreatePropertyPages(ipPropertySheetCallback);
        if (sc)
            goto Error;

        // Complete version - for snapins that need all information (like Recipients)
        sc = pitem->ScCreatePropertyPages(ipPropertySheetCallback, handle);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScCreatePropertyPages"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Saves per-view information. We don't have any.
//
SC CComponent::ScSave(IStream *pstream, BOOL fClearDirty)
{
    return S_OK;
}


// -----------------------------------------------------------------------------
// Given a dataobject, determines whether or not pages exist.
// Actually, need to return S_OK here in both cases. If no pages exist
// it is CreatePropertyPages that should return S_FALSE. Sad but true.
//
SC CComponent::ScQueryPagesFor(LPDATAOBJECT lpDataObject)
{
    // Declarations
    SC                                                              sc                                                      = S_OK;
    CBaseSnapinItem *                               pitem                                           = NULL;
    CBaseMultiSelectSnapinItem *    pBaseMultiSelectSnapinItem      = NULL;

    // Data validation
    ASSERT(lpDataObject);

    // Determine if this is a multiselect data object
    sc = CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject(lpDataObject, &pBaseMultiSelectSnapinItem);
    if (sc)
        goto Error;

    // If we received a multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        // Call ScQueryPagesFor for the multiselect object
        sc = pBaseMultiSelectSnapinItem->ScQueryPagesFor(this, lpDataObject);
        if (sc)
            goto Error;
    }
    else
    {
        // Handle the normal case - PItem() does more work than a simple cast to verify that the snapin item belongs to the snapin etc.
        pitem = Pitem(lpDataObject);
        ASSERT(pitem);

        sc = pitem->ScQueryPagesFor();
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CComponent::ScQueryPagesFor"), sc);
    goto Cleanup;
}

//+-------------------------------------------------------------------
//
//  Member:      CComponent::ScOnInitOCX
//
//  Synopsis:    MMCN_INITOCX handler
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent::ScOnInitOCX (LPDATAOBJECT lpDataObject, LPUNKNOWN lpOCXUnknown)
{
    DECLARE_SC(sc, _T("CComponent::ScOnInitOCX"));

    CBaseSnapinItem *                               pitem                                           = NULL;
    CBaseMultiSelectSnapinItem *    pBaseMultiSelectSnapinItem      = NULL;

    sc = ScCheckPointers(Psnapin());
    if(sc)
        return E_NOINTERFACE;

    // If snapin has IComponent2 then it created OCX and returned the IUnknown for
    // the OCX using IComponent2::GetResultViewType2. Since it created, it also
    // should initialize the OCX in which case MMC should not send MMCN_INITOCX.
    // The below statement is just in case if MMC sends the notification.
    if(Psnapin()->FSupportsIComponent2())
        return sc;

    // Data validation
    ASSERT(lpDataObject);

    // Determine if this is a multiselect data object
    sc = CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject(lpDataObject, &pBaseMultiSelectSnapinItem);
    if (sc)
        return sc;

    // If we received a multiselect snapin item
    if (pBaseMultiSelectSnapinItem)
    {
        return (sc = E_UNEXPECTED);
    }
    else
    {
        // Handle the normal case - PItem() does more work than a simple cast to verify that the snapin item belongs to the snapin etc.
        pitem = Pitem(lpDataObject);
        ASSERT(pitem);

        sc = pitem->ScInitOCX(lpOCXUnknown, IpConsole());
        if (sc)
            return sc;
    }

    return (sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\lib\basewin.cxx ===
/*
 *      basewin.cxx
 *
 *      Copyright (c) 1998 Microsoft Corporation
 *
 *      Purpose:        Implements the Base Windows classes for Trigger
 *
 *      Owner:          pierrec
 */

#include "headers.hxx"


#include <prsht.h>
#include <process.h>

#ifdef  _DEBUG
CTraceTag       tagAttachDetach(_T("Base"), _T("Attach/Detach"));
CTraceTag       tagFrameProc(_T("Base"), _T("FrProc"));
CTraceTag       tagHelp(_T("{Base}"), _T("Help"));
CTraceTag       tagServiceControl(_T("Base"), _T("ServiceControl"));
CTraceTag       tagProgress(_T("Base"), _T("Progress"));
CTraceTag       tagStartup(_T("BaseWin"), _T("Startup"));
#endif









//              class CBaseFrame

//      Static variables

HINSTANCE                               CBaseFrame::s_hinst                     = NULL;
HINSTANCE                               CBaseFrame::s_hinstPrev         = NULL;
HINSTANCE                               CBaseFrame::s_hinstMailBase;
CBaseFrame *                    CBaseFrame::s_pframe            = NULL;

//tstring                  strFrameClassName(_T("CTriggerFrame"));

CBaseFrame::CBaseFrame()
{
        m_nReturn = 0;
        m_fExit = FALSE;

        m_hicon = NULL;

        SetFrameComponentBits(0);
}





CBaseFrame::~CBaseFrame(void)
{

        s_pframe = NULL;
}




/*
 *      CBaseFrame::DeinitInstance()
 *
 *      Purpose:        Finishes the clean-up & dumps memory leaks.
 */
void CBaseFrame::DeinitInstance()
{
}



LONG CBaseFrame::IdMessageBox(tstring& szMessage, UINT fuStyle)
{
    MMCErrorBox(szMessage.data());
    return 0;
}





// Needed to avoid the compiler warning on SEH & destructors.
void FatalAppExit(SC sc)
{
    MMCErrorBox(sc);
    FatalExit(sc.GetCode());
}


/*
 *      CBaseFrame::OnDestroy()
 *
 *      Purpose:
 *              Exit processing that requires the frame window to still be up
 */
void CBaseFrame::OnDestroy(void)
{
        Detach();
}


DWORD CBaseFrame::DwActiveModeBits(void)
{
        return 0;
}


/*
 *      CBaseFrame::ScInitInstance
 *
 *      Purpose:        Standard Windows InitInstance stuff.
 *
 *      Return value:
 *              sc              error encountered.
 */
SC CBaseFrame::ScInitInstance( void )
{
        SC                      sc;

        return sc;
}



//              class CBaseWindow

/*
 *      Purpose:        Place holder for the virtual destructor.
 */
CBaseWindow::~CBaseWindow(void)
{
        ;
}

void CBaseWindow::Attach(HWND hwnd)
{
        ASSERT(hwnd);

#ifdef _DEBUG
        Trace(tagAttachDetach,
                        _T("Attaching hwnd = %#08lX to this = %#08lX"),
                        hwnd, this);
#endif

        ::SetWindowLong(hwnd, GWL_USERDATA, (LONG) this);
        SetHwnd(hwnd);
}

CBaseWindow * CBaseWindow::Pwin(HWND hwnd)
{
        return (CBaseWindow *) ::GetWindowLong(hwnd, GWL_USERDATA);
}

void CBaseWindow::Detach(void)
{
#ifdef _DEBUG
        Trace(tagAttachDetach,
                        _T("Detaching hwnd = %#08lX from this = %#08lX"),
                        Hwnd(), this);
#endif

        if (Hwnd())
        {
                ::SetWindowLong(Hwnd(), GWL_USERDATA, NULL);
        }
        SetHwnd(NULL);
}


void CBaseWindow::InvalidateWindow(PVOID pv)
{
        ASSERT(pv);
        ASSERT(::IsWindow((HWND) pv));
        ::InvalidateRect((HWND) pv, NULL, FALSE);
}





/*******************************************************************************
*  procedure :  ActiveWaitForObjects
*
*    purpose :  Use MsgWaitForMultipleObjects to wait for signal-state of these
*               objects to change -- but remain alive to process windows messages
*
********************************************************************************/
DWORD   ActiveWaitForObjects (DWORD                             cObjects,
                                                          LPHANDLE                      lphObjects,
                                                          BOOL                          fWaitAll,
                                                          DWORD                         dwTimeout,
                                                          DWORD                         fdwWakeMask)
{
        DWORD   dwWaitResult;
        MSG             msg;

        while (TRUE)
        {
                dwWaitResult = MsgWaitForMultipleObjects (cObjects, lphObjects, fWaitAll, dwTimeout, fdwWakeMask);

                if (dwWaitResult == (WAIT_OBJECT_0 + cObjects))
                {
                        // Process the queued windows messages
                        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                        {
                                TranslateMessage(&msg);
                                DispatchMessage(&msg);
                        }
                }
                else
                        break;
        }

        return(dwWaitResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\lib\snapinabout.cxx ===
/*
 *      SnapinAbout.cxx
 *
 *
 *      Copyright (c) 1998-1999 Microsoft Corporation
 *
 *      PURPOSE:        Defines the CSnapinAbout class.
 *
 *
 *      OWNER:          ptousig
 */

#include <headers.hxx>

CSnapinAbout::CSnapinAbout(CBaseSnapin *psnapin)
{
    SC sc = S_OK;

    m_psnapin = psnapin;

    sc = Psnapin()->ScInitBitmaps();
    if (sc)
        goto Error;

Cleanup:
    return;
Error:
    TraceError(_T("CSnapinAbout::CSnapinAbout"), sc);
    MMCErrorBox(sc);
    goto Cleanup;
}

CSnapinAbout::~CSnapinAbout(void)
{
}

HRESULT CSnapinAbout::GetSnapinDescription(LPOLESTR *lpDescription)
{
    DECLARE_SC(sc,_T("CSnapinAbout::GetSnapinDescription"));
    Trace(tagBaseSnapinISnapinAbout, _T("--> %s::ISnapinAbout::GetSnapinDescription()"), StrSnapinClassName());
    ADMIN_TRY;
    sc=Psnapin()->ScGetSnapinDescription(lpDescription);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinISnapinAbout, _T("<-- %s::ISnapinAbout::GetSnapinDescription is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

HRESULT CSnapinAbout::GetProvider(LPOLESTR * lpName)
{
    DECLARE_SC(sc,_T("CSnapinAbout::GetProvider"));
    Trace(tagBaseSnapinISnapinAbout, _T("--> %s::ISnapinAbout::GetProvider()"), StrSnapinClassName());
    ADMIN_TRY;
    sc=Psnapin()->ScGetProvider(lpName);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinISnapinAbout, _T("<-- %s::ISnapinAbout::GetProvider is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

HRESULT CSnapinAbout::GetSnapinVersion(LPOLESTR *lpVersion)
{
    DECLARE_SC(sc,_T("CSnapinAbout::GetSnapinVersion"));
    Trace(tagBaseSnapinISnapinAbout, _T("--> %s::ISnapinAbout::GetSnapinVersion()"), StrSnapinClassName());
    ADMIN_TRY;
    sc=Psnapin()->ScGetSnapinVersion(lpVersion);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinISnapinAbout, _T("<-- %s::ISnapinAbout::GetSnapinVersion is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

HRESULT CSnapinAbout::GetSnapinImage(HICON *phAppIcon)
{
    DECLARE_SC(sc,_T("CSnapinAbout::GetSnapinImage"));
    Trace(tagBaseSnapinISnapinAbout, _T("--> %s::ISnapinAbout::GetSnapinImage()"), StrSnapinClassName());
    ADMIN_TRY;
    ASSERT(phAppIcon);
    sc=Psnapin()->ScGetSnapinImage(phAppIcon);
    if (sc.ToHr() == S_OK && *phAppIcon == NULL)
        sc=S_FALSE;
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinISnapinAbout, _T("<-- %s::ISnapinAbout::GetSnapinImage is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

HRESULT CSnapinAbout::GetStaticFolderImage(HBITMAP *hSmallImage, HBITMAP *hSmallImageOpen, HBITMAP *hLargeImage, COLORREF *cMask)
{
    DECLARE_SC(sc,_T("CSnapinAbout::GetStaticFolderImage"));
    Trace(tagBaseSnapinISnapinAbout, _T("--> %s::ISnapinAbout::GetStaticFolderImage()"), StrSnapinClassName());
    ADMIN_TRY;
    sc=Psnapin()->ScGetStaticFolderImage(hSmallImage, hSmallImageOpen, hLargeImage, cMask);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinISnapinAbout, _T("<-- %s::ISnapinAbout::GetStaticFolderImage is returning hr=%s"), StrSnapinClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\lib\snapinitem.cxx ===
/*
 *      snapinitem.cxx
 *
 *
 *      Copyright (c) 1998-1999 Microsoft Corporation
 *
 *      PURPOSE:        Defines the CSnapinItem class.
 *
 *
 *      OWNER:          ptousig
 */
#include <headers.hxx>
#include <atlhost.h>

// class CBaseSnapinItem
// -----------------------------------------------------------------------------
CBaseSnapinItem::CBaseSnapinItem()
{
    Trace(tagBaseSnapinItemTracker, _T("0x%08lX: %S: Creation"), this, SzGetSnapinItemClassName());

    m_type                                                  = CCT_UNINITIALIZED;
    m_hscopeitem                                    = 0;
    m_pComponentData                                = NULL;
    m_pitemParent                                   = NULL;
    m_pitemNext                                             = NULL;
    m_pitemPrevious                                 = NULL;
    m_pitemChild                                    = NULL;
    m_fInserted                                             = FALSE;
    m_fIsRoot                                               = FALSE;
    m_fIsGhostRoot                                  = FALSE;
    m_fWasExpanded                                  = FALSE;
}

// -----------------------------------------------------------------------------
// Cleans up the subtree below the item.
//
CBaseSnapinItem::~CBaseSnapinItem()
{
    // Declarations
    SC      sc = S_OK;

    // Do not do anything below if the object is a multiselect data object.
    // We can not call FIsMultiSelectDataObject(). Use another criteria.
    // $REVIEW (dominicp) Is it possible to have a type set to CCT_UNINITIALIZED and not be a multiselect snapin item?
    if (CCT_UNINITIALIZED != m_type)
    {
        Trace(tagBaseSnapinItemTracker, _T("0x%08lX: %S: Destroyed"), this, SzGetSnapinItemClassName());

        sc = ScDeleteSubTree(FALSE);
        if (sc)
            goto Error;

        // Remove the item from the tree.
        Unlink();

        // The Pcookielist is in CBaseSnapin.
        if (Psnapin())
        {
            // Root nodes do not addref the frame and so should not release them.
            if (FIsRoot() == FALSE)
            {
                // Remove the cookie from the list of available cookies.
                Pcookielist()->erase(Cookie());
            }
        }
    }

Cleanup:
    return;
Error:
    sc.Throw ();
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Set the HSCOPEITEM of this node.
//
void CBaseSnapinItem::SetHscopeitem(HSCOPEITEM hscopeitem)
{
    // If we already have a HSCOPEITEM, we don't want it to change.
    ASSERT(m_hscopeitem == 0 || hscopeitem == 0 || m_hscopeitem == hscopeitem);
    m_hscopeitem = hscopeitem;
}

// -----------------------------------------------------------------------------
// This is the CCF_DISPLAY_NAME clipboard format.
//
SC CBaseSnapinItem::ScWriteDisplayName(IStream *pstream)
{
    SC      sc = S_OK;

    ASSERT(PstrDisplayName());

    sc = pstream->Write(PstrDisplayName()->data(), (PstrDisplayName()->length()+1)*sizeof(TCHAR), NULL);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScWriteDisplayName"), sc);
    goto Cleanup;
}

SC CBaseSnapinItem::ScWriteAnsiName(IStream *pStream )
{
    SC      sc = S_OK;

    ASSERT(PstrDisplayName());

    USES_CONVERSION;
    sc = pStream->Write( T2A(PstrDisplayName()->data()), (PstrDisplayName()->length()+1), NULL);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScWriteAnsiName"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Write the Node type's GUID out to a stream in CLSID form.
// This is the CCF_NODETYPE clipboard format.
//
SC CBaseSnapinItem::ScWriteNodeType(IStream *pstream)
{
    return pstream->Write(Pnodetype()->PclsidNodeType(), sizeof(CLSID), NULL);
}

// -----------------------------------------------------------------------------
// Write a unique ID to represent this node. This implementation uses the 'this'
// pointer. A SNodeID is simply a blob prefixed by its length (as a DWORD).
//
SC CBaseSnapinItem::ScWriteNodeID(IStream *pstream)
{
    SC              sc = S_OK;
    CBaseSnapinItem *pitemThis = this;
    DWORD   dwSize = sizeof(pitemThis);

    // Write the size of the data
    sc = pstream->Write(&dwSize, sizeof(dwSize), NULL);
    if (sc)
        goto Error;

    // Write the data itself.
    sc = pstream->Write(&pitemThis, sizeof(pitemThis), NULL);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScWriteNodeID"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Write the Node type's Column Set ID.  We use the node guid
// as a default implementation.
//
SC CBaseSnapinItem::ScWriteColumnSetId(IStream *pstream)
{
    SC              sc              = S_OK;
    DWORD   dwFlags = 0;
    DWORD   dwSize  = sizeof(GUID);

    // write out an MMC  SColumnSetID structure
    sc = pstream->Write(&dwFlags, sizeof(dwFlags), NULL);
    if (sc)
        goto Error;

    sc = pstream->Write(&dwSize, sizeof(dwSize), NULL);
    if (sc)
        goto Error;

    sc = pstream->Write(Pnodetype()->PclsidNodeType(), sizeof(GUID), NULL);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScWriteColumnSetId"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Write the HSCOPEITEM of this node out to a stream.
// This is the CF_EXCHANGE_ADMIN_HSCOPEITEM clipboard format.
//
SC CBaseSnapinItem::ScWriteAdminHscopeitem(IStream *pstream)
{
    return pstream->Write(&m_hscopeitem, sizeof(m_hscopeitem), NULL);
}

// -----------------------------------------------------------------------------
// Write the class ID of the Snapin out to a stream.
// This is the CCF_SNAPIN_CLASSID clipboard format.
//
SC CBaseSnapinItem::ScWriteClsid(IStream *pstream)
{
    return pstream->Write(PclsidSnapin(), sizeof(CLSID), NULL);
}

// -----------------------------------------------------------------------------
// Returns the snapin to which this item belongs.
//
CBaseSnapin *CBaseSnapinItem::Psnapin(void)
{
    return m_pSnapin;
}

// -----------------------------------------------------------------------------
// Get an IConsole interface.
// It is possible that this item is not associated with a ComponentData. We
// cannot ASSERT in this case, because in many situations we don't mind if it's NULL.
// Without an ASSERT, the worst that will happen is that you will hit an AV
// (which would happen in retail builds anyway) and that is as easy to debug as
// an ASSERT.
//
IConsole *CBaseSnapinItem::IpConsole(void)
{
    if (m_pComponentData)
        return m_pComponentData->IpConsole();
    else
        return NULL;
}

// -----------------------------------------------------------------------------
// Get an IPropertySheetProvider interface.
//
IPropertySheetProvider *CBaseSnapinItem::IpPropertySheetProvider(void)
{
    ASSERT(m_pComponentData);
    return m_pComponentData->IpPropertySheetProvider();
}

// -----------------------------------------------------------------------------
// Get the CComponentData that is associated with this node.
//
CComponentData *CBaseSnapinItem::PComponentData(void)
{
    ASSERT(m_pComponentData);
    return m_pComponentData;
}

// -----------------------------------------------------------------------------
// Set the given CComponentData as the "owner" of this node.
//
void CBaseSnapinItem::SetComponentData(CComponentData *pComponentData)
{
    if (pComponentData == NULL)
    {
        // We are being told to forget our owner
        m_pComponentData = NULL;
    }
    else if (pComponentData->FIsRealComponentData())
    {
        // Once the "real" owner is set, it shouldn't be changed.
        ASSERT(m_pComponentData == NULL || m_pComponentData == pComponentData);
        m_pComponentData = pComponentData;
    }
}

// -----------------------------------------------------------------------------
// Is the given item one of the children of this node.
//
BOOL CBaseSnapinItem::FIncludesChild(CBaseSnapinItem *pitem)
{
    CBaseSnapinItem *pitemIter = PitemChild();
    while (pitemIter)
    {
        if (pitemIter == pitem)
            return TRUE;
        pitemIter = pitemIter->PitemNext();
    }
    return FALSE;
}

// -----------------------------------------------------------------------------
// Add a child to this node.
//
SC CBaseSnapinItem::ScAddChild(CBaseSnapinItem *pitem)
{
    SC sc = S_OK;
    CBaseSnapinItem *pitemPrevious = NULL;

    pitemPrevious = PitemChild();
    if (pitemPrevious)
    {
        while (pitemPrevious->PitemNext())
            pitemPrevious = pitemPrevious->PitemNext();
        pitemPrevious->SetNext(pitem);
        pitem->m_pitemParent = this;
        // Successfully inserted.
    }
    else
    {
        // First child item
        SetChild(pitem);
    }

    return sc;
}

// -----------------------------------------------------------------------------
// This node will be used to represent another node (aka Ghost root node).
// We don't own the other node, it might not even be from this DLL, the only
// information we can get about this other node has to come from clipboard
// data from the provided 'lpDataObject'.
//
SC CBaseSnapinItem::ScInitializeNamespaceExtension(LPDATAOBJECT lpDataObject, HSCOPEITEM item, CNodeType *pnodetype)
{
    return S_OK;
}

// -----------------------------------------------------------------------------
// Called to ask this node to create its children.
//
SC CBaseSnapinItem::ScCreateChildren(void)
{
    return S_OK;
}

// -----------------------------------------------------------------------------
// Removes an item from the linked list. Links up the previous and next items,
// if any. If this is the first item in the list, set the parent's child pointer
// to the next item (if it exists.)
//
void CBaseSnapinItem::Unlink()
{
    // Make sure that this item has no children. Wouldn't know what to do with them.
    ASSERT(PitemChild() == NULL);

    // A real clear way of checking all cases: 8 in all.
    if (PitemPrevious())
    {
        if (PitemParent())
        {
            if (PitemNext())                                                         // PitemPrevious() && PitemParent() && PitemNext()
                PitemPrevious()->SetNext(PitemNext());
            else                                                                            // PitemPrevious() && PitemParent() && !PitemNext()
                PitemPrevious()->SetNext(NULL);
        }
        else                                                                                    // !PitemParent()
        {
            if (PitemNext())                                                         // PitemPrevious() && !PitemParent() && PitemNext()
                PitemPrevious()->SetNext(PitemNext());
            else                                                                            // PitemPrevious() && !PitemParent() && !PitemNext()
                PitemPrevious()->SetNext(NULL);
        }
    }
    else                                                                                            // !PitemPrevious()     - this is the first item in the list.
    {
        if (PitemParent())
        {
            if (PitemNext())                                                         // !PitemPrevious() && PitemParent() && PitemNext()
            {
                PitemParent()->SetChild(PitemNext());
                PitemNext()->SetPrevious(NULL);
            }
            else                                                                            // !PitemPrevious() && PitemParent() && !PitemNext()
            {
                // Set the Parent's Child pointer to NULL if we are the (only) child of the parent.
                if (PitemParent()->PitemChild() == static_cast<CBaseSnapinItem*>(this))
                    PitemParent()->SetChild(NULL);
            }
        }
        else                                                                                    // !PitemParent()
        {
            if (PitemNext())                                                         // !PitemPrevious() && !PitemParent() && PitemNext()
                PitemNext()->SetPrevious(NULL);
            else                                                                            // !PitemPrevious() && !PitemParent() && !PitemNext()
                ;                                                                               // do nothing - already an orphan.
        }
    }

    // Clear all the link pointers.
    SetNext(NULL);
    SetPrevious(NULL);
    // Can't use SetParent() because it ASSERTs.
    m_pitemParent = NULL;
}

// -----------------------------------------------------------------------------
// Initializes the snapinitem.
//
// The 'pcolinfoex' and 'ccolinfoex' are no longer used. The derived class is
// now responsible for maintaining per-item column information. The default
// implementation of the accessors will get the column information from the
// CBaseSnapin-derived class.
//
SC CBaseSnapinItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    SC      sc                      = S_OK;
    m_pSnapin               = pSnapin;
    m_fIsRoot               = fIsRoot;
    // Add the cookie to the list of available cookies.
    pSnapin->Pcookielist()->insert(Cookie());

    return sc;
}

// -----------------------------------------------------------------------------
// Initializes a child item.
//
SC CBaseSnapinItem::ScInitializeChild(CBaseSnapinItem* pitem)
{
    return pitem->ScInit(Psnapin(), NULL, 0);
}


// -----------------------------------------------------------------------------
// Information obtained from Psnapin().
//
const tstring&  CBaseSnapinItem::StrClassName(void)             { return Psnapin()->StrClassName();}
const CLSID *   CBaseSnapinItem::PclsidSnapin(void)             { return Psnapin()->PclsidSnapin();}
const tstring&  CBaseSnapinItem::StrClsidSnapin(void)           { return Psnapin()->StrClsidSnapin();}
WTL::CBitmap*   CBaseSnapinItem::PbitmapImageListSmall(void)    { return Psnapin()->PbitmapImageListSmall();}
WTL::CBitmap*   CBaseSnapinItem::PbitmapImageListLarge(void)    { return Psnapin()->PbitmapImageListLarge();}
CCookieList *   CBaseSnapinItem::Pcookielist(void)              { return Psnapin()->Pcookielist();}

// -----------------------------------------------------------------------------
// Deletes the entire subtree rooted at this node, thereby freeing up all the cookies.
// If fDeleteRoot is TRUE we need to delete the root node as well.
//
SC CBaseSnapinItem::ScDeleteSubTree(BOOL fDeleteRoot)
{
    SC                                      sc                      = S_OK;
    CBaseSnapinItem *       pitem           = PitemChild();
    CBaseSnapinItem *       pitemNext       = NULL;

    while (pitem)
    {
        // We are about to delete 'pitem', keep a pointer to the next one.
        pitemNext = pitem->PitemNext();

        // Delete the entire subtree including the root node.
        sc = pitem->ScDeleteSubTree(TRUE);
        if (sc)
            goto Error;

        pitem = pitemNext;
    }

    // We don't have any children left.
    m_pitemChild = NULL;
    m_fWasExpanded = FALSE;

    // if we have not removed the scope item, do it now

    if (fDeleteRoot)
    {
        if (m_hscopeitem)
        {
            sc = PComponentData()->IpConsoleNameSpace()->DeleteItem(m_hscopeitem, TRUE);
            if (sc)
                goto Error;
        }

        Unlink();
        // Since we are no longer known by MMC we have to forget our HSCOPEITEM
        // so that it doesn't get mis-used. This can happen if you refresh a parent
        // of a node that has properties open.
        m_hscopeitem = 0;
        static_cast<IDataObject *>(this)->Release();
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScDeleteSubTree"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Get the root of this item tree.
//
CBaseSnapinItem *CBaseSnapinItem::PitemRoot(void)
{
    if (m_pitemParent)
        return m_pitemParent->PitemRoot();
    else
        return this;
}

// -----------------------------------------------------------------------------
// We are the data object. We just return a pointer to the IDataObject of
// ourselves.
//
SC CBaseSnapinItem::ScQueryDataObject(long cookie, DATA_OBJECT_TYPES type, LPDATAOBJECT* ppDataObject)
{
    SC sc = S_OK;

    //
    // The item will remember what type it is at the moment.
    //
    m_type = type;

    //
    // This seems like a very twisted way of getting a pointer to ourselves,
    // but it is actualy because we want to make sure we play within ATL rules.
    // In a way, QueryDataObject is the same thing as a QueryInterface.
    //
    sc = static_cast<IDataObject *>(this)->QueryInterface(IID_IDataObject, reinterpret_cast<void**>(ppDataObject));
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScQueryDataObject"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Handles the MMCN_SHOW notification. Initializes the default result view headers.
//
SC CBaseSnapinItem::ScOnShow(CComponent *pComponent, BOOL fSelect)
{
    SC sc = S_OK;

    ASSERT(pComponent);

    if (fSelect)
    {
        sc = ScInitializeResultView(pComponent);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScOnShow"), sc);
    goto Cleanup;

}

// -----------------------------------------------------------------------------
// Called during the  MMCN_EXPAND notification sent to IComponentData::Notify. Inserts
// the current item into the scope pane (if it is a container item) using IConsoleNameSpace
// methods. If fExpand is FALSE, don't do anything.
// Chains all sibling items.
//
SC CBaseSnapinItem::ScInsertScopeItem(CComponentData *pComponentData, BOOL fExpand, HSCOPEITEM item)
{
    SC                                      sc              = S_OK;
    CBaseSnapinItem*        pitem   = this;
    SCOPEDATAITEM           scopedataitem;

    if (fExpand == FALSE)
        goto Cleanup;

    while (pitem)
    {
        // Only add container items.
        if (pitem->FIsContainer())
        {
            pitem->SetComponentData(pComponentData);

            ZeroMemory(&scopedataitem, sizeof(SCOPEDATAITEM));
            scopedataitem.lParam            = pitem->Cookie();
            scopedataitem.mask              = SDI_STR | SDI_PARAM | SDI_PARENT | SDI_CHILDREN;
            if (pitem->Iconid() != iconNil)
                scopedataitem.mask |= SDI_IMAGE;
            if (pitem->OpenIconid() != iconNil)
                scopedataitem.mask |= SDI_OPENIMAGE;

            // Callback for the display name.
            // $REVIEW (ptousig) Why don't we take advantage of the displayname ?
            //                                       Callbacks can be pretty inefficient.

            scopedataitem.displayname       = MMC_CALLBACK;
            scopedataitem.nImage            = pitem->Iconid();
            scopedataitem.nOpenImage        = pitem->OpenIconid();
            scopedataitem.relativeID        = item;
            // If there are no children, MMC will suppress the "+" sign
            scopedataitem.cChildren         = pitem->FHasChildren() ? 1 : 0;

            ASSERT(pComponentData);
            sc = pComponentData->IpConsoleNameSpace()->InsertItem(&scopedataitem);
            if (sc)
                goto Error;

            pitem->SetHscopeitem(scopedataitem.ID);
        }

        pitem = pitem->PitemNext();
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScInsertScopeItem"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Inserts all child items into the default result list view.
//
SC CBaseSnapinItem::ScInsertResultItem(CComponent *pComponent)
{
    SC                              sc = S_OK;
    RESULTDATAITEM  resultdataitem;

    ASSERT(pComponent && pComponent->IpResultData());

    // Add this item
    ZeroMemory(&resultdataitem, sizeof(resultdataitem));

    resultdataitem.lParam   = Cookie();
    resultdataitem.mask             = RDI_STR | RDI_PARAM | RDI_IMAGE;
    // Callback for the display name.
    resultdataitem.str              = MMC_CALLBACK;
    // Custom icon
    resultdataitem.nImage   = (int) MMC_CALLBACK;

    sc = pComponent->IpResultData()->InsertItem(&resultdataitem);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScInsertResultItem"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Asks MMC to update the display of this item in the result pane.
//
SC CBaseSnapinItem::ScUpdateResultItem(IResultData *ipResultData)
{
    DECLARE_SC(sc, _T("CBaseSnapinItem::ScUpdateResultItem"));
    HRESULTITEM             item    = NULL;

    ASSERT(ipResultData);
    sc = ipResultData->FindItemByLParam(Cookie(), &item);
    if (sc)
        return (sc);

    // If not found, does not exist in this view. Ignore.
    if (!item)
        return (sc);

    // $REVIEW (ptousig) Why are we ignoring errors ?
    ipResultData->UpdateItem(item);

    return sc;
}

// -----------------------------------------------------------------------------
// Asks MMC to update the display of this item in the scope pane.
//
SC CBaseSnapinItem::ScUpdateScopeItem(IConsoleNameSpace *ipConsoleNameSpace)
{
    SC                              sc              = S_OK;
    SCOPEDATAITEM   scopedataitem;

    ASSERT(FIsContainer());

    //
    // If this item doesn't have a HSCOPEITEM, then it is not known by MMC
    // therefore we would get an "invalid arg" error from the call to SetItem.
    //
    if (Hscopeitem() == 0)
        goto Cleanup;

    ZeroMemory(&scopedataitem, sizeof(SCOPEDATAITEM));
    scopedataitem.ID                        = Hscopeitem();
    scopedataitem.lParam            = Cookie();
    scopedataitem.mask                      = SDI_PARAM;

    if (Iconid() != iconNil)
    {
        scopedataitem.mask              |= SDI_IMAGE;
        ASSERT(FALSE && "Bitmap");
        //scopedataitem.nImage    = PbitmapImageListSmall()->GetIndex(Iconid());
    }

    if (OpenIconid() != iconNil)
    {
        scopedataitem.mask                      |= SDI_OPENIMAGE;
        ASSERT(FALSE && "Bitmap");
        //scopedataitem.nOpenImage        = PbitmapImageListSmall()->GetIndex(OpenIconid());
    }

    ASSERT(ipConsoleNameSpace);
    sc = ipConsoleNameSpace->SetItem(&scopedataitem);
    if (sc)
        goto Error;

    // Send a notification to update the result pane description bar.
    IpConsole()->UpdateAllViews(Pdataobject(), 0, ONVIEWCHANGE_UPDATEDESCRIPTIONBAR);

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScUpdateScopeItem"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// This is where we should tell MMC to remove all the items in the result pane.
//
// $REVIEW (ptousig) Why aren't we doing anything ?
//
SC CBaseSnapinItem::ScRemoveResultItems(LPRESULTDATA ipResultData)
{
    return S_OK;
}


// -----------------------------------------------------------------------------
// Provides (to MMC) the display string (or icon) for a given node in the
// scope pane.
//
SC CBaseSnapinItem::ScGetDisplayInfo(LPSCOPEDATAITEM pScopeItem)
{
    SC sc = S_OK;

#ifdef _DEBUG
    static tstring str;
#endif

    ASSERT(pScopeItem);

    if (pScopeItem->mask & SDI_STR)
    {
        pScopeItem->displayname = (LPTSTR)PstrDisplayName()->data();
#ifdef _DEBUG
        if (tagBaseSnapinDebugDisplay.FAny())
        {
            USES_CONVERSION;
            str  = OLE2T(pScopeItem->displayname);
            str += A2T(SzGetSnapinItemClassName());
//            str += this;
//            str += Hscopeitem();
            pScopeItem->displayname = T2OLE((LPTSTR)str.data());
        }
#endif
    }

    if (pScopeItem->mask & SDI_IMAGE)
    {
        ASSERT(FALSE && "Bitmap");
        //pScopeItem->nImage = PbitmapImageListSmall()->GetIndex(Iconid());
    }

    return sc;
}

// -----------------------------------------------------------------------------
// Provides (to MMC) the display string (or icon) for a given node in the
// result pane.
//
SC CBaseSnapinItem::ScGetDisplayInfo(LPRESULTDATAITEM pResultItem)
{
    DECLARE_SC(sc, _T("CBaseSnapinItem::ScGetDisplayInfo"));
    static  tstring s_sz;

    ASSERT(pResultItem);

    if (pResultItem->mask & RDI_STR)
    {
        // Need to do this explicitly because the same buffer is reused.
        pResultItem->str = (LPTSTR)s_sz.data();

        // "Old" snapins might be referring to columns that don't exist.
        if (pResultItem->nCol < CcolinfoexDisplay())
        {
            Trace(tagBaseSnapinItemTracker, _T("Requesting field data - requested DAT is %d"), PcolinfoexDisplay(pResultItem->nCol)->Dat());
            sc= ScGetField( PcolinfoexDisplay(pResultItem->nCol)->Dat(), s_sz);
            if (sc)
                return sc;


#ifdef _DEBUG
            if (pResultItem->nCol == 0 && tagBaseSnapinDebugDisplay.FAny())
            {
                s_sz  = pResultItem->str;
//                s_sz += this;
            }
#endif

            USES_CONVERSION;
            pResultItem->str = T2OLE((LPTSTR)s_sz.data());
        }
    }

    if (pResultItem->mask & RDI_IMAGE)       // $REVIEW for extension snapins.
    {
        pResultItem->nImage = Iconid();
    }

    return sc;
}

// -----------------------------------------------------------------------------
// Fills in result pane item information needed by MMC.  This
// method is used when the results pane is in virtual list mode
// and we will be asking for data by index.
//
SC CBaseSnapinItem::ScGetVirtualDisplayInfo(LPRESULTDATAITEM pResultItem, IResultData *ipResultData)
{
    DECLARE_SC(sc, _T("CBaseSnapinItem::ScGetDisplayInfo"));
    static  tstring s_sz; //$REVIEW

    ASSERT(FVirtualResultsPane() && pResultItem);

    if (pResultItem->mask & RDI_STR)
    {
        sc= ScGetField(pResultItem->nIndex, PcolinfoexDisplay(pResultItem->nCol)->Dat(), s_sz, ipResultData);
        if (sc)
            return sc;
        pResultItem->str = (LPTSTR)s_sz.data();
    }

    if (pResultItem->mask & RDI_IMAGE)       // $REVIEW for extension snapins.
    {
        pResultItem->nImage = Iconid();
    }

    return sc;
}

// -----------------------------------------------------------------------------
// Returns the default icon ID : Folder
//
LONG CBaseSnapinItem::Iconid(void)
{
    ASSERT(FALSE);
    return 0;
}

// -----------------------------------------------------------------------------
// Returns the default open icon ID : Handles open folder / open RO folder / custom
//
LONG CBaseSnapinItem::OpenIconid(void)
{
    ASSERT(FALSE);
    return 0;
}

// -----------------------------------------------------------------------------
// Initializes the result view. This implementation requires a column info
// structure, and creates the default set of columns.
//
SC CBaseSnapinItem::ScInitializeResultView(CComponent *pComponent)
{
    SC              sc = S_OK;
    INT             i  = 0;

    ASSERT(pComponent && pComponent->IpHeaderCtrl());

    // Remove any old column headers (on refresh / view change)
    while (!sc)
        sc = pComponent->IpHeaderCtrl()->DeleteColumn(0);
    sc = S_OK;

    for (i = 0; i < CcolinfoexHeaders(); i++)
    {
        Trace(tagBaseSnapinItemTracker, _T("Inserting column with title %s"), PcolinfoexHeaders(i)->strTitle().data());
        sc = pComponent->IpHeaderCtrl()->InsertColumn(i,
                                                      PcolinfoexHeaders(i)->strTitle().data(),
                                                      PcolinfoexHeaders(i)->NFormat(),
                                                      PcolinfoexHeaders(i)->NWidth());
        // Will get fail if items are already in result pane.  This is not an error, happens on refresh.
        // $REVIEW (ptousig) Maybe we should remove the items before re-initializing the columns.
        if (sc.ToHr() == E_FAIL)
            sc = S_OK;

        if (sc)
            goto Error;
    }
    // remove the NOSORTHEADER option - by default all items will have push-button header controls
    sc = pComponent->IpResultData()->ModifyViewStyle((MMC_RESULT_VIEW_STYLE)0, MMC_NOSORTHEADER);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScInitializeResultView"), sc);
    goto Cleanup;

}

// -----------------------------------------------------------------------------
// MMC wants to know the image strip that should be used for the result pane.
//
SC CBaseSnapinItem::ScOnAddImages(IImageList* ipResultImageList)
{
    SC              sc = S_OK;

    ASSERT(ipResultImageList);

    sc = ipResultImageList->ImageListSetStrip(
        reinterpret_cast<long*>(static_cast<HBITMAP>(*PbitmapImageListSmall())),
        reinterpret_cast<long*>(static_cast<HBITMAP>(*PbitmapImageListLarge())),
        0, RGB(255, 0, 255));
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScOnAddImages"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Cause this node to refresh itself.
//
// WARNING: The "flicker" effect of this call is very annoying to look at. Do
//                      not use this as a "silver bullet" solution. If you are adding,
//                      removing or updating a child then use the appropriate ONVIEWCHANGE_*
//                      notification.
//
SC CBaseSnapinItem::ScRefreshNode(void)
{
    SC sc = S_OK;

    sc = IpConsole()->UpdateAllViews(this, 0, ONVIEWCHANGE_REFRESHCHILDREN);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScRefreshNode"), sc);
    goto Cleanup;
}


// -----------------------------------------------------------------------------
// MMC is asking us the type of result pane we want
//
SC CBaseSnapinItem::ScGetResultViewType(LPOLESTR *ppViewType, long *pViewOptions)
{
    DECLARE_SC(sc, TEXT("CBaseSnapinItem::ScGetResultViewType"));
    // Validate parameters
    ASSERT(ppViewType);
    ASSERT(pViewOptions);

    if ( FResultPaneIsOCX())
    {
        tstring strclsidOCX;
        sc = ScGetOCXCLSID(strclsidOCX);
        if (sc == S_FALSE) // default to listview.
            return sc;

        *ppViewType = (LPOLESTR)CoTaskMemAlloc( (strclsidOCX.length()+1) * sizeof(WCHAR));

        USES_CONVERSION;
        wcscpy(*ppViewType, T2COLE(strclsidOCX.data()));

        return sc;
    }

    if (FResultPaneIsWeb())
    {
        tstring strURL;
        sc = ScGetWebURL(strURL);
        if (sc == S_FALSE) // default to listview.
            return sc;

        *ppViewType = (LPOLESTR)CoTaskMemAlloc( (strURL.length()+1) * sizeof(WCHAR));

        USES_CONVERSION;
        wcscpy(*ppViewType, T2COLE(strURL.data()));

        return sc;
    }

    // Set the default
    *pViewOptions = MMC_VIEW_OPTIONS_NONE;

    // Check if we are displaying a virtual result pane list
    if (FVirtualResultsPane())
        // Ask for owner data listview (virtual list box mode).
        *pViewOptions = MMC_VIEW_OPTIONS_OWNERDATALIST;

    // Check if we should enable multiselect
    if (FAllowMultiSelectionForChildren())
        *pViewOptions = *pViewOptions | MMC_VIEW_OPTIONS_MULTISELECT;

    //
    // Return S_FALSE to indicate we want the standard result view.
    //
    return S_FALSE;
}

// -----------------------------------------------------------------------------
// MMC is asking us the type of result pane we want using IComponent2
//
SC CBaseSnapinItem::ScGetResultViewType2(IConsole *pConsole, PRESULT_VIEW_TYPE_INFO pResultViewType)
{
    DECLARE_SC(sc, _T("CBaseSnapinItem::ScGetResultViewType2"));

    // Validate parameters
    ASSERT(pResultViewType);
    ASSERT(PstrDisplayName());

    LPOLESTR pszViewDesc = (LPOLESTR)CoTaskMemAlloc((PstrDisplayName()->length()+1) * sizeof(WCHAR));
    if (! pszViewDesc)
        return (sc = E_OUTOFMEMORY);

    USES_CONVERSION;
    wcscpy(pszViewDesc, T2COLE(PstrDisplayName()->data()));
    pResultViewType->pstrPersistableViewDescription = pszViewDesc;

    if ( FResultPaneIsOCX())
    {
        tstring strclsidOCX;
        sc = ScGetOCXCLSID(strclsidOCX);
        if (sc == S_FALSE) // default to listview.
            return sc;

        pResultViewType->eViewType = MMC_VIEW_TYPE_OCX;
        pResultViewType->dwOCXOptions = RVTI_OCX_OPTIONS_NOLISTVIEW;

        pResultViewType->pUnkControl = NULL;

        if (FCacheOCX())
        {
            pResultViewType->dwOCXOptions = RVTI_OCX_OPTIONS_CACHE_OCX;
            pResultViewType->pUnkControl = GetCachedOCX(pConsole);
        }

        CComQIPtr<IConsole2> spConsole2(pConsole);

        if (! pResultViewType->pUnkControl)
        {
            CLSID clsidOCX;

            USES_CONVERSION;
            sc = CLSIDFromString(T2OLE(const_cast<LPTSTR>(strclsidOCX.data())), &clsidOCX);
            if (sc)
                return sc;

            LPUNKNOWN pUnkControl = NULL;
            sc = CoCreateInstance(clsidOCX, NULL, CLSCTX_SERVER, IID_IUnknown, (LPVOID*)&pUnkControl);
            if (sc)
                return sc;

            sc = ScInitOCX(pUnkControl, pConsole);

            pResultViewType->pUnkControl = pUnkControl;

            if (spConsole2)
            {
                tstring strStatusText = L"OCX: ";
                strStatusText += strclsidOCX;
                strStatusText += L" Created";
                spConsole2->SetStatusText(const_cast<LPOLESTR>(T2COLE(strStatusText.data())));
            }
        }
        else
        {
            pResultViewType->pUnkControl->AddRef();
            if (spConsole2)
            {
                tstring strStatusText = L"OCX: ";
                strStatusText += strclsidOCX;
                strStatusText += L" cached is used";
                spConsole2->SetStatusText(const_cast<LPOLESTR>(T2COLE(strStatusText.data())));
            }
        }

        return sc;
    }

    if (FResultPaneIsWeb())
    {
        tstring strURL = TEXT("msw");
        sc = ScGetWebURL(strURL);
        if (sc == S_FALSE) // default to listview.
            return sc;

        pResultViewType->eViewType = MMC_VIEW_TYPE_HTML;
        pResultViewType->dwHTMLOptions = RVTI_HTML_OPTIONS_NONE | RVTI_HTML_OPTIONS_NOLISTVIEW;
        LPOLESTR lpszURL = (LPOLESTR)CoTaskMemAlloc( (strURL.length()+1) * sizeof(WCHAR));

        USES_CONVERSION;
        wcscpy(lpszURL, T2COLE(strURL.data()));

        pResultViewType->pstrURL = lpszURL;

        return sc;
    }

    // Set the default
    pResultViewType->dwMiscOptions = RVTI_LIST_OPTIONS_NONE;

    // Check if we are displaying a virtual result pane list
    if (FVirtualResultsPane())
        // Ask for owner data listview (virtual list box mode).
        pResultViewType->dwListOptions = RVTI_LIST_OPTIONS_OWNERDATALIST;

    // Check if we should enable multiselect
    if (FAllowMultiSelectionForChildren())
        pResultViewType->dwListOptions |= RVTI_LIST_OPTIONS_MULTISELECT;

    if (FAllowPasteForResultItems())
        pResultViewType->dwListOptions |= RVTI_LIST_OPTIONS_ALLOWPASTE;

    //
    // Return S_FALSE to indicate we want the standard result view.
    //
    return S_FALSE;
}

// -----------------------------------------------------------------------------
// MMC is trying to restore the view, see if it is our view description.
//
SC CBaseSnapinItem::ScRestoreResultView(PRESULT_VIEW_TYPE_INFO pResultViewType)
{
    DECLARE_SC(sc, _T("CBaseSnapinItem::ScRestoreResultView"));

    // Validate parameters
    ASSERT(pResultViewType);
    ASSERT(pResultViewType->pstrPersistableViewDescription);
    ASSERT(PstrDisplayName());

    LPOLESTR pszViewDesc = pResultViewType->pstrPersistableViewDescription;
    if (! pszViewDesc)
        return (sc = E_OUTOFMEMORY);

    USES_CONVERSION;
    if ( 0 != wcscmp(pszViewDesc, T2COLE(PstrDisplayName()->data())) )
        return (sc = S_FALSE);

    if (! pResultViewType->dwMiscOptions & RVTI_LIST_OPTIONS_NONE)
        return (sc = S_FALSE);

    // Check if we are displaying a virtual result pane list
    if (FVirtualResultsPane())
    {
        if (! (pResultViewType->dwListOptions & RVTI_LIST_OPTIONS_OWNERDATALIST))
            return (sc = S_FALSE);
    }

    // Check if we should enable multiselect
    if (FAllowMultiSelectionForChildren())
    {
        if (! (pResultViewType->dwListOptions & RVTI_LIST_OPTIONS_MULTISELECT) )
            return (sc = S_FALSE);
    }

    // Check if result pane items allow paste.
    if (FAllowPasteForResultItems())
    {
        if (! (pResultViewType->dwListOptions & RVTI_LIST_OPTIONS_ALLOWPASTE) )
            return (sc = S_FALSE);
    }

    return S_OK;
}

// -----------------------------------------------------------------------------
// Used to create a property sheet for an item. This uses MMC trickery to
// display property pages on an object that has not yet been added to the MMC
// result view.
//
SC CBaseSnapinItem::ScDisplayPropertySheet(void)
{
    SC                              sc                      = S_OK;
    IPropertySheetCallbackPtr       ipPropertySheetCallback;
    // If fCleanup == TRUE, we need to call Show(-1, 0) on an error.
    BOOL                            fCleanup        = FALSE;
    TCHAR                           strTitle[256];
    CComPtr<IUnknown>               spIUnknown;

    // Get a pointer to the IPropertySheetProvider interface.
    ipPropertySheetCallback = IpPropertySheetProvider();
    ASSERT(NULL != ipPropertySheetCallback);

    // Create the property pages for this object.
    // TRUE for property sheet, not wizard
    sc = IpPropertySheetProvider()->CreatePropertySheet(strTitle, TRUE, Cookie(), Pdataobject(), 0);
    if (sc)
        goto Error;

    // If failure occurs after a successful call to CreatePropertySheet, need to call Show(-1,0). See MMC docs.
    fCleanup = TRUE;

    sc = ((IComponentData *)PComponentData())->QueryInterface(IID_IUnknown, (void **)&spIUnknown);
    if (sc)
        goto Error;

    // Add the primary pages for the object.
    sc = IpPropertySheetProvider()->AddPrimaryPages(spIUnknown, TRUE, NULL, TRUE);
    if (sc)
        goto Error;

    //$REVIEW (ptousig) Why is this commented out ?
    //sc = IpPropertySheetProvider()->AddExtensionPages();
    if (sc)
        goto Error;

    sc = IpPropertySheetProvider()->Show((long) GetActiveWindow(), 0);
    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    // If failure occurs after a successful call to CreatePropertySheet, need to call Show(-1,0). See MMC docs.
    if (fCleanup)
        IpPropertySheetProvider()->Show(-1, 0);
    TraceError(_T("CBaseSnapinItem::ScDisplayPropertySheet"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
void CBaseSnapinItem::SetParent(CBaseSnapinItem *pitemParent)
{
    ASSERT(pitemParent);
    m_pitemParent = pitemParent;
}

// -----------------------------------------------------------------------------
void CBaseSnapinItem::SetNext(CBaseSnapinItem *pitemNext)
{
    m_pitemNext = pitemNext;
    if (pitemNext)
        pitemNext->m_pitemPrevious = this;
}

// -----------------------------------------------------------------------------
void CBaseSnapinItem::SetPrevious(CBaseSnapinItem *pitemPrevious)
{
    m_pitemPrevious = pitemPrevious;
    if (pitemPrevious)
        pitemPrevious->m_pitemNext = this;
}

// -----------------------------------------------------------------------------
void CBaseSnapinItem::SetChild(CBaseSnapinItem *pitemChild)
{
    m_pitemChild = pitemChild;
    if (pitemChild)
        pitemChild->m_pitemParent = this;
}

// -----------------------------------------------------------------------------
// A context menu option was selected.
//
SC CBaseSnapinItem::ScCommand(long nCommandID, CComponent *pComponent)
{
    SC sc = S_OK;

    switch (nCommandID)
    {
    case IDS_Test:
        break;
#if 0
    case idmBarfTraces:
        sc = Psnapin()->ScOnMenuTraces();
        break;

    case idmBarfClearDbgScreen:
        Trace(tagAlways, _T("\x1B[2J"));
        break;

    case idmBarfSCDescription:
        sc = Psnapin()->ScOnMenuSCDescription();
        break;

    case idmBarfSettings:
        DoBarfDialog();
        break;

    case idmBarfAll:
        BarfAll();
        break;


    case idmBarfMemoryDiff:
        sc = Psnapin()->ScOnMenuMemoryDiff();
        break;

    case idmBarfValidateMemory:
        sc = Psnapin()->ScOnMenuMemoryDiff();
        break;

    case idmBarfTotalMemAllocd:
        sc = Psnapin()->ScOnMenuTotalMemory();
        break;

    case idmBarfDebugBreak:
        DebugBreak();
        break;
#endif

    default:
        break;
    }

    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScCommand"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Determines whether any property pages are open on this item. As a side-effect
// if any property sheet is found, it will be given focus. MMC does that by
// itself, we don't have any way of stopping it.
// If the item is a result pane item, we must provide an IComponent to MMC, this
// is the component that will receive then CompareObjects call. In our
// implementation, we don't care which IComponent does the comparison, so pass
// in any IComponent you can get your hands on.
//
SC CBaseSnapinItem::ScIsPropertySheetOpen(BOOL *pfPagesUp, IComponent *ipComponent)
{
    SC sc = S_OK;

    ASSERT(pfPagesUp);

    *pfPagesUp = FALSE;

    if (FIsContainer())
    {
        // Scope pane nodes are owned by the MMC.
        // Note: MMC docs says first parameter is the cookie. It is in fact the HSCOPEITEM.
        sc = IpPropertySheetProvider()->FindPropertySheet(Hscopeitem(), NULL, Pdataobject());
        if (sc)
            goto Error;
    }
    else
    {
        // Result pane nodes are owned by the IComponent.
        ASSERT(ipComponent);

        sc = IpPropertySheetProvider()->FindPropertySheet(Cookie(), ipComponent, Pdataobject());
        if (sc)
            goto Error;
    }

    if (sc == S_FALSE)
        *pfPagesUp = FALSE;
    else if (sc == S_OK)
        *pfPagesUp = TRUE;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseSnapinItem::ScIsPropertySheetOpen"), sc);
    goto Cleanup;
}

// =============================================================================
// Class CBaseMultiSelectSnapinItem
// =============================================================================

UINT CBaseMultiSelectSnapinItem::s_cfMultiSelectSnapins         = RegisterClipboardFormat(CCF_MULTI_SELECT_SNAPINS);                    // Multiselect - list of multi select snapin items in a composite data object
UINT CBaseMultiSelectSnapinItem::s_cfCompositeDataObject        = RegisterClipboardFormat(CCF_MMC_MULTISELECT_DATAOBJECT);              // Multi select - used to determine if an object is a composite data object

// -----------------------------------------------------------------------------
// Constructor for CBaseMultiSelectSnapinItem
// -----------------------------------------------------------------------------
CBaseMultiSelectSnapinItem::CBaseMultiSelectSnapinItem() : CBaseSnapinItem()
{
    // Remember we created a multiselect snapin item
    Trace(tagBaseMultiSelectSnapinItemTracker, _T("0x%08lX: Creation"), this);

    // By default, a multiselect object is not involved in copy/paste operations
    // Set the pointer to an array indicating the pasted items to NULL
    m_pfPastedWithCut = NULL;
}

// -----------------------------------------------------------------------------
// Destructor for CBaseMultiSelectSnapinItem
// -----------------------------------------------------------------------------
CBaseMultiSelectSnapinItem::~CBaseMultiSelectSnapinItem()
{
    // Delete the array indicating the pasted items (if any was allocated)
    if (m_pfPastedWithCut)
    {
        delete [] m_pfPastedWithCut;
        m_pfPastedWithCut = NULL;
    }
}

/* CBaseMultiSelectSnapinItem::ScWriteMultiSelectionItemTypes
 *
 * PURPOSE:                     Implement the CCF_OBJECT_TYPES_IN_MULTI_SELECT clipboard format.
 *                                      The clipboard data info indicates the types of nodes selected by a multi-select operation.
 *
 * PARAMETERS:
 *                                      IStream *       pstream                 The stream to write to.
 *
 * RETURNS:
 *                                      SC                                                      Execution code.
 */
SC
CBaseMultiSelectSnapinItem::ScWriteMultiSelectionItemTypes(IStream * pstream)
{
    // Declarations
    SC                                     sc                                                                                      = S_OK;
    INT                                    nIterator                                                                       = 0;
    GUIDSet                                gsItemTypes;

    // Data validation
    ASSERT(pstream);

    // Remember we created a multiselect snapin item
    Trace(tagBaseMultiSelectSnapinItemTracker, _T("Received a request for clipboard data on node types"), this);

    // First determine how many GUIDs we have - note that the selection of snapin items was obtained for a particular component
    // Therefore the selection contains snapin items which were instanciated from the same snapin and does not include items which may have been added by other snapins
    for (nIterator=0; nIterator < PivSelectedItems()->size(); nIterator++)
    {
        // Local declarations
        LPGUID  pGuidItemType   = (LPGUID)((*PivSelectedItems())[nIterator])->Pnodetype()->PclsidNodeType();

        // Determine if the guid can be located in the guid set and if not add it
        ASSERT(pGuidItemType);
        if (gsItemTypes.find(*pGuidItemType) == gsItemTypes.end())              // means not found
            gsItemTypes.insert(*pGuidItemType);
    }

    // Write a SMMCObjectTypes data structure
    // First: number of found types
    {
        // Local declarations
        DWORD                           dwcItemTypes                                                    = 0;

        ASSERT(gsItemTypes.size() > 0);
        dwcItemTypes = gsItemTypes.size();
        sc = pstream->Write(&dwcItemTypes, sizeof(DWORD), NULL);      // need l-value
        if (sc)
            goto Error;
    }

    // Write a SMMCObjectTypes data structure
    // Second: the guids
    {
        for (GUIDSet::iterator p = gsItemTypes.begin(); p != gsItemTypes.end(); p++)
        {
            sc = pstream->Write(&p, sizeof(GUID), NULL);
            if (sc)
                goto Error;
        }
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseMultiSelectSnapinItem::ScWriteMultiSelectionItemTypes()"), sc);
    goto Cleanup;

}



/* CBaseMultiSelectSnapinItem::ScOnSelect
 *
 * PURPOSE:                     Forward a selection notification to selected items - select verbs.
 *
 * PARAMETERS:
 *                                      CComponent *            pComponent                              Pointer to the component object.
 *                                      LPDATAOBJECT            lpDataObject                    Pointer to the multiselect snapin item.
 *                                      BOOL                            fScope                                  TRUE if selection in the scope pane.
 *                                      BOOL                            fSelect                                 TRUE if selected.
 *
 * RETURNS:
 *                                      SC                                                                                      Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScOnSelect(CComponent * pComponent, LPDATAOBJECT lpDataObject, BOOL fScope, BOOL fSelect)
{
    // Declarations
    SC                                                      sc                      = S_OK;
    INT                                                     nIterator       = 0;

    // Data validation
    ASSERT(pComponent);
    ASSERT(lpDataObject);

    // Forward the request to the component as if only the first snapin item had been selected (this will allow us to select verbs)
    // MMC finds will select these verbs for all selected snapin items
    ASSERT(PivSelectedItemsFirst());

    // For this call we have to go back to the component as there is some work to do at the snapin level
    // We contact only the first snapin item to select verbs
    // $REVIEW (dominicp) MMC recommends doing this. We should probably merge verbs only though. This would be smarter.
    sc = pComponent->ScOnSelect(PivSelectedItemsFirst(), fScope, fSelect);
    if (sc)
        goto Error;

    // We just let the other snapin items know they have been selected
    for (nIterator=1; nIterator < PivSelectedItems()->size(); nIterator++)          // start at index 1
    {
        // Get the next item
        ASSERT((*PivSelectedItems())[nIterator]);

        // Call ScOnSelect for each snapin item - pass pitem as an lpDataObject parameter
        sc = (*PivSelectedItems())[nIterator]->ScOnSelect(pComponent, (*PivSelectedItems())[nIterator], fScope, fSelect);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseMultiSelectSnapinItem::ScOnSelect()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScAddMenuItems
 *
 * PURPOSE:                     Computes the merged context menu items and sets them.
 *
 * PARAMETERS:
 *                                      CBaseSnapin *                   pSnapin                                 Pointer to the snapin object.
 *                                      LPDATAOBJECT                    lpDataObject                    Pointer to the multiselect snapin item.
 *                                      LPCONTEXTMENUCALLBACK   ipContextMenuCallback   Context menu callback to add menu items.
 *                                      long *                                  pInsertionAllowed               Pointer to insertion flags.
 *
 * RETURNS:
 *                                      SC                                                                                              Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScAddMenuItems(CBaseSnapin * pSnapin, LPDATAOBJECT pDataObject, LPCONTEXTMENUCALLBACK ipContextMenuCallback, long * pInsertionAllowed)
{
    // Declarations
    SC                                                              sc                                      = S_OK;
    CBaseSnapinItem *                               pitem                           = NULL;
    INT                                                             nIterator                       = 0;
    INT                                                             nIteratorMenuItems      = 0;
    CSnapinContextMenuItemVectorWrapper   cmivwMerged;                                                                    // vector of merged context menu items

    // Data validation
    ASSERT(pSnapin);
    ASSERT(pDataObject);
    ASSERT(ipContextMenuCallback);
    ASSERT(pInsertionAllowed);

    // Iterate through the snapin items and retrieve a list of context menus - combine the menus across snapin items
    for (nIterator=0; nIterator < PivSelectedItems()->size(); nIterator++)                  // start at index 1
    {
        // Get the snapin item
        pitem = (*PivSelectedItems())[nIterator];
        ASSERT(pitem);

        // Create a vector of menu items
        CSnapinContextMenuItemVectorWrapper           cmivw;                                                                  // we will have to merge these context menu item`s

        // Determine the menu items for the snapin item
        for (nIteratorMenuItems=0; nIteratorMenuItems < pitem->CMenuItem(); nIteratorMenuItems++)
        {
            // Declarations
            CSnapinContextMenuItem *              pcmi                    = NULL;
            BOOL                                    fAllowed                = FALSE;

            // Create a new context menu item
            pcmi = new CSnapinContextMenuItem();
            if (!pcmi)
                goto MemoryError;

            // Get the context menu item
            ASSERT(pitem->Pmenuitem());
            sc = pSnapin->ScGetMenuItem(pcmi, pitem, &((pitem->Pmenuitem())[nIteratorMenuItems]), &fAllowed, *pInsertionAllowed);
            if (sc)
                goto Error;

            // If the context menu item is allowed, add it to the vector
            if (fAllowed)
            {
                if (nIterator > 0)
                    cmivw.cmiv.push_back(pcmi);                                     // for other items, set a new array and then merge
                else
                    cmivwMerged.cmiv.push_back(pcmi);                       // for the first item, set the merge
            }
            // Otherwise delete the context menu item
            else
            {
                if (pcmi)
                {
                    delete pcmi;
                    pcmi = NULL;
                }
            }
        }

        // Now combine the menus we found with the merged menus
        if (nIterator > 0)
            MergeMenuItems(&cmivwMerged, &cmivw);
    }

    // Now add the merged menu items
    for (nIteratorMenuItems=0; nIteratorMenuItems < cmivwMerged.cmiv.size(); nIteratorMenuItems++)
    {
        sc = ipContextMenuCallback->AddItem(&(cmivwMerged.cmiv[nIteratorMenuItems]->cm));
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
MemoryError:
    sc = E_OUTOFMEMORY;
    goto Error;
Error:
    TraceError(_T("CBaseMultiSelectSnapinItem::ScAddMenuItems()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScCommand
 *
 * PURPOSE:                     Forward an add menu request to selected items.
 *
 * PARAMETERS:
 *                                      CComponent *                    pComponent                              Pointer to the component object.
 *                                      long                                    nCommandID                              Id of the invoked command.
 *                                      LPDATAOBJECT                    pDataObject                             Pointer to the multiselect snapin item.
 *
 * RETURNS:
 *                                      SC                                                                                              Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScCommand(CComponent * pComponent, long nCommandID, LPDATAOBJECT pDataObject)
{
    // Declarations
    SC                                                      sc                              = S_OK;
    CBaseSnapinItem *                       pitem                   = NULL;
    INT                                                     nIterator               = 0;

    // Data validation
    ASSERT(pComponent);
    ASSERT(pDataObject);

    // We forward the call to all items in the default implementation
    // This can be overriden if you want to provide bulk operation behaviour
    // You will then have to create you own CBaseMultiSelectSnapinItem based multiselect data object
    for (nIterator=0; nIterator < PivSelectedItems()->size(); nIterator++)
    {
        // Get the next item
        ASSERT((*PivSelectedItems())[nIterator]);

        // Call the menu by going back to the component
        sc = pComponent->ScCommand(nCommandID, (*PivSelectedItems())[nIterator]);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseMultiSelectSnapinItem::ScCommand()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScQueryPagesFor
 *
 * PURPOSE:                     Indicate that there are properties for a multi selection (in fact a page saying that there are no properties available).
 *
 * PARAMETERS:
 *                                      CComponent *            pComponent                              Pointer to the component object.
 *                                      LPDATAOBJECT            lpDataObject                    Pointer to the multiselect snapin item.
 *
 * RETURNS:
 *                                      SC                                                                                      Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScQueryPagesFor(CComponent * pComponent, LPDATAOBJECT lpDataObject)
{
    // Declarations
    SC                                                      sc                      = S_OK;
    INT                                                     nIterator       = 0;

    // Data validation
    ASSERT(pComponent);
    ASSERT(lpDataObject);

    // By default, no page for a multiselection
    return S_FALSE;
}

/* CBaseMultiSelectSnapinItem::ScCreatePropertyPages
 *
 * PURPOSE:                     Display a page saying that there are no properties available.
 *
 * PARAMETERS:
 *                                      CComponent *            pComponent                              Pointer to the component object.
 *                                      LPDATAOBJECT            lpDataObject                    Pointer to the multiselect snapin item.
 *
 * RETURNS:
 *                                      SC                                                                                      Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScCreatePropertyPages(CComponent * pComponent, LPPROPERTYSHEETCALLBACK ipPropertySheetCallback, long handle, LPDATAOBJECT lpDataObject)
{
    // Data validation
    ASSERT(pComponent);
    ASSERT(ipPropertySheetCallback);
    ASSERT(lpDataObject);

    // By default, no page for a multiselection
    return S_FALSE;
}

/* CBaseMultiSelectSnapinItem::ScOnPaste
 *
 * PURPOSE:                     We receive a multiselect snapin item and we must determine which items are okay with the paste.
 *                                      Also, if the operation involves a cut, we have to return a list of items to be pasted.
 *                                      We use an array of boolean to indicate the items for which a cut notification has to be sent.
 *                                      We reuse the existing multiselect snapin item as the multiselect snapin item sent to MMC to identify
 *                                      the objects which should receive a cut notification.
 *
 * PARAMETERS:
 *                                      CBaseSnapin *                                           psnapin                                                         Pointer to the snapin.
 *                                      CBaseSnapinItem *                                       pitemTarget                                                     Target item for the paste.
 *                                      LPDATAOBJECT                                            lpDataObjectList                                        Pointer to the multiselect snapin item.
 *                                      LPDATAOBJECT *                                          ppDataObjectPasted                                      If not NULL, we must set this pointer to the multiselect snapin item indicating the objects which need a cut notification.
 *                                      IConsole *                                                      ipConsole                                                       Pointer to the console interface.
 *
 * RETURNS:
 *                                      SC                                                                                                                                              Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScOnPaste(CBaseSnapin * pSnapin, CBaseSnapinItem * pitemTarget, LPDATAOBJECT lpDataObjectList, LPDATAOBJECT * ppDataObjectPasted, IConsole * ipConsole)
{
    // Declarations
    SC                                                      sc                                              = S_OK;
    INT                                                     nIterator                               = 0;
    BOOL                                            fAtLeastOnePaste                = FALSE;

    // Data validation
    ASSERT(pSnapin);
    ASSERT(pitemTarget);
    ASSERT(lpDataObjectList);
    ASSERT(ipConsole);
    // other parameters can not be ASSERTed

    // Allocate an array of booleans to indicate the correctly pasted items
    ASSERT(PivSelectedItems()->size() > 0);
    m_pfPastedWithCut = new BOOL[PivSelectedItems()->size()];
    if (!m_pfPastedWithCut)
        goto MemoryError;
    for (nIterator=0; nIterator < PivSelectedItems()->size(); nIterator++)
        m_pfPastedWithCut[nIterator] = FALSE;

    // Iterate through all the objects and verify that they can be pasted
    for (nIterator=0; nIterator < PivSelectedItems()->size(); nIterator++)
    {
        // Local declarations
        DWORD                   dwCanCopyCut            = 0;
        BOOL                    fPasted                         = FALSE;

        // Ask the item to copy the underlying object
        sc = pitemTarget->ScOnPaste((*PivSelectedItems())[nIterator], ppDataObjectPasted ? TRUE : FALSE, &fPasted);
        if (sc)
            goto Error;
        if (fPasted)
        {
            // Remember we pasted at least one item
            fAtLeastOnePaste        = TRUE;
        }

        // If this was a cut, we need to return to MMC the items that were pasted
        // (do not delete the dropped item if we are just adding it to a policy)
        if (fPasted && ppDataObjectPasted && !pitemTarget->FIsPolicy())
        {
            // Remember the items which should receive a cut notification
            m_pfPastedWithCut[nIterator]    = TRUE;
        }
    }

    // Indicate to MMC the pasted item
    if (ppDataObjectPasted)
    {
        *ppDataObjectPasted = this;
        AddRef();                                               // reuse ourselves as the multiselect data object which indicates the pasted items
    }

    // Refresh
    if (fAtLeastOnePaste)
    {
        sc = ipConsole->UpdateAllViews(static_cast<IDataObject *>(pitemTarget), 0, ONVIEWCHANGE_REFRESHCHILDREN);
        if (sc)
            goto Error;
    }
Cleanup:
    return sc;
MemoryError:
    sc = E_OUTOFMEMORY;
    goto Error;
Error:
    TraceError(_T("CBaseMultiSelectSnapinItem::ScOnPaste()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScOnCutOrMove
 *
 * PURPOSE:                     We are a multiselect snapin item which points to an array of booleans indicating which snapin items need a cut notification.
 *                                      We must forward a cut notification to these items.
 *
 * PARAMETERS:
 *                                      CBaseSnapin *                                           psnapin                                                         Pointer to the snapin.
 *                                      LPDATAOBJECT                                            lpDataObjectList                                        Pointer to the multiselect snapin item.
 *                                      IConsoleNameSpace *                                     ipConsoleNameSpace                                      Pointer to the namespace console interface.
 *                                      IConsole *                                                      ipConsole                                                       Pointer to the console interface.
 *
 * RETURNS:
 *                                      SC                                                                                                                                              Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScOnCutOrMove(CBaseSnapin * pSnapin, LPDATAOBJECT lpDataObjectList, IConsoleNameSpace * ipConsoleNameSpace, IConsole * ipConsole)
{
    // Declarations
    SC                                                      sc                                              = S_OK;
    INT                                                     nIterator                               = 0;

    // Data validation
    ASSERT(pSnapin);
    ASSERT(lpDataObjectList);
    ASSERT(ipConsoleNameSpace);
    ASSERT(ipConsole);

    // Iterate through the items and find those which need a cut notification
    for (nIterator=0; nIterator < PivSelectedItems()->size(); nIterator++)          // start at index 1
    {
        // Get the next item
        ASSERT((*PivSelectedItems())[nIterator]);
        ASSERT(m_pfPastedWithCut);

        // Check if the item needs a cut notification
        if (m_pfPastedWithCut[nIterator])
        {
            // Call ScOnCutOrMove for each snapin item - pass pitem as an lpDataObjectList parameter
            sc = pSnapin->ScOnCutOrMove((*PivSelectedItems())[nIterator], ipConsoleNameSpace, ipConsole);
            if (sc)
                goto Error;
        }
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseMultiSelectSnapinItem::ScOnCutOrMove()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScOnDelete
 *
 * PURPOSE:                     Forward a delete notification to selected items.
 *
 * PARAMETERS:
 *                                      CComponent *                    pComponent                              Pointer to the component.
 *                                      LPDATAOBJECT                    lpDataObject                    Pointer to the multiselect snapin item.
 * RETURNS:
 *                                      SC                                                                                              Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScOnDelete(CComponent * pComponent, LPDATAOBJECT lpDataObject)
{
    // Declarations
    SC                                                      sc                                              = S_OK;
    INT                                                     nIterator                               = 0;

    // Data validation
    ASSERT(pComponent);
    ASSERT(lpDataObject);

    // Iterate through the items and find those which need a cut notification
    for (nIterator=0; nIterator < PivSelectedItems()->size(); nIterator++)          // start at index 1
    {
        // Get the next item
        ASSERT((*PivSelectedItems())[nIterator]);

        // Call ScOnDelete for each snapin item - pass pitem as an lpDataObject parameter
        sc = pComponent->ScOnDelete((*PivSelectedItems())[nIterator]);
        if (sc)
            goto Error;
    }

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseMultiSelectSnapinItem::ScOnDelete()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScExtractMultiSelectObjectFromCompositeMultiSelectObject
 *
 * PURPOSE:                     On some notifications, MMC gives us a composite object made of multiselect object from different snapins.
 *                                      This method's goal is to extract a multiselect object from the composite object.
 *
 * PARAMETERS:
 *                                      CBaseSnapin *                                           psnapin                                                         Snapin (used to determine which multiselect data object is the right one in the composite multiselect data object).
 *                                      LPDATAOBJECT                                            pDataObjectComposite                            Composite data object.
 *                                      CBaseMultiSelectSnapinItem **           ppBaseMultiSelectSnapinItem                     Determined multiselect data object.
 *
 * RETURNS:
 *                                      SC                                                                                              Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScExtractMultiSelectObjectFromCompositeMultiSelectObject(CBaseSnapin * psnapin, LPDATAOBJECT pDataObjectComposite, CBaseMultiSelectSnapinItem ** ppBaseMultiSelectSnapinItem)
{
    // Declarations
    SC                                                              sc                                                      = S_OK;
    STGMEDIUM                                               stgmedium                                       = {TYMED_HGLOBAL,  NULL};
    FORMATETC                                               formatetc                                       = {(CLIPFORMAT)s_cfMultiSelectSnapins, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    SMMCDataObjects *                               pSMMCDataObjects                        = NULL;
    CBaseMultiSelectSnapinItem *    pBaseMultiSelectSnapinItem      = NULL;
    INT                                                             nIterator                                       = 0;

    // Data validation
    ASSERT(pDataObjectComposite);
    ASSERT(ppBaseMultiSelectSnapinItem);
    ASSERT(!*ppBaseMultiSelectSnapinItem);
    ASSERT(psnapin);

    // Retrieve data
    sc = pDataObjectComposite->GetData(&formatetc, &stgmedium);
    if (sc)
        goto Error;

    // Lock memory and cast
    pSMMCDataObjects = (SMMCDataObjects *)(::GlobalLock(stgmedium.hGlobal));
    ASSERT(pSMMCDataObjects);

    // What we get here is a composite object made of multiselection sets of snapin items from the same snapin
    // We have to locate the multiselection set for our snapin
    ASSERT(pSMMCDataObjects->count > 0);
    for (nIterator=0; nIterator < pSMMCDataObjects->count; nIterator++)
    {
        // Local declarations
        CLSID           clsid;

        // Get the class id for the dataobject
        ASSERT(pSMMCDataObjects->lpDataObject[nIterator]);
        sc = ScGetClassID(pSMMCDataObjects->lpDataObject[nIterator], &clsid);
        if (sc)
        {
            // Ignore the error, probably this node does not belong to us
            sc = S_OK;
        }
        else if (::IsEqualCLSID(clsid, *(psnapin->PclsidSnapin())))
        {
            pBaseMultiSelectSnapinItem = dynamic_cast<CBaseMultiSelectSnapinItem *>(pSMMCDataObjects->lpDataObject[nIterator]);
            ASSERT(pBaseMultiSelectSnapinItem);
            break;
        }
    }

    // Assign the result
    ASSERT(pBaseMultiSelectSnapinItem);
    ASSERT(*(psnapin->PclsidSnapin()) == *(pBaseMultiSelectSnapinItem->PclsidSnapin()));
    *ppBaseMultiSelectSnapinItem = pBaseMultiSelectSnapinItem;

Cleanup:
    // Cleanup allocated resources
    if (pSMMCDataObjects)
        ::GlobalUnlock(stgmedium.hGlobal);
    if (stgmedium.hGlobal)
        ::GlobalFree(stgmedium.hGlobal);
    return sc;
Error:
    TraceError(_T("CBaseMultiSelectSnapinItem::ScExtractMultiSelectObjectFromCompositeMultiSelectObject()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScIsPastableDataObject
 *
 * PURPOSE:                     Determine, using the multiselect object, if a paste operation is acceptable.
 *
 * PARAMETERS:
 *                                      CBaseSnapin *                                           psnapin                                                         Pointer to the snapin.
 *                                      CBaseSnapinItem *                                       pitemTarget                                                     Target item for the paste.
 *                                      LPDATAOBJECT                                            lpDataObjectList                                        Pointer to the multiselect snapin item.
 *                                      BOOL *                                                          pfPastable                                                      Must be set to TRUE if the paste operation is acceptable.
 *
 * RETURNS:
 *                                      SC                                                                                                                                              Execution code
 */
SC
CBaseMultiSelectSnapinItem::ScIsPastableDataObject(CBaseSnapin * pSnapin, CBaseSnapinItem * pitemTarget, LPDATAOBJECT lpDataObjectList, BOOL * pfPastable)
{
    // Declarations
    SC                                                              sc                                                      = S_OK;
    INT                                                             nIterator                                       = 0;

    // Data validation
    ASSERT(pSnapin);
    ASSERT(pitemTarget);
    ASSERT(lpDataObjectList);
    ASSERT(pfPastable);

    // Go through each snapin items for the multiselect snapin items
    for (nIterator=0; nIterator < PivSelectedItems()->size(); nIterator++)
    {
        // Check if we can paste - if any item can not be pasted, then cancel out
        sc = pSnapin->ScIsPastableDataObject(pitemTarget, (*(PivSelectedItems()))[nIterator], pfPastable);
        if (sc)
            goto Error;
        if (!*pfPastable)
        {
            sc = S_FALSE;
            goto Cleanup;
        }
    }

Cleanup:
    return sc;
Error:
    *pfPastable = FALSE;
    TraceError(_T("CBaseMultiSelectSnapinItem::ScIsPastableDataObject()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::MergeMenuItemsVectors
 *
 * PURPOSE:                     Merges menu item vectors in a smart way.
 *                                      If a menu item in the merge is not found in the list to add, then remove this item from the merge (one snapin item does not support the operation).
 *                                      If a menu item in the merge is found in the list to add, logically combine the flags.
 *
 * PARAMETERS:
 *                                      CSnapinContextMenuItemVectorWrapper   *       pcmivwForMerge          Vector of menu items to merge - will contain the result of the merge
 *                                      CSnapinContextMenuItemVectorWrapper   *       pcmivwToAdd                     Vector of menu items to merge - specify what to add here
 */
void
CBaseMultiSelectSnapinItem::MergeMenuItems(CSnapinContextMenuItemVectorWrapper * pcmivwForMerge, CSnapinContextMenuItemVectorWrapper * pcmivwToAdd)
{
    // Declarations
    INT                             nIteratorToAdd                          = 0;
    INT                             nIteratorForMerge                       = 0;

    // Data validation
    ASSERT(pcmivwForMerge);
    ASSERT(pcmivwToAdd);

    // Iterate through the merge
    for (nIteratorForMerge=0; nIteratorForMerge < pcmivwForMerge->cmiv.size(); nIteratorForMerge++)
    {
        // Local declarations
        BOOL            fFound  = FALSE;                        // if we are not able to find, then we must remove them menu item

        // See if we can find in the add a menu item with the same command id and the same insertion point
        for (nIteratorToAdd=0; nIteratorToAdd < pcmivwToAdd->cmiv.size(); nIteratorToAdd++)
        {
            if (((pcmivwToAdd->cmiv)[nIteratorToAdd]->cm.lCommandID == (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.lCommandID) &&
                ((pcmivwToAdd->cmiv)[nIteratorToAdd]->cm.lInsertionPointID == (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.lInsertionPointID))
            {
                // Set the new default
                fFound = TRUE;

                // Combine the flags in merge
                (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags = (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags | (pcmivwToAdd->cmiv)[nIteratorToAdd]->cm.fFlags;
                (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fSpecialFlags = (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fSpecialFlags | (pcmivwToAdd->cmiv)[nIteratorToAdd]->cm.fSpecialFlags;

                // Handle flag combining exceptions: MF_ENABLED and MF_GRAYED -> MF_GRAYED
                if ((pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags & (MF_ENABLED | MF_GRAYED))
                    (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags = (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags & ~MF_ENABLED;

                // Handle flag combining exceptions: MF_MENUBARBREAK and MF_MENUBREAK -> MF_MENUBREAK
                if ((pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags & (MF_MENUBARBREAK | MF_MENUBREAK))
                    (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags = (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags & ~MF_MENUBARBREAK;

                // Handle flag combining exceptions: MF_CHECKED and MF_UNCHECKED -> MF_UNCHECKED
                if ((pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags & (MF_CHECKED | MF_UNCHECKED))
                    (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags = (pcmivwForMerge->cmiv)[nIteratorForMerge]->cm.fFlags & ~MF_CHECKED;

                // Stop now
                break;
            }
        }

        // If we were not able to find a menu item from merge in add, we have to remove this menu item because at least one snapin item does not advertise it
        if (!fFound)
        {
            // Delete the pointed context menu item
            if (pcmivwForMerge->cmiv[nIteratorForMerge])
            {
                delete pcmivwForMerge->cmiv[nIteratorForMerge];
                pcmivwForMerge->cmiv[nIteratorForMerge] = NULL;
            }
            pcmivwForMerge->cmiv.erase(&(pcmivwForMerge->cmiv[nIteratorForMerge]));
            nIteratorForMerge--;
        }
    }
}

/* CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject
 *
 * PURPOSE:                     Determines if an object is a multiselect data object and casts it.
 *
 * PARAMETERS:
 *                                      LPDATAOBJECT                                    lpDataObject                            Received data object to cast
 *                                      CBaseMultiSelectSnapinItem **   ppMultiSelectSnapinItem         Pointer to multiselect pointer - set to  NULL we can not convert.
 *
 * RETURNS                      SC                                                                                                                      Execution code.
 */
SC
CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject(LPDATAOBJECT lpDataObject, CBaseMultiSelectSnapinItem ** ppMultiSelectSnapinItem)
{
    // Declarations
    SC                                      sc                              = S_OK;
    CLSID                           clsid;

    // Data validation
    ASSERT(lpDataObject);
    ASSERT(ppMultiSelectSnapinItem);
    ASSERT(!*ppMultiSelectSnapinItem);

    // Use the clipboard format to identify the object type
    sc = CBaseDataObject::ScGetNodeType(lpDataObject, &clsid);
    if (sc == SC(DV_E_FORMATETC) )
    {
        SC scNoTrace = sc;
        sc.Clear();
        return scNoTrace;
    }

    if (sc)
        goto Error;

    // If the node type is nodetypeBaseMultiSelect then we know we are a multiselect data object
    if (::IsEqualCLSID(clsid, *(nodetypeBaseMultiSelect.PclsidNodeType())))
    {
        ASSERT(dynamic_cast<CBaseSnapinItem *>(lpDataObject));
        *ppMultiSelectSnapinItem = dynamic_cast<CBaseMultiSelectSnapinItem *>(lpDataObject);
    }
    else
        *ppMultiSelectSnapinItem = NULL;

Cleanup:
    return sc;
Error:
    *ppMultiSelectSnapinItem = NULL;
    TraceError(_T("CBaseMultiSelectSnapinItem::ScGetMultiSelectDataObject()"), sc);
    goto Cleanup;
}

/* CBaseMultiSelectSnapinItem::ScExtractMultiSelectDataObject
 *
 * PURPOSE:                     Determines if an object is a composite data object and extracts the correct multiselect snapin item from it.
 *
 * PARAMETERS:
 *                                      CBaseSnapin *                                   psnapin                                         Snapin (used to determine which multiselect data object is the right one in the composite multiselect data object).
 *                                      LPDATAOBJECT                                    lpDataObject                            Received data object to cast
 *                                      CBaseMultiSelectSnapinItem **   ppMultiSelectSnapinItem         Pointer to multiselect pointer - set to  NULL we can not convert.
 *
 * RETURNS                      SC                                                                                                                      Execution code.
 */
SC
CBaseMultiSelectSnapinItem::ScExtractMultiSelectDataObject(CBaseSnapin * psnapin, LPDATAOBJECT lpDataObject, CBaseMultiSelectSnapinItem ** ppMultiSelectSnapinItem)
{
    // Declarations
    SC                                                              sc                                                      = S_OK;
    STGMEDIUM                                               stgmedium                                       = {TYMED_HGLOBAL,  NULL};
    FORMATETC                                               formatetc                                       = {(CLIPFORMAT)s_cfCompositeDataObject, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    BOOL                    *                               pfCompositeDataObject           = NULL;

    // Data validation
    ASSERT(lpDataObject);
    ASSERT(psnapin);
    ASSERT(ppMultiSelectSnapinItem);
    ASSERT(!*ppMultiSelectSnapinItem);

    // Retrieve data
    sc = lpDataObject->GetData(&formatetc, &stgmedium);
    if (sc)
    {
        sc = S_OK;                    // ignore the error, consider that we are not a composite data object
        goto Cleanup;
    }

    // Lock memory and cast
    pfCompositeDataObject = (BOOL *)(::GlobalLock(stgmedium.hGlobal));
    ASSERT(pfCompositeDataObject);

    // If the object is a composite data object then extract the correct multiselect snapin item
    if (*pfCompositeDataObject)
    {
        sc = ScExtractMultiSelectObjectFromCompositeMultiSelectObject(psnapin, lpDataObject, ppMultiSelectSnapinItem);
        if (sc)
            goto Error;
    }

Cleanup:
    // Cleanup allocated resources
    if (pfCompositeDataObject)
        ::GlobalUnlock(stgmedium.hGlobal);
    if (stgmedium.hGlobal)
        ::GlobalFree(stgmedium.hGlobal);
    return sc;
Error:
    *ppMultiSelectSnapinItem = NULL;
    TraceError(_T("CBaseMultiSelectSnapinItem::ScExtractMultiSelectDataObject()"), sc);
    goto Cleanup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\lib\headers.cxx ===
/*
 *      headers.cxx
 *
 *
 *      Copyright (c) 1998 Microsoft Corporation
 *
 *      PURPOSE:        Contains all the junk that couldn't fit anywhere else.
 *
 *
 *      OWNER:          vivekj
 */

#include <headers.hxx>

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#ifdef VIEW_SUB
// hack here
extern "C"
const CLSID CLSID_CCertConfig = {0x52F2ED5B,0x6C6C,0x11D1,{0xA1,0x22,0x00,0xC0,0x4F,0xC3,0x35,0x89}};
extern "C"
const CLSID IID_ICertConfig = {0x52F2ED5B,0x6C6C,0x11D1,{0xA1,0x22,0x00,0xC0,0x4F,0xC3,0x35,0x89}};
#endif //VIEW_SUB

/*
 *      Purpose:        Initializes the BaseMMC subsystem (Instance).
 *
 *      Return value:
 *              sc              Error encountered
 */
SC ScInitInstanceBaseMMC( void )
{
        SC              sc = S_OK;
        return sc;
}


/*
 *      Purpose:        Undoes what ScInitInstanceBaseMMC did.
 */
void DeinitInstanceBaseMMC( void )
{
}

/*
 *      Purpose:        Initializes the BaseMMC subsystem (Application).
 *
 *      Return value:
 *              sc              Error encountered
 */
SC ScInitApplicationBaseMMC()
{
        SC              sc = S_OK;
        return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\lib\dataobject.cxx ===
/*
 *      dataobject.cxx
 *
 *
 *      Copyright (c) 1998-1999 Microsoft Corporation
 *
 *      PURPOSE:        Implements the CDataObject class
 *
 *
 *      OWNER:          ptousig
 */

#include <headers.hxx>

// -----------------------------------------------------------------------------
// static variables
UINT CBaseDataObject::s_cfAdminHscopeitem               = RegisterClipboardFormat(CF_EXCHANGE_ADMIN_HSCOPEITEM);        // The HSCOPEITEM of this node
UINT CBaseDataObject::s_cfMMCSnapinMachineName          = RegisterClipboardFormat(CF_MMC_SNAPIN_MACHINE_NAME);          // Format supplied by the Computer manager snapin. Passes in the name of the server.
UINT CBaseDataObject::s_cfDisplayName                   = RegisterClipboardFormat(CCF_DISPLAY_NAME);
UINT CBaseDataObject::s_cfNodeType                      = RegisterClipboardFormat(CCF_NODETYPE);
UINT CBaseDataObject::s_cfSzNodeType                    = RegisterClipboardFormat(CCF_SZNODETYPE);
UINT CBaseDataObject::s_cfSnapinClsid                   = RegisterClipboardFormat(CCF_SNAPIN_CLASSID);
UINT CBaseDataObject::s_cfNodeID                        = RegisterClipboardFormat(CCF_NODEID);
UINT CBaseDataObject::s_cfColumnSetId                   = RegisterClipboardFormat(CCF_COLUMN_SET_ID);
UINT CBaseDataObject::s_cfMultiSelectionItemTypes       = RegisterClipboardFormat(CCF_OBJECT_TYPES_IN_MULTI_SELECT);    // Multiselect - list of types for the selected nodes

// -----------------------------------------------------------------------------
HRESULT CBaseDataObject::GetDataHere(FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
    DECLARE_SC(sc,_T(""));
    Trace(tagBaseSnapinIDataObject, _T("--> %S::IDataObject::GetDataHere(pformatetc->cfFormat=%s)"), SzGetSnapinItemClassName(), SzDebugNameFromFormatEtc(pformatetc->cfFormat));
    ADMIN_TRY;
    sc=ScGetDataHere(pformatetc, pmedium);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIDataObject, _T("<-- %S::IDataObject::GetDataHere is returning hr=%s"), SzGetSnapinItemClassName(), SzGetDebugNameOfHr(sc.ToHr()));

	if (sc == SC(DV_E_FORMATETC) )
	{
		sc.Clear();
        return DV_E_FORMATETC;
	}

    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CBaseDataObject::GetData(FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
    DECLARE_SC(sc,_T(""));
    Trace(tagBaseSnapinIDataObject, _T("--> %S::IDataObject::GetData(pformatetc->cfFormat=%s)"), SzGetSnapinItemClassName(), SzDebugNameFromFormatEtc(pformatetc->cfFormat));
    ADMIN_TRY;
    sc=ScGetData(pformatetc, pmedium);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIDataObject, _T("<-- %S::IDataObject::GetData is returning hr=%s"), SzGetSnapinItemClassName(), SzGetDebugNameOfHr(sc.ToHr()));

	if (sc == SC(DV_E_FORMATETC) )
	{
		sc.Clear();
        return DV_E_FORMATETC;
	}

    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CBaseDataObject::QueryGetData(FORMATETC *pformatetc)
{
    DECLARE_SC(sc,_T(""));
    Trace(tagBaseSnapinIDataObject, _T("--> %S::IDataObject::QueryGetData(pformatetc->cfFormat=%s)"), SzGetSnapinItemClassName(), SzDebugNameFromFormatEtc(pformatetc->cfFormat));
    ADMIN_TRY;
    sc=ScQueryGetData(pformatetc);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIDataObject, _T("<-- %S::IDataObject::QueryGetData is returning hr=%s"), SzGetSnapinItemClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
HRESULT CBaseDataObject::EnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
{
    DECLARE_SC(sc,_T(""));
    Trace(tagBaseSnapinIDataObject, _T("--> %S::IDataObject::EnumFormatEtc(dwDirection=%d)"), SzGetSnapinItemClassName(), dwDirection);
    ADMIN_TRY;
    sc=ScEnumFormatEtc(dwDirection, ppEnumFormatEtc);
    ADMIN_CATCH_HR
    Trace(tagBaseSnapinIDataObject, _T("<-- %S::IDataObject::EnumFormatEtc is returning hr=%s"), SzGetSnapinItemClassName(), SzGetDebugNameOfHr(sc.ToHr()));
    return(sc.ToHr());
}

// -----------------------------------------------------------------------------
// Renders the data in a preallocated medium.
//
SC CBaseDataObject::ScGetDataHere(FORMATETC *pFormatEtc, STGMEDIUM *pMedium)
{
    SC sc = S_OK;

    // check parameters
    if (pFormatEtc == NULL || pMedium == NULL)
        return sc = E_INVALIDARG;

    const   CLIPFORMAT cf = pFormatEtc->cfFormat;
    CComPtr<IStream> spStream;
    HGLOBAL hGlobal = NULL;

    // see what kind of medium we have
    if (pFormatEtc->tymed == TYMED_ISTREAM)
    {
        // it's a stream
        spStream = pMedium->pstm;
        if (spStream == NULL)
        {
            sc = E_UNEXPECTED;
            goto Error;
        }
    }
    else if (pFormatEtc->tymed == TYMED_HGLOBAL)
    {
        // it's hGlobal
        hGlobal = pMedium->hGlobal;

        sc = CreateStreamOnHGlobal( hGlobal, FALSE, &spStream );
        if ( sc )
            goto Error;                                              // Minimal error checking
    }
    else // got the media we do not support
    {
        sc = DV_E_TYMED;
        goto Error;
    }

    pMedium->tymed = pFormatEtc->tymed;
    pMedium->pUnkForRelease = NULL;          // by OLE spec

    if (cf == s_cfDisplayName )
        sc = ScWriteDisplayName( spStream );

    else if ( cf == s_cfAdminHscopeitem )
        sc = ScWriteAdminHscopeitem( spStream );

    else if ( cf == s_cfNodeType )
        sc = ScWriteNodeType( spStream );

    else if ( cf == s_cfSzNodeType )
        sc = ScWriteSzNodeType( spStream );

    else if ( cf == s_cfSnapinClsid )
        sc = ScWriteClsid( spStream );

    else if ( cf == s_cfNodeID )
        sc = ScWriteNodeID( spStream );
    else if (cf == s_cfColumnSetId )
        sc = ScWriteColumnSetId( spStream );

    else if ( (cf == s_cfMultiSelectionItemTypes) && FIsMultiSelectDataObject())            // the clipboard format is enabled only for multiselect data objects
        sc = ScWriteMultiSelectionItemTypes( spStream );

	else if ( cf == CF_TEXT)
		sc = ScWriteAnsiName( spStream );

    else // Unknown format
    {
        // we will pretend to suport it for IStream based media (it probably comes from object model)
        if (pFormatEtc->tymed == TYMED_ISTREAM)
        {
            WCHAR szDescription[] = L"Sample Value For Requested Format Of: ";
            spStream->Write(szDescription, wcslen(szDescription) * sizeof(WCHAR), NULL);

            TCHAR szFormatName[512];
            int nChars = GetClipboardFormatName(cf, szFormatName, sizeof(szFormatName) / sizeof(szFormatName[0]));

            USES_CONVERSION;
            spStream->Write(T2W(szFormatName), nChars * sizeof(WCHAR), NULL);
        }
        else
        {
            sc = DV_E_FORMATETC;
            goto Cleanup;
        }
    }

    if (sc)
        goto Error;

    if (pFormatEtc->tymed == TYMED_HGLOBAL)
    {
        sc = GetHGlobalFromStream(spStream, &hGlobal);
        if (sc)
            goto Error;

        ASSERT(pMedium->hGlobal == NULL || pMedium->hGlobal == hGlobal);
        pMedium->hGlobal = hGlobal;
    }

Cleanup:
    return sc;
Error:
    if (sc == E_NOTIMPL)
    {
        sc = DV_E_FORMATETC; // Format not supported by this node
        goto Cleanup;
    }
    TraceError(_T("CBaseDataObject::GetDataHere"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Renders the data in a newly allocated medium.
//
SC CBaseDataObject::ScGetData(FORMATETC *pFormatEtc, STGMEDIUM *pmedium)
{
    SC sc = S_OK;

    pmedium->tymed = TYMED_HGLOBAL;
    pmedium->pUnkForRelease = NULL;
    pmedium->hGlobal = NULL;

    sc = ScGetDataHere(pFormatEtc, pmedium);

	if (sc == SC(DV_E_FORMATETC) )
	{
		sc.Clear();
        return DV_E_FORMATETC;
	}

    if (sc)
        goto Error;

Cleanup:
    return sc;
Error:
    TraceError(_T("CBaseDataObject::ScGetData"), sc);
    if (pmedium->hGlobal)
        GlobalFree(pmedium->hGlobal);
    pmedium->hGlobal = NULL;
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// Asks whether a given format is supported by this data object.
//
SC CBaseDataObject::ScQueryGetData(FORMATETC *pFormatEtc)
{
    SC                                      sc              = S_OK;
    const   CLIPFORMAT      cf              = pFormatEtc->cfFormat;


    if ( ( cf == s_cfDisplayName )               ||
         ( cf == s_cfNodeType )                  ||
         ( cf == s_cfSzNodeType )                ||
         ( cf == s_cfSnapinClsid )               ||
         ( cf == s_cfNodeID )                    ||
		 ( cf == CF_TEXT)                        ||
         ( (cf == s_cfMultiSelectionItemTypes) && FIsMultiSelectDataObject() )           // the clipboard format is enabled only for multiselect data objects
       )
    {
        sc = S_OK;                                                      // known and acceptable format
    }
    else
    {
        sc = S_FALSE;                                           // unknown or unacceptable format
    }

    return sc;
}

// -----------------------------------------------------------------------------
// Enumerates available clipboard format supported by this data object.
// Only implemented in DEBUG.
//
SC CBaseDataObject::ScEnumFormatEtc(DWORD dwDirection, LPENUMFORMATETC* ppEnumFormatEtc)
#ifdef DBG
{
    SC                                      sc              = S_OK;
    CComObject<CEnumFormatEtc>      *pEnum = NULL;

    ASSERT(ppEnumFormatEtc);

    sc = CComObject<CEnumFormatEtc>::CreateInstance(&pEnum);
    if (!pEnum)
        goto MemoryError;

    sc = pEnum->QueryInterface(__uuidof(IEnumFORMATETC),(void **) ppEnumFormatEtc );
    pEnum = NULL;
    if (sc)
        goto Error;

Cleanup:
    return sc;
MemoryError:
    if (pEnum)
        delete pEnum;
    pEnum = NULL;
Error:
    TraceError(_T("CBaseDataObject::ScEnumFormatEtc"), sc);
    goto Cleanup;

}
#else
{
    return E_NOTIMPL;
}
#endif


// -----------------------------------------------------------------------------
// A convenience function to extract a GUID of the specified clipboard format
// from a dataobject.
//
SC CBaseDataObject::ScGetGUID(UINT cf, LPDATAOBJECT lpDataObject, GUID *pguid)
{
    SC              sc              = S_OK;
    STGMEDIUM       stgmedium       = {TYMED_HGLOBAL,  NULL};
    FORMATETC       formatetc       = {(CLIPFORMAT)cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    BYTE*           pb              = NULL;

    // validate parameters
    ASSERT(lpDataObject);
    ASSERT(pguid);

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(GUID));
    if (!stgmedium.hGlobal)
        goto MemoryError;

    // Attempt to get data from the object
    sc = lpDataObject->GetDataHere(&formatetc, &stgmedium);
	if (sc == SC(DV_E_FORMATETC) )
	{
		SC scNoTrace = sc;
		sc.Clear();
		return scNoTrace;
	}

    if (sc)
        goto Error;

    // Copy the GUID into the return buffer
    pb = (BYTE*) GlobalLock(stgmedium.hGlobal);
    CopyMemory(pguid, pb, sizeof(GUID));

Cleanup:
    if (pb)
        GlobalUnlock(stgmedium.hGlobal);
    if (stgmedium.hGlobal)
    {
        ASSERT(GlobalFree(stgmedium.hGlobal) == NULL);
    }
    stgmedium.hGlobal = NULL;

    return sc;
MemoryError:
    sc = E_OUTOFMEMORY;
Error:
    TraceError(_T("CBaseDataObject::ScGetGUID"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// A convenience function to extract a string of the specified clipboard format
// from a dataobject.
//
SC CBaseDataObject::ScGetString(UINT cf, LPDATAOBJECT lpDataObject, tstring& str)
{
    SC                      sc                      = S_OK;
    STGMEDIUM       stgmedium       = {TYMED_HGLOBAL,  NULL};
    FORMATETC       formatetc       = {(CLIPFORMAT)cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    BYTE*                      pb                      = NULL;

    // validate parameters
    ASSERT(lpDataObject);

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, str.length());
    if (!stgmedium.hGlobal)
        goto MemoryError;

    // Attempt to get data from the object
    sc = lpDataObject->GetData(&formatetc, &stgmedium);
    if (sc)
        goto Error;

    // copy the string into the return buffer
    pb = (BYTE*) GlobalLock(stgmedium.hGlobal);
	str = (LPTSTR)pb;

Cleanup:
    if (pb)
        GlobalUnlock(stgmedium.hGlobal);
    if (stgmedium.hGlobal)
    {
        ASSERT(GlobalFree(stgmedium.hGlobal) == NULL);
    }
    stgmedium.hGlobal = NULL;

    return sc;
MemoryError:
    sc = E_OUTOFMEMORY;
Error:
    TraceError(_T("CBaseDataObject::ScGetString"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// A convenience function to extract a bool of the specified clipboard format
// from a dataobject.
//
SC CBaseDataObject::ScGetBool(UINT cf, LPDATAOBJECT lpDataObject, BOOL *pf)
{
    SC                      sc                      = S_OK;
    STGMEDIUM       stgmedium       = {TYMED_HGLOBAL,  NULL};
    FORMATETC       formatetc       = {(CLIPFORMAT)cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    BYTE*                      pb                      = NULL;

    // validate parameters
    ASSERT(lpDataObject);
    ASSERT(pf);

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(BOOL));
    if (!stgmedium.hGlobal)
        goto MemoryError;

    // Attempt to get data from the object
    sc = lpDataObject->GetDataHere(&formatetc, &stgmedium);
    if (sc)
        goto Error;

    // copy the BOOL into the return buffer
    pb = (BYTE*) GlobalLock(stgmedium.hGlobal);
    CopyMemory(pf, pb, sizeof(BOOL));

Cleanup:
    if (pb)
        GlobalUnlock(stgmedium.hGlobal);
    if (stgmedium.hGlobal)
    {
        ASSERT(GlobalFree(stgmedium.hGlobal) == NULL);
    }
    stgmedium.hGlobal = NULL;

    return sc;
MemoryError:
    sc = E_OUTOFMEMORY;
Error:
    TraceError(_T("CBaseDataObject::ScGetBool"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// A convenience function to extract a dword of the specified clipboard format
// from a dataobject.
//
SC CBaseDataObject::ScGetDword(UINT cf, LPDATAOBJECT lpDataObject, DWORD *pdw)
{
    SC                      sc                      = S_OK;
    STGMEDIUM       stgmedium       = {TYMED_HGLOBAL,  NULL};
    FORMATETC       formatetc       = {(CLIPFORMAT)cf, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    BYTE*                      pb                      = NULL;

    // validate parameters
    ASSERT(lpDataObject);
    ASSERT(pdw);

    // Allocate memory for the stream
    stgmedium.hGlobal = GlobalAlloc(GMEM_SHARE, sizeof(DWORD));
    if (!stgmedium.hGlobal)
        goto MemoryError;

    // Attempt to get data from the object
    sc = lpDataObject->GetDataHere(&formatetc, &stgmedium);
    if (sc)
        goto Error;

    // copy the DWORD into the return buffer
    pb = (BYTE*) GlobalLock(stgmedium.hGlobal);
    CopyMemory(pdw, pb, sizeof(DWORD));

Cleanup:
    if (pb)
        GlobalUnlock(stgmedium.hGlobal);
    if (stgmedium.hGlobal)
    {
        ASSERT(GlobalFree(stgmedium.hGlobal) == NULL);
    }
    stgmedium.hGlobal = NULL;

    return sc;
MemoryError:
    sc = E_OUTOFMEMORY;
Error:
    TraceError(_T("CBaseDataObject::ScGetDword"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// A convenience function to extract the SNodeID from a dataobject.
// The SNodeID will be allocated with PvAlloc() and needs to be freed by
// the caller.
//
SC CBaseDataObject::ScGetNodeID(LPDATAOBJECT lpDataObject, SNodeID **ppsnodeid)
{
    SC                      sc                      = S_OK;
    STGMEDIUM       stgmedium       = {TYMED_HGLOBAL, NULL, NULL};
    FORMATETC       formatetc       = {(CLIPFORMAT)s_cfNodeID, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    BYTE*           pb              = NULL;
    int             cb              = 0;
    SNodeID *       psnodeid        = NULL;

    // validate parameters
    ASSERT(lpDataObject);
    ASSERT(ppsnodeid);
    ASSERT(*ppsnodeid == NULL);

    // Attempt to get data from the object
    sc = lpDataObject->GetData(&formatetc, &stgmedium);
    if (sc)
        goto Error;

    // Get a pointer to the blob
    pb = (BYTE*) GlobalLock(stgmedium.hGlobal);
    psnodeid = (SNodeID *) pb;
    cb = sizeof(DWORD) + psnodeid->cBytes;

    // Allocate a new buffer with PvAlloc
    psnodeid = (SNodeID *) GlobalAlloc(GMEM_FIXED, cb);
    if (psnodeid == NULL)
        goto MemoryError;

    CopyMemory(psnodeid, pb, cb);

    // Transfer ownership to our caller
    *ppsnodeid = psnodeid;
    psnodeid = NULL;

Cleanup:
    if (pb)
        GlobalUnlock(stgmedium.hGlobal);
    if (stgmedium.hGlobal)
        GlobalFree(stgmedium.hGlobal);
    if (psnodeid)
        GlobalFree(psnodeid);
    return sc;
MemoryError:
    sc = E_OUTOFMEMORY;
Error:
    TraceError(_T("CBaseDataObject::ScGetNodeID"), sc);
    goto Cleanup;
}

// -----------------------------------------------------------------------------
// A convenience function to extract an MMC Column Set ID from a dataobject.
//
SC CBaseDataObject::ScGetColumnSetID(LPDATAOBJECT lpDataObject, SColumnSetID ** ppColumnSetID)
{
    SC                      sc          = S_OK;
    STGMEDIUM               stgmedium   = {TYMED_HGLOBAL,  NULL};
    FORMATETC               formatetc   = {(CLIPFORMAT)s_cfColumnSetId, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    BYTE*                   pb          = NULL;
    SColumnSetID *  pColumnSetID        = NULL;
    int                     cb          = 0;

    // validate parameters
    ASSERT(lpDataObject);
    ASSERT(ppColumnSetID);
    ASSERT(!*ppColumnSetID);

    // Attempt to get data from the object
    sc = lpDataObject->GetData(&formatetc, &stgmedium);
    if (sc)
        goto Error;

    pb = (BYTE*)GlobalLock(stgmedium.hGlobal);
    pColumnSetID = (SColumnSetID *) pb;
    cb = sizeof(SColumnSetID) + pColumnSetID->cBytes;

    // Allocate a new buffer with PvAlloc
    *ppColumnSetID = (SColumnSetID *)GlobalAlloc(GMEM_FIXED, cb);
    if (*ppColumnSetID == NULL)
        goto MemoryError;

    CopyMemory(*ppColumnSetID, pColumnSetID, cb);

Cleanup:
    if (pColumnSetID)
        GlobalUnlock(stgmedium.hGlobal);
    if (stgmedium.hGlobal)
    {
        ASSERT(GlobalFree(stgmedium.hGlobal) == NULL);
    }
    stgmedium.hGlobal = NULL;

    return sc;
MemoryError:
    sc = E_OUTOFMEMORY;
Error:
    if(*ppColumnSetID)
        delete (*ppColumnSetID);
    (*ppColumnSetID) = NULL;
    TraceError(_T("CBaseDataObject::ScGetColumnSetID"), sc);
    goto Cleanup;
}


// -----------------------------------------------------------------------------
// Returns the name of the clipboard format (debug only)
//
#ifdef DBG
LPTSTR CBaseDataObject::SzDebugNameFromFormatEtc(UINT format)
{
    const int cchMaxLine = 256;
    static TCHAR s_szName[cchMaxLine];
    int ret = 0;

    ret = GetClipboardFormatName(format, s_szName, cchMaxLine);
    if (ret == 0)
        _tcscpy(s_szName, _T("Unknown Clipboard Format"));

    return s_szName;
}
#endif

// -----------------------------------------------------------------------------
// Moves to the next available clipboard format (debug only)
//
#ifdef DBG
STDMETHODIMP CEnumFormatEtc::Next(
                                 /* [in] */                                              ULONG           celt,
                                 /* [length_is][size_is][out] */ FORMATETC       *rgelt,
                                 /* [out] */                                     ULONG           *pceltFetched)
{
    ASSERT(rgelt);

    if (celt != 1)
        return E_FAIL;

    if (m_dwIndex > 0)
        return S_FALSE;

    if (pceltFetched)
        *pceltFetched = 1;

    if (rgelt)
    {
        rgelt->cfFormat = CF_UNICODETEXT;
        rgelt->dwAspect = DVASPECT_CONTENT;
        rgelt->tymed = TYMED_HGLOBAL;
    }
    else
        return E_INVALIDARG;

    m_dwIndex++;

    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\lib\snaptrace.cxx ===
/*
 *      SnapTrace.cxx
 *
 *
 *      Copyright (c) 1998-1999 Microsoft Corporation
 *
 *      PURPOSE:        Support functions for debug trace
 *
 *
 *      OWNER:          ptousig
 */
#include "headers.hxx"

#ifdef DBG
// ScFromHr(E_UNEXPECTED);
CTraceTag tagBaseSnapinNotify(_T("BaseMMC"), _T("Notify"));
CTraceTag tagBaseSnapinRegister(_T("BaseMMC"), _T("Register"));

CTraceTag tagBaseSnapinISnapinAbout(_T("BaseMMC"), _T("ISnapinAbout"));
CTraceTag tagBaseSnapinIComponent(_T("BaseMMC"), _T("IComponent"));
CTraceTag tagBaseSnapinIComponentQueryDataObject(_T("BaseMMC"), _T("IComponent::QueryDataObject"));
CTraceTag tagBaseSnapinIComponentGetDisplayInfo(_T("BaseMMC"), _T("IComponent::GetDisplayInfo"));
CTraceTag tagBaseSnapinIComponentData(_T("BaseMMC"), _T("IComponentData"));
CTraceTag tagBaseSnapinIComponentDataQueryDataObject(_T("BaseMMC"), _T("IComponentData::QueryDataObject"));
CTraceTag tagBaseSnapinIComponentDataGetDisplayInfo(_T("BaseMMC"), _T("IComponentData::GetDisplayInfo"));
CTraceTag tagBaseSnapinIResultOwnerData(_T("BaseMMC"), _T("IResultOwnerData"));
CTraceTag tagBaseSnapinIDataObject(_T("BaseMMC"), _T("IDataObject"));
CTraceTag tagBaseSnapinISnapinHelp(_T("BaseMMC"), _T("ISnapinHelp"));
CTraceTag tagBaseSnapinIExtendContextMenu(_T("BaseMMC"), _T("IExtendContextMenu"));
CTraceTag tagBaseSnapinIExtendPropertySheet(_T("BaseMMC"), _T("IExtendPropertySheet"));
CTraceTag tagBaseSnapinIResultDataCompare(_T("BaseMMC"), _T("IResultDataCompare"));
CTraceTag tagBaseSnapinIPersistStreamInit(_T("BaseMMC"), _T("IPersistStreamInit"));

CTraceTag tagBaseSnapinDebugDisplay(_T("BaseMMC"), _T("Debug Display"));
CTraceTag tagBaseSnapinDebugCopy(_T("BaseMMC"), _T("Copy to WordPad"));
CTraceTag tagBaseSnapinItemTracker(_T("BaseMMC"), _T("Item Tracker"));
CTraceTag tagBaseMultiSelectSnapinItemTracker(_T("BaseMMC"), _T("Multiselect Item Tracker"));

#define CASE_DEBUG_NAME(a)         case a: return _T(#a)

tstring SzGetDebugNameOfHr(HRESULT hr)
{
    //
    // First try some of the common HRESULTs
    //
    switch (hr)
    {
        CASE_DEBUG_NAME(S_FALSE);
        CASE_DEBUG_NAME(E_NOTIMPL);
        CASE_DEBUG_NAME(DV_E_FORMATETC);
        CASE_DEBUG_NAME(E_INVALIDARG);
        CASE_DEBUG_NAME(DV_E_TYMED);
        CASE_DEBUG_NAME(S_OK);
        CASE_DEBUG_NAME(E_UNEXPECTED);
    default:
        //
        // If we reached this point we don't know what the HRESULT is.
        // We can still say wether it's an error code or not.
        //
        if (SUCCEEDED(hr))
            return TEXT("Unknown Success Code");
        else
            return TEXT("Unknown Error Code");
    }
}

tstring SzGetDebugNameOfDATA_OBJECT_TYPES(DATA_OBJECT_TYPES type)
{
    switch (type)
    {
        CASE_DEBUG_NAME(CCT_SCOPE);
        CASE_DEBUG_NAME(CCT_RESULT);
        CASE_DEBUG_NAME(CCT_SNAPIN_MANAGER);
        CASE_DEBUG_NAME(CCT_UNINITIALIZED);
    default:
        return _T("Unknown");
    }
}

tstring SzGetDebugNameOfMMC_NOTIFY_TYPE(MMC_NOTIFY_TYPE event)
{
    switch (event)
    {
        CASE_DEBUG_NAME(MMCN_ACTIVATE);
        CASE_DEBUG_NAME(MMCN_ADD_IMAGES);
        CASE_DEBUG_NAME(MMCN_BTN_CLICK);
        CASE_DEBUG_NAME(MMCN_CLICK);
        CASE_DEBUG_NAME(MMCN_COLUMN_CLICK);
        CASE_DEBUG_NAME(MMCN_CONTEXTMENU);
        CASE_DEBUG_NAME(MMCN_CUTORMOVE);
        CASE_DEBUG_NAME(MMCN_DBLCLICK);
        CASE_DEBUG_NAME(MMCN_DELETE);
        CASE_DEBUG_NAME(MMCN_DESELECT_ALL);
        CASE_DEBUG_NAME(MMCN_EXPAND);
        CASE_DEBUG_NAME(MMCN_EXPANDSYNC);
        CASE_DEBUG_NAME(MMCN_HELP);
        CASE_DEBUG_NAME(MMCN_MENU_BTNCLICK);
        CASE_DEBUG_NAME(MMCN_MINIMIZED);
        CASE_DEBUG_NAME(MMCN_PASTE);
        CASE_DEBUG_NAME(MMCN_PROPERTY_CHANGE);
        CASE_DEBUG_NAME(MMCN_QUERY_PASTE);
        CASE_DEBUG_NAME(MMCN_REFRESH);
        CASE_DEBUG_NAME(MMCN_REMOVE_CHILDREN);
        CASE_DEBUG_NAME(MMCN_RENAME);
        CASE_DEBUG_NAME(MMCN_SELECT);
        CASE_DEBUG_NAME(MMCN_SHOW);
        CASE_DEBUG_NAME(MMCN_VIEW_CHANGE);
        CASE_DEBUG_NAME(MMCN_SNAPINHELP);
        CASE_DEBUG_NAME(MMCN_CONTEXTHELP);
        CASE_DEBUG_NAME(MMCN_INITOCX);
        CASE_DEBUG_NAME(MMCN_FILTER_CHANGE);
        CASE_DEBUG_NAME(MMCN_FILTERBTN_CLICK);
        CASE_DEBUG_NAME(MMCN_RESTORE_VIEW);
        CASE_DEBUG_NAME(MMCN_PRINT);
        CASE_DEBUG_NAME(MMCN_PRELOAD);
        CASE_DEBUG_NAME(MMCN_LISTPAD);
    default:
        return _T("Unknown");
    }
}

#else
tstring SzGetDebugNameOfHr(HRESULT hr){return _T("");}
    //

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\lib\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.inc.

!ENDIF

TARGETNAME=     SnapinBase
TARGETPATH=     obj
TARGETTYPE=     LIBRARY

UMTYPE    =     windows

WIN32_WINNT_VERSION=0x0400
WIN32_IE_VERSION=0x0500
SUBSYSTEM_VERSION=4.00

SYNCHRONIZE_BLOCK = 1
USE_NATIVE_EH     = 1
USE_STATIC_ATL    = 1
USE_CRTDLL        = 1
ATL_VER           = 30
USE_RTTI          = 1
USE_WTL           = 1

# Use LINKLIBS (gets passed first) if: (from build.hlp)
#  You are building a dynamic link.
#  You are exporting something that's defined in some other component library that you also build.
#  In your dirs file in the subdirectory above, you have ordered it so that the component libraries
#     are around before you build the dynamic link.
#LINKLIBS=\
#           $(SDK_LIB_PATH)\mmc.lib            \
#           ..\..\..\core\$(CharWidth)\$(O)\uicore.lib \
#           ..\..\..\base\$(CharWidth)\$(O)\mmcbase.lib


INCLUDES=\
        ..\; \
        ..\..\inc; \
        ..\..\..\..\inc; \
		..\..\..\..\types\idl\$(O); \
        $(SDK_INC_PATH);\



SOURCES=\
        ..\basesnap.cxx         \
        ..\component.cxx        \
        ..\componentdata.cxx    \
        ..\dataobject.cxx       \
        ..\snapinabout.cxx      \
        ..\snapinitem.cxx       \
        ..\headers.cxx          \
        ..\snaptrace.cxx        \
        ..\baseatl.cxx          \
        ..\basewin.cxx          \
        ..\viewlist.cxx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\lib\viewlist.cxx ===
/*
 *      viewlist.cxx
 *
 *
 *      Copyright (c) 1998 Microsoft Corporation
 *
 *      PURPOSE:        Implements the CGenericSnapin class.
 *
 *
 *      OWNER:          vivekj
 */

#include <headers.hxx>

//---------------------------------------------------------------------------------
// class CViewItemList

/* CViewItemList::CViewItemList
 *
 * PURPOSE:             Constructor
 *
 * PARAMETERS:  None
 */
CViewItemList::CViewItemList()
{
    m_pitemSelectedContainer= NULL;
    m_fValid                                = FALSE;
    m_datSort                               = datNil;
}

/* CViewItemList::Initialize
 *
 * PURPOSE:             Initializes a view, by creating pointers to all items underneath the selected container, and
 *                              sorting them.
 *
 * PARAMETERS:
 *              CBaseSnapinItem *  pitemSelectedContainer:      The container containing the items we need to enumerate.
 *              DAT            datPresort:                              The dat according to which the list of items is already sorted.
 *              DAT            datSort:                                 The dat according to which the view is sorted.
 *
 * RETURNS:
 *              void
 */
void
CViewItemList::Initialize(CBaseSnapinItem *pitemSelectedContainer, DAT datPresort, DAT datSort)
{
    CBaseSnapinItem *                                       pitem   = NULL;
    Invalidate();                                                                   // delete any existing items and clear the valid flag

    pitem = pitemSelectedContainer->PitemChild();   // get the first child item
    while (pitem)                                                                   // Iterate through all the children
    {
        push_back(pitem);                                                       // Insert each item
        pitem = pitem->PitemNext();
    }

    if (datPresort != datSort)                                               // need to sort if not already in the correct order.
        Sort();

    SaveSortResults();                                                              // need to save the results for fast lookup.
    m_fValid = TRUE;                                                                // set the valid flag

    return;
}


/* CViewItemList::Sort
 *
 * PURPOSE:             Sorts the view list according to DatSort().
 *
 * PARAMETERS:  None
 *
 * RETURNS:
 *              void
 */
void
CViewItemList::Sort()
{
}

/* CViewItemList::SaveSortResults
 *
 * PURPOSE:             SaveSortResultss the view list according to DatSaveSortResults().
 *
 * PARAMETERS:  None
 *
 * RETURNS:
 *              void
 */
void
CViewItemList::SaveSortResults()
{
    CViewItemListBase::iterator             viewitemiter;

    Pviewsortresultsmap()->clear();

    for (viewitemiter = begin(); viewitemiter < end(); viewitemiter ++)      // create a map of the sort results
    {
        t_sortmapitem sortmapitem(*viewitemiter, viewitemiter);
        Pviewsortresultsmap()->insert(sortmapitem);     // This maps the CBaseSnapinItem *'s onto their location in the sorted array.
    }
}


/* CViewItemList::ScCompare
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *              CBaseSnapinItem *   pitem1:
 *              CBaseSnapinItem *   pitem2:
 *
 * RETURNS:
 *              INT
 */
INT
CViewItemList::Compare(CBaseSnapinItem * pitem1, CBaseSnapinItem *pitem2)
{
    SC              sc              = S_OK;
    INT             result  = 0;            // initialize to "=="

    CViewSortResultsMap:: iterator  sortresultsiterator1, sortresultsiterator2;

    sortresultsiterator1 = Pviewsortresultsmap()->find(pitem1);     // locate the iterators for the items
    sortresultsiterator2 = Pviewsortresultsmap()->find(pitem2);

    if (sortresultsiterator1 == Pviewsortresultsmap()->end() || sortresultsiterator2 == Pviewsortresultsmap()->end())
        goto Cleanup;                                                                                   // didn't find, use "=="

    result = sortresultsiterator1->second - sortresultsiterator2->second;                   // fast compare based on indexes.

    Cleanup:
    return result;
}

/* CViewItemList::Invalidate
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *
 * RETURNS:
 *              void
 */
void
CViewItemList::Invalidate()
{
    m_fValid = FALSE;
    clear();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\sample\component2snapin.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       Component2Testsnap.cxx
//
//  Contents:   Classes that implement Component2Test snapin using the framework.
//
//--------------------------------------------------------------------
#include "stdafx.hxx"


//+-------------------------------------------------------------------
//
//  Member:      CComponent2TestRootItem::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent2TestRootItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CComponent2TestRootItem::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 3; // use an enum instead of 3

    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_Component2TestROOT);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CComponent2TestRootItem::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent2TestRootItem::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CComponent2TestRootItem::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = _T("Root String1");
        break;

    case datString2:
        strField = _T("Root String2");
        break;

    case datString3:
        strField = _T("Root String3");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CComponent2TestRootItem::ScCreateChildren
//
//  Synopsis:    Create any children (nodes & leaf items) for this item.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent2TestRootItem::ScCreateChildren ()
{
    DECLARE_SC(sc, _T("CComponent2TestRootItem::ScCreateChildren"));

    t_itemChild *   pitemChild      = NULL;
    t_itemChild *   pitemPrevious   = NULL;

    // Let us create 10 items for this container.
    for (int i = 0; i < 10; ++i)
    {
        // Create the child nodes and init them.
        sc = CComponent2TestSnapinLVLeafItem::ScCreateLVLeafItem(this, pitemPrevious, &pitemChild, FALSE); // Why FALSE???
        if (sc)
            return sc;
        pitemPrevious = pitemChild;
    }

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CComponent2TestRootItem::ScQueryDispatch
//
//  Synopsis:    We support IDispatch for scripting, just return a pointer
//               to the IDispatch of ourselves.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent2TestRootItem::ScQueryDispatch(long cookie, DATA_OBJECT_TYPES type, LPDISPATCH *ppDispatch)
{
    DECLARE_SC(sc, _T("CComponent2TestRootItem::ScQueryDispatch"));

    *ppDispatch = dynamic_cast<IDispatch*>(this);
    if (! *ppDispatch)
        return (sc = E_NOINTERFACE);

    (*ppDispatch)->AddRef();

    return sc;
}

HRESULT CComponent2TestRootItem::StringFromScriptToSnapin(BSTR bstrMessage)
{
    DECLARE_SC(sc , _T("CComponent2TestRootItem::StringFromScriptToSnapin"));

    // The script is supposed to give us this function name in the string.
    if (0 == _wcsicmp(bstrMessage, L"StringFromScriptToSnapin"))
        return sc.ToHr();

    sc = E_FAIL;

    return sc.ToHr();
}

HRESULT CComponent2TestRootItem::StringFromSnapinToScript(BSTR *pbstrMessage)
{
    DECLARE_SC(sc , _T("CComponent2TestRootItem::StringFromSnapinToScript"));
    sc = ScCheckPointers(pbstrMessage);
    if (sc)
        return sc.ToHr();

    // The script is supposed to expect this function name in the string.
    *pbstrMessage = ::SysAllocString(OLESTR("StringFromSnapinToScript"));

    return sc.ToHr();
}

HRESULT CComponent2TestRootItem::get_Name(BSTR *pbstrMessage)
{
    DECLARE_SC(sc , _T("CComponent2TestRootItem::get_Name"));
    sc = ScCheckPointers(pbstrMessage);
    if (sc)
        return sc.ToHr();

    // The script is supposed to expect this function name in the string.
    *pbstrMessage = ::SysAllocString(OLESTR("Name"));

    return sc.ToHr();
}

HRESULT CComponent2TestRootItem::put_Name(BSTR bstrMessage)
{
    DECLARE_SC(sc , _T("CComponent2TestRootItem::put_Name"));

    // The script is supposed to give us this function name in the string.
    if (0 == _wcsicmp(bstrMessage, L"Name"))
        return sc.ToHr();

    sc = E_FAIL;

    return sc.ToHr();
}



//+-------------------------------------------------------------------
//
//  Member:      CComponent2TestSnapinLVLeafItem::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent2TestSnapinLVLeafItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CComponent2TestSnapinLVLeafItem::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 7; // use an enum instead of 7

    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_LVLeafItem);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CComponent2TestSnapinLVLeafItem::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent2TestSnapinLVLeafItem::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CComponent2TestSnapinLVLeafItem::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = _T("LVLeaf String1");
        break;

    case datString2:
        strField = _T("LVLeaf String2");
        break;

    case datString3:
        strField = _T("LVLeaf String3");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}



//+-------------------------------------------------------------------
//
//  Member:      CComponent2TestSnapinLVLeafItem::ScCreateLVLeafItem
//
//  Synopsis:    Do we really need this method?
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent2TestSnapinLVLeafItem::ScCreateLVLeafItem(CComponent2TestRootItem *pitemParent, t_itemChild * pitemPrevious, t_itemChild ** ppitem, BOOL fNew)
{
    DECLARE_SC(sc, _T("CComponent2TestSnapinLVLeafItem::ScCreateLVLeafItem"));
    t_itemChild *   pitem   = NULL;
    *ppitem = NULL;

    // What to do here?
    sc = ::ScCreateItem(pitemParent, pitemPrevious, &pitem, fNew);
    if (sc)
        return sc;

    *ppitem = pitem;

    return (sc);
}

// Initialize context menu structures. Let us have one item for demonstration.
SnapinMenuItem CComponent2TestSnapinLVLeafItem::s_rgmenuitemLVLeafItem[] =
{
    {IDS_NewLVItem, IDS_NewLVItem, IDS_NewLVItem, CCM_INSERTIONPOINTID_PRIMARY_TOP, NULL, dwMenuAlwaysEnable, dwMenuNeverGray,        dwMenuNeverChecked},
};

INT CComponent2TestSnapinLVLeafItem::s_cmenuitemLVLeafItem = CMENUITEM(s_rgmenuitemLVLeafItem);

// -----------------------------------------------------------------------------
SnapinMenuItem *CComponent2TestSnapinLVLeafItem::Pmenuitem(void)
{
    return s_rgmenuitemLVLeafItem;
}

// -----------------------------------------------------------------------------
INT CComponent2TestSnapinLVLeafItem::CMenuItem(void)
{
    return s_cmenuitemLVLeafItem;
}


//+-------------------------------------------------------------------
//
//  Member:      CComponent2TestSnapinLVLeafItem::ScCommand
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent2TestSnapinLVLeafItem::ScCommand (long nCommandID, CComponent *pComponent)
{
    DECLARE_SC(sc, _T("CComponent2TestSnapinLVLeafItem::ScCommand"));

    switch(nCommandID)
    {
    case IDS_NewLVItem:
        sc = ScInsertResultItem(pComponent);
        break;

    default:
        sc = E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CComponent2TestSnapinLVLeafItem::ScQueryDispatch
//
//  Synopsis:    We support IDispatch for scripting, just return a pointer
//               to the IDispatch of ourselves.
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CComponent2TestSnapinLVLeafItem::ScQueryDispatch(long cookie, DATA_OBJECT_TYPES type, LPDISPATCH *ppDispatch)
{
    DECLARE_SC(sc, _T("CComponent2TestSnapinLVLeafItem::ScQueryDispatch"));

    *ppDispatch = dynamic_cast<IDispatch *>(this);
    if (! *ppDispatch)
        return (sc = E_NOINTERFACE);

    (*ppDispatch)->AddRef();

    return sc;
}


HRESULT CComponent2TestSnapinLVLeafItem::StringFromScriptToSnapin(BSTR bstrMessage)
{
    DECLARE_SC(sc , _T("CComponent2TestSnapinLVLeafItem::StringFromScriptToSnapin"));

    // The script is supposed to give us this function name in the string.
    if (0 == _wcsicmp(bstrMessage, L"StringFromScriptToSnapin"))
        return sc.ToHr();

    sc = E_FAIL;

    return sc.ToHr();
}

HRESULT CComponent2TestSnapinLVLeafItem::StringFromSnapinToScript(BSTR *pbstrMessage)
{
    DECLARE_SC(sc , _T("CComponent2TestSnapinLVLeafItem::StringFromSnapinToScript"));
    sc = ScCheckPointers(pbstrMessage);
    if (sc)
        return sc.ToHr();

    // The script is supposed to expect this function name in the string.
    *pbstrMessage = ::SysAllocString(OLESTR("StringFromSnapinToScript"));

    return sc.ToHr();
}

HRESULT CComponent2TestSnapinLVLeafItem::get_Name(BSTR *pbstrMessage)
{
    DECLARE_SC(sc , _T("CComponent2TestSnapinLVLeafItem::get_Name"));
    sc = ScCheckPointers(pbstrMessage);
    if (sc)
        return sc.ToHr();

    // The script is supposed to expect this function name in the string.
    *pbstrMessage = ::SysAllocString(OLESTR("Name"));


    return sc.ToHr();
}

HRESULT CComponent2TestSnapinLVLeafItem::put_Name(BSTR bstrMessage)
{
    DECLARE_SC(sc , _T("CComponent2TestSnapinLVLeafItem::put_Name"));

    // The script is supposed to give us this function name in the string.
    if (0 == _wcsicmp(bstrMessage, L"Name"))
        return sc.ToHr();

    sc = E_FAIL;

    return sc.ToHr();
}


//-------------------------------------------------------------------------------------
// class CComponent2TestSnapin

#pragma BEGIN_CODESPACE_DATA
SNR     CComponent2TestSnapin::s_rgsnr[] =
{
    SNR(&nodetypeComponent2TestRoot,         snrEnumSP ),              // Standalone snapin.
    SNR(&nodetypeComponent2TestLVLeafItem,   snrEnumSP | snrEnumRP ),  // enumerates this node in the scope pane and result pane.
};

LONG  CComponent2TestSnapin::s_rgiconid[]           = {3};
LONG  CComponent2TestSnapin::s_iconidStatic         = 2;


CColumnInfoEx CComponent2TestSnapin::s_colinfo[] =
{
    CColumnInfoEx(_T("Column Name0"),   LVCFMT_LEFT,    180,    datString1),
    CColumnInfoEx(_T("Column Name1"),   LVCFMT_LEFT,    180,    datString2),
    CColumnInfoEx(_T("Column Name2"),   LVCFMT_LEFT,    180,    datString3),
};

INT CComponent2TestSnapin::s_ccolinfo = sizeof(s_colinfo) / sizeof(CColumnInfoEx);
INT CComponent2TestSnapin::s_colwidths[1];
#pragma END_CODESPACE_DATA

// include members needed for every snapin.
SNAPIN_DEFINE(CComponent2TestSnapin);

/* CComponent2TestSnapin::CComponent2TestSnapin
 *
 * PURPOSE:             Constructor
 *
 * PARAMETERS: None
 *
 */
CComponent2TestSnapin::CComponent2TestSnapin()
{
    m_pstrDisplayName = new tstring();

    *m_pstrDisplayName = _T("Component2Test Snapin Root");
}

/* CComponent2TestSnapin::~CComponent2TestSnapin
 *
 * PURPOSE:             Destructor
 *
 * PARAMETERS: None
 *
 */
CComponent2TestSnapin::~CComponent2TestSnapin()
{
    delete m_pstrDisplayName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\sample\dragdroptest.cpp ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       DragDropTest.cxx
//
//  Contents:   Classes that implement Drag & Drop tests using the framework.
//
//--------------------------------------------------------------------
#include "stdafx.hxx"

int CDragDropSnapinRootItem::s_iNextChildID = 0;

//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinRootItem::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinRootItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CDragDropSnapinRootItem::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 3; // use an enum instead of 3
    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_DragDropRoot);

    tstring strItem;
    strItem.LoadString(_Module.GetResourceInstance(), IDS_DragDropScopeItem);
    int cChildren = 4; // child nodes.

    WTL::CString strTemp;
    for (int i = 0; i < cChildren; ++i)
    {
        strTemp.Format(_T("%s - %d"), strItem.data(), i);
        m_vecContainerItems.push_back((LPCTSTR)strTemp);
    }

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinRootItem::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinRootItem::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CDragDropSnapinRootItem::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = m_strDisplayName;
        break;

    case datString2:
        strField = _T("Root String2");
        break;

    case datString3:
        strField = _T("Root String3");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinRootItem::ScCreateChildren
//
//  Synopsis:    Create any children (nodes & leaf items) for this item.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinRootItem::ScCreateChildren ()
{
    DECLARE_SC(sc, _T("CDragDropSnapinRootItem::ScCreateChildren"));

    CDragDropSnapinLVContainer *   pitemChild      = NULL;
    CDragDropSnapinLVContainer *   pitemPrevious   = NULL;

    // Let us create child items for this container.
    StringVector::iterator itItem;

    // Create scope items for this container.
    for (itItem =  m_vecContainerItems.begin(); itItem  !=  m_vecContainerItems.end(); ++itItem, ++s_iNextChildID )
    {
        // Create the child nodes and init them.
        sc = CDragDropSnapinLVContainer::ScCreateLVContainer(this, pitemPrevious, &pitemChild, FALSE); // Why FALSE???
        if (sc)
            return sc;

        pitemPrevious = pitemChild;
        pitemChild->SetDisplayName(*itItem);
    }

    return (sc);
}

SC CDragDropSnapinRootItem::ScInitializeChild(CBaseSnapinItem* pitem)
{
	CDragDropSnapinLVContainer *pDDItem = dynamic_cast<CDragDropSnapinLVContainer*>(pitem);
	if (pDDItem)
		pDDItem->SetDisplayIndex(s_iNextChildID);
	
	return CBaseSnapinItem::ScInitializeChild(pitem);
}

// Initialize context menu structures. Let us have one item for demonstration.
SnapinMenuItem CDragDropSnapinRootItem::s_rgmenuitemRoot[] =
{
    {IDS_EnablePasteInToResultItem, IDS_EnablePasteInToResultItem, IDS_EnablePasteInToResultItem, CCM_INSERTIONPOINTID_PRIMARY_TOP, NULL, dwMenuAlwaysEnable, dwMenuNeverGray, 0},
    {IDS_DisableCut, IDS_DisableCut, IDS_DisableCut, CCM_INSERTIONPOINTID_PRIMARY_TOP, NULL, dwMenuAlwaysEnable, dwMenuNeverGray, 0},
};

INT CDragDropSnapinRootItem::s_cmenuitemRoot = CMENUITEM(s_rgmenuitemRoot);

// -----------------------------------------------------------------------------
SnapinMenuItem *CDragDropSnapinRootItem::Pmenuitem(void)
{
    return s_rgmenuitemRoot;
}

// -----------------------------------------------------------------------------
INT CDragDropSnapinRootItem::CMenuItem(void)
{
    return s_cmenuitemRoot;
}


//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinRootItem::ScCommand
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinRootItem::ScCommand (long nCommandID, CComponent *pComponent)
{
    DECLARE_SC(sc, _T("CDragDropSnapinRootItem::ScCommand"));

    CDragDropSnapin *pDragDropSnapin = dynamic_cast<CDragDropSnapin*>(Psnapin());
    if (!pDragDropSnapin)
        return sc;

    switch(nCommandID)
    {
    case IDS_EnablePasteInToResultItem:
        {
            BOOL bEnabled = pDragDropSnapin->FPasteIntoResultPane();
            pDragDropSnapin->SetPasteIntoResultPane(!bEnabled);

            for (int i = 0; i < CMenuItem(); ++i)
            {
                if (s_rgmenuitemRoot[i].lCommandID == IDS_EnablePasteInToResultItem)
                    s_rgmenuitemRoot[i].dwFlagsChecked = (!bEnabled);
            }

        }
        break;

    case IDS_DisableCut:
        {
            BOOL bDisabled = pDragDropSnapin->FCutDisabled();
            pDragDropSnapin->SetCutDisabled(! bDisabled);

            for (int i = 0; i < CMenuItem(); ++i)
            {
                if (s_rgmenuitemRoot[i].lCommandID == IDS_DisableCut)
                    s_rgmenuitemRoot[i].dwFlagsChecked = (!bDisabled);
            }
        }
        break;

    default:
        sc = E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinLVContainer::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinLVContainer::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CDragDropSnapinLVContainer::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 4; // use an enum instead of 4

    m_strDisplayName = _T("None");

    tstring strLeafItem;
    strLeafItem.LoadString(_Module.GetResourceInstance(), IDS_DragDropResultItem);
    int cLeafItems = 4;

    WTL::CString strTemp;
    for (int i = 0; i < cLeafItems; ++i)
    {
        strTemp.Format(_T("%s - [%d : %d]"), strLeafItem.data(), m_index, i);
        m_vecLeafItems.push_back((LPCTSTR)strTemp);
    }

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinLVContainer::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinLVContainer::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CDragDropSnapinLVContainer::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = m_strDisplayName;
        break;

    case datString2:
        strField = _T("None");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinLVContainer::ScCreateChildren
//
//  Synopsis:    Create any children (nodes & leaf items) for this item.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinLVContainer::ScCreateChildren ()
{
    DECLARE_SC(sc, _T("CDragDropSnapinLVContainer::ScCreateChildren"));

    CDragDropSnapinLVContainer*   pitem           = NULL;
    CDragDropSnapinLVLeafItem *   pitemChild      = NULL;
    CBaseSnapinItem *             pitemPrevious   = NULL;

    StringVector::iterator itItem;

	int index = 0;
    // Create scope items for this container.
    for (itItem =  m_vecContainerItems.begin(); itItem  !=  m_vecContainerItems.end(); ++itItem, ++index )
    {
        // Create the child nodes and init them.
        sc = CDragDropSnapinLVContainer::ScCreateLVContainer(this, NULL, &pitem, FALSE); // Why FALSE???
        if (sc)
            return sc;

        pitem->SetDisplayName(*itItem);
		pitem->SetDisplayIndex(index);

        pitemPrevious = pitem;
    }

    // Create leaf items for this container.
    for (itItem  =  m_vecLeafItems.begin(); itItem  !=  m_vecLeafItems.end(); ++itItem )
    {
        // Create the child nodes and init them.
        sc = CDragDropSnapinLVLeafItem::ScCreateLVLeafItem(this, pitemPrevious, &pitemChild, FALSE); // Why FALSE???
        if (sc)
            return sc;

        pitemChild->SetDisplayName(*itItem );

        pitemPrevious = pitemChild;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinLVContainer::ScCreateLVContainer
//
//  Synopsis:    Do we really need this method?
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinLVContainer::ScCreateLVContainer(CBaseSnapinItem *pitemParent, CBaseSnapinItem *pitemPrevious, CDragDropSnapinLVContainer ** ppitem, BOOL fNew)
{
    DECLARE_SC(sc, _T("CDragDropSnapinRootItem::ScCreateLVContainer"));
    t_item *   pitem   = NULL;
    *ppitem = NULL;

    // What to do here?
    sc = ::ScCreateItem(pitemParent, pitemPrevious, &pitem, fNew);
    if (sc)
        return sc;

    *ppitem = pitem;

    return (sc);
}

SC CDragDropSnapinLVContainer::ScOnSelect(CComponent * pComponent, LPDATAOBJECT lpDataObject, BOOL fScope, BOOL fSelect)
{
    DECLARE_SC(sc, TEXT("CDragDropSnapinLVContainer::ScOnSelect"));
    sc = ScCheckPointers(pComponent);
    if (sc)
        return sc;

    CDragDropSnapin *pDragDropSnapin = dynamic_cast<CDragDropSnapin*>(Psnapin());
    if (!pDragDropSnapin)
        return S_OK;


    IConsoleVerb *pConsoleVerb = pComponent->IpConsoleVerb();
    sc = pConsoleVerb ? pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, !pDragDropSnapin->FCutDisabled()) : E_UNEXPECTED;

    return (sc);
}

SC CDragDropSnapinLVContainer::ScOnQueryPaste(LPDATAOBJECT pDataObject, BOOL *pfCanPaste)
{
	DECLARE_SC(sc, _T("CDragDropSnapinLVContainer::ScOnQueryPaste"));
	sc = ScCheckPointers(pDataObject, pfCanPaste);
	if (sc)
		return sc;

	*pfCanPaste  = FALSE;

	CLSID guidNodeType;
	sc = ScGetNodeType(pDataObject, &guidNodeType);
	if (sc)
		return sc;

	if (IsEqualGUID(guidNodeType, clsidNodeTypeDragDropLVContainer) || 
	    IsEqualGUID(guidNodeType, clsidNodeTypeDragDropLVLeafItem) )
	{
	    *pfCanPaste = TRUE;
		return (sc = S_OK);
	}

	return (sc = S_FALSE);
}

SC CDragDropSnapinLVContainer::ScOnPaste(LPDATAOBJECT pDataObject, BOOL fMove, BOOL *pfPasted)
{
    DECLARE_SC(sc, TEXT("CDragDropSnapinLVContainer::ScOnPaste"));
	sc = ScCheckPointers(pDataObject, pfPasted);
	if (sc)
		return sc;

    *pfPasted = FALSE;

	CLSID guidNodeType;
	sc = ScGetNodeType(pDataObject, &guidNodeType);
	if (sc)
		return sc;

	tstring strDispName;
	sc = ScGetDisplayName(pDataObject, strDispName);
	if (sc)
		return sc;

	if (IsEqualGUID(guidNodeType, clsidNodeTypeDragDropLVContainer) )
	{
		m_vecContainerItems.push_back(strDispName);
	}
	else if (IsEqualGUID(guidNodeType, clsidNodeTypeDragDropLVLeafItem) )
	{
		m_vecLeafItems.push_back(strDispName);
	}
	else
		return (sc = S_FALSE);

    *pfPasted = TRUE;

    return sc;
}

BOOL CDragDropSnapinLVContainer::FAllowPasteForResultItems()
{
    CDragDropSnapin *pDragDropSnapin = dynamic_cast<CDragDropSnapin*>(Psnapin());
    if (!pDragDropSnapin)
        return FALSE;

    return pDragDropSnapin->FPasteIntoResultPane();

}

SC CDragDropSnapinLVContainer::ScOnCutOrMove()
{
    DECLARE_SC(sc, TEXT("CDragDropSnapinLVContainer::ScOnCutOrMove"));

	LPDATAOBJECT pDataObject = dynamic_cast<LPDATAOBJECT>(this);
	sc = ScCheckPointers(pDataObject, E_UNEXPECTED);
	if (sc)
		return sc;

	tstring strDispName;
	sc = ScGetDisplayName(pDataObject, strDispName);
	if (sc)
		return sc;

	CDragDropSnapinLVContainer *pitemParent = dynamic_cast<CDragDropSnapinLVContainer*>(PitemParent());
	sc = ScCheckPointers(pitemParent, E_UNEXPECTED);
	if (! sc.IsError())
	{
		sc = pitemParent->_ScDeleteCutItem(strDispName, true);
		return sc;
	}

	CDragDropSnapinRootItem *pRootitem= dynamic_cast<CDragDropSnapinRootItem*>(PitemParent());
	sc = ScCheckPointers(pRootitem, E_UNEXPECTED);
	if (sc)
		return sc;

	sc = pRootitem->_ScDeleteCutItem(strDispName);

	return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinLVLeafItem::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinLVLeafItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CDragDropSnapinLVLeafItem::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 7; // use an enum instead of 7

    m_strDisplayName = m_strItemPasted = _T("None");

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinLVLeafItem::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinLVLeafItem::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CDragDropSnapinLVLeafItem::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = m_strDisplayName;
        break;

    case datString2:
        strField = m_strItemPasted;
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}



//+-------------------------------------------------------------------
//
//  Member:      CDragDropSnapinLVLeafItem::ScCreateLVLeafItem
//
//  Synopsis:    Do we really need this method?
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CDragDropSnapinLVLeafItem::ScCreateLVLeafItem(CBaseSnapinItem *pitemParent, CBaseSnapinItem * pitemPrevious, CDragDropSnapinLVLeafItem ** ppitem, BOOL fNew)
{
    DECLARE_SC(sc, _T("CDragDropSnapinLVLeafItem::ScCreateLVLeafItem"));
    t_itemChild *   pitem   = NULL;
    *ppitem = NULL;

    // What to do here?
    sc = ::ScCreateItem(pitemParent, pitemPrevious, &pitem, fNew);
    if (sc)
        return sc;

    *ppitem = pitem;

    return (sc);
}

SC CDragDropSnapinLVLeafItem::ScOnQueryPaste(LPDATAOBJECT pDataObject, BOOL *pfCanPaste)
{
	DECLARE_SC(sc, TEXT("CDragDropSnapinLVLeafItem::ScOnQueryPaste"));
	sc = ScCheckPointers(pDataObject, pfCanPaste);
	if (sc)
		return sc;

	*pfCanPaste  = FALSE;

	CLSID guidNodeType;
	sc = ScGetNodeType(pDataObject, &guidNodeType);
	if (sc)
		return sc;

	if (IsEqualGUID(guidNodeType, clsidNodeTypeDragDropLVContainer) || 
	    IsEqualGUID(guidNodeType, clsidNodeTypeDragDropLVLeafItem) )
	{
		CDragDropSnapin *pDragDropSnapin = dynamic_cast<CDragDropSnapin*>(Psnapin());
		if (!pDragDropSnapin)
			return S_OK;

	    *pfCanPaste = pDragDropSnapin->FPasteIntoResultPane();
		return (sc = S_OK);
	}

	return (sc = S_FALSE);
}

SC CDragDropSnapinLVLeafItem::ScGetVerbs(DWORD * pdwVerbs)
{
    *pdwVerbs = vmDelete | vmCopy | vmRename;

    CDragDropSnapin *pDragDropSnapin = dynamic_cast<CDragDropSnapin*>(Psnapin());
    if (!pDragDropSnapin)
        return S_OK;

    if (pDragDropSnapin->FPasteIntoResultPane())
        *pdwVerbs |= vmPaste;

    return S_OK;
}


SC CDragDropSnapinLVLeafItem::ScOnSelect(CComponent * pComponent, LPDATAOBJECT lpDataObject, BOOL fScope, BOOL fSelect)
{
    DECLARE_SC(sc, TEXT("CDragDropSnapinLVLeafItem::ScOnSelect"));
    sc = ScCheckPointers(pComponent);
    if (sc)
        return sc;

    CDragDropSnapin *pDragDropSnapin = dynamic_cast<CDragDropSnapin*>(Psnapin());
    if (!pDragDropSnapin)
        return S_OK;

    IConsoleVerb *pConsoleVerb = pComponent->IpConsoleVerb();
    sc = pConsoleVerb ? pConsoleVerb->SetVerbState(MMC_VERB_CUT, ENABLED, !pDragDropSnapin->FCutDisabled()) : E_UNEXPECTED;

    return (sc);
}

SC CDragDropSnapinLVLeafItem::ScOnPaste(LPDATAOBJECT pDataObject, BOOL fMove, BOOL *pfPasted)
{
    DECLARE_SC(sc, TEXT("CDragDropSnapinLVLeafItem::ScOnPaste"));
	sc = ScCheckPointers(pDataObject, pfPasted);
    *pfPasted = FALSE;

	CLSID guidNodeType;
	sc = ScGetNodeType(pDataObject, &guidNodeType);
	if (sc)
		return sc;

	tstring strDispName;
	sc = ScGetDisplayName(pDataObject, strDispName);
	if (sc)
		return sc;

	if (IsEqualGUID(guidNodeType, clsidNodeTypeDragDropLVContainer) ||
		IsEqualGUID(guidNodeType, clsidNodeTypeDragDropLVLeafItem) )
	{
		m_strItemPasted = strDispName;
	}
	else
		return (sc = S_FALSE);

    *pfPasted = TRUE;

    return sc;
}

SC CDragDropSnapinLVLeafItem::ScOnCutOrMove()
{
    DECLARE_SC(sc, TEXT("CDragDropSnapinLVLeafItem::ScOnCutOrMove"));

	LPDATAOBJECT pDataObject = dynamic_cast<LPDATAOBJECT>(this);
	sc = ScCheckPointers(pDataObject, E_UNEXPECTED);
	if (sc)
		return sc;

	tstring strDispName;
	sc = ScGetDisplayName(pDataObject, strDispName);
	if (sc)
		return sc;

	CDragDropSnapinLVContainer *pitemParent = dynamic_cast<CDragDropSnapinLVContainer*>(PitemParent());
	sc = ScCheckPointers(pitemParent, E_UNEXPECTED);
	if (sc)
		return sc;

	sc = pitemParent->_ScDeleteCutItem(strDispName, false);

	return sc;
}

//-------------------------------------------------------------------------------------
// class CDragDropSnapin

#pragma BEGIN_CODESPACE_DATA
SNR     CDragDropSnapin::s_rgsnr[] =
{
    SNR(&nodetypeDragDropRoot,         snrEnumSP ),              // Standalone snapin.
    SNR(&nodetypeDragDropLVContainer,  snrEnumSP | snrEnumRP | snrPaste),  // enumerates this node in the scope pane and result pane.
    SNR(&nodetypeDragDropLVLeafItem,   snrEnumSP | snrEnumRP | snrPaste),  // enumerates this node in the scope pane and result pane.
};

LONG  CDragDropSnapin::s_rgiconid[]           = {3};
LONG  CDragDropSnapin::s_iconidStatic         = 2;


CColumnInfoEx CDragDropSnapin::s_colinfo[] =
{
    CColumnInfoEx(_T("Name"),   LVCFMT_LEFT,    250,    datString1),
    CColumnInfoEx(_T("Last Cut/Copy/Paste operation"),   LVCFMT_LEFT,    180,    datString2),
};

INT CDragDropSnapin::s_ccolinfo = sizeof(s_colinfo) / sizeof(CColumnInfoEx);
INT CDragDropSnapin::s_colwidths[1];
#pragma END_CODESPACE_DATA

// include members needed for every snapin.
SNAPIN_DEFINE( CDragDropSnapin);

/* CDragDropSnapin::CDragDropSnapin
 *
 * PURPOSE:             Constructor
 *
 * PARAMETERS: None
 *
 */
CDragDropSnapin::CDragDropSnapin()
{
    m_pstrDisplayName = new tstring();

    *m_pstrDisplayName = _T("DragDrop Snapin Root");
}

/* CDragDropSnapin::~CDragDropSnapin
 *
 * PURPOSE:             Destructor
 *
 * PARAMETERS: None
 *
 */
CDragDropSnapin::~CDragDropSnapin()
{
    delete m_pstrDisplayName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\sample\dragdroptest.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       dragdroptest.hxx
//
//  Contents:   Classes that implement Drag&Drop test snapin using the framework.
//
//--------------------------------------------------------------------
#ifndef _DRAGDROPTEST_H_
#define _DRAGDROPTEST_H_

// Forward declarations.
class CDragDropSnapinLVContainer;
class CDragDropSnapinLVLeafItem;
class CDragDropSnapin;

typedef vector<tstring>  StringVector;

//+-------------------------------------------------------------------
//
//  Class:      CDragDropSnapinRootItem
//
//  Purpose:    Implements the root item for a standalone snapin.
//
//--------------------------------------------------------------------
class CDragDropSnapinRootItem : public CBaseSnapinItem
{
    typedef          CBaseSnapinItem super;

    // Used by CBaseSnapinItem::ScCreateItem, connect this item with its children.
    typedef          CComObject<CSnapinItem<CDragDropSnapinRootItem> >          t_item;
    typedef          CComObject<CSnapinItem<CDragDropSnapinLVContainer> > t_itemChild; // Who is my child?

public:
    CDragDropSnapinRootItem( void )   {} // Raw constructor - use only for static item.
    virtual          ~CDragDropSnapinRootItem( void ) {}

    BEGIN_COM_MAP(CDragDropSnapinRootItem)
        COM_INTERFACE_ENTRY(IDataObject) // Cant have empty map so add IDataObject
    END_COM_MAP()

protected:
    // Item tree related information

    // node type related information
    virtual const CNodeType* Pnodetype( void )     { return &nodetypeDragDropRoot;}

    // the display name of the item
    virtual const tstring* PstrDisplayName( void ) { return &m_strDisplayName;}

    // Get ListView data (GetDisplayInfo calls this).
    virtual SC       ScGetField(DAT dat, tstring& strField);

    // Image list information
    virtual LONG     Iconid() { return m_uIconIndex; }
    virtual LONG     OpenIconid() { return m_uIconIndex; }

    virtual BOOL     FIsContainer( void ) { return TRUE; }

    // Context menu support
    virtual SnapinMenuItem *Pmenuitem(void);
    virtual INT             CMenuItem(void);
    virtual SC              ScCommand(long nCommandID, CComponent *pComponent = NULL);
    virtual DWORD           DwFlagsMenuChecked(void)          { return TRUE;}

public:
    virtual SC       ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex = NULL, INT ccolinfoex = 0, BOOL fIsRoot = FALSE);
	virtual SC       ScInitializeChild(CBaseSnapinItem* pitem);

public:
    // Creates children for the node
    virtual SC       ScCreateChildren( void );
    void             SetDisplayName(tstring & strItemName) { m_strDisplayName = strItemName; }
	SC       _ScDeleteCutItem(tstring& strItemName)
	{
		StringVector::iterator itItem = std::find(m_vecContainerItems.begin(),
			                                      m_vecContainerItems.end(),
												  strItemName);
		if (itItem == m_vecContainerItems.end())
			return S_FALSE;

		m_vecContainerItems.erase(itItem);

		return S_OK;
	}

protected:
    virtual SC       ScGetVerbs(DWORD * pdwVerbs)     { *pdwVerbs = 0; return S_OK;}

protected:
    tstring          m_strDisplayName;
    UINT             m_uIconIndex;

    StringVector     m_vecContainerItems;
	static int       s_iNextChildID;

    // For context menus
    static SnapinMenuItem  s_rgmenuitemRoot[];
    static INT             s_cmenuitemRoot;
};


//+-------------------------------------------------------------------
//
//  Class:      CDragDropSnapinLVContainer
//
//  Purpose:    Implements a scope pane item.
//
//--------------------------------------------------------------------
class CDragDropSnapinLVContainer : public CBaseSnapinItem
{
    typedef          CBaseSnapinItem super;

    // Used by CBaseSnapinItem::ScCreateItem, connect this item with its children.
    typedef          CComObject<CSnapinItem<CDragDropSnapinLVContainer> > t_item;
    typedef          CComObject<CSnapinItem<CDragDropSnapinLVLeafItem> >  t_itemChild;

public:
    CDragDropSnapinLVContainer( void ) {}
    virtual          ~CDragDropSnapinLVContainer( void ) {}

    BEGIN_COM_MAP(CDragDropSnapinLVContainer)
        COM_INTERFACE_ENTRY(IDataObject) // Cant have empty map so add IDataObject
    END_COM_MAP()
protected:
    // Item tree related information

    // node type related information
    const CNodeType *Pnodetype( void )                { return &nodetypeDragDropLVContainer;}

    // the display name of the item
    virtual const tstring*    PstrDisplayName( void ) { return &m_strDisplayName;}

    // Get ListView data (GetDisplayInfo calls this).
    virtual SC                ScGetField(DAT dat, tstring& strField);

    // Image list information
    virtual LONG     Iconid()     { return m_uIconIndex; }
    virtual LONG     OpenIconid() { return m_uIconIndex; }

    // This item attributes.
    virtual BOOL     FIsContainer( void ) { return TRUE; }
    virtual BOOL     FAllowMultiSelectionForChildren() { return TRUE;}
    virtual BOOL     FAllowPasteForResultItems();

public:
    virtual SC       ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex = NULL, INT ccolinfoex = 0, BOOL fIsRoot = FALSE);

public:
    // Creates children for the node
    virtual SC       ScCreateChildren( void );
    static  SC       ScCreateLVContainer(CBaseSnapinItem *pitemParent, CBaseSnapinItem *pitemPrevious, CDragDropSnapinLVContainer ** ppitem, BOOL fNew);
    void             SetDisplayName(tstring & strItemName) { m_strDisplayName = strItemName;}
    void             SetDisplayIndex(int index) { m_index = index;}
	SC       _ScDeleteCutItem(tstring& strItemName, bool bContainerItem)
	{
		StringVector::iterator itItem;
		StringVector& vecStrings = bContainerItem ? m_vecContainerItems : m_vecLeafItems;

		itItem = std::find(vecStrings.begin(), vecStrings.end(), strItemName);
		if (itItem == vecStrings.end())
			return S_FALSE;

		vecStrings.erase(itItem);

		return S_OK;
	}

public: // Notification handlers
    virtual SC       ScOnQueryPaste(LPDATAOBJECT pDataObject, BOOL *pfCanPaste);
    virtual SC       ScOnDelete(BOOL *pfDeleted)                                        { *pfDeleted = TRUE; return S_OK;}
    virtual SC       ScOnSelect(CComponent * pComponent, LPDATAOBJECT lpDataObject, BOOL fScope, BOOL fSelect);
    virtual SC       ScOnPaste(LPDATAOBJECT pDataObject, BOOL fMove, BOOL *pfPasted);
	virtual SC       ScOnCutOrMove();

protected:
    virtual SC       ScGetVerbs(DWORD * pdwVerbs)     { *pdwVerbs = vmCopy | vmDelete | vmPaste; return S_OK;}

protected:
    tstring          m_strDisplayName;
	int              m_index; // ID given by container of this item.
    UINT             m_uIconIndex;

    StringVector     m_vecContainerItems;
    StringVector     m_vecLeafItems;
};


//+-------------------------------------------------------------------
//
//  Class:      CDragDropSnapinLVLeafItem
//
//  Purpose:    Implements a result pane item.
//
//--------------------------------------------------------------------
class CDragDropSnapinLVLeafItem : public CBaseSnapinItem
{
    typedef          CBaseSnapinItem super;

    // Used by CBaseSnapinItem::ScCreateItem, connect this item with its children.
    // This is a leaf item so this item acts as its child.
    typedef          CComObject<CSnapinItem<CDragDropSnapinLVLeafItem> > t_item;
    typedef          CComObject<CSnapinItem<CDragDropSnapinLVLeafItem> > t_itemChild;

public:
    CDragDropSnapinLVLeafItem( void ) {}
    virtual          ~CDragDropSnapinLVLeafItem( void ) {}

    BEGIN_COM_MAP(CDragDropSnapinLVLeafItem)
        COM_INTERFACE_ENTRY(IDataObject) // Cant have empty map so add IDataObject
    END_COM_MAP()
protected:
    // Item tree related information

    // node type related information
    virtual const CNodeType *Pnodetype( void ) {return &nodetypeDragDropLVLeafItem;}

    // the display name of the item
    virtual const tstring* PstrDisplayName( void ) { return &m_strDisplayName; }

    // Get ListView data (GetDisplayInfo calls this).
    virtual SC       ScGetField(DAT dat, tstring& strField);

    // Image list information
    virtual LONG     Iconid() { return m_uIconIndex; }

    virtual BOOL     FIsContainer( void ) { return FALSE; }

public:
    virtual SC       ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex = NULL, INT ccolinfoex = 0, BOOL fIsRoot = FALSE);

public:
    static SC        ScCreateLVLeafItem(CBaseSnapinItem *pitemParent, CBaseSnapinItem * pitemPrevious, CDragDropSnapinLVLeafItem ** ppitem, BOOL fNew);
    void             SetDisplayName(tstring & strItemName) { m_strDisplayName = strItemName; }

public: // Notification handlers
    virtual SC       ScOnQueryPaste(LPDATAOBJECT pDataObject, BOOL *pfCanPaste);
    virtual SC       ScOnDelete(BOOL *pfDeleted)         { *pfDeleted = TRUE; return S_OK;}
    virtual SC       ScOnSelect(CComponent * pComponent, LPDATAOBJECT lpDataObject, BOOL fScope, BOOL fSelect);
    virtual SC       ScOnPaste(LPDATAOBJECT pDataObject, BOOL fMove, BOOL *pfPasted);
	virtual SC       ScOnCutOrMove();
    virtual SC       ScOnRename(const tstring& strNewName)   { m_strDisplayName = strNewName; return S_OK;}

protected:
    virtual SC       ScGetVerbs(DWORD * pdwVerbs);

private:
    tstring          m_strDisplayName;
    UINT             m_uIconIndex;

    tstring          m_strItemPasted;
};


//+-------------------------------------------------------------------
//
//  Class:      CDragDropSnapin
//
//  Purpose:    Implements a snapin.
//
//--------------------------------------------------------------------
class CDragDropSnapin : public CBaseSnapin
{
    // Specify the root node of the snapin.
    typedef          CComObject<CSnapinItem<CDragDropSnapinRootItem> > t_itemRoot;

    SNAPIN_DECLARE(CDragDropSnapin);

public:
                     CDragDropSnapin();
    virtual          ~CDragDropSnapin();

    // information about the snapin and root (ie initial) node
    virtual BOOL     FStandalone()  { return TRUE; }
    virtual BOOL     FIsExtension() { return FALSE; }

    virtual BOOL     FSupportsIComponent2() {return TRUE;}

    virtual LONG     IdsDescription(void)   {return IDS_DragDropSnapinDesc;}
    virtual LONG     IdsName(void)          {return IDS_DragDropSnapinName;}

    const CSnapinInfo* Psnapininfo() { return &snapininfoDragDrop; }

    BOOL             FCutDisabled()         {return m_bDisableCut;}
    BOOL             FPasteIntoResultPane() {return m_bPasteIntoResultPane;}

    void             SetCutDisabled(BOOL b) {m_bDisableCut = b;}
    void             SetPasteIntoResultPane(BOOL b) {m_bPasteIntoResultPane = b;}

protected:
    // The column header info structures.
    static  CColumnInfoEx     s_colinfo[];
    static  INT      s_colwidths[];
    static  INT      s_ccolinfo;

protected:
    virtual CColumnInfoEx*    Pcolinfoex(INT icolinfo=0) { return s_colinfo + icolinfo; }
    virtual INT     &ColumnWidth(INT icolwidth=0) { return s_colwidths[icolwidth]; }
    virtual INT      Ccolinfoex() { return s_ccolinfo; }

private:
    BOOL              m_bDisableCut;
    BOOL              m_bPasteIntoResultPane;
};

#endif  //_DRAGDROPTEST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\sample\extension.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      extension.cpp
 *
 *  Contents:
 *
 *  History:   13-Mar-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.hxx"
#include "Extension.h"


static const WCHAR szRegistrationScript[] =
    L"HKCR"                                                                     L"\n"
    L"{"                                                                        L"\n"
    L"    %VProgID% = s '%VClassName%'"                                         L"\n"
    L"    {"                                                                    L"\n"
    L"        CLSID = s '%VCLSID%'"                                             L"\n"
    L"    }"                                                                    L"\n"
    L"    %VVersionIndependentProgID% = s '%VClassName%'"                       L"\n"
    L"    {"                                                                    L"\n"
    L"        CurVer = s '%VProgID%'"                                           L"\n"
    L"    }"                                                                    L"\n"
    L"    NoRemove CLSID"                                                       L"\n"
    L"    {"                                                                    L"\n"
    L"        ForceRemove %VCLSID% = s '%VClassName%'"                          L"\n"
    L"        {"                                                                L"\n"
    L"            ProgID = s '%VProgID%'"                                       L"\n"
    L"            VersionIndependentProgID = s '%VVersionIndependentProgID%'"   L"\n"
    L"            InprocServer32 = s '%VModule%'"                               L"\n"
    L"            {"                                                            L"\n"
    L"                val ThreadingModel = s 'Apartment'"                       L"\n"
    L"            }"                                                            L"\n"
    L"        }"                                                                L"\n"
    L"    }"                                                                    L"\n"
    L"}"                                                                        L"\n"
    L"HKLM"                                                                     L"\n"
    L"{"                                                                        L"\n"
    L"    NoRemove Software"                                                    L"\n"
    L"    {"                                                                    L"\n"
    L"        NoRemove Microsoft"                                               L"\n"
    L"        {"                                                                L"\n"
    L"            NoRemove MMC"                                                 L"\n"
    L"            {"                                                            L"\n"
    L"                NoRemove SnapIns"                                         L"\n"
    L"                {"                                                        L"\n"
    L"                    ForceRemove %VCLSID%"                                 L"\n"
    L"                    {"                                                    L"\n"
    L"                        val NameString = s '%VSnapinName%'"               L"\n"
    L"                    }"                                                    L"\n"
    L"                }"                                                        L"\n"
    L"                NoRemove NodeTypes"                                       L"\n"
    L"                {"                                                        L"\n"
    L"                    NoRemove %VExtendedNodeType%"                         L"\n"
    L"                    {"                                                    L"\n"
    L"                        NoRemove Extensions"                              L"\n"
    L"                        {"                                                L"\n"
    L"                            NoRemove %VExtensionType%"                    L"\n"
    L"                            {"                                            L"\n"
    L"                                val %VCLSID% = s '%VClassName%'"          L"\n"
    L"                            }"                                            L"\n"
    L"                        }"                                                L"\n"
    L"                    }"                                                    L"\n"
    L"                }"                                                        L"\n"
    L"            }"                                                            L"\n"
    L"        }"                                                                L"\n"
    L"    }"                                                                    L"\n"
    L"}";


/*+-------------------------------------------------------------------------*
 * CExtension::UpdateRegistry
 *
 *
 *--------------------------------------------------------------------------*/

HRESULT WINAPI CExtension::UpdateRegistry (
	BOOL			bRegister,
	ExtensionType	eExtType,
	const CLSID&	clsidSnapIn,	
	LPCWSTR			pszClassName,
	LPCWSTR			pszProgID,
	LPCWSTR			pszVersionIndependentProgID,
	LPCWSTR			pszExtendedNodeType)
{
    DECLARE_SC (sc, _T("CExtension::UpdateRegistry"));

	if ((eExtType < eExtType_First) || (eExtType > eExtType_Last))
		return ((sc = E_INVALIDARG).ToHr());

    /*
     * string-ify the CLSID
     */
    CCoTaskMemPtr<WCHAR> spszClsid;
    sc = StringFromCLSID (clsidSnapIn, &spszClsid);
    if (sc)
        return sc.ToHr();

    static const LPCWSTR rgExtTypes[eExtType_Count] =
    {
        L"Namespace",       // eExtType_Namespace
        L"ContextMenu",     // eExtType_ContextMenu
        L"PropertySheet",   // eExtType_PropertySheet
        L"Taskpad",         // eExtType_Taskpad
        L"View",			// eExtType_View
    };

	/*
	 * get the filename for the module
	 */
	USES_CONVERSION;
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName (_Module.GetModuleInstance(), szModule, countof(szModule));

    /*
     * specify the standard object substitution parameters for CRegObject
     */
    ::ATL::ATL::CRegObject ro;  // hack around nested namespace bug in ATL30
    _ATL_REGMAP_ENTRY rgObjEntries[] =
    {
        {   L"VModule",                   T2W(szModule)                 },
        {   L"VCLSID",                    spszClsid                     },
        {   L"VExtendedNodeType",         pszExtendedNodeType          	},
        {   L"VClassName",                pszClassName                  },
        {   L"VProgID",                   pszProgID                     },
        {   L"VVersionIndependentProgID", pszVersionIndependentProgID   },
        {   L"VExtensionType",            rgExtTypes[eExtType]			},
        {   L"VSnapinName",               pszClassName}
    };

    for (int i = 0; i < countof (rgObjEntries); i++)
    {
        sc = ro.AddReplacement (rgObjEntries[i].szKey, rgObjEntries[i].szData);
        if (sc)
            return (sc.ToHr());
    }

    /*
     * (un)register!
     */
    sc = (bRegister) ? ro.StringRegister   (szRegistrationScript)
                     : ro.StringUnregister (szRegistrationScript);

    return sc.ToHr();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\sample\extension.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      extension.h
 *
 *  Contents:
 *
 *  History:   13-Mar-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

class CExtension :
    public CComObjectRoot
{
protected:
    enum ExtensionType
    {
        eExtType_Namespace,
        eExtType_ContextMenu,
        eExtType_PropertySheet,
        eExtType_Taskpad,
        eExtType_View,

        // must be last
        eExtType_Count,
		eExtType_First = eExtType_Namespace,
		eExtType_Last  = eExtType_View,
    };

protected:
    static HRESULT WINAPI UpdateRegistry (
		BOOL			bRegister,
		ExtensionType	eType,
		const CLSID&	clsidSnapIn,
		LPCWSTR			pszClassName,
		LPCWSTR			pszProgID,
		LPCWSTR			pszVersionIndependentProgID,
		LPCWSTR			pszExtendedNodeType);
};

#define DECLARE_EXTENSION_REGISTRATION(                           	\
	eType,															\
    clsid,                                                          \
    szClassName,                                                    \
    szProgID,                                                       \
    szVersionIndependentProgID,                                     \
    szExtendedNodeType)                                             \
public: static HRESULT WINAPI UpdateRegistry(BOOL bRegister)        \
{                                                                   \
    return (CExtension::UpdateRegistry (                            \
				bRegister,                                          \
				eType,                                              \
				clsid,                                              \
				OLESTR(szClassName),                                \
				OLESTR(szProgID),                                   \
				OLESTR(szVersionIndependentProgID),                 \
				OLESTR(szExtendedNodeType)));                       \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\sample\nodetypes.cxx ===
/*
 *      nodetypes.cxx
 *
 *
 *      Copyright (c) 1998 Microsoft Corporation
 *
 *      PURPOSE:        Instantiates all guids, nodetypes etc.
 *
 *
 *      OWNER:          vivekj
 */

#include <stdafx.hxx>
#include <objbase.h>
#include <initguid.h>

//--------------------------------------------------------------------------
// Collect all the Snapin CLSIDs.

// DO NOT CHANGE THE COMMENT ON THE NEXT LINE
//-----------------_SUBSYSTEM_-----------------

#include "TestSnapins.h"
#include "TestSnapins_i.c"

//--------------------------------------------------------------------------
// This instantiates all the nodetypes
#define DEFINE_CONST
#include <nodetypes.hxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\sample\powertest.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      powertest.cpp
 *
 *  Contents:  Implements ACPI test snap-in
 *
 *  History:   29-Feb-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.hxx"
#include "powertest.h"



/*+-------------------------------------------------------------------------*
 * ShowReturn
 *
 *
 *--------------------------------------------------------------------------*/

static void ShowReturn (const SC& sc, LPCTSTR pszPrefix)
{
    tstring strMessage = pszPrefix;

	/*
	 * Successful HRESULTs will map to unsuccessful Win32 error codes,
	 * so if the SC doesn't contain an error, give it S_OK so GetErrorMessage
	 * doesn't return confusing error text.
	 */
	SC scLocal = sc;
	if (!scLocal.IsError())
		scLocal = S_OK;

    TCHAR szErrorMessage[256];
    scLocal.GetErrorMessage (256, szErrorMessage);
    strMessage += szErrorMessage;

	if (!sc.IsError() && !(sc == S_OK))
	{
		strMessage += _T("  ");

		if (sc == S_FALSE)
			strMessage += _T("(S_FALSE)");
		else
			strMessage += tstring(_T("(")) + _itot(sc.GetCode(), szErrorMessage, 10) + _T(")");
	}

    MessageBox (NULL, strMessage.data(), _T("Debug message"), MB_OK);
}


/*+=========================================================================*
 *                                                                          *
 *                    CPowerTestSnapinItem Implmentation                    *
 *                                                                          *
 *==========================================================================*/


#define DECLARE_SNAPIN_MENU_ITEM(id, dwGray) \
    { id, id, id, CCM_INSERTIONPOINTID_PRIMARY_TOP, 0, dwMenuAlwaysEnable, dwGray, dwMenuNeverChecked}

SnapinMenuItem CPowerTestSnapinItem::s_rgMenuItems[] =
{
    DECLARE_SNAPIN_MENU_ITEM (IDS_CreateConsolePower,   eFlag_ConsolePowerCreated),
    DECLARE_SNAPIN_MENU_ITEM (IDS_ReleaseConsolePower,  eFlag_ConsolePowerNotCreated),
    DECLARE_SNAPIN_MENU_ITEM (IDS_SetExecutionState,    eFlag_ConsolePowerNotCreated),
    DECLARE_SNAPIN_MENU_ITEM (IDS_ResetIdleTimer,       eFlag_ConsolePowerNotCreated),
};


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::CPowerTestSnapinItem
 *
 *
 *--------------------------------------------------------------------------*/

CPowerTestSnapinItem::CPowerTestSnapinItem() :
    m_cSystem        (0),
    m_cDisplay       (0),
    m_dwAdviseCookie (0)
{
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::DwFlagsMenuGray
 *
 *
 *--------------------------------------------------------------------------*/

DWORD CPowerTestSnapinItem::DwFlagsMenuGray(void)
{
    return ((m_spConsolePower) ? eFlag_ConsolePowerCreated : eFlag_ConsolePowerNotCreated);
}


/*+-------------------------------------------------------------------------*
 * tstring* CPowerTestSnapinItem::PstrDisplayName
 *
 *
 *--------------------------------------------------------------------------*/

const tstring* CPowerTestSnapinItem::PstrDisplayName()
{
    return (&Psnapin()->StrDisplayName());
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::ScGetResultViewType
 *
 *
 *--------------------------------------------------------------------------*/

SC CPowerTestSnapinItem::ScGetResultViewType(LPOLESTR* ppViewType, long* pViewOptions)
{
    DECLARE_SC (sc, _T("CPowerTestSnapinItem::ScGetResultViewType"));

    /*
     * use the standard message view OCX
     */
    sc = StringFromCLSID (CLSID_MessageView, ppViewType);
    if (sc)
        return (sc);

    /*
     * use only the OCX
     */
    *pViewOptions = MMC_VIEW_OPTIONS_NOLISTVIEWS;

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::ScOnShow
 *
 * WM_SHOW handler for CPowerTestSnapinItem.
 *--------------------------------------------------------------------------*/

SC CPowerTestSnapinItem::ScOnShow(CComponent *pComponent, BOOL fSelect)
{
    DECLARE_SC (sc, _T("CPowerTestSnapinItem::ScOnShow"));

    if (fSelect)
    {
        if (pComponent == NULL)
            return (sc = E_UNEXPECTED);

        IConsole* pConsole = pComponent->IpConsole();
        if (pConsole == NULL)
            return (sc = E_NOINTERFACE);

        CComPtr<IUnknown> spResultUnk;
        sc = pConsole->QueryResultView (&spResultUnk);
        if (sc)
            return (sc);

        m_spMsgView = spResultUnk;
        if (m_spMsgView == NULL)
            return (sc = E_NOINTERFACE);

        UpdateMessageView();
    }
    else
    {
        m_spMsgView.Release();
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::UpdateMessageView
 *
 *
 *--------------------------------------------------------------------------*/

void CPowerTestSnapinItem::UpdateMessageView ()
{
    if (m_spMsgView)
    {
        m_spMsgView->SetIcon      (Icon_Information);
        m_spMsgView->SetTitleText (L"Power Test Snap-in");
        m_spMsgView->SetBodyText  (GetMessageText().data());
    }
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::GetMessageText
 *
 *
 *--------------------------------------------------------------------------*/

std::wstring CPowerTestSnapinItem::GetMessageText()
{
    std::wstring strMessageText;

    if (m_spConsolePower)
    {
        WCHAR szMessageText[256];
        wsprintfW (szMessageText,
                   L"CLSID_ConsolePower created\n\n"
                   L"Current execution state:\n"
                   L"ES_SYSTEM_REQUIRED = %d\n"
                   L"ES_DISPLAY_REQUIRED = %d\n",
                   m_cSystem, m_cDisplay);

        strMessageText = szMessageText;
    }
    else
        strMessageText = L"CLSID_ConsolePower not created";

    return (strMessageText);
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::Pmenuitem
 *
 *
 *--------------------------------------------------------------------------*/

SnapinMenuItem* CPowerTestSnapinItem::Pmenuitem(void)
{
    return (s_rgMenuItems);
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::CMenuItem
 *
 *
 *--------------------------------------------------------------------------*/

INT CPowerTestSnapinItem::CMenuItem(void)
{
    return (sizeof(s_rgMenuItems) / sizeof(s_rgMenuItems[0]));
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::ScCommand
 *
 *
 *--------------------------------------------------------------------------*/

SC CPowerTestSnapinItem::ScCommand(long nCommandID, CComponent *pComponent)
{
    DECLARE_SC (sc, _T("CPowerTestSnapinItem::ScCommand"));

    switch (nCommandID)
    {
        case IDS_CreateConsolePower:
            sc = ScOnCreateConsolePower (pComponent);
            break;

        case IDS_ReleaseConsolePower:
            sc = ScOnReleaseConsolePower (pComponent);
            break;

        case IDS_ResetIdleTimer:
            sc = ScOnResetIdleTimer (pComponent);
            break;

        case IDS_SetExecutionState:
            sc = ScOnSetExecutionState (pComponent);
            break;

        default:
            sc = E_UNEXPECTED;
            break;
    }

    UpdateMessageView();
    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::ScOnCreateConsolePower
 *
 *
 *--------------------------------------------------------------------------*/

SC CPowerTestSnapinItem::ScOnCreateConsolePower (CComponent *pComponent)
{
    DECLARE_SC (sc, _T("CPowerTestSnapinItem::ScOnCreateConsolePower"));

    /*
     * create the CLSID_ConsolePower object
     */
    sc = m_spConsolePower.CoCreateInstance (CLSID_ConsolePower);
    if (sc)
        return (sc);

    /*
     * create a CPowerTestConsolePowerSinkImpl
     */
    CComObject<CPowerTestConsolePowerSinkImpl>* pPowerSinkImpl;
    sc = CComObject<CPowerTestConsolePowerSinkImpl>::CreateInstance (&pPowerSinkImpl);
    if (sc)
        return (ReleaseAll(), sc);

    m_spConsolePowerSink = pPowerSinkImpl;

    /*
     * set up the event sink
     */
    sc = AtlAdvise (m_spConsolePower, m_spConsolePowerSink, IID_IConsolePowerSink, &m_dwAdviseCookie);
    if (sc)
        return (ReleaseAll(), sc);

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::ScOnReleaseConsolePower
 *
 *
 *--------------------------------------------------------------------------*/

SC CPowerTestSnapinItem::ScOnReleaseConsolePower (CComponent *pComponent)
{
    DECLARE_SC (sc, _T("CPowerTestSnapinItem::ScOnCreateConsolePower"));

    AtlUnadvise (m_spConsolePower, IID_IConsolePowerSink, m_dwAdviseCookie);
    ReleaseAll();

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::ReleaseAll
 *
 *
 *--------------------------------------------------------------------------*/

void CPowerTestSnapinItem::ReleaseAll()
{
    m_spConsolePower.Release();
    m_spConsolePowerSink.Release();
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::ScOnResetIdleTimer
 *
 *
 *--------------------------------------------------------------------------*/

SC CPowerTestSnapinItem::ScOnResetIdleTimer (CComponent *pComponent)
{
    DECLARE_SC (sc, _T("CPowerTestSnapinItem::ScOnCreateConsolePower"));

    if (!m_spConsolePower)
    {
        MMCErrorBox (sc = E_UNEXPECTED);
        sc.Clear();
        return (sc);
    }

    CPowerTestDlg dlg(true);

    if (dlg.DoModal() == IDOK)
    {
        sc = m_spConsolePower->ResetIdleTimer (dlg.GetAddFlags());
        ShowReturn (sc, _T("IConsolePower::ResetIdleTimer returned:\n\n"));
    }

    return (sc);
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem::ScOnSetExecutionState
 *
 *
 *--------------------------------------------------------------------------*/

SC CPowerTestSnapinItem::ScOnSetExecutionState (CComponent *pComponent)
{
    DECLARE_SC (sc, _T("CPowerTestSnapinItem::ScOnCreateConsolePower"));

    if (!m_spConsolePower)
    {
        MMCErrorBox (sc = E_UNEXPECTED);
        sc.Clear();
        return (sc);
    }


    CPowerTestDlg dlg;

    if (dlg.DoModal() == IDOK)
    {
        DWORD dwAdd    = dlg.GetAddFlags();
        DWORD dwRemove = dlg.GetRemoveFlags();

        sc = m_spConsolePower->SetExecutionState (dwAdd, dwRemove);
        ShowReturn (sc, _T("IConsolePower::SetExecutionState returned:\n\n"));

        if (sc == S_OK)
        {
            if (dwAdd & ES_SYSTEM_REQUIRED)         m_cSystem++;
            if (dwAdd & ES_DISPLAY_REQUIRED)        m_cDisplay++;
            if (dwRemove & ES_SYSTEM_REQUIRED)      m_cSystem--;
            if (dwRemove & ES_DISPLAY_REQUIRED)     m_cDisplay--;
        }
    }

    return (sc);
}



/*+=========================================================================*
 *                                                                          *
 *               CPowerTestConsolePowerSinkImpl Implmentation               *
 *                                                                          *
 *==========================================================================*/


/*+-------------------------------------------------------------------------*
 * CPowerTestConsolePowerSinkImpl::OnPowerBroadcast
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CPowerTestConsolePowerSinkImpl::OnPowerBroadcast (
    WPARAM      wParam,
    LPARAM      lParam,
    LRESULT*    plResult)
{
    if (plResult == NULL)
        return (E_INVALIDARG);

    if (wParam == PBT_APMQUERYSUSPEND)
        *plResult = BROADCAST_QUERY_DENY;
    else
        *plResult = TRUE;

    return (S_OK);
}



/*+=========================================================================*
 *                                                                          *
 *                      CPowerTestSnapin Implmentation                      *
 *                                                                          *
 *==========================================================================*/


SNR     CPowerTestSnapin::s_rgsnr[] =
{
    SNR(&nodetypePowerTestRoot, snrEnumSP ),
};

LONG  CPowerTestSnapin::s_rgiconid[]           = {0};
LONG  CPowerTestSnapin::s_iconidStatic         = 0;


// include members needed for every snapin.
SNAPIN_DEFINE(CPowerTestSnapin);


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapin::CPowerTestSnapin
 *
 *
 *--------------------------------------------------------------------------*/

CPowerTestSnapin::CPowerTestSnapin() :
    m_strDisplayName (_T("PowerTest Snap-in"))
{
    m_pstrDisplayName = &m_strDisplayName;
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapin::~CPowerTestSnapin
 *
 *
 *--------------------------------------------------------------------------*/

CPowerTestSnapin::~CPowerTestSnapin()
{
}


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapin::ScInitBitmaps
 *
 *
 *--------------------------------------------------------------------------*/

SC CPowerTestSnapin::ScInitBitmaps(void)
{
    DECLARE_SC (sc, _T("CPowerTestSnapin::ScInitBitmaps"));

    if (BitmapSmall())
        return (sc);

    sc = CBaseSnapin::ScInitBitmaps();
    if (sc)
        return (sc);

    BitmapSmall().DeleteObject();
    sc = BitmapSmall().LoadBitmap(IDB_POWER16) ? S_OK : E_FAIL;
    if (sc)
        return sc;

    BitmapLarge().DeleteObject();
    sc = BitmapLarge().LoadBitmap(IDB_POWER32) ? S_OK : E_FAIL;
    if (sc)
        return sc;

    BitmapStaticSmall().DeleteObject();
    sc = BitmapStaticSmall().LoadBitmap(IDB_POWER16) ? S_OK : E_FAIL;
    if (sc)
        return sc;

    BitmapStaticSmallOpen().DeleteObject();
    sc = BitmapStaticSmallOpen().LoadBitmap(IDB_POWER16) ? S_OK : E_FAIL;
    if (sc)
        return sc;

    BitmapStaticLarge().DeleteObject();
    sc = BitmapStaticLarge().LoadBitmap(IDB_POWER32) ? S_OK : E_FAIL;
    if (sc)
        return sc;

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\sample\powertest.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 00
 *
 *  File:      powertest.h
 *
 *  Contents:  Interface for ACPI test snap-in
 *
 *  History:   29-Feb-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapinItem
 *
 *
 *--------------------------------------------------------------------------*/

class CPowerTestSnapinItem : public CBaseSnapinItem
{
public:
    CPowerTestSnapinItem();

    BEGIN_COM_MAP(CPowerTestSnapinItem)
        COM_INTERFACE_ENTRY(IDataObject) // Cant have empty map so add IDataObject
    END_COM_MAP()

public:
    virtual const tstring*  PstrDisplayName(void);
    virtual BOOL            FIsContainer(void)          { return FALSE; }
    virtual BOOL            FUsesResultList(void)       { return FALSE; }
    virtual const CNodeType*Pnodetype(void)             { return &nodetypePowerTestRoot; }
    virtual SC              ScGetField(DAT dat, tstring& strField)  { strField.erase(); return S_OK;}
    virtual SC              ScGetResultViewType(LPOLESTR* ppViewType, long* pViewOptions);
    virtual SC              ScOnShow(CComponent *pComponent, BOOL fSelect);
    virtual SnapinMenuItem *Pmenuitem(void);
    virtual INT             CMenuItem(void);
    virtual SC              ScCommand(long nCommandID, CComponent *pComponent = NULL);
    virtual DWORD           DwFlagsMenuGray(void);

    // There is no list-view so following methods are empty.
    virtual SC       ScInitializeResultView(CComponent *pComponent) { return S_OK;}
    virtual SC       ScOnAddImages(IImageList* ipResultImageList) { return S_OK;}

private:
    // bits returned from DwFlagsMenuGray
    enum
    {
        eFlag_ConsolePowerCreated    = 0x00000001,
        eFlag_ConsolePowerNotCreated = 0x00000002,
    };

    std::wstring GetMessageText();

    void ReleaseAll              ();
    void UpdateMessageView       ();
    SC   ScOnCreateConsolePower  (CComponent *pComponent);
    SC   ScOnReleaseConsolePower (CComponent *pComponent);
    SC   ScOnResetIdleTimer      (CComponent *pComponent);
    SC   ScOnSetExecutionState   (CComponent *pComponent);


private:
    CComQIPtr<IMessageView>     m_spMsgView;
    CComPtr<IConsolePower>      m_spConsolePower;
    CComPtr<IConsolePowerSink>  m_spConsolePowerSink;

    DWORD                       m_dwAdviseCookie;
    int                         m_cSystem;
    int                         m_cDisplay;

    static SnapinMenuItem       s_rgMenuItems[];
};


/*+-------------------------------------------------------------------------*
 * CPowerTestConsolePowerSinkImpl
 *
 *
 *--------------------------------------------------------------------------*/

class CPowerTestConsolePowerSinkImpl :
    public CComObjectRoot,
    public IConsolePowerSink
{
    BEGIN_COM_MAP(CPowerTestConsolePowerSinkImpl)
        COM_INTERFACE_ENTRY(IConsolePowerSink)
    END_COM_MAP()

    DECLARE_NOT_AGGREGATABLE(CPowerTestConsolePowerSinkImpl);

public:
    STDMETHOD (OnPowerBroadcast)(WPARAM wParam, LPARAM lParam, LRESULT* plResult);
};


/*+-------------------------------------------------------------------------*
 * CPowerTestSnapin
 *
 *
 *--------------------------------------------------------------------------*/

class CPowerTestSnapin : public CBaseSnapin
{
    typedef                 CComObject<CSnapinItem<CPowerTestSnapinItem> > t_itemRoot;

    SNAPIN_DECLARE( CPowerTestSnapin);

public:
                                  CPowerTestSnapin();
        virtual                   ~CPowerTestSnapin();

        // information about the snapin and root (ie initial) node
        virtual BOOL              FStandalone()          {return TRUE;} // only an extension snapin.
        virtual BOOL              FIsExtension()         {return FALSE;}

        virtual LONG              IdsDescription(void)   {return IDS_POWERTESTSNAPIN;}
        virtual LONG              IdsName(void)          {return IDS_POWERTESTSNAPIN;}
        virtual SC                ScInitBitmaps(void);

        const CSnapinInfo *       Psnapininfo()          {return &snapininfoPowerTest;}

private:
    tstring m_strDisplayName;
};


/*+-------------------------------------------------------------------------*
 * CPowerTestDlg
 *
 *
 *--------------------------------------------------------------------------*/

class CPowerTestDlg : public CDialogImpl<CPowerTestDlg>
{
public:
    CPowerTestDlg(bool fResetTimer = false) :
        m_fResetTimer (fResetTimer),
        m_dwAdd       (0),
        m_dwRemove    (0)
    {}


    DWORD GetAddFlags    () const       { return (m_dwAdd);     }
    DWORD GetRemoveFlags () const       { return (m_dwRemove);  }

    enum { IDD = IDD_ConsolePowerTest };

BEGIN_MSG_MAP(CPowerTestDlg)
    MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
    COMMAND_ID_HANDLER(IDOK, OnOK)
    COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        if (m_fResetTimer)
        {
            SetWindowText (_T("IConsolePower::ResetIdleTimer"));
            ::EnableWindow (GetDlgItem (IDC_RemoveGroup),   false);
            ::EnableWindow (GetDlgItem (IDC_RemoveSystem),  false);
            ::EnableWindow (GetDlgItem (IDC_RemoveDisplay), false);
        }

        return 1;  // Let the system set the focus
    }

    LRESULT OnOK(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        if (IsDlgButtonChecked (IDC_AddSystem))     m_dwAdd    |= ES_SYSTEM_REQUIRED;
        if (IsDlgButtonChecked (IDC_AddDisplay))    m_dwAdd    |= ES_DISPLAY_REQUIRED;

        if (IsDlgButtonChecked (IDC_RemoveSystem))  m_dwRemove |= ES_SYSTEM_REQUIRED;
        if (IsDlgButtonChecked (IDC_RemoveDisplay)) m_dwRemove |= ES_DISPLAY_REQUIRED;

        EndDialog(wID);
        return 0;
    }

    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled)
    {
        EndDialog(wID);
        return 0;
    }

private:
    const bool  m_fResetTimer;
    DWORD       m_dwAdd;
    DWORD       m_dwRemove;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\sample\ocxcaching.cpp ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       ocxcaching.cpp
//
//  Contents:   Classes that implement OCX caching snapin using the framework.
//
//--------------------------------------------------------------------
#include "stdafx.hxx"

//+-------------------------------------------------------------------
//
//  Member:      COCXCachingSnapinRootItem::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC COCXCachingSnapinRootItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("COCXCachingSnapinRootItem::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 3; // use an enum instead of 3

    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_OCXCachingRoot);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      COCXCachingSnapinRootItem::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC COCXCachingSnapinRootItem::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("COCXCachingSnapinRootItem::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = _T("OCX Caching Snapin Root Node");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      COCXCachingSnapinRootItem::ScCreateChildren
//
//  Synopsis:    Create any children (nodes & leaf items) for this item.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC COCXCachingSnapinRootItem::ScCreateChildren ()
{
    DECLARE_SC(sc, _T("COCXCachingSnapinRootItem::ScCreateChildren"));

    COCXContainer *   pitemChild      = NULL;
    COCXContainer *   pitemPrevious   = NULL;

    // Create the 1st child node for calendar OCX.
    sc = COCXContainer::ScCreateLVContainer(this, pitemPrevious, &pitemChild, FALSE); // Why FALSE???
    if (sc)
        return sc;

    pitemChild->SetOCXGUID(TEXT("{8E27C92B-1264-101C-8A2F-040224009C02}"));
    pitemPrevious = pitemChild;

    // Create the 2nd child node for calendar OCX.
    sc = COCXContainer::ScCreateLVContainer(this, pitemPrevious, &pitemChild, FALSE); // Why FALSE???
    if (sc)
        return sc;

    pitemChild->SetOCXGUID(TEXT("{2179C5D3-EBFF-11CF-B6FD-00AA00B4E220}"));
    pitemPrevious = pitemChild;

    return (sc);
}


// Initialize context menu structures. Let us have one item for demonstration.
SnapinMenuItem COCXCachingSnapinRootItem::s_rgmenuitem[] =
{
    {IDS_EnableOCXCaching, IDS_EnableOCXCaching, IDS_EnableOCXCaching, CCM_INSERTIONPOINTID_PRIMARY_TOP, NULL, dwMenuAlwaysEnable, dwMenuNeverGray, 0},
};

INT COCXCachingSnapinRootItem::s_cmenuitem = CMENUITEM(s_rgmenuitem);

// -----------------------------------------------------------------------------
SnapinMenuItem *COCXCachingSnapinRootItem::Pmenuitem(void)
{
    return s_rgmenuitem;
}

// -----------------------------------------------------------------------------
INT COCXCachingSnapinRootItem::CMenuItem(void)
{
    return s_cmenuitem;
}


//+-------------------------------------------------------------------
//
//  Member:      COCXCachingSnapinRootItem::ScCommand
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC COCXCachingSnapinRootItem::ScCommand (long nCommandID, CComponent *pComponent)
{
    DECLARE_SC(sc, _T("COCXCachingSnapinRootItem::ScCommand"));

    COCXCachingSnapin *pSnapin = dynamic_cast<COCXCachingSnapin*>(Psnapin());
    if (!pSnapin)
        return sc;

    switch(nCommandID)
    {
    case IDS_EnableOCXCaching:
        {
            bool bCachingEnabled = pSnapin->FCacheOCX();

                pSnapin->SetCacheOCX(! bCachingEnabled);

            for (int i = 0; i < CMenuItem(); ++i)
            {
                if (s_rgmenuitem[i].lCommandID == IDS_EnableOCXCaching)
                    s_rgmenuitem[i].dwFlagsChecked = (!bCachingEnabled);
            }

        }
        break;

    default:
        sc = E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      COCXContainer::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC COCXContainer::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("COCXContainer::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 4; // use an enum instead of 4

    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_OCXContainer);

    return sc;
}


BOOL COCXContainer::FCacheOCX()
{
    COCXCachingSnapin *pSnapin = dynamic_cast<COCXCachingSnapin*>(Psnapin());
    if (!pSnapin)
        return FALSE;

    return pSnapin->FCacheOCX();
}


//+-------------------------------------------------------------------
//
//  Member:      COCXContainer::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC COCXContainer::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("COCXContainer::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = _T("OCX Container");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      COCXContainer::ScInitOCX
//
//  Synopsis:    OCX is created & attached to host. Now MMC has asked
//               us to initialize the OCX.
//
//  Arguments:   [pUnkOCX] - IUnknown of the OCX.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC COCXContainer::ScInitOCX (LPUNKNOWN pUnkOCX, IConsole* pConsole)
{
    DECLARE_SC(sc, _T("COCXContainer::ScInitOCX"));
    sc = ScCheckPointers(pUnkOCX, pConsole);
    if (sc)
        return sc;

    // Store the cached OCX ptr to provide it later in GetResultViewType2.
    if (FCacheOCX())
        m_mapOCXs.insert(CachedOCXs::value_type(pConsole, pUnkOCX));

    CComQIPtr <IPersistStreamInit> spPerStm(pUnkOCX);

    if (spPerStm)
        spPerStm->InitNew();

    return (sc);
}

IUnknown* COCXContainer::GetCachedOCX(IConsole* pConsole)
{
    CachedOCXs::iterator it = m_mapOCXs.find(pConsole);

    if (it != m_mapOCXs.end())
        return it->second;

    return NULL;
}

//+-------------------------------------------------------------------
//
//  Member:      COCXContainer::ScCreateChildren
//
//  Synopsis:    Create any children (nodes & leaf items) for this item.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC COCXContainer::ScCreateChildren ()
{
    DECLARE_SC(sc, _T("COCXContainer::ScCreateChildren"));

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      COCXContainer::ScCreateLVContainer
//
//  Synopsis:    Do we really need this method?
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC COCXContainer::ScCreateLVContainer(CBaseSnapinItem *pitemParent, CBaseSnapinItem *pitemPrevious, COCXContainer ** ppitem, BOOL fNew)
{
    DECLARE_SC(sc, _T("COCXCachingSnapinRootItem::ScCreateLVContainer"));
    t_item *   pitem   = NULL;
    *ppitem = NULL;

    // What to do here?
    sc = ::ScCreateItem(pitemParent, pitemPrevious, &pitem, fNew);
    if (sc)
        return sc;

    *ppitem = pitem;

    return (sc);
}

//-------------------------------------------------------------------------------------
// class COCXCachingSnapin

#pragma BEGIN_CODESPACE_DATA
SNR     COCXCachingSnapin::s_rgsnr[] =
{
    SNR(&nodetypeOCXCachingRoot,         snrEnumSP ),              // Standalone snapin.
    SNR(&nodetypeOCXCachingContainer1,   snrEnumSP ),  // enumerates this node in the scope pane
    SNR(&nodetypeOCXCachingContainer2,   snrEnumSP ),  // enumerates this node in the scope pane
};

LONG  COCXCachingSnapin::s_rgiconid[]           = {3};
LONG  COCXCachingSnapin::s_iconidStatic         = 2;


CColumnInfoEx COCXCachingSnapin::s_colinfo[] =
{
    CColumnInfoEx(_T("Column Name0"),   LVCFMT_LEFT,    180,    datString1),
    CColumnInfoEx(_T("Column Name1"),   LVCFMT_LEFT,    180,    datString2),
    CColumnInfoEx(_T("Column Name2"),   LVCFMT_LEFT,    180,    datString3),
};

INT COCXCachingSnapin::s_ccolinfo = sizeof(s_colinfo) / sizeof(CColumnInfoEx);
INT COCXCachingSnapin::s_colwidths[1];
#pragma END_CODESPACE_DATA

// include members needed for every snapin.
SNAPIN_DEFINE( COCXCachingSnapin);

/* COCXCachingSnapin::COCXCachingSnapin
 *
 * PURPOSE:             Constructor
 *
 * PARAMETERS: None
 *
 */
COCXCachingSnapin::COCXCachingSnapin()
{
    m_pstrDisplayName = new tstring();

    m_bCacheOCX = false;

    *m_pstrDisplayName = _T("OCX Caching Snapin Root");
}

/* COCXCachingSnapin::~COCXCachingSnapin
 *
 * PURPOSE:             Destructor
 *
 * PARAMETERS: None
 *
 */
COCXCachingSnapin::~COCXCachingSnapin()
{
    delete m_pstrDisplayName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\sample\ocxcaching.h ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       ocxcaching.h
//
//  Contents:   Classes that implement OCX caching snapin using the framework.
//
//--------------------------------------------------------------------
#ifndef _OCXCACHING_H_
#define _OCXCACHING_H_

// Forward declarations.
class COCXContainer;

//+-------------------------------------------------------------------
//
//  Class:      COCXCachingSnapinRootItem
//
//  Purpose:    Implements the root item for a standalone snapin.
//
//--------------------------------------------------------------------
class COCXCachingSnapinRootItem : public CBaseSnapinItem
{
    typedef          CBaseSnapinItem super;

    // Used by CBaseSnapinItem::ScCreateItem, connect this item with its children.
    typedef          CComObject<CSnapinItem<COCXCachingSnapinRootItem> >          t_item;
    typedef          CComObject<CSnapinItem<COCXContainer> > t_itemChild; // Who is my child?

public:
    COCXCachingSnapinRootItem( void )   {} // Raw constructor - use only for static item.
    virtual          ~COCXCachingSnapinRootItem( void ) {}

    BEGIN_COM_MAP(COCXCachingSnapinRootItem)
        COM_INTERFACE_ENTRY(IDataObject) // Cant have empty map so add IDataObject
    END_COM_MAP()

protected:
    // Item tree related information

    // node type related information
    virtual const CNodeType* Pnodetype( void )     { return &nodetypeSampleRoot;}

    // the display name of the item
    virtual const tstring* PstrDisplayName( void ) { return &m_strDisplayName;}

    // Get ListView data (GetDisplayInfo calls this).
    virtual SC       ScGetField(DAT dat, tstring& strField);

    // Image list information
    virtual LONG     Iconid() { return m_uIconIndex; }
    virtual LONG     OpenIconid() { return m_uIconIndex; }

    virtual BOOL     FIsContainer( void ) { return TRUE; }

    // Context menu support
    virtual SnapinMenuItem *Pmenuitem(void);
    virtual INT             CMenuItem(void);
    virtual SC              ScCommand(long nCommandID, CComponent *pComponent = NULL);
    virtual DWORD           DwFlagsMenuChecked(void)          { return TRUE;}
public:
    virtual SC       ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex = NULL, INT ccolinfoex = 0, BOOL fIsRoot = FALSE);

public:
    // Creates children for the node
    virtual SC       ScCreateChildren( void );

protected:
    tstring          m_strDisplayName;
    UINT             m_uIconIndex;

    // For context menus
    static SnapinMenuItem  s_rgmenuitem[];
    static INT             s_cmenuitem;
};



//+-------------------------------------------------------------------
//
//  Class:      COCXContainer
//
//  Purpose:    Implements a scope pane item.
//
//--------------------------------------------------------------------
class COCXContainer : public CBaseSnapinItem
{
    typedef          CBaseSnapinItem super;

    // Used by CBaseSnapinItem::ScCreateItem, connect this item with its children.
    typedef          CComObject<CSnapinItem<COCXContainer> > t_item;

    // If we cache OCX's then it should be cached per IComponent. But this CBaseSnapinItem based
    // container is per snapin (not per IComponent) so we use a map to store the per IComponent OCX.
    typedef          std::map<IConsole*, IUnknownPtr>  CachedOCXs;

public:
    COCXContainer( void ) {}
    virtual          ~COCXContainer( void ) {}

    BEGIN_COM_MAP(COCXContainer)
        COM_INTERFACE_ENTRY(IDataObject) // Cant have empty map so add IDataObject
    END_COM_MAP()
protected:
    // Item tree related information

    // node type related information
    const CNodeType *Pnodetype( void )                { return &nodetypeSampleLVContainer;}

    // the display name of the item
    virtual const tstring*    PstrDisplayName( void ) { return &m_strDisplayName;}

    // Get ListView data (GetDisplayInfo calls this).
    virtual SC                ScGetField(DAT dat, tstring& strField);

    // Image list information
    virtual LONG     Iconid()     { return m_uIconIndex; }
    virtual LONG     OpenIconid() { return m_uIconIndex; }

    // This item attributes.
    virtual BOOL     FIsContainer( void ) { return TRUE; }

    virtual BOOL     FUsesResultList()    { return FALSE;}
    virtual BOOL     FResultPaneIsOCX()   { return TRUE; }
    virtual SC       ScGetOCXCLSID(tstring& strclsidOCX) { strclsidOCX = m_strOCX; return S_OK;}

    virtual BOOL     FAllowMultiSelectionForChildren() { return FALSE;}

    virtual SC       ScInitOCX(LPUNKNOWN pUnkOCX, IConsole* pConsole);
    virtual BOOL     FCacheOCX();
    virtual IUnknown* GetCachedOCX(IConsole* pConsole);

    // There is no list-view so following methods are empty.
    virtual SC       ScInitializeResultView(CComponent *pComponent) { return S_OK;}
    virtual SC       ScOnAddImages(IImageList* ipResultImageList) { return S_OK;}

public:
    virtual SC       ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex = NULL, INT ccolinfoex = 0, BOOL fIsRoot = FALSE);

public:
    // Creates children for the node
    virtual SC       ScCreateChildren( void );
    static SC        ScCreateLVContainer(CBaseSnapinItem *pitemParent, CBaseSnapinItem *pitemPrevious, COCXContainer ** ppitem, BOOL fNew);

    void     SetOCXGUID(LPCTSTR szGUID)      { m_strOCX = szGUID;}

protected:
//    virtual SC       ScGetVerbs(DWORD * pdwVerbs);

protected:
    tstring          m_strDisplayName;
    UINT             m_uIconIndex;

    CachedOCXs       m_mapOCXs;
    tstring          m_strOCX;
};


//+-------------------------------------------------------------------
//
//  Class:      COCXCachingSnapin
//
//  Purpose:    Implements a snapin.
//
//--------------------------------------------------------------------
class COCXCachingSnapin : public CBaseSnapin
{
    // Specify the root node of the snapin.
    typedef          CComObject<CSnapinItem<COCXCachingSnapinRootItem> > t_itemRoot;

    SNAPIN_DECLARE(COCXCachingSnapin);

public:
                     COCXCachingSnapin();
    virtual          ~COCXCachingSnapin();

    // information about the snapin and root (ie initial) node
    virtual BOOL     FStandalone()  { return TRUE; }
    virtual BOOL     FIsExtension() { return FALSE; }

    virtual BOOL     FSupportsIComponent2() {return TRUE;}

    virtual LONG     IdsDescription(void)   {return IDS_OCXCachingRoot;}
    virtual LONG     IdsName(void)          {return IDS_OCXCachingSnapin;}

    const CSnapinInfo* Psnapininfo() { return &snapininfoOCXCaching; }
            bool     FCacheOCX()     { return m_bCacheOCX;}
            void     SetCacheOCX(bool b) { m_bCacheOCX = b;}

protected:
    // The column header info structures.
    static  CColumnInfoEx     s_colinfo[];
    static  INT      s_colwidths[];
    static  INT      s_ccolinfo;

    bool                   m_bCacheOCX;

protected:
    virtual CColumnInfoEx*    Pcolinfoex(INT icolinfo=0) { return s_colinfo + icolinfo; }
    virtual INT     &ColumnWidth(INT icolwidth=0) { return s_colwidths[icolwidth]; }
    virtual INT      Ccolinfoex() { return s_ccolinfo; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\sample\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TestSnapins.rc
//
#define IDR_TESTSNAPINS_TYPELIB         1
#define IDS_LVContainer                 2
#define IDS_LVLeafItem                  3
#define IDS_SAMPLEROOT                  4
#define IDB_NODES16                     103
#define IDB_NODES32                     105
#define IDB_COMMONTB                    106
#define IDB_SNAPINTB                    107
#define IDB_FOLDER16                    108
#define IDB_FOLDER16OP                  109
#define IDB_FOLDER32                    110
#define IDB_POWER16                     111
#define IDB_POWER32                     112
#define IDD_ConsolePowerTest            133
#define IDS_SAMPLESNAPIN                1000
#define IDS_POWERTESTSNAPIN             1001
#define IDS_CreateConsolePower          1002
#define IDS_ReleaseConsolePower         1003
#define IDS_ResetIdleTimer              1004
#define IDS_SetExecutionState           1005
#define IDS_SampleExtnSnapinDescription 1006
#define IDS_SampleExtnSnapinName        1007
#define IDS_Component2TestROOT          1008
#define IDS_Component2SNAPIN            1009
#define IDS_Component2SNAPINDesc        1009
#define IDS_Component2SNAPINName        1010
#define IDS_NewLVItem                   1011
#define IDS_Test                        1012
#define IDS_RenameROOT                  1013
#define IDS_RenameScopeItem             1014
#define IDS_RenameResultItem            1015
#define IDS_RenameSnapinDesc            1016
#define IDS_RenameSnapinName            1017
#define IDS_DragDropRoot                1018
#define IDS_DragDropScopeItem           1019
#define IDS_DragDropResultItem          1020
#define IDS_DragDropSnapinDesc          1021
#define IDS_DragDropSnapinName          1022
#define IDS_EnablePasteInToResultItem   1023
#define IDS_DisableCut                  1024
#define IDS_OCXCachingSnapin            1025
#define IDS_OCXCachingRoot              1026
#define IDS_OCXContainer                1027
#define IDS_EnableOCXCaching            1028
#define IDC_AddGroup                    2000
#define IDC_AddSystem                   2001
#define IDC_AddDisplay                  2002
#define IDC_RemoveGroup                 2003
#define IDC_RemoveSystem                2004
#define IDC_RemoveDisplay               2005
#define IDR_EventViewExt1               3001
#define IDR_EventViewExt2               3002

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        114
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         2006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\sample\renamesnapin.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       Renamesnap.cxx
//
//  Contents:   Classes that implement Rename snapin using the framework.
//
//--------------------------------------------------------------------
#include "stdafx.hxx"


//+-------------------------------------------------------------------
//
//  Member:      CRenameRootItem::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CRenameRootItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CRenameRootItem::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 3; // use an enum instead of 3

    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_RenameROOT);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CRenameRootItem::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CRenameRootItem::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CRenameRootItem::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = _T("Root String1");
        break;

    case datString2:
        strField = _T("Root String2");
        break;

    case datString3:
        strField = _T("Root String3");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CRenameRootItem::ScCreateChildren
//
//  Synopsis:    Create any children (nodes & leaf items) for this item.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CRenameRootItem::ScCreateChildren ()
{
    DECLARE_SC(sc, _T("CRenameRootItem::ScCreateChildren"));

    t_itemChild *   pitemChild      = NULL;
    t_itemChild *   pitemPrevious   = NULL;

    // Let us create 10 items for this container.
    for (int i = 0; i < 10; ++i)
    {
        // Create the child nodes and init them.
        sc = CRenameSnapinLVLeafItem::ScCreateLVLeafItem(this, pitemPrevious, &pitemChild, FALSE); // Why FALSE???
        if (sc)
            return sc;
        pitemPrevious = pitemChild;
    }

    return (sc);
}

/*+-------------------------------------------------------------------------*
 *
 * CRenameRootItem::ScOnRename
 *
 * PURPOSE: Renames the item
 *
 * PARAMETERS: 
 *    const  tstring :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC       
CRenameRootItem::ScOnRename(const tstring& strNewName)
{
    DECLARE_SC(sc, TEXT("CRenameRootItem::ScOnRename"));

    m_strDisplayName = strNewName;

    return sc;
}

//+-------------------------------------------------------------------
//
//  Member:      CRenameSnapinLVLeafItem::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CRenameSnapinLVLeafItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CRenameSnapinLVLeafItem::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 7; // use an enum instead of 7

    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_LVLeafItem);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CRenameSnapinLVLeafItem::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CRenameSnapinLVLeafItem::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CRenameSnapinLVLeafItem::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = _T("LVLeaf String1");
        break;

    case datString2:
        strField = _T("LVLeaf String2");
        break;

    case datString3:
        strField = _T("LVLeaf String3");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}



//+-------------------------------------------------------------------
//
//  Member:      CRenameSnapinLVLeafItem::ScCreateLVLeafItem
//
//  Synopsis:    Do we really need this method?
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CRenameSnapinLVLeafItem::ScCreateLVLeafItem(CRenameRootItem *pitemParent, t_itemChild * pitemPrevious, t_itemChild ** ppitem, BOOL fNew)
{
    DECLARE_SC(sc, _T("CRenameSnapinLVLeafItem::ScCreateLVLeafItem"));
    t_itemChild *   pitem   = NULL;
    *ppitem = NULL;

    // What to do here?
    sc = ::ScCreateItem(pitemParent, pitemPrevious, &pitem, fNew);
    if (sc)
        return sc;

    *ppitem = pitem;

    return (sc);
}

// Initialize context menu structures. Let us have one item for demonstration.
SnapinMenuItem CRenameSnapinLVLeafItem::s_rgmenuitemLVLeafItem[] =
{
    {IDS_NewLVItem,        IDS_NewLVItem,        IDS_NewLVItem,        CCM_INSERTIONPOINTID_PRIMARY_TOP, NULL, dwMenuAlwaysEnable, dwMenuNeverGray,        dwMenuNeverChecked},
    {IDS_RenameScopeItem,  IDS_RenameScopeItem,  IDS_RenameScopeItem,  CCM_INSERTIONPOINTID_PRIMARY_TOP, NULL, dwMenuAlwaysEnable, dwMenuNeverGray,        dwMenuNeverChecked},
    {IDS_RenameResultItem, IDS_RenameResultItem, IDS_RenameResultItem, CCM_INSERTIONPOINTID_PRIMARY_TOP, NULL, dwMenuAlwaysEnable, dwMenuNeverGray,        dwMenuNeverChecked},
};

INT CRenameSnapinLVLeafItem::s_cmenuitemLVLeafItem = CMENUITEM(s_rgmenuitemLVLeafItem);

// -----------------------------------------------------------------------------
SnapinMenuItem *CRenameSnapinLVLeafItem::Pmenuitem(void)
{
    return s_rgmenuitemLVLeafItem;
}

// -----------------------------------------------------------------------------
INT CRenameSnapinLVLeafItem::CMenuItem(void)
{
    return s_cmenuitemLVLeafItem;
}


//+-------------------------------------------------------------------
//
//  Member:      CRenameSnapinLVLeafItem::ScCommand
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CRenameSnapinLVLeafItem::ScCommand (long nCommandID, CComponent *pComponent)
{
    DECLARE_SC(sc, _T("CRenameSnapinLVLeafItem::ScCommand"));

    switch(nCommandID)
    {
    case IDS_NewLVItem:
        sc = ScInsertResultItem(pComponent);
        break;

    case IDS_RenameScopeItem:
        sc = ScRenameScopeItem();
        break;

    case IDS_RenameResultItem:
        sc = ScRenameResultItem();
        break;

    default:
        sc = E_INVALIDARG;
        break;
    }

    return (sc);
}

/*+-------------------------------------------------------------------------*
 *
 * CRenameSnapinLVLeafItem::ScRenameScopeItem
 *
 * PURPOSE: Puts the parent scope item into rename mode.
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CRenameSnapinLVLeafItem::ScRenameScopeItem()
{
    DECLARE_SC(sc, _T("CRenameSnapinLVLeafItem::ScRenameScopeItem"));

    IConsole3Ptr spConsole3 = IpConsole(); // get a pointer to the IConsole3 interface

    sc = ScCheckPointers(spConsole3, PitemParent(), E_FAIL);
    if(sc)
        return sc;

    sc = spConsole3->RenameScopeItem(PitemParent()->Hscopeitem());

    return sc;
}

/*+-------------------------------------------------------------------------*
 *
 * CRenameSnapinLVLeafItem::ScInsertResultItem
 *
 * PURPOSE: Overrides the base class method because we need to cache the 
 *          IResultData2 and HRESULTITEM
 *
 * PARAMETERS: 
 *    CComponent * pComponent :
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC 
CRenameSnapinLVLeafItem::ScInsertResultItem(CComponent *pComponent)
{
    DECLARE_SC(sc, _T("CRenameSnapinLVLeafItem::ScInsertResultItem"));

    RESULTDATAITEM  resultdataitem;

    ASSERT(pComponent && pComponent->IpResultData());

    // Add this item
    ZeroMemory(&resultdataitem, sizeof(resultdataitem));

    resultdataitem.lParam   = Cookie();
    resultdataitem.mask             = RDI_STR | RDI_PARAM | RDI_IMAGE;
    // Callback for the display name.
    resultdataitem.str              = MMC_CALLBACK;
    // Custom icon
    resultdataitem.nImage   = (int) MMC_CALLBACK;

    sc = pComponent->IpResultData()->InsertItem(&resultdataitem);
    if (sc)
        return sc;

    // cache this item - NOTE: breaks for multiple views
    m_hresultItem = resultdataitem.itemID;
    m_spResultData2 = pComponent->IpResultData();

    return sc;
}


/*+-------------------------------------------------------------------------*
 *
 * CRenameSnapinLVLeafItem::ScRenameResultItem
 *
 * PURPOSE: Renames the list item
 *
 * RETURNS: 
 *    SC
 *
 *+-------------------------------------------------------------------------*/
SC
CRenameSnapinLVLeafItem::ScRenameResultItem()
{
    DECLARE_SC(sc, _T("CRenameSnapinLVLeafItem::ScRenameResultItem"));

    sc = ScCheckPointers(m_spResultData2, PitemParent(), E_FAIL);
    if(sc)
        return sc;

    if(m_hresultItem==NULL)
        return (sc = E_FAIL);

    sc = m_spResultData2->RenameResultItem(m_hresultItem);

    return sc;
}


//-------------------------------------------------------------------------------------
// class CRenameSnapin

#pragma BEGIN_CODESPACE_DATA
SNR     CRenameSnapin::s_rgsnr[] =
{
    SNR(&nodetypeRenameRoot,         snrEnumSP ),              // Standalone snapin.
    SNR(&nodetypeRenameLVLeafItem,   snrEnumSP | snrEnumRP ),  // enumerates this node in the scope pane and result pane.
};

LONG  CRenameSnapin::s_rgiconid[]           = {3};
LONG  CRenameSnapin::s_iconidStatic         = 2;


CColumnInfoEx CRenameSnapin::s_colinfo[] =
{
    CColumnInfoEx(_T("Column Name0"),   LVCFMT_LEFT,    180,    datString1),
    CColumnInfoEx(_T("Column Name1"),   LVCFMT_LEFT,    180,    datString2),
    CColumnInfoEx(_T("Column Name2"),   LVCFMT_LEFT,    180,    datString3),
};

INT CRenameSnapin::s_ccolinfo = sizeof(s_colinfo) / sizeof(CColumnInfoEx);
INT CRenameSnapin::s_colwidths[1];
#pragma END_CODESPACE_DATA

// include members needed for every snapin.
SNAPIN_DEFINE(CRenameSnapin);

/* CRenameSnapin::CRenameSnapin
 *
 * PURPOSE:             Constructor
 *
 * PARAMETERS: None
 *
 */
CRenameSnapin::CRenameSnapin()
{
    m_pstrDisplayName = new tstring();

    *m_pstrDisplayName = _T("Rename Snapin Root");
}

/* CRenameSnapin::~CRenameSnapin
 *
 * PURPOSE:             Destructor
 *
 * PARAMETERS: None
 *
 */
CRenameSnapin::~CRenameSnapin()
{
    delete m_pstrDisplayName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\sample\samplesnap.cxx ===
//+-------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1994 - 1999
//
//  File:       samplesnap.cxx
//
//  Contents:   Classes that implement sample snapin using the framework.
//
//--------------------------------------------------------------------
#include "stdafx.hxx"


//+-------------------------------------------------------------------
//
//  Member:      CSnapinRootItem::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSnapinRootItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CSnapinRootItem::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 3; // use an enum instead of 3

    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_SAMPLEROOT);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CSnapinRootItem::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSnapinRootItem::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CSnapinRootItem::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = _T("Root String1");
        break;

    case datString2:
        strField = _T("Root String2");
        break;

    case datString3:
        strField = _T("Root String3");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CSnapinRootItem::ScCreateChildren
//
//  Synopsis:    Create any children (nodes & leaf items) for this item.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSnapinRootItem::ScCreateChildren ()
{
    DECLARE_SC(sc, _T("CSnapinRootItem::ScCreateChildren"));

    t_itemChild *   pitemChild      = NULL;
    t_itemChild *   pitemPrevious   = NULL;

    // If creating multiple items pass "previous" parameter so that the items are linked in
    // the internal linked list which will be enumerated & inserted in scope/result pane.
    // See CBaseSnapinItem::ScCreateItem which will be called by ScCreateLVContainer.

    // Create the child nodes and init them.
    sc = CSampleSnapinLVContainer::ScCreateLVContainer(this, &pitemChild, FALSE); // Why FALSE???
    if (sc)
        return sc;
    pitemPrevious = pitemChild;

    // Next item to create... (If there is next item then it must be linked with previous item)
    // See comments above for more information.

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CSampleSnapinLVContainer::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSampleSnapinLVContainer::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CSampleSnapinLVContainer::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 4; // use an enum instead of 4

    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_LVContainer);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CSampleSnapinLVContainer::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSampleSnapinLVContainer::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CSampleSnapinLVContainer::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = _T("LVContainer String1");
        break;

    case datString2:
        strField = _T("LVContainer String2");
        break;

    case datString3:
        strField = _T("LVContainer String3");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CSampleSnapinLVContainer::ScCreateChildren
//
//  Synopsis:    Create any children (nodes & leaf items) for this item.
//
//  Arguments:   None
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSampleSnapinLVContainer::ScCreateChildren ()
{
    DECLARE_SC(sc, _T("CSampleSnapinLVContainer::ScCreateChildren"));

    t_itemChild *   pitemChild      = NULL;
    t_itemChild *   pitemPrevious   = NULL;

    // Let us create 10 items for this container.
    for (int i = 0; i < 10; ++i)
    {
        // Create the child nodes and init them.
        sc = CSampleSnapinLVLeafItem::ScCreateLVLeafItem(this, pitemPrevious, &pitemChild, FALSE); // Why FALSE???
        if (sc)
            return sc;
        pitemPrevious = pitemChild;
    }

    return (sc);
}


//+-------------------------------------------------------------------
//
//  Member:      CSampleSnapinLVContainer::ScCreateLVContainer
//
//  Synopsis:    Do we really need this method?
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSampleSnapinLVContainer::ScCreateLVContainer(CSnapinRootItem *pitemParent, t_item ** ppitem, BOOL fNew)
{
    DECLARE_SC(sc, _T("CSnapinRootItem::ScCreateLVContainer"));
    t_item *   pitem   = NULL;
    *ppitem = NULL;

    // What to do here?
    sc = ::ScCreateItem(pitemParent, NULL, &pitem, fNew);
    if (sc)
        return sc;

    *ppitem = pitem;

    return (sc);
}

//+-------------------------------------------------------------------
//
//  Member:      CSampleSnapinLVLeafItem::ScInit
//
//  Synopsis:    Called immeadiately after the item is created to init
//               displayname, icon index etc...
//
//  Arguments:   [CBaseSnapin]   -
//               [CColumnInfoEx] - Any columns to be displayed for this item.
//               [INT]           - # of columns
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSampleSnapinLVLeafItem::ScInit(CBaseSnapin *pSnapin, CColumnInfoEx *pcolinfoex, INT ccolinfoex, BOOL fIsRoot)
{
    DECLARE_SC(sc, _T("CSampleSnapinLVLeafItem::ScInit"));

    sc = CBaseSnapinItem::ScInit(pSnapin, pcolinfoex, ccolinfoex, fIsRoot);
    if (sc)
        return sc;

    // Init following
    //  a. Icon index.
    //  b. Load display name.

    m_uIconIndex = 7; // use an enum instead of 7

    m_strDisplayName.LoadString(_Module.GetResourceInstance(), IDS_LVLeafItem);

    return sc;
}


//+-------------------------------------------------------------------
//
//  Member:      CSampleSnapinLVLeafItem::ScGetField
//
//  Synopsis:    Get the string representation for given field to display
//               it in result pane.
//
//  Arguments:   [DAT]     - The column requested (this is an enumeration).
//               [tstring] - Out string.
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSampleSnapinLVLeafItem::ScGetField (DAT dat, tstring& strField)
{
    DECLARE_SC(sc, _T("CSampleSnapinLVLeafItem::ScGetField"));

    switch(dat)
    {
    case datString1:
        strField = _T("LVLeaf String1");
        break;

    case datString2:
        strField = _T("LVLeaf String2");
        break;

    case datString3:
        strField = _T("LVLeaf String3");
        break;

    default:
        E_INVALIDARG;
        break;
    }

    return (sc);
}



//+-------------------------------------------------------------------
//
//  Member:      CSampleSnapinLVLeafItem::ScCreateLVLeafItem
//
//  Synopsis:    Do we really need this method?
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSampleSnapinLVLeafItem::ScCreateLVLeafItem(CSampleSnapinLVContainer *pitemParent, t_itemChild * pitemPrevious, t_itemChild ** ppitem, BOOL fNew)
{
    DECLARE_SC(sc, _T("CSampleSnapinLVLeafItem::ScCreateLVLeafItem"));
    t_itemChild *   pitem   = NULL;
    *ppitem = NULL;

    // What to do here?
    sc = ::ScCreateItem(pitemParent, pitemPrevious, &pitem, fNew);
    if (sc)
        return sc;

    *ppitem = pitem;

    return (sc);
}

// Initialize context menu structures. Let us have one item for demonstration.
SnapinMenuItem CSampleSnapinLVLeafItem::s_rgmenuitemLVLeafItem[] =
{
    {IDS_NewLVItem, IDS_NewLVItem, IDS_NewLVItem, CCM_INSERTIONPOINTID_PRIMARY_TOP, NULL, dwMenuAlwaysEnable, dwMenuNeverGray,        dwMenuNeverChecked},
};

INT CSampleSnapinLVLeafItem::s_cmenuitemLVLeafItem = CMENUITEM(s_rgmenuitemLVLeafItem);

// -----------------------------------------------------------------------------
SnapinMenuItem *CSampleSnapinLVLeafItem::Pmenuitem(void)
{
    return s_rgmenuitemLVLeafItem;
}

// -----------------------------------------------------------------------------
INT CSampleSnapinLVLeafItem::CMenuItem(void)
{
    return s_cmenuitemLVLeafItem;
}


//+-------------------------------------------------------------------
//
//  Member:      CSampleSnapinLVLeafItem::ScCommand
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:     SC
//
//--------------------------------------------------------------------
SC CSampleSnapinLVLeafItem::ScCommand (long nCommandID, CComponent *pComponent)
{
    DECLARE_SC(sc, _T("CSampleSnapinLVLeafItem::ScCommand"));

    switch(nCommandID)
    {
    case IDS_NewLVItem:
        sc = ScInsertResultItem(pComponent);
        break;

    default:
        sc = E_INVALIDARG;
        break;
    }

    return (sc);
}



//-------------------------------------------------------------------------------------
// class CSampleSnapin

#pragma BEGIN_CODESPACE_DATA
SNR     CSampleSnapin::s_rgsnr[] =
{
    SNR(&nodetypeSampleRoot,         snrEnumSP ),              // Standalone snapin.
    SNR(&nodetypeSampleLVContainer,  snrEnumSP | snrEnumRP ),  // enumerates this node in the scope pane and result pane.
    SNR(&nodetypeSampleLVLeafItem,   snrEnumSP | snrEnumRP ),  // enumerates this node in the scope pane and result pane.
};

LONG  CSampleSnapin::s_rgiconid[]           = {3};
LONG  CSampleSnapin::s_iconidStatic         = 2;


CColumnInfoEx CSampleSnapin::s_colinfo[] =
{
    CColumnInfoEx(_T("Column Name0"),   LVCFMT_LEFT,    180,    datString1),
    CColumnInfoEx(_T("Column Name1"),   LVCFMT_LEFT,    180,    datString2),
    CColumnInfoEx(_T("Column Name2"),   LVCFMT_LEFT,    180,    datString3),
};

INT CSampleSnapin::s_ccolinfo = sizeof(s_colinfo) / sizeof(CColumnInfoEx);
INT CSampleSnapin::s_colwidths[1];
#pragma END_CODESPACE_DATA

// include members needed for every snapin.
SNAPIN_DEFINE( CSampleSnapin);

/* CSampleSnapin::CSampleSnapin
 *
 * PURPOSE:             Constructor
 *
 * PARAMETERS: None
 *
 */
CSampleSnapin::CSampleSnapin()
{
    m_pstrDisplayName = new tstring();

    *m_pstrDisplayName = _T("Sample Snapin Root");
}

/* CSampleSnapin::~CSampleSnapin
 *
 * PURPOSE:             Destructor
 *
 * PARAMETERS: None
 *
 */
CSampleSnapin::~CSampleSnapin()
{
    delete m_pstrDisplayName;
}


//-------------------------------------------------------------------------------------
// class CSampleGhostRootSnapinItem


/* CSampleGhostRootSnapinItem::ScInitializeNamespaceExtension
 *
 * PURPOSE:
 *
 * PARAMETERS:
 *              PDATAOBJECT    lpDataObject:
 *              HSCOPEITEM     item:
 *              CNodeType *    pNodeType:
 *
 * RETURNS:
 *              SC
 */
SC
CSampleGhostRootSnapinItem::ScInitializeNamespaceExtension(LPDATAOBJECT lpDataObject, HSCOPEITEM item, CNodeType *pNodeType)
{
    DECLARE_SC(sc, _T("CSampleGhostRootSnapinItem::ScInitializeNamespaceExtension()"));

    return sc;
}


/* CSampleGhostRootSnapinItem::ScCreateChildren
 *
 * PURPOSE:     Creates children items
 *
 * PARAMETERS:
 *
 * RETURNS:
 *              SC
 */
SC
CSampleGhostRootSnapinItem::ScCreateChildren( void )
{
    DECLARE_SC(sc, _T("CSampleGhostRootSnapinItem::ScCreateChildren()"));
    t_itemChild *    pitemChild = NULL;

    sc = CBaseProtSnapinItem::ScCreateItem(this, NULL, &pitemChild, FALSE /*fNew*/ );
    if (sc)
        return sc;

    pitemChild->InitContainer();

    return sc;
}


//-------------------------------------------------------------------------------------
// class CBaseProtSnapinItem


/* CBaseProtSnapinItem::CBaseProtSnapinItem
 *
 * PURPOSE:             Constructor
 *
 * PARAMETERS:  None
 *
 */
CBaseProtSnapinItem::CBaseProtSnapinItem()
{
    m_fIsContainer  = FALSE;
}


/* CBaseProtSnapinItem::ScGetField
 *
 * PURPOSE:                     Gets the string value of a field.
 *
 * PARAMETERS:
 *              DAT             dat:            The field.
 *              STR *   pstrField:      [OUT]: The string value.
 *
 * RETURNS:
 *              SC
 */
SC
CBaseProtSnapinItem::ScGetField(DAT dat, tstring& strField)
{
    ASSERT(FALSE);
    return S_OK;
}


/* CBaseProtSnapinItem::ScCreateChildren
 *
 * PURPOSE:     Creates children items
 *
 * PARAMETERS:
 *
 * RETURNS:
 *              SC
 */
SC
CBaseProtSnapinItem::ScCreateChildren( void )
{
    DECLARE_SC(sc, _T("CBaseProtSnapinItem::ScCreateChildren()"));
    t_itemChild *   pitemChild = NULL;
    t_itemChild *   pitemPrevious = NULL;

    if ( FIsContainer() )
    {
        for ( INT idob = 0; idob < 10; idob++ )
        {
            // insert protocols
            sc = ScCreateItem(this, pitemPrevious, &pitemChild, FALSE /*fNew*/);
            if (sc)
                return sc;

            pitemPrevious = pitemChild;
        }
    }

    return sc;
}


/* CBaseProtSnapinItem::ScCreateItem
 *
 * PURPOSE:             Creates a new child item, assuming the DOB for it already exists.
 *
 * PARAMETERS:
 *              CBaseSnapinItem * pitemParent   The parent of this item - should be 'this' of the calling class
 *              t_itemChild *   pitemPrevious:  The previous item to link the newly created item to.
 *              t_itemChild **  ppitem:                 [OUT]: The new item.
 *              BOOL                    fNew                    new item?
 *
 * RETURNS:
 *              SC
 */
SC
CBaseProtSnapinItem::ScCreateItem(CBaseSnapinItem *pitemParent, t_itemChild * pitemPrevious, t_itemChild ** ppitem, BOOL fNew)
{
    DECLARE_SC(sc, _T("CBaseProtSnapinItem::ScCreateItem()"));
    t_itemChild *   pitem   = NULL;

    *ppitem = NULL;

    sc = ::ScCreateItem(pitemParent, pitemPrevious, &pitem, fNew);
    if (sc)
        return sc;

    *ppitem = pitem;
    return sc;
}


//-------------------------------------------------------------------------------------
// class CSampleExtnSnapin

#pragma BEGIN_CODESPACE_DATA    // $REVIEW should all the nodetypes be registered?
SNR     CSampleExtnSnapin::s_rgsnr[] =
{
//    SNR(&nodetypeSampleRoot,     snrExtNS ),                             // extends the namespace of a server node.
    SNR(&nodetypeSampleExtnNode, snrEnumSP | snrEnumRP ),// enumerates this node in the scope pane and result pane.
};

LONG  CSampleExtnSnapin::s_rgiconid[]               = { 0};
LONG  CSampleExtnSnapin::s_iconidStatic             = 0;


CColumnInfoEx CSampleExtnSnapin::s_colinfo[] =
{
    CColumnInfoEx(_T("Extn Column Name0"),   LVCFMT_LEFT,    180,    datString1),
};

INT CSampleExtnSnapin::s_ccolinfo = sizeof(s_colinfo) / sizeof(CColumnInfoEx);
INT CSampleExtnSnapin::s_colwidths[1];
#pragma END_CODESPACE_DATA

// include members needed for every snapin.
SNAPIN_DEFINE(CSampleExtnSnapin);

/* CSampleExtnSnapin::CSampleExtnSnapin
 *
 * PURPOSE:             Constructor
 *
 * PARAMETERS: None
 *
 */
CSampleExtnSnapin::CSampleExtnSnapin()
{
    m_pstrDisplayName = new tstring();

    *m_pstrDisplayName = _T("Sample Snapin Extn");
}

/* CSampleExtnSnapin::~CSampleExtnSnapin
 *
 * PURPOSE:             Destructor
 *
 * PARAMETERS: None
 *
 */
CSampleExtnSnapin::~CSampleExtnSnapin()
{
    delete m_pstrDisplayName;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\sample\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    sources.

!ENDIF

MAJORCOMP=admin
MINORCOMP=MMC

TARGETNAME=     TestSnapins
TARGETPATH=     obj
TARGETTYPE=     DYNLINK

DLLENTRY=_DllMainCRTStartup
UMTYPE    =     windows

WIN32_WINNT_VERSION=0x0400
WIN32_IE_VERSION=0x0500
SUBSYSTEM_VERSION=4.00

USE_NATIVE_EH   = 1
USE_RTTI        = 1
USE_VCCOM       = 1
USE_STL         = 1
USE_STATIC_ATL  = 1
ATL_VER         = 30
USE_MSVCRT      = 1
USE_WTL         = 1

MIDL_TLBDIR     = $(O)
PASS0_HEADERDIR = $(O)
PASS0_SOURCEDIR = $(O)
MIDL_UUIDDIR    = $(O)

DLLDEF = ..\TestSnapins.def

# Use LINKLIBS (gets passed first) if: (from build.hlp)
#  You are building a dynamic link.
#  You are exporting something that's defined in some other component library that you also build.
#  In your dirs file in the subdirectory above, you have ordered it so that the component libraries
#     are around before you build the dynamic link.
LINKLIBS = \
    $(SDK_LIB_PATH)\mmc.lib                         \
    ..\..\..\..\core\$(CharWidth)\$(O)\uicore.lib   \
    ..\..\..\..\base\$(CharWidth)\$(O)\mmcbase.lib  \
    ..\..\lib\$(CharWidth)\$(O)\SnapinBase.lib


TARGETLIBS = \
    $(SDK_LIB_PATH)\kernel32.lib    \
    $(SDK_LIB_PATH)\user32.lib      \
    $(SDK_LIB_PATH)\oleaut32.lib    \
    $(SDK_LIB_PATH)\ole32.lib       \
    $(SDK_LIB_PATH)\advapi32.lib    \
    $(SDK_LIB_PATH)\uuid.lib        \
    $(SDK_LIB_PATH)\comctl32.lib    \
    $(SDK_LIB_PATH)\gdi32.lib       \
    $(SDK_LIB_PATH)\comdlg32.lib    \
    $(SDK_LIB_PATH)\urlmon.lib      \
    $(SDK_LIB_PATH)\shell32.lib

TLBDir = $(O)

INCLUDES = \
    ..;                    	\
    inc;                    \
    ..\..\inc;              \
    ..\..\..\..\inc;        \
    ..\..\..\..\types\idl\$(O); \
    $(SDK_INC_PATH);        \
    $(TLBDir);


PRECOMPILED_INCLUDE = ..\stdafx.hxx
PRECOMPILED_CXX     = 1

# This target is required so $O\testsnapins.res doesn't become the default target
# for makefile.def.  We want "all" to be the default target.
#
# We have to go to this effort because sources(.inc) is included very early
# in makefile.def.  makefile.inc is the place where this would naturally go,
# but we don't want to have to maintain this dependency list in
# ansi\makefile.inc and unicode\makefile.inc.
dummytarget:    all

$O\testsnapins.res: \
    $(TLBDir)\testsnapins.tlb   \
    ..\res\commontb.bmp         \
    ..\res\folder.bmp           \
    ..\res\folder32.bmp         \
    ..\res\power16.bmp          \
    ..\res\power32.bmp          \
    ..\res\nodes16.bmp          \
    ..\res\nodes32.bmp          \
    ..\res\snpinlst.bmp         \
    ..\res\EventViewExt1.htm    \
    ..\res\EventViewExt2.htm    \
    ..\testsnapins.idl          \

SOURCES = \
    ..\TestSnapins.rc       \
    ..\TestSnapins.idl      \
    ..\TestSnapins.cxx      \
    ..\Component2Snapin.cxx \
    ..\Extension.cpp        \
    ..\nodetypes.cxx        \
    ..\PowerTest.cpp        \
    ..\RenameSnapin.cxx     \
    ..\samplesnap.cxx       \
    ..\ViewExtTest.cpp      \
	..\DragDropTest.cpp     \
	..\OcxCaching.cpp       \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\types\proxy\dlldata_wrap.c ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      dlldata_wrap.c
 *
 *  Contents:  Wraps dlldata_p.c from MIDL
 *
 *  History:   20-Jun-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "dlldata.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\sample\stdafx.cxx ===
#include "stdafx.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\sample\testsnapins.cxx ===
#include "stdafx.hxx"

#include "init.cxx"
#include "ViewExtTest.h"

#define _SNAPINLIST_FILE        "TestSnapinslist.hxx"
#define _FREGISTERTYPELIB       FALSE

#define SNAPIN_COM_OBJECTS												\
	OBJECT_ENTRY(CLSID_EventViewExtension1, CEventViewExtension1)		\
	OBJECT_ENTRY(CLSID_EventViewExtension2, CEventViewExtension2)		\

#include <targetdll.cxx>

const tstring szHelpFileTOC = _T("");

// Name of context-sensitive help file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\sample\viewexttest.cpp ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      viewexttest.cpp
 *
 *  Contents:  Implementation file for view extension test snap-ins
 *
 *  History:   20-Mar-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "stdafx.hxx"
#include "ViewExtTest.h"


// {49737049-EBF3-4e1c-B034-DE4936EDD1F4}
const CLSID CLSID_EventViewExtension1 =
{ 0x49737049, 0xebf3, 0x4e1c, { 0xb0, 0x34, 0xde, 0x49, 0x36, 0xed, 0xd1, 0xf4 } };

// {94AED30D-A033-436c-9919-E09CBA339973}
const CLSID CLSID_EventViewExtension2 =
{ 0x94aed30d, 0xa033, 0x436c, { 0x99, 0x19, 0xe0, 0x9c, 0xba, 0x33, 0x99, 0x73 } };


/*+-------------------------------------------------------------------------*
 * CEventViewExtension1::GetViews
 *
 *
 *--------------------------------------------------------------------------*/

STDMETHODIMP CViewExtension::GetViews (
	IDataObject*			pDataObject,
	IViewExtensionCallback*	pViewExtCallback)
{
	DECLARE_SC (sc, _T("CEventViewExtension1::GetView"));

	sc = ScCheckPointers (pViewExtCallback);
	if (sc)
		return (sc.ToHr());

	/*
	 * generate a URL for the view extension using the res: protocol and
	 * duplicate it into a CoTaskMemAlloc'd buffer
	 */
	TCHAR szModule[_MAX_PATH];
	GetModuleFileName (_Module.GetModuleInstance(), szModule, countof(szModule));

	std::wstring strURL;
	UINT nResourceID = GetResourceID();

	if (nResourceID != 0)
	{
		WCHAR szResourceID[6];
		_itow (nResourceID, szResourceID, 10);

		USES_CONVERSION;
		strURL = std::wstring(L"res://") + T2W(szModule) + L"/" + szResourceID;
	}
	else
		strURL = GetResource();

	std::wstring	strTabName (GetTabName());
	std::wstring	strTooltip (GetTooltip());

	MMC_EXT_VIEW_DATA xvd;
	xvd.viewID               = GetCLSID();
	xvd.pszURL               = strURL.data();
	xvd.pszViewTitle         = strTabName.data();
	xvd.pszTooltipText       = strTooltip.data();
	xvd.bReplacesDefaultView = TRUE;

	return (pViewExtCallback->AddView (&xvd));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\types\proxy\hcolwrap_wrap.c ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      hcolwrap_wrap.c
 *
 *  Contents:  Wraps hcolwrap_p.c from MIDL
 *
 *  History:   20-Jun-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "hcolwrap_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\types\proxy\ndmgriid.c ===
#include "ndmgr_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\test\snapins\sample\viewexttest.h ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      viewexttest.h
 *
 *  Contents:
 *
 *  History:   20-Mar-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#pragma once

#include "Extension.h"
#include "string.h"


class CViewExtension :
	public CExtension,
	public IExtendView
{
	BEGIN_COM_MAP(CViewExtension)
		COM_INTERFACE_ENTRY(IExtendView)
	END_COM_MAP()

public:
	// IExtendView methods
	STDMETHOD(GetViews) (IDataObject* pDataObject, IViewExtensionCallback* pViewExtCallback);

	virtual const CLSID&	GetCLSID()		const = 0;
	virtual std::wstring	GetTabName()	const = 0;
	virtual std::wstring	GetTooltip()	const = 0;
	virtual UINT			GetResourceID()	const		{ return 0; }
	virtual std::wstring	GetResource()	const		{ return L""; }

private:

};


extern const CLSID CLSID_EventViewExtension1;

class CEventViewExtension1 :
	public CViewExtension,
	public CComCoClass<CEventViewExtension1, &CLSID_EventViewExtension1>
{
	DECLARE_EXTENSION_REGISTRATION(
		eExtType_View,
		CLSID_EventViewExtension1,
		"EventViewExtension1 Class",
		"TestSnapins.EventViewExtension1.1",
		"TestSnapins.EventViewExtension1",
		"{7AB4A1FC-E403-11D0-9A97-00C04FD8DBF7}");	// event viewer nodetype

public:
	virtual const CLSID&	GetCLSID()		const	{ return (CLSID_EventViewExtension1);	}
	virtual std::wstring	GetTabName()	const	{ return (L"Event Ext 1"); }
	virtual std::wstring	GetTooltip()	const	{ return (L"Tooltip for Event Ext 1"); }
	virtual UINT			GetResourceID()	const	{ return (IDR_EventViewExt1); }
	virtual std::wstring	GetResource()	const	{ return (L"file://d:\\newnt\\admin\\mmcdev\\test\\Snapins\\Sample\\res\\EventViewExt1.htm"); }

};


extern const CLSID CLSID_EventViewExtension2;

class CEventViewExtension2 :
	public CViewExtension,
	public CComCoClass<CEventViewExtension2, &CLSID_EventViewExtension2>
{
	DECLARE_EXTENSION_REGISTRATION(
		eExtType_View,
		CLSID_EventViewExtension2,
		"EventViewExtension2 Class",
		"TestSnapins.EventViewExtension2.1",
		"TestSnapins.EventViewExtension2",
		"{7AB4A1FC-E403-11D0-9A97-00C04FD8DBF7}");	// event viewer nodetype

public:
	virtual const CLSID&	GetCLSID()		const	{ return (CLSID_EventViewExtension2);	}
	virtual std::wstring	GetTabName()	const	{ return (L"Event Ext 2"); }
	virtual std::wstring	GetTooltip()	const	{ return (L"Tooltip for Event Ext 2"); }
	virtual UINT			GetResourceID()	const	{ return (IDR_EventViewExt2); }
	virtual std::wstring	GetResource()	const	{ return (L"file://d:\\newnt\\admin\\mmcdev\\test\\Snapins\\Sample\\res\\EventViewExt2.htm"); }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\activec\types\proxy\ndmgr_wrap.c ===
/*--------------------------------------------------------------------------*
 *
 *  Microsoft Windows
 *  Copyright (C) Microsoft Corporation, 1992 - 000
 *
 *  File:      ndmgr_wrap.c
 *
 *  Contents:  Wraps ndmgr_p.c from MIDL
 *
 *  History:   20-Jun-2000 jeffro    Created
 *
 *--------------------------------------------------------------------------*/

#include "ndmgr_p.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\adsprop\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\adsprop\objprop.h ===
/*---------------------------------------------------------------------------
  File: ObjPropBuilder.h

  Comments: Declaration of CObjPropBuilder

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/

#ifndef __OBJPROPBUILDER_H_
#define __OBJPROPBUILDER_H_

#include "resource.h"       // main symbols
//#import "\bin\mcsvarsetmin.tlb" no_namespace 
#import "VarSet.tlb" no_namespace rename("property", "aproperty")

/////////////////////////////////////////////////////////////////////////////
// CObjPropBuilder
class ATL_NO_VTABLE CObjPropBuilder : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CObjPropBuilder, &CLSID_ObjPropBuilder>,
	public IObjPropBuilder
{
public:
	CObjPropBuilder()
	{
      m_lVer = -1;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_OBJPROPBUILDER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CObjPropBuilder)
	COM_INTERFACE_ENTRY(IObjPropBuilder)
END_COM_MAP()

// IObjPropBuilder
public:
	STDMETHOD(CopyNT4Props)(/*[in]*/ BSTR sSourceSam, /*[in]*/ BSTR sTargetSam, /*[in]*/ BSTR sSourceServer, /*[in]*/ BSTR sTargetServer, /*[in]*/ BSTR sType, long lGrpType, BSTR sExclude);
	STDMETHOD(ChangeGroupType)(/*[in]*/ BSTR sGroupPath, /*[in]*/ long lGroupType);
	STDMETHOD(MapProperties)(/*[in]*/ BSTR sSourceClass, /*[in]*/ BSTR sSourceDomain, long lSourceVer, /*[in]*/ BSTR sTargetClass, /*[in]*/ BSTR sTargetDomain, long lTargetVer, /*[in]*/ BOOL bIncName, /*[out]*/ IUnknown ** pUnk);
	STDMETHOD(SetPropertiesFromVarset)(/*[in]*/ BSTR sTargetPath, /*BSTR sTragetDomain,*/ IUnknown * pUnk, DWORD dwControl = ADS_ATTR_UPDATE);
   DWORD GetProperties(BSTR sObjPath, /*BSTR sDomainName, */IVarSet * pVar, ADS_ATTR_INFO*& pAttrInfo);
   STDMETHOD(CopyProperties)(/*[in]*/ BSTR sSourcePath, /*[in]*/ BSTR sSourceDomain, /*[in]*/ BSTR sTargetPath, /*[in]*/ BSTR sTargetDomain, /*[in]*/ IUnknown *pPropSet, /*[in]*/ IUnknown *pDBManager);
	STDMETHOD(GetObjectProperty)(/*[in]*/ BSTR sobjSubPath, /*[in]*/ /*BSTR sDomainName,*/ /*[in, out]*/ IUnknown ** ppVarset);
	STDMETHOD(GetClassPropEnum)(/*[in]*/ BSTR sClassName, /*[in]*/ BSTR sDomainName, long lVer, /*[out, retval]*/ IUnknown ** ppVarset);
   HRESULT SetProperties(BSTR sTargetPath, /*BSTR sTargetDomain,*/ ADS_ATTR_INFO* pAttrInfo, DWORD dwItems);
	STDMETHOD(ExcludeProperties)(/*[in]*/ BSTR sExclusionList, /*[in]*/ IUnknown *pPropSet, /*[out]*/ IUnknown ** ppUnk);
private:
	BOOL TranslateDNs( ADS_ATTR_INFO * pAttrInfo, DWORD dwRet, BSTR sSource, BSTR sTarget, IUnknown *pCheckList);
   HRESULT CObjPropBuilder::GetClassProperties( IADsClass * pClass, IUnknown *& pVarSet );
   HRESULT FillupVarsetFromVariant(IADsClass * pClass, VARIANT * pVar, BSTR sPropType, IUnknown *& pVarSet);
   HRESULT FillupVarsetWithProperty(BSTR sPropName, BSTR sPropType, IUnknown *& pVarSet);
   HRESULT FillupVarsetFromVariantArray(IADsClass * pClass, SAFEARRAY * pArray, BSTR sPropType, IUnknown *& pVarSet);
   void SetValuesInVarset(ADS_ATTR_INFO attrInfo, IVarSetPtr pVar);
   bool GetAttrInfo(_variant_t varX, _variant_t var, ADS_ATTR_INFO& attrInfo);
   bool IsPropSystemOnly(const WCHAR * sName, const WCHAR * sDomain, bool& bSystemFlag);
   BOOL GetProgramDirectory(WCHAR * filename);

   WCHAR m_sDomainName[255];
   WCHAR m_sNamingConvention[255];
   // cached schema search interface for IsPropSystemOnly()
   _bstr_t m_strSchemaDomain;
   CComPtr<IDirectorySearch> m_spSchemaSearch;
   //
   long m_lVer;
};

#endif //__OBJPROPBUILDER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\adsprop\objprop.cpp ===
/*---------------------------------------------------------------------------
  File: ObjPropBuilder.cpp

  Comments: Implementation of CObjPropBuilder COM object. This COM object
            is used to access/set properties for Win2K active directory
            objects. This COM object supports following operations
            
            1. GetClassPropeEnum : This method allows users to get all the
                                   the properties for a class in a domain.

            2. GetObjectProperty : This method gathers values for properties
                                   on a given AD object. 

            3. MapProperties : Constructs a set of properties that are common
                               to two classes in the AD.

            4. SetPropFromVarset : Sets properties for a AD object from a varset.

            5. CopyProperties : Copies common properties from source AD object
                                to target AD object.


  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/
#include "stdafx.h"
#include "EaLen.hpp"
#include "ResStr.h"
#include "ADsProp.h"
#include "ObjProp.h"
#include "iads.h"
#include <lm.h>
#include "ErrDct.hpp"
#include "TReg.hpp"
#include "StrHelp.h"

#include "pwgen.hpp"

StringLoader gString;

//#import "\bin\NetEnum.tlb" no_namespace 
//#import "\bin\DBManager.tlb" no_namespace
#import "NetEnum.tlb" no_namespace 
#import "DBMgr.tlb" no_namespace

#ifndef IADsPtr
_COM_SMARTPTR_TYPEDEF(IADs, IID_IADs);
#endif

TErrorDct                    err;
TError                     & errCommon = err;
/////////////////////////////////////////////////////////////////////////////
// CObjPropBuilder

BOOL CObjPropBuilder::GetProgramDirectory(
      WCHAR                * filename      // out - buffer that will contain path to program directory
   )
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;

   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);
   if ( ! rc )
   {
      rc = key.ValueGetStr(L"Directory",filename,MAX_PATH);
      if ( ! rc )
      {
         if ( *filename ) 
            bFound = TRUE;
      }
   }
   if ( ! bFound )
   {
      UStrCpy(filename,L"C:\\");    // if all else fails, default to the C: drive
   }
   return bFound;
}

//---------------------------------------------------------------------------
// GetClassPropEnum: This function fills the varset with all the properties 
//                   for a given class in a given domain. The Varset has 
//                   values stored by the OID and then by their name with
//                   MandatoryProperties/OptionalProperties as parent nodes
//                   as applicable.
//---------------------------------------------------------------------------
STDMETHODIMP CObjPropBuilder::GetClassPropEnum(
                                                BSTR sClassName,        //in -Class name to get the properties for
                                                BSTR sDomainName,       //in -Domain name
                                                long lVer,              //in -The domain version
                                                IUnknown **ppVarset     //out-Varset filled with the properties
                                              )
{
   // This function goes through the list of properties for the specified class in specified domain
   // Builds the given varset with the properties and their values.
   WCHAR                     sAdsPath[LEN_Path];
   HRESULT                   hr = E_INVALIDARG;
   _variant_t                dnsName;
   

   if ( lVer > 4 ) 
   {
      // For this Domain get the default naming context
      wsprintfW(sAdsPath, L"LDAP://%s/rootDSE", sDomainName);
      IADs                    * pAds = NULL;

      hr = ADsGetObject(sAdsPath, IID_IADs, (void**)&pAds);
   
      if ( SUCCEEDED(hr) )
      {
         hr = pAds->Get(L"defaultNamingContext", &dnsName);
      }
      if ( SUCCEEDED(hr) )
      {
         wcscpy(m_sNamingConvention, dnsName.bstrVal);

         // Build LDAP path to the schema
         wcscpy(sAdsPath, L"LDAP://"); 
         wcscat(sAdsPath, sDomainName);
         wcscat(sAdsPath, L"/");
         wcscat(sAdsPath, sClassName);
         wcscat(sAdsPath, L", schema");
         hr = S_OK;
      }

      if ( pAds )
         pAds->Release();
   }
   else
   {
      wsprintf(sAdsPath, L"WinNT://%s/Schema/%s", sDomainName, sClassName);
      hr = S_OK;
   }

   if ( SUCCEEDED(hr) )
   {
      wcscpy(m_sDomainName, sDomainName);
      m_lVer = lVer;
      // Get the class object.
      IADsClass               * pIClass=NULL;
            
      hr = ADsGetObject(sAdsPath, IID_IADsClass, (void **)&pIClass);
      // Without the object we can not go any further so we will stop here.
      if ( SUCCEEDED(hr) )
      {
         // Let the Auxilliary function take care of Getting properties and filling up the Varset.
         hr = GetClassProperties( pIClass, *ppVarset );
         pIClass->Release();
      }   
   }
	return hr;
}

//---------------------------------------------------------------------------
// GetClassProperties: This function fills the varset with properties of the class.
//---------------------------------------------------------------------------
HRESULT CObjPropBuilder::GetClassProperties( 
                                            
                                             IADsClass * pClass,     //in -IADsClass * to the class
                                             IUnknown *& pVarSet     //out-Varset to fill the properties
                                           )
{
   HRESULT                   hr;
   _variant_t                variant;
   VariantInit(&variant);

   // mandatory properties
   hr = pClass->get_MandatoryProperties(&variant);
   if ( SUCCEEDED(hr) )
   {
      hr = FillupVarsetFromVariant(pClass, &variant, L"MandatoryProperties", pVarSet);
   }
   VariantClear(&variant);
   
   // optional properties
   hr = pClass->get_OptionalProperties(&variant);
   if ( SUCCEEDED(hr) )
   {
      hr = FillupVarsetFromVariant(pClass, &variant, L"OptionalProperties", pVarSet);
   }
   VariantClear(&variant);

   return hr;
}

//---------------------------------------------------------------------------
// FillupVarsetFromVariant: This function fills in the Varset property info
//                          with the info in a variant.
//---------------------------------------------------------------------------
HRESULT CObjPropBuilder::FillupVarsetFromVariant(
                                                   IADsClass * pClass,  //in -IADsClass * to the class
                                                   VARIANT * pVar,      //in -Variant to lookup info.
                                                   BSTR sPropType,      //in -Type of the property
                                                   IUnknown *& pVarSet  //out-Varset with the info,
                                                )
{
   HRESULT                      hr;
   BSTR                         sPropName;
   USHORT                       type;
   type = pVar->vt;
   
   if ( type & VT_ARRAY )
   {
      if ( type == (VT_ARRAY|VT_VARIANT) )
      {
         hr = FillupVarsetFromVariantArray(pClass, pVar->parray, sPropType, pVarSet);
         if ( FAILED ( hr ) )
            return hr;
      }
      else
         return S_FALSE;
   }
   else
   {
      if ( type == VT_BSTR )
      {
         // Only other thing that the VARIANT could be is a BSTR.
         sPropName = pVar->bstrVal;
         hr = FillupVarsetWithProperty(sPropName, sPropType, pVarSet);
         if ( FAILED ( hr ) )
            return hr;
      }
      else
         return S_FALSE;
   }
   return S_OK;
}

//---------------------------------------------------------------------------
// FillupVarsetWithProperty: Given the class prop name and the prop type this
//                           function fills info into the varset.
//---------------------------------------------------------------------------
HRESULT CObjPropBuilder::FillupVarsetWithProperty(
                                                   BSTR sPropName,      //in -Property name
                                                   BSTR sPropType,      //in -Property type
                                                   IUnknown *& pVarSet  //out-Varset to fill in the information
                                                 )
{
   if ( wcslen(sPropName) == 0 )
      return S_OK;
   // This function fills up the Varset for a given property
   HRESULT                         hr;
   _variant_t                      var;
   _variant_t                      varSO;
   _variant_t                      varID;
   IVarSetPtr                      pVar;
   WCHAR                           sAdsPath[LEN_Path];
   IADsProperty                  * pProp = NULL;
   BSTR                            objID = NULL;
   BSTR                            sPath = NULL;
   BSTR                            sClass = NULL;
   WCHAR                           sPropPut[LEN_Path];

   // Get the OID  for the property
   // First we need a IADsProperty pointer to the property schema
   if ( m_lVer > 4 )
   {
      wcscpy(sAdsPath, L"LDAP://");
      wcscat(sAdsPath, m_sDomainName);
      wcscat(sAdsPath, L"/");
      wcscat(sAdsPath, sPropName);
      wcscat(sAdsPath, L", schema");
   }
   else
   {
      wsprintf(sAdsPath, L"WinNT://%s/Schema/%s", m_sDomainName, sPropName);
   }

   hr = ADsGetObject(sAdsPath, IID_IADsProperty, (void **)&pProp);

   // Get the objectID for the property
   hr = pProp->get_OID(&objID);
   hr = pProp->get_ADsPath(&sPath);
   pProp->get_Class(&sClass);
      
   
   // Get the varset from the parameter
   pVar = pVarSet;

   // Set up the variant to put into the varset
   var = objID;
 
   // Put the value into the varset
   wcscpy(sPropPut, sPropType);
   wcscat(sPropPut, L".");
   wcscat(sPropPut, sPropName);
   hr = pVar->put(sPropPut, var);
   
   // Set up the variant to put into the varset
   var = sPropName;

   // Put the value with the ObjectID as the key.
   hr = pVar->put(objID, var);
   SysFreeString(objID);
   SysFreeString(sPath);
   SysFreeString(sClass);
   pProp->Release();
   return hr;
}

//---------------------------------------------------------------------------
// FillupVarsetFromVariantArray: Given the class, SafeArray of props and the 
//                               prop type this function fills info into the 
//                               varset.
//---------------------------------------------------------------------------
HRESULT CObjPropBuilder::FillupVarsetFromVariantArray(
                                                         IADsClass * pClass,  //in -IADsClass* to the class in question
                                                         SAFEARRAY * pArray,  //in -SafeArray pointer with the prop names
                                                         BSTR sPropType,      //in -Property type
                                                         IUnknown *& pVarSet  //out-Varset with the information filled in
                                                     )
{
   HRESULT                   hr = S_FALSE;
   DWORD                     nDim;         // number of dimensions, must be one
   LONG                      nLBound;      // lower bound of array
   LONG                      nUBound;      // upper bound of array
   LONG                      indices[1];   // array indices to access elements
   DWORD                     rc;           // SafeArray return code
   VARIANT                   variant;      // one element in array
   
   nDim = SafeArrayGetDim(pArray);
   VariantInit(&variant);

   if ( nDim == 1 )
   {
      SafeArrayGetLBound(pArray, 1, &nLBound);
      SafeArrayGetUBound(pArray, 1, &nUBound);
      for ( indices[0] = nLBound, rc = 0;
            indices[0] <= nUBound && !rc;
            indices[0] += 1 )
      {
         
         rc = SafeArrayGetElement(pArray,indices,&variant);
         if ( !rc )
            hr = FillupVarsetFromVariant(pClass, &variant, sPropType, pVarSet);
         VariantClear(&variant);
      }
   }


   return hr;
}

//---------------------------------------------------------------------------
// GetProperties: This function gets the values for the properties specified
//                in the varset in the ADS_ATTR_INFO array for the object
//                specified in a given domain.
//---------------------------------------------------------------------------
DWORD CObjPropBuilder::GetProperties(
                                       BSTR sObjPath,             //in -Path to the object for which we are getting the props
//                                       BSTR sDomainName,          //in -Domain name where the object resides
                                       IVarSet * pVar,           //in -Varset listing all the property names that we need to get.
                                       ADS_ATTR_INFO*& pAttrInfo  //out-Attribute values for the property
                                    )
{
   // Construct the LDAP path.
   WCHAR                   sPath[LEN_Path];
   VARIANT                 var;

   // Get the path to the source object
   safecopy(sPath, sObjPath);

   // Get the Varset pointer and enumerate the properties asked for and build an array to send to IADsDirectory
   long                      lRet=0;
   SAFEARRAY               * keys = NULL;
   SAFEARRAY               * vals = NULL;
   IDirectoryObject        * pDir;
   DWORD                     dwRet = 0;

   LPWSTR                  * pAttrNames = new LPWSTR[pVar->GetCount()];
   HRESULT                   hr = pVar->raw_getItems(NULL, NULL, 1, 10000, &keys, &vals, &lRet);

   VariantInit(&var);

   if (!pAttrNames)
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

   if ( SUCCEEDED( hr ) ) 
   {

      // Build the Attribute array from the varset.
      for ( long x = 0; x < lRet; x++ )
      {
         ::SafeArrayGetElement(keys, &x, &var);
         int len = wcslen(var.bstrVal);
         pAttrNames[x] = new WCHAR[len + 2];
		 if (!(pAttrNames[x]))
		 {
			for (int j=0; j<x; j++)
			   delete [] pAttrNames[j];
			delete [] pAttrNames;
            return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
		 }
         wcscpy(pAttrNames[x], var.bstrVal);
         VariantClear(&var);
      }

      // Now get the IDirectoryObject Ptr for the given object.
      hr = ADsGetObject(sPath, IID_IDirectoryObject, (void **)&pDir);
      if ( FAILED( hr ) ) 
      {
         dwRet = 0;
      }
      else
      {
         // Get the Property values for the object.
         hr = pDir->GetObjectAttributes(pAttrNames, lRet, &pAttrInfo, &dwRet);
         pDir->Release();
      }
      for ( long y = 0 ; y < lRet; y++ )
      {
         delete [] pAttrNames[y];
      }
      SafeArrayDestroy(keys);
      SafeArrayDestroy(vals);
   }
   delete [] pAttrNames;

   return dwRet;
}

//---------------------------------------------------------------------------
// GetObjectProperty: This function takes in a varset with property names. 
//                    Then it fills up the varset with values by getting them 
//                    from the Object.
//---------------------------------------------------------------------------
STDMETHODIMP CObjPropBuilder::GetObjectProperty(
                                                   BSTR sobjSubPath,       //in- LDAP Sub path to the object
//                                                   BSTR sDomainName,       //in- Domain name where the object resides
                                                   IUnknown **ppVarset     //out-Varset filled with the information
                                               )
{
   IVarSetPtr                pVar;
   ADS_ATTR_INFO           * pAttrInfo=NULL;
   pVar = *ppVarset;

   // Get the properties from the directory
   DWORD dwRet = GetProperties(sobjSubPath, /*sDomainName,*/ pVar, pAttrInfo);
   
   if ( dwRet > 0 )
      return dwRet;

   // Go through the property values and put them into the varset.
   for ( DWORD dwIdx = 0; dwIdx < dwRet; dwIdx++ )
   {
      SetValuesInVarset(pAttrInfo[dwIdx], pVar);
   }
   if ( pAttrInfo )
      FreeADsMem( pAttrInfo );
   return S_OK;
}

//---------------------------------------------------------------------------
// SetValuesInVarset: This function sets the values for the properties into
//                    a varset.
//---------------------------------------------------------------------------
void CObjPropBuilder::SetValuesInVarset(
                                          ADS_ATTR_INFO attrInfo,    //in -The property value in ADS_ATTR_INFO struct.
                                          IVarSetPtr pVar            //in,out -The VarSet where we need to put the values
                                       )
{
   // This function extraces values from ADS_ATTR_INFO struct and puts it into the Varset.
   LPWSTR            sKeyName = attrInfo.pszAttrName;
   _variant_t        var;
   // Got through each value ( in case of multivalued entries ) and depending on the type put it into the varset
   // the way we put in single value entries is to put the propertyName as key and put its value as value. Although
   // in case of a multivalued entry we put PropertyName.### and each of the values in it.
   for ( DWORD dw = 0; dw < attrInfo.dwNumValues; dw++)
   {
      var = L"";
      if ( attrInfo.dwNumValues > 1 )
         // Multivalued property name
         wsprintfW(sKeyName, L"%s.%d", attrInfo.pszAttrName, dw);
      else
         // Single value keyname.
         wcscpy(sKeyName,attrInfo.pszAttrName);

      // Fill in the values as per the varset.
      switch (attrInfo.dwADsType)
      {
         case ADSTYPE_DN_STRING           :  var.vt = VT_BSTR;
                                             var.bstrVal = ::SysAllocString(attrInfo.pADsValues[dw].DNString);
                                             break;
         case ADSTYPE_CASE_EXACT_STRING   :  var.vt = VT_BSTR;
                                             var.bstrVal = attrInfo.pADsValues[dw].CaseExactString;
                                             break;
         case ADSTYPE_CASE_IGNORE_STRING  :  var.vt = VT_BSTR;
                                             var.bstrVal = ::SysAllocString(attrInfo.pADsValues[dw].CaseIgnoreString);
                                             break;
         case ADSTYPE_PRINTABLE_STRING    :  var.vt = VT_BSTR;
                                             var.bstrVal = ::SysAllocString(attrInfo.pADsValues[dw].PrintableString);
                                             break;
         case ADSTYPE_NUMERIC_STRING      :  var.vt = VT_BSTR;
                                             var.bstrVal = ::SysAllocString(attrInfo.pADsValues[dw].NumericString);
                                             break;
         case ADSTYPE_INTEGER             :  var.vt = VT_I4;
                                             var.lVal = attrInfo.pADsValues[dw].Integer;
                                             break; 
         case ADSTYPE_OCTET_STRING        :  {
                                                var.vt = VT_ARRAY | VT_UI1;
                                                long           * pData;
                                                DWORD            dwLength = attrInfo.pADsValues[dw].OctetString.dwLength;
                                                SAFEARRAY      * sA;
                                                SAFEARRAYBOUND   rgBound = {dwLength, 0}; 
                                                sA = ::SafeArrayCreate(VT_UI1, 1, &rgBound);
                                                ::SafeArrayAccessData( sA, (void**)&pData);
                                                for ( DWORD i = 0; i < dwLength; i++ )
                                                   pData[i] = attrInfo.pADsValues[dw].OctetString.lpValue[i];
                                                ::SafeArrayUnaccessData(sA);
                                                var.parray = sA;
                                             }
                                             break;
/*         case ADSTYPE_UTC_TIME            :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = ::SysAllocString(L"Date not supported.");
                                             break;
         case ADSTYPE_LARGE_INTEGER       :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = ::SysAllocString(L"Large Integer not supported.");
                                             break;
         case ADSTYPE_PROV_SPECIFIC       :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = ::SysAllocString(L"Provider specific strings not supported.");
                                             break;
         case ADSTYPE_OBJECT_CLASS        :  var.vt = VT_BSTR;
                                             var.bstrVal = ::SysAllocString(attrInfo.pADsValues[dw].ClassName);
                                             break;
         case ADSTYPE_CASEIGNORE_LIST     :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Case ignore lists are not supported.";
                                             break;
         case ADSTYPE_OCTET_LIST          :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Octet lists are not supported.";
                                             break;
         case ADSTYPE_PATH                :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Path type not supported.";
                                             break;
         case ADSTYPE_POSTALADDRESS       :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Postal addresses are not supported.";
                                             break;
         case ADSTYPE_TIMESTAMP           :  var.vt = VT_UI4;
                                             var.lVal = attrInfo.pADsValues[dw].UTCTime;
                                             break;
         case ADSTYPE_BACKLINK            :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Backlink is not supported.";
                                             break;
         case ADSTYPE_TYPEDNAME           :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Typed name not supported.";
                                             break;
         case ADSTYPE_HOLD                :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Hold not supported.";
                                             break;
         case ADSTYPE_NETADDRESS          :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"NetAddress not supported.";
                                             break;
         case ADSTYPE_REPLICAPOINTER      :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Replica pointer not supported.";
                                             break;
         case ADSTYPE_FAXNUMBER           :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Faxnumber not supported.";
                                             break;
         case ADSTYPE_EMAIL               :  wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Email not supported.";
                                             break;
         case ADSTYPE_NT_SECURITY_DESCRIPTOR : wcscat(sKeyName,L".ERROR");
                                             var.vt = VT_BSTR;
                                             var.bstrVal = L"Security Descriptor not supported.";
                                             break;
*/
         default                          :  wcscat(sKeyName,GET_STRING(DCTVS_SUB_ERROR));
                                             var.vt = VT_BSTR;
                                             var.bstrVal = GET_BSTR(IDS_UNKNOWN_TYPE);
                                             break;
      }
      pVar->put(sKeyName, var);
      if ( attrInfo.dwADsType == ADSTYPE_OCTET_STRING) 
         var.vt = VT_EMPTY;
   }
}

//---------------------------------------------------------------------------
// CopyProperties: This function copies properties, specified in the varset,
//                 by getting the values 
//                 from the source account and the setting the values in
//                 the target account.
//---------------------------------------------------------------------------
STDMETHODIMP CObjPropBuilder::CopyProperties(
                                                BSTR sSourcePath,       //in -Source path to the object
                                                BSTR sSourceDomain,     //in -Source domain name
                                                BSTR sTargetPath,       //in -Target object LDAP path
                                                BSTR sTargetDomain,     //in -Target domain name
                                                IUnknown *pPropSet,     //in -Varset listing all the props to copy
                                                IUnknown *pDBManager    //in -DB Manager that has a open connection to the DB.
                                            )
{
   IIManageDBPtr                pDb = pDBManager;

   ADS_ATTR_INFO              * pAttrInfo = NULL;
   IVarSetPtr                   pVarset = pPropSet;
   HRESULT                      hr = S_OK;

   
  
   // Get properties from the source
   DWORD dwRet = GetProperties(sSourcePath, /*sSourceDomain,*/ pVarset, pAttrInfo);
   
   if ( dwRet > 0 )
   {
      TranslateDNs(pAttrInfo, dwRet, sSourceDomain, sTargetDomain, pDBManager);
   
      for ( DWORD dwIdx = 0; dwIdx < dwRet; dwIdx++)
      {
         pAttrInfo[dwIdx].dwControlCode = ADS_ATTR_UPDATE;
	        //we do not want to copy over the account enable\disable bit since we want this target
	        //account to remain disabled at this time, so make sure that bit is cleared
		 if (!_wcsicmp(pAttrInfo[dwIdx].pszAttrName, L"userAccountControl"))
		 {
			 if (pAttrInfo[dwIdx].dwADsType == ADSTYPE_INTEGER)
			    pAttrInfo[dwIdx].pADsValues->Integer |= UF_ACCOUNTDISABLE;
		 }
      }

      // Set the source properties in the target.
      hr = SetProperties(sTargetPath, /*sTargetDomain,*/ pAttrInfo, dwRet);
   }
   

   if ( pAttrInfo )
      FreeADsMem( pAttrInfo );
   
   
  return hr;
}

//---------------------------------------------------------------------------
// SetProperties: This function sets the properties for a given object from 
//                the attr info array.
//---------------------------------------------------------------------------
HRESULT CObjPropBuilder::SetProperties(
                                          BSTR sTargetPath,             //in -Target object path.
//                                          BSTR sTargetDomain,           //in - Target domain name
                                          ADS_ATTR_INFO * pAttrInfo,    //in - ADSATTRINFO array with values for props
                                          DWORD dwItems                 //in - number of properties in the array
                                      )
{
   IDirectoryObject           * pDir;
   DWORD                        dwRet=0;
   IVarSetPtr                   pSucc(__uuidof(VarSet));
   IVarSetPtr                   pFail(__uuidof(VarSet));

   // Get the IDirectory Object interface to the Object.
   HRESULT hr = ADsGetObject(sTargetPath, IID_IDirectoryObject, (void**) &pDir);
   if ( FAILED(hr) )
      return hr;

   // Set the Object Attributes.
   hr = pDir->SetObjectAttributes(pAttrInfo, dwItems, &dwRet);
   if ( FAILED(hr) )
   {
      // we are going to try it one at a time and see what causes problems
      for (DWORD dw = 0; dw < dwItems; dw++)
      {
         hr = pDir->SetObjectAttributes(&pAttrInfo[dw], 1, &dwRet);
         _bstr_t x = pAttrInfo[dw].pszAttrName;
         _variant_t var;
         if ( FAILED(hr))
         {
           DWORD dwLastError;
           WCHAR szErrorBuf[LEN_Path];
           WCHAR szNameBuf[LEN_Path];
           //Get extended error value.
           HRESULT hr_return =S_OK;
           hr_return = ADsGetLastError( &dwLastError,
                                          szErrorBuf,
                                          LEN_Path-1,
                                           szNameBuf,
                                          LEN_Path-1);
           //var = szErrorBuf;
           var = hr;
            pFail->put(x, var);
            hr = S_OK;
         }
         else
         {
            pSucc->put(x, var);         
         }
      }
   }
   pDir->Release();
   return hr;
}

//---------------------------------------------------------------------------
// SetPropertiesFromVarset: This function sets values for properties from
//                          the varset. The varset should contain the 
//                          propname (containing the val) and the 
//                          propname.Type ( containing the type of Val) 
//---------------------------------------------------------------------------
STDMETHODIMP CObjPropBuilder::SetPropertiesFromVarset(
                                                         BSTR sTargetPath,       //in -LDAP path to the target object
//                                                         BSTR sTragetDomain,     //in - Domain name for the Target domain
                                                         IUnknown *pUnk,         //in - Varset to fetch the values from
                                                         DWORD dwControl         //in - Cotnrol code to use for Updating/Deleting etc..
                                                     )
{
   // This function loads up properties and their values from the Varset and sets them for a given user
   IVarSetPtr                   pVar;
   SAFEARRAY                  * keys;
   SAFEARRAY                  * vals;
   long                         lRet;
   VARIANT                      var;
   _variant_t                   varX;
   pVar = pUnk;

   VariantInit(&var);

   ADS_ATTR_INFO  FAR		  * pAttrInfo = new ADS_ATTR_INFO[pVar->GetCount()];
   if (!pAttrInfo)
      return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

   HRESULT  hr = pVar->getItems(L"", L"", 0, 10000, &keys, &vals, &lRet);
   if ( FAILED (hr) ) 
   {
      delete [] pAttrInfo;
      return hr;
   }
	
   // Build the Property Name/Value array from the varset.
   for ( long x = 0; x < lRet; x++ )
   {
      // Get the property name
      ::SafeArrayGetElement(keys, &x, &var);
      _bstr_t                keyName = var.bstrVal;
      int                    len = wcslen(keyName);

      pAttrInfo[x].pszAttrName = new WCHAR[len + 2];
	  if (!(pAttrInfo[x].pszAttrName))
	  {
		 for (int z=0; z<x; z++)
			 delete [] pAttrInfo[z].pszAttrName;
         delete [] pAttrInfo;
         return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
	  }
      wcscpy(pAttrInfo[x].pszAttrName, keyName);
      VariantClear(&var);
      // Get the property value
      ::SafeArrayGetElement(vals, &x, &var);
      keyName = keyName + _bstr_t(L".Type");
      varX = pVar->get(keyName);
      
      if(GetAttrInfo(varX, var, pAttrInfo[x]))
	  {
         pAttrInfo[x].dwControlCode = dwControl;
         pAttrInfo[x].dwNumValues = 1;
	  }
      VariantClear(&var);
   }
   SafeArrayDestroy(keys);
   SafeArrayDestroy(vals);
   // Once we build the array of name and property values then we call the sister function to do the rest
   if ( lRet > 0 ) SetProperties(sTargetPath, /*sTragetDomain,*/ pAttrInfo, lRet);

   // Always cleanup after yourself...

   for ( x = 0; x < lRet; x++ )
   {
      delete pAttrInfo[x].pADsValues;
	  delete [] pAttrInfo[x].pszAttrName;
   }
   delete [] pAttrInfo;

   return S_OK;
}


//------------------------------------------------------------------------------
// GetAttrInfo: Given a variant this function fills in the ADS_ATTR_INFO struct
//------------------------------------------------------------------------------
bool CObjPropBuilder::GetAttrInfo(
                                    _variant_t varX,           //in - Variant containing the Type of prop
                                    _variant_t var,            //in - Variant containing the Prop value
                                    ADS_ATTR_INFO& attrInfo    //out - The filled up attr info structure
                                 )
{
   switch (varX.lVal)
   {
      case ADSTYPE_DN_STRING           :  {
                                             attrInfo.dwADsType = ADSTYPE_DN_STRING;
                                             ADSVALUE * pAd = new ADSVALUE();
											 if (!pAd)
											    return false;
                                             pAd->dwType = ADSTYPE_DN_STRING;
                                             pAd->DNString = var.bstrVal;
                                             attrInfo.pADsValues = pAd;
                                             break;
                                          }

      case ADSTYPE_CASE_EXACT_STRING   :  {
                                             attrInfo.dwADsType = ADSTYPE_CASE_EXACT_STRING;
                                             ADSVALUE * pAd = new ADSVALUE();
											 if (!pAd)
											    return false;
                                             pAd->dwType = ADSTYPE_CASE_EXACT_STRING;
                                             pAd->CaseExactString  = var.bstrVal;
                                             attrInfo.pADsValues = pAd;
                                             break;
                                          }

      case ADSTYPE_CASE_IGNORE_STRING  :  {
                                             attrInfo.dwADsType = ADSTYPE_CASE_IGNORE_STRING;
                                             ADSVALUE * pAd = new ADSVALUE();
											 if (!pAd)
											    return false;
                                             pAd->dwType = ADSTYPE_CASE_IGNORE_STRING;
                                             pAd->CaseIgnoreString = var.bstrVal;
                                             attrInfo.pADsValues = pAd;
                                             break;
                                          }

      case ADSTYPE_PRINTABLE_STRING    :  {
                                             attrInfo.dwADsType = ADSTYPE_PRINTABLE_STRING;
                                             ADSVALUE * pAd = new ADSVALUE();
											 if (!pAd)
											    return false;
                                             pAd->dwType = ADSTYPE_PRINTABLE_STRING;
                                             pAd->PrintableString = var.bstrVal;
                                             attrInfo.pADsValues = pAd;
                                             break;
                                          }

      case ADSTYPE_NUMERIC_STRING      :  {
                                             attrInfo.dwADsType = ADSTYPE_NUMERIC_STRING;
                                             ADSVALUE * pAd = new ADSVALUE();
											 if (!pAd)
											    return false;
                                             pAd->dwType = ADSTYPE_NUMERIC_STRING;
                                             pAd->NumericString = var.bstrVal;
                                             attrInfo.pADsValues = pAd;
                                             break;
                                          }

      case ADSTYPE_INTEGER            :   {
                                             attrInfo.dwADsType = ADSTYPE_INTEGER;
                                             ADSVALUE * pAd = new ADSVALUE();
											 if (!pAd)
											    return false;
                                             pAd->dwType = ADSTYPE_INTEGER;
                                             pAd->Integer = var.lVal;
                                             attrInfo.pADsValues = pAd;
                                             break;
                                          }

      default                          :  {
                                             // Don't support this type then get it out of the way.
                                             return false;
                                             break;
                                          }
   }
   return true;
}

//------------------------------------------------------------------------------
// MapProperties: Using the OID of the properties this function creates a set
//                of properties that are common to both source and target domain.
//------------------------------------------------------------------------------
STDMETHODIMP CObjPropBuilder::MapProperties(
                                             BSTR sSourceClass,      //in- Source Class name 
                                             BSTR sSourceDomain,     //in- Source domain name
                                             long lSourceVer,        //in- Source domain version
                                             BSTR sTargetClass,      //in - Target class name
                                             BSTR sTargetDomain,     //in - Target domain name
                                             long lTargetVer,        //in - Target Domain version
                                             BOOL bIncNames,         //in - flag telling if varset should include propname
                                             IUnknown **ppUnk        //out - Varset with the mapped properties
                                           )
{
	ATLTRACE(_T("E CObjPropBuilder::MapProperties(sSourceClass='%s', sSourceDomain='%s', lSourceVer=%ld, sTargetClass='%s', sTargetDomain='%s', lTargetVer=%ld, bIncNames=%s, ppUnk=...)\n"), sSourceClass, sSourceDomain, lSourceVer, sTargetClass, sTargetDomain, lTargetVer, bIncNames ? _T("TRUE") : _T("FALSE"));

	IVarSetPtr				     pSource(__uuidof(VarSet));
	IVarSetPtr				     pTarget(__uuidof(VarSet));
   IVarSetPtr                pMerged = *ppUnk;
   IVarSetPtr                pFailed(__uuidof(VarSet));
   IUnknown                * pUnk;
   SAFEARRAY               * keys;
   SAFEARRAY               * vals;
   long                      lRet;
   VARIANT                   var;
   _variant_t                varTarget;
   _variant_t                varEmpty;
   bool                      bSystemFlag;
   WCHAR                     sPath[LEN_Path];
   WCHAR                     sProgDir[LEN_Path];
   bool						 bUnMapped = false;

   VariantInit(&var);
   GetProgramDirectory(sProgDir);
   wsprintf(sPath, L"%s%s", sProgDir, L"Logs\\PropMap.log");

   err.LogOpen(sPath,0,0);
   // Get the list of props for source and target first
   HRESULT hr = pSource->QueryInterface(IID_IUnknown, (void **)&pUnk);
   GetClassPropEnum(sSourceClass, sSourceDomain, lSourceVer, &pUnk);
   pUnk->Release();
   hr = pTarget->QueryInterface(IID_IUnknown, (void **)&pUnk);
   GetClassPropEnum(sTargetClass, sTargetDomain, lTargetVer, &pUnk);
   pUnk->Release();

   // For every item in source try to find same OID in target. If it exists in both source and target then put it into merged Varset
   hr = pSource->getItems(L"", L"", 1, 10000, &keys, &vals, &lRet);
   if ( FAILED (hr) ) 
      return hr;
	
   // Build the Property Name/Value array from the varset.
   _bstr_t        val;
   _bstr_t        keyName;
   for ( long x = 0; x < lRet; x++ )
   {
       // Get the property name
      ::SafeArrayGetElement(keys, &x, &var);
      keyName = var.bstrVal;
      VariantClear(&var);

      if ( lSourceVer > 4 )
      {
	     // Windows 2000 domain so we map by OID    
        if ((wcsncmp(keyName, L"Man", 3) != 0) && (wcsncmp(keyName, L"Opt", 3) != 0) )
	    {
		     // Only go through the OID keys to get the name of the properties.
		   varTarget = pTarget->get(keyName);
		   if ( varTarget.vt == VT_BSTR )
           {
              val = varTarget.bstrVal;
              if ((!IsPropSystemOnly(val, sTargetDomain, bSystemFlag) && (wcscmp(val, L"objectSid") != 0) 
                 && (wcscmp(val, L"sAMAccountName") != 0) && (_wcsicmp(val, L"Rid") != 0) 
				 && (wcscmp(val, L"pwdLastSet") != 0) && (wcscmp(val, L"userPassword") != 0) 
				 && (wcscmp(val, L"isCriticalSystemObject") != 0)) 
                 || ( !_wcsicmp(val, L"c") || !_wcsicmp(val, L"l") || !_wcsicmp(val, L"st") 
                 || !_wcsicmp(val, L"userAccountControl") ) )     // These properties are exceptions.
			  {
				 if (bIncNames)
                    pMerged->put(keyName, val);
			     else
                    pMerged->put(val, varEmpty);
			  }
              else
                 pFailed->put(val, varEmpty);
           }
           else if (!bIncNames)
           {
              var = pSource->get(keyName);
              if (var.vt == VT_BSTR) keyName = var.bstrVal;
              err.MsgWrite(ErrE, DCT_MSG_FAILED_TO_MAP_PROP_SSSSS, (WCHAR*) keyName, (WCHAR*) sSourceClass, 
                                             (WCHAR*) sSourceDomain, (WCHAR*) sTargetClass, (WCHAR*) sTargetDomain);
			  bUnMapped = true;
           }
	    }
      }
      else
      {
         // NT4 code is the one that we map by Names.
         if ( keyName.length() > 0 )
         {
            WCHAR          propName[LEN_Path];
            if (wcsncmp(keyName, L"Man", 3) == 0)
               wcscpy(propName, (WCHAR*) keyName+20);
            else
               wcscpy(propName, (WCHAR*) keyName+19);
      
            varTarget = pSource->get(keyName);
            if ( varTarget.vt == VT_BSTR )
               pMerged->put(propName, varEmpty);
         }
      }
   }
   SafeArrayDestroy(keys);
   SafeArrayDestroy(vals);
   err.LogClose();

	ATLTRACE(_T("L CObjPropBuilder::MapProperties()\n"));

   if (bUnMapped)
      return DCT_MSG_PROPERTIES_NOT_MAPPED;
   else
      return S_OK;
}

//------------------------------------------------------------------------------
// IsPropSystemOnly: This function determines if a specific property is 
//                   System Only or not
//------------------------------------------------------------------------------
bool CObjPropBuilder::IsPropSystemOnly(
                                          const WCHAR * sName,       //in- Name of the property
                                          const WCHAR * sDomain,     //in- Domain name where we need to check  
                                          bool& bSystemFlag          //out- Tells us if it failed due to system flag.
                                      )
{
   // we will lookup the property name in target domain schema and see if it is system only or not.
   // First build an LDAP path to the Schema container.
   HRESULT                   hr = S_OK;
   WCHAR                     sQuery[LEN_Path];
   LPWSTR                    sCols[] = { L"systemOnly", L"systemFlags" };                   
   ADS_SEARCH_HANDLE         hSearch;
   ADS_SEARCH_COLUMN         col;
   bool                      bSystemOnly = true;

   if ((m_strSchemaDomain != _bstr_t(sDomain)) || (m_spSchemaSearch == false))
   {
      m_strSchemaDomain = sDomain;

      IADsPtr spAds;
      hr = ADsGetObject(L"LDAP://" + m_strSchemaDomain + L"/rootDSE", IID_IADs, (void**)&spAds);

      if ( SUCCEEDED(hr) )
      {
         _variant_t var;
         hr = spAds->Get(L"schemaNamingContext", &var);

         if ( SUCCEEDED(hr) )
         {
            // Get the IDirectorySearch interface to it.
            hr = ADsGetObject(
               L"LDAP://" + m_strSchemaDomain + L"/" + _bstr_t(var),
               IID_IDirectorySearch,
               (void**)&m_spSchemaSearch
            );
         }
      }
   }

   if ( SUCCEEDED(hr) )
   {
      // Build the query string
      wsprintf(sQuery, L"(lDAPDisplayName=%s)", sName);
      // Now search for this property
      hr = m_spSchemaSearch->ExecuteSearch(sQuery, sCols, 2, &hSearch);

	   if ( SUCCEEDED(hr) )
	   {// Get the systemOnly flag and return its value.
	      hr = m_spSchemaSearch->GetFirstRow(hSearch);
	      if (hr == S_ADS_NOMORE_ROWS || SUCCEEDED(hr))
	      {
	         hr = m_spSchemaSearch->GetColumn( hSearch, sCols[0], &col );
	         if ( SUCCEEDED(hr) )
	         {
	             bSystemOnly = ( col.pADsValues->Boolean == TRUE);
	             m_spSchemaSearch->FreeColumn( &col );
	         }
	         // Check the system flags 
	         hr = m_spSchemaSearch->GetColumn( hSearch, sCols[1], &col );
	         if ( SUCCEEDED(hr) )
	         {
	            bSystemFlag = ((col.pADsValues->Integer & 0x1F) > 16);
	            bSystemOnly = bSystemOnly || bSystemFlag;
	            m_spSchemaSearch->FreeColumn(&col);
	         }
	      }
	      m_spSchemaSearch->CloseSearchHandle(hSearch);
	   }
   }

   return bSystemOnly;
}


//------------------------------------------------------------------------------
// TranslateDNs: This function Translates object properties that are
//               distinguished names to point to same object in target domain
//               as the object in the source domain.
//------------------------------------------------------------------------------
BOOL CObjPropBuilder::TranslateDNs(
                                    ADS_ATTR_INFO *pAttrInfo,        //in -Array
                                    DWORD dwRet, BSTR sSource, 
                                    BSTR sTarget,
                                    IUnknown *pCheckList          //in -Object that will check the list if an account Exists
                                  )
{
   IVarSetPtr                pVs(__uuidof(VarSet));
   IUnknown                * pUnk;
   INetObjEnumeratorPtr      pNet(__uuidof(NetObjEnumerator));
   WCHAR                     sPath[LEN_Path];
   WCHAR                     sQuery[LEN_Path];
   IADs                    * pAds = NULL;
   _variant_t                vName;
   _bstr_t                   sName;
   _bstr_t                   sObjPath;
   HRESULT                   hr;
   LPWSTR                    pNames[] = { L"distinguishedName" };
   SAFEARRAY               * saCols;
   SAFEARRAYBOUND            bd = { 1, 0 };
   BSTR  HUGEP             * pBstr = NULL;
   IEnumVARIANT            * pEnum = NULL;
   DWORD                     dwf = 0;
   VARIANT                   var2;
   IIManageDBPtr             pList = pCheckList;

   VariantInit(&var2);
   pVs->QueryInterface(IID_IUnknown, (void**)&pUnk);
   for ( DWORD dw = 0; dw < dwRet; dw++)
   {
      // initialize the varset that we need to send to the Get props function.
      if ( pAttrInfo[dw].dwADsType == ADSTYPE_DN_STRING )
      {
         // Get the path to the source dn string
         wsprintf(sPath, L"GC://%s/%s", sSource, pAttrInfo[dw].pADsValues->DNString);
         
         // get the SAM name for this object.
         hr = ADsGetObject(sPath, IID_IADs, (void**)&pAds);      
         
         if ( SUCCEEDED(hr) )
         {
            hr = pAds->Get(L"sAMAccountName", &vName);
         }
         
         if ( SUCCEEDED(hr) )
         {
            if ( pAds )
            {
               pAds->Release();
               pAds = NULL;
            }
         
            if ( SUCCEEDED(hr) )
            {
               sName = vName;
            } 
            // Check if we are copying this account in this batch
            if ( SUCCEEDED(hr) )
            {
               hr = pList->raw_GetAMigratedObject(sName, sSource, sTarget, &pUnk);
            }
            if ( hr == S_OK )
            {
               // Get the prop from the varset
               sObjPath = pVs->get(L"MigratedObjects.TargetAdsPath");
               if ( wcslen((WCHAR*)sObjPath) > 0 )
               {
                  // We have the ads path so lets get the DN and move on
                  hr = ADsGetObject(sObjPath, IID_IADs, (void**)&pAds);
                  if ( SUCCEEDED(hr) )
                  {
                     hr = pAds->Get(L"distinguishedName", &vName);
                  }
                  if ( pAds )
                  {
                     pAds->Release();
                     pAds = NULL;
                  }
                  if ( SUCCEEDED(hr) )
                     pAttrInfo[dw].pADsValues->DNString = vName.bstrVal;
               }
            }
            else
            {
               // Now that we have the SAM name for the source account And we know we are not copying the
               // account in this batch we can search for this account in the target domain
               // and if the account is there then we use the newly found account.
               wsprintf(sPath, L"GC://%s", sTarget);
               WCHAR                     sTempSamName[LEN_Path];
               wcscpy(sTempSamName, (WCHAR*)sName);
               if ( sTempSamName[0] == L' ' )
               {
                  WCHAR               sTemp[LEN_Path];
                  wsprintf(sTemp, L"\\20%s", sTempSamName + 1); 
                  wcscpy(sTempSamName, sTemp);
               }
               wsprintf(sQuery, L"(sAMAccountName=%s)", sTempSamName);
         
               saCols = SafeArrayCreate(VT_BSTR, 1, &bd);
               SafeArrayAccessData(saCols, (void HUGEP **) &pBstr);
               pBstr[0] = SysAllocString(pNames[0]);
               SafeArrayUnaccessData(saCols);
         
               hr = pNet->raw_SetQuery(sPath, sTarget, sQuery, 2, FALSE);
            
               if ( SUCCEEDED(hr) )
               {
                  hr = pNet->raw_SetColumns(saCols);
               }
            
               if (SUCCEEDED(hr) )
               {
                  hr = pNet->raw_Execute(&pEnum);
               }
               
               if (SUCCEEDED(hr) )
               {
                  pEnum->Next(1, &vName, &dwf);
                  if ( dwf == 0 )
                     return FALSE;

                  dwf = 0;
                  ::SafeArrayGetElement(vName.parray, (long*)&dwf, &var2);
                  if ( sName.length() > 0 )
                    pAttrInfo[dw].pADsValues->DNString = var2.bstrVal;
                  else
                     pAttrInfo[dw].pADsValues->DNString = L"";
                  VariantClear(&var2);
               }
               if ( pEnum )
                  pEnum->Release();
               VariantInit(&vName);
               SafeArrayDestroy(saCols);
            }
         }
      }
   }
   pUnk->Release();
   return TRUE;
}

STDMETHODIMP CObjPropBuilder::ChangeGroupType(BSTR sGroupPath, long lGroupType)
{
   HRESULT                   hr;
   IADsGroup               * pGroup;
   _variant_t                var;
   long                      lType;
   
   // Get the group type info from the object.
   hr = ADsGetObject( sGroupPath, IID_IADsGroup, (void**) &pGroup);
   if (FAILED(hr)) return hr;

   hr = pGroup->Get(L"groupType", &var);
   if (FAILED(hr)) return hr;

   // Check if Security group or Distribution group and then set the type accordingly.
   lType = var.lVal;

   if (lType & 0x80000000 )
      lType = lGroupType | 0x80000000;
   else
      lType = lGroupType;

   // Set the value into the Group Information
   var = lType;
   hr = pGroup->Put(L"groupType", var);   
   if (FAILED(hr)) return hr;

   hr = pGroup->SetInfo();
   if (FAILED(hr)) return hr;

   pGroup->Release();
   return S_OK;
}


//------------------------------------------------------------------------------------------------------------------------------
// CopyNT4Props : Uses Net APIs to get info from the source account and then set it to the target account.
//------------------------------------------------------------------------------------------------------------------------------
STDMETHODIMP CObjPropBuilder::CopyNT4Props(BSTR sSourceSam, BSTR sTargetSam, BSTR sSourceServer, BSTR sTargetServer, BSTR sType, long lGrpType, BSTR sExclude)
{
	DWORD dwError = ERROR_SUCCESS;

	#define ISEXCLUDE(a) IsStringInDelimitedString(sExclude, L#a, L',')

	if (_wcsicmp(sType, L"user") == 0)
	{
		//
		// user
		//

		USER_INFO_3 ui;

		PUSER_INFO_3 puiSource = NULL;
		PUSER_INFO_3 puiTarget = NULL;

		dwError = NetUserGetInfo(sSourceServer, sSourceSam, 3, (LPBYTE*)&puiSource);

		if (dwError == ERROR_SUCCESS)
		{
			dwError = NetUserGetInfo(sTargetServer, sTargetSam, 3, (LPBYTE*)&puiTarget);

			if (dwError == ERROR_SUCCESS)
			{
				// note that attributes with the comment ignored are ignored by NetUserSetInfo
				// setting to target value just so that they have a valid value

				ui.usri3_name = puiTarget->usri3_name; // ignored
				ui.usri3_password = NULL; // must not set during copy properties
				ui.usri3_password_age = puiTarget->usri3_password_age; // ignored
				ui.usri3_priv = puiTarget->usri3_priv; // ignored
				ui.usri3_home_dir = ISEXCLUDE(homeDirectory) ? puiTarget->usri3_home_dir : puiSource->usri3_home_dir;
				ui.usri3_comment = ISEXCLUDE(description) ? puiTarget->usri3_comment : puiSource->usri3_comment;

				ui.usri3_flags = puiSource->usri3_flags;
				// translate a local account to a domain account
				ui.usri3_flags &= ~UF_TEMP_DUPLICATE_ACCOUNT;
				// disable the account in case no password has been set
				ui.usri3_flags |= UF_ACCOUNTDISABLE;

				ui.usri3_script_path = ISEXCLUDE(scriptPath) ? puiTarget->usri3_script_path : puiSource->usri3_script_path;
				ui.usri3_auth_flags = puiTarget->usri3_auth_flags; // ignored
				ui.usri3_full_name = ISEXCLUDE(displayName) ? puiTarget->usri3_full_name : puiSource->usri3_full_name;
				ui.usri3_usr_comment = ISEXCLUDE(comment) ? puiTarget->usri3_usr_comment : puiSource->usri3_usr_comment;
				ui.usri3_parms = ISEXCLUDE(userParameters) ? puiTarget->usri3_parms : puiSource->usri3_parms;
				ui.usri3_workstations = ISEXCLUDE(userWorkstations) ? puiTarget->usri3_workstations : puiSource->usri3_workstations;
				ui.usri3_last_logon = puiTarget->usri3_last_logon; // ignored
				ui.usri3_last_logoff = ISEXCLUDE(lastLogoff) ? puiTarget->usri3_last_logoff : puiSource->usri3_last_logoff;
				ui.usri3_acct_expires = ISEXCLUDE(accountExpires) ? puiTarget->usri3_acct_expires : puiSource->usri3_acct_expires;
				ui.usri3_max_storage = ISEXCLUDE(maxStorage) ? puiTarget->usri3_max_storage : puiSource->usri3_max_storage;
				ui.usri3_units_per_week = puiTarget->usri3_units_per_week; // ignored
				ui.usri3_logon_hours = ISEXCLUDE(logonHours) ? puiTarget->usri3_logon_hours : puiSource->usri3_logon_hours;
				ui.usri3_bad_pw_count = puiTarget->usri3_bad_pw_count; // ignored
				ui.usri3_num_logons = puiTarget->usri3_num_logons; // ignored
				ui.usri3_logon_server = puiTarget->usri3_logon_server; // ignored
				ui.usri3_country_code = ISEXCLUDE(countryCode) ? puiTarget->usri3_country_code : puiSource->usri3_country_code;
				ui.usri3_code_page = ISEXCLUDE(codePage) ? puiTarget->usri3_code_page : puiSource->usri3_code_page;
				ui.usri3_user_id = puiTarget->usri3_user_id; // ignored
				// if not excluded set the primary group to the Domain Users group
				ui.usri3_primary_group_id = ISEXCLUDE(primaryGroupID) ? puiTarget->usri3_primary_group_id : DOMAIN_GROUP_RID_USERS;
				ui.usri3_profile = ISEXCLUDE(profilePath) ? puiTarget->usri3_profile : puiSource->usri3_profile;
				ui.usri3_home_dir_drive = ISEXCLUDE(homeDrive) ? puiTarget->usri3_home_dir_drive : puiSource->usri3_home_dir_drive;
				ui.usri3_password_expired = puiTarget->usri3_password_expired;

				dwError = NetUserSetInfo(sTargetServer, sTargetSam, 3, (LPBYTE)&ui, NULL);

				if (dwError == NERR_UserNotInGroup)
				{
					// if the setInfo failed because of the primary group property, try again, using the primary group 
					// that is already defined for the target account
					ui.usri3_primary_group_id = puiTarget->usri3_primary_group_id;

					dwError = NetUserSetInfo(sTargetServer, sTargetSam, 3, (LPBYTE)&ui, NULL);
				}
			}

			if (puiTarget)
			{
				NetApiBufferFree(puiTarget);
			}

			if (puiSource)
			{
				NetApiBufferFree(puiSource);
			}
		}
	}
	else if (_wcsicmp(sType, L"group") == 0)
	{
		// if description attribute is not excluded then copy comment attribute
		// note that the only downlevel group attribute that will be copied is the description (comment) attribute

		if (ISEXCLUDE(description) == FALSE)
		{
			if (lGrpType & 4)
			{
				//
				// local group
				//

				PLOCALGROUP_INFO_1 plgi = NULL;

				dwError = NetLocalGroupGetInfo(sSourceServer, sSourceSam, 1, (LPBYTE*)&plgi);

				if (dwError == ERROR_SUCCESS)
				{
					dwError = NetLocalGroupSetInfo(sTargetServer, sTargetSam, 1, (LPBYTE)plgi, NULL);

					NetApiBufferFree(plgi);
				}
			}
			else
			{
				//
				// global group
				//

				PGROUP_INFO_1 pgi = NULL;

				dwError = NetGroupGetInfo(sSourceServer, sSourceSam, 1, (LPBYTE*)&pgi);

				if (dwError == ERROR_SUCCESS)
				{
					dwError = NetGroupSetInfo(sTargetServer, sTargetSam, 1, (LPBYTE)pgi, NULL);

					NetApiBufferFree(pgi);
				}
			}
		}
	}
	else if (_wcsicmp(sType, L"computer") == 0)
	{
		//
		// computer
		//

		USER_INFO_3 ui;

		PUSER_INFO_3 puiSource = NULL;
		PUSER_INFO_3 puiTarget = NULL;

		dwError = NetUserGetInfo(sSourceServer, sSourceSam, 3, (LPBYTE*)&puiSource);

		if (dwError == ERROR_SUCCESS)
		{
			dwError = NetUserGetInfo(sTargetServer, sTargetSam, 3, (LPBYTE*)&puiTarget);

			if (dwError == ERROR_SUCCESS)
			{
				// note that attributes with the comment ignored are ignored by NetUserSetInfo
				// setting to target value just so that they have a valid value

				ui.usri3_name = puiTarget->usri3_name; // ignored
				ui.usri3_password = NULL; // must not set during copy properties
				ui.usri3_password_age = puiTarget->usri3_password_age; // ignored
				ui.usri3_priv = puiTarget->usri3_priv; // ignored
				ui.usri3_home_dir = puiTarget->usri3_home_dir;
				ui.usri3_comment = ISEXCLUDE(description) ? puiTarget->usri3_comment : puiSource->usri3_comment;

				ui.usri3_flags = puiSource->usri3_flags;
				// translate a local account to a domain account
				ui.usri3_flags &= ~UF_TEMP_DUPLICATE_ACCOUNT;
				// disable the account in case no password has been set
				//ui.usri3_flags |= UF_ACCOUNTDISABLE;

				ui.usri3_script_path = puiTarget->usri3_script_path;
				ui.usri3_auth_flags = puiTarget->usri3_auth_flags; // ignored
				ui.usri3_full_name = ISEXCLUDE(displayName) ? puiTarget->usri3_full_name : puiSource->usri3_full_name;
				ui.usri3_usr_comment = ISEXCLUDE(comment) ? puiTarget->usri3_usr_comment : puiSource->usri3_usr_comment;
				ui.usri3_parms = puiTarget->usri3_parms;
				ui.usri3_workstations = puiTarget->usri3_workstations;
				ui.usri3_last_logon = puiTarget->usri3_last_logon; // ignored
				ui.usri3_last_logoff = puiTarget->usri3_last_logoff;
				ui.usri3_acct_expires = puiTarget->usri3_acct_expires;
				ui.usri3_max_storage = puiTarget->usri3_max_storage;
				ui.usri3_units_per_week = puiTarget->usri3_units_per_week; // ignored
				ui.usri3_logon_hours = puiTarget->usri3_logon_hours;
				ui.usri3_bad_pw_count = puiTarget->usri3_bad_pw_count; // ignored
				ui.usri3_num_logons = puiTarget->usri3_num_logons; // ignored
				ui.usri3_logon_server = puiTarget->usri3_logon_server; // ignored
				ui.usri3_country_code = puiTarget->usri3_country_code;
				ui.usri3_code_page = puiTarget->usri3_code_page;
				ui.usri3_user_id = puiTarget->usri3_user_id; // ignored
				ui.usri3_primary_group_id = puiTarget->usri3_primary_group_id;
				ui.usri3_profile = puiTarget->usri3_profile;
				ui.usri3_home_dir_drive = puiTarget->usri3_home_dir_drive;
				ui.usri3_password_expired = puiTarget->usri3_password_expired;

				dwError = NetUserSetInfo(sTargetServer, sTargetSam, 3, (LPBYTE)&ui, NULL);
			}

			if (puiTarget)
			{
				NetApiBufferFree(puiTarget);
			}

			if (puiSource)
			{
				NetApiBufferFree(puiSource);
			}
		}
	}
	else
	{
		_ASSERT(FALSE);
	}

	return HRESULT_FROM_WIN32(dwError);
}


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 31 OCT 2000                                                 *
 *                                                                   *
 *     This function is responsible for copying all properties, from *
 * an incoming varset of properties, into a new varset but excluding *
 * those properties listed in a given exclusion list.  The exclusion *
 * list is a comma-seperated string of property names.               *
 *                                                                   *
 *********************************************************************/

//BEGIN ExcludeProperties
STDMETHODIMP CObjPropBuilder::ExcludeProperties(
                                             BSTR sExclusionList,    //in- list of props to exclude 
                                             IUnknown *pPropSet,     //in -Varset listing all the props to copy
                                             IUnknown **ppUnk        //out - Varset with all the props except those excluded
                                           )
{
/* local variables */
   IVarSetPtr                pVarsetNew = *ppUnk;
   IVarSetPtr                pVarset = pPropSet;
   SAFEARRAY               * keys;
   SAFEARRAY               * vals;
   long                      lRet;
   VARIANT                   var;
   _variant_t                varEmpty;
   BOOL						 bFound = FALSE;
   HRESULT					 hr;

/* function body */
   VariantInit(&var);

      //retrieve all item in the incoming varset
   hr = pVarset->getItems(L"", L"", 1, 10000, &keys, &vals, &lRet);
   if ( FAILED (hr) ) 
      return hr;
	
      //get each property name and if it is not in the exclusion list
      //place it in the new varset
   _bstr_t        keyName;

   for ( long x = 0; x < lRet; x++ )
   {
         //get the property name
      ::SafeArrayGetElement(keys, &x, &var);
      keyName = var.bstrVal;
      VariantClear(&var);

	     //see if this name is in the exclusion list
      bFound = IsStringInDelimitedString((WCHAR*)sExclusionList, 
										 (WCHAR*)keyName,
										 L',');

	     //if the property was not found in the exclusion list, place it
		 //in the new varset
	  if (!bFound)
         pVarsetNew->put(keyName, varEmpty);
  }//end for each property

   SafeArrayDestroy(keys);
   SafeArrayDestroy(vals);
   return S_OK;
}
//END ExcludeProperties
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\adsprop\adsprop.cpp ===
/*---------------------------------------------------------------------------
  File: McsADsClassProp.cpp

  Comments: Implementation of DLL Exports.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Sham Chauthani
  Revised on 07/02/99 12:40:00
 ---------------------------------------------------------------------------
*/


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f McsADsClassPropps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ADsProp.h"

#include "ADsProp_i.c"
#include "ObjProp.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ObjPropBuilder, CObjPropBuilder)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		ATLTRACE(_T("{McsADsClassProp.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_ATTACH,...)\n"), hInstance);
        _Module.Init(ObjectMap, hInstance, &LIBID_MCSADSCLASSPROPLib);
        DisableThreadLibraryCalls(hInstance);
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);

    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
		ATLTRACE(_T("{McsADsClassProp.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_DETACH,...)\n"), hInstance);
        _Module.Term();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\adsprop\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ADsProp.rc
//
#define IDS_PROJNAME                    100
#define IDR_OBJPROPBUILDER              101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\adsprop\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__29CFAF11_1D02_11D3_8C81_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__29CFAF11_1D02_11D3_8C81_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <iads.h>
#include <adshlp.h>
#include <adserr.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__29CFAF11_1D02_11D3_8C81_0090270D48D1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\adsprop\getproptest\getproptest.cpp ===
// GetPropTest.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "GetPropTest.h"
#include "GetPropTestDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CGetPropTestApp

BEGIN_MESSAGE_MAP(CGetPropTestApp, CWinApp)
	//{{AFX_MSG_MAP(CGetPropTestApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGetPropTestApp construction

CGetPropTestApp::CGetPropTestApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CGetPropTestApp object

CGetPropTestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CGetPropTestApp initialization

BOOL CGetPropTestApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CGetPropTestDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\adsprop\getproptest\getproptestdlg.h ===
// GetPropTestDlg.h : header file
//

#if !defined(AFX_GETPROPTESTDLG_H__B68553D4_1D10_11D3_8C81_0090270D48D1__INCLUDED_)
#define AFX_GETPROPTESTDLG_H__B68553D4_1D10_11D3_8C81_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CGetPropTestDlg dialog

class CGetPropTestDlg : public CDialog
{
// Construction
public:
	CGetPropTestDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CGetPropTestDlg)
	enum { IDD = IDD_GETPROPTEST_DIALOG };
	CString	m_strClass;
	CString	m_strSource;
	CString	m_strTarget;
	CString	m_strTargetDomain;
	CString	m_strSourceDomain;
	CString	m_strCont;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGetPropTestDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CGetPropTestDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GETPROPTESTDLG_H__B68553D4_1D10_11D3_8C81_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\adsprop\getproptest\objcopy.cpp ===
// ObjCopy.cpp: implementation of the CObjCopy class.
//
//////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "GetPropTest.h"
#include "ObjCopy.h"

#import "../McsAdsClassProp.tlb" no_namespace
#import "C:\\bin\\mcsvarsetmin.tlb" no_namespace

#ifdef _DEBUG
#undef THIS_FILE
static char THIS_FILE[]=__FILE__;
#define new DEBUG_NEW
#endif

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CObjCopy::CObjCopy(CString a_strContainer) : m_strCont(a_strContainer)
{

}

CObjCopy::~CObjCopy()
{

}

HRESULT CObjCopy::CopyObject(CString a_strSource, CString a_strSrcDomain, CString a_strTarget, CString a_strTgtDomain)
{
   WCHAR                     sAdsPath[255];
   WCHAR                     sNC[255];
   HRESULT                   hr;
   IADs                    * pAds;
   IADsContainer           * pCont;
   IDispatch               * pDisp;
   IVarSetPtr                pVarset(__uuidof(VarSet));
   IObjPropBuilderPtr        pObjProps(__uuidof(ObjPropBuilder));
   IUnknown                * pUnk;
   _variant_t                var;
   _bstr_t                   sClassName;

   // Find the naming convention for the Source domain.
   wcscpy(sAdsPath, L"LDAP://");
   wcscat(sAdsPath, a_strSrcDomain);
   wcscat(sAdsPath, L"/rootDSE");
   
   hr = ADsGetObject(sAdsPath, IID_IADs, (void**)&pAds);
   if ( FAILED(hr))
      return hr;

   hr = pAds->Get(L"defaultNamingContext",&var);
   if ( SUCCEEDED( hr) )
      wcscpy(sNC, var.bstrVal);

   pAds->Release();

   // Now build a path to your source object.
   wsprintf(sAdsPath, L"LDAP://%s/%s,%s", a_strSrcDomain, a_strSource, sNC);
   
   // Get the class type of the property
   hr = ADsGetObject(sAdsPath, IID_IADs, (void**)&pAds);
   if ( FAILED(hr) )
      return hr;

   // Get the name of the class for the source object so we can use that to create the new object.
   WCHAR * sClass;
   hr = pAds->get_Name(&sClass);
   hr = pAds->get_Class(&sClass);
   pAds->Release();
   if ( FAILED(hr) )
      return hr;

   // Now that we have the classname we can go ahead and create an object in the target domain.
   // First we need to get IAdsContainer * to the domain.
   wcscpy(sAdsPath, m_strCont);
   hr = ADsGetObject(sAdsPath, IID_IADsContainer, (void**)&pCont);
   if ( FAILED(hr) )
      return (hr);

   // Call the create method on the container.
   WCHAR sTarget[255];
   wcscpy(sTarget, a_strTarget);
   hr = pCont->Create(sClass, sTarget, &pDisp);
   pCont->Release();
   if ( FAILED(hr) )
      return hr;

   // Get the IADs interface to get the path to newly created object.
   hr = pDisp->QueryInterface(IID_IADs, (void**)&pAds);
   pDisp->Release();
   if ( FAILED(hr) )
      return hr;

   _variant_t varT;
   _bstr_t    strName;
   int d = a_strTarget.Find(',');
   if (d == -1)
      varT = a_strTarget.Mid(3);
   else
      varT = a_strTarget.Mid(3,d - 3);
   hr = pAds->Put(L"sAMAccountName", varT);
   hr = pAds->SetInfo();
   WCHAR * sTgtPath;
   hr = pAds->get_ADsPath(&sTgtPath);
   if ( FAILED(hr) )
      return hr;


   // Get the IUnknown * to the varset to pass it around
   hr = pVarset->QueryInterface(IID_IUnknown, (void**)&pUnk);
   if ( FAILED(hr) )
      return hr;

   // Now lets get a mapping of the properties between the two domains
   _bstr_t  sSrcDomain = a_strSrcDomain;
   _bstr_t  sTgtDomain = a_strTgtDomain;
   _bstr_t  sSource    = a_strSource;
   hr = pObjProps->MapProperties(sClass, sSrcDomain, sClass, sTgtDomain, &pUnk);
   if ( FAILED(hr) )
      return hr;

   _variant_t varX;
/*   pVarset->Clear();
   pVarset->put("telephoneNumber", varX);
   pVarset->put("Description", varX);
   pVarset->put("userPassword", varX);
   pVarset->put("userPrincipalName", varX);
   pVarset->put("userParameters", varX);
   pVarset->put("wbemPath", varX);
   pVarset->put("telephoneNumber", varX);
*/
   // Copy the mapped properties from Source to Target object.
   hr = pObjProps->CopyProperties(sSource, sSrcDomain, sTgtPath, sTgtDomain, pUnk);
   if ( FAILED(hr) )
      return hr;
   pUnk->Release();
   hr = pAds->SetInfo();
   pAds->Release();
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\adsprop\getproptest\objcopy.h ===
// ObjCopy.h: interface for the CObjCopy class.
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_OBJCOPY_H__B6132030_227D_11D3_8C86_0090270D48D1__INCLUDED_)
#define AFX_OBJCOPY_H__B6132030_227D_11D3_8C86_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CObjCopy  
{
public:
	CString m_strCont;
	HRESULT CopyObject(CString a_strSource, CString a_strSrcDomain, CString a_strTarget, CString a_strTgtDomain);
	CObjCopy(CString a_strContainer);
	virtual ~CObjCopy();

};

#endif // !defined(AFX_OBJCOPY_H__B6132030_227D_11D3_8C86_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\adsprop\getproptest\getproptest.h ===
// GetPropTest.h : main header file for the GETPROPTEST application
//

#if !defined(AFX_GETPROPTEST_H__B68553D2_1D10_11D3_8C81_0090270D48D1__INCLUDED_)
#define AFX_GETPROPTEST_H__B68553D2_1D10_11D3_8C81_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CGetPropTestApp:
// See GetPropTest.cpp for the implementation of this class
//

class CGetPropTestApp : public CWinApp
{
public:
	CGetPropTestApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CGetPropTestApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CGetPropTestApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_GETPROPTEST_H__B68553D2_1D10_11D3_8C81_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\adsprop\getproptest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	GetPropTest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\adsprop\getproptest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by GetPropTest.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_GETPROPTEST_DIALOG          102
#define IDR_MAINFRAME                   128
#define IDC_EDIT_SOURCE                 1001
#define IDC_EDIT_TARGET                 1002
#define IDC_EDIT_SourceDomain           1003
#define IDC_EDIT4                       1004
#define IDC_EDIT_CONTAINER              1005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1006
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\adsprop\getproptest\getproptestdlg.cpp ===
// GetPropTestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "GetPropTest.h"
#include "GetPropTestDlg.h"
#include <sddl.h>
#include "ObjCopy.h"

#import "\bin\AdsProp.tlb" no_namespace
#import "C:\\bin\\mcsvarsetmin.tlb" no_namespace
#import "c:\\bin\\mcsDctWorkerObjects.tlb" no_namespace

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGetPropTestDlg dialog

CGetPropTestDlg::CGetPropTestDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CGetPropTestDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CGetPropTestDlg)
	m_strClass = _T("");
	m_strSource = _T("");
	m_strTarget = _T("");
	m_strTargetDomain = _T("");
	m_strSourceDomain = _T("");
	m_strCont = _T("");
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CGetPropTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CGetPropTestDlg)
	DDX_Text(pDX, IDC_EDIT_SOURCE, m_strSource);
	DDX_Text(pDX, IDC_EDIT_TARGET, m_strTarget);
	DDX_Text(pDX, IDC_EDIT4, m_strTargetDomain);
	DDX_Text(pDX, IDC_EDIT_SourceDomain, m_strSourceDomain);
	DDX_Text(pDX, IDC_EDIT_CONTAINER, m_strCont);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CGetPropTestDlg, CDialog)
	//{{AFX_MSG_MAP(CGetPropTestDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CGetPropTestDlg message handlers

BOOL CGetPropTestDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

   CoInitialize(NULL);
	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
   m_strClass = L"LDAP://devblewerg/CN=Sham,cn=Users,dc=devblewerg, dc=com";
   m_strCont = L"LDAP://devblewerg/OU=ShamTest, dc=devblewerg,dc=com";
   m_strSource = L"CN=Banu,OU=ShamTest";
   m_strTarget = L"CN=XShamu123";
   m_strSourceDomain = L"devblewerg";
   m_strTargetDomain = L"devblewerg";

   UpdateData(FALSE);	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CGetPropTestDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CGetPropTestDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

void ConvertOctetToSid(	VARIANT var, PSID& pSid )
{
   void HUGEP *pArray;
   HRESULT hr = SafeArrayAccessData( V_ARRAY(&var), &pArray );
   if ( SUCCEEDED(hr) ) 
      pSid = (PSID)pArray;
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CGetPropTestDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

void CGetPropTestDlg::OnOK() 
{
   UpdateData(); 
   IObjPropBuilderPtr         pProp(__uuidof(ObjPropBuilder));
   IVarSetPtr                 pVarset(__uuidof(VarSet));
   IAcctReplPtr               pAcctRepl(__uuidof(AcctRepl));
   IUnknown                 * pUnk;
   _variant_t                 varX;

   pVarset->QueryInterface(IID_IUnknown, (void **)&pUnk);
   // If you need to use the pUnk outside of the scope of pVarset then do an AddRef and release on it,
   
   HRESULT				hr;
   //CObjCopy          objCopy(m_strCont);
   //hr = objCopy.CopyObject(m_strSource, m_strSourceDomain, m_strTarget, m_strTargetDomain);
   varX = L"Yes";
   pVarset->put("AccountOptions.CopyUsers", varX);
   pVarset->put("AccountOptions.CopyComputers", varX);
   pVarset->put("AccountOptions.CopyGlobalGroups", varX);
   pVarset->put("AccountOptions.CopyLocalGroups", varX);
   pVarset->put("AccountOptions.ReplaceExistingAccounts", varX);
//   pVarset->put("AccountOptions.ReplaceExistingGroupMembers", varX);
//   pVarset->put("AccountOptions.RemoveExistingUserRights", varX);
   pVarset->put("AccountOptions.CopyOUs", varX);
	pVarset->put("AccountOptions.DisableSourceAccounts", varX);
   pVarset->put("AccountOptions.GenerateStrongPasswords", varX);
   pVarset->put("AccountOptions.AddSidHistory", varX); 


   varX = L"mcsfox1";
   pVarset->put("Options.Credentials.Domain", varX);
   varX = L"";
   pVarset->put("Options.Credentials.Password", varX);
   varX = L"ChautSZ";
   pVarset->put("Options.Credentials.UserName", varX);

   varX = L"c:\\password.csv";
   pVarset->put("AccountOptions.PasswordFile", varX);

   varX = L"LDAP://devraptorw2k/OU=Hello,DC=devraptorw2k,Dc=com";
   pVarset->put("Options.OuPath", varX);
   
   varX = L"Hello-";
   pVarset->put("AccountOptions.Suffix", varX);
//   pVarset->put("AccountOptions.Prefix", varX);
   
   varX = L"No";
   pVarset->put("Options.NoChange", varX);
   varX = L"c:\\result.csv";
   pVarset->put("AccountOptions.CSVResultFile", varX);
   varX = L"c:\\AcctSrc.txt";
//   varX = L"c:\\NT4Source.txt";
   pVarset->put("Accounts.InputFile", varX);

   varX = L"devblewerg";
//   varX = L"MCSDEV";
   pVarset->put("Options.SourceDomain", varX);
   varX = L"devRaptorW2k";
   pVarset->put("Options.TargetDomain", varX);
   varX = L"\\\\whqblewerg1";
//   varX = L"MCSDEVEL";
   pVarset->put("Options.SourceEaServer", varX);
   varX = L"\\\\whqraptor";
   pVarset->put("Options.TargetEaServer", varX);
   varX = "c:\\DCTLogFile.txt";
   pVarset->put("Options.Logfile", varX);
   
//   varX = L"LDAP://Qamain5/CN=USERS,DC=devblewerg,DC=com";
//   varX = L"LDAP://devrdt1/CN=Users,DC=devrdt1,DC=devblewerg,DC=com";
//   varX = L"LDAP://devblewerg/OU=EvenMore,OU=more,ou=ShamTest,DC=devblewerg,DC=com";
   varX = L"OU=HELLO";
   pVarset->put("Options.OuPath", varX);

   varX.vt = VT_UI4;
   varX.lVal = 15;
   pVarset->put("Options.LogLevel", varX);

   hr = pAcctRepl->Process(pUnk);
   
   pUnk->Release();

   /*
   IObjPropBuilderPtr         pProp(__uuidof(ObjPropBuilder));
   IVarSetPtr                 pVarset(__uuidof(VarSet));
   _variant_t                 vt;

   IUnknown * pUnk;
   pVarset->QueryInterface(IID_IUnknown, (void**) &pUnk);

   pVarset->put(L"Description", L"This is from the SetVarset function");
   vt = (long) ADSTYPE_CASE_IGNORE_STRING;
   pVarset->put(L"Description.Type", vt);
   pProp->SetPropertiesFromVarset(L"LDAP://devblewerg/CN=SZC200,CN=Users,DC=devblewerg,DC=com", L"devblewerg", pUnk, ADS_ATTR_UPDATE);
   pUnk->Release();
   */
   CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\adsprop\getproptest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__B68553D6_1D10_11D3_8C81_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__B68553D6_1D10_11D3_8C81_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#include <iads.h>
#include <adshlp.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__B68553D6_1D10_11D3_8C81_0090270D48D1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\agtsvc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by DCTAgSvc.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\agtsvc\agentrpc.cpp ===
/*---------------------------------------------------------------------------
  File: AgentRpc.cpp

  Comments:  RPC interface for DCT Agent service   

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/19/99 11:39:58

 ---------------------------------------------------------------------------
*/


#include <windows.h>
#include <objbase.h>

#include "AgSvc.h"

#include "Common.hpp"
#include "UString.hpp"
#include "Err.hpp"
#include "TEvent.hpp"
#include "EaLen.hpp"
#include "Cipher.hpp"
#include "IsAdmin.hpp"
#include "ResStr.h"

//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
//#import "\bin\MCSEADCTAgent.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")
#import "Engine.tlb" no_namespace, named_guids

#include "TNode.hpp"

#ifdef OFA
#include "atlbase.h"
#endif

extern LPSTREAM              pStream;
extern TErrorEventLog        err;
extern BOOL                  gSuicide;
extern BOOL                  gDebug;
extern BOOL                  gLocallyInstalled;
extern BOOL                  gbFinished;
extern BOOL                  gbIsNt351;
extern StringLoader          gString;

DWORD RemoveService();
DWORD UnregisterFiles();
DWORD RemoveFiles(); 
DWORD RegisterDLL(const WCHAR * filename);
DWORD RegisterExe(const WCHAR * filename);
BOOL IsLocallyInstalled();

DWORD __stdcall 
   ShutdownService(
      /* [in] */ DWORD    bFlags
   );



TNodeList                    gJobList;

class TJobNode : public TNode
{
   WCHAR                   guid[LEN_Guid];
public:
   TJobNode(WCHAR const * id) { safecopy(guid,id); }
   WCHAR const * JobID() { return guid; }
};

// thread entry point, waits for the specified job to end,
// then shuts down the DCTAgentService
DWORD __stdcall
   MonitorJob( 
      void                 * arg           // in - BSTR job ID
   )
{
   HRESULT                   hr = CoInitialize(NULL);
   _bstr_t                   jobID = (BSTR)arg;
   IDCTAgent               * pLocalAgent = NULL;
   BOOL                      bDone = FALSE;
   
   try { 
   // Get a pointer to the local agent
   if ( SUCCEEDED(hr) )
   {
      hr = CoUnmarshalInterface( pStream, IID_IDCTAgent,(void**)&pLocalAgent);
      if ( SUCCEEDED(hr) )
      {
         // Reset the stream to the beginning
         LARGE_INTEGER           offset =  { 0,0 };
         ULARGE_INTEGER          result =  { 0,0 };
      
         hr = pStream->Seek(offset,STREAM_SEEK_SET,&result);

      }

      // Get the status of the job
      IUnknown             * pUnk = NULL;

      if ( SUCCEEDED(hr) )
      {
         do { 
            hr = pLocalAgent->raw_QueryJobStatus(jobID,&pUnk);
            if ( SUCCEEDED(hr) )
            {
               IVarSetPtr          pVarSet = pUnk;
               _bstr_t             status = pVarSet->get(GET_BSTR(DCTVS_JobStatus));

               if ( gDebug )
               {
//*                  err.DbgMsgWrite(0,L"Monitoring job %ls, Status: %ls",(WCHAR*)jobID, (WCHAR*)status);
                  err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_MONJOBSTAT),(WCHAR*)jobID, (WCHAR*)status);
               }
               if ( ! UStrICmp(status,GET_STRING(IDS_DCT_Status_Completed)) )
               {
                  bDone = TRUE;
                  break;
               }
            }
            pUnk->Release();
            pUnk = NULL;
            Sleep(60*1000);   // one minute
         }
         while ( SUCCEEDED(hr) );
//         int x = pLocalAgent->Release();
         pLocalAgent->Release();
      }
      
      // TODO:  make this an option
      if ( bDone )
      {
         hr = ShutdownService(0);
      }
      CoUninitialize();
   }
   }
   catch ( ... )
   {
//*      err.DbgMsgWrite(0,L"An exception occurred while monitoring the job.  Shutting down the agent service.");
      err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_MONERROR));
      try { 
         pLocalAgent->Release();
      }
      catch ( ... )
      {
      }
   }
   if ( gDebug )
//*      err.DbgMsgWrite(0,L"MonitorJob exiting, hr = %lx",hr);
      err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_MONEXIT),hr);
   return hr;
}

DWORD 
   AuthenticateClient(
      handle_t               hBinding        // in - binding for client call
   )
{
   DWORD                     rc;
   
   rc = RpcImpersonateClient(hBinding);
   if ( rc )
   {
      err.SysMsgWrite(ErrE,rc,DCT_MSG_FAILED_TO_IMPERSONATE_D,rc);
   }
   else 
   {
      rc = IsAdminLocal();
      if ( rc )
      {
         err.SysMsgWrite(ErrE,rc,DCT_MSG_CLIENT_NOT_ADMIN_D, rc);
      }

      RpcRevertToSelf();
   }
   return rc;
}
DWORD 
   RegisterPlugInFiles(
      IVarSet              * pVarSet
   )
{
   DWORD                     rc = 0;
   WCHAR                     key[MAX_PATH + 50];
   int                       nFiles = 0;
   _bstr_t                   filename;

   do 
   {
      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Starting plug-in file registration.");
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_STARTPLUGREG));
      
      swprintf(key,GET_STRING(IDS_DCTVSFmt_PlugIn_RegisterFiles_D),nFiles);
      filename = pVarSet->get(key);

      if ( filename.length() != 0 )
      {
         if ( gDebug )
//*            err.DbgMsgWrite(0,L"File %ld = %ls",nFiles,(WCHAR*)filename);
            err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_FILEREG),nFiles,(WCHAR*)filename);

         if ( !UStrICmp((WCHAR *)filename + filename.length() - 4,L".DLL") )
         {
            RegisterDLL(filename);   
         }
         else
         {
            RegisterExe(filename);
         }
         nFiles++;
      }

   } while (filename.length() != 0);
   if ( gDebug )
//*      err.DbgMsgWrite(0,L"Done Registering plug-in files.");
      err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_PLUGREGDONE));
   return rc;
}

DWORD __stdcall 
   EaxsSubmitJob( 
      /* [in] */ handle_t hBinding,
      /* [string][in] */ const WCHAR __RPC_FAR *filename,
      /* [string][in] */ const WCHAR __RPC_FAR *extra,
      /* [size_is][string][out] */ WCHAR __RPC_FAR *jobGUID
   )
{
   HRESULT                   hr = 0;
   WCHAR                     filenameW[MAX_PATH];
   WCHAR                     pathW[MAX_PATH];
   IDCTAgent               * pLocalAgent = NULL;
//   BOOL                      bFileCopied = FALSE;
   BOOL                      gbDeleteOnCompletion = FALSE;

   // Make sure the client is an admin on the local machine, otherwise, forget it
   hr = AuthenticateClient(hBinding);
   if ( hr )
   {
      return hr; 
   }
   hr = CoInitialize(NULL);

   if ( FAILED(hr) )
   {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_COINITIALIZE_FAILED_D,hr);
      return hr;
   }
   safecopy(filenameW,filename);

   // get the path for our install directory
   if ( ! GetModuleFileName(NULL,pathW,DIM(pathW)) )
   {
      hr = GetLastError();
      safecopy(pathW,filenameW);
      err.SysMsgWrite(ErrW,hr,DCT_MSG_GET_MODULE_PATH_FAILED_D,hr);
   }
   else
   {
      UStrCpy(pathW + UStrLen(pathW) - UStrLen(GET_STRING(IDS_SERVICE_EXE)),filenameW, DIM(pathW));
   }


   hr = CoUnmarshalInterface( pStream, IID_IDCTAgent,(void**)&pLocalAgent);
                   // interface pointer requested in riid);
   if ( SUCCEEDED(hr) )
   {
      // Reset the stream to the beginning
      LARGE_INTEGER           offset = { 0,0 };
      ULARGE_INTEGER          result = { 0,0 };
      
      hr = pStream->Seek(offset,STREAM_SEEK_SET,&result);

      BSTR                   jobID = NULL;

      // Read the varset data from the file

      IVarSetPtr             pVarSet;
      IStoragePtr            store = NULL;

      // Try to create the COM objects
      hr = pVarSet.CreateInstance(CLSID_VarSet);
      if ( SUCCEEDED(hr) )
      {
         
         // Read the VarSet from the data file
         hr = StgOpenStorage(pathW,NULL,STGM_DIRECT | STGM_READ | STGM_SHARE_EXCLUSIVE,NULL,0,&store);
         if ( SUCCEEDED(hr) )
         {                  
            // Load the data into a new varset
            hr = OleLoad(store,IID_IUnknown,NULL,(void **)&pVarSet);
            if ( SUCCEEDED(hr) )
            {
               _bstr_t       text = pVarSet->get(GET_BSTR(DCTVS_Options_DeleteFileAfterLoad));

               if ( !UStrICmp(text,GET_STRING(IDS_YES)) )
               {
                  // Free the storage pointer to the file
                  store = NULL;
                  if ( DeleteFile(pathW) )
                  {
                     if ( gDebug )
//*                        err.DbgMsgWrite(0,L"Deleted job file %ls",pathW);
                        err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_JOBDEL),pathW);
                  }
                  else
                  {
                     err.SysMsgWrite(ErrW,GetLastError(),DCT_MSG_JOB_FILE_NOT_DELETED_SD,pathW,GetLastError());
                  }
               }
               text = pVarSet->get(GET_BSTR(DCTVS_Options_RemoveAgentOnCompletion));
               if ( !UStrICmp(text,GET_STRING(IDS_YES)))
               {
                  gbDeleteOnCompletion = TRUE;   
               }
               text = pVarSet->get(GET_BSTR(DCTVS_AgentService_DebugMode));
               if ( !UStrICmp(text,GET_STRING(IDS_YES)))
               {
                  gDebug = TRUE;
               }
               WCHAR password[LEN_Password];
               safecopy(password,extra);
               

#ifdef OFA
               if(!IsLocallyInstalled())
#endif
                  RegisterPlugInFiles(pVarSet);

               pVarSet->put(GET_BSTR(DCTVS_Options_Credentials_Password),password);
               
               hr = pLocalAgent->raw_SubmitJob(pVarSet,&jobID);
               if ( SUCCEEDED(hr)) 
               {
                  TJobNode * pnode = new TJobNode(jobID);
                  gJobList.InsertBottom(pnode);
                  err.MsgWrite(0,DCT_MSG_AGENT_JOB_STARTED_SSS,jobID,L"",L"");
               }
               else
               {
                  err.SysMsgWrite(ErrE,hr,DCT_MSG_SUBMIT_JOB_FAILED_D,hr);
               }

               if ( gbDeleteOnCompletion )
               {
                  if ( ! gLocallyInstalled )
                  {
                     gSuicide = TRUE;
      
                  }
                  if ( SUCCEEDED(hr) )
                  {
                     // Start up a thread to monitor this job and initiate a shutdown when it is completed
                     DWORD                 threadID = 0;
                     HANDLE                gThread = CreateThread(NULL,0,&MonitorJob,(void*)jobID,0,&threadID);
                  
                     CloseHandle(gThread);
                  }
                  
               }
               UStrCpy(jobGUID,jobID);
            }
            else
            {
               err.SysMsgWrite(ErrE,HRESULT_CODE(hr),DCT_MSG_VARSET_LOAD_FAILED_SD,filenameW, hr);
            }
         }
         else
         {
            err.SysMsgWrite(ErrE,HRESULT_CODE(hr),DCT_MSG_JOBFILE_OPEN_FAILED_SD,filenameW,hr);
         }
         
      }
//      int x = pLocalAgent->Release();
      pLocalAgent->Release();
   }
   else
   {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_UMARSHAL_AGENT_FAILED_D,hr);
   }
   CoUninitialize();
   return hr;
}


DWORD __stdcall 
   EaxsCancelJob( 
      /* [in] */ handle_t hBinding,
      /* [string][in] */ const WCHAR __RPC_FAR *jobGUID
   )
{
   DWORD                     rc = 0;
   HRESULT                   hr;
   IDCTAgent               * pLocalAgent = NULL;

   // make sure the client is an admin on the local machine
   rc = AuthenticateClient(hBinding);
   if ( rc )
   {
      return rc; 
   }
   
   hr = CoInitialize(NULL);
   
   if ( FAILED(hr) )
   {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_COINITIALIZE_FAILED_D,hr);
      return hr;        
   }
   
   hr = CoUnmarshalInterface( pStream, IID_IDCTAgent,(void**)&pLocalAgent);
                   // interface pointer requested in riid);
   
   if ( SUCCEEDED(hr) )
   {
      // Reset the stream to the beginning
      LARGE_INTEGER           offset =  { 0,0 };
      ULARGE_INTEGER          result = { 0,0};
      
      hr = pStream->Seek(offset,STREAM_SEEK_SET,&result);

      BSTR                   jobID;

      jobID = SysAllocString(jobGUID);

      hr = pLocalAgent->CancelJob(jobID);
      if ( SUCCEEDED(hr))
      {
         err.MsgWrite(0,DCT_MSG_JOB_CANCELLED_S,jobID);
      }
      pLocalAgent->Release();
      rc = hr;
   }
   else
   {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_UMARSHAL_AGENT_FAILED_D,hr);
   }
   CoUninitialize();
   
   return rc;
}


DWORD __stdcall
   EaxsQueryInterface(
      /* [in] */ handle_t hBinding,
      /* [out] */ LPUNKNOWN __RPC_FAR *lpAgentUnknown
   )
{
   DWORD                     rc = 0;
   HRESULT                   hr;
   IDCTAgent               * pLocalAgent = NULL;

   (*lpAgentUnknown) = NULL;
   // make sure the client is an admin on the local machine
   rc = AuthenticateClient(hBinding);
   if ( rc )
   {
      return rc; 
   }
   
   hr  = CoInitialize(NULL);

   if ( FAILED(hr) )
   {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_COINITIALIZE_FAILED_D,hr);
      return hr;
   }
                     //E_NOINTERFACE
   if ( ! gbIsNt351 )
   {
      hr = CoUnmarshalInterface( pStream, IID_IUnknown,(void**)&pLocalAgent);
                   // interface pointer requested in riid);
   
      if ( SUCCEEDED(hr) )
      {
         // Reset the stream to the beginning
         LARGE_INTEGER           offset = { 0,0 };
         ULARGE_INTEGER          result = { 0,0 };
      
         hr = pStream->Seek(offset,STREAM_SEEK_SET,&result);

         (*lpAgentUnknown) = pLocalAgent;
      }
      else 
      {
         err.SysMsgWrite(ErrE,hr,DCT_MSG_UMARSHAL_AGENT_FAILED_D,hr);
         (*lpAgentUnknown) = NULL;
      }
   }
   else
   {
      // NT 3.51 doesn't support DCOM, so there's no point in even trying this
      (*lpAgentUnknown) = NULL;
      hr = E_NOTIMPL;
   }
   return hr;
}
 

#define DCTAgent_Remove             1

DWORD __stdcall 
   ShutdownService(
      /* [in] */ DWORD    bFlags
   )
{
   DWORD                     rc = 0;
   HRESULT                   hr;
//   LPUNKNOWN                 pLocalAgent = NULL;

   hr = CoInitialize(NULL);
   
   if ( bFlags )
   {
      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Set suicide flag.");
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_SETFLAG));
      gSuicide = TRUE;
   }
   else
   {
      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Did not set suicide flag");
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_NOSETFLAG));
   }

   if ( gSuicide && ! gLocallyInstalled )
   {
      if ( gDebug )
//*         err.DbgMsgWrite(ErrW,L"Removing agent");
         err.DbgMsgWrite(ErrW,GET_STRING(IDS_EVENTVW_MSG_REMOVEAGENT));
      // Uninstall the service
      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Unregistering files");
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_UNREGFILES));
      UnregisterFiles();
      // delete all files
      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Deleting files");
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_FILEDEL));
      RemoveFiles();
      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Removing service");
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_REMOVESVC));
      RemoveService();
      
   }
   else
   {
      if ( gDebug )
//*         err.DbgMsgWrite(ErrW,L"Not Removing agent");
         err.DbgMsgWrite(ErrW,GET_STRING(IDS_EVENTVW_MSG_NOREMOVEAGENT));
   }

   if ( ! gbIsNt351 )
   {
      RpcMgmtStopServerListening( NULL );
   }
   else
   {
      gbFinished = TRUE;
   }
   RpcServerUnregisterIf( NULL, NULL, FALSE );
   if ( gDebug )
//*      err.DbgMsgWrite(0,L"Stopped listening(%ld)",bFlags);
      err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_STOPLISTEN),bFlags);
   
   return rc;
}

DWORD __stdcall
   EaxsShutdown(
      /* [in] */ handle_t hBinding,
      /* [in] */ DWORD    bFlags
   )
{
   DWORD                     rc = 0;
   
   // make sure the client is an admin on the local machine
   rc = AuthenticateClient(hBinding);
   if ( rc )
   {
      return rc; 
   }
   rc = ShutdownService(bFlags);
   
   return rc;  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\agtsvc\servicetest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ServiceTest.rc
//
#define IDM_ABOUTBOX                    0x0010
#define IDD_ABOUTBOX                    100
#define IDS_ABOUTBOX                    101
#define IDD_SERVICETEST_DIALOG          102
#define IDR_MAINFRAME                   128
#define IDC_COMPUTER                    1000
#define IDC_SHUTDOWN                    1001

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\agtsvc\dctagsvc.cpp ===
/*---------------------------------------------------------------------------
  File: DCTAgentService.cpp

  Comments:  entry point and service control functions for DCTAgent service

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/19/99 11:39:58

 ---------------------------------------------------------------------------
*/
//

#include <windows.h>  
#include <lm.h>
#include <lmwksta.h>
#include <locale.h>
#include "AgSvc.h"
#include "AgSvc_s.c"

#include "Common.hpp"
#include "Err.hpp"
#include "TService.hpp"  
#include "TSync.hpp"
#include "TEvent.hpp"       
#include "TReg.hpp"
#include "TNode.hpp"
#include "ResStr.h"


//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
//#import "\bin\McsEADCTAgent.tlb" no_namespace, named_guids
#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")
#import "Engine.tlb" no_namespace, named_guids

// These global variables can be changed if required
WCHAR                const * gsEaDctProtoSeq = TEXT("ncacn_np");
WCHAR                const * gsEaDctEndPoint = TEXT("\\pipe\\EaDctRpc");

class TServerNode : public TNode
{
   WCHAR                     filename[MAX_PATH];
   BOOL                      bExe;
public:
   TServerNode(WCHAR const * fname,BOOL isExe) { safecopy(filename,fname);bExe=isExe; }
   BOOL                      IsExe() { return bExe; }
   WCHAR             const * Name() { return filename; }
};

BOOL                         gForceCli = FALSE;
BOOL                         gDebug = TRUE;
BOOL                         gHelp = FALSE;
DWORD                        gEaDctRpcMinThreads = 1;
DWORD                        gEaDctRpcMaxThreads = 20;
BOOL                         gSuicide = FALSE;
BOOL                         gLocallyInstalled = FALSE;
BOOL                         gbIsNt351 = FALSE;
BOOL                         gbFinished = FALSE;
TNodeList                    gRegisteredFiles;

IDCTAgent                  * m_pAgent = NULL;
         
StringLoader                 gString;

LPSTREAM pStream = NULL;


#define  EADCTAGENT_SEMNAME  L"EaDCTAgent.990000.Sem"

TErrorEventLog               err( L"", GET_STRING(IDS_EVENT_SOURCE), 0, 0 );
TError                     & errCommon = err;

// Provided by TService user
BOOL                                       // ret-TRUE if argument accepted
   UScmCmdLineArgs(
      char           const * arg           // in -command line argument
   )
{
		//adding bogus use of arg parameter to satisfy the compiler
   if (!arg)
	   return TRUE;

   return TRUE;
}

BOOL                                       // ret-TRUE if argument accepted
   UScmCmdLineArgs(
      WCHAR          const * arg           // in -command line argument
   )
{
   if ( !UStrICmp(arg,(WCHAR*)GET_STRING(IDS_DEBUG_SWITCH)) )
   {
      gDebug = TRUE;
   }
   return TRUE;
}

BOOL                                       // ret-TRUE if force CLI
   UScmForceCli()
{
   // TODO:  what should this do?
   return FALSE;
}

BOOL 
   IsLocallyInstalled()
{
   BOOL                      bFound;
   TRegKey                   key;
   DWORD                     rc;


   rc = key.Open(GET_STRING(IDS_HKLM_DomainAdmin_Key));
#ifdef OFA
   if(!rc)
   {
      BSTR buf = ::SysAllocStringLen(0, 2000);
      DWORD nMax = 2000;
      DWORD res = key.ValueGetStr(_bstr_t(L"Directory"), buf, nMax);
      ::SysFreeString(buf);
      rc = (res == ERROR_SUCCESS)?0:1;
   }
#endif

   if ( ! rc )
   {
      bFound = TRUE;
      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Agent service has been locally installed.  The Domain Administrator components will not be unregistered or removed.");
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_AGENTSVCINSTALLED));
   }
   else
   {
      bFound = FALSE;
      if  ( gDebug )
//*         err.DbgMsgWrite(0,L"Agent service has not been locally installed, rc=%ld, ",rc);
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_AGENTSVCNOTINSTALLED),rc);
   }
   return bFound;
}


void 
   CheckOSVersion()
{
   DWORD                     rc = 0;
   WKSTA_INFO_100          * info = NULL;

   // TODO:  change this to use GetVersionEx
   rc = NetWkstaGetInfo(NULL,100,(LPBYTE*)&info);
   if (! rc )
   {
      if ( info->wki100_ver_major == 3 )
      {
         if ( gDebug )
//*            err.DbgMsgWrite(0,L"This computer is running Windows NT, version %ld.%ld",info->wki100_ver_major,info->wki100_ver_minor);
            err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_OSVERSION),info->wki100_ver_major,info->wki100_ver_minor);
         gbIsNt351 = TRUE;
      }
      NetApiBufferFree(info);
   }
}

DWORD                                      // ret- HRESULT or WIN32 error
   RegisterDLL(
      WCHAR          const * filename      // in - DLL name to register (regsvr32)
   )
{
   DWORD                     rc = 0;
   HMODULE                   hDLL;
   HRESULT (STDAPICALLTYPE * lpDllEntryPoint)(void);
   HRESULT                   hr = S_OK;   
   hDLL = LoadLibrary(filename);
   if ( hDLL )
   {
      
      (FARPROC&)lpDllEntryPoint = GetProcAddress(hDLL,"DllRegisterServer");
      if (lpDllEntryPoint != NULL) 
      {
         hr = (*lpDllEntryPoint)();
         if ( FAILED(hr) )
         {
            // registration failed
            err.SysMsgWrite(ErrE,HRESULT_CODE(hr),DCT_MSG_FAILED_TO_REGISTER_FILE_SD,filename,hr);
            rc = hr;                       
         }
         else
         {
            if ( gDebug )
//*               err.DbgMsgWrite(0,L"Registered %ls",filename);
               err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_REGISTERED),filename);

            TServerNode * pNode = new TServerNode(filename,FALSE);
            gRegisteredFiles.InsertBottom(pNode);
         }
      }
      else
      {
         //unable to locate entry point
         err.MsgWrite(ErrE,DCT_MSG_DLL_NOT_REGISTERABLE_S,filename);
      }
   }
   else
   {
      rc = GetLastError();
      err.SysMsgWrite(ErrE,rc,DCT_MSG_LOAD_LIBRARY_FAILED_SD,filename,rc);
   }
   
   return rc;
}

DWORD                                      // ret- HRESULT or WIN32 error
   UnregisterDLL(
      WCHAR          const * filename      // in - name of dll to unregister
   )
{
   DWORD                     rc = 0;
   HMODULE                   hDLL;
   HRESULT (STDAPICALLTYPE * lpDllEntryPoint)(void);
   HRESULT                   hr = S_OK;   
   
   hDLL = LoadLibrary(filename);
   if ( hDLL )
   {
      
      (FARPROC&)lpDllEntryPoint = GetProcAddress(hDLL,"DllUnregisterServer");
      if (lpDllEntryPoint != NULL) 
      {
         hr = (*lpDllEntryPoint)();
         if ( FAILED(hr) )
         {
            // registration failed
            err.SysMsgWrite(ErrE,HRESULT_CODE(hr),DCT_MSG_FAILED_TO_UNREGISTER_FILE_SD,filename,hr);
            rc = hr;                       
         }
         else
         {
            if ( gDebug )
//*               err.DbgMsgWrite(0,L"Unregistered %ls",filename);
               err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_UNREGISTERED),filename);
         }
      }
      else
      {
         //unable to locate entry point
         err.MsgWrite(ErrE,DCT_MSG_DLL_NOT_UNREGISTERABLE_S,filename);
      }
   }
   else
   {
      rc = GetLastError();
      err.SysMsgWrite(ErrE,rc,DCT_MSG_LOAD_LIBRARY_FAILED_SD,filename,rc);
   }
   return rc;   
}

DWORD                                      // ret- OS return code
   RegisterExe(
      WCHAR          const * filename      // in - name of EXE to register
   )
{
   DWORD                     rc = 0;
   WCHAR                     cmdline[1000];
   STARTUPINFO               sInfo;
   PROCESS_INFORMATION       pInfo;

   memset(&sInfo,0,(sizeof sInfo));
   memset(&pInfo,0,(sizeof pInfo));

   sInfo.cb = (sizeof sInfo);
   
   swprintf(cmdline,L"%ls /REGSERVER",filename);
   if ( ! CreateProcess(NULL,cmdline,NULL,NULL,FALSE,0,NULL,NULL,&sInfo,&pInfo) )
   {
      rc = GetLastError();
   }
   else 
   {
      // TODO:  wait for the registration to complete
      DWORD             exitCode = 0;
      int               count = 0;         
      do 
      {
         Sleep(100);
         if (! GetExitCodeProcess(pInfo.hProcess,&exitCode) )
            break;
         count++;
      } while ( exitCode == STILL_ACTIVE && ( count < 500 ) );
      CloseHandle(pInfo.hProcess);
   }
   
   if ( rc == ERROR_SUCCESS)
   {
      rc = 0; // success
      TServerNode * pNode = new TServerNode(filename,TRUE);
      gRegisteredFiles.InsertBottom(pNode);
      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Registered %ls",filename);
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_REGISTERED),filename);

   }
   else
   {
      err.SysMsgWrite(ErrE,rc,DCT_MSG_FAILED_TO_REGISTER_FILE_SD,filename,rc);
   }
   return rc;
}

DWORD                                     //ret- OS return code
   UnregisterExe(
      WCHAR          const * filename     // in - name of EXE to unregister
   )
{
   DWORD                     rc = 0;
   char                      cmdline[1000];

   sprintf(cmdline,"%ls /UNREGSERVER",filename);
   rc = WinExec(cmdline,FALSE);
   
   if ( rc > 31 )
   {
      rc = 0; // success
   }
   else
   {
      err.SysMsgWrite(ErrE,rc,DCT_MSG_FAILED_TO_UNREGISTER_FILE_SD,filename,rc);
   }
   return rc;
}


DWORD    
   UnregisterFiles()
{
//   DWORD                     rc = 0;
   TNodeListEnum             e;
   TServerNode             * pNode;
   TServerNode             * pNext;

   for ( pNode = (TServerNode *)e.OpenFirst(&gRegisteredFiles) ;  pNode ; pNode = pNext )
   {
      pNext = (TServerNode*)e.Next();
      
      if ( pNode->IsExe() )
      {
         UnregisterExe(pNode->Name());
      }
      else
      {
         UnregisterDLL(pNode->Name());
      }
      gRegisteredFiles.Remove(pNode);
      delete pNode;
   }
  
   return 0;
}

DWORD    
   RemoveFiles()
{
   DWORD                     rc = 0;
   WCHAR                     pathWC[MAX_PATH];
   WCHAR                     pathW[MAX_PATH] = L"";
   WCHAR                     fullpath[MAX_PATH];
   HANDLE                    h;
   WIN32_FIND_DATA           fDat;


   // get the path for our install directory
   if ( ! GetModuleFileName(NULL,pathW,DIM(pathW)) )
   {
      rc = GetLastError();
      err.SysMsgWrite(ErrE,rc,DCT_MSG_GET_MODULE_PATH_FAILED_D,rc);
   }
   else
   {
      WCHAR *pszAgentSvcPath;
#ifdef OFA
      pszAgentSvcPath = L"OnePointFileAdminAgent\\OFAAgentService.exe";
#else
      pszAgentSvcPath = L"OnePointDomainAgent\\DCTAgentService.exe";
#endif
      if ( !UStrICmp(pathW + UStrLen(pathW) - UStrLen(GET_STRING(IDS_AGENT_DIRECTORY)) - UStrLen(GET_STRING(IDS_SERVICE_EXE))-1,pszAgentSvcPath) )
      {
         // this is our install directory.  Delete all the files from it, then remove the directory
         UStrCpy(pathWC,pathW,UStrLen(pathW)-UStrLen(GET_STRING(IDS_SERVICE_EXE)));
         UStrCpy(pathWC+UStrLen(pathWC),"\\*");
         
         h = FindFirstFile(pathWC,&fDat);
         if ( h != INVALID_HANDLE_VALUE )
         {
            do 
            {
               if ( fDat.cFileName[0] != L'.' )
               {
                  UStrCpy(fullpath,pathWC);
                  UStrCpy(fullpath + UStrLen(fullpath)-1, fDat.cFileName);

                  if (!DeleteFile(fullpath) && ! MoveFileEx(fullpath,NULL,MOVEFILE_DELAY_UNTIL_REBOOT) )
                  {
                     err.SysMsgWrite(ErrW,GetLastError(),DCT_MSG_DELETE_FILE_FAILED_SD,fDat.cFileName,GetLastError());
                  }
               
               }
               if ( ! FindNextFile(h,&fDat) )
               {
                  rc = GetLastError();
               }
            } while ( ! rc );
            FindClose(h);
         }
         // now delete the directory
         UStrCpy(fullpath,pathWC);
         fullpath[UStrLen(fullpath)-2] = 0;
         if(!DeleteFile(fullpath))
            MoveFileEx(fullpath,NULL,MOVEFILE_DELAY_UNTIL_REBOOT);
      }
   }

   return 0;
}


DWORD    
   RemoveService()
{
   SC_HANDLE                 hScm = OpenSCManager(NULL,SERVICES_ACTIVE_DATABASE,SC_MANAGER_ALL_ACCESS);
   DWORD                     rc = 0;

   if ( hScm && hScm != INVALID_HANDLE_VALUE )
   {
      SC_HANDLE              hService = OpenService(hScm,GET_STRING(IDS_SERVICE_NAME),DELETE);

      if ( hService && hService != INVALID_HANDLE_VALUE )
      {
         if ( ! DeleteService(hService) )
         {
            rc = GetLastError();
         }
      }
      else
      {
         rc = GetLastError();
      }
   }
   else
   {
      rc = GetLastError();
   }
   if ( rc )
   {
      err.SysMsgWrite(ErrE,rc,DCT_MSG_REMOVE_SERVICE_FAILED_D,rc);
   }
   return rc;
}

void
   UScmEp(
//      BOOL                   bService      // in -FALSE=Cli,TRUE=Service
   )
{
   DWORD                     rc = 0;
   _bstr_t                   jobID;
   _bstr_t                   filename = GET_STRING(IDS_DATA_FILE);
      
   // Register all the DCT DLLs
   
//   do { // once
   int i = 0;
   while (i == 0) 
   { // once
	  i++;
      HRESULT                   hr;
      
      hr = CoInitialize(NULL);
      if ( FAILED(hr) )
         break;
        
      _wsetlocale( LC_ALL, L".ACP" );
      // Check to see if this is NT 3.51 or not
      CheckOSVersion();

      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Initializing OLE subsystem.");
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_INITOLE));

      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Registering Components");
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_REGCOMPNT));
      rc = RegisterDLL(GET_STRING(IDS_VARSET_DLL));
      if ( rc ) break;
      rc = RegisterDLL(GET_STRING(IDS_WORKER_DLL));
      if ( rc ) break;
      rc = RegisterExe(GET_STRING(IDS_AGENT_EXE));
      if ( rc ) break;
      
      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Creating Instance of agent.");
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_CREATEAGT));
      {
         hr = CoCreateInstance(CLSID_DCTAgent,NULL,CLSCTX_ALL,IID_IDCTAgent,(void**)&m_pAgent);
         
         if ( FAILED(hr) )
         {
            if ((hr == REGDB_E_CLASSNOTREG) || (hr == E_NOINTERFACE))
            {
               // we just registered this file -- wait a few seconds and try it again
               Sleep(5000);
               hr = CoCreateInstance(CLSID_DCTAgent,NULL,CLSCTX_ALL,IID_IDCTAgent,(void**)&m_pAgent);
            }
         }
         if ( FAILED(hr) )
         {
            err.SysMsgWrite(ErrE,hr,DCT_MSG_AGENT_CREATE_FAILED_D,hr);
            rc = hr;
            break;
         }
         hr =CoMarshalInterThreadInterfaceInStream(IID_IDCTAgent,m_pAgent,&pStream);
         if ( FAILED(hr) )
         {
            err.SysMsgWrite(ErrE,hr,DCT_MSG_AGENT_MARSHAL_FAILED_D,hr);
            rc = hr;
            break;
         }
         
      }
      
      gLocallyInstalled = IsLocallyInstalled();
      
      
      // specify protocol sequence and endpoint
      // for receiving remote procedure calls

      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Initializing RPC connection.");
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_INITRPC));
      rc = RpcServerUseProtseqEp(
            const_cast<UTCHAR *>(gsEaDctProtoSeq),
            gEaDctRpcMaxThreads,
            const_cast<UTCHAR *>(gsEaDctEndPoint),
            NULL );
      if ( rc )
      {
         err.SysMsgWrite(
               ErrE,
               rc,
               DCT_MSG_RpcServerUseProtseqEp_FAILED_SDSD,
               gsEaDctProtoSeq,
               gEaDctRpcMaxThreads,
               gsEaDctEndPoint,
               rc );
         break;
      }
      // register an interface with the RPC run-time library
      rc = RpcServerRegisterIf( EaxsEaDctRpc_ServerIfHandle, NULL, NULL );
      if ( rc )
      {
         err.SysMsgWrite(
               ErrE,
               rc,
               DCT_MSG_RpcServerRegisterIf_FAILED_SDSD,
               gsEaDctProtoSeq,
               gEaDctRpcMaxThreads,
               gsEaDctEndPoint,
               rc );
         break;
      }

      rc = RpcServerRegisterAuthInfo(
               0,
               RPC_C_AUTHN_WINNT,
               0,
               0 );

      if ( gDebug )
//*         err.DbgMsgWrite(0,L"Listening...");   
         err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_LISTENQ));   
      // listen for remote procedure calls
// per Q141264       

      if (! gbIsNt351 )
      {
         // on NT 4 or higher, put ourselves into a listening state
         rc = RpcServerListen(
               gEaDctRpcMinThreads,
               gEaDctRpcMaxThreads,
               FALSE );

         if ( rc == RPC_S_ALREADY_LISTENING )
         {
            // assume this is NT 3.51
            gbIsNt351 = TRUE;
         }

      }
      if ( gbIsNt351 )
      {
         // for NT 3.51, RpcServerListen will return an error
         // we need to sit and wait for shutdown
         do 
         {
            Sleep(5000);
         } while ( ! gbFinished );
      }
   }// while ( false );
   CoUninitialize();
   if ( gDebug )
//*      err.DbgMsgWrite(0,L"Agent entry-point exiting.");
      err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_EXITENTRYP));
}


int __cdecl                                // ret-zero
   main(
      int                    argc         ,// in -argument count
      char          const ** argv          // in -argument array
   )
{
   TScmEpRc                  rcScmEp;      // TScmEp return code
   TSemaphoreNamed           cSem;         // named semaphore
   BOOL                      bExisted=FALSE; // TRUE if semaphore existed
   DWORD                     rcOs = 0;
   HRESULT                   hr = 0;

   hr = CoInitialize(NULL);
   if (FAILED(hr) )
   {
      err.SysMsgWrite(ErrE,hr,DCT_MSG_COINITIALIZE_FAILED_D,hr);
      return hr;
   }
         // Only allow one instance of EaDctAgent per machine
   rcOs = cSem.Create( EADCTAGENT_SEMNAME, 0, 1, &bExisted );
   if ( rcOs || bExisted )
   {
      err.MsgWrite(ErrE,DCT_MSG_AGENT_ALREADY_RUNNING);
      return 1;
   }

   rcScmEp = TScmEp(
         argc,
         argv,
         GET_STRING(IDS_EVENTSOURCE));

   if ( gDebug )
//*      err.DbgMsgWrite(0,L"Agent main exiting...",m_pAgent);
      err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_AGTEXITQ),m_pAgent);

   if ( m_pAgent )
   {
      if ( pStream )
      {
         CoReleaseMarshalData(pStream);
         pStream->Release();
      }
      pStream = NULL;
      m_pAgent->Release();
      m_pAgent = NULL;
   }  
   if ( gDebug )
//*      err.DbgMsgWrite(0,L"Agent main exiting!.",m_pAgent);
      err.DbgMsgWrite(0,GET_STRING(IDS_EVENTVW_MSG_AGTEXITS),m_pAgent);
   CoUninitialize();
   return 0;
}

///////////////////////////////////////////////////////////////////////////////
// Midl allocate memory
///////////////////////////////////////////////////////////////////////////////

void __RPC_FAR * __RPC_USER
   midl_user_allocate(
      size_t                 len )
{
   return new char[len];
}

///////////////////////////////////////////////////////////////////////////////
// Midl free memory
///////////////////////////////////////////////////////////////////////////////

void __RPC_USER
   midl_user_free(
      void __RPC_FAR       * ptr )
{
   delete [] ptr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\agtsvc\servicetest\agrpcutl.cpp ===
/*---------------------------------------------------------------------------
  File: AgentRpcUtil.cpp

  Comments: Functions to establish binding to DCT Agent service.
  These functions are used by the dispatcher, and the agent monitor 
  to bind to the agent service on remote machines.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:23:57

 ---------------------------------------------------------------------------
*/
#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif


// These global variables can be changed if required
TCHAR            const * gsEaDctProtoSeq = (TCHAR const *)TEXT("ncacn_np");
TCHAR            const * gsEaDctEndPoint = (TCHAR const *)TEXT("\\pipe\\EaDctRpc");


// Destroy RPC binding for connection with Agent service
DWORD                                      // ret-OS return code
   EaxBindDestroy(
      handle_t             * phBinding    ,// i/o-binding handle
      TCHAR               ** psBinding     // i/o-binding string
   )
{
   if ( *phBinding )
   {
      RpcBindingFree( phBinding );
      *phBinding = NULL;
   }

   if ( *psBinding )
   {
      RpcStringFree( psBinding );
      *psBinding = NULL;
   }

   return 0;
}




// Create RPC binding for connection with Agent Service
DWORD                                      // ret-OS return code
   EaxBindCreate(
      TCHAR          const * sComputer    ,// in -computer name
      handle_t             * phBinding    ,// out-binding handle
      TCHAR               ** psBinding    ,// out-binding string
      BOOL                   bAuthn        // in -flag whether to use authenticated RPC
   )
{
   DWORD                     rcOs;         // OS return code

   do // once or until break
   {
      EaxBindDestroy( phBinding, psBinding );
      rcOs = RpcStringBindingCompose(
            NULL,
            (TCHAR *) gsEaDctProtoSeq,
            (TCHAR *) sComputer,
            (TCHAR *) gsEaDctEndPoint,
            NULL,
            psBinding );
      if ( rcOs ) break;
      rcOs = RpcBindingFromStringBinding( *psBinding, phBinding );
      if ( rcOs || !bAuthn ) break;
      rcOs = RpcBindingSetAuthInfo(
            *phBinding,
            0,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
            RPC_C_AUTHN_WINNT,
            0,
            0 );
   }  while ( FALSE );

   if ( rcOs )
   {
      EaxBindDestroy( phBinding, psBinding );
   }

   return rcOs;
}



///////////////////////////////////////////////////////////////////////////////
// midl allocate memory
///////////////////////////////////////////////////////////////////////////////

void __RPC_FAR * __RPC_USER
   midl_user_allocate(
      size_t                 len )
{
   return new char[len];
}

///////////////////////////////////////////////////////////////////////////////
// midl free memory
///////////////////////////////////////////////////////////////////////////////

void __RPC_USER
   midl_user_free(
      void __RPC_FAR       * ptr )
{
   delete [] ptr;
   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\agtsvc\servicetest\servicetest.cpp ===
// ServiceTest.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "ServiceTest.h"
#include "ServiceTestDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CServiceTestApp

BEGIN_MESSAGE_MAP(CServiceTestApp, CWinApp)
	//{{AFX_MSG_MAP(CServiceTestApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG
	ON_COMMAND(ID_HELP, CWinApp::OnHelp)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServiceTestApp construction

CServiceTestApp::CServiceTestApp()
{
	// TODO: add construction code here,
	// Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CServiceTestApp object

CServiceTestApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CServiceTestApp initialization

BOOL CServiceTestApp::InitInstance()
{
	AfxEnableControlContainer();

	// Standard initialization
	// If you are not using these features and wish to reduce the size
	//  of your final executable, you should remove from the following
	//  the specific initialization routines you do not need.

#ifdef _AFXDLL
	Enable3dControls();			// Call this when using MFC in a shared DLL
#else
	Enable3dControlsStatic();	// Call this when linking to MFC statically
#endif

	CServiceTestDlg dlg;
	m_pMainWnd = &dlg;
	int nResponse = dlg.DoModal();
	if (nResponse == IDOK)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with OK
	}
	else if (nResponse == IDCANCEL)
	{
		// TODO: Place code here to handle when the dialog is
		//  dismissed with Cancel
	}

	// Since the dialog has been closed, return FALSE so that we exit the
	//  application, rather than start the application's message pump.
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\agtsvc\servicetest\servicetest.h ===
// ServiceTest.h : main header file for the SERVICETEST application
//

#if !defined(AFX_SERVICETEST_H__970AA2A2_24FB_11D3_8ADE_00A0C9AFE114__INCLUDED_)
#define AFX_SERVICETEST_H__970AA2A2_24FB_11D3_8ADE_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"		// main symbols

/////////////////////////////////////////////////////////////////////////////
// CServiceTestApp:
// See ServiceTest.cpp for the implementation of this class
//

class CServiceTestApp : public CWinApp
{
public:
	CServiceTestApp();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServiceTestApp)
	public:
	virtual BOOL InitInstance();
	//}}AFX_VIRTUAL

// Implementation

	//{{AFX_MSG(CServiceTestApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SERVICETEST_H__970AA2A2_24FB_11D3_8ADE_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\agtsvc\servicetest\agrpcutl.h ===
/*---------------------------------------------------------------------------
  File: AgentRpcUtil.h

  Comments: Functions to establish binding to DCT Agent service.
  These functions are used by the dispatcher, and the agent monitor 
  to bind to the agent service on remote machines.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:23:57

 ---------------------------------------------------------------------------
*/


// Create RPC binding for connection with DCT Agent
DWORD                                      // ret-OS return code
   EaxBindCreate(
      TCHAR          const * sComputer    ,// in -computer name
      handle_t             * phBinding    ,// out-binding handle
      TCHAR               ** psBinding    ,// out-binding string
      BOOL                   bAuthn        // in -authentication option
   );

DWORD                                      // ret-OS return code
   EaxBindDestroy(
      handle_t             * phBinding    ,// i/o-binding handle
      TCHAR               ** psBinding     // i/o-binding string
   );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\agtsvc\servicetest\servicetestdlg.cpp ===
// ServiceTestDlg.cpp : implementation file
//

#include "stdafx.h"
#include "ServiceTest.h"
#include "ServiceTestDlg.h"
#include "AgentRpcUtil.h"
#include "..\DCTAgentService.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
	//{{AFX_DATA_INIT(CAboutDlg)
	//}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CAboutDlg)
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
	//{{AFX_MSG_MAP(CAboutDlg)
		// No message handlers
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServiceTestDlg dialog

CServiceTestDlg::CServiceTestDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CServiceTestDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CServiceTestDlg)
	m_Computer = _T("");
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	m_hIcon = AfxGetApp()->LoadIcon(IDR_MAINFRAME);
}

void CServiceTestDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CServiceTestDlg)
	DDX_Text(pDX, IDC_COMPUTER, m_Computer);
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CServiceTestDlg, CDialog)
	//{{AFX_MSG_MAP(CServiceTestDlg)
	ON_WM_SYSCOMMAND()
	ON_WM_PAINT()
	ON_WM_QUERYDRAGICON()
	ON_BN_CLICKED(IDC_SHUTDOWN, OnShutdown)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CServiceTestDlg message handlers

BOOL CServiceTestDlg::OnInitDialog()
{
	CDialog::OnInitDialog();

	// Add "About..." menu item to system menu.

	// IDM_ABOUTBOX must be in the system command range.
	ASSERT((IDM_ABOUTBOX & 0xFFF0) == IDM_ABOUTBOX);
	ASSERT(IDM_ABOUTBOX < 0xF000);

	CMenu* pSysMenu = GetSystemMenu(FALSE);
	if (pSysMenu != NULL)
	{
		CString strAboutMenu;
		strAboutMenu.LoadString(IDS_ABOUTBOX);
		if (!strAboutMenu.IsEmpty())
		{
			pSysMenu->AppendMenu(MF_SEPARATOR);
			pSysMenu->AppendMenu(MF_STRING, IDM_ABOUTBOX, strAboutMenu);
		}
	}

	// Set the icon for this dialog.  The framework does this automatically
	//  when the application's main window is not a dialog
	SetIcon(m_hIcon, TRUE);			// Set big icon
	SetIcon(m_hIcon, FALSE);		// Set small icon
	
	// TODO: Add extra initialization here
	
	return TRUE;  // return TRUE  unless you set the focus to a control
}

void CServiceTestDlg::OnSysCommand(UINT nID, LPARAM lParam)
{
	if ((nID & 0xFFF0) == IDM_ABOUTBOX)
	{
		CAboutDlg dlgAbout;
		dlgAbout.DoModal();
	}
	else
	{
		CDialog::OnSysCommand(nID, lParam);
	}
}

// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CServiceTestDlg::OnPaint() 
{
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
		CDialog::OnPaint();
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
HCURSOR CServiceTestDlg::OnQueryDragIcon()
{
	return (HCURSOR) m_hIcon;
}

DWORD TryShutdown(handle_t hBinding,DWORD arg)
{
   DWORD                     rc;

   RpcTryExcept
   {
      // the job file has been copied to the remote computer 
      // during the installation
      rc = EaxcShutdown(hBinding,arg);
   }
   RpcExcept(1)
   {
      rc = RpcExceptionCode();
   }
   RpcEndExcept
   return rc;
}

void CServiceTestDlg::OnShutdown() 
{
   UpdateData(TRUE);
  	
   // try to bind to the service on the specified server
   DWORD                     rc = 0;
   handle_t                  hBinding = NULL;
   WCHAR                   * sBinding = NULL;
   CString                   msg;
   
   rc = EaxBindCreate(m_Computer.GetBuffer(0),&hBinding,&sBinding,TRUE);
   if ( rc )
   {
      msg.Format(L"Failed to bind to the agent service, rc=%ld",rc);
      MessageBox(msg);
   }
   if( ! rc )
   {
      rc = TryShutdown(hBinding,0);
      if ( ! rc )
      {
         MessageBox(L"Service shutdown successfully.");
      }
      else
      {
         msg.Format(L"Service shutdown failed, rc=%ld",rc);
         MessageBox(msg);
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\agtsvc\servicetest\servicetestdlg.h ===
// ServiceTestDlg.h : header file
//

#if !defined(AFX_SERVICETESTDLG_H__970AA2A4_24FB_11D3_8ADE_00A0C9AFE114__INCLUDED_)
#define AFX_SERVICETESTDLG_H__970AA2A4_24FB_11D3_8ADE_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

/////////////////////////////////////////////////////////////////////////////
// CServiceTestDlg dialog

class CServiceTestDlg : public CDialog
{
// Construction
public:
	CServiceTestDlg(CWnd* pParent = NULL);	// standard constructor

// Dialog Data
	//{{AFX_DATA(CServiceTestDlg)
	enum { IDD = IDD_SERVICETEST_DIALOG };
	CString	m_Computer;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CServiceTestDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);	// DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	HICON m_hIcon;

	// Generated message map functions
	//{{AFX_MSG(CServiceTestDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	afx_msg void OnPaint();
	afx_msg HCURSOR OnQueryDragIcon();
	afx_msg void OnShutdown();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SERVICETESTDLG_H__970AA2A4_24FB_11D3_8ADE_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\agtsvc\servicetest\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	ServiceTest.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\addtogrp\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\agtsvc\servicetest\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__970AA2A6_24FB_11D3_8ADE_00A0C9AFE114__INCLUDED_)
#define AFX_STDAFX_H__970AA2A6_24FB_11D3_8ADE_00A0C9AFE114__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__970AA2A6_24FB_11D3_8ADE_00A0C9AFE114__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\addtogrp\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__D228C861_3644_11D3_8C9B_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__D228C861_3644_11D3_8C9B_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__D228C861_3644_11D3_8C9B_0090270D48D1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\addtogrp\addtogrp.cpp ===
// AddToGroup.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f AddToGroupps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "AddToGrp.h"

#include "AddToGrp_i.c"
#include "GrpUpdt.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_GroupUpdate, CGroupUpdate)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
         ATLTRACE(_T("{AddToGroup.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_ATTACH,...)\n"), hInstance);
       _Module.Init(ObjectMap, hInstance, &LIBID_ADDTOGROUPLib);
        DisableThreadLibraryCalls(hInstance);
        _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
        ATLTRACE(_T("{AddToGroup.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_DETACH,...)\n"), hInstance);
        _Module.Term();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\addtogrp\grpupdt.h ===
//---------------------------------------------------------------------------
// GrpUpdt.h
//
// Comment: This is a COM object extension for the MCS DCTAccountReplicator.
//          This object implements the IExtendAccountMigration interface. 
//          The Process method adds the migrated account to the specified
//          group on source and target domain. The Undo function removes these
//          from the specified group.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifndef __GROUPUPDATE_H_
#define __GROUPUPDATE_H_

#include "resource.h"       // main symbols
#include "ExtSeq.h"
/////////////////////////////////////////////////////////////////////////////
// CGroupUpdate
class ATL_NO_VTABLE CGroupUpdate : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CGroupUpdate, &CLSID_GroupUpdate>,
	public IDispatchImpl<IExtendAccountMigration, &IID_IExtendAccountMigration, &LIBID_ADDTOGROUPLib>
{
public:
	CGroupUpdate()
	{
      m_sName = L"";
      m_sDesc = L"";
      m_Sequence = AREXT_DEFAULT_SEQUENCE_NUMBER;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_GROUPUPDATE)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CGroupUpdate)
	COM_INTERFACE_ENTRY(IExtendAccountMigration)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IExtendAccountMigration
public:
   STDMETHOD(ProcessUndo)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in, out]*/ IUnknown ** pPropToSet);
	STDMETHOD(PreProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet);
	STDMETHOD(ProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet);
	STDMETHOD(get_sDesc)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sDesc)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_sName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sName)(/*[in]*/ BSTR newVal);
   STDMETHOD(get_SequenceNumber)(/*[out, retval]*/ LONG * value) { (*value) = m_Sequence; return S_OK; }
private:
	_bstr_t m_sDesc;
	_bstr_t m_sName;
   long    m_Sequence;
};

#endif //__GROUPUPDATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\addtogrp\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AddToGrp.rc
//
#define IDS_PROJNAME                    100
#define IDR_GROUPUPDATE                 101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\disacct\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\disacct\disacct.cpp ===
//---------------------------------------------------------------------------
// DisableTarget.cpp
//
// Comment: This is a COM object extension for the MCS DCTAccountReplicator.
//          This object implements the IExtendAccountMigration interface. In
//          the process method this object disables the Source and the Target
//          accounts depending on the settings in the VarSet.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------

#include "stdafx.h"
#include "ResStr.h"
#include <lm.h>
#include <activeds.h>
#include "AcctDis.h"
#include "DisAcct.h"
#include "ARExt.h"
#include "ARExt_i.c"
#include "ErrDCT.hpp"
//#import "\bin\McsVarSetMin.tlb" no_namespace
//#import "\bin\DBManager.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")
#import "DBMgr.tlb" no_namespace

const int  LEN_Path = 255;
StringLoader                 gString;
/////////////////////////////////////////////////////////////////////////////
// CDisableTarget

//---------------------------------------------------------------------------
// Get and set methods for the properties.
//---------------------------------------------------------------------------
STDMETHODIMP CDisableTarget::get_sName(BSTR *pVal)
{
   *pVal = m_sName;
	return S_OK;
}

STDMETHODIMP CDisableTarget::put_sName(BSTR newVal)
{
   m_sName = newVal;
	return S_OK;
}

STDMETHODIMP CDisableTarget::get_sDesc(BSTR *pVal)
{
   *pVal = m_sDesc;
	return S_OK;
}

STDMETHODIMP CDisableTarget::put_sDesc(BSTR newVal)
{
   m_sDesc = newVal;
	return S_OK;
}


//---------------------------------------------------------------------------
// ProcessObject : This method doesn't do anything.
//---------------------------------------------------------------------------
STDMETHODIMP CDisableTarget::PreProcessObject(
                                             IUnknown *pSource,         //in- Pointer to the source AD object
                                             IUnknown *pTarget,         //in- Pointer to the target AD object
                                             IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                             IUnknown **ppPropsToSet    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                        //         once all extension objects are executed.
                                          )
{
   // Check if the object is of user type. if not then there is no point in disabling that account.
   IVarSetPtr                   pVs = pMainSettings;
   _bstr_t sType = pVs->get(GET_BSTR(DCTVS_CopiedAccount_Type));
   if (!sType.length())
	   return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
   if (UStrICmp((WCHAR*)sType,L"user"))
      return S_OK;

   if ( pSource )
   {
//      HRESULT                      hr = S_OK;
      _variant_t                   vtExp;
      _variant_t                   vtFlag;
      _bstr_t                      sSourceType;
      IIManageDBPtr                pDb = pVs->get(GET_BSTR(DCTVS_DBManager));

      sSourceType = pVs->get(GET_BSTR(DCTVS_CopiedAccount_Type));

      if ( !_wcsicmp((WCHAR*) sSourceType, L"user") )
      {
         // Get the expiration date and put it into the AR Node.
         _bstr_t sSam = pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
         _bstr_t sComp = pVs->get(GET_BSTR(DCTVS_Options_SourceServer));
         USER_INFO_3  * pInfo = NULL;
         DWORD rc = NetUserGetInfo((WCHAR*) sComp, (WCHAR*)sSam, 3, (LPBYTE*)&pInfo);

         if ( !rc )
         {
            vtExp = (long)pInfo->usri3_acct_expires;
            pVs->put(GET_BSTR(DCTVS_CopiedAccount_ExpDate), vtExp);

            // Get the ControlFlag and store it into the AR Node.
            vtFlag = (long)pInfo->usri3_flags;
            pVs->put(GET_BSTR(DCTVS_CopiedAccount_UserFlags), vtFlag);
            if ( pInfo ) NetApiBufferFree(pInfo);
         }
      }
      pDb->raw_SaveUserProps(pMainSettings);
   }
   return S_OK;
}
//---------------------------------------------------------------------------
// ProcessObject : This method checks in varset if it needs to disable any
//                 accounts. If it does then it disables those accounts.
//---------------------------------------------------------------------------
STDMETHODIMP CDisableTarget::ProcessObject(
                                             IUnknown *pSource,         //in- Pointer to the source AD object
                                             IUnknown *pTarget,         //in- Pointer to the target AD object
                                             IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                             IUnknown **ppPropsToSet    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                        //         once all extension objects are executed.
                                          )
{
   IVarSetPtr                pVarSet = pMainSettings;
   _variant_t                var;
   DWORD                     paramErr;
   USER_INFO_3             * info = NULL;
   long                      rc;
   WCHAR                     strDomain[LEN_Path];
   WCHAR                     strAcct[LEN_Path];
   HRESULT                   hr = S_OK;
   TErrorDct                 err;
   WCHAR                     fileName[LEN_Path];
   BOOL                      bDisableSource = FALSE;
   BOOL                      bExpireSource = FALSE;
   _bstr_t                   temp;
   time_t                    expireTime = 0;
   _bstr_t                   bstrSameForest;
   BOOL                      bSameAsSource = FALSE;
   BOOL                      bDisableTarget = FALSE;
   BOOL                      bGotSrcState = FALSE;
   BOOL                      bSrcDisabled = FALSE;

   bstrSameForest = pVarSet->get(GET_BSTR(DCTVS_Options_IsIntraforest));

   if (! UStrICmp((WCHAR*)bstrSameForest,GET_STRING(IDS_YES)) )
   {
      // in the intra-forest case, we are moving the user accounts, not 
      // copying them, so these disabling/expiring options don't make any sense
      return S_OK;
   }
   // Get the Error log filename from the Varset
   var = pVarSet->get(GET_BSTR(DCTVS_Options_Logfile));
   wcscpy(fileName, (WCHAR*)V_BSTR(&var));
   VariantInit(&var);
   // Open the error log
   err.LogOpen(fileName, 1);

   // Check if the object is of user type. if not then there is no point in disabling that account.
   var = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_Type));
   if ( UStrICmp(var.bstrVal,L"user"))
   {
      return S_OK;
   }

      //set flags based on user selections
   temp = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_DisableSourceAccounts));
   if ( ! UStrICmp(temp,GET_STRING(IDS_YES)) )
   {
      bDisableSource = TRUE;
   }
   temp = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_DisableCopiedAccounts));
   if ( ! UStrICmp(temp,GET_STRING(IDS_YES)) )
   {
      bDisableTarget = TRUE;
   }
   temp = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_TgtStateSameAsSrc));
   if ( ! UStrICmp(temp,GET_STRING(IDS_YES)) )
   {
      bSameAsSource = TRUE;
   }

   /* process the source account */
      //if expire source accounts was set, retrieve the expire time, now given to us in
      //number of days from now
   temp = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExpireSourceAccounts));
   if ( temp.length() )
   {
	  long oneDay = 24 * 60 * 60; // number of seconds in 1 day

         //get days until expire
      long lExpireDays = _wtol(temp);
	     //get the current time
	  time_t currentTime = time(NULL);
         //convert current time to local time
      struct tm  * convtm;
      convtm = localtime(&currentTime);
	     //rollback to this morning
      convtm->tm_hour = 0;
      convtm->tm_min = 0;
      convtm->tm_sec = 0;

         //convert this time back to GMT
	  expireTime = mktime(convtm);
	     //move forward to tonight at midnight
      expireTime += oneDay;

	     //now add the desired number of days
      expireTime += lExpireDays * oneDay;

      bExpireSource = TRUE;
   }

      //get source account state
   var = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
   wcscpy(strAcct, (WCHAR*)V_BSTR(&var));
   var = pVarSet->get(GET_BSTR(DCTVS_Options_SourceServer));
   wcscpy(strDomain, (WCHAR*)V_BSTR(&var));
   // we will use the net APIs to disable the source account
   rc = NetUserGetInfo(strDomain, strAcct, 3, (LPBYTE *)&info);
   if (rc != 0) 
   {
      hr = S_FALSE;
      err.SysMsgWrite(ErrW, rc, DCT_MSG_DISABLE_SOURCE_FAILED_SD, strAcct, rc);
   }
   else
   {
	     //set current source account state
	  if (info->usri3_flags & UF_ACCOUNTDISABLE)
	     bSrcDisabled = TRUE;
	     //also save the flags in the varset to be used in setpass ARExt
      _variant_t vtFlag = (long)info->usri3_flags;
      pVarSet->put(GET_BSTR(DCTVS_CopiedAccount_UserFlags), vtFlag);

         //disable the source account if requested
      if (bDisableSource)
	  {
            // Set the disable flag
         info->usri3_flags |= UF_ACCOUNTDISABLE;
         err.MsgWrite(0,DCT_MSG_SOURCE_DISABLED_S, strAcct);
	  }
   
         //expire the account in given timeframe, if requested
      if ( bExpireSource )
	  {
         if (((time_t)info->usri3_acct_expires == TIMEQ_FOREVER) 
		     || ((time_t)info->usri3_acct_expires > expireTime))
		 {
            info->usri3_acct_expires = (DWORD)expireTime;
            err.MsgWrite(0,DCT_MSG_SOURCE_EXPIRED_S,strAcct);
		 }
         else
            err.MsgWrite(0, DCT_MSG_SOURCE_EXPIRATION_EARLY_S, strAcct);
	  }
         
         //if changed, set the source information into the Domain.
      if (bDisableSource || bExpireSource)
	  {
         rc = NetUserSetInfo(strDomain,strAcct, 3, (LPBYTE)info, &paramErr);
         if ( rc )
            err.SysMsgWrite(0,rc,DCT_MSG_ACCOUNT_DISABLE_OR_EXPIRE_FAILED_SD,strAcct,rc);
	  }
      NetApiBufferFree((LPVOID) info);
   }//if got current src account state
   

   /* process the target account */
      //get the target state
   var = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
   wcscpy(strAcct, (WCHAR*)V_BSTR(&var));
   var = pVarSet->get(GET_BSTR(DCTVS_Options_TargetServer));
   wcscpy(strDomain, (WCHAR*)V_BSTR(&var));
      // we will use the net APIs to disable the target account
   rc = NetUserGetInfo(strDomain, strAcct, 3, (LPBYTE *)&info);
   if (rc != 0) 
   {
      hr = S_FALSE;
      err.SysMsgWrite(ErrW, rc, DCT_MSG_DISABLE_TARGET_FAILED_SD, strAcct, rc);
   }
   else
   {
         //disable the target if requested
      if (bDisableTarget)
	  {
         // Set the disable flag
         info->usri3_flags |= UF_ACCOUNTDISABLE;
         // Set the information into the Domain.
         rc = NetUserSetInfo(strDomain, strAcct, 3, (LPBYTE)info, &paramErr);
         err.MsgWrite(0,DCT_MSG_TARGET_DISABLED_S, strAcct);
      }
	     //else make target same state as source was
	  else if (bSameAsSource) 
	  {
            //if the source was disabled, disable the target
         if (bSrcDisabled)
		 {
               //disable the target
            info->usri3_flags |= UF_ACCOUNTDISABLE;
               // Set the information into the Domain.
            rc = NetUserSetInfo( strDomain, strAcct, 3, (LPBYTE)info, &paramErr);
            err.MsgWrite(0,DCT_MSG_TARGET_DISABLED_S, strAcct);
		 }
	     else //else make sure target is enabled and not set to expire
		 {
            info->usri3_flags &= ~UF_ACCOUNTDISABLE;
            rc = NetUserSetInfo(strDomain,strAcct,3,(LPBYTE)info,&paramErr);
		 }
	  }
	  else //else make sure target is enabled and not set to expire
	  {
         info->usri3_flags &= ~UF_ACCOUNTDISABLE;
         rc = NetUserSetInfo(strDomain,strAcct,3,(LPBYTE)info,&paramErr);
	  }
      NetApiBufferFree((LPVOID) info);
   }
   
   return hr;
}


//---------------------------------------------------------------------------
// ProcessUndo : This function Enables the accounts that were previously 
//               disabled..
//---------------------------------------------------------------------------
STDMETHODIMP CDisableTarget::ProcessUndo(                                             
                                             IUnknown *pSource,         //in- Pointer to the source AD object
                                             IUnknown *pTarget,         //in- Pointer to the target AD object
                                             IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                             IUnknown **ppPropsToSet    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                        //         once all extension objects are executed.
                                          )
{
   IVarSetPtr                pVarSet = pMainSettings;
   IIManageDBPtr             pDb = pVarSet->get(GET_BSTR(DCTVS_DBManager));
   _variant_t                var;
   DWORD                     paramErr;
   USER_INFO_3             * info;
   long                      rc;
   WCHAR                     strDomain[LEN_Path];
   WCHAR                     strAcct[LEN_Path];
   HRESULT                   hr = S_OK;
   TErrorDct                 err;
   IUnknown                * pUnk = NULL;
   _bstr_t                   sSourceName, sSourceDomain, sTgtDomain;
   WCHAR                     fileName[LEN_Path];
   IVarSetPtr                pVs(__uuidof(VarSet));
   _variant_t                vtExp, vtFlag;
   _bstr_t                   sDomainName = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));

   pVs->QueryInterface(IID_IUnknown, (void**)&pUnk);

   sSourceName = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
   sSourceDomain = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
   sTgtDomain = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));

   hr = pDb->raw_GetUserProps(sSourceDomain, sSourceName, &pUnk);
   if ( pUnk ) pUnk->Release();

   if ( hr == S_OK )
   {
      vtExp = pVs->get(GET_BSTR(DCTVS_CopiedAccount_ExpDate));      
      vtFlag = pVs->get(GET_BSTR(DCTVS_CopiedAccount_UserFlags));      
   }

   // Get the Error log filename from the Varset
   var = pVarSet->get(GET_BSTR(DCTVS_Options_Logfile));
   wcscpy(fileName, (WCHAR*)V_BSTR(&var));
   VariantInit(&var);
   // Open the error log
   err.LogOpen(fileName, 1);

   // Check if the object is of user type. if not then there is no point in disabling that account.
   var = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_Type));
   if ( _wcsicmp((WCHAR*)V_BSTR(&var),L"user") != 0 )
      return S_OK;

   _bstr_t sDis = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_DisableSourceAccounts));
   _bstr_t sExp = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_ExpireSourceAccounts));


   if ( !wcscmp((WCHAR*)sDis,GET_STRING(IDS_YES)) || sExp.length() )
   {
      // Reset the flag and the expiration date for the source account.
      var = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
      wcscpy(strAcct, (WCHAR*)V_BSTR(&var));
      var = pVarSet->get(GET_BSTR(DCTVS_Options_SourceServer));
      wcscpy(strDomain, (WCHAR*)V_BSTR(&var));
      // we will use the net APIs to disable the source account
      rc = NetUserGetInfo( strDomain, strAcct, 3, (LPBYTE *)&info);
      if (rc != 0) 
      {
         hr = S_FALSE;
         err.SysMsgWrite(ErrW, rc, DCT_MSG_ENABLE_SOURCE_FAILED_SD, strAcct, rc);
      }
      else
      {
         // Set the disable flag
         info->usri3_flags = vtFlag.lVal;
         info->usri3_acct_expires = vtExp.lVal;
         // Set the information into the Domain.
         rc = NetUserSetInfo(strDomain,strAcct, 3, (LPBYTE)info, &paramErr);
         NetApiBufferFree((LPVOID) info);
         err.MsgWrite(0,DCT_MSG_SOURCE_ENABLED_S, (WCHAR*)strAcct);
      }
   }

   // Process the target account if the Varset is set
   var = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_DisableCopiedAccounts));
   if ( (var.vt == VT_BSTR) && (_wcsicmp((WCHAR*)V_BSTR(&var),GET_STRING(IDS_YES)) == 0) )
   {
      var = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
      wcscpy(strAcct, (WCHAR*)V_BSTR(&var));
      var = pVarSet->get(GET_BSTR(DCTVS_Options_TargetServer));
      wcscpy(strDomain, (WCHAR*)V_BSTR(&var));
      // we will use the net APIs to disable the target account
      rc = NetUserGetInfo( strDomain, strAcct, 3, (LPBYTE *)&info);
      if (rc != 0)
      {
         hr = S_FALSE;
         err.SysMsgWrite(ErrW, rc, DCT_MSG_ENABLE_TARGET_FAILED_SD, strAcct, rc);
      }
      else
      {
         // Set the disable flag
         info->usri3_flags &= !(UF_ACCOUNTDISABLE);
         // Set the information into the Domain.
         rc = NetUserSetInfo( strDomain, strAcct, 3, (LPBYTE)info, &paramErr);
         NetApiBufferFree((LPVOID) info);
         err.MsgWrite(0,DCT_MSG_TARGET_ENABLED_S, strAcct);
      }
   }
   WCHAR                     sFilter[5000];
   wsprintf(sFilter, L"SourceDomain='%s' and SourceSam='%s'", (WCHAR*)sDomainName, strAcct);
   _variant_t Filter = sFilter;
   pDb->raw_ClearTable(L"UserProps", Filter);
  
   err.LogClose();
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\addtogrp\grpupdt.cpp ===
//---------------------------------------------------------------------------
// GrpUpdt.cpp
//
// Comment: This is a COM object extension for the MCS DCTAccountReplicator.
//          This object implements the IExtendAccountMigration interface. 
//          The Process method adds the migrated account to the specified
//          group on source and target domain. The Undo function removes these
//          from the specified group.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#include "stdafx.h"
#include <lm.h>
#include "AddToGrp.h"
#include "ARExt.h"
#include "ARExt_i.c"
#include "GrpUpdt.h"
#include "ResStr.h"
#include "ErrDCT.hpp"
#include "EALen.hpp"
//#import "\bin\mcsvarsetmin.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")


StringLoader      gString;
/////////////////////////////////////////////////////////////////////////////
// CGroupUpdate

//---------------------------------------------------------------------------
// Get and set methods for the properties.
//---------------------------------------------------------------------------
STDMETHODIMP CGroupUpdate::get_sName(BSTR *pVal)
{
   *pVal = m_sName;
	return S_OK;
}

STDMETHODIMP CGroupUpdate::put_sName(BSTR newVal)
{
   m_sName = newVal;
	return S_OK;
}

STDMETHODIMP CGroupUpdate::get_sDesc(BSTR *pVal)
{
   *pVal = m_sDesc;
	return S_OK;
}

STDMETHODIMP CGroupUpdate::put_sDesc(BSTR newVal)
{
   m_sDesc = newVal;
	return S_OK;
}

//---------------------------------------------------------------------------
// PreProcessObject : This method doesn't do anything at this point
//---------------------------------------------------------------------------
STDMETHODIMP CGroupUpdate::PreProcessObject(
                                             IUnknown *pSource,         //in- Pointer to the source AD object
                                             IUnknown *pTarget,         //in- Pointer to the target AD object
                                             IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                             IUnknown **ppPropsToSet    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                        //         once all extension objects are executed.
                                          )
{
   return S_OK;
}
//---------------------------------------------------------------------------
// ProcessObject : This method adds the copied account to the specified
//                 groups on source and target domains.
//---------------------------------------------------------------------------
STDMETHODIMP CGroupUpdate::ProcessObject(
                                             IUnknown *pSource,         //in- Pointer to the source AD object
                                             IUnknown *pTarget,         //in- Pointer to the target AD object
                                             IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                             IUnknown **ppPropsToSet    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                        //         once all extension objects are executed.
                                          )
{
   IVarSetPtr                pVs = pMainSettings;
   _variant_t                var;
   _bstr_t                   sGrpName, sServer, sAcct;
   HRESULT                   hr = S_OK;
   long                      rc = 0;
   TErrorDct                 err;
   WCHAR                     fileName[LEN_Path];

   // Get the Error log filename from the Varset
   var = pVs->get(GET_BSTR(DCTVS_Options_Logfile));
   wcscpy(fileName, (WCHAR*)V_BSTR(&var));
   
   // Open the error log
   err.LogOpen(fileName, 1);

   // Process adding users to the source domain.
   var = pVs->get(GET_BSTR(DCTVS_AccountOptions_AddToGroupOnSourceDomain));
   if ( var.vt == VT_BSTR )
   {
      sGrpName = V_BSTR(&var);
      if ( sGrpName.length() > 0 )
      {
         var = pVs->get(GET_BSTR(DCTVS_Options_SourceServer));
         sServer = V_BSTR(&var);

         var = pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
         sAcct = V_BSTR(&var);
         rc = NetGroupAddUser((WCHAR*) sServer, (WCHAR *) sGrpName, (WCHAR *) sAcct);
         if ( rc != 0 )
         {
            hr = HRESULT_FROM_WIN32(rc);
            err.SysMsgWrite(ErrW, rc, DCT_MSG_ADDTO_FAILED_SSD, sAcct, sGrpName, rc);
         }
         else
         {
            err.MsgWrite(0,DCT_MSG_ADDED_TO_GROUP_SS,sAcct,sGrpName);
         }
      }
   }

   // Now process the group on the target domain.
   var = pVs->get(GET_BSTR(DCTVS_AccountOptions_AddToGroup));
   if ( var.vt == VT_BSTR )
   {
      sGrpName = V_BSTR(&var);
      if ( sGrpName.length() > 0 )
      {
         var = pVs->get(GET_BSTR(DCTVS_Options_TargetServer));
         sServer = V_BSTR(&var);

         var = pVs->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
         sAcct = V_BSTR(&var);
         rc = NetGroupAddUser((WCHAR*) sServer, (WCHAR *) sGrpName, (WCHAR *) sAcct);
         if ( rc != 0 )
         {
            hr = HRESULT_FROM_WIN32(rc);
            err.SysMsgWrite(ErrW, rc, DCT_MSG_ADDTO_FAILED_SSD, sAcct, sGrpName, rc);
         }
         else
         {
            err.MsgWrite(0,DCT_MSG_ADDED_TO_GROUP_SS,sAcct,sGrpName);
         }
      }
   }
   err.LogClose();
   return hr;
}

//---------------------------------------------------------------------------
// ProcessUndo :  This method removes the account from the specified group.
//---------------------------------------------------------------------------
STDMETHODIMP CGroupUpdate::ProcessUndo(                                             
                                          IUnknown *pSource,         //in- Pointer to the source AD object
                                          IUnknown *pTarget,         //in- Pointer to the target AD object
                                          IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                          IUnknown **ppPropsToSet    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                     //         once all extension objects are executed.
                                       )
{
   IVarSetPtr                pVs = pMainSettings;
   _variant_t                var;
   _bstr_t                   sGrpName, sServer, sAcct;
   HRESULT                   hr = S_OK;
   long                      rc = 0;
   TErrorDct                 err;
   WCHAR                     fileName[LEN_Path];

   // Get the Error log filename from the Varset
   var = pVs->get(GET_BSTR(DCTVS_Options_Logfile));
   wcscpy(fileName, (WCHAR*)V_BSTR(&var));
   VariantInit(&var);
   // Open the error log
   err.LogOpen(fileName, 1);

   // Process adding users to the source domain.
   var = pVs->get(GET_BSTR(DCTVS_AccountOptions_AddToGroupOnSourceDomain));
   if ( var.vt == VT_BSTR )
   {
      sGrpName = V_BSTR(&var);
      if ( sGrpName.length() > 0 )
      {
         var = pVs->get(GET_BSTR(DCTVS_Options_SourceServer));
         sServer = V_BSTR(&var);

         var = pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
         sAcct = V_BSTR(&var);
         rc = NetGroupDelUser((WCHAR*) sServer, (WCHAR *) sGrpName, (WCHAR *) sAcct);
         if ( rc != 0 )
         {
            hr = HRESULT_FROM_WIN32(rc);;
            err.SysMsgWrite(ErrW, rc, DCT_MSG_REMOVE_FROM_FAILED_SSD, (WCHAR *)sAcct, (WCHAR*)sGrpName, rc);
         }
         else
         {
            err.MsgWrite(0,DCT_MSG_REMOVE_FROM_GROUP_SS,(WCHAR *)sAcct,(WCHAR *)sGrpName);
         }
      }
   }

   // Now process the group on the target domain.
   var = pVs->get(GET_BSTR(DCTVS_AccountOptions_AddToGroup));
   if ( var.vt == VT_BSTR )
   {
      sGrpName = V_BSTR(&var);
      if ( sGrpName.length() > 0 )
      {
         var = pVs->get(GET_BSTR(DCTVS_Options_TargetServer));
         sServer = V_BSTR(&var);

         var = pVs->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
         sAcct = V_BSTR(&var);
         rc = NetGroupDelUser((WCHAR*) sServer, (WCHAR *) sGrpName, (WCHAR *) sAcct);
         if ( rc != 0 )
         {
            hr = HRESULT_FROM_WIN32(rc);;
            err.SysMsgWrite(ErrW, rc, DCT_MSG_REMOVE_FROM_FAILED_SSD, (WCHAR *)sAcct, (WCHAR *)sGrpName, rc);
         }
         else
         {
            err.MsgWrite(0,DCT_MSG_REMOVE_FROM_GROUP_SS,(WCHAR *)sAcct,(WCHAR *)sGrpName);
         }
      }
   }
   err.LogClose();
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\disacct\acctdis.cpp ===
// DisableTargetAccount.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f DisableTargetAccountps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "AcctDis.h"

#include "AcctDis_i.c"
#include "DisAcct.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_DisableTarget, CDisableTarget)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        ATLTRACE(_T("{DisableTargetAccount.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_ATTACH,...)\n"), hInstance);
        _Module.Init(ObjectMap, hInstance, &LIBID_DISABLETARGETACCOUNTLib);
        DisableThreadLibraryCalls(hInstance);
        _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        ATLTRACE(_T("{DisableTargetAccount.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_DETACH,...)\n"), hInstance);
        _Module.Term();
    }
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\disacct\disacct.h ===
//---------------------------------------------------------------------------
// DisableTarget.h
//
// Comment: This is a COM object extension for the MCS DCTAccountReplicator.
//          This object implements the IExtendAccountMigration interface. In
//          the process method this object disables the Source and the Target
//          accounts depending on the settings in the VarSet.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------

#ifndef __DISABLETARGET_H_
#define __DISABLETARGET_H_

#include "resource.h"       // main symbols
#include <comdef.h>
#include "ResStr.h"
#include "ExtSeq.h"
/////////////////////////////////////////////////////////////////////////////
// CDisableTarget
class ATL_NO_VTABLE CDisableTarget : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CDisableTarget, &CLSID_DisableTarget>,
	public IDispatchImpl<IExtendAccountMigration, &IID_IExtendAccountMigration, &LIBID_DISABLETARGETACCOUNTLib>
{
public:
	CDisableTarget()
	{
      m_sName = L"Disable Accounts";
      m_sDesc = L"Extensions to Disable accounts.";
      m_Sequence = AREXT_DEFAULT_SEQUENCE_NUMBER;
	}

//DECLARE_REGISTRY_RESOURCEID(IDR_DISABLETARGET)
static HRESULT WINAPI UpdateRegistry( BOOL bUpdateRegistry )
{
   _ATL_REGMAP_ENTRY         regMap[] =
   {
      { OLESTR("DISPIDVER"), GET_BSTR(IDS_COM_DisPidVer) },
      { OLESTR("DISACCT"), GET_BSTR(IDS_COM_DisTarget) },
      { OLESTR("DISPID"), GET_BSTR(IDS_COM_DisPid) },
      { 0, 0 }
   };

   return _Module.UpdateRegistryFromResourceD( IDR_DISABLETARGET, bUpdateRegistry, regMap );
}

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CDisableTarget)
	COM_INTERFACE_ENTRY(IExtendAccountMigration)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IExtendAccountMigration
public:
   STDMETHOD(ProcessUndo)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in, out]*/ IUnknown ** pPropToSet);
	STDMETHOD(PreProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet);
	STDMETHOD(ProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet);
	STDMETHOD(get_sDesc)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sDesc)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_sName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sName)(/*[in]*/ BSTR newVal);
   STDMETHOD(get_SequenceNumber)(/*[out, retval]*/ LONG * value) { (*value) = m_Sequence; return S_OK; }
private:
	_bstr_t m_sDesc;
	_bstr_t m_sName;
   long    m_Sequence;
};

#endif //__DISABLETARGET_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\disacct\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by AcctDis.rc
//
#define IDS_PROJNAME                    100
#define IDR_DISABLETARGET               101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\disacct\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__94367601_29B2_11D3_8C8D_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__94367601_29B2_11D3_8C8D_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__94367601_29B2_11D3_8C8D_0090270D48D1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\getrids\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "GetRids_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\getrids\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\getrids\exldap.cpp ===
#include "stdafx.h"
#include <winldap.h>

#include "Common.hpp"
#include "UString.hpp"
#include "EaLen.hpp"

#include "exldap.h"


CLdapConnection::CLdapConnection()
{ 
   m_exchServer[0] = 0; 
   m_LD = NULL; 
   m_port = LDAP_PORT;
   m_bUseSSL = FALSE;
   
   // try to dynamically load the LDAP DLL
   m_hDll = LoadLibrary(L"wldap32.dll");
   ldap_open = NULL;
   ldap_parse_result = NULL;
   ldap_parse_page_control = NULL;
   ldap_controls_free = NULL;
   ber_bvfree = NULL;
   ldap_first_entry = NULL;
   ldap_next_entry = NULL;
   ldap_value_free = NULL;
   ldap_get_values = NULL;
   ldap_create_page_control = NULL;
   ldap_search_ext_s = NULL;
   ldap_count_entries = NULL;
   ldap_msgfree = NULL;
   ldap_modify_s = NULL;
   LdapGetLastError = NULL;
   ldap_bind_sW = NULL;
   ldap_unbind = NULL;
   ldap_get_option = NULL;
   ldap_set_option = NULL;
   LdapMapErrorToWin32 = NULL;
   ldap_init = NULL;

   if ( m_hDll )
   {
      ldap_open = (LDAP_OPEN *)GetProcAddress(m_hDll,"ldap_openW");
      ldap_parse_result = (LDAP_PARSE_RESULT *)GetProcAddress(m_hDll,"ldap_parse_resultW");
      ldap_parse_page_control = (LDAP_PARSE_PAGE_CONTROL*)GetProcAddress(m_hDll,"ldap_parse_page_controlW");
      ldap_controls_free = (LDAP_CONTROLS_FREE*)GetProcAddress(m_hDll,"ldap_controls_freeW");
      ber_bvfree = (BER_BVFREE*)GetProcAddress(m_hDll,"ber_bvfree");
      ldap_first_entry = (LDAP_FIRST_ENTRY*)GetProcAddress(m_hDll,"ldap_first_entry");
      ldap_next_entry = (LDAP_NEXT_ENTRY*)GetProcAddress(m_hDll,"ldap_next_entry");
      ldap_value_free = (LDAP_VALUE_FREE*)GetProcAddress(m_hDll,"ldap_value_freeW");
      ldap_get_values = (LDAP_GET_VALUES*)GetProcAddress(m_hDll,"ldap_get_valuesW");
      ldap_create_page_control = (LDAP_CREATE_PAGE_CONTROL*)GetProcAddress(m_hDll,"ldap_create_page_controlW");
      ldap_search_ext_s = (LDAP_SEARCH_EXT_S*)GetProcAddress(m_hDll,"ldap_search_ext_sW");
      ldap_count_entries = (LDAP_COUNT_ENTRIES*)GetProcAddress(m_hDll,"ldap_count_entries");
      ldap_msgfree = (LDAP_MSGFREE*)GetProcAddress(m_hDll,"ldap_msgfree");
      ldap_modify_s = (LDAP_MODIFY_S*)GetProcAddress(m_hDll,"ldap_modify_sW");
      LdapGetLastError = (LDAPGETLASTERROR*)GetProcAddress(m_hDll,"LdapGetLastError");
      ldap_bind_sW = (LDAP_BIND*)GetProcAddress(m_hDll,"ldap_bind_sW");
      ldap_unbind = (LDAP_UNBIND*)GetProcAddress(m_hDll,"ldap_unbind");
      ldap_get_option = (LDAP_GET_OPTION*)GetProcAddress(m_hDll,"ldap_get_option");
      ldap_set_option = (LDAP_SET_OPTION*)GetProcAddress(m_hDll,"ldap_set_option");
      LdapMapErrorToWin32 = (LDAPMAPERRORTOWIN32*)GetProcAddress(m_hDll,"LdapMapErrorToWin32");
      ldap_init = (LDAP_INIT *)GetProcAddress(m_hDll,"ldap_initW");
   }
   
}

CLdapConnection::~CLdapConnection()
{
   Close();
   if ( m_hDll )
   {
      FreeLibrary(m_hDll);
      ldap_open = NULL;
      ldap_parse_result = NULL;
      ldap_parse_page_control = NULL;
      ldap_controls_free = NULL;
      ber_bvfree = NULL;
      ldap_first_entry = NULL;
      ldap_next_entry = NULL;
      ldap_value_free = NULL;
      ldap_get_values = NULL;
      ldap_create_page_control = NULL;
      ldap_search_ext_s = NULL;
      ldap_count_entries = NULL;
      ldap_msgfree = NULL;
      ldap_modify_s = NULL;
      LdapGetLastError = NULL;
      ldap_bind_sW = NULL;
      ldap_unbind = NULL;
      ldap_get_option = NULL;
      ldap_set_option = NULL;
      LdapMapErrorToWin32 = NULL;
      ldap_init = NULL;
   }
}


 
DWORD  CLdapConnection::Connect(WCHAR const * server, ULONG port = LDAP_PORT)
{
   DWORD                     rc = 0;

   safecopy(m_exchServer,server);

//   m_LD = CLdapConnection::ldap_open(m_exchServer,LDAP_SSL_PORT);
	  //replace ldap_open(servername,..) with ldap_init and set LDAP_OPT_AREC_EXCLUSIVE 
      //flag so that the following ldap calls (i.e. ldap_bind) will not need to 
	  //unnecessarily query for the domain controller
   m_LD = CLdapConnection::ldap_init(m_exchServer,LDAP_SSL_PORT);
   if (! m_LD )
   {
      // try the non-SSL port
      m_LD = ldap_init(m_exchServer,port);
   }
   if ( ! m_LD )
   {
      rc = CLdapConnection::LdapGetLastError();
   }
   else
   {
      ULONG                   flags = 0;
	     //set LDAP_OPT_AREC_EXCLUSIVE flag so that the following calls tp
	     //ldap_open will not need to unnecessarily query for the domain controller
      flags = PtrToUlong(LDAP_OPT_ON); 
      ldap_set_option(m_LD, LDAP_OPT_AREC_EXCLUSIVE, &flags);

	  flags = 0;
      // set version to 3
      rc = ldap_get_option(m_LD, LDAP_OPT_VERSION,&flags);

      if ( ! rc )
      {
         flags = LDAP_VERSION3;
    
         
         rc = ldap_set_option(m_LD,LDAP_OPT_VERSION, &flags);
      }

      if (! rc )
      {
         if ( *m_credentials )
         {
            rc = CLdapConnection::ldap_bind_s(m_LD,m_credentials,m_password,LDAP_AUTH_SIMPLE);
            if ( rc )
            {
               rc = CLdapConnection::ldap_bind_s(m_LD,NULL,NULL,LDAP_AUTH_NTLM);
            }
         }
         else
         {
            rc = CLdapConnection::ldap_bind_s(m_LD,NULL,NULL,LDAP_AUTH_NTLM);
         }
      }
      if ( rc )
      {
         rc = CLdapConnection::LdapMapErrorToWin32(rc);
      }
   }
   
   return rc;
}

void   CLdapConnection::Close()
{
   if ( m_LD )
   {
      CLdapConnection::ldap_unbind(m_LD);
      m_LD = NULL;
   }
}

DWORD CLdapConnection::UpdateSimpleStringValue(WCHAR const * dn, WCHAR const * property, WCHAR const * value)
{
   DWORD             rc = ERROR_NOT_FOUND;

   if ( m_LD )
   {
      LDAPMod         * mods[2];
      LDAPMod           mod1;
      WCHAR           * strVals[] = { const_cast<WCHAR*>(value),NULL };
      mods[0] = &mod1;

      mods[0]->mod_op = LDAP_MOD_REPLACE;
      mods[0]->mod_type = const_cast<WCHAR*>(property);
      mods[0]->mod_vals.modv_strvals = strVals;
      mods[1] = NULL;

      rc = CLdapConnection::ldap_modify_s(m_LD,const_cast<WCHAR*>(dn),mods);
      if ( rc )
      {
         rc = CLdapConnection::LdapMapErrorToWin32(rc);
      }
   }

   return rc;
}

// Helper function for SidToString - converts one BYTE of the SID into a string representation
void 
   CLdapConnection::AddByteToString(
      WCHAR               ** string,      // i/o- pointer to current location in string
      BYTE                   value        // in - value (from SID) to add to the string
   )
{
   WCHAR                     hi,
                             lo;
   BYTE                      hiVal, 
                             loVal;

   loVal = value & 0x0F;
   hiVal = value & 0xF0;
   hiVal = hiVal >> 4;

   if  ( hiVal < 10 )
   {
      hi=L'0' + hiVal;
   }
   else
   {
      hi=L'A' + ( hiVal - 10 );
   }

   if ( loVal < 10 )
   {
      lo=L'0' + loVal;
   }
   else
   {
      lo=L'A' + (loVal - 10 );
   }
   swprintf(*string,L"%c%c",hi,lo);

   *string+=2;
}

BYTE                                          // ret- value for the digit, or 0 if value is not a valid hex digit
   CLdapConnection::HexValue(
      WCHAR                  value           // in - character representing a hex digit
   )
{
   BYTE                      val = 0;
   switch ( toupper((char)value) )
   {
   case L'1': val = 1; break;
   case L'2': val = 2; break;
   case L'3': val = 3; break;
   case L'4': val = 4; break;
   case L'5': val = 5; break;
   case L'6': val = 6; break;
   case L'7': val = 7; break;
   case L'8': val = 8; break;
   case L'9': val = 9; break;
   case L'A': val = 0xA; break;
   case L'B': val = 0xB; break;
   case L'C': val = 0xC; break;
   case L'D': val = 0xD; break;
   case L'E': val = 0xE; break;
   case L'F': val = 0xF; break;
   }
   return val;
}


BOOL                                         // ret- 0=success, or ERROR_INSUFFICIENT_BUFFER 
   CLdapConnection::BytesToString(
      BYTE                 * pBytes,         // in - SID to represent as a string
      WCHAR                * sidString,      // out- buffer that will contain the 
      DWORD                  numBytes        // in - number of bytes in the buffer to copy
   )
{
   BOOL                      bSuccess = TRUE;
   WCHAR                   * curr = sidString;

   // add each byte of the SID to the output string
   for ( int i = 0 ; i < (int)numBytes ; i++)
   {  
      AddByteToString(&curr,pBytes[i]);
   }
   return bSuccess;
}

BOOL 
   CLdapConnection::StringToBytes(
      WCHAR          const * pString,     // in - string representing the data
      BYTE                 * pBytes       // out- binary representation of the data
   )
{
   BOOL                      bSuccess = TRUE;
   int                       len = UStrLen(pString) / 2;

   for ( int i = 0 ; i < len ; i++, pString += 2 )
   {
      // each byte is represented by 2 characters
      WCHAR                  str[3];
      BYTE                   hi,lo;

      safecopy(str,pString);
      
      hi = HexValue(str[0]);
      lo = HexValue(str[1]);

      pBytes[i] = ((hi << 4)+lo);
      
   }

   return bSuccess;
}

CLdapEnum::~CLdapEnum()
{
   if ( m_message )
   {
      m_connection.ldap_msgfree(m_message);
      m_message = NULL;
   }
}


DWORD 
   CLdapEnum::Open(
      WCHAR          const * query,          // in - query to execute
      WCHAR          const * basePoint,      // in - basepoint for query
      short                  scope,          // in - scope: 0=base only, 1=one level, 2=recursive
      long                   pageSize,       // in - page size to use for large searches
      int                    numAttributes,  // in - number of attributes to retrieve for each matching item
      WCHAR               ** attrs           // in - array of attribute names to retrieve for each matching item
   )
{
   // open and bind before calling this function
   ULONG                     result;
//   PLDAPSearch               searchBlock = NULL;
   PLDAPControl              serverControls[2];
//   l_timeval                 timeout = { 1000,1000 };
//   ULONG                     totalCount = 0;
   berval                    cookie1 = { 0, NULL };
//   DWORD                     numRead = 0;
 
   if ( m_message )
   {
      m_connection.ldap_msgfree(m_message);
      m_message = NULL;
   }

   LDAP                    * ld = m_connection.GetHandle();

   safecopy(m_query,query);
   safecopy(m_basepoint,basePoint);
   m_scope = scope;
   m_pageSize = pageSize;
   m_nAttributes = numAttributes;
   m_AttrNames = attrs;


   result = m_connection.ldap_create_page_control(ld,
                                     pageSize,
                                     &cookie1,
                                     FALSE, // is critical
                                     &serverControls[0]
                                    );

   serverControls[1] = NULL;

   result = m_connection.ldap_search_ext_s(ld,
                     m_basepoint,
                     m_scope,
                     m_query,
                     m_AttrNames,
                     FALSE,
                     serverControls,
                     NULL,
                     NULL,
                     0,
                     &m_message);
  
   if  ( ! result )
   {
      m_nReturned = m_connection.ldap_count_entries(ld,m_message);
      m_nCurrent = 0;
      m_bOpen = TRUE;
   }

  
   return m_connection.LdapMapErrorToWin32(result);
}

DWORD 
   CLdapEnum::Next(
      PWCHAR              ** ppAttrs        // out- array of values for the next matching item
   )
{
   DWORD                     rc = 0;

   if ( ! m_bOpen )
   {
      rc = ERROR_NOT_FOUND;
   }
   else
   {
      if ( m_nReturned > m_nCurrent )
      {
         // return the next entry from the current page
         return GetNextEntry(ppAttrs);
      }
      else 
      {
         // see if there are more pages of results to get
         rc = GetNextPage();
         if (! rc )
         {
            return GetNextEntry(ppAttrs);
         }
      }


   }
   return rc;
}

void CLdapEnum::FreeData(WCHAR ** values)
{
   for ( int i = 0 ; m_AttrNames[i] ; i++ )
   {
      if ( values[i] )
      {
         delete [] values[i];
         values[i] = NULL;
      }
   }
   delete [] values;
}

DWORD 
   CLdapEnum::GetNextEntry(
      PWCHAR              ** ppAttrs
   )
{
   DWORD                     rc = 0;
   WCHAR                  ** pValues = new PWCHAR[m_nAttributes+1];

   if (!pValues)
      return ERROR_NOT_ENOUGH_MEMORY;

   if ( m_nCurrent == 0 )
   {

      m_currMsg = m_connection.ldap_first_entry(m_connection.GetHandle(),m_message);
   }
   else
   {
      m_currMsg = m_connection.ldap_next_entry(m_connection.GetHandle(),m_currMsg);
      
   }
   if ( m_currMsg )
   {

      int curr;

      for ( curr = 0 ; m_AttrNames[curr] ; curr++ )
      {
         pValues[curr] = NULL;

         WCHAR ** allvals = m_connection.ldap_get_values(m_connection.GetHandle(),m_currMsg,m_AttrNames[curr] );
         if ( allvals )
         {
            pValues[curr] = new WCHAR[UStrLen(allvals[0])+1];
            if (!(pValues[curr]))
			{
			   for (int j=0; j<curr; j++)
			      delete [] pValues[j];
			   delete [] pValues;
               return ERROR_NOT_ENOUGH_MEMORY;
			}

            UStrCpy(pValues[curr],allvals[0]);
            m_connection.ldap_value_free(allvals);
            allvals =NULL;
         }
      }
      
   }
   (*ppAttrs) = pValues;
   m_nCurrent++;
   return rc;
}

DWORD 
   CLdapEnum::GetNextPage()
{
   ULONG                     result = 0;
   LDAP                    * ld = m_connection.GetHandle();
   berval                  * currCookie = NULL;
//   berval                  * cookie2 = NULL;
//   WCHAR                   * matched = NULL;
   PLDAPControl            * currControls = NULL;
   ULONG                     retcode = 0;    
//   PLDAPControl            * clientControls = NULL;
//   WCHAR                   * errMsg = NULL;
   PLDAPControl              serverControls[2];
   
 
   
   // Get the server control from the message, and make a new control with the cookie from the server
   result = m_connection.ldap_parse_result(ld,m_message,&retcode,NULL,NULL,NULL,&currControls,FALSE);
   m_connection.ldap_msgfree(m_message);
   m_message = NULL;
   if ( ! result )
   {
      result = m_connection.ldap_parse_page_control(ld,currControls,&m_totalCount,&currCookie);
      // under Exchange 5.5, before SP 2, this will fail with LDAP_CONTROL_NOT_FOUND when there are 
      // no more search results.  With Exchange 5.5 SP 2, this succeeds, and gives us a cookie that will 
      // cause us to start over at the beginning of the search results.

   }
   if ( ! result )
   {
      if ( currCookie->bv_len == 0 && currCookie->bv_val == 0 )
      {
         // under Exchange 5.5, SP 2, this means we're at the end of the results.
         // if we pass in this cookie again, we will start over at the beginning of the search results.
         result = LDAP_CONTROL_NOT_FOUND;
      }
      
      serverControls[0] = NULL;
      serverControls[1] = NULL;
      if ( ! result )
      {
         result = m_connection.ldap_create_page_control(ld,
                                 m_pageSize,
                                 currCookie,
                                 FALSE,
                                 serverControls);
      }
      m_connection.ldap_controls_free(currControls);
      currControls = NULL;
      m_connection.ber_bvfree(currCookie);
      currCookie = NULL;
   }

   // continue the search with the new cookie
   if ( ! result )
   {
      result = m_connection.ldap_search_ext_s(ld,
            m_basepoint,
            m_scope,
            m_query,
            m_AttrNames,
            FALSE,
            serverControls,
            NULL,
            NULL,
            0,
            &m_message);

      if ( result && result != LDAP_CONTROL_NOT_FOUND )
      {
         // LDAP_CONTROL_NOT_FOUND means that we have reached the end of the search results 
         // in Exchange 5.5, before SP 2 (the server doesn't return a page control when there 
         // are no more pages, so we get LDAP_CONTROL_NOT_FOUND when we try to extract the page 
         // control from the search results).
         
      }
   }
   if ( ! result )
   {
      m_nReturned = m_connection.ldap_count_entries(ld,m_message);
      m_nCurrent = 0;

   }
   return m_connection.LdapMapErrorToWin32(result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\getrids\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__D98E3D9A_C1A8_4907_9648_8B52BD7CFCA1__INCLUDED_)
#define AFX_DLLDATAX_H__D98E3D9A_C1A8_4907_9648_8B52BD7CFCA1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__D98E3D9A_C1A8_4907_9648_8B52BD7CFCA1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\getrids\exldap.h ===
#ifndef EXLDAP_H
#define EXLDAP_H

#include <winldap.h>

#include "EaLen.hpp"
#include "Common.hpp"
#include "UString.hpp"

typedef WINLDAPAPI LDAP * LDAPAPI LDAP_OPEN( PWCHAR HostName, ULONG PortNumber );
typedef WINLDAPAPI LDAP * LDAPAPI LDAP_INIT( PWCHAR HostName, ULONG PortNumber );
typedef WINLDAPAPI ULONG LDAPAPI LDAPMAPERRORTOWIN32( ULONG LdapError );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_UNBIND( LDAP *ld );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_BIND( LDAP *ld, PWCHAR dn, PWCHAR cred, ULONG method );
typedef WINLDAPAPI ULONG LDAPAPI LDAPGETLASTERROR( VOID );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_MODIFY_S( LDAP *ld, PWCHAR dn, LDAPModW *mods[] );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_MSGFREE( LDAPMessage *res );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_COUNT_ENTRIES( LDAP *ld, LDAPMessage *res );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_SEARCH_EXT_S(
        LDAP            *ld,
        PWCHAR          base,
        ULONG           scope,
        PWCHAR          filter,
        PWCHAR          attrs[],
        ULONG           attrsonly,
        PLDAPControlW   *ServerControls,
        PLDAPControlW   *ClientControls,
        struct l_timeval  *timeout,
        ULONG           SizeLimit,
        LDAPMessage     **res
    );
typedef WINLDAPAPI ULONG LDAPAPI LDAP_CREATE_PAGE_CONTROL(
        PLDAP           ExternalHandle,
        ULONG           PageSize,
        struct berval  *Cookie,
        UCHAR           IsCritical,
        PLDAPControlW  *Control
        );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_PARSE_PAGE_CONTROL (
        PLDAP           ExternalHandle,
        PLDAPControlW  *ServerControls,
        ULONG          *TotalCount,
        struct berval  **Cookie     // Use ber_bvfree to free
        );
typedef WINLDAPAPI PWCHAR *LDAPAPI LDAP_GET_VALUES(
        LDAP            *ld,
        LDAPMessage     *entry,
        PWCHAR          attr
        );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_VALUE_FREE( PWCHAR *vals );

typedef WINLDAPAPI LDAPMessage *LDAPAPI LDAP_NEXT_ENTRY( LDAP *ld, LDAPMessage *entry );

typedef WINLDAPAPI LDAPMessage *LDAPAPI LDAP_FIRST_ENTRY( LDAP *ld, LDAPMessage *res );

typedef WINLDAPAPI VOID LDAPAPI BER_BVFREE( struct berval *bv );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_CONTROLS_FREE (
        LDAPControlW **Control
        );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_PARSE_RESULT (
        LDAP *Connection,
        LDAPMessage *ResultMessage,
        ULONG *ReturnCode OPTIONAL,          // returned by server
        PWCHAR *MatchedDNs OPTIONAL,         // free with ldap_memfree
        PWCHAR *ErrorMessage OPTIONAL,       // free with ldap_memfree
        PWCHAR **Referrals OPTIONAL,         // free with ldap_value_freeW
        PLDAPControlW **ServerControls OPTIONAL,    // free with ldap_free_controlsW
        BOOLEAN Freeit
        );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_GET_OPTION( LDAP *ld, int option, void *outvalue );

typedef WINLDAPAPI ULONG LDAPAPI LDAP_SET_OPTION( LDAP *ld, int option, void *invalue );

class CLdapConnection
{
   WCHAR                     m_exchServer[LEN_Computer];
   LDAP                    * m_LD;
   ULONG                     m_port;
   HMODULE                   m_hDll;
   BOOL                      m_bUseSSL;
   WCHAR                     m_credentials[300];
   WCHAR                     m_password[100];
public:
   LDAP_PARSE_RESULT        * ldap_parse_result;
   LDAP_PARSE_PAGE_CONTROL  * ldap_parse_page_control;
   LDAP_CONTROLS_FREE       * ldap_controls_free;
   BER_BVFREE               * ber_bvfree;
   LDAP_FIRST_ENTRY         * ldap_first_entry;
   LDAP_NEXT_ENTRY          * ldap_next_entry;
   LDAP_VALUE_FREE          * ldap_value_free;
   LDAP_GET_VALUES          * ldap_get_values;
   LDAP_CREATE_PAGE_CONTROL * ldap_create_page_control;
   LDAP_SEARCH_EXT_S        * ldap_search_ext_s;
   LDAP_COUNT_ENTRIES       * ldap_count_entries;
   LDAP_MSGFREE             * ldap_msgfree;
   LDAP_MODIFY_S            * ldap_modify_s;
   LDAPGETLASTERROR         * LdapGetLastError;
   LDAP_BIND                * ldap_bind_sW;
   LDAP_UNBIND              * ldap_unbind;
   LDAPMAPERRORTOWIN32      * LdapMapErrorToWin32;
   LDAP_OPEN                * ldap_open;
   LDAP_INIT                * ldap_init;
   LDAP_GET_OPTION          * ldap_get_option;
   LDAP_SET_OPTION          * ldap_set_option;

public:
   CLdapConnection();
   ~CLdapConnection();

   void   SetCredentials(WCHAR const * cred,WCHAR const * pwd) { safecopy(m_credentials,cred); safecopy(m_password,pwd); }
   LDAP * GetHandle() { return m_LD; }
   DWORD  Connect(WCHAR const * server,ULONG port);
   DWORD UpdateSimpleStringValue(WCHAR const * dn, WCHAR const * property, WCHAR const * value);
   void   Close();

   BOOL StringToBytes(WCHAR const * pString,BYTE * pBytes);
   BOOL BytesToString(BYTE * pBytes,WCHAR * sidString,DWORD numBytes);
protected:
   // helper functions
   BYTE HexValue(WCHAR value);
   void AddByteToString(WCHAR ** string,BYTE value);
};


class CLdapEnum
{
   BOOL                      m_bOpen;
   ULONG                     m_nReturned;
   ULONG                     m_nCurrent;
   ULONG                     m_totalCount;
   LDAPMessage             * m_message;
   LDAPMessage             * m_currMsg;
   WCHAR                     m_query[1000];
   WCHAR                     m_basepoint[LEN_DistName];
   int                       m_scope;
   long                      m_pageSize;
   int                       m_nAttributes;
   WCHAR                  ** m_AttrNames;
public:
    CLdapConnection           m_connection;
public:
   CLdapEnum() { m_bOpen = FALSE; m_nReturned = 0; m_nCurrent = 0; m_totalCount = 0; m_message = NULL; 
                 m_query[0] = 0; m_basepoint[0] = 0; m_scope = 2; m_pageSize = 100; m_currMsg = NULL;
                 m_nAttributes = 0; m_AttrNames =NULL;}
   ~CLdapEnum();

   DWORD          InitConnection(WCHAR const * server,ULONG port) { return m_connection.Connect(server,port); }
   DWORD          Open(WCHAR const * query,WCHAR const * basePoint,short scope, long pageSize,int numAttributes,
                  WCHAR ** attrs);
   DWORD          Next(PWCHAR ** ppAttrs);
   void           FreeData(PWCHAR* pValues);
protected:

   DWORD          GetNextEntry(PWCHAR ** ppAttrs);
   DWORD          GetNextPage();

};


#endif // EXLDAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\getrids\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by GetRids.rc
//
#define IDS_PROJNAME                    100
#define IDS_RIDSAVE_DESC                101
#define IDR_RidSave                     102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\getrids\ridsave.h ===
// RidSave.h: Definition of the RidSave class
//
//////////////////////////////////////////////////////////////////////

#if !defined(AFX_RIDSAVE_H__D5DB8B95_5E8A_4DC8_8945_71A69574E426__INCLUDED_)
#define AFX_RIDSAVE_H__D5DB8B95_5E8A_4DC8_8945_71A69574E426__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#include "resource.h"       // main symbols
#include "ExtSeq.h"
/////////////////////////////////////////////////////////////////////////////
// RidSave

class RidSave : 
	public IDispatchImpl<IExtendAccountMigration, &IID_IExtendAccountMigration, &LIBID_GETRIDSLib>, 
	public ISupportErrorInfoImpl<&IID_IExtendAccountMigration>,
	public CComObjectRoot,
	public CComCoClass<RidSave,&CLSID_RidSave>
{
public:
	RidSave() 
   {
      m_sName = L"Get Rids";
      m_sDesc = L"Extension that gathers the RID for the source and target accounts.";
      m_Sequence = AREXT_DEFAULT_SEQUENCE_NUMBER;
   }
BEGIN_COM_MAP(RidSave)
	COM_INTERFACE_ENTRY(IDispatch)
	COM_INTERFACE_ENTRY(IExtendAccountMigration)
	COM_INTERFACE_ENTRY(ISupportErrorInfo)
END_COM_MAP()
//DECLARE_NOT_AGGREGATABLE(RidSave) 
// Remove the comment from the line above if you don't want your object to 
// support aggregation. 

DECLARE_REGISTRY_RESOURCEID(IDR_RidSave)

// IExtendAccountMigration
public:
   STDMETHOD(ProcessUndo)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in, out]*/ IUnknown ** pPropToSet);
	STDMETHOD(PreProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet);
	STDMETHOD(ProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet);
	STDMETHOD(get_sDesc)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sDesc)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_sName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sName)(/*[in]*/ BSTR newVal);
   STDMETHOD(get_SequenceNumber)(/*[out, retval]*/ LONG * value) { (*value) = m_Sequence; return S_OK; }
private:
	_bstr_t m_sDesc;
	_bstr_t m_sName;
   long    m_Sequence;
};

#endif // !defined(AFX_RIDSAVE_H__D5DB8B95_5E8A_4DC8_8945_71A69574E426__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\getrids\getrids.cpp ===
// GetRids.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for GetRids.idl by adding the following 
//      files to the Outputs.
//          GetRids_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f GetRidsps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "GetRids.h"
#include "dlldatax.h"

#include "GetRids_i.c"
#include "RidSave.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_RidSave, RidSave)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
		ATLTRACE(_T("{GetRids.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_ATTACH,...)\n"), hInstance);
        _Module.Init(ObjectMap, hInstance, &LIBID_GETRIDSLib);
        DisableThreadLibraryCalls(hInstance);
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
	{
		ATLTRACE(_T("{GetRids.dll}DllMain(hInstance=0x%08lX, dwReason=DLL_PROCESS_DETACH,...)\n"), hInstance);
        _Module.Term();
	}
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\getrids\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__C3044D3E_E79E_4D42_B8AD_A09CF9B605F1__INCLUDED_)
#define AFX_STDAFX_H__C3044D3E_E79E_4D42_B8AD_A09CF9B605F1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C3044D3E_E79E_4D42_B8AD_A09CF9B605F1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\getrids\ridsave.cpp ===
// RidSave.cpp : Implementation of CGetRidsApp and DLL registration.

#include "stdafx.h"
#include "GetRids.h"
#include "RidSave.h"
#include "ARExt.h"
#include "ARExt_i.c"
#include <iads.h>
#include <AdsHlp.h>
#include "resstr.h"
#include "exldap.h"
#include "TxtSid.h"

//#import "\bin\McsVarSetMin.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")


/////////////////////////////////////////////////////////////////////////////
// RidSave
StringLoader   gString;
//---------------------------------------------------------------------------
// Get and set methods for the properties.
//---------------------------------------------------------------------------
STDMETHODIMP RidSave::get_sName(BSTR *pVal)
{
   *pVal = m_sName;
	return S_OK;
}

STDMETHODIMP RidSave::put_sName(BSTR newVal)
{
   m_sName = newVal;
	return S_OK;
}

STDMETHODIMP RidSave::get_sDesc(BSTR *pVal)
{
   *pVal = m_sDesc;
	return S_OK;
}

STDMETHODIMP RidSave::put_sDesc(BSTR newVal)
{
   m_sDesc = newVal;
	return S_OK;
}



void VariantSidToString(_variant_t & varSid)
{
   if ( varSid.vt == VT_BSTR )
   {
      return;
   }
   else if ( varSid.vt == ( VT_ARRAY | VT_UI1) )
   {
      // convert the array of bits to a string
      CLdapConnection   c;
      LPBYTE            pByte = NULL;
      WCHAR             str[LEN_Path];

      SafeArrayAccessData(varSid.parray,(void**)&pByte);
      c.BytesToString(pByte,str,GetLengthSid(pByte));
      SafeArrayUnaccessData(varSid.parray);
      
      varSid = str;

   }
   else
   {
      varSid.ChangeType(VT_BSTR);
   }
}

//---------------------------------------------------------------------------
// ProcessObject : This method doesn't do anything.
//---------------------------------------------------------------------------
STDMETHODIMP RidSave::PreProcessObject(
                                       IUnknown *pSource,         //in- Pointer to the source AD object
                                       IUnknown *pTarget,         //in- Pointer to the target AD object
                                       IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                       IUnknown **ppPropsToSet    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                  //         once all extension objects are executed.
                                    )
{
   IVarSetPtr                pVs = pMainSettings;
   _variant_t                var;
   _bstr_t                   sTemp;
   IADs                    * pAds = NULL;
   HRESULT                   hr = S_OK;
   DWORD                     rid = 0; // default to 0, if RID not found   
   // We need to process users and groups only
   sTemp = pVs->get(GET_BSTR(DCTVS_CopiedAccount_Type));
   if (!sTemp.length())
	   return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
   if ( _wcsicmp((WCHAR*)sTemp,L"user") && _wcsicmp((WCHAR*)sTemp,L"group") ) 
      return S_OK;
   
   if ( pSource )
   {
      //Get the IADs pointer to manipulate properties
      hr = pSource->QueryInterface(IID_IADs, (void**) &pAds);
      
      if ( SUCCEEDED(hr) )
      {
         hr = pAds->Get(SysAllocString(L"objectSID"),&var);
         if ( SUCCEEDED(hr) )
         {
            // got the SID -- convert it to the proper format
            VariantSidToString(var);
            CLdapConnection      e;
            BYTE                 sid[300];

            
            if ( e.StringToBytes(var.bstrVal,sid) )
            {
               // Get the rid
               UCHAR         len = (* GetSidSubAuthorityCount(sid));
               PDWORD        pRid = GetSidSubAuthority(sid,len-1);
               
               rid = (*pRid);
            }
         }
         pAds->Release();
      }
   }
   // save the RID
   pVs->put(GET_BSTR(DCTVS_CopiedAccount_SourceRID),(long)rid);
   return hr;
}

//---------------------------------------------------------------------------
// ProcessObject : This method updates the UPN property of the object. It 
//                 first sees if a E-Mail is specified then it will set UPN
//                 to that otherwise it builds it from SAMAccountName and the
//                 Domain name
//---------------------------------------------------------------------------
STDMETHODIMP RidSave::ProcessObject(
                                       IUnknown *pSource,         //in- Pointer to the source AD object
                                       IUnknown *pTarget,         //in- Pointer to the target AD object
                                       IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                       IUnknown **ppPropsToSet    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                  //         once all extension objects are executed.
                                    )
{
   IVarSetPtr                pVs = pMainSettings;
   _variant_t                var;
   _bstr_t                   sTemp;
   IADs                    * pAds = NULL;
   HRESULT                   hr = S_OK;
   DWORD                     rid = 0; // default to 0, if RID not found   
   // We need to process users and groups only
   sTemp = pVs->get(GET_BSTR(DCTVS_CopiedAccount_Type));
   if ( _wcsicmp((WCHAR*)sTemp,L"user") && _wcsicmp((WCHAR*)sTemp,L"group") ) 
   {
      return S_OK;
   }
   
   if ( pTarget )
   {
      //Get the IADs pointer to manipulate properties
      hr = pTarget->QueryInterface(IID_IADs, (void**) &pAds);
      
      if ( SUCCEEDED(hr) )
      {
         hr = pAds->Get(SysAllocString(L"objectSID"),&var);
         if ( SUCCEEDED(hr) )
         {
            // got the SID -- convert it to the proper format
            CLdapConnection      e;
            BYTE                 sid[300];
            VariantSidToString(var);
            
            if ( e.StringToBytes(var.bstrVal,sid) )
            {
               // Get the rid
               UCHAR         len = (* GetSidSubAuthorityCount(sid));
               PDWORD        pRid = GetSidSubAuthority(sid,len-1);
               
               rid = (*pRid);
            }
         }
         pAds->Release();
      }
   }
   // save the RID
   pVs->put(GET_BSTR(DCTVS_CopiedAccount_TargetRID),(long)rid);
   return hr;

}

//---------------------------------------------------------------------------
// ProcessUndo : We are not going to undo this.
//---------------------------------------------------------------------------
STDMETHODIMP RidSave::ProcessUndo(                                             
                                       IUnknown *pSource,         //in- Pointer to the source AD object
                                       IUnknown *pTarget,         //in- Pointer to the target AD object
                                       IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                       IUnknown **ppPropsToSet    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                  //         once all extension objects are executed.
                                    )
{
   return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\scmmigr\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "ScmMigr_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\scmmigr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\scmmigr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ScmMigr.rc
//
#define IDS_PROJNAME                    100
#define IDR_SERVMIGR                    101
#define IDS_SVCMGR_DESC                 102
#define IDR_SvcMgr                      103

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           104
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\scmmigr\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__8FCC6D19_4A12_11D3_99F9_0010A4F77383__INCLUDED_)
#define AFX_DLLDATAX_H__8FCC6D19_4A12_11D3_99F9_0010A4F77383__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__8FCC6D19_4A12_11D3_99F9_0010A4F77383__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\scmmigr\scmmigr.cpp ===
// ScmMigr.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for ScmMigr.idl by adding the following 
//      files to the Outputs.
//          ScmMigr_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f ScmMigrps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "ScmMigr.h"
#include "dlldatax.h"

#include "ScmMigr_i.c"
#include "ServMigr.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ServMigr, CServMigr)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_SCMMIGRLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\scmmigr\servmigr.cpp ===
// ServMigr.cpp : Implementation of CServMigr
#include "stdafx.h"
#include "ScmMigr.h"
#include "ServMigr.h"
#include "ErrDct.hpp"
#include "ResStr.h"
#include "Common.hpp"
#include "PWGen.hpp"
#include "EaLen.hpp"
#include "TReg.hpp"
#include "TxtSid.h"
#include "ARExt_i.c"

#include <lm.h>
#include <dsgetdc.h>

//#import "\bin\McsVarSetMin.tlb" no_namespace, named_guids
//#import "\bin\DBManager.tlb" no_namespace, named_guids
//#import "\bin\McsDctWorkerObjects.tlb" no_namespace, named_guids

#import "VarSet.tlb" no_namespace, named_guids rename("property", "aproperty")
//#import "DBMgr.tlb" no_namespace, named_guids //already #imported in ServMigr.h
#import "WorkObj.tlb" no_namespace, named_guids

TErrorDct         err;
StringLoader      gString;

#define BLOCK_SIZE 160
#define BUFFER_SIZE 400

#define SvcAcctStatus_NotMigratedYet			0
#define SvcAcctStatus_DoNotUpdate			   1
#define SvcAcctStatus_Updated				      2
#define SvcAcctStatus_UpdateFailed			   4
#define SvcAcctStatus_NeverAllowUpdate       8
   
/////////////////////////////////////////////////////////////////////////////
// CServMigr

STDMETHODIMP CServMigr::ProcessUndo(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in, out]*/ IUnknown ** pPropToSet)
{
   return E_NOTIMPL;
}

STDMETHODIMP CServMigr::PreProcessObject(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in, out]*/ IUnknown ** pPropToSet)
{
   return S_OK;
}

STDMETHODIMP 
   CServMigr::ProcessObject(
      /*[in]*/ IUnknown     * pSource, 
      /*[in]*/ IUnknown     * pTarget, 
      /*[in]*/ IUnknown     * pMainSettings, 
      /*[in,out]*/IUnknown ** ppPropsToSet
   )
{
   HRESULT                    hr = S_OK;
//   BOOL                       bFailedToUpdateOne = FALSE;
   WCHAR                      domAccount[500];
   WCHAR                      domTgtAccount[500];
   _bstr_t                    domain;
   _bstr_t                    account;
   IVarSetPtr                 pVarSet(pMainSettings);
   IIManageDBPtr              pDB;
   _bstr_t                    logfile;
   _bstr_t                    srcComputer;
   _bstr_t                    tgtComputer;
   _bstr_t                    tgtAccount;
   _bstr_t                    tgtDomain;
   IVarSetPtr                 pData(CLSID_VarSet);
   IUnknown                 * pUnk = NULL;
   DWORD                      rc = 0;
   _bstr_t                    sIntraForest;
   BOOL                       bIntraForest = FALSE;
   WCHAR                    * lastOperation = NULL;

   try { 
      logfile = pVarSet->get(GET_BSTR(DCTVS_Options_Logfile));
      lastOperation = L"Get Log file name";
      if ( logfile.length() )
      {
         err.LogOpen(logfile,1);
         lastOperation = L"Open log";
         
      }
         
      pDB = pVarSet->get(GET_BSTR(DCTVS_DBManager));
      lastOperation = L"Got DBManager pointer";
      if ( pDB != NULL )
      {
         lastOperation = L"DBManager is not null";
         // Check to see if this account is referenced in the service accounts table
         domain = pVarSet->get(GET_BSTR(DCTVS_Options_SourceDomain));
         tgtDomain = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));
         account = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
         tgtAccount = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
         srcComputer = pVarSet->get(GET_BSTR(DCTVS_Options_SourceServer));
         tgtComputer = pVarSet->get(GET_BSTR(DCTVS_Options_TargetServer));
         sIntraForest = pVarSet->get(GET_BSTR(DCTVS_Options_IsIntraforest));
         lastOperation = L"got names from varset";
         if ( ! UStrICmp((WCHAR*)sIntraForest,GET_STRING(IDS_YES)) )
         {
            // for intra-forest migration we are moving, not copying, so we don't need to update the password
            lastOperation = L"checking whether this migration is intraforest";
            // Actually, it turns out that ChangeServiceConfig will not let us update just the service account
            // and not the passord, so we'll have to go ahead and change the password for the service ac
            //bIntraForest = TRUE;
         }
		    //if the SAM account name has a " character in it, it cannot be a service
		    //account, and therefore we leave
		 if (wcschr(account, L'\"'))
			 return S_OK;

         lastOperation = L"preparing to build domain\\username strings";
         swprintf(domAccount,L"%s\\%s",(WCHAR*)domain,(WCHAR*)account);
         swprintf(domTgtAccount,L"%s\\%s",(WCHAR*)tgtDomain,(WCHAR*)tgtAccount);
         lastOperation = L"done building domain\\username strings";
      }
      }catch (... )
      {
         err.DbgMsgWrite(ErrE,L"Exception!...LastOperation=%ls",lastOperation);
      }
         
      try { 
         hr = pData->QueryInterface(IID_IUnknown,(void**)&pUnk);
         lastOperation = L"Got IUnknown pointer to varset";
         if ( SUCCEEDED(hr) )
         {
            lastOperation = L"Checking database for this account";
            hr = pDB->raw_GetServiceAccount(SysAllocString(domAccount),&pUnk);
            lastOperation = L"Got service account info";
            
         }
      }
      catch ( ... )
      {
         err.DbgMsgWrite(ErrE,L"Exception!...lastOperation=%ls",lastOperation);
      }
      try {
         if ( SUCCEEDED(hr) )
         {
            lastOperation = L"preparing to check service account info";
            pData = pUnk;
            lastOperation = L"freeing old pointer";
            pUnk->Release();
            lastOperation = L"freed old pointer";
         // remove the password must change flag, if set
            USER_INFO_2           * uInfo = NULL;
            DWORD                   parmErr = 0;
            WCHAR                   password[LEN_Password];
            long                    entries = pData->get("ServiceAccountEntries");
            
            lastOperation = L"got entry count";
         
            if ( (entries != 0) && !bIntraForest ) // if we're moving the account, don't mess with its properties
            {
               lastOperation = L"getting target user info";
               rc = NetUserGetInfo(tgtComputer,tgtAccount,2,(LPBYTE*)&uInfo);
               lastOperation = L"got target user info";
               if ( ! rc )
               {
                  // generate a new, strong, 14 character password for this account, 
                  // and set the password to not expire
                  lastOperation = L"generating password";
                  EaPasswordGenerate(3,3,3,3,6,14,password,DIM(password));
                  lastOperation = L"generated password";
                  uInfo->usri2_flags |= (UF_DONT_EXPIRE_PASSWD);
                  lastOperation = L"updating flags";
                  uInfo->usri2_password = password;
                  lastOperation = L"setting user info";
                  rc = NetUserSetInfo(tgtComputer,tgtAccount,2,(LPBYTE)uInfo,&parmErr);
                  lastOperation = L"set user info";
                  if ( ! rc )
                  {
                     lastOperation = L"writing log messages";
                     err.MsgWrite(0,DCT_MSG_REMOVED_PWDCHANGE_FLAG_S,(WCHAR*)tgtAccount);
                     lastOperation = L"writing log messages2";
                     err.MsgWrite(0,DCT_MSG_PWGENERATED_S,(WCHAR*)tgtAccount);
                     lastOperation = L"wrote log messages";
                     // write the password to the password log file and mark this account, so that the 
                     // SetPassword extension will not reset the password again.
                     pVarSet->put(GET_BSTR(DCTVS_CopiedAccount_DoNotUpdatePassword),account);
                     lastOperation = L"put flag into varset";
                     _bstr_t sFileName = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_PasswordFile));
                     lastOperation = L"got name for password file";
				     if ( !m_bTriedToOpenFile )
                     {
              	         lastOperation = L"trying to open password file";
                        m_bTriedToOpenFile = true;
                        lastOperation = L"set password file flag";
                        // we should see if the varset specifies a file name
                        if ( sFileName.length() > 0 )
                        {
         					   lastOperation = L"password file has a name";
                        // we have the file name so lets open it and save the handle.
                           m_passwordLog.LogOpen(sFileName, TRUE, 1);
                           lastOperation = L"opened password file";
			            }
							//failure to get to password file so store it elsewhere and
							//post that new file location in the migration log
						if (!m_passwordLog.IsOpen() )
						{ 
							WCHAR sPasswordFile[MAX_PATH];
							if (GetDirectory(sPasswordFile))//place log in default log dir
								wcscat(sPasswordFile, L"Logs\\passwords.txt");
							else
								wcscpy(sPasswordFile, L"c:\\passwords.txt");
				
							m_passwordLog.LogOpen(sPasswordFile, TRUE, 1);//open this log file
							if ( m_passwordLog.IsOpen() )
								err.MsgWrite(0,DCT_MSG_NEW_PASSWORD_LOG_S,(WCHAR*)sFileName,sPasswordFile);
						}
                     }
			            lastOperation = L"done with pwd file opening";
                     // Log the new password in the password log.
                     if ( m_passwordLog.IsOpen() )
                     {
                        lastOperation = L"preparing to write to password file";
					         m_passwordLog.MsgWrite(L"%ls,%ls",(WCHAR*)tgtAccount,password);
					         lastOperation = L"wrote to password file";
                     }
                  }
                  lastOperation = L"done with user set info";
                  uInfo->usri2_password = NULL;
			         lastOperation = L"cleared password property";
                  NetApiBufferFree(uInfo);
                  lastOperation = L"freed buffer";
			      }
                  
               lastOperation = L"done with get user info";
               
               if ( rc )
               {
                  lastOperation = L"writing error message";
                  err.SysMsgWrite(ErrE,rc,DCT_MSG_REMOVED_PWDCHANGE_FLAG_FAILED_SD,(WCHAR*)tgtAccount,rc);
                  lastOperation = L"done writing error message";
               }
            }
            if (entries != 0 )
            {
               lastOperation = L"There are some entries";
               try { 
               if ( ! rc )
               {
                  lastOperation = L"no errors";
                  WCHAR             strSID[200] = L"";
                  BYTE              sid[200];
                  WCHAR             domain[LEN_Domain];
                  SID_NAME_USE      snu;
                  DWORD             lenSid = DIM(sid);
                  DWORD             lenDomain = DIM(domain);
                  DWORD             lenStrSid = DIM(strSID);

                  lastOperation = L"Looking up account name";
				      if ( LookupAccountName(tgtComputer,tgtAccount,sid,&lenSid,domain,&lenDomain,&snu) )
                  {
                     lastOperation = L"getting txt for sid";
                     if ( GetTextualSid(sid,strSID,&lenStrSid) )
                     {
                           lastOperation = L"got txt for sid";
                        // for each reference to the service account, update the SCM
                        // for intra-forest migration, don't update the password
                        if ( bIntraForest )
                           UpdateSCMs(pData,domTgtAccount,NULL,strSID,pDB); 
                        else
                           UpdateSCMs(pData,domTgtAccount,password,strSID,pDB);
                        lastOperation = L"did scm updates";
                     }
                     else
                     {
                        lastOperation = L"didn't get text for sid";
                        err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_CANNOT_FIND_ACCOUNT_SSD,tgtAccount,tgtComputer,GetLastError());
                     }
                  }
                  else
                  {
                     lastOperation = L"didn't find account name";
                     err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_CANNOT_FIND_ACCOUNT_SSD,tgtAccount,tgtComputer,GetLastError());
                     lastOperation = L"wrote LookupAccountName error message";
                  }
               }
               }
               catch(...)
               {
                  err.DbgMsgWrite(ErrE,L"Exception!, last=%ls",lastOperation);
               }
                  lastOperation = L"123";
            }
            lastOperation = L"444444";
         
         lastOperation = L"656346";
      }
      else
      {
         lastOperation = L"234234242";
         err.SysMsgWrite(ErrE,E_FAIL,DCT_MSG_DB_OBJECT_CREATE_FAILED_D,E_FAIL);
         lastOperation = L"asdfsadf";
      }
      lastOperation = L"ddddd";
      err.LogClose();
   }
   catch (... )
   {
      err.DbgMsgWrite(ErrE,L"An exception occurred.  LastOperation=%ls",lastOperation);
   }
   return S_OK;
}

STDMETHODIMP CServMigr::get_sDesc(/*[out, retval]*/ BSTR *pVal)
{
   (*pVal) = SysAllocString(L"Updates SCM entries for services using migrated accounts.");
   return S_OK;
}

STDMETHODIMP CServMigr::put_sDesc(/*[in]*/ BSTR newVal)
{
   return E_NOTIMPL;
}

STDMETHODIMP CServMigr::get_sName(/*[out, retval]*/ BSTR *pVal)
{
   (*pVal) = SysAllocString(L"Generic Service Account Migration");
   return S_OK;
}

STDMETHODIMP CServMigr::put_sName(/*[in]*/ BSTR newVal)
{
   return E_NOTIMPL;
}

DWORD 
   CServMigr::DoUpdate(
      WCHAR const          * account,
      WCHAR const          * password,
      WCHAR const          * strSid,
      WCHAR const          * computer,
      WCHAR const          * service,
      BOOL                   bNeedToGrantLOS
   )
{
   DWORD                     rc = 0;
   IUserRightsPtr            pRights;
   WCHAR   const           * ppassword = password;

 
   // if password is empty, set it to NULL
   if ( ppassword && ppassword[0] == 0 )  
   {
      ppassword = NULL;
   }
   else if ( !UStrCmp(password,L"NULL") )
   {
      ppassword = NULL;
   }
// only try to update entries that we need to be updating
         // try to connect to the SCM on this machine
   rc = pRights.CreateInstance(CLSID_UserRights);
   if ( FAILED(rc) )
   {
      pRights = NULL;
   }
   SC_HANDLE          pScm = OpenSCManager(computer, NULL, SC_MANAGER_ALL_ACCESS );
   if ( pScm )
   {
      // grant the logon as a service right to the target account
      if ( pRights != NULL )
      {
         if ( bNeedToGrantLOS )
         {
            rc = pRights->raw_AddUserRight(SysAllocString(computer),SysAllocString(strSid),SysAllocString(L"SeServiceLogonRight"));   
            if ( rc )
            {
               err.SysMsgWrite(ErrE,rc,DCT_MSG_LOS_GRANT_FAILED_SSD,
                  account,(WCHAR*)computer,rc);
            }
            else
            {
               err.MsgWrite(0,DCT_MSG_LOS_GRANTED_SS,
                  account,(WCHAR*)computer);
            }
         }
      }

      SC_HANDLE         pService = OpenService(pScm,service,SERVICE_ALL_ACCESS);

      if ( pService )
      {
         int nCnt = 0;
         // update the account and password for the service
         while ( !ChangeServiceConfig(pService,
                           SERVICE_NO_CHANGE, // dwServiceType
                           SERVICE_NO_CHANGE, // dwStartType
                           SERVICE_NO_CHANGE, // dwErrorControl
                           NULL,              // lpBinaryPathName
                           NULL,              // lpLoadOrderGroup
                           NULL,              // lpdwTagId
                           NULL,              // lpDependencies
                           account, // lpServiceStartName
                           ppassword,   // lpPassword
                           NULL) && nCnt < 5)       // lpDisplayName
         {
            nCnt++;
            Sleep(500);
         }
         if ( nCnt < 5 )
         {
            err.MsgWrite(0,DCT_MSG_UPDATED_SCM_ENTRY_SS,(WCHAR*)computer,(WCHAR*)service);
         }
         else
         {
            rc = GetLastError();
         }
         CloseServiceHandle(pService);
      }
      CloseServiceHandle(pScm);
   }
   else
   {
      rc = GetLastError();
   }
   return rc;
}

BOOL 
   CServMigr::UpdateSCMs(
      IUnknown             * pVS,
      WCHAR const          * account, 
      WCHAR const          * password, 
      WCHAR const          * strSid,
      IIManageDB           * pDB
   )
{
   BOOL                      bGotThemAll = TRUE;
   IVarSetPtr                pVarSet = pVS;
   LONG                      nCount = 0;
   WCHAR                     key[LEN_Path];            
   _bstr_t                   computer;
   _bstr_t                   service;
   long                      status;
   DWORD                     rc = 0;
   BOOL                      bFirst = TRUE;
   WCHAR                     prevComputer[LEN_Path] = L"";
   try  {
      nCount = pVarSet->get("ServiceAccountEntries");
      
      for ( long i = 0 ; i < nCount ; i++ )
      {
         
         swprintf(key,L"Computer.%ld",i);
         computer = pVarSet->get(key);
         swprintf(key,L"Service.%ld",i);
         service = pVarSet->get(key);
         swprintf(key,L"ServiceAccountStatus.%ld",i);
         status = pVarSet->get(key);
         
         if ( status == SvcAcctStatus_NotMigratedYet || status == SvcAcctStatus_UpdateFailed )
         {
            if ( UStrICmp(prevComputer,(WCHAR*)computer) )
            {
               bFirst = TRUE; // reset the 'first' flag when the computer changes
            }
            try {
               rc = DoUpdate(account,password,strSid,computer,service,bFirst/*only grant SeServiceLogonRight once per account*/);
               bFirst = FALSE;
               safecopy(prevComputer,(WCHAR*)computer);
            }
            catch (...)
            {
               err.DbgMsgWrite(ErrE,L"Exception!");
               err.DbgMsgWrite(0,L"Updating %ls on %ls",(WCHAR*)service,(WCHAR*)computer);
               err.DbgMsgWrite(0,L"Account=%ls, SID=%ls",(WCHAR*)account,(WCHAR*)strSid);
               rc = E_FAIL;
            }
            if (! rc )
            {
               // the update was successful
               pDB->raw_SetServiceAcctEntryStatus(computer,service,SysAllocString(account),SvcAcctStatus_Updated); 
            }
            else
            {
               // couldn't connect to this one -- we will need to save this account's password
               // in our encrypted storage
               pDB->raw_SetServiceAcctEntryStatus(computer,service,SysAllocString(account),SvcAcctStatus_UpdateFailed);
               bGotThemAll = FALSE;
               SaveEncryptedPassword(computer,service,account,password);
               err.SysMsgWrite(ErrE,rc,DCT_MSG_UPDATE_SCM_ENTRY_FAILED_SSD,(WCHAR*)computer,(WCHAR*)service,rc);
            }
         }
      }
   }
   catch ( ... )
   {
      err.DbgMsgWrite(ErrE,L"Exception!");
   }
   return bGotThemAll;
}

HRESULT 
   CServMigr::SaveEncryptedPassword(
      WCHAR          const * server,
      WCHAR          const * service,
      WCHAR          const * account,
      WCHAR          const * password
   )
{
	HRESULT hr = S_OK;
	TNodeListEnum e;
	TEntryNode* pNode;

	// if entry exists...

	for (pNode = (TEntryNode*)e.OpenFirst(&m_List); pNode; pNode = (TEntryNode*)e.Next())
	{
		if (_wcsicmp(pNode->GetComputer(), server) == 0)
		{
			if (_wcsicmp(pNode->GetService(), service) == 0)
			{
				if (_wcsicmp(pNode->GetAccount(), account) == 0)
				{
					// update password
					pNode->SetPassword(password);
					break;
				}
			}
		}
	}

	// else...

	if (pNode == NULL)
	{
		// insert new entry

		pNode = new TEntryNode(server, service, account, password);

		if (pNode)
		{
			m_List.InsertBottom(pNode);
		}
		else
		{
			hr = E_OUTOFMEMORY;
		}
	}

	return hr;
}


//////////////////////////////////////////////////////////////////////////////////////
///
/// TEntryList implementation of secure storage for service account passwords 
///
///
//////////////////////////////////////////////////////////////////////////////////////

DWORD 
   TEntryList::LoadFromFile(WCHAR const * filename)
{
   DWORD                     rc = 0;
   
   FILE                    * hSource = NULL;
   
   HCRYPTPROV                hProv = 0;
   HCRYPTKEY                 hKey = 0;

   BYTE                      pbBuffer[BLOCK_SIZE];
   WCHAR                     strData[BLOCK_SIZE * 5] = { 0 };
   DWORD                     dwCount;
   int                       eof = 0;
   WCHAR                     fullpath[LEN_Path];

   BYTE *pbKeyBlob = NULL;
   DWORD dwBlobLen;

   // Get our install directory from the registry, and then append the filename
   HKEY           hRegKey;
   DWORD          type;
   DWORD          lenValue = (sizeof fullpath);

   rc = RegOpenKey(HKEY_LOCAL_MACHINE,L"Software\\Mission Critical Software\\DomainAdmin",&hRegKey);
   if ( ! rc )
   {
      
      rc = RegQueryValueEx(hRegKey,L"Directory",0,&type,(LPBYTE)fullpath,&lenValue);
      if (! rc )
      {
         UStrCpy(fullpath+UStrLen(fullpath),filename);
      }
      RegCloseKey(hRegKey);
   }
   
   // Open the source file.
   if((hSource = _wfopen(fullpath,L"rb"))==NULL) 
   {
       rc = GetLastError();
       goto done;
   }

   // acquire handle to key container which must exist
   if ((hProv = AcquireContext(true)) == 0)
   {
       rc = GetLastError();
       goto done;
   }

   // Read the key blob length from the source file and allocate it to memory.
   fread(&dwBlobLen, sizeof(DWORD), 1, hSource);
   if(ferror(hSource) || feof(hSource)) 
   {
       rc = GetLastError();
       goto done;
   }

   if((pbKeyBlob = (BYTE*)malloc(dwBlobLen)) == NULL) 
   {
       rc = GetLastError();
       goto done;
   }

   // Read the key blob from the source file.
   fread(pbKeyBlob, 1, dwBlobLen, hSource);
   if(ferror(hSource) || feof(hSource)) 
   {
       rc = GetLastError();
       goto done;
   }

   // Import the key blob into the CSP.
   if(!CryptImportKey(hProv, pbKeyBlob, dwBlobLen, 0, 0, &hKey)) 
   {
       rc = GetLastError();
       goto done;
   }
   
   // Decrypt the source file and load the list
   do {
       // Read up to BLOCK_SIZE bytes from source file.
       dwCount = fread(pbBuffer, 1, BLOCK_SIZE, hSource);
       if(ferror(hSource)) 
       {
           rc = GetLastError();
           goto done;
       }
       eof=feof(hSource);

       // Decrypt the data.
       if(!CryptDecrypt(hKey, 0, eof, 0, pbBuffer, &dwCount)) 
       {
           rc = GetLastError();
           goto done;
       }
       // Read any complete entries from the buffer
       // first, add the buffer contents to any leftover information we had read from before
       WCHAR               * curr = strData;
       long                  len = UStrLen(strData);
       WCHAR               * nl = NULL;
       WCHAR                 computer[LEN_Computer];
       WCHAR                 service[LEN_Service];
       WCHAR                 account[LEN_Account];
       WCHAR                 password[LEN_Password];

       wcsncpy(strData + len,(WCHAR*)pbBuffer, dwCount / sizeof(WCHAR));
       strData[len + (dwCount / sizeof(WCHAR))] = 0;
          do {
       
         nl = wcschr(curr,L'\n');
         if ( nl )
         {
            *nl = 0;
            if ( swscanf(curr,L" %[^\t]\t%[^\t]\t%[^\t]\t%[^\t]\n",computer,service,account,password) )
            {
               TEntryNode     * pNode = new TEntryNode(computer,service,account,password);
               InsertBottom(pNode);
            }
            else 
            {
               rc = E_FAIL;
               break;
            }
            // go on to the next entry
            curr = nl + 1;
         }
         
       } while ( nl );
       // there may be a partial record left in the buffer
       // if so, save it for the next read
       if ( (*curr) != 0 )
       {
          memmove(strData,curr,( 1 + UStrLen(curr) ) * (sizeof WCHAR));
       }


   } while(!feof(hSource));

  
   done:

   // Clean up
   if(pbKeyBlob) 
      free(pbKeyBlob);

   
   if(hKey != 0) 
      CryptDestroyKey(hKey);

   
   if(hProv != 0) 
      CryptReleaseContext(hProv, 0);

   
   if(hSource != NULL) 
      fclose(hSource);

   return rc;
}

DWORD 
   TEntryList::SaveToFile(WCHAR const * filename)
{
   DWORD                     rc = 0;
   BYTE                      pbBuffer[BUFFER_SIZE];
   DWORD                     dwCount;
   FILE                    * hDest;
   BYTE                    * pbKeyBlob = NULL;
   DWORD                     dwBlobLen;
   HCRYPTPROV                hProv = 0;
   HCRYPTKEY                 hKey = 0;
   HCRYPTKEY                 hXchgKey = 0;
   TEntryNode              * pNode;
   TNodeListEnum             e;
   WCHAR                     fullpath[LEN_Path];
   DWORD                     dwBlockSize;
   DWORD                     cbBlockSize = sizeof(dwBlockSize);
   DWORD                     dwPaddedCount;

   // Open the destination file.
   HKEY           hRegKey;
   DWORD          type;
   DWORD          lenValue = (sizeof fullpath);

   rc = RegOpenKey(HKEY_LOCAL_MACHINE,L"Software\\Mission Critical Software\\DomainAdmin",&hRegKey);
   if ( ! rc )
   {
      
      rc = RegQueryValueEx(hRegKey,L"Directory",0,&type,(LPBYTE)fullpath,&lenValue);
      if (! rc )
      {
         UStrCpy(fullpath+UStrLen(fullpath),filename);
      }
      RegCloseKey(hRegKey);
   }
   if( (hDest = _wfopen(fullpath,L"wb")) == NULL)
   {
      rc = GetLastError();
      goto done;
   }

   // acquire handle to key container
   if ((hProv = AcquireContext(false)) == 0)
   {
      rc = GetLastError();
      goto done;
   }

   // Attempt to get handle to exchange key.
   if(!CryptGetUserKey(hProv,AT_KEYEXCHANGE,&hKey)) 
   {
      if(GetLastError()==NTE_NO_KEY) 
      {
         // Create key exchange key pair.
         if(!CryptGenKey(hProv,AT_KEYEXCHANGE,0,&hKey)) 
         {
             rc = GetLastError();
            goto done;
         } 
      } 
      else 
      {
         rc = GetLastError();
         goto done;
      }
   }
   CryptDestroyKey(hKey);
   CryptReleaseContext(hProv,0);

   // acquire handle to key container
   if ((hProv = AcquireContext(false)) == 0)
   {
      rc = GetLastError();
      goto done;
   }

   // Get a handle to key exchange key.
   if(!CryptGetUserKey(hProv, AT_KEYEXCHANGE, &hXchgKey)) 
   {
       rc = GetLastError();
       goto done;
   }

   // Create a random block cipher session key.
   if(!CryptGenKey(hProv, CALG_RC2, CRYPT_EXPORTABLE, &hKey)) 
   {
       rc = GetLastError();
       goto done;
   }

   // Determine the size of the key blob and allocate memory.
   if(!CryptExportKey(hKey, hXchgKey, SIMPLEBLOB, 0, NULL, &dwBlobLen)) 
   {
       rc = GetLastError();
       goto done;
   }

   if((pbKeyBlob = (BYTE*)malloc(dwBlobLen)) == NULL) 
   {
       rc = ERROR_NOT_ENOUGH_MEMORY;
       goto done;
   }

   // Export the key into a simple key blob.
   if(!CryptExportKey(hKey, hXchgKey, SIMPLEBLOB, 0, pbKeyBlob, 
           &dwBlobLen)) 
   {
       rc = GetLastError();
       free(pbKeyBlob);
       goto done;
   }

   // Write the size of the key blob to the destination file.
   fwrite(&dwBlobLen, sizeof(DWORD), 1, hDest);

   if(ferror(hDest)) 
   {
       rc = GetLastError();
       free(pbKeyBlob);
       goto done;
   }

   // Write the key blob to the destination file.
   fwrite(pbKeyBlob, 1, dwBlobLen, hDest);
   if(ferror(hDest)) 
   {
       rc = GetLastError();
       free(pbKeyBlob);
       goto done;
   }

   // Free memory.
   free(pbKeyBlob);

   // get key cipher's block length in bytes

   if (CryptGetKeyParam(hKey, KP_BLOCKLEN, (BYTE*)&dwBlockSize, &cbBlockSize, 0))
   {
      dwBlockSize /= 8;
   }
   else
   {
      rc = GetLastError();
      goto done;
   }

   // Encrypt the item list and write it to the destination file.
   
   for ( pNode = (TEntryNode*)e.OpenFirst(this); pNode ; pNode = (TEntryNode *)e.Next()  )
   {
      // copy an item into the buffer in the following format:
      // Computer\tService\tAccount\tPassword
      if ( pNode->GetPassword() && *pNode->GetPassword() )
      {
         swprintf((WCHAR*)pbBuffer,L"%s\t%s\t%s\t%s\n",pNode->GetComputer(),pNode->GetService(),pNode->GetAccount(),pNode->GetPassword());
      }
      else
      {
         swprintf((WCHAR*)pbBuffer,L"%s\t%s\t%s\t%s\n",pNode->GetComputer(),pNode->GetService(),pNode->GetAccount(),L"NULL");
      }

      dwCount = UStrLen((WCHAR*)pbBuffer) * (sizeof WCHAR) ;

      // the buffer must be a multiple of the key cipher's block length
      // NOTE: this algorithm assumes block length is multiple of sizeof(WCHAR)

      if (dwBlockSize > 0)
      {
         // calculate next multiple greater than count
         dwPaddedCount = ((dwCount + (dwBlockSize / 2)) / dwBlockSize) * dwBlockSize;

         // pad buffer with space characters

         WCHAR* pch = (WCHAR*)(pbBuffer + dwCount);

         for (; dwCount < dwPaddedCount; dwCount += sizeof(WCHAR))
         {
            *pch++ = L' ';
         }
      }

      // Encrypt the data.
      if(!CryptEncrypt(hKey, 0, (pNode->Next() == NULL) , 0, pbBuffer, &dwCount,
                                                  BUFFER_SIZE))
      {
         rc = GetLastError();
         goto done;
      }

       // Write the data to the destination file.
       fwrite(pbBuffer, 1, dwCount, hDest);
       if(ferror(hDest)) 
       {
           rc = GetLastError();
           goto done;
       }
   }

   done:

   // Destroy the session key.
   if(hKey != 0) CryptDestroyKey(hKey);

   // Destroy the key exchange key.
   if(hXchgKey != 0) CryptDestroyKey(hXchgKey);

   // Release the provider handle.
   if(hProv != 0) CryptReleaseContext(hProv, 0);

   // Close destination file.
   if(hDest != NULL) fclose(hDest);

   return rc;
}


// AcquireContext Method
//
// acquire handle to key container within cryptographic service provider (CSP)
//

HCRYPTPROV TEntryList::AcquireContext(bool bContainerMustExist)
{
	HCRYPTPROV hProv = 0;

	#define KEY_CONTAINER_NAME _T("A69904BC349C4CFEAAEAB038BAB8C3B1")

	if (bContainerMustExist)
	{
		// first try Microsoft Enhanced Cryptographic Provider

		if (!CryptAcquireContext(&hProv, KEY_CONTAINER_NAME, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET))
		{
			if (GetLastError() == NTE_KEYSET_NOT_DEF)
			{
				// then try Microsoft Base Cryptographic Provider

				CryptAcquireContext(&hProv, KEY_CONTAINER_NAME, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET);
			}
		}
	}
	else
	{
		// first try Microsoft Enhanced Cryptographic Provider

		if (!CryptAcquireContext(&hProv, KEY_CONTAINER_NAME, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET))
		{
			DWORD dwError = GetLastError();

			if ((dwError == NTE_BAD_KEYSET) || (dwError == NTE_KEYSET_NOT_DEF))
			{
				// then try creating key container in enhanced provider

				if (!CryptAcquireContext(&hProv, KEY_CONTAINER_NAME, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET|CRYPT_NEWKEYSET))
				{
					dwError = GetLastError();

					if (dwError == NTE_KEYSET_NOT_DEF)
					{
						// then try Microsoft Base Cryptographic Provider

						if (!CryptAcquireContext(&hProv, KEY_CONTAINER_NAME, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET))
						{
							dwError = GetLastError();

							if ((dwError == NTE_BAD_KEYSET) || (dwError == NTE_KEYSET_NOT_DEF))
							{
								// finally try creating key container in base provider

								CryptAcquireContext(&hProv, KEY_CONTAINER_NAME, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET|CRYPT_NEWKEYSET);
							}
						}
					}
				}
			}
		}
	}

	return hProv;
}


STDMETHODIMP CServMigr::TryUpdateSam(BSTR computer,BSTR service,BSTR account)
{
   HRESULT                   hr = S_OK;
   
   // Find the entry in the list, and perform the update
   TNodeListEnum             e;
   TEntryNode              * pNode;
   BOOL                      bFound = FALSE;

   for ( pNode = (TEntryNode*)e.OpenFirst(&m_List) ; pNode ; pNode = (TEntryNode*)e.Next() )
   {
      if (  !UStrICmp(computer,pNode->GetComputer())
         && !UStrICmp(service,pNode->GetService()) 
         && !UStrICmp(account,pNode->GetAccount())
         )
      {
         // found it!
         bFound = TRUE;
         hr = TryUpdateSamWithPassword(computer,service,account,SysAllocString(pNode->GetPassword()) );
         break;
      }
   }
   
   if ( ! bFound )
   {
      hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
   }
   return hr;
}

STDMETHODIMP CServMigr::TryUpdateSamWithPassword(BSTR computer,BSTR service,BSTR domAccount,BSTR password)
{
   DWORD                     rc = 0;
   WCHAR                     domain[LEN_Domain];
   WCHAR                     dc[LEN_Computer];
   WCHAR                     account[LEN_Account];
   WCHAR                     domStr[LEN_Domain];
   BYTE                      sid[100];
   WCHAR                     strSid[200];
   WCHAR                   * pSlash = wcschr(domAccount,L'\\');
   DOMAIN_CONTROLLER_INFO  * pInfo = NULL;
   SID_NAME_USE              snu;
   DWORD                     lenSid = DIM(sid);
   DWORD                     lenDomStr = DIM(domStr);
   DWORD                     lenStrSid = DIM(strSid);

   // split out the domain and account names
   if ( pSlash )
   {
//      UStrCpy(domain,domAccount,pSlash - domAccount + 1);
      UStrCpy(domain,domAccount,(int)(pSlash - domAccount + 1));
      UStrCpy(account,pSlash+1);
      
      rc = DsGetDcName(NULL,domain,NULL,NULL,0,&pInfo);
      if (! rc )
      {
         safecopy(dc,pInfo->DomainControllerName);
         NetApiBufferFree(pInfo);
      }

      // get the SID for the target account
      if ( LookupAccountName(dc,account,sid,&lenSid,domStr,&lenDomStr,&snu) )
      {
         GetTextualSid(sid,strSid,&lenStrSid);

         rc = DoUpdate(domAccount,password,strSid,computer,service,TRUE);
      }
      else 
      {
         rc = GetLastError();
      }
   }
   else
   {
      rc = ERROR_NOT_FOUND;
   }
   
   return HRESULT_FROM_WIN32(rc);
}


BOOL                                       // ret - TRUE if directory found
   CServMigr::GetDirectory(
      WCHAR                * filename      // out - string buffer to store directory name
   )
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;


   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);


   if ( ! rc )
   {

	   rc = key.ValueGetStr(L"Directory",filename,MAX_PATH);

	   if ( ! rc )
      {
         if ( *filename ) 
            bFound = TRUE;
      }
   }
   key.Close();

   return bFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\scmmigr\servmigr.h ===
// ServMigr.h : Declaration of the CServMigr

#ifndef __SERVMIGR_H_
#define __SERVMIGR_H_

#include "resource.h"       // main symbols
#include "TNode.hpp"
#include "EaLen.hpp"
#include "UString.hpp"
#include "ExtSeq.h"
#include <wincrypt.h>

#define LEN_Service     200
//#import "\bin\DBManager.tlb" no_namespace, named_guids
#import "DBMgr.tlb" no_namespace, named_guids

#include "CommaLog.hpp"

class TEntryNode : public TNode
{
   WCHAR                     computer[LEN_Computer];
   WCHAR                     service[LEN_Service];
   WCHAR                     account[LEN_Account];
   WCHAR                     password[LEN_Password];
public:
   TEntryNode(WCHAR const * c,WCHAR const * s,WCHAR const * a,WCHAR const* p)
   {
      safecopy(computer,c);
      safecopy(service,s);
      safecopy(account,a);
      safecopy(password,p ? p: L"");
   }
   WCHAR const * GetComputer() { return computer; }
   WCHAR const * GetService() { return service; }
   WCHAR const * GetAccount() { return account; }
   WCHAR const * GetPassword() { return password; }
   void SetPassword(WCHAR const* p) { safecopy(password,p ? p: L""); }
};

class TEntryList : public TNodeList
{
   WCHAR                     file[LEN_Path];
public:
   TEntryList(WCHAR const * filename) { safecopy(file,filename); LoadFromFile(file);  }
   DWORD LoadFromFile(WCHAR const * filename);
   DWORD SaveToFile(WCHAR const * filename);
   ~TEntryList() { SaveToFile(file); DeleteAllListItems(TEntryNode); }
private:
   HCRYPTPROV AcquireContext(bool bContainerMustExist);
};


/////////////////////////////////////////////////////////////////////////////
// CServMigr
class ATL_NO_VTABLE CServMigr : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CServMigr, &CLSID_ServMigr>,
	public IDispatchImpl<IExtendAccountMigration, &IID_IExtendAccountMigration, &LIBID_SCMMIGRLib>,
   public ISvcMgr
{
      TEntryList        m_List;
      IIManageDBPtr     m_pDB;
      BOOL              m_bFatal;
      CommaDelimitedLog m_passwordLog;       //Password file
      bool              m_bTriedToOpenFile; 
      long              m_Sequence;

public:
   CServMigr() : m_List(L"SCMData.txt")
	{
      HRESULT           hr = m_pDB.CreateInstance(CLSID_IManageDB);
      
      if ( FAILED(hr) )
      {
         m_bFatal = TRUE;
      }
      else
      {
         m_bFatal = FALSE;
      }
      m_bTriedToOpenFile = FALSE;
      m_Sequence = AREXT_DEFAULT_SEQUENCE_NUMBER;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_SvcMgr)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CServMigr)
	COM_INTERFACE_ENTRY(IExtendAccountMigration)
   COM_INTERFACE_ENTRY(ISvcMgr)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IExtendAccountMigration
public:
   STDMETHOD(ProcessUndo)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in, out]*/ IUnknown ** pPropToSet);
   STDMETHOD(PreProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet);
   STDMETHOD(ProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet);
   STDMETHOD(get_sDesc)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(put_sDesc)(/*[in]*/ BSTR newVal);
   STDMETHOD(get_sName)(/*[out, retval]*/ BSTR *pVal);
   STDMETHOD(put_sName)(/*[in]*/ BSTR newVal);
   STDMETHOD(get_SequenceNumber)(/*[out, retval]*/ LONG * value) { (*value) = m_Sequence; return S_OK; }
protected:
   // Helper functions
   BOOL UpdateSCMs(IUnknown * pVarSet,WCHAR const * account, WCHAR const * password,WCHAR const * strSid,IIManageDB * pDB);
   HRESULT SaveEncryptedPassword(WCHAR const * server,WCHAR const * service,WCHAR const * account,WCHAR const * password);
   DWORD DoUpdate(WCHAR const * acount,WCHAR const * password,WCHAR const * strSid,WCHAR const * computer,WCHAR const * service,BOOL bNeedToGrantLOS);
   BOOL GetDirectory(WCHAR* filename);

   // ISvcMgr
public:
   STDMETHOD(TryUpdateSam)(BSTR computer,BSTR service,BSTR account);
   STDMETHOD(TryUpdateSamWithPassword)(BSTR computer,BSTR service,BSTR account,BSTR password);
};

#endif //__SERVMIGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\scmmigr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__8FCC6D11_4A12_11D3_99F9_0010A4F77383__INCLUDED_)
#define AFX_STDAFX_H__8FCC6D11_4A12_11D3_99F9_0010A4F77383__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__8FCC6D11_4A12_11D3_99F9_0010A4F77383__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\setpwd\mcsdebug_stub.cpp ===
/* This is a stub to include common\commonlib\mcsdebug.cpp in this project and compile
	that cpp differently than it is for common.lib */
#include "StdAfx.h"
#include "McsDebug.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\setpwd\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\setpwd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by SetPwd.rc
//
#define IDS_PROJNAME                    100
#define IDR_SETPASSWORD                 101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\updatedb\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\setpwd\setpass.h ===
//---------------------------------------------------------------------------
// SetPass.h
//
// Comment: This is a COM object extension for the MCS DCTAccountReplicator.
//          This object implements the IExtendAccountMigration interface. 
//          The process method of this object sets the password for the 
//          target account according to the users specification.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------

#ifndef __SETPASSWORD_H_
#define __SETPASSWORD_H_

#include "resource.h"       // main symbols
#include "CommaLog.hpp"
#include "ExtSeq.h"
#include "ADMTCrypt.h"
#include <string>
#include <map>

#import "VarSet.tlb" no_namespace rename("property", "aproperty")
#import "MsPwdMig.tlb" no_namespace

typedef std::basic_string<WCHAR> tstring;
/////////////////////////////////////////////////////////////////////////////
// CSetPassword
class ATL_NO_VTABLE CSetPassword : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CSetPassword, &CLSID_SetPassword>,
	public IDispatchImpl<IExtendAccountMigration, &IID_IExtendAccountMigration, &LIBID_SETTARGETPASSWORDLib>
{
public:
   CSetPassword() : m_bTriedToOpenFile(false)
	{
      m_sName = L"Set Target Password";
      m_sDesc = L"Sets the target password and other related options.";
      m_Sequence = AREXT_LATER_SEQUENCE_NUMBER;
	  m_bEstablishedSession = false;
	  m_bUCCPFlagSet = false;
	  m_bUMCPNLFlagSet = false;
	  m_bPNEFlagSet = false;
	  m_pTgtCrypt = NULL;
	  m_sUndoneUsers = L",";
	  m_lPwdHistoryLength = -1;
	}

   ~CSetPassword()
	{
      mUCCPMap.clear();
      mMigTimeMap.clear();
      m_passwordLog.LogClose();
	  delete m_pTgtCrypt;
	}


DECLARE_REGISTRY_RESOURCEID(IDR_SETPASSWORD)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CSetPassword)
	COM_INTERFACE_ENTRY(IExtendAccountMigration)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IExtendAccountMigration
public:
   STDMETHOD(ProcessUndo)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in, out]*/ IUnknown ** pPropToSet);
	STDMETHOD(PreProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet);
	STDMETHOD(ProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet);
	STDMETHOD(get_sDesc)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sDesc)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_sName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sName)(/*[in]*/ BSTR newVal);
   STDMETHOD(get_SequenceNumber)(/*[out, retval]*/ LONG * value) { (*value) = m_Sequence; return S_OK; }
private:
	_bstr_t m_sDesc;
	_bstr_t m_sName;
   CommaDelimitedLog         m_passwordLog;       //Password file
   bool                      m_bTriedToOpenFile; 
   long                      m_Sequence;
   bool						 m_bEstablishedSession;
   CTargetCrypt			   * m_pTgtCrypt;
   bool						 m_bUCCPFlagSet;
   bool						 m_bUMCPNLFlagSet;
   bool						 m_bPNEFlagSet;
   long						 m_lPwdHistoryLength;
   typedef std::map<tstring,bool> CUCCPMap;
   CUCCPMap mUCCPMap;
   typedef std::map<tstring,_variant_t> CMigTimeMap;
   CMigTimeMap mMigTimeMap;
   _bstr_t m_sUndoneUsers;
   IPasswordMigrationPtr     m_pPwdMig;

   BOOL GetDirectory(WCHAR* filename);
   bool IsValidPassword(LPCWSTR pwszPassword);
   HRESULT CopyPassword(_bstr_t srcServer, _bstr_t tgtServer, _bstr_t srcName, _bstr_t tgtName, _bstr_t password);
   void SetUserMustChangePwdFlag(IUnknown *pTarget);
   void RecordPwdFlags(LPCWSTR pwszMach, LPCWSTR pwszUser);
   void ResetPwdFlags(IUnknown *pTarget, LPCWSTR pwszMach, LPCWSTR pwszUser);
   void ClearUserCanChangePwdFlag(LPCWSTR pwszMach, LPCWSTR pwszUser);
   BOOL CanCopyPassword(IVarSet * pVarSet, LPCWSTR pwszMach, LPCWSTR pwszUser);
};

#endif //__SETPASSWORD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\updatedb\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__43C988D1_3AEF_11D3_8C9E_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__43C988D1_3AEF_11D3_8C9E_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__43C988D1_3AEF_11D3_8C9E_0090270D48D1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\updatedb\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by UpdateDB.rc
//
#define IDS_PROJNAME                    100
#define IDR_STOREINFO                   101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\updatedb\storeinfo.cpp ===
// StoreInfo.cpp : Implementation of CStoreInfo
#include "stdafx.h"
#include "UpdateDB.h"
#include "ResStr.h"
#include "StoreInfo.h"
#include "Err.hpp"
#include "ARExt_i.c"

//#import "\bin\mcsvarsetmin.tlb" no_namespace
//#import "\bin\DBManager.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")
#import "DBMgr.tlb" no_namespace
/////////////////////////////////////////////////////////////////////////////
// CStoreInfo
StringLoader  gString;
#define LEN_Path   255
//---------------------------------------------------------------------------
// Get and set methods for the properties.
//---------------------------------------------------------------------------
STDMETHODIMP CStoreInfo::get_sName(BSTR *pVal)
{
   *pVal = m_sName;
	return S_OK;
}

STDMETHODIMP CStoreInfo::put_sName(BSTR newVal)
{
   m_sName = newVal;
	return S_OK;
}

STDMETHODIMP CStoreInfo::get_sDesc(BSTR *pVal)
{
   *pVal = m_sDesc;
	return S_OK;
}

STDMETHODIMP CStoreInfo::put_sDesc(BSTR newVal)
{
   m_sDesc = newVal;
	return S_OK;
}

//---------------------------------------------------------------------------
// ProcessObject : This method doesn't do anything
//---------------------------------------------------------------------------
STDMETHODIMP CStoreInfo::PreProcessObject(
                                             IUnknown *pSource,         //in- Pointer to the source AD object
                                             IUnknown *pTarget,         //in- Pointer to the target AD object
                                             IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                             IUnknown **ppPropsToSet    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                        //         once all extension objects are executed.
                                       )
{
   return S_OK;
}

//---------------------------------------------------------------------------
// ProcessObject : This method adds the copied account info to the DB
//---------------------------------------------------------------------------
STDMETHODIMP CStoreInfo::ProcessObject(
                                             IUnknown *pSource,         //in- Pointer to the source AD object
                                             IUnknown *pTarget,         //in- Pointer to the target AD object
                                             IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                             IUnknown **ppPropsToSet    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                        //         once all extension objects are executed.
                                       )
{
   IIManageDBPtr             pDBMgr;//(__uuidof(IManageDB));
   IVarSetPtr                pVs(__uuidof(VarSet));
   IVarSetPtr                pMain = pMainSettings;
   IUnknown                * pUnk;
   HRESULT                   hr;
   long                      lActionID = 0;
   _variant_t                var;
   TError                    logFile;


   var = pMain->get(GET_BSTR(DCTVS_DBManager));
   if ( var.vt == VT_DISPATCH )
   {
      pDBMgr = var.pdispVal;
      // Fill up the Varset from the info in the main settings varset.
      var = pMain->get(GET_BSTR(DCTVS_CopiedAccount_SourcePath));
      pVs->put(GET_BSTR(DB_SourceAdsPath),var);
      var = pMain->get(GET_BSTR(DCTVS_CopiedAccount_TargetPath));
      pVs->put(GET_BSTR(DB_TargetAdsPath),var);
      var = pMain->get(GET_BSTR(DCTVS_Options_SourceDomain));
      pVs->put(GET_BSTR(DB_SourceDomain), var);

      var = pMain->get(GET_BSTR(DCTVS_Options_TargetDomain));
      pVs->put(GET_BSTR(DB_TargetDomain), var);
   
      var = pMain->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
      pVs->put(GET_BSTR(DB_SourceSamName), var);
   
      var = pMain->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
      pVs->put(GET_BSTR(DB_TargetSamName), var);
   
      var = pMain->get(GET_BSTR(DCTVS_CopiedAccount_Type));
      pVs->put(GET_BSTR(DB_Type), var);
   
      var = pMain->get(GET_BSTR(DCTVS_CopiedAccount_GUID));
      pVs->put(GET_BSTR(DB_GUID), var);
   
      var = pMain->get(GET_BSTR(DCTVS_CopiedAccount_Status));
      pVs->put(GET_BSTR(DB_status), var);
   
      var = pMain->get(GET_BSTR(DCTVS_CopiedAccount_SourceRID));
      pVs->put(GET_BSTR(DB_SourceRid),var);

      var = pMain->get(GET_BSTR(DCTVS_CopiedAccount_TargetRID));
      pVs->put(GET_BSTR(DB_TargetRid),var);

      var = pMain->get(GET_BSTR(DCTVS_CopiedAccount_SourceDomainSid));
      pVs->put(GET_BSTR(DB_SourceDomainSid), var);

      hr = pVs->QueryInterface(IID_IUnknown, (void**)&pUnk);
      if ( FAILED(hr)) return hr;

      hr = pDBMgr->raw_GetCurrentActionID(&lActionID);
      if ( FAILED(hr)) return hr;

      hr = pDBMgr->raw_SaveMigratedObject(lActionID, pUnk);
      if ( FAILED(hr)) return hr;
      pUnk->Release();
   }

   return S_OK;
}

//---------------------------------------------------------------------------
// ProcessUndo :  This method adds an entry into the DB for undoing migration
//---------------------------------------------------------------------------
STDMETHODIMP CStoreInfo::ProcessUndo(                                             
                                       IUnknown *pSource,         //in- Pointer to the source AD object
                                       IUnknown *pTarget,         //in- Pointer to the target AD object
                                       IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                       IUnknown **ppPropsToSet    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                  //         once all extension objects are executed.
                                    )
{
   // We need to delete this entry from the database.
   WCHAR                     sQuery[LEN_Path];
   IVarSetPtr                pVs = pMainSettings;
   IIManageDBPtr             pDBMgr;
   HRESULT                   hr = E_INVALIDARG;
   _variant_t                var;
   _bstr_t                   sSourceSam = pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
   _bstr_t                   sTargetSam = pVs->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
   _bstr_t                   sSourceDom = pVs->get(GET_BSTR(DCTVS_Options_SourceDomain));
   _bstr_t                   sTargetDom = pVs->get(GET_BSTR(DCTVS_Options_TargetDomain));


   var = pVs->get(GET_BSTR(DCTVS_DBManager));
   if ( var.vt == VT_DISPATCH )
   {
      pDBMgr = var.pdispVal;
      _bstr_t bstrSameForest = pVs->get(GET_BSTR(DCTVS_Options_IsIntraforest));

      if (! UStrICmp((WCHAR*)bstrSameForest,GET_STRING(IDS_YES)) )
      {
         swprintf(sQuery, L"SourceSamName = \"%s\" and TargetSamName = \"%s\" and SourceDomain = \"%s\" and TargetDomain = \"%s\"",
                  (WCHAR*)sTargetSam, (WCHAR*)sSourceSam, (WCHAR*)sTargetDom, (WCHAR*)sSourceDom);
      }
      else
      {
         swprintf(sQuery, L"SourceSamName = \"%s\" and TargetSamName = \"%s\" and SourceDomain = \"%s\" and TargetDomain = \"%s\"",
                  (WCHAR*)sSourceSam, (WCHAR*)sTargetSam, (WCHAR*)sSourceDom, (WCHAR*)sTargetDom);
      }
      _bstr_t  sFilter = sQuery;
	  _variant_t Filter = sFilter;
      hr = pDBMgr->raw_ClearTable(L"MigratedObjects", Filter);
   }
   return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\setpwd\setpass.cpp ===
//---------------------------------------------------------------------------
// SetPass.cpp
//
// Comment: This is a COM object extension for the MCS DCTAccountReplicator.
//          This object implements the IExtendAccountMigration interface. 
//          The process method of this object sets the password for the 
//          target account according to the users specification.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "ResStr.h"
#include <lm.h>
#include "rpc.h"
#include "EaLen.hpp"
#include <activeds.h>
#include "ARExt.h"
#include "ARExt_i.c"
#include "ErrDCT.hpp"
#include "PWGen.hpp"
#include "TReg.hpp"

#import "DBMgr.tlb" no_namespace

StringLoader                 gString;
TErrorDct   err;

#include "SetPwd.h"
#include "SetPass.h"
#include "pwdfuncs.h"
#include "PwRpcUtl.h"
#include "PwdSvc.h"

#define AR_Status_Created           (0x00000001)

/////////////////////////////////////////////////////////////////////////////
// CSetPassword

//---------------------------------------------------------------------------
// Get and set methods for the properties.
//---------------------------------------------------------------------------
STDMETHODIMP CSetPassword::get_sName(BSTR *pVal)
{
   *pVal = m_sName;
	return S_OK;
}

STDMETHODIMP CSetPassword::put_sName(BSTR newVal)
{
   m_sName = newVal;
	return S_OK;
}

STDMETHODIMP CSetPassword::get_sDesc(BSTR *pVal)
{
   *pVal = m_sDesc;
	return S_OK;
}

STDMETHODIMP CSetPassword::put_sDesc(BSTR newVal)
{
   m_sDesc = newVal;
	return S_OK;
}

//---------------------------------------------------------------------------
// ProcessObject : This method currently records the setting of the "User
//                 cannot change password" flag for intra-forest user migrations
//---------------------------------------------------------------------------
STDMETHODIMP CSetPassword::PreProcessObject(
                                             IUnknown *pSource,         //in- Pointer to the source AD object
                                             IUnknown *pTarget,         //in- Pointer to the target AD object
                                             IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                             IUnknown **ppPropsToSet    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                        //         once all extension objects are executed.
                                          )
{
/* local variables */
   IVarSetPtr  pVS = pMainSettings;
   tstring	   sSAMName = L"";

/* function body */
   _bstr_t sIntraforest = pVS->get(GET_BSTR(DCTVS_Options_IsIntraforest));
   _bstr_t sType = pVS->get(GET_BSTR(DCTVS_CopiedAccount_Type));
   _bstr_t sSrc = pVS->get(GET_BSTR(DCTVS_Options_SourceServer));
   _bstr_t sAccount = pVS->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
   if ((!sIntraforest.length()) || (!sType.length()) || 
	   (!sSrc.length()) || (!sAccount.length()))
	   return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

   sSAMName = sAccount;
   if (!UStrICmp((WCHAR*)sIntraforest,GET_STRING(IDS_YES)))
   {
      if (!UStrICmp((WCHAR*)sType,L"user"))
      {
            //record the password flags set on the source account
         RecordPwdFlags(sSrc, sAccount);
		    //we only want to record the "User cannot change password" flag, so
		    //clear the others
		 m_bUMCPNLFlagSet = false;
		 m_bPNEFlagSet = false;

		    //store the flag setting in a map
         mUCCPMap.insert(CUCCPMap::value_type(sSAMName, m_bUCCPFlagSet));
	  }
   }
      //if previously migrated, store that time in a map
   _bstr_t sSrcDom = pVS->get(GET_BSTR(DCTVS_Options_SourceDomain));
   _bstr_t sTgtDom = pVS->get(GET_BSTR(DCTVS_Options_TargetDomain));
   IVarSetPtr		pVSMig(__uuidof(VarSet));
   IUnknown		  * pUnk;
   IIManageDBPtr	pDb(__uuidof(IManageDB));
   _variant_t		varDate;
   
   pVSMig->QueryInterface(IID_IUnknown, (void**) &pUnk);
   HRESULT hrFind = pDb->raw_GetAMigratedObject(sAccount, sSrcDom, sTgtDom, &pUnk);
   pUnk->Release();
      //if migrated previously, store that time and date in a class map
   if (hrFind == S_OK)
   {
	  varDate = pVSMig->get(L"MigratedObjects.Time");
	     //store the flag setting in a map
      mMigTimeMap.insert(CMigTimeMap::value_type(sSAMName, varDate));
   }

   return S_OK;
}
//---------------------------------------------------------------------------
// ProcessObject : This method sets the password of the target object
//                 by looking at the settings in the varset.
//---------------------------------------------------------------------------
STDMETHODIMP CSetPassword::ProcessObject(
                                             IUnknown *pSource,         //in- Pointer to the source AD object
                                             IUnknown *pTarget,         //in- Pointer to the target AD object
                                             IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                             IUnknown **ppPropsToSet    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                        //         once all extension objects are executed.
                                          )
{
   _bstr_t                   sType;
   _bstr_t                   sFileName;
   IVarSetPtr                pVS = pMainSettings;
   WCHAR                     password[LEN_Path];
   bool                      bGenerate = false;
   bool                      bGenerated = false;
   DWORD                     dwMinUC = 0, dwMinLC = 0, dwMinDigits = 1, dwMinSpecial = 0, dwMaxAlpha = 10, dwMinLen = 4;
   _variant_t                var;
//   TErrorDct                 err;
   WCHAR                     fileName[LEN_Path];
   bool						 bCopiedPwd = false;
   HRESULT					 hrPwd = ERROR_SUCCESS;

   // Get the Error log filename from the Varset
   var = pVS->get(GET_BSTR(DCTVS_Options_Logfile));
   wcscpy(fileName, (WCHAR*)V_BSTR(&var));
   VariantInit(&var);
   // Open the error log
   err.LogOpen(fileName, 1);
   
   _bstr_t sXXX = GET_BSTR(DCTVS_Options_TargetServer);
   _variant_t vMach = pVS->get(sXXX);
   _variant_t vTgtName = pVS->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));

   _bstr_t sSrc = pVS->get(GET_BSTR(DCTVS_Options_SourceServer));
   _bstr_t sSrcDom = pVS->get(GET_BSTR(DCTVS_Options_SourceDomain));
   _bstr_t sMach = vMach;
   _bstr_t sTgtName = vTgtName;
   _bstr_t sAccount = pVS->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
   _bstr_t sSkip = pVS->get(GET_BSTR(DCTVS_CopiedAccount_DoNotUpdatePassword));
   _bstr_t sTgtCN = pVS->get(GET_BSTR(DCTVS_CopiedAccount_TargetName));
   _bstr_t sIntraforest = pVS->get(GET_BSTR(DCTVS_Options_IsIntraforest));
   _bstr_t sCopyPwd = pVS->get(GET_BSTR(DCTVS_AccountOptions_CopyPasswords));
   _bstr_t sPwdDC = pVS->get(GET_BSTR(DCTVS_AccountOptions_PasswordDC));

   if ( !UStrICmp((WCHAR*)sSkip,(WCHAR*)sAccount) )
   {
      return S_OK;
   }
   
   if ( sTgtCN.length() == 0 ) 
      sTgtCN = sTgtName;
   // strip off the CN= from the beginning of the name, if necessary
   if ( !UStrICmp(sTgtCN,"CN=",3) )
   {
      sTgtCN = _bstr_t(((WCHAR*)sTgtCN)+3);
   }

   dwMaxAlpha = (LONG)pVS->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MaxConsecutiveAlpha));
   dwMinDigits = (LONG)pVS->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinDigit));
   dwMinLC = (LONG)pVS->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinLower));
   dwMinUC = (LONG)pVS->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinUpper));
   dwMinSpecial = (LONG)pVS->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinSpecial));
   dwMinLen = (LONG)pVS->get(GET_BSTR(DCTVS_AccountOptions_PasswordPolicy_MinLength));

   // if the values are all 0 s then we make up something
   if ( (dwMaxAlpha + dwMinDigits + dwMinLC + dwMinUC + dwMinSpecial) == 0 ) 
   {
      dwMinDigits = 3;
      dwMinSpecial = 3;
      dwMinUC = 3;
      dwMinLC = 3;
   }

   sType = pVS->get(GET_BSTR(DCTVS_CopiedAccount_Type)).bstrVal;

      //for intra-forest migration of a user, reset the user's
      //original "User cannot change password" flag, whose value is
	  //stored in the map
   if ( ! UStrICmp((WCHAR*)sIntraforest,GET_STRING(IDS_YES)) )
   {
      if ( ! UStrICmp((WCHAR*)sType,L"user" ) )
      {
		   //get the UCCP flag from the map
         CUCCPMap::iterator		itUCCPMap;
         tstring				sSam = sAccount;
		 itUCCPMap = mUCCPMap.find(sSam);
		 if (itUCCPMap != mUCCPMap.end())
		    m_bUCCPFlagSet = itUCCPMap->second;
		 else
		    m_bUCCPFlagSet = false;
		 m_bUMCPNLFlagSet = false;
		 m_bPNEFlagSet = false;

		 ResetPwdFlags(pTarget, sMach, sTgtName);
         return S_OK;
      }
   }
   // Set the password for this account.
   if ( (_wcsicmp((WCHAR*)sType,L"user") == 0) || (_wcsicmp((WCHAR*)sType, L"computer") == 0)  )
   {
      if  ( !_wcsicmp((WCHAR*)sType,L"user" ) )
      {
			//we will not migrate passwords if replacing and password reuse policy on the target is 2 or greater
		 if (!CanCopyPassword(pVS, sSrc, sAccount))
		 {
            err.MsgWrite(0,DCT_MSG_PW_COPY_NOT_TRIED_S,(WCHAR*)sTgtCN);
			return S_OK;
		 }

         _bstr_t bstrGenerate = pVS->get(GET_BSTR(DCTVS_AccountOptions_GenerateStrongPasswords));

         if (bstrGenerate == GET_BSTR(IDS_YES))
         {
            bGenerate = true;
         }

         if (bGenerate)
         {
            // generate a strong password
            BOOL pwGeneratedRc = EaPasswordGenerate(dwMinUC, dwMinLC, dwMinDigits, dwMinSpecial, dwMaxAlpha, dwMinLen, password, LEN_Path);
            bGenerated = ( pwGeneratedRc == 0 );

            if ( !bGenerated )
               wcsncpy(password,(WCHAR*)(sTgtName),15);

            // ensure that the password is NULL terminated
            password[14] = 0;
            
         }
         else
         {
            // set the password to the first 14 characters of the username
            wcsncpy(password,(WCHAR*)(sTgtName),15);
             // Convert the password to lower case.
            
            // ensure that the password is NULL terminated
            password[14] = 0;
            
            for ( DWORD i = 0; i < wcslen(password); i++ )
               password[i] = towlower(password[i]);

            // if the password is invalid then generate a password

         // if (!IsValidPassword(password))
         // {
         //    err.MsgWrite(0, DCT_MSG_USERNAME_INVALID_FOR_PASSWORD_S, (PCWSTR)sTgtCN);

         //    EaPasswordGenerate(dwMinUC, dwMinLC, dwMinDigits, dwMinSpecial, dwMaxAlpha, dwMinLen, password, LEN_Path);

               // TODO: if password generation fails then what? Should not fail though as that would be a logic error?

         //    bGenerated = true;
         // }
         }
      }
      else
      {
         // computer, set the password to the first 14 characters of the computer name, in lower case,
         // without the trailing $
         UStrCpy(password, (WCHAR*)sTgtName, DIM(password));
         if ( password[UStrLen(password) - 1] == L'$' )
            password[UStrLen(password) - 1] = L'\0';  // remove trailing $ from machine name
         password[14] = L'\0';                     // truncate to max password length of 14
         
          // Convert the password to lower case.
          for ( DWORD i = 0; i < wcslen(password); i++ )
            password[i] = towlower(password[i]);
     
      }

//      BSTR sPassword = password;

      // We are going to use the Net API to set the password.
      USER_INFO_1003                  pInfo;
      DWORD                           pDw;
      WCHAR                           server[MAX_PATH];
	  bool							  bFailedCopyPwd = false;

	     //place the new password in the info structure
	  pInfo.usri1003_password = password;

      long rc = NetUserSetInfo((WCHAR*)sMach, 
                  (WCHAR*)sTgtName, 1003, (LPBYTE) &pInfo, &pDw);

      if ( rc != 0 ) 
	  {
         if ( bGenerated )
		 {
            err.SysMsgWrite(ErrW,rc,DCT_MSG_PW_GENERATE_FAILED_S,(WCHAR*)sTgtCN);
		 }
         else
		 {
            err.SysMsgWrite(ErrW,rc,DCT_MSG_FAILED_SET_PASSWORD_TO_USERNAME_SD,(WCHAR*)sTgtCN,rc);
            if ( rc == NERR_PasswordTooShort )
			{
               // try to generate a password
               EaPasswordGenerate(dwMinUC, dwMinLC, dwMinDigits, dwMinSpecial, dwMaxAlpha, dwMinLen, password, LEN_Path);
            
               rc = NetUserSetInfo((WCHAR*)sMach,(WCHAR*)sTgtName,1003,(LPBYTE)&pInfo,&pDw);
               if ( rc )
			   {
                  err.SysMsgWrite(ErrW,rc,DCT_MSG_PW_GENERATE_FAILED_S,(WCHAR*)sTgtCN);
			   }
               else //else complex password generated, if requested to copy password
			   {    //we now try to do that and only log that complex pwd generated if copy fails
	                 //if we are migrating the user's password, then set it here
                  if ( !UStrICmp((WCHAR*)sCopyPwd,GET_STRING(IDS_YES)) )
				  {
					    //record the password flags set on the source account
					 RecordPwdFlags(sSrc, sAccount);
					    //clear the "User cannot change password" flag if it is set
					 ClearUserCanChangePwdFlag(sMach, sTgtName);
				        //set the change password flag to get past the minimum pwd age policy
			         SetUserMustChangePwdFlag(pTarget);
		                //prepare the server name
                     server[0] = L'\\';
                     server[1] = L'\\';
                     UStrCpy(server+2,(WCHAR*)sPwdDC);
		                //call the member function to copy the password.  If success, set flag, else
					    //failed, log the generated password message
		             if ((hrPwd = CopyPassword(_bstr_t(server), sMach, sAccount, sTgtName, _bstr_t(password))) == ERROR_SUCCESS)
					 {
                        err.MsgWrite(0,DCT_MSG_PWCOPIED_S,(WCHAR*)sTgtCN);
						bCopiedPwd = true;
                           //reset the password flags as were on the source account 
					    ResetPwdFlags(pTarget, sMach, sTgtName);
					 }
					 else
					 {
						bFailedCopyPwd = true;
					 }
				  }//end if migrate password
				  else //else not copy password, so post the complex password generated message
                     err.MsgWrite(0,DCT_MSG_PWGENERATED_S,(WCHAR*)sTgtCN);
			   }
			}
		 }
	  }
      else //else success
	  {
			//if complex password generated, if requested to copy password
			//we now try to do that and only log that complex pwd generated if copy fails
         if ( bGenerated )
		 {
               //if we are migrating the user's password, then set it here
            if ( !UStrICmp((WCHAR*)sCopyPwd,GET_STRING(IDS_YES)) )
			{
				  //record the password flags set on the source account
			   RecordPwdFlags(sSrc, sAccount);
			      //clear the "User cannot change password" flag if it is set
			   ClearUserCanChangePwdFlag(sMach, sTgtName);
				  //set the change password flag to get past the minimum pwd age policy
			   SetUserMustChangePwdFlag(pTarget);
		          //prepare the server name
               server[0] = L'\\';
               server[1] = L'\\';
               UStrCpy(server+2,(WCHAR*)sPwdDC);
		          //call the member function to copy the password.  If success, set flag, else
				  //failed, log the generated password message
		       if ((hrPwd = CopyPassword(_bstr_t(server), sMach, sAccount, sTgtName, _bstr_t(password))) == ERROR_SUCCESS)
			   {
                  err.MsgWrite(0,DCT_MSG_PWCOPIED_S,(WCHAR*)sTgtCN);
			      bCopiedPwd = true;
                     //reset the password flags as were on the source account 
			      ResetPwdFlags(pTarget, sMach, sTgtName);
			   }
			   else
			   {
				  bFailedCopyPwd = true;
			   }
			}//end if migrate password
			else //else not copy password, so post the complex password generated message
               err.MsgWrite(0,DCT_MSG_PWGENERATED_S,(WCHAR*)sTgtCN);
		 }
         else
		 {
            err.MsgWrite(0,DCT_MSG_SET_PASSWORD_TO_USERNAME_S,(WCHAR*)sTgtCN);
		 }
	  }
	     //if user being migrated and that user's password was not copied, write
	     //password to the password file
	  if ((_wcsicmp((WCHAR*)sType,L"user") == 0) && (bCopiedPwd == false))
	  {
		 if ( !m_bTriedToOpenFile )
		 {
			m_bTriedToOpenFile = true;
			// we should see if the varset specifies a file name
			var = pVS->get(GET_BSTR(DCTVS_AccountOptions_PasswordFile));
			sFileName = var;
			if ( sFileName.length() > 0 )
			{
			   // we have the file name so lets open it and save the handle.
			   m_passwordLog.LogOpen(sFileName, TRUE, 1);
			}
			   //failure to get to password file so store it elsewhere and
			   //post that new file location in the migration log
			if (!m_passwordLog.IsOpen() )
			{ 
			   WCHAR sPasswordFile[MAX_PATH];
			   if (GetDirectory(sPasswordFile))//place log in default log dir
			      wcscat(sPasswordFile, L"Logs\\passwords.txt");
			   else
				  wcscpy(sPasswordFile, L"c:\\passwords.txt");
				
			   m_passwordLog.LogOpen(sPasswordFile, TRUE, 1);//open this log file
			   if ( m_passwordLog.IsOpen() )
			   {
			      if (!bFailedCopyPwd)
				     err.MsgWrite(0,DCT_MSG_NEW_PASSWORD_LOG_S,(WCHAR*)sFileName,sPasswordFile);
				  else
				     err.MsgWrite(0,DCT_MSG_NEW_PASSWORD_LOG_CPY_FAILED_S,sPasswordFile);
			   }
			}
			else if (bFailedCopyPwd)
			{
			   WCHAR sPasswordFile[MAX_PATH];
			   wcscpy(sPasswordFile, (WCHAR*)sFileName);
		       err.MsgWrite(0,DCT_MSG_NEW_PASSWORD_LOG_CPY_FAILED_S,sPasswordFile);
			}
		 }

	     // Log the new password in the password log.
	     if ( m_passwordLog.IsOpen() )
		 {
	        m_passwordLog.MsgWrite(L"%ls,%ls",(WCHAR*)(pVS->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam)).bstrVal),password);
		 }
	  }//end if migrating user
   }//end if migrating user or computer

      //change password flags on the account if we did not copy the password
   if (( pTarget ) && (!bCopiedPwd))
   {
      // We want to clear "user cannot change password" and "password never expire flag"
      USER_INFO_1008               usr1008;
      USER_INFO_20               * usr20;
      DWORD                        errParam = 0;
      DWORD rc = NetUserGetInfo((WCHAR*) sSrc, (WCHAR*)sAccount, 20, (LPBYTE *)&usr20);
      _bstr_t                      strDisable = pVS->get(GET_BSTR(DCTVS_AccountOptions_DisableCopiedAccounts));
      _bstr_t                      strSame = pVS->get(GET_BSTR(DCTVS_AccountOptions_TgtStateSameAsSrc));
	  long						   val = pVS->get(GET_WSTR(DCTVS_CopiedAccount_UserFlags));
      BOOL                         bDisable = FALSE;
      BOOL                         bSame = FALSE;

      if ( ! UStrICmp(strDisable,GET_STRING(IDS_YES)) )
         bDisable = TRUE;
      if ( ! UStrICmp(strSame,GET_STRING(IDS_YES)) )
         bSame = TRUE;
      if ( !rc ) 
      {
         usr1008.usri1008_flags = usr20->usri20_flags & ~UF_DONT_EXPIRE_PASSWD;
         // we won't turn off the user cannot change password, we will just expire the password below.
         // This will lock out any account with user cannot change password set, and the admin will
         // have to manually unlock the account.
        
         //usr1008.usri1008_flags &= ~UF_PASSWD_CANT_CHANGE;
         
         // for the computer account we need to set the UF_PASSWD_NOTREQD
         if ( !_wcsicmp((WCHAR*)sType,L"computer") )
         {
            usr1008.usri1008_flags |= UF_PASSWD_NOTREQD;
            // make sure the disable state for the computer account is the same as for the source computer
            if ( usr20->usri20_flags & UF_ACCOUNTDISABLE )
            {
               usr1008.usri1008_flags |= UF_ACCOUNTDISABLE;
            }
            else
            {
               usr1008.usri1008_flags &= ~UF_ACCOUNTDISABLE;
            }
         }
         else
         {
            // for user accounts, the disable flag is set based on the disable option
            // make sure that the disable flag is set properly!
            if ((bDisable) || (bSame && (val & UF_ACCOUNTDISABLE)))
            {
               usr1008.usri1008_flags |= UF_ACCOUNTDISABLE;
            }
            else 
            {
               usr1008.usri1008_flags &= ~UF_ACCOUNTDISABLE;
            }
         }         

         NetUserSetInfo((WCHAR*) sMach, (WCHAR*) sTgtName, 1008, (LPBYTE)&usr1008, &errParam);
         NetApiBufferFree(usr20);
      }
         // Require the users to change the password at next logon since we created new passwords for them
      SetUserMustChangePwdFlag(pTarget);
   }
   err.LogClose();
   return S_OK;
}

//---------------------------------------------------------------------------
// ProcessUndo : Since we cant undo the password setting we will ignore this.
//---------------------------------------------------------------------------
STDMETHODIMP CSetPassword::ProcessUndo(                                             
                                          IUnknown *pSource,         //in- Pointer to the source AD object
                                          IUnknown *pTarget,         //in- Pointer to the target AD object
                                          IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                          IUnknown **ppPropsToSet    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                     //         once all extension objects are executed.
                                       )
{
   _bstr_t                   sType;
   _bstr_t                   sSam;
   _bstr_t                   sServer;
   _bstr_t					 sIntraforest;
   WCHAR                     password[LEN_Path];
   DWORD                     rc = 0;
   DWORD                     pDw = 0;
   IVarSetPtr                pVs = pMainSettings;

   sIntraforest = pVs->get(GET_BSTR(DCTVS_Options_IsIntraforest));
   sSam  = pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
   sType = pVs->get(GET_BSTR(DCTVS_CopiedAccount_Type));
   sServer = pVs->get(GET_BSTR(DCTVS_Options_TargetServer));
   if ((!sIntraforest.length()) || (!sType.length()) || 
	   (!sSam.length()) || (!sServer.length()))
	   return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);

	  //if this is user intra-forest, call preprocess the first time in and
      //precess the second
   if (!UStrICmp((WCHAR*)sIntraforest,GET_STRING(IDS_YES)))
   {
      if (!UStrICmp((WCHAR*)sType,L"user"))
      {
	        //see if this SAM is in the undone list (every entry in the list has a ","
		    //on each side of it
		 _bstr_t sTemp = _bstr_t(L",") + sSam + _bstr_t(L",");
		    //if found, that means it is post migration, so call process
	     if (wcsstr((PCWSTR)m_sUndoneUsers, sTemp))
		 {
		    ProcessObject(pSource, pTarget, pMainSettings, ppPropsToSet);
		 }
		 else //else pre-migration, so add to the list and call preprocess
		 {
			   //add to the list with an ending ","
			m_sUndoneUsers += sSam;
			m_sUndoneUsers += L",";
		    PreProcessObject(pSource, pTarget, pMainSettings, ppPropsToSet);
		 }
	  }
   }
   
   if (!_wcsicmp((WCHAR*) sType, L"computer"))
   {
      USER_INFO_1003                      buf;
      rc = 0;
      if ( !rc ) 
      {
         // Create a lower case password from the sam account name. Do not include the trailing $.
         // Password to be maximum of 14 characters.
         UStrCpy(password, (WCHAR*)sSam, DIM(password));
         if ( password[UStrLen(password) - 1] == L'$' )
            password[UStrLen(password) - 1] = L'\0';  // remove trailing $ from machine name
         password[14] = L'\0';                        // truncate to max password length of 14
         for ( DWORD i = 0; i < wcslen(password); i++ )
            password[i] = towlower(password[i]);
         buf.usri1003_password = password;
         rc = NetUserSetInfo((WCHAR*) sServer, (WCHAR*) sSam, 1003, (LPBYTE) &buf, &pDw);
         if ( rc == 2221 )
         {
            WCHAR             sam[300];
            UStrCpy(sam,(WCHAR*)sSam);

            // remove the $ from the sam account name
            sam[UStrLen(sam)-1] = 0;
            rc = NetUserSetInfo((WCHAR*) sServer, sam, 1003, (LPBYTE) &buf, &pDw);
         }
      }
   }
   return HRESULT_FROM_WIN32(rc);
}

BOOL                                       // ret - TRUE if directory found
   CSetPassword::GetDirectory(
      WCHAR                * filename      // out - string buffer to store directory name
   )
{
   DWORD                     rc = 0;
   BOOL                      bFound = FALSE;
   TRegKey                   key;


   rc = key.OpenRead(GET_STRING(IDS_HKLM_DomainAdmin_Key),HKEY_LOCAL_MACHINE);


   if ( ! rc )
   {

	   rc = key.ValueGetStr(L"Directory",filename,MAX_PATH);

	   if ( ! rc )
      {
         if ( *filename ) 
            bFound = TRUE;
      }
   }
   key.Close();


   return bFound;
}


//---------------------------------------------------------------------------
// IsValidPassword Method
//
// This method validates a password by converting the Unicode password string
// to an ANSI string.
//
// If any Unicode characters cannot be directly translated to an ANSI
// character and a default character must be used then the password is
// invalid.
//
// If any Unicode characters translate to multi-byte characters then the
// password is invalid.
//---------------------------------------------------------------------------


#ifndef WC_NO_BEST_FIT_CHARS
#define WC_NO_BEST_FIT_CHARS 0x00000400
#endif


bool CSetPassword::IsValidPassword(LPCWSTR pwszPassword)
{
	bool bValid = false;

	BOOL bUsedDefaultChar;
	CHAR szPassword[PWLEN + 1];

	// convert Unicode string to ANSI string

	int cch = WideCharToMultiByte(
		CP_ACP,						// use system ANSI code page
		WC_NO_BEST_FIT_CHARS,		// do not use best fit characters
		pwszPassword,
		-1,							// assume password string is zero terminated
		szPassword,
		sizeof (szPassword),
		NULL,
		&bUsedDefaultChar			// will be true if default character used
	);

	// if no error occurred

	if (cch > 0)
	{
		// if default character was not used

		if (bUsedDefaultChar == FALSE)
		{
			CPINFOEX cpie;
			GetCPInfoEx(CP_ACP, 0, &cpie);

			// if code page defines a SBCS then password is valid
			// otherwise code page defines a DBCS and the password
			// must be searched for a multi-byte character

			if ((cpie.LeadByte[0] == 0) && (cpie.LeadByte[1] == 0))
			{
				bValid = true;
			}
			else
			{
				// search for multi-byte character

				bool bLeadByteFound = false;

				for (int ich = 0; ich < cch; ich++)
				{
					if (IsDBCSLeadByteEx(CP_ACP, szPassword[ich]))
					{
						bLeadByteFound = true;
						break;
					}
				}

				// if no multi-byte character found
				// then password is valid

				if (!bLeadByteFound)
				{
					bValid = true;
				}
			}
		}
	}

	return bValid;
}

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 4 SEPT 2000                                                 *
 *                                                                   *
 *     This function is responsible for copying the user's password  *
 * in the source domain to its new account in the target domain.     *
 *     We use the Password Migration COM Wrapper to first check the  *
 * configuration and establish a session with the given Password     *
 * Export server.  Then we copy the password.  The configuration     *
 * check, which establishes a session for this series of operations, *
 * is only done once per set of accounts.                            *
 *                                                                   *
 *********************************************************************/

//BEGIN CopyPassword
HRESULT CSetPassword::CopyPassword(_bstr_t srcServer, _bstr_t tgtServer, _bstr_t srcName, 
								   _bstr_t tgtName, _bstr_t password)
{
/* local variables */
	HRESULT		hr = S_OK;

/* function body */

	if (m_pPwdMig == NULL)
	{
		hr = m_pPwdMig.CreateInstance(__uuidof(PasswordMigration));

		if (FAILED(hr))
		{
			return hr;
		}
	}

		//if we have not checked the password DC's configuration and
		//established a session, do it now
	if (!m_bEstablishedSession)
		hr = m_pPwdMig->raw_EstablishSession(srcServer, tgtServer);
	
		//if success, try copying the password
	if (SUCCEEDED(hr))
		hr = m_pPwdMig->raw_CopyPassword(srcName, tgtName, password);

	   //if either failed, print warning in the migration.log
	if (FAILED(hr))
	{
		IErrorInfoPtr		pErrorInfo = NULL;
		BSTR				bstrDescription;
		_bstr_t				sText = GET_BSTR(IDS_Unspecified_Failure);

			//get the rich error information on the failure
		if (SUCCEEDED(GetErrorInfo(0, &pErrorInfo)))
		{
			HRESULT hrTmp = pErrorInfo->GetDescription(&bstrDescription);
			if (SUCCEEDED(hrTmp)) //if got rich error info, use it
				sText = _bstr_t(bstrDescription, false);
		}
			//print message in the log
        err.MsgWrite(ErrW,DCT_MSG_PW_COPY_FAILED_S,(WCHAR*)tgtName, (WCHAR*)sText);
	}

	return hr;
}
//END CopyPassword


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 5 DEC 2000                                                  *
 *                                                                   *
 *     This function is responsible for setting the "User must change*
 * password at next logon" flag for a given user.  We use this prior *
 * to copying a user's password and after we have just set it to a   *
 * new complex password so that we get around the minimum password   *
 * age policy for the target domain.                                 *
 *                                                                   *
 *********************************************************************/

//BEGIN SetUserMustChangePwdFlag
void CSetPassword::SetUserMustChangePwdFlag(IUnknown *pTarget)
{
/* local variables */
   IADs  * pAds = NULL;

/* function body */
      //set the new pwdLastSet value
   HRESULT hr = pTarget->QueryInterface(IID_IADs, (void**) &pAds);
   if ( SUCCEEDED(hr) )
   {
         // Require the users to change the password at next logon since we created new passwords for them
      VARIANT var;
      VariantInit(&var);
      V_I4(&var)=0;
      V_VT(&var)=VT_I4;
      hr = pAds->Put(L"pwdLastSet",var);
      hr = pAds->SetInfo();
      VariantClear(&var);
      if ( pAds ) pAds->Release();
   }
}
//END SetUserMustChangePwdFlag


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 11 JAN 2001                                                 *
 *                                                                   *
 *     This function is responsible for setting and clearing the     *
 * "User cannot change password" flag for a given user, if it was    *
 * originally set.                                                   *
 *                                                                   *
 *********************************************************************/

//BEGIN ClearUserCanChangePwdFlag
void CSetPassword::ClearUserCanChangePwdFlag(LPCWSTR pwszMach, LPCWSTR pwszUser)
{
/* local variables */
   USER_INFO_3                   * pInfo;
   DWORD                           pDw;
   long		                       rc;

/* function body */
      //get the current flag info for this user
   rc = NetUserGetInfo(pwszMach, pwszUser, 3, (LPBYTE *)&pInfo);
   if (rc == 0)
   {
	     //clear the "User cannot change password" flag if it is set
	  if (pInfo->usri3_flags & UF_PASSWD_CANT_CHANGE)
	  {
         pInfo->usri3_flags &= !(UF_PASSWD_CANT_CHANGE);
         NetUserSetInfo(pwszMach, pwszUser, 3, (LPBYTE)pInfo, &pDw);
	  }

      NetApiBufferFree((LPVOID) pInfo);
   }
}
//END ClearUserCanChangePwdFlag


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 JAN 2001                                                 *
 *                                                                   *
 *     This function is responsible for recording the password flags *
 * from a given user's source domain account.                        *
 *                                                                   *
 *********************************************************************/

//BEGIN RecordPwdFlags
void CSetPassword::RecordPwdFlags(LPCWSTR pwszMach, LPCWSTR pwszUser)
{
/* local variables */
   USER_INFO_3                   * pInfo;
   long		                       rc;

/* function body */
      //get the user password flags
   rc = NetUserGetInfo(pwszMach, pwszUser, 3, (LPBYTE *)&pInfo);
   if (rc == 0)
   {
	     //record whether the "User cannot change password" flag is set
	  if (pInfo->usri3_flags & UF_PASSWD_CANT_CHANGE)
	     m_bUCCPFlagSet = true;//store whether the flag was set
      else
	     m_bUCCPFlagSet = false;

	     //record whether the "Password never expires" flag is set
	  if (pInfo->usri3_flags & UF_DONT_EXPIRE_PASSWD)
	     m_bPNEFlagSet = true;//store whether the flag was set
      else
	     m_bPNEFlagSet = false;

         //record whether the "User must change password at next logon" flag is set
	  if (pInfo->usri3_password_expired)
	     m_bUMCPNLFlagSet = true;//store whether the flag was set
      else
	     m_bUMCPNLFlagSet = false;

      NetApiBufferFree((LPVOID) pInfo);
   }
}
//END RecordPwdFlags


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 22 JAN 2001                                                 *
 *                                                                   *
 *     This function is responsible for recording the password flags *
 * from a given user's source domain account.                        *
 *                                                                   *
 *********************************************************************/

//BEGIN ResetPwdFlags
void CSetPassword::ResetPwdFlags(IUnknown *pTarget, LPCWSTR pwszMach, LPCWSTR pwszUser)
{
/* local variables */
   USER_INFO_3                   * pInfo = NULL;
   DWORD                           pDw;
   long		                       rc;

/* function body */
      //if the "User cannot change password" or "Password never expires" 
      //flag was original set, reset it
   if ((m_bUCCPFlagSet) || (m_bPNEFlagSet))
   {
         //get the current flag info for this user
      rc = NetUserGetInfo(pwszMach, pwszUser, 3, (LPBYTE *)&pInfo);
      if (rc == 0)
	  {
		 if (m_bUCCPFlagSet)
            pInfo->usri3_flags |= UF_PASSWD_CANT_CHANGE;
		 if (m_bPNEFlagSet)
            pInfo->usri3_flags |= UF_DONT_EXPIRE_PASSWD;
         NetUserSetInfo(pwszMach, pwszUser, 3, (LPBYTE)pInfo, &pDw);

         NetApiBufferFree((LPVOID) pInfo);
	  }
   }

      //if the "User must change password at next logon" flag was original set, reset it
   if (m_bUMCPNLFlagSet)
      SetUserMustChangePwdFlag(pTarget);

}
//END ResetPwdFlags


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 7 MAY 2001                                                  *
 *                                                                   *
 *     This function is responsible for determining if we will indeed*
 * set the password.  If the user is being re-migrated, copy password*
 * was selected, the password reuse policy on the target domain is   *
 * greater than 1, and the password on the source object has not been*
 * changed since the last migration of that user, then we will not   *
 * touch the password on the existing object on the target domain.   *
 *                                                                   *
 *********************************************************************/

//BEGIN CanCopyPassword
BOOL CSetPassword::CanCopyPassword(IVarSet * pVarSet, LPCWSTR pwszMach, LPCWSTR pwszUser)
{
/* local constants */
	const long		MAX_REUSE_NUM_ALLOWED = 1;

/* local variables */
	BOOL			bCanCopy = TRUE;
	_variant_t		varDate;
	USER_INFO_1   * pInfo = NULL;
	long			rc;

/* function body */
		//if not copying passwords, return TRUE
	_bstr_t sCopyPwd = pVarSet->get(GET_BSTR(DCTVS_AccountOptions_CopyPasswords));
	if (UStrICmp((WCHAR*)sCopyPwd,GET_STRING(IDS_YES)))
		return bCanCopy;

		//if not previously migrated, return TRUE
	_bstr_t sAccount = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
		//get the previous migration time from the class map
	CMigTimeMap::iterator		itTimeMap;
	tstring						sSam = sAccount;
	itTimeMap = mMigTimeMap.find(sSam);
		//if previously migrated, get the date this user was last migrated
	if (itTimeMap != mMigTimeMap.end())
		varDate = itTimeMap->second;
	else //else return TRUE
		return bCanCopy;

	/* if not already done, check password reuse policy on the target domain */
	if (m_lPwdHistoryLength == -1)
	{
		IADsDomain     			* pDomain;
		_bstr_t                   sDom( L"WinNT://" );
   
		_bstr_t sTgtDom = pVarSet->get(GET_BSTR(DCTVS_Options_TargetDomain));
		sDom += sTgtDom;

		HRESULT hr = ADsGetObject(sDom, IID_IADsDomain, (void **) &pDomain);
		if (SUCCEEDED(hr))
		{
			//Get the password reuse policy
			long lReuse;
			hr = pDomain->get_PasswordHistoryLength(&lReuse);
			pDomain->Release();
				//if successful, store it in a class member variable
			if (SUCCEEDED(hr))
				m_lPwdHistoryLength = lReuse;
		}
	}
	if ((m_lPwdHistoryLength != -1) && (m_lPwdHistoryLength <= MAX_REUSE_NUM_ALLOWED))
		return bCanCopy;

	/* if target account was created, we still want to copy password if object was created (Stystus == 1) */
		//get the migration status for this user
	long lStatus = pVarSet->get(GET_BSTR(DCTVS_CopiedAccount_Status));
		//if the status field has the first bit set, then this user was
		//created and we should return TRUE to copy the password
	if (lStatus & AR_Status_Created)
		return bCanCopy;


	/* check if the source user's password has been modified since its last migration */
		//get time lapsed since last migrated	
	COleDateTime  migTime(varDate.date); //get the time last migrated
	COleDateTime  curTime = COleDateTime::GetCurrentTime(); //get the current time
	COleDateTimeSpan elapsedTime = curTime - migTime;
	DWORD migElapsed = elapsedTime.GetTotalSeconds();
		//get the time the source password was last set
	rc = NetUserGetInfo(pwszMach, pwszUser, 1, (LPBYTE *)&pInfo);
	if (rc == 0)
	{
		DWORD setElapsed = pInfo->usri1_password_age;
		NetApiBufferFree((LPVOID) pInfo);

			//if not set since last migration, set return to FALSE
		if (migElapsed < setElapsed)
			bCanCopy = FALSE;
	}

	return bCanCopy;
}
//END CanCopyPassword
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\upnupdt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\updatedb\storeinfo.h ===
// StoreInfo.h : Declaration of the CStoreInfo

#ifndef __STOREINFO_H_
#define __STOREINFO_H_

#include "resource.h"       // main symbols
#include "extseq.h"

/////////////////////////////////////////////////////////////////////////////
// CStoreInfo
class ATL_NO_VTABLE CStoreInfo : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CStoreInfo, &CLSID_StoreInfo>,
	public IDispatchImpl<IExtendAccountMigration, &IID_IExtendAccountMigration, &LIBID_UPDATEDBLib>
{
public:
	CStoreInfo()
	{
      m_sName = L"Update Database";
      m_sDesc = L"Extension that updates the migration information in the DB";
      m_Sequence = AREXT_LATER_SEQUENCE_NUMBER;
	}

DECLARE_REGISTRY_RESOURCEID(IDR_STOREINFO)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CStoreInfo)
	COM_INTERFACE_ENTRY(IExtendAccountMigration)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IExtendAccountMigration
public:
   STDMETHOD(ProcessUndo)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in, out]*/ IUnknown ** pPropToSet);
	STDMETHOD(PreProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet);
	STDMETHOD(ProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet);
	STDMETHOD(get_sDesc)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sDesc)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_sName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sName)(/*[in]*/ BSTR newVal);
   STDMETHOD(get_SequenceNumber)(/*[out, retval]*/ LONG * value) { (*value) = m_Sequence; return S_OK; }
private:
	_bstr_t m_sDesc;
	_bstr_t m_sName;
   long    m_Sequence;
};

#endif //__STOREINFO_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\setpwd\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__660C4751_349D_11D3_8C93_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__660C4751_349D_11D3_8C93_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#ifdef _DEBUG
//#define _CRTDBG_MAP_ALLOC
//#define _ATL_DEBUG_INTERFACES
//#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
#endif

//#include <afxwin.h>
#include <afxdisp.h>

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__660C4751_349D_11D3_8C93_0090270D48D1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\setpwd\setpwd.cpp ===
// SetTargetPassword.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f SetTargetPasswordps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "SetPwd.h"

#include "SetPwd_i.c"
#include "SetPass.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_SetPassword, CSetPassword)
END_OBJECT_MAP()

class CSetPwdApp : public CWinApp
{
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CSetPwdApp)
	public:
    virtual BOOL InitInstance();
    virtual int ExitInstance();
	//}}AFX_VIRTUAL

	//{{AFX_MSG(CSetPwdApp)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

BEGIN_MESSAGE_MAP(CSetPwdApp, CWinApp)
	//{{AFX_MSG_MAP(CSetPwdApp)
		// NOTE - the ClassWizard will add and remove mapping macros here.
		//    DO NOT EDIT what you see in these blocks of generated code!
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CSetPwdApp theApp;

BOOL CSetPwdApp::InitInstance()
{
	ATLTRACE(_T("{SetTargetPassword.dll}CSetPwdApp::InitInstance() : m_hInstance=0x%08lX\n"), m_hInstance);
    _Module.Init(ObjectMap, m_hInstance, &LIBID_SETTARGETPASSWORDLib);
	BOOL bInit = CWinApp::InitInstance();
	_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);
    return bInit;
}

int CSetPwdApp::ExitInstance()
{
	ATLTRACE(_T("{DomMigSI.dll}CSetPwdApp::ExitInstance() : m_hInstance=0x%08lX\n"), m_hInstance);
    _Module.Term();
    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    AFX_MANAGE_STATE(AfxGetStaticModuleState());
    return (AfxDllCanUnloadNow()==S_OK && _Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\upnupdt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__C9517D21_3F9E_11D3_8CA1_0090270D48D1__INCLUDED_)
#define AFX_STDAFX_H__C9517D21_3F9E_11D3_8CA1_0090270D48D1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <comdef.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__C9517D21_3F9E_11D3_8CA1_0090270D48D1__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\upnupdt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by UPNUpdt.rc
//
#define IDS_PROJNAME                    100
#define IDR_UPDTUPN                     101

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\updatedb\updatedb.cpp ===
// UpdateDB.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f UpdateDBps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "UpdateDB.h"

#include "UpdateDB_i.c"
#include "StoreInfo.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_StoreInfo, CStoreInfo)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_UPDATEDBLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\upnupdt\updtupn.cpp ===
//---------------------------------------------------------------------------
// UPDTUPN.cpp
//
// Comment: This is a COM object extension for the MCS DCTAccountReplicator.
//          This object implements the IExtendAccountMigration interface. 
//          The process method on this object updates the userPrincipalName
//          property on the user object.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#include "stdafx.h"
#include "ARExt.h"
#include "ARExt_i.c"
#include "UPNUpdt.h"
#include "ErrDCT.hpp"
#include "Names.hpp"
#include <iads.h>
#include <AdsHlp.h>
#include "resstr.h"

//#import "\bin\NetEnum.tlb" no_namespace
#import "NetEnum.tlb" no_namespace
#include "UpdtUPN.h"

TErrorDct                      err;

/////////////////////////////////////////////////////////////////////////////
// CUpdtUPN
StringLoader   gString;

//---------------------------------------------------------------------------
// Get and set methods for the properties.
//---------------------------------------------------------------------------
STDMETHODIMP CUpdtUPN::get_sName(BSTR *pVal)
{
   *pVal = m_sName;
	return S_OK;
}

STDMETHODIMP CUpdtUPN::put_sName(BSTR newVal)
{
   m_sName = newVal;
	return S_OK;
}

STDMETHODIMP CUpdtUPN::get_sDesc(BSTR *pVal)
{
   *pVal = m_sDesc;
	return S_OK;
}

STDMETHODIMP CUpdtUPN::put_sDesc(BSTR newVal)
{
   m_sDesc = newVal;
	return S_OK;
}

//---------------------------------------------------------------------------
// ProcessObject : This method doesn't do anything.
//---------------------------------------------------------------------------
STDMETHODIMP CUpdtUPN::PreProcessObject(
                                       IUnknown *pSource,         //in- Pointer to the source AD object
                                       IUnknown *pTarget,         //in- Pointer to the target AD object
                                       IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                       IUnknown **ppPropsToSet    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                  //         once all extension objects are executed.
                                    )
{
   IVarSetPtr                pVs = pMainSettings;
   _variant_t                var;
   _bstr_t                   sTemp;
   _bstr_t                   sUPN;
   _bstr_t                   sPref;
   _bstr_t                   sSuff;
   IADs                    * pAds = NULL;
   IADs                    * pAdsSource = NULL;
   HRESULT                   hr;
   WCHAR                     sTempUPN[7000];
   long                      ub, lb;
   _bstr_t                   sFull;
   _variant_t HUGEP        * pDt;
   _bstr_t                   sAdsPath;
   _variant_t                varDN;
   _bstr_t                   sIntraforest;
   _bstr_t                   sDomainDNS;
   _bstr_t                   sTargetOU;
   WCHAR                     fileName[MAX_PATH];
   bool						 bReplace = false;
   tstring					 sSAMName;
   tstring					 sUPNName;
   _bstr_t					 sOldUPN;
   bool						 bConflicted = false;
   SUPNStruc				 UPNStruc;

   // We need to process the user accounts only
   sTemp = pVs->get(GET_BSTR(DCTVS_CopiedAccount_Type));
   if (!sTemp.length())
	   return HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
   if (_wcsicmp((WCHAR*)sTemp,L"user")) 
	   return S_OK;

	  //store the name of this user in the UPN list
   sSAMName = _bstr_t(pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam)));

      //get the target domain DNS name
   sDomainDNS = pVs->get(GET_BSTR(DCTVS_Options_TargetDomainDns));

      //get the target OU path
   sTargetOU = pVs->get(GET_BSTR(DCTVS_Options_OuPath));

      //if not retrieved yet, get the default UPN suffix for this domain
   if (m_sUPNSuffix.length() == 0)
   {
	      //if failed, use the domain's DNS name
	   if (!GetDefaultUPNSuffix(sDomainDNS, sTargetOU))
	      m_sUPNSuffix = sDomainDNS;
   }

   // Get the Error log filename from the Varset
   wcscpy(fileName, (WCHAR*)(pVs->get(GET_BSTR(DCTVS_Options_Logfile)).bstrVal));
   // Open the error log
   err.LogOpen(fileName, 1);

   sPref = pVs->get(GET_BSTR(DCTVS_Options_Prefix));
   sSuff = pVs->get(GET_BSTR(DCTVS_Options_Suffix));
   sIntraforest = pVs->get(GET_BSTR(DCTVS_Options_IsIntraforest));
   sTemp = pVs->get(GET_BSTR(DCTVS_AccountOptions_ReplaceExistingAccounts));
   if (!UStrICmp(sTemp,GET_STRING(IDS_YES)))
	   bReplace = true;

   sAdsPath = L"";
   if ( pSource )
   {
       // Get the UPN from the source domain
       hr = pSource->QueryInterface(IID_IADs, (void**) &pAdsSource);
   }
            
   if ( pAdsSource )
   {
      if ( SUCCEEDED(hr) )
      {
          hr = pAdsSource->GetEx(L"userPrincipalName", &var);
          if (SUCCEEDED(hr) )
          {
             SAFEARRAY * pArray = V_ARRAY(&var);
             hr = SafeArrayGetLBound(pArray, 1, &lb);
             hr = SafeArrayGetUBound(pArray, 1, &ub);

             hr = SafeArrayAccessData(pArray, (void HUGEP **) &pDt);
                  
             if ( SUCCEEDED(hr) )
             {
                // translate all the UPNs to the target domain.
                for ( long x = lb; x <= ub; x++)
                {
                   wcsncpy(sTempUPN, (WCHAR*) pDt[x].bstrVal, 5000);
                   sTempUPN[4999] = 0;

                   //Get the stuff before the LAST @ sign.
                   WCHAR             * ndx = NULL;
                   WCHAR             * tempNdx = sTempUPN;
                   do
                   {
                      tempNdx = wcschr(tempNdx + 1, L'@');
                      if ( tempNdx ) 
                         ndx = tempNdx;
                   } while (tempNdx);

                   if (ndx) *ndx = L'\0';

                   if ( sPref.length() )
                      sFull = sPref + _bstr_t(sTempUPN);
                   else if ( sSuff.length() ) 
                      sFull = _bstr_t(sTempUPN) + sSuff;
                   else
                      sFull = sTempUPN;

				   sTemp = sFull;
                   sUPN = sTemp + _bstr_t(L"@");
                   sUPN = sUPN + m_sUPNSuffix;
					//store UPN name as it enters
				   sOldUPN = sUPN;
				   sUPNName = sUPN;
					//get unigue UPN on target
                   GetUniqueUPN(sUPN, pVs, false, sAdsPath);
					//see if the two UPN's differ.  If they do, then we had a conflict
//				   if ((_wcsicmp(sOldUPN, sUPN) != 0) && (!bReplace))
				   if (_wcsicmp((WCHAR*)sOldUPN, sUPN) != 0)
				   {
				      sUPNName = sUPN;
					  hr = ERROR_OBJECT_ALREADY_EXISTS;
					  bConflicted = true;
				   }
                   pDt[x] = _variant_t(sUPN);
                }
                SafeArrayUnaccessData(pArray);
             }
          }
          else
          {
             sTemp = pVs->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
             sUPN = sTemp + _bstr_t(L"@");
             sUPN = sUPN + m_sUPNSuffix;
		    	//store UPN name as it enters
	         sOldUPN = sUPN;
		     sUPNName = sUPN;
				//get unigue UPN on target
             GetUniqueUPN(sUPN, pVs, true, sAdsPath);
				//see if the two UPN's differ.  If they do, then we had a conflict
//			 if ((_wcsicmp(sOldUPN, sUPN) != 0) && (!bReplace))
			 if (_wcsicmp((WCHAR*)sOldUPN, sUPN) != 0)
			 {
				sUPNName = sUPN;
				hr = ERROR_OBJECT_ALREADY_EXISTS;
				bConflicted = true;
			 }
          }
      }
   }
   else
   {
      sTemp = pVs->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
      sUPN = sTemp + _bstr_t(L"@");
      sUPN = sUPN + m_sUPNSuffix;
    	//store UPN name as it enters
	  sOldUPN = sUPN;
	  sUPNName = sUPN;
		//get unigue UPN on target
      GetUniqueUPN(sUPN, pVs, true, sAdsPath);
		//see if the two UPN's differ.  If they do, then we had a conflict
//	  if ((_wcsicmp(sOldUPN, sUPN) != 0) && (!bReplace))
	  if (_wcsicmp((WCHAR*)sOldUPN, sUPN) != 0)
	  {
	      sUPNName = sUPN;
		  hr = ERROR_OBJECT_ALREADY_EXISTS;
		  bConflicted = true;
	  }
   }

   if ( pAds ) pAds->Release();
   if (pAdsSource) pAdsSource->Release();

   UPNStruc.sName = sUPNName;
   UPNStruc.sOldName = sOldUPN;
   UPNStruc.bConflicted = bConflicted;
     //insert UPN into Map
   mUPNMap.insert(CUPNMap::value_type(sSAMName, UPNStruc));

   return hr;
}

//---------------------------------------------------------------------------
// ProcessObject : This method updates the UPN property of the object. It 
//                 first sees if a E-Mail is specified then it will set UPN
//                 to that otherwise it builds it from SAMAccountName and the
//                 Domain name
//---------------------------------------------------------------------------
STDMETHODIMP CUpdtUPN::ProcessObject(
                                       IUnknown *pSource,         //in- Pointer to the source AD object
                                       IUnknown *pTarget,         //in- Pointer to the target AD object
                                       IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                       IUnknown **ppPropsToSet    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                  //         once all extension objects are executed.
                                    )
{
   IVarSetPtr                pVs = pMainSettings;
   _bstr_t                   sTemp;
   IADs                    * pAds = NULL;
   _variant_t                var;
   HRESULT                   hr;
   WCHAR                     fileName[MAX_PATH];
   CUPNMap::iterator		 itUPNMap;
   tstring					 sSam;
   SUPNStruc				 UPNStruc;
   bool						 bReplace = false;
   _bstr_t					 sOldUPNSuffix;

   // We need to process the user accounts only
   sTemp = pVs->get(GET_BSTR(DCTVS_CopiedAccount_Type));
   if ( _wcsicmp((WCHAR*)sTemp,L"user") ) return S_OK;

   sTemp = pVs->get(GET_BSTR(DCTVS_AccountOptions_ReplaceExistingAccounts));
   if (!UStrICmp(sTemp,GET_STRING(IDS_YES)))
	   bReplace = true;

      //get the target SAM name
   sSam = _bstr_t(pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam)));

   // Get the Error log filename from the Varset
   wcscpy(fileName, (WCHAR*)(pVs->get(GET_BSTR(DCTVS_Options_Logfile)).bstrVal));
   // Open the error log
   err.LogOpen(fileName, 1);

   // And only need to process the accounts copied to Win2k domain.
   if ( pTarget )
   {
      //Get the IADs pointer to manipulate properties
      hr = pTarget->QueryInterface(IID_IADs, (void**) &pAds);

      if (SUCCEEDED(hr))
      {
			//get the UPN name for this user from the list
		 itUPNMap = mUPNMap.find(sSam);
		 if (itUPNMap != mUPNMap.end())
		    UPNStruc = itUPNMap->second;

         if (!UPNStruc.sName.empty())
		 {
			bool bSame = false;
			   //if replace mode, don't set UPN if same object we are replacing and
			   //if not the same object, get it's current UPN Suffix
			if (bReplace)
			{
               hr = pAds->Get(L"userPrincipalName", &var);
               if (SUCCEEDED(hr))
			   {
				     //if replacing the object whose UPN conflicted, don't change it
			      if (!UPNStruc.sOldName.compare(var.bstrVal))
			         bSame = true;
				  else //else, get the object's current UPN suffix for re-use
				     sOldUPNSuffix = GetUPNSuffix(var.bstrVal);
			   }
			}

			if (!bSame)
			{
			   var = UPNStruc.sName.c_str();
			      //if replacing an existing object, use it's old UPN suffix
			   if ((bReplace) && (sOldUPNSuffix.length() != 0))
			   {
				     //change the suffix on the old name, since it may longer conflict
			      _bstr_t sUPN = ChangeUPNSuffix(UPNStruc.sOldName.c_str(), sOldUPNSuffix);
				     //if changed, make sure we don't still have a UPN conflict and save the 
				     //new UPN for setting
				  if (sUPN.length() != 0)
				  {
					 _bstr_t sTempUPN = sUPN;
		                //get unigue UPN on target, now that we could conflict
                     GetUniqueUPN(sUPN, pVs, true, _bstr_t(L""));
					    //if changed, set conflicted flag and names for error message
					 if (sUPN != sTempUPN)
					 {
                        UPNStruc.sName = sUPN;
                        UPNStruc.sOldName = sTempUPN;
                        UPNStruc.bConflicted = true;
					 }
					 else
                        UPNStruc.bConflicted = false;

				     var = sUPN;
				  }
			   }
               hr = pAds->Put(L"userPrincipalName", var);
               if (SUCCEEDED(hr))
			   {
                  hr = pAds->SetInfo();
                  if (SUCCEEDED(hr))
				  {
                        // If we changed the UPN Name due to conflict, we need to log a 
			            //message indicating the fact that we changed it.
			         if (UPNStruc.bConflicted)
                        err.MsgWrite(1, DCT_MSG_CREATE_FAILED_UPN_CONF_SS, 
			                         UPNStruc.sOldName.c_str(), UPNStruc.sName.c_str());
				  }
			   }
			}
		 }
      }
   }
   if ( pAds ) pAds->Release();
   return hr;
}

//---------------------------------------------------------------------------
// ProcessUndo : We are not going to undo this.
//---------------------------------------------------------------------------
STDMETHODIMP CUpdtUPN::ProcessUndo(                                             
                                       IUnknown *pSource,         //in- Pointer to the source AD object
                                       IUnknown *pTarget,         //in- Pointer to the target AD object
                                       IUnknown *pMainSettings,   //in- Varset filled with the settings supplied by user
                                       IUnknown **ppPropsToSet    //in,out - Varset filled with Prop-Value pairs that will be set 
                                                                  //         once all extension objects are executed.
                                    )
{
   IVarSetPtr                pVs = pMainSettings;
   _bstr_t                   sTemp, sSUPN;
   IADs                    * pAds = NULL;
   _variant_t                var;
   HRESULT                   hr = S_OK;
   _bstr_t                   sAdsPath = L"";
   _bstr_t                   sTempUPN;

   // We need to process the user accounts only
   sTemp = pVs->get(GET_BSTR(DCTVS_CopiedAccount_Type));
   if ( _wcsicmp((WCHAR*)sTemp,L"user") ) return S_OK;

	// get the original source account's UPN
   sSUPN = pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceUPN));
   if (sSUPN.length())
   {
      sTempUPN = sSUPN;
      GetUniqueUPN(sTempUPN, pVs, true, sAdsPath);
      
	  int len;
	  WCHAR * ndx, * tempNdx = (WCHAR*)sTempUPN;
      do
      {
         tempNdx = wcschr(tempNdx + 1, L'@');
         if ( tempNdx ) 
            ndx = tempNdx;
      } while (tempNdx);

      if (ndx) len = ndx - sTempUPN;
	  if (_wcsnicmp(sTempUPN, sSUPN, len) != 0)
		  return S_OK;
	    // And only need to process the accounts copied to Win2k domain.
	  if ( pTarget )
	  {
         //Get the IADs pointer to manipulate properties
         hr = pTarget->QueryInterface(IID_IADs, (void**) &pAds);

         if ( SUCCEEDED(hr) )
		 {
            var = sSUPN;
            hr = pAds->Put(L"userPrincipalName", var);
			hr = pAds->SetInfo();
		 }
	  }
      if ( pAds ) pAds->Release();
   }

   return S_OK;
}

//---------------------------------------------------------------------------
// GetUniqueUPN : This function checks if the UPN is unique if not then 
//                appends a number starting with 0 and retries till a unique 
//                UPN is found.
//---------------------------------------------------------------------------
void CUpdtUPN::GetUniqueUPN(_bstr_t &sUPN, IVarSetPtr pVs, bool bUsingSamName, _bstr_t sAdsPath)
{
   // Here are the steps that we follow to get the unique UPN name
   // 1. Check if the current name is unique. If it is then return that.
   // 2. Append collision prefix and suffix if the sam account name has changed due to pref/suffix.
   // 3. Add a numeric suffix to the UPN and repeat till a unique UPN is found.
   
   // If the user tells us not to do this then we simply return the current UPN name.
   _bstr_t sProcess = pVs->get(GET_BSTR(DCTVS_Options_AllowDuplicateUPNs));
   if ( sProcess == GET_BSTR(IDS_YES) ) return;

   WCHAR                     sTempUPN[5000];
//   long                      x = 0;
   WCHAR                     sQuery[5000], sPath[5000];
   HRESULT                   hr = E_FAIL;
//   LPWSTR                    pCols[] = { L"distinguishedName" };
   LPWSTR                    pCols[] = { L"sAMAccountName" };
   BSTR                    * pData = NULL;
   SAFEARRAY               * pSaCols = NULL;
   SAFEARRAYBOUND            bd = { 1, 0 };
   _bstr_t                   sTgtDomain = pVs->get(GET_BSTR(DCTVS_Options_TargetDomainDns));
   INetObjEnumeratorPtr      pQuery(__uuidof(NetObjEnumerator));
   IEnumVARIANT            * pEnum = NULL;
   DWORD                     fetched = 0;
   _variant_t                var;
   bool                      bCollPrefSufProcessed = false;
   _bstr_t                   sSourceSam = pVs->get(GET_BSTR(DCTVS_CopiedAccount_SourceSam));
   _bstr_t                   sTargetSam = pVs->get(GET_BSTR(DCTVS_CopiedAccount_TargetSam));
   _bstr_t                   sPrefix = pVs->get(GET_BSTR(DCTVS_AccountOptions_Prefix));
   _bstr_t                   sSuffix = pVs->get(GET_BSTR(DCTVS_AccountOptions_Suffix));
   _bstr_t                   sPref = pVs->get(GET_BSTR(DCTVS_Options_Prefix));
   _bstr_t                   sSuff = pVs->get(GET_BSTR(DCTVS_Options_Suffix));
   int                       offset = 0;
   WCHAR                     sTemp[5000];
   SAFEARRAY               * psaPath = NULL;
   _variant_t                varPath;
   _variant_t              * pVar;
   bool						 bReplace = false;
   WCHAR					 sTempSAM[MAX_PATH];
   _bstr_t					 sNewSAM;
   _bstr_t					 sUPNSuffix;
   _bstr_t					 sUPNPrefix;

   _bstr_t sReplace = pVs->get(GET_BSTR(DCTVS_AccountOptions_ReplaceExistingAccounts));
   if (!UStrICmp(sReplace,GET_STRING(IDS_YES)))
	   bReplace = true;

   wcscpy(sTempSAM, (WCHAR*)sSourceSam);
   StripSamName(sTempSAM);
   if ( sPref.length() )
      sNewSAM = sPref + _bstr_t(sTempSAM);
   else if ( sSuff.length() ) 
      sNewSAM = _bstr_t(sTempSAM) + sSuff;
   else
      sNewSAM = sTempSAM;
   
   wcscpy(sTempUPN, (WCHAR*) sUPN);

   //Get the stuff before the LAST @ sign.
   WCHAR             * ndx = NULL;
   WCHAR             * tempNdx = sTempUPN;
   do
   {
      tempNdx = wcschr(tempNdx + 1, L'@');
      if ( tempNdx ) 
         ndx = tempNdx;
   } while (tempNdx);

   if (ndx) *ndx = L'\0';
   
   sUPNSuffix = ndx+1;
   sUPNPrefix = sTempUPN;

   // Setup the path name to the domain. 
   wsprintf(sPath, L"LDAP://%s", (WCHAR*)sTgtDomain);

   // setup the columns that we want the query to return to us.
   pSaCols = SafeArrayCreate(VT_BSTR, 1, &bd);
   if (pSaCols)
   {
      hr = SafeArrayAccessData(pSaCols, (void HUGEP **) &pData);
      if ( SUCCEEDED(hr) )
      {
         pData[0] = SysAllocString(pCols[0]);
      }
      hr = SafeArrayUnaccessData(pSaCols);
   }

   if ( SUCCEEDED(hr) )
   {
      // First we need to set up a query to find the UPN
      wcscpy(sTempUPN, (WCHAR*)sUPN);
      do
      {
         wsprintf(sQuery, L"(userPrincipalName=%s)", sTempUPN);
         hr = pQuery->raw_SetQuery(sPath, sTgtDomain, sQuery, ADS_SCOPE_SUBTREE, FALSE);
         
         if ( SUCCEEDED(hr) )
            hr = pQuery->raw_SetColumns(pSaCols);

         if ( SUCCEEDED(hr) ) 
            hr = pQuery->raw_Execute(&pEnum);

         if ( SUCCEEDED(hr) )
         {
            hr = pEnum->Next(1, &var, &fetched);
            while ( hr == S_OK )
            {
               if ( var.vt & VT_ARRAY )
               {
                  psaPath = var.parray;
                  hr = SafeArrayAccessData(psaPath, (void HUGEP**) &pVar);
                  if ( SUCCEEDED(hr) )
                  {
                     varPath = pVar[0];
                  }
                  SafeArrayUnaccessData(psaPath);
                  //SafeArrayGetElement(psaPath, &x, (void*)&varPath);
                  if ( !wcslen((WCHAR*) varPath.bstrVal) )
                  {
                     hr = S_FALSE;
                  }

                  if ((!_wcsicmp((WCHAR*)varPath.bstrVal, (WCHAR*)sNewSAM)) && (bReplace))
                  {
                     // If the account found is the same as the account being processed then we
                     // need to see if any other accounts have this UPN. if they do then we need
                     // to change it other wise we do not need to process this any further.
                     hr = pEnum->Next(1, &var, &fetched);
                     continue;
                  }
                  else
                     break;
               }
            }
            
            if ( hr == S_OK )
            {
               // If we are here that means we have a collision So we need to update the UPN and try again
               // See if we have processed the Prefix/Suffix
               if ( !bCollPrefSufProcessed )
               {
                  // See if we renamed the samAccountName with the prefix/suffix. If we are already using 
                  // sam name then there is no need to add the prefix/suffix.
                  if ( !bUsingSamName && RenamedWithPrefixSuffix(sSourceSam, sTargetSam, sPrefix, sSuffix))
                  {
                     // Since we renamed the sam names we can rename the UPN
                     if ( sPrefix.length() )
                        wsprintf(sTempUPN, L"%s%s", (WCHAR*)sPrefix, (WCHAR*)sUPNPrefix);

                     if ( sSuffix.length() )
                        wsprintf(sTempUPN, L"%s%s",(WCHAR*)sUPNPrefix, (WCHAR*)sSuffix);

                     sUPNPrefix = sTempUPN;   // we want to apply the prefix/suffix in any case.
                  }
                  else
                  {
                     // just add a number to the end of the name.
                     wsprintf(sTempUPN, L"%s%d", (WCHAR*)sUPNPrefix, offset);
                     offset++;
                  }
                  bCollPrefSufProcessed = true;
               }
               else
               {
                  // we went through prefix/suffix and still found a collision so we need to go by the count now.
                  wsprintf(sTempUPN, L"%s%d", (WCHAR*)sUPNPrefix, offset);
                  offset++;
               }
               wcscpy(sTemp, sTempUPN);
               wsprintf(sTempUPN, L"%s@%s", sTemp, (WCHAR*)sUPNSuffix);
            }
            VariantInit(&var);
            if ( pEnum ) pEnum->Release();
         }
      } while ( hr == S_OK );
      SafeArrayDestroy(pSaCols);
   }
   sUPN = sTempUPN;
}

//---------------------------------------------------------------------------
// RenamedWithPrefixSuffix : Checks to see if the Target sam name 
//                           was renamed with a prefix/suffix.
//---------------------------------------------------------------------------
bool CUpdtUPN::RenamedWithPrefixSuffix(_bstr_t sSourceSam, _bstr_t sTargetSam, _bstr_t sPrefix, _bstr_t sSuffix)
{
   bool retVal = false;
   if ( sSourceSam != sTargetSam )
   {
      if ( sPrefix.length() )
      {
         if ( !wcsncmp((WCHAR*) sTargetSam, (WCHAR*) sPrefix, sPrefix.length()) )
            retVal = true;
      }

      if ( sSuffix.length() )
      {
         if ( !wcscmp((WCHAR*) sTargetSam + (sTargetSam.length() - sSuffix.length()), (WCHAR*) sSuffix ) )
            retVal = true;
      }
   }
   return retVal;
}


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 24 MAR 2001                                                 *
 *                                                                   *
 *     This function is responsible for retrieving the default UPN   *
 * suffix to be used in making UPN names.  The suffix will be stored *
 * in a class member variable.                                       *
 *     First, using the given target OU path, see if the target OU   *
 * has any UPN suffixes defined for it.  If so, return store the     *
 * last one enumerated.  Otherwise, see if any UPN suffixes have     *
 * been defined on the configuration's partition.  If so, store the  *
 * last one enumerated.  If no success yet, use the forest root's    *
 * domain DNS name.                                                  *
 *                                                                   *
 *********************************************************************/

//BEGIN GetDefaultUPNSuffix
bool CUpdtUPN::GetDefaultUPNSuffix(_bstr_t sDomainDNS, _bstr_t sTargetOU)
{
/* local variables */
   IADs					* pDSE = NULL;
   IADs					* pCont = NULL;
   WCHAR				  sRoot[1000];
   HRESULT				  hr = S_OK;
   _variant_t			  var;
   _variant_t   HUGEP   * pVar;
   int					  nLast;

/* function body */
      //check incoming parameters
   if ((sDomainDNS.length() == 0) || (sTargetOU.length() == 0))
	  return false;

  /* first see if the target OU has UPN suffixes defined */
     //get a pointer to the target OU
  hr = ADsGetObject(sTargetOU,IID_IADs,(void**)&pCont);
  if ( SUCCEEDED(hr) )
  {
	    //get any UPN suffixes defined
     hr = pCont->Get( L"uPNSuffixes", &var);
     if ( SUCCEEDED(hr) ) 
	 {
	    //if one, store it and return
        if ( var.vt == VT_BSTR )
		{
           m_sUPNSuffix = var.bstrVal;  //store the suffix
		   pCont->Release();
		   return true;
		}
		   //else if nore than one, get the first one, store it, and return
		else if ( var.vt & VT_ARRAY )
		{
           SAFEARRAY * multiVals = var.parray; 
           SafeArrayAccessData(multiVals, (void HUGEP **) &pVar);
		   nLast = multiVals->rgsabound->cElements - 1;
		   m_sUPNSuffix = _bstr_t(V_BSTR(&pVar[nLast]));
           SafeArrayUnaccessData(multiVals);
		   pCont->Release();
		   return true;
		}
	 }//end if suffixes defined on the partition
	 pCont->Release();
     pCont = NULL;
  }//if got partition

  /* next try the UPN suffixes on the partition container or the root
     domain's DNS name */
     //get the root DSE container
  wcscpy(sRoot,L"LDAP://RootDSE");
  hr = ADsGetObject(sRoot,IID_IADs,(void**)&pDSE);
  if ( SUCCEEDED(hr) )
  {
        //get the suffixes listed on the configuration partition
     hr = pDSE->Get(L"configurationNamingContext",&var);
     if ( SUCCEEDED(hr) )
     {
        swprintf(sRoot,L"LDAP://%ls/CN=Partitions,%ls", (WCHAR*)sDomainDNS, var.bstrVal);
        hr = ADsGetObject(sRoot,IID_IADs,(void**)&pCont);
        if ( SUCCEEDED(hr) )
        {
	          //get any UPN suffixes defined
           hr = pCont->Get( L"uPNSuffixes", &var);
           if ( SUCCEEDED(hr) ) 
		   {
			     //if one, store it and return
              if ( var.vt == VT_BSTR )
			  {
                 m_sUPNSuffix = var.bstrVal;  //store the suffix
				 pDSE->Release();
				 pCont->Release();
				 return true;
			  }
			     //else if nore than one, get the first one, store it, and return
		      else if ( var.vt & VT_ARRAY )
			  {
                 SAFEARRAY * multiVals = var.parray; 
                 SafeArrayAccessData(multiVals, (void HUGEP **) &pVar);
		         nLast = multiVals->rgsabound->cElements - 1;
		         m_sUPNSuffix = _bstr_t(V_BSTR(&pVar[nLast]));
                 SafeArrayUnaccessData(multiVals);
			     pDSE->Release();
			     pCont->Release();
				 return true;
			  }
		   }//end if suffixes defined on the partition
	       pCont->Release();
           pCont = NULL;
		}//if got partition
	 }//if got config naming context

	 //since no UPN suffixes defined on the partition, try the root domain's
	 //DNS name
     hr = pDSE->Get(L"RootDomainNamingContext",&var);
     if ( SUCCEEDED(hr) )
     {
           //convert the DN of the root domain to a DNS name, store it, and return
        m_sUPNSuffix = GetDomainDNSFromPath(_bstr_t(var.bstrVal));
	    pDSE->Release();
		return true;
	 }
	 pDSE->Release();
     pDSE = NULL;
  }//if got rootDSE
  return false;
}
//END GetDefaultUPNSuffix


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 26 MAR 2001                                                 *
 *                                                                   *
 *     This function is responsible for extracting the UPN Suffix    *
 * from a given UPN name and returning that suffix.                  *
 *                                                                   *
 *********************************************************************/

//BEGIN GetUPNSuffix
_bstr_t CUpdtUPN::GetUPNSuffix(_bstr_t sUPNName)
{
/* local variables */
   _bstr_t		sUPNSuffix = L"";
   WCHAR *		pTemp;

/* function body */
      //check incoming parameters
   if (sUPNName.length() == 0)
	  return sUPNSuffix;

      //find the last '@'
   pTemp = wcsrchr((WCHAR*)sUPNName, L'@');

      //if found, copy the suffix to the return variable
   if (pTemp)
      sUPNSuffix = pTemp+1;

   return sUPNSuffix;
}
//END GetUPNSuffix


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 26 MAR 2001                                                 *
 *                                                                   *
 *     This function is responsible for replacing the UPN Suffix     *
 * on a given UPN name with the given suffix and returning the new   *
 * UPN name.                                                         *
 *                                                                   *
 *********************************************************************/

//BEGIN ChangeUPNSuffix
_bstr_t CUpdtUPN::ChangeUPNSuffix(_bstr_t sUPNName, _bstr_t sNewSuffix)
{
/* local variables */
   _bstr_t		sNewUPN = L"";
   WCHAR *		pTemp;

/* function body */
      //check incoming parameters
   if (sUPNName.length() == 0)
	  return sNewUPN;

      //create a temporary buffer to hold the UPN Name
   WCHAR* sUPN = new WCHAR[sUPNName.length() + 1];
   if (!sUPN)
	  return sNewUPN;

      //copy the UPN to this buffer
   wcscpy(sUPN, sUPNName);

      //find the last '@'
   pTemp = wcsrchr(sUPN, L'@');

      //if found, make the new UPN with the old Prefix and given suffix
   if (pTemp)
   {
	    //end the string after the '@'
	  *(pTemp+1) = L'\0';

	    //copy the Prefix plus the new Suffix to the new UPN name
	  sNewUPN = sUPN + sNewSuffix;
   }
      //delete the prefix string
   delete [] sUPN;

   return sNewUPN;
}
//END ChangeUPNSuffix
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\upnupdt\upnupdt.cpp ===
// UPNUpdt.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f UPNUpdtps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "UPNUpdt.h"

#include "UPNUpdt_i.c"
#include "UpdtUPN.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_UpdtUPN, CUpdtUPN)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_UPNUPDTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\arext\upnupdt\updtupn.h ===
//---------------------------------------------------------------------------
// UPDTUPN.h
//
// Comment: This is a COM object extension for the MCS DCTAccountReplicator.
//          This object implements the IExtendAccountMigration interface. 
//          The process method on this object updates the userPrincipalName
//          property on the user object.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------

#ifndef __UPDTUPN_H_
#define __UPDTUPN_H_

#include "resource.h"       // main symbols
#include "ExtSeq.h"
#include <string>
#include <map>

typedef std::basic_string<WCHAR> tstring;

//#import "\bin\McsVarSetMin.tlb" no_namespace
#import "VarSet.tlb" no_namespace rename("property", "aproperty")
/////////////////////////////////////////////////////////////////////////////
// CUpdtUPN
class ATL_NO_VTABLE CUpdtUPN : 
	public CComObjectRootEx<CComSingleThreadModel>,
	public CComCoClass<CUpdtUPN, &CLSID_UpdtUPN>,
	public IDispatchImpl<IExtendAccountMigration, &IID_IExtendAccountMigration, &LIBID_UPNUPDTLib>
{
public:
	CUpdtUPN()
	{
      m_sName = L"UpnUpdate";
      m_sDesc = L"";
      m_sUPNSuffix = L"";
      m_Sequence = AREXT_DEFAULT_SEQUENCE_NUMBER;
	}

    ~CUpdtUPN()
	{
      mUPNMap.clear();
	}

DECLARE_REGISTRY_RESOURCEID(IDR_UPDTUPN)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CUpdtUPN)
	COM_INTERFACE_ENTRY(IExtendAccountMigration)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IExtendAccountMigration
public:
   STDMETHOD(ProcessUndo)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in, out]*/ IUnknown ** pPropToSet);
	STDMETHOD(PreProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet);
	STDMETHOD(ProcessObject)(/*[in]*/ IUnknown * pSource, /*[in]*/ IUnknown * pTarget, /*[in]*/ IUnknown * pMainSettings, /*[in,out]*/  IUnknown ** ppPropsToSet);
	STDMETHOD(get_sDesc)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sDesc)(/*[in]*/ BSTR newVal);
	STDMETHOD(get_sName)(/*[out, retval]*/ BSTR *pVal);
	STDMETHOD(put_sName)(/*[in]*/ BSTR newVal);
    STDMETHOD(get_SequenceNumber)(/*[out, retval]*/ LONG * value) { (*value) = m_Sequence; return S_OK; }
private:
	   //define a structure to hold the UPN name and whether it conflicted in the map below
	struct SUPNStruc {
	   SUPNStruc() :
		   bConflicted(false)
	   {
	   }
	   SUPNStruc(const SUPNStruc& UPNData)
	   {
		   bConflicted = UPNData.bConflicted;
		   sName = UPNData.sName;
		   sOldName = UPNData.sOldName;
	   }
	   SUPNStruc& operator =(const SUPNStruc& UPNData)
	   {
		   bConflicted = UPNData.bConflicted;
		   sName = UPNData.sName;
		   sOldName = UPNData.sOldName;
		   return *this;
	   }

	   bool bConflicted;
	   tstring sName;
	   tstring sOldName;
	};

	typedef std::map<tstring,SUPNStruc> CUPNMap;
	CUPNMap mUPNMap;

    bool RenamedWithPrefixSuffix(_bstr_t sSourceSam, _bstr_t sTargetSam, _bstr_t sPrefix, _bstr_t sSuffix);
	void GetUniqueUPN(_bstr_t& sUPN, IVarSetPtr pVs, bool bUsingSamName, _bstr_t sAdsPath);
    bool GetDefaultUPNSuffix(_bstr_t sDomainDNS, _bstr_t sTargetOU);
	_bstr_t GetUPNSuffix(_bstr_t sUPNName);
	_bstr_t ChangeUPNSuffix(_bstr_t sUPNName, _bstr_t sNewSuffix);
	_bstr_t m_sDesc;
	_bstr_t m_sName;
	_bstr_t	m_sUPNSuffix;
    long    m_Sequence;
};

#endif //__UPDTUPN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\command\argument.h ===
#pragma once


//---------------------------------------------------------------------------
// Arguments Class
//---------------------------------------------------------------------------


class CArguments
{
public:

	CArguments(int argc, wchar_t* argv[]) :
		m_iArg(1),
		m_cArg(argc),
		m_ppszArg(argv)
	{
	}

	LPCTSTR Value()
	{
		LPCTSTR pszArg = NULL;

		if ((m_iArg > 0) && (m_iArg < m_cArg))
		{
			pszArg = m_ppszArg[m_iArg];
		}

		return pszArg;
	}

	bool Next()
	{
		if (m_iArg < m_cArg)
		{
			++m_iArg;
		}

		return (m_iArg < m_cArg);
	}

	bool Prev()
	{
		if (m_iArg > 0)
		{
			--m_iArg;
		}

		return (m_iArg > 0);
	}

protected:

	CArguments(const CArguments& r) {}
	CArguments& operator =(const CArguments& r) { return *this; }

protected:

	int m_iArg;
	int m_cArg;
	_TCHAR** m_ppszArg;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\command\admtcommand.cpp ===
#include "StdAfx.h"
#include "Argument.h"
#include "Parameter.h"
#include "Migration.h"
#include "Switch.h"
#include "MonitorThread.h"
#include "GenerateKey.h"


namespace PrintUsage
{

void __stdcall PrintADMTUsage();
void __stdcall PrintUserUsage();
void __stdcall PrintGroupUsage();
void __stdcall PrintComputerUsage();
void __stdcall PrintSecurityUsage();
void __stdcall PrintServiceUsage();
void __stdcall PrintReportUsage();
void __stdcall PrintKeyUsage();
void __stdcall PrintUsage(UINT uId[], UINT cId);
void __stdcall GetString(UINT uId, LPTSTR pszBuffer, int cchBuffer);

}

using namespace PrintUsage;


//---------------------------------------------------------------------------
// Main
//---------------------------------------------------------------------------


int __cdecl _tmain(int argc, LPTSTR argv[])
{
	HRESULT hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);

	if (SUCCEEDED(hr))
	{
		_RPT0(_CRT_WARN, _T("{ADMT.exe}_tmain() : Enter\n"));
		_CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|_CRTDBG_LEAK_CHECK_DF);

		CMonitorThread mtMonitor;

		try
		{
			CArguments aArgs(argc, argv);
			CParameterMap mapParams(aArgs);

			long lTask;

			if (mapParams.GetValue(SWITCH_TASK, lTask))
			{
				bool bHelp;

				if (!mapParams.GetValue(SWITCH_HELP, bHelp))
				{
					bHelp = false;
				}

				switch (lTask)
				{
					case TASK_USER:
					{
						if (bHelp)
						{
							PrintUserUsage();
						}
						else
						{
							mtMonitor.Start();
							CUserMigration(CMigration(mapParams), mapParams);
							mtMonitor.Stop();
						}
						break;
					}
					case TASK_GROUP:
					{
						if (bHelp)
						{
							PrintGroupUsage();
						}
						else
						{
							mtMonitor.Start();
							CGroupMigration(CMigration(mapParams), mapParams);
							mtMonitor.Stop();
						}
						break;
					}
					case TASK_COMPUTER:
					{
						if (bHelp)
						{
							PrintComputerUsage();
						}
						else
						{
							mtMonitor.Start();
							CComputerMigration(CMigration(mapParams), mapParams);
							mtMonitor.Stop();
						}
						break;
					}
					case TASK_SECURITY:
					{
						if (bHelp)
						{
							PrintSecurityUsage();
						}
						else
						{
							mtMonitor.Start();
							CSecurityTranslation(CMigration(mapParams), mapParams);
							mtMonitor.Stop();
						}
						break;
					}
					case TASK_SERVICE:
					{
						if (bHelp)
						{
							PrintServiceUsage();
						}
						else
						{
							mtMonitor.Start();
							CServiceEnumeration(CMigration(mapParams), mapParams);
							mtMonitor.Stop();
						}
						break;
					}
					case TASK_REPORT:
					{
						if (bHelp)
						{
							PrintReportUsage();
						}
						else
						{
							mtMonitor.Start();
							CReportGeneration(CMigration(mapParams), mapParams);
							mtMonitor.Stop();
						}
						break;
					}
					case TASK_KEY:
					{
						if (bHelp)
						{
							PrintKeyUsage();
						}
						else
						{
							_bstr_t strKeyId;

							if (!mapParams.GetValue(SWITCH_KEY_IDENTIFIER, strKeyId))
							{
								ThrowError(E_INVALIDARG, IDS_E_NO_KEY_DOMAIN);
							}

							_bstr_t strDrive;

							if (!mapParams.GetValue(SWITCH_KEY_FOLDER, strDrive))
							{
								ThrowError(E_INVALIDARG, IDS_E_NO_KEY_FOLDER);
							}

							_bstr_t strPassword;

							mapParams.GetValue(SWITCH_KEY_PASSWORD, strPassword);

							GeneratePasswordKey(strKeyId, strPassword, strDrive);
						}
						break;
					}
					default:
					{
						_ASSERT(false);
						break;
					}
				}
			}
			else
			{
				PrintADMTUsage();
			}
		}
		catch (_com_error& ce)
		{
			mtMonitor.Stop();

			_com_error ceNew(ce);

			_bstr_t strDescription = ceNew.Description();

			if (!strDescription)
			{
			   IErrorInfo* pErrorInfo = NULL;

			   if (GetErrorInfo(0, &pErrorInfo) == S_OK)
			   {
				  ceNew = _com_error(ceNew.Error(), pErrorInfo);
			   }
			}

			_tprintf(_T("%s : %s (0x%08lX)\n"), (LPCTSTR)ceNew.Description(), ceNew.ErrorMessage(), ceNew.Error());
		}
		catch (...)
		{
			mtMonitor.Stop();

			_tprintf(_T("%s (0x%08lX)\n"), _com_error(E_FAIL).ErrorMessage(), E_FAIL);
		}

		_RPT0(_CRT_WARN, _T("{ADMT.exe}_tmain() : Leave\n"));

		CoUninitialize();
	}

	return 0;
}


// Print Usage --------------------------------------------------------------


namespace PrintUsage
{


void __stdcall PrintADMTUsage()
{
	static UINT s_uId[] =
	{
		IDS_USAGE_SYNTAX,
		IDS_USAGE_ADMT,
	};

	PrintUsage(s_uId, countof(s_uId));
}


void __stdcall PrintUserUsage()
{
	static UINT s_uId[] =
	{
		// user command
		IDS_USAGE_SYNTAX,
		IDS_USAGE_USER,
		// common options
		IDS_USAGE_OPTIONFILE,
		IDS_USAGE_TESTMIGRATION,
		IDS_USAGE_INTRAFOREST,
		IDS_USAGE_SOURCEDOMAIN,
		IDS_USAGE_SOURCEOU,
		IDS_USAGE_TARGETDOMAIN,
		IDS_USAGE_TARGETOU,
		// user migration options
		IDS_USAGE_PASSWORDOPTION,
		IDS_USAGE_PASSWORDSERVER,
		IDS_USAGE_PASSWORDFILE,
		IDS_USAGE_DISABLEOPTION,
		IDS_USAGE_SOURCEEXPIRATION,
		IDS_USAGE_MIGRATESIDS,
		IDS_USAGE_TRANSLATEROAMINGPROFILE,
		IDS_USAGE_UPDATEUSERRIGHTS,
		IDS_USAGE_MIGRATEGROUPS,
		IDS_USAGE_UPDATEPREVIOUSLYMIGRATEDOBJECTS,
		IDS_USAGE_FIXGROUPMEMBERSHIP,
		IDS_USAGE_MIGRATESERVICEACCOUNTS,
		IDS_USAGE_RENAMEOPTION,
		IDS_USAGE_RENAMEPREFIXORSUFFIX,
		IDS_USAGE_CONFLICTOPTIONS_U,
		IDS_USAGE_CONFLICTPREFIXORSUFFIX,
		IDS_USAGE_USERPROPERTIESTOEXCLUDE,
		// users to migrate
		IDS_USAGE_INCLUDE_A,
		IDS_USAGE_EXCLUDE,
		IDS_USAGE_FOOTER,
	};

	PrintUsage(s_uId, countof(s_uId));
}


void __stdcall PrintGroupUsage()
{
	static UINT s_uId[] =
	{
		// group command
		IDS_USAGE_SYNTAX,
		IDS_USAGE_GROUP,
		// common options
		IDS_USAGE_OPTIONFILE,
		IDS_USAGE_TESTMIGRATION,
		IDS_USAGE_INTRAFOREST,
		IDS_USAGE_SOURCEDOMAIN,
		IDS_USAGE_SOURCEOU,
		IDS_USAGE_TARGETDOMAIN,
		IDS_USAGE_TARGETOU,
		// group migration options
		IDS_USAGE_UPDATEGROUPRIGHTS,
		IDS_USAGE_FIXGROUPMEMBERSHIP,
		IDS_USAGE_MIGRATESIDS,
		IDS_USAGE_RENAMEOPTION,
		IDS_USAGE_RENAMEPREFIXORSUFFIX,
		IDS_USAGE_CONFLICTOPTIONS_G,
		IDS_USAGE_CONFLICTPREFIXORSUFFIX,
		IDS_USAGE_GROUPPROPERTIESTOEXCLUDE,
		// member migration options
		IDS_USAGE_MIGRATEMEMBERS,
		IDS_USAGE_UPDATEPREVIOUSLYMIGRATEDOBJECTS,
		IDS_USAGE_PASSWORDOPTION,
		IDS_USAGE_PASSWORDSERVER,
		IDS_USAGE_PASSWORDFILE,
		IDS_USAGE_DISABLEOPTION,
		IDS_USAGE_SOURCEEXPIRATION,
		IDS_USAGE_TRANSLATEROAMINGPROFILE,
		// groups to migrate
		IDS_USAGE_INCLUDE_A,
		IDS_USAGE_EXCLUDE,
		IDS_USAGE_FOOTER,
	};

	PrintUsage(s_uId, countof(s_uId));
}


void __stdcall PrintComputerUsage()
{
	static UINT s_uId[] =
	{
		// computer command
		IDS_USAGE_SYNTAX,
		IDS_USAGE_COMPUTER,
		// common options
		IDS_USAGE_OPTIONFILE,
		IDS_USAGE_TESTMIGRATION,
		IDS_USAGE_INTRAFOREST,
		IDS_USAGE_SOURCEDOMAIN,
		IDS_USAGE_SOURCEOU,
		IDS_USAGE_TARGETDOMAIN,
		IDS_USAGE_TARGETOU,
		// computer migration options
		IDS_USAGE_TRANSLATIONOPTION,
		IDS_USAGE_TRANSLATEFILESANDFOLDERS,
		IDS_USAGE_TRANSLATELOCALGROUPS,
		IDS_USAGE_TRANSLATEPRINTERS,
		IDS_USAGE_TRANSLATEREGISTRY,
		IDS_USAGE_TRANSLATESHARES,
		IDS_USAGE_TRANSLATEUSERPROFILES,
		IDS_USAGE_TRANSLATEUSERRIGHTS,
		IDS_USAGE_RENAMEOPTION,
		IDS_USAGE_RENAMEPREFIXORSUFFIX,
		IDS_USAGE_CONFLICTOPTIONS_C,
		IDS_USAGE_CONFLICTPREFIXORSUFFIX,
		IDS_USAGE_RESTARTDELAY,
		IDS_USAGE_COMPUTERPROPERTIESTOEXCLUDE,
		// computers to migrate
		IDS_USAGE_INCLUDE_A,
		IDS_USAGE_EXCLUDE,
		IDS_USAGE_FOOTER,
	};

	PrintUsage(s_uId, countof(s_uId));
}


void __stdcall PrintSecurityUsage()
{
	static UINT s_uId[] =
	{
		// security command
		IDS_USAGE_SYNTAX,
		IDS_USAGE_SECURITY,
		// common options
		IDS_USAGE_OPTIONFILE,
		IDS_USAGE_TESTMIGRATION,
		IDS_USAGE_SOURCEDOMAIN,
		IDS_USAGE_SOURCEOU,
		IDS_USAGE_TARGETDOMAIN,
		// security migration options
		IDS_USAGE_TRANSLATIONOPTION,
		IDS_USAGE_TRANSLATEFILESANDFOLDERS,
		IDS_USAGE_TRANSLATELOCALGROUPS,
		IDS_USAGE_TRANSLATEPRINTERS,
		IDS_USAGE_TRANSLATEREGISTRY,
		IDS_USAGE_TRANSLATESHARES,
		IDS_USAGE_TRANSLATEUSERPROFILES,
		IDS_USAGE_TRANSLATEUSERRIGHTS,
		IDS_USAGE_SIDMAPPINGFILE,
		// computers to perform security translation on
		IDS_USAGE_INCLUDE_C,
		IDS_USAGE_EXCLUDE,
		IDS_USAGE_FOOTER,
	};

	PrintUsage(s_uId, countof(s_uId));
}


void __stdcall PrintServiceUsage()
{
	static UINT s_uId[] =
	{
		// security command
		IDS_USAGE_SYNTAX,
		IDS_USAGE_SERVICE,
		// common options
		IDS_USAGE_OPTIONFILE,
		IDS_USAGE_SOURCEDOMAIN,
		IDS_USAGE_SOURCEOU,
		// computers to perform security translation on
		IDS_USAGE_INCLUDE_C,
		IDS_USAGE_EXCLUDE,
		IDS_USAGE_FOOTER,
	};

	PrintUsage(s_uId, countof(s_uId));
}


void __stdcall PrintReportUsage()
{
	static UINT s_uId[] =
	{
		// report command
		IDS_USAGE_SYNTAX,
		IDS_USAGE_REPORT,
		// common options
		IDS_USAGE_OPTIONFILE,
		IDS_USAGE_SOURCEDOMAIN,
		IDS_USAGE_SOURCEOU,
		IDS_USAGE_TARGETDOMAIN,
		// report options
		IDS_USAGE_REPORTTYPE,
		IDS_USAGE_REPORTFOLDER,
		// computers to generate reports for
		IDS_USAGE_INCLUDE_D,
		IDS_USAGE_EXCLUDE,
		IDS_USAGE_FOOTER,
	};

	PrintUsage(s_uId, countof(s_uId));
}


void __stdcall PrintKeyUsage()
{
	static UINT s_uId[] =
	{
		IDS_USAGE_SYNTAX,
		IDS_USAGE_KEY,
	};

	PrintUsage(s_uId, countof(s_uId));
}


void __stdcall PrintUsage(UINT uId[], UINT cId)
{
	_TCHAR szBuffer[512];

	// print this is command syntax line

	if (cId > 0)
	{
		GetString(uId[0], szBuffer, countof(szBuffer));
		_tprintf(_T("%s\n\n"), szBuffer);
	}

	// print command

	if (cId > 1)
	{
		GetString(uId[1], szBuffer, countof(szBuffer));
		_tprintf(_T("%s\n\n"), szBuffer);
	}

	// print options

	if (cId > 2)
	{
		for (UINT i = 2; i < cId; i++)
		{
			GetString(uId[i], szBuffer, countof(szBuffer));

			_tprintf(_T("%s\n"), szBuffer);
		}
	}
}

void __stdcall GetString(UINT uId, LPTSTR pszBuffer, int cchBuffer)
{
	if (pszBuffer)
	{
		if (LoadString(GetModuleHandle(NULL), uId, pszBuffer, cchBuffer) == 0)
		{
			pszBuffer[0] = _T('\0');
		}
	}
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\command\generatekey.cpp ===
#include "StdAfx.h"
#include "GenerateKey.h"

#include <AdmtCrypt.h>


void __stdcall GeneratePasswordKey(LPCTSTR pszDomainName, LPCTSTR pszPassword, LPCTSTR pszFolder)
{
	// validate parameters

	if ((pszFolder == NULL) || (pszFolder[0] == NULL))
	{
		ThrowError(E_INVALIDARG);
	}

	// generate full path to folder

	_TCHAR szPath[_MAX_PATH];
	LPTSTR pszFilePart;

	DWORD cchPath = GetFullPathName(pszFolder, _MAX_PATH, szPath, &pszFilePart);

	if ((cchPath == 0) || (cchPath >= _MAX_PATH))
	{
		ThrowError(HRESULT_FROM_WIN32(GetLastError()), IDS_E_INVALID_FOLDER, pszFolder);
	}

	// path must be terminated with path separator otherwise
	// _tsplitpath will treat last path component as file name

	if (szPath[cchPath - 1] != _T('\\'))
	{
		_tcscat(szPath, _T("\\"));
	}

	_TCHAR szDrive[_MAX_DRIVE];
	_TCHAR szDir[_MAX_DIR];

	_tsplitpath(szPath, szDrive, szDir, NULL, NULL);

	// verify drive is a local drive

	_TCHAR szTestDrive[_MAX_PATH];
	_tmakepath(szTestDrive, szDrive, _T("\\"), NULL, NULL);

	if (GetDriveType(szTestDrive) == DRIVE_REMOTE)
	{
		ThrowError(E_INVALIDARG, IDS_E_NOT_LOCAL_DRIVE, pszFolder);
	}

	// generate random name

	static _TCHAR s_chName[] = _T("ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");

	BYTE bRandom[8];
	CCryptProvider crypt;
	crypt.GenerateRandom(bRandom, 8);

	_TCHAR szName[9];

	for (int i = 0; i < 8; i++)
	{
		szName[i] = s_chName[bRandom[i] % (countof(s_chName) - 1)];
	}

	szName[8] = _T('\0');

	// generate path to key file

	_TCHAR szKeyFile[_MAX_PATH];
	_tmakepath(szKeyFile, szDrive, szDir, szName, _T(".pes"));

	// generate key

	IPasswordMigrationPtr spPasswordMigration(__uuidof(PasswordMigration));
	spPasswordMigration->GenerateKey(pszDomainName, szKeyFile, pszPassword);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\command\generatekey.h ===
#pragma once

#include "Resource.h"


void __stdcall GeneratePasswordKey(LPCTSTR pszDomainName, LPCTSTR pszPassword, LPCTSTR pszFolder);

#ifdef _DEBUG

void __stdcall ImportPasswordKey(LPCTSTR pszFolder, LPCTSTR pszPassword);
void TestSession(LPCTSTR pszDomainName);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\command\less.h ===
#pragma once

#include <functional>


//---------------------------------------------------------------------------
// String Ignore Case Less Structure
//---------------------------------------------------------------------------


struct StringIgnoreCaseLess :
	public std::binary_function<_bstr_t, _bstr_t, bool>
{
	bool operator()(const _bstr_t& x, const _bstr_t& y) const
	{
		bool bLess;

		LPCTSTR pszThis = x;
		LPCTSTR pszThat = y;

		if (pszThis == pszThat)
		{
			bLess = false;
		}
		else if (pszThis == NULL)
		{
			bLess = true;
		}
		else if (pszThat == NULL)
		{
			bLess = false;
		}
		else
		{
			bLess = _tcsicmp(pszThis, pszThat) < 0;
		}

		return bLess;
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\command\monitorthread.h ===
#pragma once

#include "Thread.h"


//---------------------------------------------------------------------------
// MonitorThread Class
//---------------------------------------------------------------------------


class CMonitorThread : public CThread
{
public:

	CMonitorThread();
	virtual ~CMonitorThread();

	void Start();
	void Stop();

protected:

	virtual void Run();

	void ProcessMigrationLog();

private:

	_bstr_t m_strMigrationLog;
	HANDLE m_hMigrationLog;
	FILETIME m_ftMigrationLogLastWriteTime;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\command\migration.cpp ===
#include "StdAfx.h"
#include "Migration.h"
#include "Switch.h"


namespace
{

void __stdcall AdmtCheckError(HRESULT hr)
{
	if (FAILED(hr))
	{
		IErrorInfo* pErrorInfo = NULL;

		if (GetErrorInfo(0, &pErrorInfo) == S_OK)
		{
			_com_raise_error(hr, pErrorInfo);
		}
		else
		{
			_com_issue_error(hr);
		}
	}
}

}


//---------------------------------------------------------------------------
// Migration Class
//---------------------------------------------------------------------------


void CMigration::Initialize(CParameterMap& mapParams)
{
	bool bValue;
	long lValue;
	_bstr_t strValue;

	if (mapParams.GetValue(SWITCH_TEST_MIGRATION, bValue))
	{
		m_spMigration->TestMigration = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_INTRA_FOREST, bValue))
	{
		m_spMigration->IntraForest = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_SOURCE_DOMAIN, strValue))
	{
		m_spMigration->SourceDomain = strValue;
	}

	if (mapParams.GetValue(SWITCH_SOURCE_OU, strValue))
	{
		m_spMigration->SourceOu = strValue;
	}

	if (mapParams.GetValue(SWITCH_TARGET_DOMAIN, strValue))
	{
		m_spMigration->TargetDomain = strValue;
	}

	if (mapParams.GetValue(SWITCH_TARGET_OU, strValue))
	{
		m_spMigration->TargetOu = strValue;
	}

	if (mapParams.GetValue(SWITCH_RENAME_OPTION, lValue))
	{
		m_spMigration->RenameOption = lValue;
	}

	if (mapParams.GetValue(SWITCH_RENAME_PREFIX_OR_SUFFIX, strValue))
	{
		m_spMigration->RenamePrefixOrSuffix = strValue;
	}

	if (mapParams.GetValue(SWITCH_PASSWORD_OPTION, lValue))
	{
		m_spMigration->PasswordOption = lValue;
	}

	if (mapParams.GetValue(SWITCH_PASSWORD_SERVER, strValue))
	{
		AdmtCheckError(m_spMigration->put_PasswordServer(strValue));
	}

	if (mapParams.GetValue(SWITCH_PASSWORD_FILE, strValue))
	{
		m_spMigration->PasswordFile = strValue;
	}

	if (mapParams.GetValue(SWITCH_CONFLICT_OPTIONS, lValue))
	{
		m_spMigration->ConflictOptions = lValue;
	}

	if (mapParams.GetValue(SWITCH_CONFLICT_PREFIX_OR_SUFFIX, strValue))
	{
		m_spMigration->ConflictPrefixOrSuffix = strValue;
	}

	if (mapParams.GetValue(SWITCH_USER_PROPERTIES_TO_EXCLUDE, strValue))
	{
		m_spMigration->UserPropertiesToExclude = strValue;
	}

	if (mapParams.GetValue(SWITCH_GROUP_PROPERTIES_TO_EXCLUDE, strValue))
	{
		m_spMigration->GroupPropertiesToExclude = strValue;
	}

	if (mapParams.GetValue(SWITCH_COMPUTER_PROPERTIES_TO_EXCLUDE, strValue))
	{
		m_spMigration->ComputerPropertiesToExclude = strValue;
	}
}


//---------------------------------------------------------------------------
// User Migration Class
//---------------------------------------------------------------------------


void CUserMigration::Initialize(CParameterMap& mapParams)
{
	bool bValue;
	long lValue;

	if (mapParams.GetValue(SWITCH_DISABLE_OPTION, lValue))
	{
		m_spUser->DisableOption = lValue;
	}

	if (mapParams.GetValue(SWITCH_SOURCE_EXPIRATION, lValue))
	{
		m_spUser->SourceExpiration = lValue;
	}

	if (mapParams.GetValue(SWITCH_MIGRATE_SIDS, bValue))
	{
		m_spUser->MigrateSIDs = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_ROAMING_PROFILE, bValue))
	{
		m_spUser->TranslateRoamingProfile = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_UPDATE_USER_RIGHTS, bValue))
	{
		m_spUser->UpdateUserRights = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_MIGRATE_GROUPS, bValue))
	{
		m_spUser->MigrateGroups = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_UPDATE_PREVIOUSLY_MIGRATED_OBJECTS, bValue))
	{
		m_spUser->UpdatePreviouslyMigratedObjects = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_FIX_GROUP_MEMBERSHIP, bValue))
	{
		m_spUser->FixGroupMembership = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_MIGRATE_SERVICE_ACCOUNTS, bValue))
	{
		m_spUser->MigrateServiceAccounts = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_SOURCE_EXPIRATION, lValue))
	{
		m_spUser->SourceExpiration = lValue;
	}

	_variant_t vntExcludeNames;

	if (!mapParams.GetValues(SWITCH_EXCLUDE_NAME, vntExcludeNames))
	{
		_bstr_t strExcludeFile;

		if (mapParams.GetValue(SWITCH_EXCLUDE_FILE, strExcludeFile))
		{
			vntExcludeNames = strExcludeFile;
		}
	}

	_variant_t vntIncludeNames;
	_bstr_t strIncludeFile;
	long lIncludeOption;

	if (mapParams.GetValues(SWITCH_INCLUDE_NAME, vntIncludeNames))
	{
		AdmtCheckError(m_spUser->raw_Migrate(admtData, vntIncludeNames, vntExcludeNames));
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_FILE, strIncludeFile))
	{
		AdmtCheckError(m_spUser->raw_Migrate(admtFile, _variant_t(strIncludeFile), vntExcludeNames));
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_DOMAIN, lIncludeOption))
	{
		AdmtCheckError(m_spUser->raw_Migrate(admtDomain | lIncludeOption, _variant_t(), vntExcludeNames));
	}
	else
	{
		ThrowError(E_INVALIDARG, IDS_E_NO_INCLUDE_OPTION_SPECIFIED);
	}
}


//---------------------------------------------------------------------------
// Group Migration Class
//---------------------------------------------------------------------------


void CGroupMigration::Initialize(CParameterMap& mapParams)
{
	bool bValue;
	long lValue;

	if (mapParams.GetValue(SWITCH_MIGRATE_SIDS, bValue))
	{
		m_spGroup->MigrateSIDs = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_UPDATE_GROUP_RIGHTS, bValue))
	{
		m_spGroup->UpdateGroupRights = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_UPDATE_PREVIOUSLY_MIGRATED_OBJECTS, bValue))
	{
		m_spGroup->UpdatePreviouslyMigratedObjects = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_FIX_GROUP_MEMBERSHIP, bValue))
	{
		m_spGroup->FixGroupMembership = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_MIGRATE_MEMBERS, bValue))
	{
		m_spGroup->MigrateMembers = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_DISABLE_OPTION, lValue))
	{
		m_spGroup->DisableOption = lValue;
	}

	if (mapParams.GetValue(SWITCH_SOURCE_EXPIRATION, lValue))
	{
		m_spGroup->SourceExpiration = lValue;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_ROAMING_PROFILE, bValue))
	{
		m_spGroup->TranslateRoamingProfile = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	_variant_t vntExcludeNames;

	if (!mapParams.GetValues(SWITCH_EXCLUDE_NAME, vntExcludeNames))
	{
		_bstr_t strExcludeFile;

		if (mapParams.GetValue(SWITCH_EXCLUDE_FILE, strExcludeFile))
		{
			vntExcludeNames = strExcludeFile;
		}
	}

	_variant_t vntIncludeNames;
	_bstr_t strIncludeFile;
	long lIncludeOption;

	if (mapParams.GetValues(SWITCH_INCLUDE_NAME, vntIncludeNames))
	{
		AdmtCheckError(m_spGroup->raw_Migrate(admtData, vntIncludeNames, vntExcludeNames));
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_FILE, strIncludeFile))
	{
		AdmtCheckError(m_spGroup->raw_Migrate(admtFile, _variant_t(strIncludeFile), vntExcludeNames));
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_DOMAIN, lIncludeOption))
	{
		AdmtCheckError(m_spGroup->raw_Migrate(admtDomain | lIncludeOption, _variant_t(), vntExcludeNames));
	}
	else
	{
		ThrowError(E_INVALIDARG, IDS_E_NO_INCLUDE_OPTION_SPECIFIED);
	}
}


//---------------------------------------------------------------------------
// Computer Migration Class
//---------------------------------------------------------------------------


void CComputerMigration::Initialize(CParameterMap& mapParams)
{
	bool bValue;
	long lValue;

	if (mapParams.GetValue(SWITCH_TRANSLATION_OPTION, lValue))
	{
		m_spComputer->TranslationOption = lValue;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_FILES_AND_FOLDERS, bValue))
	{
		m_spComputer->TranslateFilesAndFolders = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_LOCAL_GROUPS, bValue))
	{
		m_spComputer->TranslateLocalGroups = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_PRINTERS, bValue))
	{
		m_spComputer->TranslatePrinters = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_REGISTRY, bValue))
	{
		m_spComputer->TranslateRegistry = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_SHARES, bValue))
	{
		m_spComputer->TranslateShares = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_USER_PROFILES, bValue))
	{
		m_spComputer->TranslateUserProfiles = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_USER_RIGHTS, bValue))
	{
		m_spComputer->TranslateUserRights = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_RESTART_DELAY, lValue))
	{
		m_spComputer->RestartDelay = lValue;
	}

	_variant_t vntExcludeNames;

	if (!mapParams.GetValues(SWITCH_EXCLUDE_NAME, vntExcludeNames))
	{
		_bstr_t strExcludeFile;

		if (mapParams.GetValue(SWITCH_EXCLUDE_FILE, strExcludeFile))
		{
			vntExcludeNames = strExcludeFile;
		}
	}

	_variant_t vntIncludeNames;
	_bstr_t strIncludeFile;
	long lIncludeOption;

	if (mapParams.GetValues(SWITCH_INCLUDE_NAME, vntIncludeNames))
	{
		AdmtCheckError(m_spComputer->raw_Migrate(admtData, vntIncludeNames, vntExcludeNames));
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_FILE, strIncludeFile))
	{
		AdmtCheckError(m_spComputer->raw_Migrate(admtFile, _variant_t(strIncludeFile), vntExcludeNames));
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_DOMAIN, lIncludeOption))
	{
		AdmtCheckError(m_spComputer->raw_Migrate(admtDomain | lIncludeOption, _variant_t(), vntExcludeNames));
	}
	else
	{
		ThrowError(E_INVALIDARG, IDS_E_NO_INCLUDE_OPTION_SPECIFIED);
	}
}


//---------------------------------------------------------------------------
// Security Translation Class
//---------------------------------------------------------------------------


void CSecurityTranslation::Initialize(CParameterMap& mapParams)
{
	bool bValue;
	long lValue;
	_bstr_t strValue;

	if (mapParams.GetValue(SWITCH_TRANSLATION_OPTION, lValue))
	{
		m_spSecurity->TranslationOption = lValue;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_FILES_AND_FOLDERS, bValue))
	{
		m_spSecurity->TranslateFilesAndFolders = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_LOCAL_GROUPS, bValue))
	{
		m_spSecurity->TranslateLocalGroups = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_PRINTERS, bValue))
	{
		m_spSecurity->TranslatePrinters = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_REGISTRY, bValue))
	{
		m_spSecurity->TranslateRegistry = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_SHARES, bValue))
	{
		m_spSecurity->TranslateShares = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_USER_PROFILES, bValue))
	{
		m_spSecurity->TranslateUserProfiles = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_TRANSLATE_USER_RIGHTS, bValue))
	{
		m_spSecurity->TranslateUserRights = bValue ? VARIANT_TRUE : VARIANT_FALSE;
	}

	if (mapParams.GetValue(SWITCH_SID_MAPPING_FILE, strValue))
	{
		AdmtCheckError(m_spSecurity->put_SidMappingFile(strValue));
	}

	_variant_t vntExcludeNames;

	if (!mapParams.GetValues(SWITCH_EXCLUDE_NAME, vntExcludeNames))
	{
		_bstr_t strExcludeFile;

		if (mapParams.GetValue(SWITCH_EXCLUDE_FILE, strExcludeFile))
		{
			vntExcludeNames = strExcludeFile;
		}
	}

	_variant_t vntIncludeNames;
	_bstr_t strIncludeFile;
	long lIncludeOption;

	if (mapParams.GetValues(SWITCH_INCLUDE_NAME, vntIncludeNames))
	{
		AdmtCheckError(m_spSecurity->raw_Translate(admtData, vntIncludeNames, vntExcludeNames));
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_FILE, strIncludeFile))
	{
		AdmtCheckError(m_spSecurity->raw_Translate(admtFile, _variant_t(strIncludeFile), vntExcludeNames));
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_DOMAIN, lIncludeOption))
	{
		AdmtCheckError(m_spSecurity->raw_Translate(admtDomain | lIncludeOption, _variant_t(), vntExcludeNames));
	}
	else
	{
		ThrowError(E_INVALIDARG, IDS_E_NO_INCLUDE_OPTION_SPECIFIED);
	}
}


//---------------------------------------------------------------------------
// Service Enumeration Class
//---------------------------------------------------------------------------


void CServiceEnumeration::Initialize(CParameterMap& mapParams)
{
	_variant_t vntExcludeNames;

	if (!mapParams.GetValues(SWITCH_EXCLUDE_NAME, vntExcludeNames))
	{
		_bstr_t strExcludeFile;

		if (mapParams.GetValue(SWITCH_EXCLUDE_FILE, strExcludeFile))
		{
			vntExcludeNames = strExcludeFile;
		}
	}

	_variant_t vntIncludeNames;
	_bstr_t strIncludeFile;
	long lIncludeOption;

	if (mapParams.GetValues(SWITCH_INCLUDE_NAME, vntIncludeNames))
	{
		AdmtCheckError(m_spService->raw_Enumerate(admtData, vntIncludeNames, vntExcludeNames));
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_FILE, strIncludeFile))
	{
		AdmtCheckError(m_spService->raw_Enumerate(admtFile, _variant_t(strIncludeFile), vntExcludeNames));
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_DOMAIN, lIncludeOption))
	{
		AdmtCheckError(m_spService->raw_Enumerate(admtDomain | lIncludeOption, _variant_t(), vntExcludeNames));
	}
	else
	{
		ThrowError(E_INVALIDARG, IDS_E_NO_INCLUDE_OPTION_SPECIFIED);
	}
}


//---------------------------------------------------------------------------
// Report Generation Class
//---------------------------------------------------------------------------


void CReportGeneration::Initialize(CParameterMap& mapParams)
{
	long lValue;
	_bstr_t strValue;

	if (mapParams.GetValue(SWITCH_REPORT_TYPE, lValue))
	{
		m_spReport->Type = lValue;
	}

	if (mapParams.GetValue(SWITCH_REPORT_FOLDER, strValue))
	{
		AdmtCheckError(m_spReport->put_Folder(strValue));
	}

	_variant_t vntExcludeNames;

	if (!mapParams.GetValues(SWITCH_EXCLUDE_NAME, vntExcludeNames))
	{
		_bstr_t strExcludeFile;

		if (mapParams.GetValue(SWITCH_EXCLUDE_FILE, strExcludeFile))
		{
			vntExcludeNames = strExcludeFile;
		}
	}

	_variant_t vntIncludeNames;
	_bstr_t strIncludeFile;
	long lIncludeOption;

	if (mapParams.GetValues(SWITCH_INCLUDE_NAME, vntIncludeNames))
	{
		AdmtCheckError(m_spReport->raw_Generate(admtData, vntIncludeNames, vntExcludeNames));
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_FILE, strIncludeFile))
	{
		AdmtCheckError(m_spReport->raw_Generate(admtFile, _variant_t(strIncludeFile), vntExcludeNames));
	}
	else if (mapParams.GetValue(SWITCH_INCLUDE_DOMAIN, lIncludeOption))
	{
		AdmtCheckError(m_spReport->raw_Generate(admtDomain | lIncludeOption, _variant_t(), vntExcludeNames));
	}
	else
	{
		AdmtCheckError(m_spReport->raw_Generate(admtNone, _variant_t(), _variant_t()));
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\command\migration.h ===
#pragma once

#include "Parameter.h"


//---------------------------------------------------------------------------
// Migration Class
//---------------------------------------------------------------------------


class CMigration
{
public:

	CMigration(CParameterMap& mapParams) :
		m_spMigration(__uuidof(Migration))
	{
		Initialize(mapParams);
	}

	IUserMigrationPtr CreateUserMigration()
	{
		return m_spMigration->CreateUserMigration();
	}

	IGroupMigrationPtr CreateGroupMigration()
	{
		return m_spMigration->CreateGroupMigration();
	}

	IComputerMigrationPtr CreateComputerMigration()
	{
		return m_spMigration->CreateComputerMigration();
	}

	ISecurityTranslationPtr CreateSecurityTranslation()
	{
		return m_spMigration->CreateSecurityTranslation();
	}

	IServiceAccountEnumerationPtr CreateServiceAccountEnumeration()
	{
		return m_spMigration->CreateServiceAccountEnumeration();
	}

	IReportGenerationPtr CreateReportGeneration()
	{
		return m_spMigration->CreateReportGeneration();
	}

protected:

	CMigration() {}

	void Initialize(CParameterMap& mapParams);

protected:

	IMigrationPtr m_spMigration;
};


//---------------------------------------------------------------------------
// User Migration Class
//---------------------------------------------------------------------------


class CUserMigration
{
public:

	CUserMigration(CMigration& rMigration, CParameterMap& mapParams) :
		m_spUser(rMigration.CreateUserMigration())
	{
		Initialize(mapParams);
	}

protected:

	CUserMigration() {}

	void Initialize(CParameterMap& mapParams);

protected:

	IUserMigrationPtr m_spUser;
};


//---------------------------------------------------------------------------
// Group Migration Class
//---------------------------------------------------------------------------


class CGroupMigration
{
public:

	CGroupMigration(CMigration& rMigration, CParameterMap& mapParams) :
		m_spGroup(rMigration.CreateGroupMigration())
	{
		Initialize(mapParams);
	}

protected:

	CGroupMigration() {}

	void Initialize(CParameterMap& mapParams);

protected:

	IGroupMigrationPtr m_spGroup;
};


//---------------------------------------------------------------------------
// Computer Migration Class
//---------------------------------------------------------------------------


class CComputerMigration
{
public:

	CComputerMigration(CMigration& rMigration, CParameterMap& mapParams) :
		m_spComputer(rMigration.CreateComputerMigration())
	{
		Initialize(mapParams);
	}

protected:

	CComputerMigration() {}

	void Initialize(CParameterMap& mapParams);

protected:

	IComputerMigrationPtr m_spComputer;
};


//---------------------------------------------------------------------------
// Security Translation Class
//---------------------------------------------------------------------------


class CSecurityTranslation
{
public:

	CSecurityTranslation(CMigration& rMigration, CParameterMap& mapParams) :
		m_spSecurity(rMigration.CreateSecurityTranslation())
	{
		Initialize(mapParams);
	}

protected:

	CSecurityTranslation() {}

	void Initialize(CParameterMap& mapParams);

protected:

	ISecurityTranslationPtr m_spSecurity;
};


//---------------------------------------------------------------------------
// Service Enumeration Class
//---------------------------------------------------------------------------


class CServiceEnumeration
{
public:

	CServiceEnumeration(CMigration& rMigration, CParameterMap& mapParams) :
		m_spService(rMigration.CreateServiceAccountEnumeration())
	{
		Initialize(mapParams);
	}

protected:

	CServiceEnumeration() {}

	void Initialize(CParameterMap& mapParams);

protected:

	IServiceAccountEnumerationPtr m_spService;
};


//---------------------------------------------------------------------------
// Report Generation Class
//---------------------------------------------------------------------------


class CReportGeneration
{
public:

	CReportGeneration(CMigration& rMigration, CParameterMap& mapParams) :
		m_spReport(rMigration.CreateReportGeneration())
	{
		Initialize(mapParams);
	}

protected:

	CReportGeneration() {}

	void Initialize(CParameterMap& mapParams);

protected:

	IReportGenerationPtr m_spReport;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\command\parameter.cpp ===
#include "StdAfx.h"
#include "Parameter.h"

#define NO_WBEM
#include "T_SafeVector.h"


namespace Parameter_cpp
{

inline bool IsPrefix(_TCHAR ch)
{
	return ((ch == _T('/')) || (ch == _T('-')));
}

struct SNameToTask
{
	LPCTSTR pszName;
	int nTask;
};

SNameToTask s_TaskValues[] =
{
	{ _T("User"),     TASK_USER     },
	{ _T("Group"),    TASK_GROUP    },
	{ _T("Computer"), TASK_COMPUTER },
	{ _T("Security"), TASK_SECURITY },
	{ _T("Service"),  TASK_SERVICE  },
	{ _T("Report"),   TASK_REPORT   },
	{ _T("Key"),      TASK_KEY      },
	{ NULL,           TASK_NONE     },
};

struct SNameToBool
{
	LPCTSTR pszName;
	bool bValue;
};

SNameToBool s_BoolValues[] =
{
	{ _T("Yes"),   true  },
	{ _T("No"),    false },
	{ _T("True"),  true  },
	{ _T("False"), false },
	{ NULL,        false },
};

struct SNameToLong
{
	LPCTSTR pszName;
	long lValue;
};

SNameToLong s_RenameOptionValues[] =
{
	{ _T("Dont"),   admtDoNotRename      },
	{ _T("Prefix"), admtRenameWithPrefix },
	{ _T("Suffix"), admtRenameWithSuffix },
	{ NULL,                          -1L },
};

SNameToLong s_PasswordOptionValues[] =
{
	{ _T("Name"),    admtPasswordFromName },
	{ _T("Complex"), admtComplexPassword  },
	{ _T("Copy"),    admtCopyPassword     },
	{ NULL,                           -1L },
};

SNameToLong s_ConflictOptionValues[] =
{
	{ _T("Ignore"),  admtIgnoreConflicting           },
	{ _T("Replace"), admtReplaceConflicting          },
	{ _T("Prefix"),  admtRenameConflictingWithPrefix },
	{ _T("Suffix"),  admtRenameConflictingWithSuffix },
	{ NULL,                                      -1L },
};

SNameToLong s_ConflictOptionFlagValues[] =
{
	{ _T("RemoveUserRights"),     admtRemoveExistingUserRights },
	{ _T("RemoveMembers"),        admtRemoveExistingMembers    },
	{ _T("MoveReplacedAccounts"), admtMoveReplacedAccounts     },
	{ NULL,                                                -1L },
};

SNameToLong s_DisableOptionValues[] =
{
	{ _T("Neither"),      admtEnableTarget       },
	{ _T("Source"),       admtDisableSource      },
	{ _T("Target"),       admtDisableTarget      },
	{ _T("SameAsSource"), admtTargetSameAsSource },
	{ NULL,                                  -1L },
};

SNameToLong s_SourceExpirationValues[] =
{
	{ _T("None"), admtNoExpiration },
	{ NULL,                     0L },
};

SNameToLong s_TranslationOptionValues[] =
{
	{ _T("Replace"), admtTranslateReplace },
	{ _T("Add"),     admtTranslateAdd     },
	{ _T("Remove"),  admtTranslateRemove  },
	{ NULL,                           -1L },
};

SNameToLong s_ReportTypeValues[] =
{
	{ _T("MigratedAccounts"),  admtReportMigratedAccounts  },
	{ _T("MigratedComputers"), admtReportMigratedComputers },
	{ _T("ExpiredComputers"),  admtReportExpiredComputers  },
	{ _T("AccountReferences"), admtReportAccountReferences },
	{ _T("NameConflicts"),     admtReportNameConflicts     },
	{ NULL,                                            -1L },
};

SNameToLong s_DomainOptionFlagAValues[] =
{
	{ _T("Recurse"),  admtRecurse },
	{ NULL,                   -1L },
};

SNameToLong s_DomainOptionFlagBValues[] =
{
	{ _T("Flatten"),  admtFlattenHierarchy  },
	{ _T("Maintain"), admtMaintainHierarchy },
	{ NULL,                             -1L },
};

bool GetBoolValue(LPCTSTR pszArg);
bool GetBoolFromName(LPCTSTR pszName, SNameToBool* pNameToBool);
long GetLongValue(LPCTSTR pszArg, SNameToLong* pNameToLong);
long GetLongFromName(LPCTSTR pszName, SNameToLong* pNameToLong);

bool GetPasswordFromUser(LPCTSTR pszKeyId, _bstr_t& strPassword);

_bstr_t LoadStringHelper(UINT uId);

}

using namespace Parameter_cpp;


//---------------------------------------------------------------------------
// Parameter Map
//---------------------------------------------------------------------------


// Public Methods -----------------------------------------------------------


// GetValue Method

bool CParameterMap::GetValue(int nParam, bool& bValue)
{
	bool bGet = false;

	iterator it = find(nParam);

	if (it != end())
	{
		bValue = it->second;

		bGet = true;
	}

	return bGet;
}


// GetValue Method

bool CParameterMap::GetValue(int nParam, long& lValue)
{
	bool bGet = false;

	iterator it = find(nParam);

	if (it != end())
	{
		lValue = it->second;

		bGet = true;
	}

	return bGet;
}


// GetValue Method

bool CParameterMap::GetValue(int nParam, _bstr_t& strValue)
{
	bool bGet = false;

	iterator it = find(nParam);

	if (it != end())
	{
		strValue = it->second;

		bGet = true;
	}

	return bGet;
}


// GetValues Method

bool CParameterMap::GetValues(int nParam, _variant_t& vntValues)
{
	bool bGet = false;

	iterator it = find(nParam);

	if (it != end())
	{
		vntValues = it->second;

		bGet = true;
	}

	return bGet;
}


// GetValues Method

bool CParameterMap::GetValues(int nParam, StringVector& vecValues)
{
	bool bGet = false;

	iterator it = find(nParam);

	if (it != end())
	{
		vecValues = T_SafeVector2<VT_BSTR, _bstr_t, StringVector, T_Extract_bstr_t<StringVector> >(it->second);

		bGet = true;
	}

	return bGet;
}


// Protected Methods --------------------------------------------------------


// Initialize Method

void CParameterMap::Initialize(CArguments& rArgs)
{
	if (DoTask(rArgs.Value()))
	{
		long lTask;

		if (GetValue(SWITCH_TASK, lTask))
		{
			if (lTask == TASK_KEY)
			{
				DoTaskKey(rArgs);
			}
			else
			{
				DoSwitches(rArgs);

				VerifyIncludeExclude();
			}
		}
	}

//	if (empty())
//	{
//		ThrowError(E_INVALIDARG, IDS_E_NO_ARGUMENTS);
//	}
}


// DoTask

bool CParameterMap::DoTask(LPCTSTR pszArg)
{
	bool bTask = false;

	if (pszArg != NULL)
	{
		// first switch must specify task or help

		int nSwitch = m_mapSwitchs.GetSwitch(pszArg);

		if (nSwitch == SWITCH_TASK)
		{
			int nTask = TASK_NONE;

			for (SNameToTask* p = s_TaskValues; p->pszName; p++)
			{
				if (_tcsicmp(p->pszName, pszArg) == 0)
				{
					nTask = p->nTask;
					break;
				}
			}

			insert(value_type(SWITCH_TASK, _variant_t(long(nTask))));

			bTask = true;
		}
		else
		{
			_TCHAR chPrefix;
			_TCHAR szSwitch[16];

			if ((_stscanf(pszArg, _T(" %c%15s "), &chPrefix, szSwitch) == 2) && IsPrefix(chPrefix) && (m_mapSwitchs.GetSwitch(szSwitch) == SWITCH_HELP))
			{
				insert(value_type(SWITCH_HELP, _variant_t(true)));
			}
			else
			{
				ThrowError(E_INVALIDARG, IDS_E_INVALID_FIRST_ARGUMENT, pszArg);
			}
		}
	}
	else
	{
	//	ThrowError(E_INVALIDARG, IDS_E_NO_ARGUMENTS);
	}

	return bTask;
}


// DoSwitches Method

void CParameterMap::DoSwitches(CArguments& rArgs)
{
	LPCTSTR pszArg = NULL;

	while (rArgs.Next())
	{
		pszArg = rArgs.Value();

		_TCHAR chPrefix;
		_TCHAR szSwitch[64];

		if ((_stscanf(pszArg, _T(" %c%63[A-Za-z?] "), &chPrefix, szSwitch) == 2) && IsPrefix(chPrefix))
		{
			int nSwitch = m_mapSwitchs.GetSwitch(szSwitch);

			if (nSwitch == -1)
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_UNRECOGNIZED, pszArg);
			}

			if (nSwitch == SWITCH_TASK)
			{
				ThrowError(E_INVALIDARG, IDS_E_TASK_NOT_FIRST, pszArg);
			}

			if (nSwitch == SWITCH_HELP)
			{
				insert(value_type(SWITCH_HELP, _variant_t(true)));
				break;
			}

			DoSwitch(nSwitch, rArgs);
		}
		else
		{
			ThrowError(E_INVALIDARG, IDS_E_INVALID_OPTION_FORMAT, pszArg);
		}
	}

	// if no switches/options then display help

	if (pszArg == NULL)
	{
		insert(value_type(SWITCH_HELP, _variant_t(true)));
	}
}


// DoSwitch Method

void CParameterMap::DoSwitch(int nSwitch, CArguments& rArgs)
{
	_variant_t& vntValue = Insert(nSwitch);

	switch (nSwitch)
	{
		// boolean values

		case SWITCH_TEST_MIGRATION:
		case SWITCH_INTRA_FOREST:
		case SWITCH_MIGRATE_SIDS:
		case SWITCH_TRANSLATE_ROAMING_PROFILE:
		case SWITCH_UPDATE_USER_RIGHTS:
		case SWITCH_MIGRATE_GROUPS:
		case SWITCH_UPDATE_PREVIOUSLY_MIGRATED_OBJECTS:
		case SWITCH_FIX_GROUP_MEMBERSHIP:
		case SWITCH_MIGRATE_SERVICE_ACCOUNTS:
		case SWITCH_UPDATE_GROUP_RIGHTS:
		case SWITCH_MIGRATE_MEMBERS:
		case SWITCH_TRANSLATE_FILES_AND_FOLDERS:
		case SWITCH_TRANSLATE_LOCAL_GROUPS:
		case SWITCH_TRANSLATE_PRINTERS:
		case SWITCH_TRANSLATE_REGISTRY:
		case SWITCH_TRANSLATE_SHARES:
		case SWITCH_TRANSLATE_USER_PROFILES:
		case SWITCH_TRANSLATE_USER_RIGHTS:
		{
			vntValue = GetBoolValue(rArgs.Value());
			break;
		}

		// long values

		case SWITCH_RENAME_OPTION:
		{
			vntValue = GetLongValue(rArgs.Value(), s_RenameOptionValues);
			break;
		}
		case SWITCH_PASSWORD_OPTION:
		{
			vntValue = GetLongValue(rArgs.Value(), s_PasswordOptionValues);
			break;
		}
		case SWITCH_CONFLICT_OPTIONS:
		{
			_TCHAR szValueA[32];
			_TCHAR szValueB[32];
			_TCHAR szValueC[32];
			_TCHAR szValueD[32];

			int cFields = _stscanf(rArgs.Value(), _T("%*[^:]: %31[A-Za-z] + %31[A-Za-z] + %31[A-Za-z] + %31[A-Za-z]"), szValueA, szValueB, szValueC, szValueD);

			if (cFields <= 0)
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_FORMAT_INVALID, rArgs.Value());
			}

			long lValue = GetLongFromName(szValueA, s_ConflictOptionValues);

			if (cFields >= 2)
			{
				lValue |= GetLongFromName(szValueB, s_ConflictOptionFlagValues);
			}

			if (cFields >= 3)
			{
				lValue |= GetLongFromName(szValueC, s_ConflictOptionFlagValues);
			}

			if (cFields >= 4)
			{
				lValue |= GetLongFromName(szValueD, s_ConflictOptionFlagValues);
			}

			vntValue = lValue;
			break;
		}
		case SWITCH_DISABLE_OPTION:
		{
			_TCHAR szValueA[32];
			_TCHAR szValueB[32];

			int cFields = _stscanf(rArgs.Value(), _T("%*[^:]: %31[A-Za-z] + %31[A-Za-z]"), szValueA, szValueB);

			if (cFields <= 0)
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_FORMAT_INVALID, rArgs.Value());
			}

			long lValue = GetLongFromName(szValueA, s_DisableOptionValues);

			if (cFields >= 2)
			{
				lValue |= GetLongFromName(szValueB, s_DisableOptionValues);
			}

			vntValue = lValue;
			break;
		}
		case SWITCH_SOURCE_EXPIRATION:
		{
			long lValue;
			_TCHAR szValue[32];

			if (_stscanf(rArgs.Value(), _T("%*[^:]: %31[A-Za-z]"), szValue) == 1)
			{
				vntValue = GetLongFromName(szValue, s_SourceExpirationValues);
			}
			else if (_stscanf(rArgs.Value(), _T("%*[^:]: %ld"), &lValue) == 1)
			{
				vntValue = lValue;
			}
			else
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_FORMAT_INVALID, rArgs.Value());
			}
			break;
		}
		case SWITCH_TRANSLATION_OPTION:
		{
			vntValue = GetLongValue(rArgs.Value(), s_TranslationOptionValues);
			break;
		}
		case SWITCH_RESTART_DELAY:
		{
			long lValue;

			if (_stscanf(rArgs.Value(), _T("%*[^:]: %ld"), &lValue) == 1)
			{
				vntValue = lValue;
			}
			else
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_FORMAT_INVALID, rArgs.Value());
			}
			break;
		}
		case SWITCH_INCLUDE_DOMAIN:
		{
			_TCHAR szValueA[32];
			_TCHAR szValueB[32];

			int cFields = _stscanf(rArgs.Value(), _T("%*[^:]: %31[A-Za-z] + %31[A-Za-z]"), szValueA, szValueB);

			if (cFields < 0)
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_FORMAT_INVALID, rArgs.Value());
			}

			long lValue = 0;

			if (cFields >= 1)
			{
				lValue |= GetLongFromName(szValueA, s_DomainOptionFlagAValues);
			}

			if (cFields >= 2)
			{
				lValue |= GetLongFromName(szValueB, s_DomainOptionFlagBValues);
			}

			vntValue = lValue;
			break;
		}
		case SWITCH_REPORT_TYPE:
		{
			vntValue = GetLongValue(rArgs.Value(), s_ReportTypeValues);
			break;
		}

		// string values

		case SWITCH_SOURCE_DOMAIN:
		case SWITCH_SOURCE_OU:
		case SWITCH_TARGET_DOMAIN:
		case SWITCH_TARGET_OU:
		case SWITCH_RENAME_PREFIX_OR_SUFFIX:
		case SWITCH_PASSWORD_SERVER:
		case SWITCH_PASSWORD_FILE:
		case SWITCH_CONFLICT_PREFIX_OR_SUFFIX:
		case SWITCH_USER_PROPERTIES_TO_EXCLUDE:
		case SWITCH_GROUP_PROPERTIES_TO_EXCLUDE:
		case SWITCH_COMPUTER_PROPERTIES_TO_EXCLUDE:
		case SWITCH_SID_MAPPING_FILE:
		case SWITCH_REPORT_FOLDER:
		case SWITCH_INCLUDE_FILE:
		case SWITCH_EXCLUDE_FILE:
		{
			_TCHAR szValue[4096];

			if (_stscanf(rArgs.Value(), _T("%*[^:]:%4095[^\0]"), szValue) == 1)
			{
				if (_tcslen(szValue) > 2047)
				{
					ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_TOO_LONG);
				}

				vntValue = szValue;
			}
			else
			{
				if (rArgs.Next())
				{
					LPCTSTR pszArg = rArgs.Value();

					if (IsPrefix(pszArg[0]))
					{
						rArgs.Prev();
						ThrowError(E_INVALIDARG, IDS_E_NO_OPTION_VALUE, rArgs.Value());
					}

					if (_tcslen(pszArg) > 2047)
					{
						ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_TOO_LONG);
					}

					vntValue = pszArg;
				}
				else
				{
					ThrowError(E_INVALIDARG, IDS_E_NO_OPTION_VALUE, rArgs.Value());
				}
			}
			break;
		}

		// multi-string values

		case SWITCH_INCLUDE_NAME:
		case SWITCH_EXCLUDE_NAME:
		{
			T_SafeVector2<VT_BSTR, _bstr_t, StringVector, T_Extract_bstr_t<StringVector> > svValues(vntValue);

			_TCHAR szValue[4096];

			if (_stscanf(rArgs.Value(), _T("%*[^:]:%4095[^\0]"), szValue) == 1)
			{
				if (_tcslen(szValue) > 2047)
				{
					ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_TOO_LONG);
				}

				svValues.push_back(_bstr_t(szValue));
			}
			else
			{
				while (rArgs.Next())
				{
					LPCTSTR pszArg = rArgs.Value();

					if (IsPrefix(pszArg[0]))
					{
						rArgs.Prev();
						break;
					}

					if (_tcslen(pszArg) > 2047)
					{
						ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_TOO_LONG);
					}

					svValues.push_back(_bstr_t(pszArg));
				}
			}

			vntValue = svValues.GetVariant();
			break;
		}

		// option files

		case SWITCH_OPTION_FILE:
		{
			_TCHAR szValue[1024];

			if (_stscanf(rArgs.Value(), _T("%*[^:]:%1023[^\0]"), szValue) == 1)
			{
				DoOptionFile(szValue);
			}
			else
			{
				if (rArgs.Next())
				{
					LPCTSTR pszArg = rArgs.Value();

					if (IsPrefix(pszArg[0]))
					{
						rArgs.Prev();
					}
					else
					{
						DoOptionFile(pszArg);
					}
				}
			}
			break;
		}

		// default

		default:
		{
			_ASSERT(false);
			break;
		}
	}
}


// Insert Method

_variant_t& CParameterMap::Insert(int nParam)
{
	iterator it = find(nParam);

	if (it == end())
	{
		std::pair<iterator, bool> pair = insert(value_type(nParam, _variant_t()));

		it = pair.first;
	}

	return it->second;
}


// DoOptionFile Method

void CParameterMap::DoOptionFile(LPCTSTR pszFileName)
{
	CSwitchMap mapSwitchs;

	FILE* fp = OpenOptionFile(pszFileName);

	try
	{
		iterator it = find(SWITCH_TASK);

		if (it == end())
		{
			ThrowError(E_FAIL, IDS_E_OPTION_FILE_TASK, pszFileName);
		}

		int nCurrentTask = long(it->second);

		int nTask;

		do
		{
			nTask = FindTask(fp);

			if ((nTask == 0) || (nTask == nCurrentTask))
			{
				DoTask(fp, mapSwitchs);
			}
		}
		while (nTask >= 0);
	}
	catch (...)
	{
		fclose(fp);
		throw;
	}

	fclose(fp);
}


// OpenOptionFile Method

FILE* CParameterMap::OpenOptionFile(LPCTSTR pszFileName)
{
	// open in binary mode first in order to check for UNICODE byte order
	// mark if the file is UNICODE then it must be read in binary mode
	// with the stream i/o functions

	FILE* fp = _tfopen(pszFileName, _T("rb"));

	if (fp == NULL)
	{
		ThrowError(E_INVALIDARG, IDS_E_OPTION_FILE_OPEN, pszFileName);
	}

	// check if file is ANSI or UNICODE or UTF-8

	BYTE byteSignature[3];

	if (fread(byteSignature, sizeof(BYTE), 3, fp) == 3)
	{
		static BYTE byteUtf8[] = { 0xEF, 0xBB, 0xBF };
		static BYTE byteUnicodeLE[] = { 0xFF, 0xFE };
		static BYTE byteUnicodeBE[] = { 0xFE, 0xFF };

		// check for signature or byte order mark

		if (memcmp(byteSignature, byteUtf8, sizeof(byteUtf8)) == 0)
		{
			// UTF-8 signature
			// TODO: not currently supported
			fclose(fp);
			ThrowError(E_INVALIDARG, IDS_E_OPTION_FILE_UTF_8, pszFileName);
		}
		else if (memcmp(byteSignature, byteUnicodeLE, sizeof(byteUnicodeLE)) == 0)
		{
			// UNICODE Little Endian Byte Order Mark
			// supported
			// must read in binary mode
			// move file pointer back one byte because we read 3 bytes
			fseek(fp, -1, SEEK_CUR);
		}
		else if (memcmp(byteSignature, byteUnicodeBE, sizeof(byteUnicodeBE)) == 0)
		{
			// UNICODE Big Endian Byte Order Mark
			// TODO: not currently supported
			fclose(fp);
			ThrowError(E_INVALIDARG, IDS_E_OPTION_FILE_UNICODE_BIG_ENDIAN, pszFileName);
		}
		else
		{
			// assume ANSI
			// re-open file in text mode as the stream i/o functions will
			// treat the file as multi-byte characters and will convert them
			// to UNICODE

			fclose(fp);

			fp = _tfopen(pszFileName, _T("rt"));

			if (fp == NULL)
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_FILE_OPEN, pszFileName);
			}
		}
	}
	else
	{
		fclose(fp);
		ThrowError(E_INVALIDARG, IDS_E_OPTION_FILE_READ_SIGNATURE, pszFileName);
	}

	return fp;
}


// FindTask Method

int CParameterMap::FindTask(FILE* fp)
{
	int nTask = -1;

	_TCHAR szBuffer[1024];

	while (_fgetts(szBuffer, countof(szBuffer), fp))
	{
		_TCHAR szTask[64];
		
		if (_stscanf(szBuffer, _T(" [ %63[A-Za-z] ] "), szTask) == 1)
		{
		//	_tprintf(_T("FindTask() : '%s'\n"), szTask);

			if (_tcsicmp(szTask, _T("Migration")) == 0)
			{
				nTask = TASK_NONE;
				break;
			}

			if (_tcsicmp(szTask, _T("UserMigration")) == 0)
			{
				nTask = TASK_USER;
				break;
			}

			if (_tcsicmp(szTask, _T("GroupMigration")) == 0)
			{
				nTask = TASK_GROUP;
				break;
			}

			if (_tcsicmp(szTask, _T("ComputerMigration")) == 0)
			{
				nTask = TASK_COMPUTER;
				break;
			}

			if (_tcsicmp(szTask, _T("SecurityTranslation")) == 0)
			{
				nTask = TASK_SECURITY;
				break;
			}

			if (_tcsicmp(szTask, _T("ReportGeneration")) == 0)
			{
				nTask = TASK_REPORT;
				break;
			}
		}
	}

	return nTask;
}


// DoTask Method

void CParameterMap::DoTask(FILE* fp, CSwitchMap& mapSwitchs)
{
	_TCHAR szBuffer[8192];

	for (;;)
	{
		long lOffset = ftell(fp);

		if (_fgetts(szBuffer, countof(szBuffer), fp) == NULL)
		{
			break;
		}

		_TCHAR szTask[64];

		if (_stscanf(szBuffer, _T(" [ %63[A-Za-z] ] "), szTask) == 1)
		{
			fseek(fp, lOffset, SEEK_SET);
			break;
		}

		_TCHAR szName[64];
		_TCHAR szValue[4096];

		try
		{
			if ((szBuffer[0] != _T(';')) && (_stscanf(szBuffer, _T(" %63[A-Za-z] = %4095[^\r\n]"), szName, szValue) == 2))
			{
			//	_tprintf(_T("DoTask() : %s='%s'\n"), szName, szValue);

				CSwitchMap::iterator it = mapSwitchs.find(_bstr_t(szName));

				if ((it != mapSwitchs.end()) && (it->second != SWITCH_TASK))
				{
					DoParameter(it->second, szValue);
				}
			}
		}
		catch (_com_error& ce)
		{
			ThrowError(ce, IDS_CANT_GET_OPTION_VALUE, szName, szValue);
		}
		catch (...)
		{
			ThrowError(E_FAIL, IDS_CANT_GET_OPTION_VALUE, szName, szValue);
		}
	}
}


// DoParameter Method

void CParameterMap::DoParameter(int nSwitch, LPCTSTR pszValue)
{
	_variant_t& vntValue = Insert(nSwitch);

	switch (nSwitch)
	{
		// boolean values

		case SWITCH_TEST_MIGRATION:
		case SWITCH_INTRA_FOREST:
		case SWITCH_MIGRATE_SIDS:
		case SWITCH_TRANSLATE_ROAMING_PROFILE:
		case SWITCH_UPDATE_USER_RIGHTS:
		case SWITCH_MIGRATE_GROUPS:
		case SWITCH_UPDATE_PREVIOUSLY_MIGRATED_OBJECTS:
		case SWITCH_FIX_GROUP_MEMBERSHIP:
		case SWITCH_MIGRATE_SERVICE_ACCOUNTS:
		case SWITCH_UPDATE_GROUP_RIGHTS:
		case SWITCH_MIGRATE_MEMBERS:
		case SWITCH_TRANSLATE_FILES_AND_FOLDERS:
		case SWITCH_TRANSLATE_LOCAL_GROUPS:
		case SWITCH_TRANSLATE_PRINTERS:
		case SWITCH_TRANSLATE_REGISTRY:
		case SWITCH_TRANSLATE_SHARES:
		case SWITCH_TRANSLATE_USER_PROFILES:
		case SWITCH_TRANSLATE_USER_RIGHTS:
		{
			vntValue = GetBoolFromName(pszValue, s_BoolValues);
			break;
		}

		// long values

		case SWITCH_RENAME_OPTION:
		{
			vntValue = GetLongFromName(pszValue, s_RenameOptionValues);
			break;
		}
		case SWITCH_PASSWORD_OPTION:
		{
			vntValue = GetLongFromName(pszValue, s_PasswordOptionValues);
			break;
		}
		case SWITCH_CONFLICT_OPTIONS:
		{
			_TCHAR szValueA[32];
			_TCHAR szValueB[32];
			_TCHAR szValueC[32];
			_TCHAR szValueD[32];

			int cFields = _stscanf(pszValue, _T("%31[A-Za-z] + %31[A-Za-z] + %31[A-Za-z] + %31[A-Za-z]"), szValueA, szValueB, szValueC, szValueD);

			if (cFields <= 0)
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_INVALID);
			}

			long lValue = GetLongFromName(szValueA, s_ConflictOptionValues);

			if (cFields >= 2)
			{
				lValue |= GetLongFromName(szValueB, s_ConflictOptionFlagValues);
			}

			if (cFields >= 3)
			{
				lValue |= GetLongFromName(szValueC, s_ConflictOptionFlagValues);
			}

			if (cFields >= 4)
			{
				lValue |= GetLongFromName(szValueD, s_ConflictOptionFlagValues);
			}

			vntValue = lValue;
			break;
		}
		case SWITCH_DISABLE_OPTION:
		{
			_TCHAR szValueA[32];
			_TCHAR szValueB[32];

			int cFields = _stscanf(pszValue, _T("%31[A-Za-z] + %31[A-Za-z]"), szValueA, szValueB);

			if (cFields <= 0)
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_FORMAT_INVALID, pszValue);
			}

			long lValue = GetLongFromName(szValueA, s_DisableOptionValues);

			if (cFields >= 2)
			{
				lValue |= GetLongFromName(szValueB, s_DisableOptionValues);
			}

			vntValue = lValue;
			break;
		}
		case SWITCH_SOURCE_EXPIRATION:
		{
			long lValue;
			_TCHAR szValue[32];

			if (_stscanf(pszValue, _T("%31[A-Za-z]"), szValue) == 1)
			{
				vntValue = GetLongFromName(szValue, s_SourceExpirationValues);
			}
			else if (_stscanf(pszValue, _T("%ld"), &lValue) == 1)
			{
				vntValue = lValue;
			}
			else
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_INVALID);
			}
			break;
		}
		case SWITCH_TRANSLATION_OPTION:
		{
			vntValue = GetLongFromName(pszValue, s_TranslationOptionValues);
			break;
		}
		case SWITCH_RESTART_DELAY:
		{
			long lValue;

			if (_stscanf(pszValue, _T("%ld"), &lValue) == 1)
			{
				vntValue = lValue;
			}
			else
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_INVALID);
			}
			break;
		}
		case SWITCH_REPORT_TYPE:
		{
			vntValue = GetLongFromName(pszValue, s_ReportTypeValues);
			break;
		}

		// string values

		case SWITCH_SOURCE_DOMAIN:
		case SWITCH_SOURCE_OU:
		case SWITCH_TARGET_DOMAIN:
		case SWITCH_TARGET_OU:
		case SWITCH_RENAME_PREFIX_OR_SUFFIX:
		case SWITCH_PASSWORD_SERVER:
		case SWITCH_PASSWORD_FILE:
		case SWITCH_CONFLICT_PREFIX_OR_SUFFIX:
		case SWITCH_USER_PROPERTIES_TO_EXCLUDE:
		case SWITCH_GROUP_PROPERTIES_TO_EXCLUDE:
		case SWITCH_COMPUTER_PROPERTIES_TO_EXCLUDE:
		case SWITCH_SID_MAPPING_FILE:
		case SWITCH_REPORT_FOLDER:
		{
			_TCHAR szValue[2048];

			UINT cch = _tcslen(pszValue);

			if (cch > 2047)
			{
				ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_TOO_LONG);
			}

			_tcscpy(szValue, pszValue);

			if ((szValue[0] == _T('"')) && (szValue[cch - 1] == _T('"')))
			{
				szValue[cch - 1] = _T('\0');
				vntValue = &szValue[1];
			}
			else
			{
				vntValue = szValue;
			}
			break;
		}

		// default

		default:
		{
			_ASSERT(false);
			break;
		}
	}
}


// DoTaskKey Method

void CParameterMap::DoTaskKey(CArguments& rArgs)
{
	// key identifier

	LPCTSTR pszKeyId = NULL;

	if (rArgs.Next())
	{
		pszKeyId = rArgs.Value();

		_TCHAR chPrefix;
		_TCHAR szSwitch[16];

		if ((_stscanf(pszKeyId, _T(" %c%15s "), &chPrefix, szSwitch) == 2) && IsPrefix(chPrefix) && (m_mapSwitchs.GetSwitch(szSwitch) == SWITCH_HELP))
		{
			insert(value_type(SWITCH_HELP, _variant_t(true)));
		}
		else
		{
			insert(value_type(SWITCH_KEY_IDENTIFIER, _variant_t(pszKeyId)));

			// drive

			if (rArgs.Next())
			{
				insert(value_type(SWITCH_KEY_FOLDER, _variant_t(rArgs.Value())));

				// password

				_bstr_t strPassword;

				if (rArgs.Next())
				{
					strPassword = rArgs.Value();
				}

				if (strPassword.length() > 0)
				{
					if (_tcscmp(strPassword, _T("*")) == 0)
					{
						if (!GetPasswordFromUser(pszKeyId, strPassword))
						{
							ThrowError(E_FAIL, IDS_E_CANT_GET_PASSWORD);
						}
					}
				}

				insert(value_type(SWITCH_KEY_PASSWORD, _variant_t(strPassword)));
			}
		}
	}

	if (pszKeyId == NULL)
	{
		insert(value_type(SWITCH_HELP, _variant_t(true)));
	}
}


// VerifyIncludeExclude Method

void CParameterMap::VerifyIncludeExclude()
{
	// verify that only one include option type was specified

	int cInclude = 0;

	if (find(SWITCH_INCLUDE_NAME) != end())
	{
		++cInclude;
	}

	if (find(SWITCH_INCLUDE_FILE) != end())
	{
		++cInclude;
	}

	if (find(SWITCH_INCLUDE_DOMAIN) != end())
	{
		++cInclude;
	}

	if (cInclude > 1)
	{
		ThrowError(E_INVALIDARG, IDS_E_MULTIPLE_INCLUDE_OPTIONS);
	}

	// verify that only one exclude option type was specified

	if ((find(SWITCH_EXCLUDE_NAME) != end()) && (find(SWITCH_EXCLUDE_FILE) != end()))
	{
		ThrowError(E_INVALIDARG, IDS_E_MULTIPLE_EXCLUDE_OPTIONS);
	}
}


namespace Parameter_cpp
{


// GetBoolValue Method

bool GetBoolValue(LPCTSTR pszArg)
{
	bool bValue;

	try
	{
		_TCHAR szValue[16];

		if (_stscanf(pszArg, _T("%*[^:]: %15[A-Za-z]"), szValue) == 1)
		{
			bValue = GetBoolFromName(szValue, s_BoolValues);
		}
		else
		{
			ThrowError(E_INVALIDARG, IDS_E_OPTION_FORMAT_INVALID2, pszArg);
		}
	}
	catch (_com_error& ce)
	{
		ThrowError(ce, IDS_E_CANT_GET_OPTION_VALUE2, pszArg);
	}
	catch (...)
	{
		ThrowError(E_FAIL, IDS_E_CANT_GET_OPTION_VALUE2, pszArg);
	}

	return bValue;
}


// GetBoolFromName Method

bool GetBoolFromName(LPCTSTR pszName, SNameToBool* pNameToBool)
{
	bool bValue;

	bool bFound = false;

	for (SNameToBool* p = pNameToBool; p->pszName; p++)
	{
		if (_tcsicmp(p->pszName, pszName) == 0)
		{
			bValue = p->bValue;
			bFound = true;
			break;
		}
	}

	if (!bFound)
	{
		ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_UNRECOGNIZED, pszName);
	}

	return bValue;
}


// GetLongValue Method

long GetLongValue(LPCTSTR pszArg, SNameToLong* pNameToLong)
{
	long lValue;

	try
	{
		_TCHAR szValue[32];

		if (_stscanf(pszArg, _T("%*[^:]: %31[A-Za-z]"), szValue) == 1)
		{
			lValue = GetLongFromName(szValue, pNameToLong);
		}
		else
		{
			ThrowError(E_INVALIDARG, IDS_E_OPTION_FORMAT_INVALID2, pszArg);
		}
	}
	catch (_com_error& ce)
	{
		ThrowError(ce, IDS_E_CANT_GET_OPTION_VALUE2, pszArg);
	}
	catch (...)
	{
		ThrowError(E_FAIL, IDS_E_CANT_GET_OPTION_VALUE2, pszArg);
	}

	return lValue;
}


// GetLongFromName Method

long GetLongFromName(LPCTSTR pszName, SNameToLong* pNameToLong)
{
	long lValue;

	bool bFound = false;

	for (SNameToLong* p = pNameToLong; p->pszName; p++)
	{
		if (_tcsicmp(p->pszName, pszName) == 0)
		{
			lValue = p->lValue;
			bFound = true;
			break;
		}
	}

	if (!bFound)
	{
		ThrowError(E_INVALIDARG, IDS_E_OPTION_VALUE_UNRECOGNIZED, pszName);
	}

	return lValue;
}


// GetPasswordFromUser Method

bool GetPasswordFromUser(LPCTSTR pszKeyId, _bstr_t& strPassword)
{
	bool bGet = false;

	#define BUFFER_SIZE 32

	_bstr_t strFormat[2];
	strFormat[0] = LoadStringHelper(IDS_TYPE_PASSWORD);
	strFormat[1] = LoadStringHelper(IDS_CONFIRM_PASSWORD);

	_TCHAR szPassword[2][BUFFER_SIZE];
	szPassword[0][0] = _T('\0');
	szPassword[1][0] = _T('\0');

	HANDLE hInput = GetStdHandle(STD_INPUT_HANDLE);
	HANDLE hOutput = GetStdHandle(STD_OUTPUT_HANDLE);

	if (hInput != INVALID_HANDLE_VALUE)
	{
		DWORD dwMode;

		if (GetConsoleMode(hInput, &dwMode))
		{
			if (SetConsoleMode(hInput, ENABLE_PROCESSED_INPUT))
			{
				while (bGet == false)
				{
					for (int nPass = 0; nPass < 2; nPass++)
					{
						_tprintf(strFormat[nPass], pszKeyId);

						_TCHAR ch;
						DWORD dwRead;
						int nIndex = 0;

						while (ReadConsole(hInput, &ch, 1, &dwRead, NULL))
						{
							if ((ch == _T('\r')) || (ch == _T('\n')))
							{
								break;
							}
							else if (ch == _T('\b'))
							{
								if (nIndex > 0)
								{
									CONSOLE_SCREEN_BUFFER_INFO csbi;

									if (GetConsoleScreenBufferInfo(hOutput, &csbi))
									{
										--csbi.dwCursorPosition.X;

										if (SetConsoleCursorPosition(hOutput, csbi.dwCursorPosition))
										{
											--nIndex;

											DWORD dwWritten;
											WriteConsole(hOutput, _T(" "), 1, &dwWritten, NULL);
											SetConsoleCursorPosition(hOutput, csbi.dwCursorPosition);
										}
									}
								}
							}
							else if ((nIndex < BUFFER_SIZE - 1) && _istprint(ch))
							{
								szPassword[nPass][nIndex++] = ch;

								DWORD dwWritten;
								WriteConsole(hOutput, _T("*"), 1, &dwWritten, NULL);
							}
						}

						_puttchar(_T('\n'));

						szPassword[nPass][nIndex] = _T('\0');
					}

					if (_tcscmp(szPassword[0], szPassword[1]) == 0)
					{
						strPassword = szPassword[0];
						bGet = true;
						break;
					}
				}
			}
			
			SetConsoleMode(hInput, dwMode);
		}
	}

	return bGet;
}


_bstr_t LoadStringHelper(UINT uId)
{
	_TCHAR szBuffer[1024];

	if (LoadString(GetModuleHandle(NULL), uId, szBuffer, countof(szBuffer)) <= 0)
	{
		szBuffer[0] = _T('\0');
	}

	return szBuffer;
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\command\monitorthread.cpp ===
#include "StdAfx.h"
#include "MonitorThread.h"


namespace nsMonitorThread
{

_bstr_t GetLogFolder();

}

using namespace nsMonitorThread;


//---------------------------------------------------------------------------
// MonitorThread Class
//---------------------------------------------------------------------------


// Constructor

CMonitorThread::CMonitorThread() :
	m_hMigrationLog(NULL)
{
	SYSTEMTIME st;
	GetSystemTime(&st);
	
	if (!SystemTimeToFileTime(&st, &m_ftMigrationLogLastWriteTime))
	{
		m_ftMigrationLogLastWriteTime.dwLowDateTime = 0;
		m_ftMigrationLogLastWriteTime.dwHighDateTime = 0;
	}
}


// Destructor

CMonitorThread::~CMonitorThread()
{
}


// Start Method

void CMonitorThread::Start()
{
	CThread::StartThread();
}


// Stop Method

void CMonitorThread::Stop()
{
	CThread::StopThread();
}


// Run Method

void CMonitorThread::Run()
{
	try
	{
		_bstr_t strFolder = GetLogFolder();

		if (strFolder.length() > 0)
		{
			m_strMigrationLog = strFolder + _T("Migration.log");

			HANDLE hChange = FindFirstChangeNotification(strFolder, FALSE, FILE_NOTIFY_CHANGE_LAST_WRITE);

			HANDLE hHandles[2] = { StopEvent(), hChange };

			while (WaitForMultipleObjects(2, hHandles, FALSE, INFINITE) == (WAIT_OBJECT_0 + 1))
			{
				ProcessMigrationLog();

				FindNextChangeNotification(hChange);
			}

			FindCloseChangeNotification(hChange);

			ProcessMigrationLog();

			if (m_hMigrationLog)
			{
				CloseHandle(m_hMigrationLog);
			}
		}
	}
	catch (...)
	{
		;
	}
}


// ProcessMigrationLog Method

void CMonitorThread::ProcessMigrationLog()
{
	if (m_hMigrationLog == NULL)
	{
		m_hMigrationLog = CreateFile(
			m_strMigrationLog,
			GENERIC_READ,
			FILE_SHARE_READ|FILE_SHARE_WRITE,
			NULL,
			OPEN_EXISTING,
			FILE_ATTRIBUTE_NORMAL,
			NULL
		);

		if (m_hMigrationLog)
		{
			_TCHAR ch;
			DWORD dwBytesRead;

			if (ReadFile(m_hMigrationLog, &ch, sizeof(ch), &dwBytesRead, NULL) && (dwBytesRead > 0))
			{
				if (ch != _T('\xFEFF'))
				{
					SetFilePointer(m_hMigrationLog, 0, NULL, FILE_BEGIN);
				}
			}
		}
	}

	if (m_hMigrationLog)
	{
		BY_HANDLE_FILE_INFORMATION bhfiInformation;

		if (GetFileInformationByHandle(m_hMigrationLog, &bhfiInformation))
		{
			if (CompareFileTime(&bhfiInformation.ftLastWriteTime, &m_ftMigrationLogLastWriteTime) == 1)
			{
				m_ftMigrationLogLastWriteTime = bhfiInformation.ftLastWriteTime;

				HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

				_TCHAR szBuffer[1024];
				DWORD dwBytesRead;

				while (ReadFile(m_hMigrationLog, szBuffer, sizeof(szBuffer), &dwBytesRead, NULL) && (dwBytesRead > 0))
				{
					DWORD dwCharsWritten;

					WriteConsole(hStdOut, szBuffer, dwBytesRead / sizeof(_TCHAR), &dwCharsWritten, NULL);
				}
			}
		}
	}
}


namespace nsMonitorThread
{


// GetLogFolder Method

_bstr_t GetLogFolder()
{
	_bstr_t strFolder;

	HKEY hKey;

	DWORD dwError = RegOpenKey(HKEY_LOCAL_MACHINE, _T("Software\\Mission Critical Software\\DomainAdmin"), &hKey);

	if (dwError == ERROR_SUCCESS)
	{
		_TCHAR szPath[_MAX_PATH];
		DWORD cbPath = sizeof(szPath);

		dwError = RegQueryValueEx(hKey, _T("Directory"), NULL, NULL, (LPBYTE)szPath, &cbPath);

		if (dwError == ERROR_SUCCESS)
		{
			_TCHAR szDrive[_MAX_DRIVE];
			_TCHAR szDir[_MAX_DIR];

			_tsplitpath(szPath, szDrive, szDir, NULL, NULL);
			_tcscat(szDir, _T("Logs"));
			_tmakepath(szPath, szDrive, szDir, NULL, NULL);

			strFolder = szPath;
		}

		RegCloseKey(hKey);
	}

	return strFolder;
}


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\command\parameter.h ===
#pragma once

#include "Resource.h"
#include <map>

#ifndef StringVector
#include <vector>
typedef std::vector<_bstr_t> StringVector;
#endif

#include "Argument.h"
#include "Switch.h"


enum ETask
{
	TASK_NONE,
	TASK_USER,
	TASK_GROUP,
	TASK_COMPUTER,
	TASK_SECURITY,
	TASK_SERVICE,
	TASK_REPORT,
	TASK_KEY,
};


//---------------------------------------------------------------------------
// Parameter Map
//---------------------------------------------------------------------------


class CParameterMap :
	public std::map<int, _variant_t>
{
public:

	CParameterMap(CArguments& rArgs)
	{
		Initialize(rArgs);
	}

	bool IsExist(int nParam)
	{
		return (find(nParam) != end());
	}

	bool GetValue(int nParam, bool& bValue);
	bool GetValue(int nParam, long& lValue);
	bool GetValue(int nParam, _bstr_t& strValue);

	bool GetValues(int nParam, _variant_t& vntValues);
	bool GetValues(int nParam, StringVector& vecValues);

protected:

	void Initialize(CArguments& rArgs);

	bool DoTask(LPCTSTR pszArg);
	void DoSwitches(CArguments& rArgs);
	void DoSwitch(int nSwitch, CArguments& rArgs);

	_variant_t& Insert(int nParam);

	void DoOptionFile(LPCTSTR pszFileName);
	FILE* OpenOptionFile(LPCTSTR pszFileName);
	int FindTask(FILE* fp);
	void DoTask(FILE* fp, CSwitchMap& mapSwitchs);
	void DoParameter(int nSwitch, LPCTSTR pszValue);
	void DoTaskKey(CArguments& rArgs);
	void VerifyIncludeExclude();

protected:

	CSwitchMap m_mapSwitchs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\command\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Command.rc
//
#define IDS_E_NOT_LOCAL_DRIVE           1
#define IDS_E_CANT_CREATE_FILE          2
#define IDS_E_CANT_WRITE_FILE           3
#define IDS_E_INVALID_FIRST_ARGUMENT    4
#define IDS_E_NO_KEY_DOMAIN             5
#define IDS_E_NO_KEY_FOLDER             6
#define IDS_TYPE_PASSWORD               7
#define IDS_CONFIRM_PASSWORD            8
#define IDS_E_CANT_GET_PASSWORD         9
#define IDS_E_OPTION_UNRECOGNIZED       10
#define IDS_E_TASK_NOT_FIRST            11
#define IDS_E_INVALID_OPTION_FORMAT     12
#define IDS_E_NO_ARGUMENTS              13
#define IDS_E_OPTION_FORMAT_INVALID     14
#define IDS_E_NO_OPTION_VALUE           15
#define IDS_CANT_GET_OPTION_VALUE       16
#define IDS_E_OPTION_VALUE_INVALID      17
#define IDS_E_OPTION_VALUE_TOO_LONG     18
#define IDS_E_OPTION_FORMAT_INVALID2    19
#define IDS_E_CANT_GET_OPTION_VALUE2    20
#define IDS_E_OPTION_VALUE_UNRECOGNIZED 21
#define IDS_E_MULTIPLE_INCLUDE_OPTIONS  22
#define IDS_E_MULTIPLE_EXCLUDE_OPTIONS  23
#define IDS_E_OPTION_FILE_OPEN          24
#define IDS_E_OPTION_FILE_READ_SIGNATURE 25
#define IDS_E_OPTION_FILE_UNICODE_BIG_ENDIAN 26
#define IDS_E_OPTION_FILE_UTF_8         27
#define IDS_E_OPTION_FILE_TASK          28
#define IDS_E_NO_INCLUDE_OPTION_SPECIFIED 29
#define IDS_USAGE_SYNTAX                49
#define IDS_USAGE_ADMT                  50
#define IDS_USAGE_USER                  51
#define IDS_USAGE_GROUP                 52
#define IDS_USAGE_COMPUTER              53
#define IDS_USAGE_SECURITY              54
#define IDS_USAGE_SERVICE               55
#define IDS_USAGE_REPORT                56
#define IDS_USAGE_KEY                   57
#define IDS_USAGE_OPTIONFILE            58
#define IDS_USAGE_INCLUDE_A             59
#define IDS_USAGE_INCLUDE_B             60
#define IDS_USAGE_INCLUDE_C             61
#define IDS_USAGE_INCLUDE_D             62
#define IDS_USAGE_EXCLUDE               63
#define IDS_USAGE_TESTMIGRATION         64
#define IDS_USAGE_INTRAFOREST           65
#define IDS_USAGE_SOURCEDOMAIN          66
#define IDS_USAGE_SOURCEOU              67
#define IDS_USAGE_TARGETDOMAIN          68
#define IDS_USAGE_TARGETOU              69
#define IDS_USAGE_RENAMEOPTION          70
#define IDS_USAGE_RENAMEPREFIXORSUFFIX  71
#define IDS_USAGE_PASSWORDOPTION        72
#define IDS_USAGE_PASSWORDSERVER        73
#define IDS_USAGE_PASSWORDFILE          74
#define IDS_USAGE_CONFLICTOPTIONS_U     75
#define IDS_USAGE_CONFLICTOPTIONS_G     76
#define IDS_USAGE_CONFLICTOPTIONS_C     77
#define IDS_USAGE_CONFLICTPREFIXORSUFFIX 78
#define IDS_USAGE_USERPROPERTIESTOEXCLUDE 79
#define IDS_USAGE_GROUPPROPERTIESTOEXCLUDE 80
#define IDS_USAGE_COMPUTERPROPERTIESTOEXCLUDE 81
#define IDS_USAGE_DISABLEOPTION         82
#define IDS_USAGE_SOURCEEXPIRATION      83
#define IDS_USAGE_MIGRATESIDS           84
#define IDS_USAGE_TRANSLATEROAMINGPROFILE 85
#define IDS_USAGE_UPDATEUSERRIGHTS      86
#define IDS_USAGE_MIGRATEGROUPS         87
#define IDS_USAGE_UPDATEPREVIOUSLYMIGRATEDOBJECTS 88
#define IDS_USAGE_FIXGROUPMEMBERSHIP    89
#define IDS_USAGE_UPDATEGROUPRIGHTS     90
#define IDS_USAGE_MIGRATEMEMBERS        91
#define IDS_USAGE_TRANSLATIONOPTION     92
#define IDS_USAGE_TRANSLATEFILESANDFOLDERS 93
#define IDS_USAGE_TRANSLATELOCALGROUPS  94
#define IDS_USAGE_TRANSLATEPRINTERS     95
#define IDS_USAGE_TRANSLATEREGISTRY     96
#define IDS_USAGE_TRANSLATESHARES       97
#define IDS_USAGE_TRANSLATEUSERPROFILES 98
#define IDS_USAGE_TRANSLATEUSERRIGHTS   99
#define IDS_USAGE_RESTARTDELAY          100
#define IDS_USAGE_SIDMAPPINGFILE        101
#define IDS_USAGE_REPORTTYPE            102
#define IDS_USAGE_REPORTFOLDER          103
#define IDS_USAGE_FOOTER                104
#define IDS_E_INVALID_FOLDER            105
#define IDS_USAGE_MIGRATESERVICEACCOUNTS 106

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\command\stdafx.cpp ===
#include "StdAfx.h"

#import <MsPwdMig.tlb> no_namespace implementation_only
#import <ADMTScript.tlb> no_namespace implementation_only


// ThrowError Methods -----------------------------------------------

namespace
{

void __stdcall ThrowErrorImpl(const _com_error& ce, LPCTSTR pszDescription)
{
	_bstr_t bstrNewDescription;

	try
	{
		bstrNewDescription = pszDescription;

		_bstr_t bstrSource = ce.Source();

		if (bstrSource.length() > 0)
		{
			if (bstrNewDescription.length() > 0)
			{
				bstrNewDescription += _T(" : ");
			}

			bstrNewDescription += bstrSource;
		}

		_bstr_t bstrOldDescription = ce.Description();

		if (bstrOldDescription.length() > 0)
		{
			if (bstrNewDescription.length() > 0)
			{
				if (bstrSource.length() > 0)
				{
					bstrNewDescription += _T(": ");
				}
				else
				{
					bstrNewDescription += _T(" ");
				}
			}

			bstrNewDescription += bstrOldDescription;
		}
	//	else
	//	{
	//		LPCTSTR pszErrorMessage = ce.ErrorMessage();

	//		if (pszErrorMessage)
	//		{
	//			if (bstrNewDescription.length() > 0)
	//			{
	//				bstrNewDescription += _T(" : ");
	//			}

	//			bstrNewDescription += pszErrorMessage;
	//		}
	//	}
	}
	catch (...)
	{
		;
	}

	ICreateErrorInfoPtr spCreateErrorInfo;
	CreateErrorInfo(&spCreateErrorInfo);

	if (spCreateErrorInfo)
	{
		spCreateErrorInfo->SetSource(L"");
		spCreateErrorInfo->SetGUID(GUID_NULL);
		spCreateErrorInfo->SetDescription(bstrNewDescription);
		spCreateErrorInfo->SetHelpFile(L"");
		spCreateErrorInfo->SetHelpContext(0);
	}

	_com_raise_error(ce.Error(), IErrorInfoPtr(spCreateErrorInfo).Detach());
}

}


void __cdecl ThrowError(_com_error ce, LPCTSTR pszFormat, ...)
{
	_TCHAR szDescription[1024];

	if (pszFormat)
	{
		va_list args;
		va_start(args, pszFormat);
		_vsntprintf(szDescription, countof(szDescription), pszFormat, args);
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	ThrowErrorImpl(ce, szDescription);
}


void __cdecl ThrowError(_com_error ce, UINT uId, ...)
{
	_TCHAR szFormat[512];
	_TCHAR szDescription[1024];

	if (LoadString(GetModuleHandle(NULL), uId, szFormat, countof(szFormat)) > 0)
	{
		va_list args;
		va_start(args, uId);
		_vsntprintf(szDescription, countof(szDescription), szFormat, args);
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	ThrowErrorImpl(ce, szDescription);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\command\stdafx.h ===
#pragma once

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif

#pragma warning(disable : 4786)

#ifdef _DEBUG
//#define _CRTDBG_MAP_ALLOC
#include <stdlib.h>
#define DEBUG_NEW new(_NORMAL_BLOCK, THIS_FILE, __LINE__)
//#define _ATL_DEBUG_INTERFACES
#endif

#include <windows.h>
#include <winnls.h>
#include <ole2.h>
#include <tchar.h>
#include <crtdbg.h>

#import <MsPwdMig.tlb> no_namespace no_implementation
#import <ADMTScript.tlb> no_namespace no_implementation

#define countof(a) (sizeof(a) / sizeof(a[0]))

void __cdecl ThrowError(_com_error ce, UINT uId, ...);
void __cdecl ThrowError(_com_error ce, LPCTSTR pszFormat = NULL, ...);

//{{AFX_INSERT_LOCATION}}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\command\switch.cpp ===
#include "StdAfx.h"
#include "Switch.h"


namespace
{


//---------------------------------------------------------------------------
// Switch Text Structure
//---------------------------------------------------------------------------


struct SSwitchText
{
	int nSwitch;
	LPCTSTR pszText;
};


const SSwitchText s_SwitchText[] =
{
	// tasks
	{ SWITCH_TASK,                               _T("user,group,computer,security,service,report,key") },
	// general task options
	{ SWITCH_OPTION_FILE,                        _T("o,OptionFile") },
	{ SWITCH_TEST_MIGRATION,                     _T("tm,TestMigration") },
	{ SWITCH_INTRA_FOREST,                       _T("if,IntraForest") },
	{ SWITCH_SOURCE_DOMAIN,                      _T("sd,SourceDomain") },
	{ SWITCH_SOURCE_OU,                          _T("so,SourceOu") },
	{ SWITCH_TARGET_DOMAIN,                      _T("td,TargetDomain") },
	{ SWITCH_TARGET_OU,                          _T("to,TargetOu") },
	{ SWITCH_RENAME_OPTION,                      _T("ro,RenameOption") },
	{ SWITCH_RENAME_PREFIX_OR_SUFFIX,            _T("rt,RenamePrefixOrSuffix") },
	{ SWITCH_PASSWORD_OPTION,                    _T("po,PasswordOption") },
	{ SWITCH_PASSWORD_SERVER,                    _T("ps,PasswordServer") },
	{ SWITCH_PASSWORD_FILE,                      _T("pf,PasswordFile") },
	{ SWITCH_CONFLICT_OPTIONS,                   _T("co,ConflictOptions") },
	{ SWITCH_CONFLICT_PREFIX_OR_SUFFIX,          _T("ct,ConflictPrefixOrSuffix") },
	{ SWITCH_USER_PROPERTIES_TO_EXCLUDE,         _T("ux,UserPropertiesToExclude") },
	{ SWITCH_GROUP_PROPERTIES_TO_EXCLUDE,        _T("gx,GroupPropertiesToExclude") },
	{ SWITCH_COMPUTER_PROPERTIES_TO_EXCLUDE,     _T("cx,ComputerPropertiesToExclude") },
	// specific task options
	{ SWITCH_DISABLE_OPTION,                     _T("dot,DisableOption") },
	{ SWITCH_SOURCE_EXPIRATION,                  _T("sep,SourceExpiration") },
	{ SWITCH_MIGRATE_SIDS,                       _T("mss,MigrateSids") },
	{ SWITCH_TRANSLATE_ROAMING_PROFILE,          _T("trp,TranslateRoamingProfile") },
	{ SWITCH_UPDATE_USER_RIGHTS,                 _T("uur,UpdateUserRights") },
	{ SWITCH_MIGRATE_GROUPS,                     _T("mgs,MigrateGroups") },
	{ SWITCH_UPDATE_PREVIOUSLY_MIGRATED_OBJECTS, _T("umo,UpdatePreviouslyMigratedObjects") },
	{ SWITCH_FIX_GROUP_MEMBERSHIP,               _T("fgm,FixGroupMembership") },
	{ SWITCH_MIGRATE_SERVICE_ACCOUNTS,           _T("msa,MigrateServiceAccounts") },
	{ SWITCH_UPDATE_GROUP_RIGHTS,                _T("ugr,UpdateGroupRights") },
	{ SWITCH_MIGRATE_MEMBERS,                    _T("mms,MigrateMembers") },
	{ SWITCH_TRANSLATION_OPTION,                 _T("tot,TranslationOption") },
	{ SWITCH_TRANSLATE_FILES_AND_FOLDERS,        _T("tff,TranslateFilesAndFolders") },
	{ SWITCH_TRANSLATE_LOCAL_GROUPS,             _T("tlg,TranslateLocalGroups") },
	{ SWITCH_TRANSLATE_PRINTERS,                 _T("tps,TranslatePrinters") },
	{ SWITCH_TRANSLATE_REGISTRY,                 _T("trg,TranslateRegistry") },
	{ SWITCH_TRANSLATE_SHARES,                   _T("tss,TranslateShares") },
	{ SWITCH_TRANSLATE_USER_PROFILES,            _T("tup,TranslateUserProfiles") },
	{ SWITCH_TRANSLATE_USER_RIGHTS,              _T("tur,TranslateUserRights") },
	{ SWITCH_RESTART_DELAY,                      _T("rdl,RestartDelay") },
	{ SWITCH_SID_MAPPING_FILE,                   _T("smf,SidMappingFile") },
	{ SWITCH_REPORT_TYPE,                        _T("rpt,ReportType") },
	{ SWITCH_REPORT_FOLDER,                      _T("rpf,ReportFolder") },
	// include switches
	{ SWITCH_INCLUDE_NAME,                       _T("n,IncludeName") },
	{ SWITCH_INCLUDE_FILE,                       _T("f,IncludeFile") },
	{ SWITCH_INCLUDE_DOMAIN,                     _T("d,IncludeDomain") },
	// exclude switches
	{ SWITCH_EXCLUDE_NAME,                       _T("en,ExcludeName") },
	{ SWITCH_EXCLUDE_FILE,                       _T("ef,ExcludeFile") },
	// help
	{ SWITCH_HELP,                               _T("?,h,help") },
};

const UINT SWITCH_COUNT = countof(s_SwitchText);


}


//---------------------------------------------------------------------------
// Switch Map
//---------------------------------------------------------------------------


// constructor

CSwitchMap::CSwitchMap()
{
	static const _TCHAR DELIMITERS[] = _T(",");

	_TCHAR szSwitch[256];

	for (UINT i = 0; i < SWITCH_COUNT; i++)
	{
		int nSwitch = s_SwitchText[i].nSwitch;
		_ASSERT(_tcslen(s_SwitchText[i].pszText) < countof(szSwitch));
		_tcscpy(szSwitch, s_SwitchText[i].pszText);

		for (LPTSTR psz = _tcstok(szSwitch, DELIMITERS); psz; psz = _tcstok(NULL, DELIMITERS))
		{
			insert(value_type(_bstr_t(psz), nSwitch));
		}
	}
}


// GetSwitch Method

int CSwitchMap::GetSwitch(LPCTSTR pszSwitch)
{
	int nSwitch = -1;

	iterator it = find(_bstr_t(pszSwitch));

	if (it != end())
	{
		nSwitch = it->second;
	}

	return nSwitch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\agrpcutl.cpp ===
/*---------------------------------------------------------------------------
  File: AgentRpcUtil.cpp

  Comments: Functions to establish binding to DCT Agent service.
  These functions are used by the dispatcher, and the agent monitor 
  to bind to the agent service on remote machines.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 11:23:57

 ---------------------------------------------------------------------------
*/
#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif


// These global variables can be changed if required
TCHAR            const * gsEaDctProtoSeq = (TCHAR const *)TEXT("ncacn_np");
TCHAR            const * gsEaDctEndPoint = (TCHAR const *)TEXT("\\pipe\\EaDctRpc");


// Destroy RPC binding for connection with Agent service
DWORD                                      // ret-OS return code
   EaxBindDestroy(
      handle_t             * phBinding    ,// i/o-binding handle
      TCHAR               ** psBinding     // i/o-binding string
   )
{
   if ( *phBinding )
   {
      RpcBindingFree( phBinding );
      *phBinding = NULL;
   }

   if ( *psBinding )
   {
      RpcStringFree( psBinding );
      *psBinding = NULL;
   }

   return 0;
}




// Create RPC binding for connection with Agent Service
DWORD                                      // ret-OS return code
   EaxBindCreate(
      TCHAR          const * sComputer    ,// in -computer name
      handle_t             * phBinding    ,// out-binding handle
      TCHAR               ** psBinding    ,// out-binding string
      BOOL                   bAuthn        // in -flag whether to use authenticated RPC
   )
{
   DWORD                     rcOs;         // OS return code

   do // once or until break
   {
      EaxBindDestroy( phBinding, psBinding );
      rcOs = RpcStringBindingCompose(
            NULL,
            (TCHAR *) gsEaDctProtoSeq,
            (TCHAR *) sComputer,
            (TCHAR *) gsEaDctEndPoint,
            NULL,
            psBinding );
      if ( rcOs ) break;
      rcOs = RpcBindingFromStringBinding( *psBinding, phBinding );
      if ( rcOs || !bAuthn ) break;
      rcOs = RpcBindingSetAuthInfo(
            *phBinding,
            0,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
            RPC_C_AUTHN_WINNT,
            0,
            0 );
   }  while ( FALSE );

   if ( rcOs )
   {
      EaxBindDestroy( phBinding, psBinding );
   }

   return rcOs;
}



///////////////////////////////////////////////////////////////////////////////
// midl allocate memory
///////////////////////////////////////////////////////////////////////////////

void __RPC_FAR * __RPC_USER
   midl_user_allocate(
      size_t                 len )
{
   return new char[len];
}

///////////////////////////////////////////////////////////////////////////////
// midl free memory
///////////////////////////////////////////////////////////////////////////////

void __RPC_USER
   midl_user_free(
      void __RPC_FAR       * ptr )
{
   delete [] ptr;
   return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\command\switch.h ===
#pragma once

#include <map>
#include "Less.h"


enum ESwitch
{
	// task switch
	SWITCH_TASK,
	// option switches
	SWITCH_OPTION_FILE,
	// migration switches
	SWITCH_TEST_MIGRATION,
	SWITCH_INTRA_FOREST,
	SWITCH_SOURCE_DOMAIN,
	SWITCH_SOURCE_OU,
	SWITCH_TARGET_DOMAIN,
	SWITCH_TARGET_OU,
	SWITCH_RENAME_OPTION,
	SWITCH_RENAME_PREFIX_OR_SUFFIX,
	SWITCH_PASSWORD_OPTION,
	SWITCH_PASSWORD_SERVER,
	SWITCH_PASSWORD_FILE,
	SWITCH_CONFLICT_OPTIONS,
	SWITCH_CONFLICT_PREFIX_OR_SUFFIX,
	SWITCH_USER_PROPERTIES_TO_EXCLUDE,
	SWITCH_GROUP_PROPERTIES_TO_EXCLUDE,
	SWITCH_COMPUTER_PROPERTIES_TO_EXCLUDE,
	// user migration switches
	SWITCH_DISABLE_OPTION,
	SWITCH_SOURCE_EXPIRATION,
	SWITCH_MIGRATE_SIDS,
	SWITCH_TRANSLATE_ROAMING_PROFILE,
	SWITCH_UPDATE_USER_RIGHTS,
	SWITCH_MIGRATE_GROUPS,
	SWITCH_UPDATE_PREVIOUSLY_MIGRATED_OBJECTS,
	SWITCH_FIX_GROUP_MEMBERSHIP,
	SWITCH_MIGRATE_SERVICE_ACCOUNTS,
	// group migration switches
//	SWITCH_MIGRATE_SIDS,
	SWITCH_UPDATE_GROUP_RIGHTS,
//	SWITCH_UPDATE_PREVIOUSLY_MIGRATED_OBJECTS,
//	SWITCH_FIX_GROUP_MEMBERSHIP,
	SWITCH_MIGRATE_MEMBERS,
//	SWITCH_DISABLE_OPTION,
//	SWITCH_SOURCE_EXPIRATION,
//	SWITCH_TRANSLATE_ROAMING_PROFILE,
	// computer migration switches
	SWITCH_TRANSLATION_OPTION,
	SWITCH_TRANSLATE_FILES_AND_FOLDERS,
	SWITCH_TRANSLATE_LOCAL_GROUPS,
	SWITCH_TRANSLATE_PRINTERS,
	SWITCH_TRANSLATE_REGISTRY,
	SWITCH_TRANSLATE_SHARES,
	SWITCH_TRANSLATE_USER_PROFILES,
	SWITCH_TRANSLATE_USER_RIGHTS,
	SWITCH_RESTART_DELAY,
	// security translation switches
//	SWITCH_TRANSLATION_OPTION,
//	SWITCH_TRANSLATE_FILES_AND_FOLDERS,
//	SWITCH_TRANSLATE_LOCAL_GROUPS,
//	SWITCH_TRANSLATE_PRINTERS,
//	SWITCH_TRANSLATE_REGISTRY,
//	SWITCH_TRANSLATE_SHARES,
//	SWITCH_TRANSLATE_USER_PROFILES,
//	SWITCH_TRANSLATE_USER_RIGHTS,
	SWITCH_SID_MAPPING_FILE,
	// service account enumeration switches
	// report generation
	SWITCH_REPORT_TYPE,
	SWITCH_REPORT_FOLDER,
	// include switches
	SWITCH_INCLUDE_NAME,
	SWITCH_INCLUDE_FILE,
	SWITCH_INCLUDE_DOMAIN,
	// exclude switches
	SWITCH_EXCLUDE_NAME,
	SWITCH_EXCLUDE_FILE,
	// key switches
	SWITCH_KEY_IDENTIFIER,
	SWITCH_KEY_FOLDER,
	SWITCH_KEY_PASSWORD,
	// help switch
	SWITCH_HELP,
};


//---------------------------------------------------------------------------
// Switch Map
//---------------------------------------------------------------------------


class CSwitchMap :
	public std::map<_bstr_t, int, StringIgnoreCaseLess>
{
public:

	CSwitchMap();

	int GetSwitch(LPCTSTR pszSwitch);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\command\thread.cpp ===
#include "StdAfx.h"
#include "Thread.h"


//---------------------------------------------------------------------------
// Thread Class
//---------------------------------------------------------------------------


//---------------------------------------------------------------------------
// Constructor
//---------------------------------------------------------------------------

CThread::CThread() :
	m_dwThreadId(0),
	m_hStopEvent(CreateEvent(NULL, TRUE, FALSE, NULL))
{
}


//---------------------------------------------------------------------------
// Destructor
//---------------------------------------------------------------------------

CThread::~CThread()
{
}


//---------------------------------------------------------------------------
// Start Thread
//---------------------------------------------------------------------------

void CThread::StartThread()
{
	// reset exit event

	ResetEvent(m_hStopEvent);

	// create thread

	m_hThread = CreateThread(NULL, 0, ThreadProc, this, 0, &m_dwThreadId);

	if (m_hThread == NULL)
	{
	//	ThrowError(HRESULT_FROM_WIN32(GetLastError()), _T("Unable to create thread."));
	}
}


//---------------------------------------------------------------------------
// Stop Thread
//---------------------------------------------------------------------------

void CThread::StopThread()
{
	SetEvent(m_hStopEvent);

	if (m_hThread != NULL)
	{
		WaitForSingleObject(m_hThread, INFINITE);
	}
}


//---------------------------------------------------------------------------
// Thread Procedure
//---------------------------------------------------------------------------

DWORD WINAPI CThread::ThreadProc(LPVOID pvParameter)
{
	// initialize COM library for this thread
	// setting thread concurrency model to multi-threaded

	HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

	if (SUCCEEDED(hr))
	{
		CThread* pThis = reinterpret_cast<CThread*>(pvParameter);

		try
		{
			pThis->Run();
		}
		catch (...)
		{
			;
		}

		CoUninitialize();
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\command\thread.h ===
#pragma once


//---------------------------------------------------------------------------
// Handle Class
//
// Wrapper class for Win32 HANDLE.
//---------------------------------------------------------------------------


class CHandle
{
public:
	CHandle(HANDLE h = NULL) :
		m_Handle(h)
	{
	}

	~CHandle()
	{
		if (m_Handle != NULL)
		{
			CloseHandle(m_Handle);
			m_Handle = NULL;
		}
	}

	HANDLE operator =(HANDLE h)
	{
		if (m_Handle != NULL)
		{
			CloseHandle(m_Handle);
		}

		m_Handle = h;

		return m_Handle;
	}

	operator HANDLE() const
	{
		return m_Handle;
	}

protected:

	HANDLE m_Handle;
};


//---------------------------------------------------------------------------
// Thread Class
//
// Provides methods for starting and stopping a thread.
// The derived class must implement the Run method and perform all thread
// activity within this method. Any wait logic must include the stop event.
//---------------------------------------------------------------------------


class CThread
{
public:

	virtual ~CThread();

protected:

	CThread();

	HANDLE StopEvent() const
	{
		return m_hStopEvent;
	}

	void StartThread();
	void StopThread();

	virtual void Run() = 0;

private:

	static DWORD WINAPI ThreadProc(LPVOID pvParameter);

private:

	CHandle m_hThread;
	DWORD m_dwThreadId;

	CHandle m_hStopEvent;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\bkuprstr.cpp ===
//#pragma title( "BkupRstr.cpp - Get backup and restore privileges" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  BkupRstr.cpp
System      -  Common
Author      -  Rich Denham
Created     -  1997-05-30
Description -  Get backup and restore privileges
Updates     -
===============================================================================
*/

#include <stdio.h>
#include <windows.h>
#include <lm.h>

#include "Common.hpp"
#include "UString.hpp"
#include "BkupRstr.hpp"


// Get backup and restore privileges using WCHAR machine name.
BOOL                                       // ret-TRUE if successful.
   GetBkupRstrPriv(
      WCHAR          const * sMachineW     // in -NULL or machine name
   )
{
   BOOL                      bRc=FALSE;    // boolean return code.
   HANDLE                    hToken=INVALID_HANDLE_VALUE; // process token.
   DWORD                     rcOs, rcOs2;  // OS return code.
   WKSTA_INFO_100          * pWkstaInfo;   // Workstation info
   
   struct
   {
      TOKEN_PRIVILEGES       tkp;          // token privileges.
      LUID_AND_ATTRIBUTES    x[3];         // room for several.
   }                         token;

   rcOs = OpenProcessToken(
         GetCurrentProcess(),
         TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
         &hToken )
         ? 0 : GetLastError();

   if ( !rcOs )
   {
      memset( &token, 0, sizeof token );
      bRc = LookupPrivilegeValue(
            sMachineW,
            SE_BACKUP_NAME,
            &token.tkp.Privileges[0].Luid );
      if ( bRc )
      {
         bRc = LookupPrivilegeValue(
               sMachineW,
               SE_RESTORE_NAME,
               &token.tkp.Privileges[1].Luid );
      }
      if ( !bRc )
      {
         rcOs = GetLastError();
      }
      else
      {
         token.tkp.PrivilegeCount = 2;
         token.tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
         token.tkp.Privileges[1].Attributes = SE_PRIVILEGE_ENABLED;
         AdjustTokenPrivileges( hToken, FALSE, &token.tkp, 0, NULL, 0 );
         rcOs = GetLastError();
      }
   }

   if ( hToken != INVALID_HANDLE_VALUE )
   {
      CloseHandle( hToken );
      hToken = INVALID_HANDLE_VALUE;
   }

   // If we had any error, try NetWkstaGetInfo.
   // If NetWkstaGetInfo fails, then use it's error condition instead.
   if ( rcOs )
   {
      pWkstaInfo = NULL,
      rcOs2 = NetWkstaGetInfo(
            const_cast<WCHAR *>(sMachineW),
            100,
            (BYTE **) &pWkstaInfo );
      if ( pWkstaInfo )
      {
         NetApiBufferFree( pWkstaInfo );
      }
      if ( rcOs2 )
      {
         rcOs = rcOs2;
      }
   }

   if ( !rcOs )
   {
      bRc = TRUE;
   }
   else
   {
      SetLastError(rcOs);
      bRc = FALSE;
   }

   return bRc;
}

// BkupRstr.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\admtcrypt.cpp ===
//#include <StdAfx.h>
#include "AdmtCrypt.h"

#include <NtSecApi.h>

#pragma comment( lib, "AdvApi32.lib" )


namespace
{

void __stdcall CreateByteArray(DWORD cb, _variant_t& vntByteArray)
{
	vntByteArray.Clear();

	vntByteArray.parray = SafeArrayCreateVector(VT_UI1, 0, cb);

	if (vntByteArray.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntByteArray.vt = VT_UI1|VT_ARRAY;
}

_variant_t operator +(const _variant_t& vntByteArrayA, const _variant_t& vntByteArrayB)
{
	_variant_t vntByteArrayC;

	// validate parameters

	if ((vntByteArrayA.vt != (VT_UI1|VT_ARRAY)) || ((vntByteArrayA.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	if ((vntByteArrayB.vt != (VT_UI1|VT_ARRAY)) || ((vntByteArrayB.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// concatenate byte arrays

	DWORD cbA = vntByteArrayA.parray->rgsabound[0].cElements;
	DWORD cbB = vntByteArrayB.parray->rgsabound[0].cElements;

	CreateByteArray(cbA + cbB, vntByteArrayC);

	memcpy(vntByteArrayC.parray->pvData, vntByteArrayA.parray->pvData, cbA);
	memcpy((BYTE*)vntByteArrayC.parray->pvData + cbA, vntByteArrayB.parray->pvData, cbB);

	return vntByteArrayC;
}

#ifdef _DEBUG

_bstr_t __stdcall DebugByteArray(const _variant_t& vnt)
{
	_bstr_t strArray;

	if ((vnt.vt == (VT_UI1|VT_ARRAY)) && ((vnt.parray != NULL)))
	{
		_TCHAR szArray[256] = _T("");

		DWORD c = vnt.parray->rgsabound[0].cElements;
		BYTE* pb = (BYTE*) vnt.parray->pvData;

		for (DWORD i = 0; i < c; i++, pb++)
		{
			_TCHAR sz[48];
			wsprintf(sz, _T("%02X"), (UINT)(USHORT)*pb);

			if (i > 0)
			{
				_tcscat(szArray, _T(" "));
			}

			_tcscat(szArray, sz);
		}

		strArray = szArray;
	}

	return strArray;
}

#define TRACE_BUFFER_SIZE 1024

void _cdecl Trace(LPCTSTR pszFormat, ...)
{
	_TCHAR szMessage[TRACE_BUFFER_SIZE];

	if (pszFormat)
	{
		va_list args;
		va_start(args, pszFormat);

		_vsntprintf(szMessage, TRACE_BUFFER_SIZE, pszFormat, args);

		va_end(args);

	#if 0
		OutputDebugString(szMessage);
	#else
		HANDLE hFile = CreateFile(L"C:\\AdmtCrypt.log", GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

		if (hFile != INVALID_HANDLE_VALUE)
		{
			SetFilePointer(hFile, 0, NULL, FILE_END);
			DWORD dwWritten;
			WriteFile(hFile, szMessage, _tcslen(szMessage) * sizeof(_TCHAR), &dwWritten, NULL);
			CloseHandle(hFile);
		}
	#endif
	}
}

#else

_bstr_t __stdcall DebugByteArray(const _variant_t& vnt)
{
	return _T("");
}

void _cdecl Trace(LPCTSTR pszFormat, ...)
{
}

#endif

}


//---------------------------------------------------------------------------
// Target Crypt Class
//---------------------------------------------------------------------------


// Constructor

CTargetCrypt::CTargetCrypt()
{
	Trace(_T("CTargetCrypt::CTargetCrypt()\r\n"));
}


// Destructor

CTargetCrypt::~CTargetCrypt()
{
	Trace(_T("CTargetCrypt::~CTargetCrypt()\r\n"));
}


// CreateEncryptionKey Method

_variant_t CTargetCrypt::CreateEncryptionKey(LPCTSTR pszKeyId, LPCTSTR pszPassword)
{
	Trace(_T("CreateEncryptionKey(pszKeyId='%s', pszPassword='%s')\r\n"), pszKeyId, pszPassword);

	// generate encryption key bytes

	_variant_t vntBytes = GenerateRandom(ENCRYPTION_KEY_SIZE);

	Trace(_T(" vntBytes={ %s }\r\n"), (LPCTSTR)DebugByteArray(vntBytes));

	// store encryption key bytes

	StoreBytes(pszKeyId, vntBytes);

	// create key from password

	CCryptHash hashPassword(CreateHash(CALG_SHA1));

	if (pszPassword && pszPassword[0])
	{
		hashPassword.Hash(pszPassword);
	}
	else
	{
		BYTE b = 0;
		hashPassword.Hash(&b, 1);
	}

	CCryptKey keyPassword(DeriveKey(CALG_3DES, hashPassword));

	_variant_t vntPasswordFlag;
	CreateByteArray(1, vntPasswordFlag);
	*((BYTE*)vntPasswordFlag.parray->pvData) = (pszPassword && pszPassword[0]) ? 0xFF : 0x00;

	// concatenate encryption key bytes and hash of encryption key bytes

	CCryptHash hashBytes(CreateHash(CALG_SHA1));
	hashBytes.Hash(vntBytes);

	_variant_t vntDecrypted = vntBytes + hashBytes.GetValue();

//	Trace(_T(" vntDecrypted={ %s }\n"), (LPCTSTR)DebugByteArray(vntDecrypted));

	// encrypt bytes / hash pair

	_variant_t vntEncrypted = keyPassword.Encrypt(NULL, true, vntDecrypted);

//	Trace(_T(" vntEncrypted={ %s }\n"), (LPCTSTR)DebugByteArray(vntEncrypted));

	return vntPasswordFlag + vntEncrypted;
}


// CreateSession Method

_variant_t CTargetCrypt::CreateSession(LPCTSTR pszKeyId)
{
	Trace(_T("CreateSession(pszKeyId='%s')\r\n"), pszKeyId);

	// get encryption key

	CCryptHash hashEncryption(CreateHash(CALG_SHA1));
	hashEncryption.Hash(RetrieveBytes(pszKeyId));

	CCryptKey keyEncryption(DeriveKey(CALG_3DES, hashEncryption));

	// generate session key bytes

	_variant_t vntBytes = GenerateRandom(SESSION_KEY_SIZE);

	// create session key

	CCryptHash hash(CreateHash(CALG_SHA1));
	hash.Hash(vntBytes);

	m_keySession.Attach(DeriveKey(CALG_3DES, hash));

	// concatenate session key bytes and hash of session key bytes

	_variant_t vntDecrypted = vntBytes + hash.GetValue();

	// encrypt session bytes and include hash

	return keyEncryption.Encrypt(NULL, true, vntDecrypted);
}


// Encrypt Method

_variant_t CTargetCrypt::Encrypt(_bstr_t strData)
{
	Trace(_T("Encrypt(strData='%s')\r\n"), (LPCTSTR)strData);

	// convert string to byte array

	_variant_t vnt;

	HRESULT hr = VectorFromBstr(strData, &vnt.parray);

	if (FAILED(hr))
	{
		_com_issue_error(hr);
	}

	vnt.vt = VT_UI1|VT_ARRAY;

	// encrypt data

	return m_keySession.Encrypt(NULL, true, vnt);
}


//---------------------------------------------------------------------------
// Source Crypt Class
//---------------------------------------------------------------------------


// Constructor

CSourceCrypt::CSourceCrypt()
{
	Trace(_T("CSourceCrypt::CSourceCrypt()\r\n"));
}


// Destructor

CSourceCrypt::~CSourceCrypt()
{
	Trace(_T("CSourceCrypt::~CSourceCrypt()\r\n"));
}


// ImportEncryptionKey Method

void CSourceCrypt::ImportEncryptionKey(const _variant_t& vntEncryptedKey, LPCTSTR pszPassword)
{
	Trace(_T("ImportEncryptionKey(vntEncryptedKey={ %s }, pszPassword='%s')\r\n"), (LPCTSTR)DebugByteArray(vntEncryptedKey), pszPassword);

	// validate parameters

	if ((vntEncryptedKey.vt != (VT_UI1|VT_ARRAY)) || ((vntEncryptedKey.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// extract password flag and verify with password

	bool bPassword = *((BYTE*)vntEncryptedKey.parray->pvData) ? true : false;

	if (bPassword)
	{
		if ((pszPassword == NULL) || (pszPassword[0] == NULL))
		{
			_com_issue_error(HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD));
		}
	}
	else
	{
		if (pszPassword && pszPassword[0])
		{
			_com_issue_error(HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD));
		}
	}

	// create key from password

	CCryptHash hashPassword(CreateHash(CALG_SHA1));

	if (pszPassword && pszPassword[0])
	{
		hashPassword.Hash(pszPassword);
	}
	else
	{
		BYTE b = 0;
		hashPassword.Hash(&b, 1);
	}

	CCryptKey keyPassword(DeriveKey(CALG_3DES, hashPassword));

	// encrypted data

	_variant_t vntEncrypted;
	DWORD cbEncrypted = vntEncryptedKey.parray->rgsabound[0].cElements - 1;
	CreateByteArray(cbEncrypted, vntEncrypted);
	memcpy(vntEncrypted.parray->pvData, (BYTE*)vntEncryptedKey.parray->pvData + 1, cbEncrypted);

//	Trace(_T(" vntEncrypted={ %s }\n"), (LPCTSTR)DebugByteArray(vntEncrypted));

	// decrypt encryption key bytes plus hash

	_variant_t vntDecrypted = keyPassword.Decrypt(NULL, true, vntEncrypted);

//	Trace(_T(" vntDecrypted={ %s }\n"), (LPCTSTR)DebugByteArray(vntDecrypted));

	// extract encryption key bytes

	_variant_t vntBytes;
	CreateByteArray(ENCRYPTION_KEY_SIZE, vntBytes);
	memcpy(vntBytes.parray->pvData, (BYTE*)vntDecrypted.parray->pvData, ENCRYPTION_KEY_SIZE);

	Trace(_T(" vntBytes={ %s }\r\n"), (LPCTSTR)DebugByteArray(vntBytes));

	// extract hash of encryption key bytes

	_variant_t vntHashValue;
	DWORD cbHashValue = vntDecrypted.parray->rgsabound[0].cElements - ENCRYPTION_KEY_SIZE;
	CreateByteArray(cbHashValue, vntHashValue);
	memcpy(vntHashValue.parray->pvData, (BYTE*)vntDecrypted.parray->pvData + ENCRYPTION_KEY_SIZE, cbHashValue);

//	Trace(_T(" vntHashValue={ %s }\n"), (LPCTSTR)DebugByteArray(vntHashValue));

	// create hash from bytes and create hash from hash value

	CCryptHash hashA(CreateHash(CALG_SHA1));
	hashA.Hash(vntBytes);

	CCryptHash hashB(CreateHash(CALG_SHA1));
	hashB.SetValue(vntHashValue);

	// if hashes compare store encryption key bytes

	if (hashA == hashB)
	{
		StoreBytes(m_szIdPrefix, vntBytes);
	}
	else
	{
		_com_issue_error(HRESULT_FROM_WIN32(ERROR_INVALID_PASSWORD));
	}
}


// ImportSessionKey Method

void CSourceCrypt::ImportSessionKey(const _variant_t& vntEncryptedKey)
{
	Trace(_T("ImportSessionKey(vntEncryptedKey={ %s })\r\n"), (LPCTSTR)DebugByteArray(vntEncryptedKey));

	// validate parameters

	if ((vntEncryptedKey.vt != (VT_UI1|VT_ARRAY)) || ((vntEncryptedKey.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// get encryption key

	CCryptKey keyEncryption(GetEncryptionKey(m_szIdPrefix));

	// decrypt session key bytes plus hash

	_variant_t vntDecrypted = keyEncryption.Decrypt(NULL, true, vntEncryptedKey);

	// extract session key bytes

	_variant_t vntBytes;
	CreateByteArray(SESSION_KEY_SIZE, vntBytes);
	memcpy(vntBytes.parray->pvData, vntDecrypted.parray->pvData, SESSION_KEY_SIZE);

	// extract hash of session key bytes

	_variant_t vntHashValue;
	DWORD cbHashValue = vntDecrypted.parray->rgsabound[0].cElements - SESSION_KEY_SIZE;
	CreateByteArray(cbHashValue, vntHashValue);
	memcpy(vntHashValue.parray->pvData, (BYTE*)vntDecrypted.parray->pvData + SESSION_KEY_SIZE, cbHashValue);

	// create hash from bytes and create hash from hash value

	CCryptHash hashA(CreateHash(CALG_SHA1));
	hashA.Hash(vntBytes);

	CCryptHash hashB(CreateHash(CALG_SHA1));
	hashB.SetValue(vntHashValue);

	// if hashes compare

	if (hashA == hashB)
	{
		// derive session key from session key bytes hash

		m_keySession.Attach(DeriveKey(CALG_3DES, hashA));
	}
	else
	{
		_com_issue_error(E_FAIL);
	}
}


// Decrypt Method

_bstr_t CSourceCrypt::Decrypt(const _variant_t& vntData)
{
	Trace(_T("Decrypt(vntData={ %s })\r\n"), (LPCTSTR)DebugByteArray(vntData));

	// decrypt data

	_variant_t vnt = m_keySession.Decrypt(NULL, true, vntData);

	// convert into string

	BSTR bstr;

	HRESULT hr = BstrFromVector(vnt.parray, &bstr);

	if (FAILED(hr))
	{
		_com_issue_error(hr);
	}

	return bstr;
}


//---------------------------------------------------------------------------
// Domain Crypt Class
//---------------------------------------------------------------------------


// Constructor

CDomainCrypt::CDomainCrypt()
{
	Trace(_T("CDomainCrypt::CDomainCrypt()\r\n"));
}


// Destructor

CDomainCrypt::~CDomainCrypt()
{
	Trace(_T("CDomainCrypt::~CDomainCrypt()\r\n"));
}


// GetEncryptionKey Method

HCRYPTKEY CDomainCrypt::GetEncryptionKey(LPCTSTR pszKeyId)
{
	// retrieve bytes

	_variant_t vntBytes = RetrieveBytes(pszKeyId);

	// set hash value

	CCryptHash hash;
	hash.Attach(CreateHash(CALG_SHA1));
	hash.Hash(vntBytes);

	// create encryption key derived from bytes

	return DeriveKey(CALG_3DES, hash);
}


// StoreBytes Method

void CDomainCrypt::StoreBytes(LPCTSTR pszId, const _variant_t& vntBytes)
{
	// validate parameters

	if ((pszId == NULL) || (pszId[0] == NULL))
	{
		_com_issue_error(E_INVALIDARG);
	}

	if ((vntBytes.vt != VT_EMPTY) && (vntBytes.vt != (VT_UI1|VT_ARRAY)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	if ((vntBytes.vt == (VT_UI1|VT_ARRAY)) && (vntBytes.parray == NULL))
	{
		_com_issue_error(E_INVALIDARG);
	}

	LSA_HANDLE hPolicy = NULL;

	try
	{
		// open policy object

		LSA_OBJECT_ATTRIBUTES loa = { sizeof(LSA_OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };

		NTSTATUS ntsStatus = LsaOpenPolicy(NULL, &loa, POLICY_CREATE_SECRET, &hPolicy);

		if (!LSA_SUCCESS(ntsStatus))
		{
			_com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
		}

		// store data

		PWSTR pwsKey = const_cast<PWSTR>(pszId);
		USHORT cbKey = _tcslen(pszId) * sizeof(_TCHAR);

		PWSTR pwsData = NULL;
		USHORT cbData = 0;

		if (vntBytes.vt != VT_EMPTY)
		{
			pwsData = reinterpret_cast<PWSTR>(vntBytes.parray->pvData);
			cbData = (USHORT) vntBytes.parray->rgsabound[0].cElements;
		}

		LSA_UNICODE_STRING lusKey = { cbKey, cbKey, pwsKey };
		LSA_UNICODE_STRING lusData = { cbData, cbData, pwsData };

		ntsStatus = LsaStorePrivateData(hPolicy, &lusKey, &lusData);

		if (!LSA_SUCCESS(ntsStatus))
		{
			_com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
		}

		// close policy object

		LsaClose(hPolicy);
	}
	catch (...)
	{
		if (hPolicy)
		{
			LsaClose(hPolicy);
		}

		throw;
	}
}


// RetrievePrivateData Method

_variant_t CDomainCrypt::RetrieveBytes(LPCTSTR pszId)
{
	_variant_t vntBytes;

	// validate parameters

	if ((pszId == NULL) || (pszId[0] == NULL))
	{
		_com_issue_error(E_INVALIDARG);
	}

	LSA_HANDLE hPolicy = NULL;

	try
	{
		// open policy object

		LSA_OBJECT_ATTRIBUTES loa = { sizeof(LSA_OBJECT_ATTRIBUTES), NULL, NULL, 0, NULL, NULL };

		NTSTATUS ntsStatus = LsaOpenPolicy(NULL, &loa, POLICY_GET_PRIVATE_INFORMATION, &hPolicy);

		if (!LSA_SUCCESS(ntsStatus))
		{
			_com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
		}

		// retrieve data

		PWSTR pwsKey = const_cast<PWSTR>(pszId);
		USHORT cbKey = _tcslen(pszId) * sizeof(_TCHAR);

		LSA_UNICODE_STRING lusKey = { cbKey, cbKey, pwsKey };
		PLSA_UNICODE_STRING plusData;

		ntsStatus = LsaRetrievePrivateData(hPolicy, &lusKey, &plusData);

		if (!LSA_SUCCESS(ntsStatus))
		{
			_com_issue_error(HRESULT_FROM_WIN32(LsaNtStatusToWinError(ntsStatus)));
		}

		vntBytes.parray = SafeArrayCreateVector(VT_UI1, 0, plusData->Length);

		if (vntBytes.parray == NULL)
		{
			LsaFreeMemory(plusData);
			_com_issue_error(E_OUTOFMEMORY);
		}

		vntBytes.vt = VT_UI1|VT_ARRAY;

		memcpy(vntBytes.parray->pvData, plusData->Buffer, plusData->Length);

		LsaFreeMemory(plusData);

		// close policy object

		LsaClose(hPolicy);
	}
	catch (...)
	{
		if (hPolicy)
		{
			LsaClose(hPolicy);
		}

		throw;
	}

	return vntBytes;
}


// private data key identifier

_TCHAR CDomainCrypt::m_szIdPrefix[] = _T("L$6A2899C0-CECE-459A-B5EB-7ED04DE61388");


//---------------------------------------------------------------------------
// Crypt Provider Class
//---------------------------------------------------------------------------


// Constructors
//
// Notes:
// If the enhanced provider is not installed, CryptAcquireContext() generates
// the following error: (0x80090019) The keyset is not defined.

CCryptProvider::CCryptProvider() :
	m_hProvider(NULL)
{
	Trace(_T("E CCryptProvider::CCryptProvider(this=0x%p)\r\n"), this);

	if (!CryptAcquireContext(&m_hProvider, NULL, MS_ENHANCED_PROV, PROV_RSA_FULL, CRYPT_MACHINE_KEYSET|CRYPT_VERIFYCONTEXT))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

#ifdef _DEBUG
	char szProvider[256];
	DWORD cbProvider = sizeof(szProvider);

	if (CryptGetProvParam(m_hProvider, PP_NAME, (BYTE*) szProvider, &cbProvider, 0))
	{
	}

	DWORD dwVersion;
	DWORD cbVersion = sizeof(dwVersion);

	if (CryptGetProvParam(m_hProvider, PP_VERSION, (BYTE*) &dwVersion, &cbVersion, 0))
	{
	}

//	char szContainer[256];
//	DWORD cbContainer = sizeof(szContainer);

//	if (CryptGetProvParam(m_hProvider, PP_CONTAINER, (BYTE*) szContainer, &cbContainer, 0))
//	{
//	}
#endif

	Trace(_T("L CCryptProvider::CCryptProvider()\r\n"));
}

CCryptProvider::CCryptProvider(const CCryptProvider& r) :
	m_hProvider(r.m_hProvider)
{
//	if (!CryptContextAddRef(r.m_hProvider, NULL, 0))
//	{
//		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
//	}
}


// Destructor

CCryptProvider::~CCryptProvider()
{
	Trace(_T("E CCryptProvider::~CCryptProvider()\r\n"));

	if (m_hProvider)
	{
		if (!CryptReleaseContext(m_hProvider, 0))
		{
			#ifdef _DEBUG
			DebugBreak();
			#endif
		}
	}

	Trace(_T("L CCryptProvider::~CCryptProvider()\r\n"));
}


// assignment operators

CCryptProvider& CCryptProvider::operator =(const CCryptProvider& r)
{
	m_hProvider = r.m_hProvider;

//	if (!CryptContextAddRef(r.m_hProvider, NULL, 0))
//	{
//		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
//	}

	return *this;
}


// CreateHash Method

HCRYPTHASH CCryptProvider::CreateHash(ALG_ID aid)
{
	HCRYPTHASH hHash;

	if (!CryptCreateHash(m_hProvider, aid, 0, 0, &hHash))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	return hHash;
}


// DeriveKey Method

HCRYPTKEY CCryptProvider::DeriveKey(ALG_ID aid, HCRYPTHASH hHash, DWORD dwFlags)
{
	HCRYPTKEY hKey;

	if (!CryptDeriveKey(m_hProvider, aid, hHash, dwFlags, &hKey))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	return hKey;
}


// GenerateRandom Method
//
// Generates a specified number of random bytes.

_variant_t CCryptProvider::GenerateRandom(DWORD dwNumberOfBytes) const
{
	_variant_t vntRandom;

	// create byte array of specified length

	vntRandom.parray = SafeArrayCreateVector(VT_UI1, 0, dwNumberOfBytes);

	if (vntRandom.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntRandom.vt = VT_UI1|VT_ARRAY;

	// generate specified number of random bytes

	GenerateRandom((BYTE*)vntRandom.parray->pvData, dwNumberOfBytes);

	return vntRandom;
}


// GenerateRandom Method
//
// Generates a specified number of random bytes.

void CCryptProvider::GenerateRandom(BYTE* pbData, DWORD cbData) const
{
	// generate specified number of random bytes

	if (!CryptGenRandom(m_hProvider, cbData, pbData))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}
}


//---------------------------------------------------------------------------
// Crypt Key Class
//---------------------------------------------------------------------------


// Constructor

CCryptKey::CCryptKey(HCRYPTKEY hKey) :
	m_hKey(hKey)
{
}


// Destructor

CCryptKey::~CCryptKey()
{
	if (m_hKey)
	{
		if (!CryptDestroyKey(m_hKey))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}
	}
}


// Encrypt Method

_variant_t CCryptKey::Encrypt(HCRYPTHASH hHash, bool bFinal, const _variant_t& vntData)
{
	_variant_t vntEncrypted;

	// validate parameters

	if ((vntData.vt != (VT_UI1|VT_ARRAY)) || ((vntData.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// get encrypted data size

	DWORD cbData = vntData.parray->rgsabound[0].cElements;
	DWORD cbBuffer = cbData;

	if (!CryptEncrypt(m_hKey, hHash, bFinal ? TRUE : FALSE, 0, NULL, &cbBuffer, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	// create encrypted data buffer

	vntEncrypted.parray = SafeArrayCreateVector(VT_UI1, 0, cbBuffer);

	if (vntEncrypted.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntEncrypted.vt = VT_UI1|VT_ARRAY;

	// copy data to encrypted buffer

	memcpy(vntEncrypted.parray->pvData, vntData.parray->pvData, cbData);

	// encrypt data

	BYTE* pbData = (BYTE*) vntEncrypted.parray->pvData;

	if (!CryptEncrypt(m_hKey, hHash, bFinal ? TRUE : FALSE, 0, pbData, &cbData, cbBuffer))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	return vntEncrypted;
}


// Decrypt Method

_variant_t CCryptKey::Decrypt(HCRYPTHASH hHash, bool bFinal, const _variant_t& vntData)
{
	_variant_t vntDecrypted;

	// validate parameters

	if ((vntData.vt != (VT_UI1|VT_ARRAY)) || ((vntData.parray == NULL)))
	{
		_com_issue_error(E_INVALIDARG);
	}

	// decrypt data

	_variant_t vnt = vntData;

	BYTE* pb = (BYTE*) vnt.parray->pvData;
	DWORD cb = vnt.parray->rgsabound[0].cElements;

	if (!CryptDecrypt(m_hKey, hHash, bFinal ? TRUE : FALSE, 0, pb, &cb))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	// create decrypted byte array
	// the number of decrypted bytes may be less than
	// the number of encrypted bytes

	vntDecrypted.parray = SafeArrayCreateVector(VT_UI1, 0, cb);

	if (vntDecrypted.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntDecrypted.vt = VT_UI1|VT_ARRAY;

	memcpy(vntDecrypted.parray->pvData, vnt.parray->pvData, cb);

	return vntDecrypted;
}


//---------------------------------------------------------------------------
// Crypt Hash Class
//---------------------------------------------------------------------------


// Constructor

CCryptHash::CCryptHash(HCRYPTHASH hHash) :
	m_hHash(hHash)
{
}


// Destructor

CCryptHash::~CCryptHash()
{
	if (m_hHash)
	{
		if (!CryptDestroyHash(m_hHash))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}
	}
}


// GetValue Method

_variant_t CCryptHash::GetValue() const
{
	_variant_t vntValue;

	// get hash size

	DWORD dwHashSize;
	DWORD cbHashSize = sizeof(DWORD);

	if (!CryptGetHashParam(m_hHash, HP_HASHSIZE, (BYTE*)&dwHashSize, &cbHashSize, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	// allocate buffer

	vntValue.parray = SafeArrayCreateVector(VT_UI1, 0, dwHashSize);

	if (vntValue.parray == NULL)
	{
		_com_issue_error(E_OUTOFMEMORY);
	}

	vntValue.vt = VT_UI1|VT_ARRAY;

	// get hash value

	if (!CryptGetHashParam(m_hHash, HP_HASHVAL, (BYTE*)vntValue.parray->pvData, &dwHashSize, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	return vntValue;
}


// SetValue Method

void CCryptHash::SetValue(const _variant_t& vntValue)
{
	// if parameter is valid

	if ((vntValue.vt == (VT_UI1|VT_ARRAY)) && ((vntValue.parray != NULL)))
	{
		// get hash size

		DWORD dwHashSize;
		DWORD cbHashSize = sizeof(DWORD);

		if (!CryptGetHashParam(m_hHash, HP_HASHSIZE, (BYTE*)&dwHashSize, &cbHashSize, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}

		// validate hash size

		BYTE* pbValue = (BYTE*)vntValue.parray->pvData;
		DWORD cbValue = vntValue.parray->rgsabound[0].cElements;

		if (cbValue != dwHashSize)
		{
			_com_issue_error(E_INVALIDARG);
		}

		// set hash value

		if (!CryptSetHashParam(m_hHash, HP_HASHVAL, (BYTE*)pbValue, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}
	}
	else
	{
		_com_issue_error(E_INVALIDARG);
	}
}


// Hash Method

void CCryptHash::Hash(LPCTSTR pszData)
{
	if (pszData && pszData[0])
	{
		Hash((BYTE*)pszData, _tcslen(pszData) * sizeof(_TCHAR));
	}
	else
	{
		_com_issue_error(E_INVALIDARG);
	}
}


// Hash Method

void CCryptHash::Hash(const _variant_t& vntData)
{
	if ((vntData.vt == (VT_UI1|VT_ARRAY)) && ((vntData.parray != NULL)))
	{
		Hash((BYTE*)vntData.parray->pvData, vntData.parray->rgsabound[0].cElements);
	}
	else
	{
		_com_issue_error(E_INVALIDARG);
	}
}


// Hash Method

void CCryptHash::Hash(BYTE* pbData, DWORD cbData)
{
	if ((pbData != NULL) && (cbData > 0))
	{
		if (!CryptHashData(m_hHash, pbData, cbData, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}
	}
	else
	{
		_com_issue_error(E_INVALIDARG);
	}
}


bool CCryptHash::operator ==(const CCryptHash& hash)
{
	bool bEqual = false;

	DWORD cbSize = sizeof(DWORD);

	// compare hash sizes

	DWORD dwSizeA;
	DWORD dwSizeB;

	if (!CryptGetHashParam(m_hHash, HP_HASHSIZE, (BYTE*)&dwSizeA, &cbSize, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	if (!CryptGetHashParam(hash.m_hHash, HP_HASHSIZE, (BYTE*)&dwSizeB, &cbSize, 0))
	{
		_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	}

	// if sizes are equal

	if (dwSizeA == dwSizeB)
	{
		// compare hashes

		BYTE* pbA;
		BYTE* pbB;

		try
		{
			pbA = (BYTE*) _alloca(dwSizeA);
			pbB = (BYTE*) _alloca(dwSizeB);
		}
		catch (...)
		{
			_com_issue_error(E_OUTOFMEMORY);
		}

		if (!CryptGetHashParam(m_hHash, HP_HASHVAL, pbA, &dwSizeA, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}

		if (!CryptGetHashParam(hash.m_hHash, HP_HASHVAL, pbB, &dwSizeB, 0))
		{
			_com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
		}

		if (memcmp(pbA, pbB, dwSizeA) == 0)
		{
			bEqual = true;
		}
	}

	return bEqual;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\commalog.cpp ===
/*---------------------------------------------------------------------------
  File: CommaLog.cpp

  Comments: TError based log file with optional NTFS security initialization.

  This can be used to write a log file which only administrators can access.

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/15/99 10:49:07

 ---------------------------------------------------------------------------
*/


//#include "stdafx.h"
#include <windows.h>
#include <stdio.h>
#include <share.h>
#include <lm.h>
#include "Common.hpp"
#include "UString.hpp"
#include "Err.hpp"
#include "ErrDct.hpp"
#include "sd.hpp"
#include "SecObj.hpp"
#include "CommaLog.hpp"
#include "BkupRstr.hpp"



#define ADMINISTRATORS     1
#define ACCOUNT_OPERATORS  2
#define BACKUP_OPERATORS   3 
#define DOMAIN_ADMINS      4
#define CREATOR_OWNER      5
#define USERS              6
#define SYSTEM             7


extern TErrorDct err;

#define  BYTE_ORDER_MARK   (0xFEFF)


PSID                                            // ret- SID for well-known account
   GetWellKnownSid(
      DWORD                  wellKnownAccount   // in - one of the constants #defined above for the well-known accounts
   )
{
   PSID                      pSid = NULL;
//   PUCHAR                    numsubs = NULL;
//   DWORD                   * rid = NULL;
   BOOL                      error = FALSE;

   
   
    SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY creatorIA =    SECURITY_CREATOR_SID_AUTHORITY;
    //
    // Sid is the same regardless of machine, since the well-known
    // BUILTIN domain is referenced.
    //
   switch ( wellKnownAccount )
   {
      case CREATOR_OWNER:
         if( ! AllocateAndInitializeSid(
                  &creatorIA,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  SECURITY_CREATOR_OWNER_RID,
                  0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         break;
      case ADMINISTRATORS:
         if( ! AllocateAndInitializeSid(
                  &sia,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_ADMINS,
                  0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         break;
      case ACCOUNT_OPERATORS:
         if( ! AllocateAndInitializeSid(
                  &sia,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_ACCOUNT_OPS,
                  0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         break;
      case BACKUP_OPERATORS:
         if( ! AllocateAndInitializeSid(
                  &sia,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_BACKUP_OPS,
                  0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         break;
     case USERS:
         if( ! AllocateAndInitializeSid(
                  &sia,
                  2,
                  SECURITY_BUILTIN_DOMAIN_RID,
                  DOMAIN_ALIAS_RID_USERS,
                  0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
         break;
     case SYSTEM:
         if( ! AllocateAndInitializeSid(
                  &sia,
                  1,
                  SECURITY_LOCAL_SYSTEM_RID,
                  0, 0, 0, 0, 0, 0, 0,
                  &pSid
            ))
         {
            err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_INITIALIZE_SID_FAILED_D,GetLastError());
         }
        
         break;

      default:
         MCSASSERT(FALSE);
         break;
   }
   if ( error )
   {
      FreeSid(pSid);
      pSid = NULL;
   }
   return pSid;
}


BOOL                                       // ret- whether log was successfully opened or not
   CommaDelimitedLog::LogOpen(
      TCHAR          const *  filename,    // in - name for log file
      BOOL                    protect,     // in - if TRUE, try to ACL the file so only admins can access
      int                     mode         // in - mode 0=overwrite, 1=append
   )
{
   BOOL                       retval=TRUE;

   if ( fptr )
   {
      fclose(fptr);
      fptr = NULL;
   }
   if ( filename && filename[0] )
   {
      // Check to see if the file already exists
      WIN32_FIND_DATA      fDat;
      HANDLE               hFind;
      BOOL                 bExisted = FALSE;

      hFind = FindFirstFile(filename,&fDat);
      if ( hFind != INVALID_HANDLE_VALUE )
      {
         FindClose(hFind);
         bExisted = TRUE;   
      }

      #ifdef UNICODE 
         fptr = _wfsopen( filename, mode == 0 ? L"wb" : L"ab", _SH_DENYNO );
      #else
         fptr = _fsopen( filename, mode == 0 ? "w" : "a", _SH_DENYNO );
      #endif
      if ( !fptr )
      {
         retval = FALSE;
      }
      else
      {
         if (! bExisted )
         {
            // this is a new file we've just created
            // we need to write the byte order mark to the beginning of the file
            WCHAR x = BYTE_ORDER_MARK;
            fwprintf(fptr,L"%lc",x);
         }
      }
   }

   if ( protect )
   {
      
      WCHAR               fname[MAX_PATH+1];
      
      safecopy(fname,filename);
   
      if ( GetBkupRstrPriv() )
      {
         // Set the SD for the file to Administrators Full Control only.
         TFileSD                sd(fname);

         if ( sd.GetSecurity() != NULL )
         {
            PSID                mySid = GetWellKnownSid(ADMINISTRATORS);
            TACE                ace(ACCESS_ALLOWED_ACE_TYPE,0,DACL_FULLCONTROL_MASK,mySid);
            PACL                acl = NULL;  // start with an empty ACL
         
            sd.GetSecurity()->ACLAddAce(&acl,&ace,-1);
            sd.GetSecurity()->SetDacl(acl,TRUE);

            sd.WriteSD();
         }
      }
      else
      {
         err.SysMsgWrite(ErrW,GetLastError(),DCT_MSG_NO_BR_PRIV_SD,fname,GetLastError());
      }
   }
   return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\errdct.cpp ===
/*---------------------------------------------------------------------------
  File: ErrDct.cpp

  Comments: TError derived class for OnePoint Domain Administrator messages

  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/18/99 11:34:16

 ---------------------------------------------------------------------------
*/

#ifdef USE_STDAFX 
   #include "stdafx.h"
#else
   #include <windows.h>
#endif
#include "ErrDct.hpp"
#include "AdsErr.h"

#define  TERR_MAX_MSG_LEN  (2000)

// Recursively walk through a path, trying to create the directories at each level

DWORD          // ret - 0 if successful (directories created\already existed), OS return code otherwise
   DirectoryCreateR(
      WCHAR          const * dirToCreate       // in-directory to create (full path or UNC)
   )
{
   WCHAR                   * c;
   WCHAR                   * end;
   BOOL                      error = FALSE;
   DWORD                     rcOs;
   WCHAR                     dirName[MAX_PATH+1];
   BOOL                      isUNC = FALSE;
   BOOL                      skipShareName = FALSE;

   if ( !dirName )
      return ERROR_INVALID_PARAMETER;

   safecopy(dirName,dirToCreate);

   // Note: if the string is empty, that's ok - we will catch it when we don't see C:\ or C$\ below
   // walk through the string, and try to create at each step along the way

   do { // once
      c = dirName;
      end = dirName + UStrLen(dirName);
          // skip computer-name if UNC
      if ( *c == L'\\' && *(c + 1) == L'\\' )
      {
         isUNC = TRUE;
         for ( c=c+2 ; *c && *c != L'\\' ; c++ )
         ;
         if ( ! *c )
         {
            error = TRUE;
            rcOs = ERROR_INVALID_PARAMETER;
            break;
         }
         c++;
      }
      // skip C:\ or C$\.
      if ( *(c) &&  ( *(c+1)==L'$' || *(c+1)==L':' ) && *(c+2)==L'\\' )
      {
         c = c + 3;
         if ( c == end ) // They put in the root directory for some volume
            break;

      }
      else
      {
         if ( isUNC )
         {
            skipShareName = TRUE;
         }
         else
         {
            rcOs = ERROR_INVALID_PARAMETER;
            error = TRUE;
            break;
         }
      }
      // scan through the string looking for '\'
      for ( ; c <= end ; c++ )
      {
         if ( !*c || *c == L'\\' )
         {
            if ( skipShareName )
            {
               skipShareName = FALSE;
               continue;
            }
            // try to create at this level
            *c = L'\0';
            if ( ! CreateDirectory(dirName,NULL) )
            {
               rcOs = GetLastError();
               switch ( rcOs )
               {
               case 0:
               case ERROR_ALREADY_EXISTS:
                  break;
               default:
                  error = TRUE;
               }
            }
            if (c != end )
               *c = L'\\';
            if ( error )
                  break;
         }
      }
   } while ( FALSE );
   if ( !error )
      rcOs = 0;

   return rcOs;
}


WCHAR const *                               // ret- text for DCT message
   TErrorDct::LookupMessage(
      UINT                   msgNumber     // in - message number DCT_MSG_???
   )
{
   WCHAR             const * msg = NULL;

   return msg;
}

WCHAR *                                     // ret-text for system or EA error
   TErrorDct::ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   )
{
   if ( SUCCEEDED(code) )
   {
      return TError::ErrorCodeToText(code,lenMsg,msg);
   }
   else
   {
      if ( HRESULT_FACILITY(code) == FACILITY_WIN32 )
      {
         return TError::ErrorCodeToText(HRESULT_CODE(code),lenMsg,msg);
      }
      else
      {
         //Translate ADSI errors to DCT errors so message can be written.
         DWORD msgId = 0;
         switch ( code )
         {
            case (E_ADS_BAD_PATHNAME)              :   msgId = DCT_MSG_E_MSG_ADS_BAD_PATHNAME;
                                                      break;
            case (E_ADS_INVALID_DOMAIN_OBJECT)     :   msgId = DCT_MSG_E_ADS_INVALID_DOMAIN_OBJECT;
                                                      break;
            case (E_ADS_INVALID_USER_OBJECT)       :   msgId = DCT_MSG_E_ADS_INVALID_USER_OBJECT;
                                                      break;
            case (E_ADS_INVALID_COMPUTER_OBJECT)   :   msgId = DCT_MSG_E_ADS_INVALID_COMPUTER_OBJECT;
                                                      break;
            case (E_ADS_UNKNOWN_OBJECT)            :   msgId = DCT_MSG_E_ADS_UNKNOWN_OBJECT;
                                                      break;
            case (E_ADS_PROPERTY_NOT_SET)          :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_SET;
                                                      break;
            case (E_ADS_PROPERTY_NOT_SUPPORTED)    :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_SUPPORTED;
                                                      break;
            case (E_ADS_PROPERTY_INVALID)          :   msgId = DCT_MSG_E_ADS_PROPERTY_INVALID;
                                                      break;
            case (E_ADS_BAD_PARAMETER)             :   msgId = DCT_MSG_E_ADS_BAD_PARAMETER;
                                                      break;
            case (E_ADS_OBJECT_UNBOUND)            :   msgId = DCT_MSG_E_ADS_OBJECT_UNBOUND;
                                                      break;
            case (E_ADS_PROPERTY_NOT_MODIFIED)     :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_MODIFIED;
                                                      break;
            case (E_ADS_PROPERTY_MODIFIED)         :   msgId = DCT_MSG_E_ADS_PROPERTY_MODIFIED;
                                                      break;
            case (E_ADS_CANT_CONVERT_DATATYPE)     :   msgId = DCT_MSG_E_ADS_CANT_CONVERT_DATATYPE;
                                                      break;
            case (E_ADS_PROPERTY_NOT_FOUND)        :   msgId = DCT_MSG_E_ADS_PROPERTY_NOT_FOUND;
                                                      break;
            case (E_ADS_OBJECT_EXISTS)             :   msgId = DCT_MSG_E_ADS_OBJECT_EXISTS;
                                                      break;
            case (E_ADS_SCHEMA_VIOLATION)          :   msgId = DCT_MSG_E_ADS_SCHEMA_VIOLATION;
                                                      break;
            case (E_ADS_COLUMN_NOT_SET)            :   msgId = DCT_MSG_E_ADS_COLUMN_NOT_SET;
                                                      break;
            case (E_ADS_INVALID_FILTER)            :   msgId = DCT_MSG_E_ADS_INVALID_FILTER;
                                                      break;
            default                                :   msgId = 0;
         }

         if ( !msgId )
         {
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
                         | FORMAT_MESSAGE_MAX_WIDTH_MASK
                         | FORMAT_MESSAGE_IGNORE_INSERTS
                         | 80,
                           NULL,
                           code,
                           0,
                           msg,
                           lenMsg,
                           NULL );
         }
         else
         {
            static HMODULE            hDctMsg = NULL;
            DWORD                     rc = 0;   
            if ( ! hDctMsg )
            {
               hDctMsg = LoadLibrary(L"McsDmMsg.DLL");
               if ( ! hDctMsg )
               {
                  rc = GetLastError();
               }
            }

            if ( ! rc )
            {
               FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                          hDctMsg,
                          msgId,
                          0,
                          msg,
                          lenMsg,
                          NULL);
            }
            else
            {
               swprintf(msg,L"McsDomMsg.DLL not loaded, rc=%ld, MessageNumber = %lx",rc,msgId);
            }
            
         }
      }
   }
   return msg;
}

//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TErrorDct::SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      UINT                   msgNumber    ,// in -constant for message
            ...                            // in -printf args to msg pattern
   )
{
   WCHAR                     suffix[TERR_MAX_MSG_LEN] = L"";
   WCHAR                   * pMsg = NULL;
   va_list                   argPtr;
   int                       len;
   
   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;

   static HMODULE            hDctMsg = NULL;
   DWORD                     rc = 0;

   if ( ! hDctMsg )
   {
      hDctMsg = LoadLibrary(L"McsDmMsg.DLL");
      if ( ! hDctMsg )
      {
         rc = GetLastError();
      }
   }
   
   va_start(argPtr,msgNumber);
   
   if ( ! rc )
   {
      len = FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                 hDctMsg,
                 msgNumber,
                 0,
                 suffix,
                 DIM(suffix),
                 &argPtr);
   }
   else
   {
      swprintf(suffix,L"McsDomMsg.DLL not loaded, rc=%ld, MessageNumber = %lx",rc,msgNumber);
   }
   va_end(argPtr);
   
   // Change any imbedded CR or LF to blank.
   for ( pMsg = suffix;
         *pMsg;
         pMsg++ )
   {
      if ( (*pMsg == L'\x0D') || (*pMsg == L'\x0A') )
         *pMsg = L' ';
   }
   // append the system message for the lastRc at the end.
   len = UStrLen(suffix);
   if ( len < DIM(suffix) - 1 )
   {
      ErrorCodeToText(lastRc, DIM(suffix) - len - 1, suffix + len );
   }
   suffix[DIM(suffix) - 1] = '\0';
   
   va_end(argPtr);
   
   MsgProcess(num + HRESULT_CODE(msgNumber), suffix);
}

//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TErrorDct::MsgWrite(
      int                    num          ,// in -error number/level code
      UINT                   msgNumber    ,// in -constant for message
      ...                                  // in -printf args to msg pattern
   )
{
   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;
   static HMODULE            hDctMsg = NULL;
   DWORD                     rc = 0;

   if ( ! hDctMsg )
   {
     hDctMsg = LoadLibrary(L"McsDmMsg.DLL");
	  if ( ! hDctMsg )
	  {
//		  DWORD rc = GetLastError();
		  rc = GetLastError();
	  }

   }
   
   WCHAR                     suffix[TERR_MAX_MSG_LEN] = L"";
   va_list                   argPtr;

   va_start(argPtr,msgNumber);
   
   if ( rc == 0 )
   {
      FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                 hDctMsg,
                 msgNumber,
                 0,
                 suffix,
                 DIM(suffix),
                 &argPtr);
   }
   else
   {
      swprintf(suffix,L"McsDomMsg.DLL not loaded, rc=%ld, MessageNumber = %lx",rc,msgNumber);
   }
   if ( suffix[UStrLen(suffix)-1] == L'\n' )
   {
		suffix[UStrLen(suffix)-1] = L'\0';
   }
   
   va_end(argPtr);
   
   MsgProcess(num + HRESULT_CODE(msgNumber), suffix);

}

void __cdecl
   TErrorDct::DbgMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
      )
{
   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;

   WCHAR                     suffix[TERR_MAX_MSG_LEN];
   va_list                   argPtr;

   va_start(argPtr,msg);
   _vsnwprintf(suffix, DIM(suffix) - 1, msg, argPtr);
   suffix[DIM(suffix) - 1] = L'\0';
   va_end(argPtr);

   MsgProcess(num, suffix);
}

//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
_bstr_t __cdecl
   TErrorDct::GetMsgText(
      UINT                   msgNumber    ,// in -constant for message
      ...                                  // in -printf args to msg pattern
   )
{
   WCHAR                     suffix[TERR_MAX_MSG_LEN] = L"";
   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return suffix;
   static HMODULE            hDctMsg = NULL;
   DWORD                     rc = 0;

   if ( ! hDctMsg )
   {
     hDctMsg = LoadLibrary(L"McsDmMsg.DLL");
	  if ( ! hDctMsg )
	  {
//		  DWORD rc = GetLastError();
		  rc = GetLastError();
	  }

   }
   
   va_list                   argPtr;
   va_start(argPtr,msgNumber);
   
   if ( rc == 0 )
   {
      FormatMessage(FORMAT_MESSAGE_FROM_HMODULE,
                 hDctMsg,
                 msgNumber,
                 0,
                 suffix,
                 DIM(suffix),
                 &argPtr);
   }
   else
   {
      swprintf(suffix,L"McsDomMsg.DLL not loaded, rc=%ld, MessageNumber = %lx",rc,msgNumber);
   }
   if ( suffix[UStrLen(suffix)-1] == L'\n' )
   {
		suffix[UStrLen(suffix)-1] = L'\0';
   }

   return suffix;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\cipher.cpp ===
//#pragma title( "Cipher.cpp - Very simple cipher for encryption" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc.  All rights reserved.
===============================================================================
Module      -  Cipher.cpp
System      -  Common
Author      -  Tom Bernhardt
Created     -  1996-01-21
Description -  Very simple Cipher routine for network packet password
               encryption.  This is a symmetrical cipher where applying
               it twice will revert it to its orignial form.  One of its
               functions is a one's complement so it assumes that no char
               will have the value of '\xff' to erroneously pre-terminate
               the resultant string.

               NOTE: This is obviously so simple that it can be easily
               cracked by either single stepping the code or comparing sequences
               of known values and their encrypted result.  Its only use
               is to keep out the casual observer/hacker.  It should be replaced
               by heavy public key encryption when possible.

Updates     -
===============================================================================
*/
#include <windows.h>
#include "Cipher.hpp"

void
   SimpleCipher(
      WCHAR                * str           // i/o-string to encrypt
   )
{
   WCHAR                   * c;

   // exchange nibbles and NOT result or each char
   for ( c = str;  *c;  c++ )
      *c = ~( *c >> 4  |  *c << 4 );

   // exchange chars around middle
   for ( --c;  c > str;  c--, str++ )
   {
      *c   ^= *str;
      *str ^= *c;
      *c   ^= *str;
   }
}

void
   SimpleCipher(
      char unsigned        * str           // i/o-string to encrypt
   )
{
   char unsigned           * c;

   // exchange nibbles and NOT result or each char
   for ( c = str;  *c;  c++ )
      *c = ~( *c >> 4  |  *c << 4 );

   // exchange chars around middle
   for ( --c;  c > str;  c--, str++ )
   {
      *c   ^= *str;
      *str ^= *c;
      *c   ^= *str;
   }
}

void
   SimpleCipher(
      char unsigned        * str          ,// i/o-string to encrypt
      int                    len           // in -length of string
   )
{
   char unsigned           * c;

   // exchange nibbles and NOT result or each char
   for ( c = str;  len--;  c++ )
      *c = ~( *c >> 4  |  *c << 4 );

   // exchange chars around middle
   for ( --c;  c > str;  c--, str++ )
   {
      *c   ^= *str;
      *str ^= *c;
      *c   ^= *str;
   }
}

// Cipher.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\common.cpp ===
//#pragma title( "Common.cpp - Common class implementations" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Common.cpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Common class implementations.
Updates     -  1997-09-09 RED ErrorCodeToText moved to Err.cpp
            -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif

#include "Common.hpp"

///////////////////////////////////////////////////////////////////////////////
// TTime class member functions
///////////////////////////////////////////////////////////////////////////////

   TTime                     gTTime;       // global instance of TTime

time_t                                     // ret-current time
   TTime::Now(
      time_t               * pTime         // out-optional current time
   )  const
{
   time_t                    tTime;        // work copy of current time

   union
   {
      __int64                intTime;
      FILETIME               fileTime;
   }                         wTime;
   GetSystemTimeAsFileTime( &wTime.fileTime );
   tTime = ConvertFiletimeToTimet( wTime.intTime );

   if ( pTime ) *pTime = tTime;
   return tTime;
}

__int64                                    // ret-current time
   TTime::NowAsFiletime(
      __int64              * pTime         // out-optional current time
   )  const
{
   union
   {
      __int64                intTime;
      FILETIME               fileTime;
   }                         wTime;
   GetSystemTimeAsFileTime( &wTime.fileTime );
   if ( pTime ) *pTime = wTime.intTime;
   return wTime.intTime;
}

time_t                                     // ret-time_t representation
   TTime::ConvertFiletimeToTimet(
      __int64                fileTime      // in -filetime representation
   )  const
{
   __int64                   wTime;        // intermediate work area
   time_t                    retTime;      // returned time

   // If the source date/time is less than the minimum date/time supported
   // by time_t, then zero is returned.
   // If the source date/time is more that the maximum date/time supported
   // by time_t, then ULONG_MAX is returned.

   wTime = fileTime / 10000000;

   if ( wTime < 11644473600 )
   {
      retTime = 0;
   }
   else
   {
      wTime -= 11644473600;
      if ( wTime > ULONG_MAX )
      {
         retTime = ULONG_MAX;
      }
      else
      {
         retTime = (time_t) wTime;
      }
   }

   return retTime;
}


WCHAR *                                     // ret-YYYY-MM-DD HH:MM:SS string
   TTime::FormatIsoUtc(
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const
{
   struct tm               * tmTime;

   tmTime = gmtime( &tTime );
   tmTime->tm_year += tmTime->tm_year >= 70 ? 1900 : 2000;
   swprintf(
         sTime,
         L"%04d-%02d-%02d %02d:%02d:%02d",
         tmTime->tm_year,
         tmTime->tm_mon+1,
         tmTime->tm_mday,
         tmTime->tm_hour,
         tmTime->tm_min,
         tmTime->tm_sec );

   return sTime;
}

WCHAR *                                    // ret-YYYY-MM-DD HH:MM:SS string
   TTime::FormatIsoLcl(
      time_t                 tTime        ,// in -time_t representation
      WCHAR                * sTime         // out-YYYY-MM-DD HH:MM:SS string
   )  const
{
   struct tm               * tmTime;

   TIME_ZONE_INFORMATION     infoTime;     // WIN32 time zone info
   time_t                    wTime;        // workarea
   switch ( GetTimeZoneInformation( &infoTime ) )
   {
      case TIME_ZONE_ID_STANDARD:
         wTime = infoTime.StandardBias;
         break;
      case TIME_ZONE_ID_DAYLIGHT:
         wTime = infoTime.DaylightBias;
         break;
      default:
         wTime = 0;
         break;
   }
   wTime = (infoTime.Bias + wTime) * 60;
   wTime = tTime - wTime;
   if ( wTime < 0 )
   {
      wTime = 0;
   }
   tmTime = gmtime( &wTime );
   tmTime->tm_year += tmTime->tm_year >= 70 ? 1900 : 2000;
   swprintf(
         sTime,
         L"%04d-%02d-%02d %02d:%02d:%02d",
         tmTime->tm_year,
         tmTime->tm_mon+1,
         tmTime->tm_mday,
         tmTime->tm_hour,
         tmTime->tm_min,
         tmTime->tm_sec );

   return sTime;
}

// Return time zone information
// If the returned value is TRUE, the EaTimeZoneInfo structure is filled in
// If the returned value is FALSE, the EaTimeZoneInfo structure is all zeroes
// Note:  UTC (gTTime.Now( NULL )) plus pTimeZoneInfo->biasdst is the local date/time
BOOL
   EaGetTimeZoneInfo(
      EaTimeZoneInfo       * pTimeZoneInfo // in -time zone information
   )
{
   memset( pTimeZoneInfo, 0, sizeof *pTimeZoneInfo );
   BOOL                      retval=TRUE;  // returned value
   DWORD                     OsRc;         // OS return code
   TIME_ZONE_INFORMATION     TimeZoneInfo; // WIN32 time zone info

   OsRc = GetTimeZoneInformation( &TimeZoneInfo );
   switch ( OsRc )
   {
      case TIME_ZONE_ID_STANDARD:
         pTimeZoneInfo->dst = TimeZoneInfo.StandardBias;
         break;
      case TIME_ZONE_ID_DAYLIGHT:
         pTimeZoneInfo->dst = TimeZoneInfo.DaylightBias;
         break;
      case TIME_ZONE_ID_UNKNOWN:
         retval = TimeZoneInfo.Bias;
         break;
      default:
         retval = FALSE;
         break;
   }
   if ( retval )
   {
      pTimeZoneInfo->bias = TimeZoneInfo.Bias * 60;
      pTimeZoneInfo->dst *= 60;
      pTimeZoneInfo->biasdst = pTimeZoneInfo->bias + pTimeZoneInfo->dst;
   }
   return retval;
}

// Common.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\err.cpp ===
//#pragma title( "Err.cpp - Basic error handling/message/logging" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  Err.cpp
System      -  Common
Author      -  Tom Bernhardt, Rich Denham
Created     -  1994-08-22
Description -  Implements the TError class that handles basic exception
               handling, message generation, and logging functions.
Updates     -  1997-09-12 RED replace TTime class
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#ifndef WIN16_VERSION
   #include <lm.h>
#endif

#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <string.h>
#include <stdarg.h>
#include <share.h>
#include <time.h>
#include <rpc.h>
#include <rpcdce.h>
#include <sys\types.h>
#include <sys\stat.h>

#include "Common.hpp"
#include "Err.hpp"
#include "UString.hpp"
#include <ResStr.h>
#include "TReg.hpp"

#define  TERR_MAX_MSG_LEN  (2000)
#define  BYTE_ORDER_MARK   (0xFEFF)


TError::TError(
      int                    displevel    ,// in -mimimum severity level to display
      int                    loglevel     ,// in -mimimum severity level to log
      WCHAR          const * filename     ,// in -file name of log (NULL if none)
      int                    logmode      ,// in -0=replace, 1=append
      int                    beeplevel     // in -min error level for beeping
   )
{
   lastError = 0;
   maxError = 0;
   logLevel = loglevel;
   dispLevel = displevel;
   logFile = NULL;
   beepLevel = beeplevel;
   LogOpen(filename, logmode, loglevel);
}


TError::~TError()
{
   LogClose();
}

// Closes any existing open logFile and opens a new log file if the fileName is
// not null.  If it is a null string, then a default fileName of "Temp.log" is
// used.
BOOL
   TError::LogOpen(
      WCHAR           const * fileName ,// in -name of file including any path
      int                     mode     ,// in -0=overwrite, 1=append
      int                     level    ,// in -minimum level to log
      bool                   bBeginNew  // in -begin a new log file
   )
{
   BOOL                       retval=TRUE;

   if ( logFile )
   {
      fclose(logFile);
      logFile = NULL;
   }

   if ( fileName && fileName[0] )
   {
      // Check to see if the file already exists
      WIN32_FIND_DATA      fDat;
      HANDLE               hFind;
      BOOL                 bExisted = FALSE;

      hFind = FindFirstFile(fileName,&fDat);
      if ( hFind != INVALID_HANDLE_VALUE )
      {
         FindClose(hFind);

         if (bBeginNew)
         {
            // rename existing log file

            // get next sequence number from registry
            DWORD dwSequence = 1;
            static WCHAR c_szValueName[] = L"LogSeqNum";
            TRegKey key(GET_STRING(IDS_HKLM_DomainAdmin_Key));
            key.ValueGetDWORD(c_szValueName, &dwSequence);

            // split path components
            WCHAR szPath[_MAX_PATH];
            WCHAR szDrive[_MAX_DRIVE];
            WCHAR szDir[_MAX_DIR];
            WCHAR szFName[_MAX_FNAME];
            WCHAR szExt[_MAX_EXT];
            _wsplitpath(fileName, szDrive, szDir, szFName, szExt);

            // find name for backup that isn't already used...

            for (bool bFoundName = false; bFoundName == false; dwSequence++)
            {
               // generate backup name using the sequence number
               WCHAR szFNameSeq[_MAX_FNAME];
               wsprintf(szFNameSeq, L"%s %04lu", szFName, dwSequence);

               // make path from path components
               _wmakepath(szPath, szDrive, szDir, szFNameSeq, szExt);

               // check if file exists
               WIN32_FIND_DATA fd;
               HANDLE hFind = FindFirstFile(szPath, &fd);

               if (hFind == INVALID_HANDLE_VALUE)
               {
                  DWORD dwError = GetLastError();

                  if (dwError == ERROR_FILE_NOT_FOUND)
                  {
                     bFoundName = true;
                  }
               }
               else
               {
                  FindClose(hFind);
               }
            }

            if (bFoundName)
            {
               // attempt to rename file
               if (MoveFile(fileName, szPath))
               {
                  // save next sequence number in registry
                  key.ValueSetDWORD(c_szValueName, dwSequence);
               }
               else
               {
                  bExisted = TRUE;
               }
            }

            if (!bExisted)
            {
               // get log history value from registry

               TRegKey keyHistory(GET_STRING(IDS_HKLM_DomainAdmin_Key));

               DWORD dwHistory = 20;
               static WCHAR c_szValueName[] = L"LogHistory";

               if (keyHistory.ValueGetDWORD(c_szValueName, &dwHistory) == ERROR_FILE_NOT_FOUND)
               {
                  keyHistory.ValueSetDWORD(c_szValueName, dwHistory);
               }

               keyHistory.Close();

               if (dwSequence > dwHistory)
               {
                  DWORD dwMinimum = dwSequence - dwHistory;

                  // generate migration log path specification

                  WCHAR szFNameSpec[_MAX_FNAME];
                  wsprintf(szFNameSpec, L"%s *", szFName);
                  _wmakepath(szPath, szDrive, szDir, szFNameSpec, szExt);

                  // for each migration older than minimum

                  WIN32_FIND_DATA fd;

                  HANDLE hFind = FindFirstFile(szPath, &fd);

                  if (hFind != INVALID_HANDLE_VALUE)
                  {
                     do
                     {
                        DWORD dwFileSequence;

                        if (swscanf(fd.cFileName, L"%*s %lu", &dwFileSequence) == 1)
                        {
                           // if file sequence less than minimum to keep...

                           if (dwFileSequence < dwMinimum)
                           {
                              // delete file
                              WCHAR szDeleteName[_MAX_FNAME];
                              _wsplitpath(fd.cFileName, 0, 0, szDeleteName, 0);
                              WCHAR szDeletePath[_MAX_PATH];
                              _wmakepath(szDeletePath, szDrive, szDir, szDeleteName, szExt);
                              DeleteFile(szDeletePath);
                           }
                        }
                     }
                     while (FindNextFile(hFind, &fd));

                     FindClose(hFind);
                  }
               }
            }

            key.Close();
         }
         else
         {
            // overwrite or append to existing log file

            bExisted = TRUE;
         }
      }

      logFile = _wfsopen( fileName, mode == 0 ? L"wb" : L"ab", _SH_DENYNO );
      if ( !logFile )
      {
         MsgWrite( 4101, L"Log Open(%s) failed", fileName );
         retval = FALSE;
      }
      else
      {
         if (! bExisted )
         {
            // this is a new file we've just created
            // we need to write the byte order mark to the beginning of the file
            WCHAR x = BYTE_ORDER_MARK;
            fwprintf(logFile,L"%lc",x);
         }
      }
   }

   logLevel = level;

   return retval;
}


//-----------------------------------------------------------------------------
// Writes formatted message to log file and flushes buffers
//-----------------------------------------------------------------------------
void TError::LogWrite(WCHAR const * msg)
{
   WCHAR                     sTime[32];
   WCHAR                     sTemp[TERR_MAX_MSG_LEN];   
   
   // Get rid of the <CR> from the end of the message because it causes things
   // to run together in the logs
   wcscpy(sTemp, msg);
   DWORD dwLen = wcslen(sTemp);
   if ( sTemp[dwLen-1] == 0x0d )
      sTemp[dwLen-1] = 0x00;

   if ( logFile )
   {
      fseek(logFile, 0L, SEEK_END);
      fwprintf(
            logFile,
            L"%s %s\r\n",
            gTTime.FormatIsoLcl( gTTime.Now( NULL ), sTime ),
            sTemp );
      fflush( logFile );
   }
}

//-----------------------------------------------------------------------------
// Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TError::MsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message to display
      ...                                  // in -printf args to msg pattern
   )
{
   WCHAR                     suffix[TERR_MAX_MSG_LEN];
   va_list                   argPtr;

   va_start(argPtr, msg);
   _vsnwprintf(suffix, DIM(suffix) - 1, msg, argPtr);
   suffix[DIM(suffix) - 1] = L'\0';
   va_end(argPtr);
   MsgProcess(num, suffix);
}

#ifndef WIN16_VERSION
//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TError::SysMsgWrite(
      int                    num          ,// in -error number/level code
      DWORD                  lastRc       ,// in -error return code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   )
{
   WCHAR                     suffix[TERR_MAX_MSG_LEN];
   va_list                   argPtr;
   int                       len;

   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;

   va_start(argPtr, msg);
   len = _vsnwprintf(suffix, DIM(suffix) - 1, msg, argPtr);

   // append the system message for the lastRc at the end.
   if ( len < DIM(suffix) - 1 )
   {
      ErrorCodeToText(lastRc, DIM(suffix) - len - 1, suffix + len);
   }
   suffix[DIM(suffix) - 1] = L'\0';
   va_end(argPtr);
   MsgProcess(num, suffix);
}

//-----------------------------------------------------------------------------
// System Error message with format and arguments
//-----------------------------------------------------------------------------
void __cdecl
   TError::SysMsgWrite(
      int                    num          ,// in -error number/level code
      WCHAR          const   msg[]        ,// in -error message/pattern to display
      ...                                  // in -printf args to msg pattern
   )
{
   WCHAR                     suffix[TERR_MAX_MSG_LEN];
   va_list                   argPtr;
   int                       len;
   DWORD                     lastRc = GetLastError();

   // When an error occurs while in a constructor for a global object,
   // the TError object may not yet exist.  In this case, "this" is zero
   // and we gotta get out of here before we generate a protection exception.

   if ( !this )
      return;

   va_start( argPtr, msg );
   len = _vsnwprintf( suffix, DIM(suffix) - 1, msg, argPtr );

   // append the system message for the lastRc at the end.
   if ( len < DIM(suffix) - 1 )
   {
      ErrorCodeToText(lastRc, DIM(suffix) - len - 1, suffix + len);
   }
   suffix[DIM(suffix) - 1] = L'\0';
   va_end(argPtr);
   MsgProcess(num, suffix);
}
#endif

//-----------------------------------------------------------------------------
// Error message format, display and exception processing function
//-----------------------------------------------------------------------------
void __stdcall
   TError::MsgProcess(
      int                    num          ,// in -error number/level code
      WCHAR          const * str           // in -error string to display
   )
{
   static WCHAR      const   prefLetter[] = L"TIWEEEEXXXXX"; // These form the status code that appears at the start of each error message
   WCHAR                     fullmsg[TERR_MAX_MSG_LEN];
   struct
   {
      USHORT                 frequency;    // audio frequency
      USHORT                 duration;     // duration in mSec
   }                         audio[] = {{ 300,  20},{ 500,  50},{ 700, 100},
                                        { 800, 200},{1000, 300},{1500, 400},
                                        {2500, 750},{2500,1000},{2500,1000}};

   if ( num >= 0 )
      level = num / 10000;                 // 10000's position of error number
   else
      level = -1;

   if ( level <= 0 )
   {
      wcsncpy(fullmsg, str, DIM(fullmsg));
      fullmsg[DIM(fullmsg) - 1] = L'\0';  // ensure null termination
   }
   else
   {
      if ( num > maxError )
         maxError = num;
      _snwprintf(fullmsg, DIM(fullmsg), L"%c%1d:%04d %-s", prefLetter[level+1], level, num % 10000, str);
      fullmsg[DIM(fullmsg) - 1] = L'\0';  // ensure null termination
   }

   lastError = num;

   if ( level >= beepLevel )
      Beep(audio[level].frequency, audio[level].duration);

   if ( level >= logLevel )
      LogWrite(fullmsg);

   if ( level > 4 )
   {
      exit(level);
   }
}

//-----------------------------------------------------------------------------
// Return text for error code
//-----------------------------------------------------------------------------

WCHAR *        
   TError::ErrorCodeToText(
      DWORD                  code         ,// in -message code
      DWORD                  lenMsg       ,// in -length of message text area
      WCHAR                * msg           // out-returned message text
   )
{
   static HMODULE            hNetMsg = NULL;
   DWORD                     rc;
   WCHAR                   * pMsg;

   msg[0] = '\0'; // force to null

   if ( code >= NERR_BASE && code < MAX_NERR )
   {
      if ( !hNetMsg )
         hNetMsg = LoadLibrary(L"netmsg.dll");
      rc = 1;
   }
   else
   {
      rc = DceErrorInqText( code, msg );
      // Change any imbedded CR or LF to blank.
      for ( pMsg = msg;
            *pMsg;
            pMsg++ )
      {
         if ( (*pMsg == L'\x0D') || (*pMsg == L'\x0A') )
            *pMsg = L' ';
      }
      // Remove trailing blanks
      for ( pMsg--;
            pMsg >= msg;
            pMsg-- )
      {
         if ( *pMsg == L' ' )
            *pMsg = L'\0';
         else
            break;
      }
   }
   if ( rc )
   {
      if ( code >= NERR_BASE && code < MAX_NERR && hNetMsg )
      {
         FormatMessage(FORMAT_MESSAGE_FROM_HMODULE
                      | FORMAT_MESSAGE_MAX_WIDTH_MASK
                      | FORMAT_MESSAGE_IGNORE_INSERTS
                      | 80,
                        hNetMsg,
                        code,
                        0,
                        msg,
                        lenMsg,
                        NULL );
      }
      else
      {
         FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
                      | FORMAT_MESSAGE_MAX_WIDTH_MASK
                      | FORMAT_MESSAGE_IGNORE_INSERTS
                      | 80,
                        NULL,
                        code,
                        0,
                        msg,
                        lenMsg,
                        NULL );
      }
   }
   return msg;
}

// Err.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\hrmsg.cpp ===
/******************************************************************
 *                                                                *
 * CPP file for common error handling functions.                  *
 *                                                                *
 ******************************************************************/

#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif

#include "HrMsg.h"
#include <stdio.h>
#include <stdarg.h>


namespace HrMsg_cpp
{

void __stdcall AdmtThrowErrorImpl(const _com_error& ce, LPCTSTR pszDescription);

}

using namespace HrMsg_cpp;


//---------------------------------------------------------------------------
// GetError Helper Function
//---------------------------------------------------------------------------

_com_error GetError(HRESULT hr)
{
   _com_error ce(hr);

   IErrorInfo* pErrorInfo = NULL;

   if (GetErrorInfo(0, &pErrorInfo) == S_OK)
   {
      ce = _com_error(FAILED(hr) ? hr : E_FAIL, pErrorInfo);
   }
   else
   {
      ce = _com_error(FAILED(hr) ? hr : S_OK);
   }

   return ce;
}

//-----------------------------------------------------------------------------
// Return text for hresults
//-----------------------------------------------------------------------------
_bstr_t __stdcall HResultToText2(HRESULT hr)
{
	_bstr_t bstrError;

	LPTSTR pszError = NULL;

	try
	{
		switch (HRESULT_FACILITY(hr))
		{
		//	case FACILITY_NULL:        //  0
		//	case FACILITY_RPC:         //  1
		//	case FACILITY_DISPATCH:    //  2
		//	case FACILITY_STORAGE:     //  3
			case FACILITY_ITF:         //  4
			{
				HMODULE hModule = LoadLibrary(_T("MSDAERR.dll"));

				if (hModule)
				{
					FormatMessage(
						FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE,
						hModule,
						hr,
						0,
						(LPTSTR)&pszError,
						0,
						NULL
					);

					FreeLibrary(hModule);
				}
				break;
			}
			case FACILITY_WIN32:       //  7
			{
				FormatMessage(
					FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM,
					NULL,
					hr,
					0,
					(LPTSTR)&pszError,
					0,
					NULL
				);
				break;
			}
		//	case FACILITY_WINDOWS:     //  8
		//	case FACILITY_SSPI:        //  9
		//	case FACILITY_SECURITY:    //  9
			case FACILITY_CONTROL:     // 10
			{
				HMODULE hModule = LoadLibrary(_T("MSADER15.dll"));

				if (hModule)
				{
					FormatMessage(
						FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE,
						hModule,
						hr,
						0,
						(LPTSTR)&pszError,
						0,
						NULL
					);

					FreeLibrary(hModule);
				}
				break;
			}
		//	case FACILITY_CERT:        // 11
		//	case FACILITY_INTERNET:    // 12
		//	case FACILITY_MEDIASERVER: // 13
			case FACILITY_MSMQ:        // 14
			{
				HMODULE hModule = LoadLibrary(_T("MQUTIL.dll"));

				if (hModule)
				{
					FormatMessage(
						FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_HMODULE,
						hModule,
						hr,
						0,
						(LPTSTR)&pszError,
						0,
						NULL
					);

					FreeLibrary(hModule);
				}
				break;
			}
		//	case FACILITY_SETUPAPI:    // 15
		//	case FACILITY_SCARD:       // 16
		//	case FACILITY_COMPLUS:     // 17
		//	case FACILITY_AAF:         // 18
		//	case FACILITY_URT:         // 19
		//	case FACILITY_ACS:         // 20
			default:
			{
				FormatMessage(
					FORMAT_MESSAGE_ALLOCATE_BUFFER|FORMAT_MESSAGE_FROM_SYSTEM,
					NULL,
					hr,
					0,
					(LPTSTR)&pszError,
					0,
					NULL
				);
				break;
			}
		}

		if (pszError)
		{
			size_t cch = _tcslen(pszError);

			if ((cch > 1) && (pszError[cch - 1] == _T('\n')))
			{
				pszError[cch - 1] = 0;

				if (pszError[cch - 2] == _T('\r'))
				{
					pszError[cch - 2] = 0;
				}
			}

			bstrError = pszError;
		}
		else
		{
			_TCHAR szError[32];
			_stprintf(szError, _T("Unknown error 0x%08lX."), hr);

			bstrError = szError;
		}
	}
	catch (...)
	{
		;
	}

	if (pszError)
	{
		LocalFree((HLOCAL)pszError);
	}

    return bstrError;
}


_bstr_t FormatHRMsg(LPCTSTR pformatStr, HRESULT hr)
{
	WCHAR sError[MAX_PATH]; 
    _com_error ce = GetError(hr);
    _bstr_t bstrDescription = ce.Description();

    if (bstrDescription.length() > 0)
    {
	  swprintf(sError, pformatStr, (WCHAR*)bstrDescription);
	}
	else
	{
	  swprintf(sError, pformatStr, (WCHAR*)HResultToText(hr));
	}

	return sError;
}

_bstr_t __stdcall HResultToText(HRESULT hr)
{
	return GetError(hr).Description();
}


//---------------------------------------------------------------------------
// AdmtThrowError
//
// Generates formatted error description and generates exception.
//
// 2000-??-?? Mark Oluper - initial
// 2001-02-13 Mark Oluper - moved to commonlib
//---------------------------------------------------------------------------

void __cdecl AdmtThrowError(_com_error ce, HINSTANCE hInstance, UINT uId, ...)
{
	_TCHAR szFormat[512];
	_TCHAR szDescription[1024];

	if (LoadString(hInstance, uId, szFormat, 512))
	{
		va_list args;
		va_start(args, uId);
		_vsntprintf(szDescription, sizeof(szDescription) / sizeof(szDescription[0]), szFormat, args);
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	AdmtThrowErrorImpl(ce, szDescription);
}


void __cdecl AdmtThrowError(_com_error ce, LPCTSTR pszFormat, ...)
{
	_TCHAR szDescription[1024];

	if (pszFormat)
	{
		va_list args;
		va_start(args, pszFormat);
		_vsntprintf(szDescription, sizeof(szDescription) / sizeof(szDescription[0]), pszFormat, args);
		va_end(args);
	}
	else
	{
		szDescription[0] = _T('\0');
	}

	AdmtThrowErrorImpl(ce, szDescription);
}


namespace HrMsg_cpp
{


//---------------------------------------------------------------------------
// AdmtThrowErrorImpl
//
// Concatenates rich error information and throws exception.
//
// 2000-??-?? Mark Oluper - initial
// 2001-02-13 Mark Oluper - moved to commonlib
//---------------------------------------------------------------------------

void __stdcall AdmtThrowErrorImpl(const _com_error& ce, LPCTSTR pszDescription)
{
	_bstr_t bstrNewDescription;

	try
	{
		bstrNewDescription = pszDescription;

		_bstr_t bstrSource = ce.Source();

		if (bstrSource.length() > 0)
		{
			if (bstrNewDescription.length() > 0)
			{
				bstrNewDescription += _T(" : ");
			}

			bstrNewDescription += bstrSource;
		}

		_bstr_t bstrOldDescription = ce.Description();

		if (bstrOldDescription.length() > 0)
		{
			if (bstrNewDescription.length() > 0)
			{
				if (bstrSource.length() > 0)
				{
					bstrNewDescription += _T(": ");
				}
				else
				{
					bstrNewDescription += _T(" ");
				}
			}

			bstrNewDescription += bstrOldDescription;
		}
		else
		{
			LPCTSTR pszErrorMessage = ce.ErrorMessage();

			if (pszErrorMessage)
			{
				if (bstrNewDescription.length() > 0)
				{
					bstrNewDescription += _T(" : ");
				}

				bstrNewDescription += pszErrorMessage;
			}
		}
	}
	catch (...)
	{
		;
	}

	ICreateErrorInfoPtr spCreateErrorInfo;
	CreateErrorInfo(&spCreateErrorInfo);

	if (spCreateErrorInfo)
	{
	//	LPOLESTR pszProgId;

	//	if (ProgIDFromCLSID(clsid, &pszProgId) == S_OK)
	//	{
	//		spCreateErrorInfo->SetSource(pszProgId);
	//		CoTaskMemFree(pszProgId);
	//	}
	//	else
	//	{
			spCreateErrorInfo->SetSource(L"");
	//	}

	//	spCreateErrorInfo->SetGUID(iid);
		spCreateErrorInfo->SetGUID(GUID_NULL);
		spCreateErrorInfo->SetDescription(bstrNewDescription);
		spCreateErrorInfo->SetHelpFile(L"");
		spCreateErrorInfo->SetHelpContext(0);
	}

	_com_raise_error(ce.Error(), IErrorInfoPtr(spCreateErrorInfo).Detach());
}


} // namespace
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\isadmin.cpp ===
//#pragma title( "IsAdmin.cpp - Determine if user is administrator" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  IsAdmin.cpp
System      -  Common
Author      -  Rich Denham
Created     -  1996-06-04
Description -  Determine if user is administrator (local or remote)
Updates     -
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#endif

#include <lm.h>

#include "Common.hpp"
#include "UString.hpp"
#include "IsAdmin.hpp"


namespace
{

#ifndef SECURITY_MAX_SID_SIZE
#define SECURITY_MAX_SID_SIZE (sizeof(SID) - sizeof(DWORD) + (SID_MAX_SUB_AUTHORITIES * sizeof(DWORD)))
#endif
const DWORD MAX_VERSION_2_ACE_SIZE = sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD) + SECURITY_MAX_SID_SIZE;


// GetEffectiveToken
//
// Brown, Keith. 2000. Programming Windows Security. Reading MA: Addison-Wesley
// Pages 120-121

HANDLE __stdcall GetEffectiveToken(DWORD dwDesiredAccess, BOOL bImpersonation, SECURITY_IMPERSONATION_LEVEL silLevel)
{
	HANDLE hToken = 0;

	if (!OpenThreadToken(GetCurrentThread(), dwDesiredAccess, TRUE, &hToken))
	{
		if (GetLastError() == ERROR_NO_TOKEN)
		{
			DWORD dwAccess = bImpersonation ? TOKEN_DUPLICATE : dwDesiredAccess;

			if (OpenProcessToken(GetCurrentProcess(), dwAccess, &hToken))
			{
				if (bImpersonation)
				{
					// convert primary to impersonation token

					HANDLE hImpersonationToken = 0;
					DuplicateTokenEx(hToken, dwDesiredAccess, 0, silLevel, TokenImpersonation, &hImpersonationToken);
					CloseHandle(hToken);
					hToken = hImpersonationToken;
				}
			}
		}
	}

	return hToken;
}


// CheckTokenMembership
//
// Brown, Keith. 2000. Programming Windows Security. Reading MA: Addison-Wesley
// Pages 130-131

//#if (_WIN32_WINNT < 0x0500)
#if TRUE // always use our function
BOOL WINAPI AdmtCheckTokenMembership(HANDLE hToken, PSID pSid, PBOOL pbIsMember)
{
	// if no token was passed, CTM uses the effective
	// security context (the thread or process token)

	if (!hToken)
	{
		hToken = GetEffectiveToken(TOKEN_QUERY, TRUE, SecurityIdentification);
	}

	if (!hToken)
	{
		return FALSE;
	}

	// create a security descriptor that grants a
	// specific permission only to the specified SID

	BYTE dacl[sizeof ACL + MAX_VERSION_2_ACE_SIZE];
	ACL* pdacl = (ACL*)dacl;
	InitializeAcl(pdacl, sizeof dacl, ACL_REVISION);
	AddAccessAllowedAce(pdacl, ACL_REVISION, 1, pSid);

	SECURITY_DESCRIPTOR sd;
	InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION);
	SID sidWorld = { SID_REVISION, 1, SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID };
	SetSecurityDescriptorOwner(&sd, &sidWorld, FALSE);
	SetSecurityDescriptorGroup(&sd, &sidWorld, FALSE);
	SetSecurityDescriptorDacl(&sd, TRUE, pdacl, FALSE);

	// now let AccessCheck do all the hard work

	GENERIC_MAPPING gm = { 0, 0, 0, 1 };
	PRIVILEGE_SET ps;
	DWORD cb = sizeof ps;
	DWORD ga;

	return AccessCheck(&sd, hToken, 1, &gm, &ps, &cb, &ga, pbIsMember);
}
#else
#define AdmtCheckTokenMembership CheckTokenMembership
#endif

} // namespace


///////////////////////////////////////////////////////////////////////////////
// Determine if user is administrator on local machine                       //
///////////////////////////////////////////////////////////////////////////////

DWORD                                      // ret-OS return code, 0=User is admin
   IsAdminLocal()
{
	DWORD dwError = NO_ERROR;

	// create well known SID Administrators

	SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;

	PSID psidAdministrators;

	BOOL bSid = AllocateAndInitializeSid(
		&siaNtAuthority,
		2,
		SECURITY_BUILTIN_DOMAIN_RID,
		DOMAIN_ALIAS_RID_ADMINS,
		0,
		0,
		0,
		0,
		0,
		0,
		&psidAdministrators
	);

	if (bSid)
	{
		// check if token membership includes Administrators

		BOOL bIsMember;

		if (AdmtCheckTokenMembership(0, psidAdministrators, &bIsMember))
		{
			dwError = bIsMember ? NO_ERROR : ERROR_ACCESS_DENIED;
		}
		else
		{
			dwError = GetLastError();
		}

		FreeSid(psidAdministrators);
	}
	else
	{
		dwError = GetLastError();
	}

	return dwError;
}

///////////////////////////////////////////////////////////////////////////////
// Determine if user is administrator on remote machine                      //
///////////////////////////////////////////////////////////////////////////////

DWORD                                      // ret-OS return code, 0=User is admin
   IsAdminRemote(
      WCHAR          const * pMachine      // in -\\machine name
   )
{
   DWORD                     osRc;         // OS return code
   HANDLE                    hToken=INVALID_HANDLE_VALUE; // process token
   BYTE                      bufTokenGroups[10000]; // token group information
   DWORD                     lenTokenGroups;        // returned length of token group information
   BYTE                      bufTokenUser[1000];
   DWORD                     lenTokenUser;
//   SID_IDENTIFIER_AUTHORITY  siaNtAuthority = SECURITY_NT_AUTHORITY;
   PTOKEN_GROUPS             ptgGroups = (PTOKEN_GROUPS) bufTokenGroups;
   PTOKEN_USER               ptUser = (PTOKEN_USER)bufTokenUser;
//   DWORD                     iGroup;       // group number index
   LPLOCALGROUP_MEMBERS_INFO_0 pBuf = NULL;
   DWORD                     dwPrefMaxLen = 255;
   DWORD                     dwEntriesRead = 0;
   DWORD                     dwTotalEntries = 0;
   DWORD_PTR                 dwResumeHandle = 0;
//   DWORD                     dwTotalCount = 0;
//   DWORD                     rcOs = 0;
   WCHAR                     grpName[255];
   PSID                      pSid;
   SID_NAME_USE              use;
   DWORD                     dwNameLen = 255;
   DWORD                     dwDomLen = 255;
   WCHAR                     domain[255];
   SID_IDENTIFIER_AUTHORITY sia = SECURITY_NT_AUTHORITY;
//   SID_IDENTIFIER_AUTHORITY creatorIA =    SECURITY_CREATOR_SID_AUTHORITY;
   BOOL                      bIsAdmin = FALSE;

   if ( OpenProcessToken( GetCurrentProcess(), TOKEN_READ, &hToken ) )
   {
      if ( GetTokenInformation( hToken, TokenGroups, bufTokenGroups, sizeof bufTokenGroups, &lenTokenGroups ) )
      {
         if ( GetTokenInformation(hToken,TokenUser,bufTokenUser,sizeof bufTokenUser,&lenTokenUser) )
         {
            // build the Administrators SID
            if ( AllocateAndInitializeSid(
                     &sia,
                     2,
                     SECURITY_BUILTIN_DOMAIN_RID,
                     DOMAIN_ALIAS_RID_ADMINS,
                     0, 0, 0, 0, 0, 0,
                     &pSid
               ) )
            {
                  // and look up the administrators group on the specified machine
               if ( LookupAccountSid(pMachine, pSid, grpName, &dwNameLen, domain, &dwDomLen, &use) )
               {
/*
                  // enumerate the contents of the administrators group on the specified machine
                  do 
                  {
                     osRc =   NetLocalGroupGetMembers(
                                                   const_cast<WCHAR*>(pMachine),
                                                   grpName,
                                                   0,
                                                   (LPBYTE*)&pBuf,
                                                   dwPrefMaxLen,
                                                   &dwEntriesRead,
                                                   &dwTotalEntries,
                                                   &dwResumeHandle
                                                  );
                     if ( !osRc || osRc == ERROR_MORE_DATA )
                     {
                        for ( UINT i = 0 ; i < dwEntriesRead ; i++ )
                        {
                           // for each SID in the administrators group, see if that SID is in our token
                           if ( EqualSid( pBuf[i].lgrmi0_sid , ptUser->User.Sid) )
                           {
                              bIsAdmin = TRUE;
                              break;
                           }
                           for ( iGroup = 0;
                                 iGroup < ptgGroups->GroupCount;
                                 iGroup++ )
                           {
                          
                              if ( EqualSid( pBuf[i].lgrmi0_sid,ptgGroups->Groups[iGroup].Sid ) )
                              {
                                 osRc = 0;
                                 bIsAdmin = TRUE;
                                 break;
                              }
                           }
                           if ( bIsAdmin )
                              break;
                        }
                     }
                     if ( pBuf ) 
                        NetApiBufferFree(pBuf);
                     if ( bIsAdmin )
                        break;
                  } while ( osRc == ERROR_MORE_DATA );
*/
                  // remove explict administrator check
                  bIsAdmin = TRUE;
               }
               else 
                  osRc = GetLastError();
               FreeSid(pSid);
            }
            else 
               osRc = GetLastError();
         }
         else
            osRc = GetLastError();
      }
      else
         osRc = GetLastError();
   }
   else
      osRc = GetLastError();

   if ( hToken != INVALID_HANDLE_VALUE )
   {
      CloseHandle( hToken );
      hToken = INVALID_HANDLE_VALUE;
   }

   
   if ( bIsAdmin  )
      osRc = 0;
   else
      if ( ! osRc )
         osRc = ERROR_ACCESS_DENIED;
      
   return osRc;
}

// IsAdmin.cpp - end of file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\lsautils.cpp ===
/*---------------------------------------------------------------------------
  File: LSAUtils.cpp

  Comments: Code to change the domain membership of a workstation.
  

  This file also contains some general helper functions, such as:

  GetDomainDCName
  EstablishNullSession
  EstablishSession
  EstablishShare   // connects to a share
  InitLsaString
  GetDomainSid


  (c) Copyright 1999, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 02/03/99 12:37:51

 ---------------------------------------------------------------------------
*/

//

//#include "stdafx.h"
#include <windows.h>
#include <process.h>

#ifndef UNICODE
#define UNICODE
#define _UNICODE
#endif

#include <lm.h>         // for NetXxx API

#include <stdio.h>

#include "LSAUtils.h"
#include "ErrDct.hpp"
#include "ResStr.h"


#define RTN_OK 0
#define RTN_USAGE 1
#define RTN_ERROR 13

extern TErrorDct        err;


BOOL
   GetDomainDCName(
      LPWSTR                 Domain,       // in - domain name
      LPWSTR               * pPrimaryDC    // out- PDC name (must be freed with NetApiBufferFree)
    )
{
   NET_API_STATUS            nas;

   //
   // get the name of the Primary Domain Controller
   //
   // we're using NetGetDCName instead of DsGetDCName so this can work on NT 3.51

   nas = NetGetDCName(NULL, Domain, (LPBYTE *)pPrimaryDC);

   if(nas != NERR_Success) 
   {
      SetLastError(nas);
      return FALSE;
   }

   return TRUE;
}

BOOL 
   EstablishNullSession(
      LPCWSTR                Server,       // in - server name
      BOOL                   bEstablish    // in - TRUE=establish, FALSE=disconnect
    )
{
   return EstablishSession(Server,L"",L"",L"",bEstablish);
}

BOOL
   EstablishSession(
      LPCWSTR                Server,       // in - server name
      LPWSTR                 Domain,       // in - domain name for user credentials
      LPWSTR                 UserName,     // in - username for credentials to use
      LPWSTR                 Password,     // in - password for credentials 
      BOOL                   bEstablish    // in - TRUE=establish, FALSE=disconnect
    )
{
   LPCWSTR                   szIpc = L"\\IPC$";
   WCHAR                     RemoteResource[UNCLEN + 5 + 1]; // UNC len + \IPC$ + NULL
   DWORD                     cchServer;
   NET_API_STATUS            nas;

   //
   // do not allow NULL or empty server name
   //
   if(Server == NULL || *Server == L'\0') 
   {
       SetLastError(ERROR_INVALID_COMPUTERNAME);
       return FALSE;
   }

   cchServer = lstrlenW( Server );

   if( Server[0] != L'\\' && Server[1] != L'\\') 
   {

      //
      // prepend slashes and NULL terminate
      //
      RemoteResource[0] = L'\\';
      RemoteResource[1] = L'\\';
      RemoteResource[2] = L'\0';
   }
   else 
   {
      cchServer -= 2; // drop slashes from count
      
      RemoteResource[0] = L'\0';
   }

   if(cchServer > CNLEN) 
   {
      SetLastError(ERROR_INVALID_COMPUTERNAME);
      return FALSE;
   }

   if(lstrcatW(RemoteResource, Server) == NULL) 
   {
      return FALSE;
   }
   if(lstrcatW(RemoteResource, szIpc) == NULL) 
   {
      return FALSE;
   }

   //
   // disconnect or connect to the resource, based on bEstablish
   //
   if(bEstablish) 
   {
      USE_INFO_2 ui2;
      DWORD      errParm;

      ZeroMemory(&ui2, sizeof(ui2));

      ui2.ui2_local = NULL;
      ui2.ui2_remote = RemoteResource;
      ui2.ui2_asg_type = USE_IPC;
      ui2.ui2_domainname = Domain;
      ui2.ui2_username = UserName;
      ui2.ui2_password = Password;

      // try establishing session for one minute
      // if computer is not accepting any more connections

      for (int i = 0; i < (60000 / 5000); i++)
      {
         nas = NetUseAdd(NULL, 2, (LPBYTE)&ui2, &errParm);

         if (nas != ERROR_REQ_NOT_ACCEP)
         {
            break;
         }

         Sleep(5000);
      }
   }
   else 
   {
      nas = NetUseDel(NULL, RemoteResource, 0);
   }

   if( nas == NERR_Success ) 
   {
      return TRUE; // indicate success
   }
   SetLastError(nas);
   return FALSE;
}

BOOL
   EstablishShare(
      LPCWSTR                Server,       // in - server name
      LPWSTR                 Share,        // in - share name
      LPWSTR                 Domain,       // in - domain name for credentials to connect with
      LPWSTR                 UserName,     // in - user name to connect as
      LPWSTR                 Password,     // in - password for username
      BOOL                   bEstablish    // in - TRUE=connect, FALSE=disconnect
    )
{
   WCHAR                     RemoteResource[MAX_PATH]; 
   DWORD                     cchServer;
   NET_API_STATUS            nas;

   //
   // do not allow NULL or empty server name
   //
   if(Server == NULL || *Server == L'\0') 
   {
       SetLastError(ERROR_INVALID_COMPUTERNAME);
       return FALSE;
   }

   cchServer = lstrlenW( Server );

   if( Server[0] != L'\\' && Server[1] != L'\\') 
   {

      //
      // prepend slashes and NULL terminate
      //
      RemoteResource[0] = L'\\';
      RemoteResource[1] = L'\\';
      RemoteResource[2] = L'\0';
   }
   else 
   {
      cchServer -= 2; // drop slashes from count
      
      RemoteResource[0] = L'\0';
   }

   if(cchServer > CNLEN) 
   {
      SetLastError(ERROR_INVALID_COMPUTERNAME);
      return FALSE;
   }

   if(lstrcatW(RemoteResource, Server) == NULL) 
   {
      return FALSE;
   }
   if(lstrcatW(RemoteResource, Share) == NULL) 
   {
      return FALSE;
   }

   //
   // disconnect or connect to the resource, based on bEstablish
   //
   if(bEstablish) 
   {
      USE_INFO_2 ui2;
      DWORD      errParm;

      ZeroMemory(&ui2, sizeof(ui2));

      ui2.ui2_local = NULL;
      ui2.ui2_remote = RemoteResource;
      ui2.ui2_asg_type = USE_DISKDEV;
      ui2.ui2_domainname = Domain;
      ui2.ui2_username = UserName;
      ui2.ui2_password = Password;

      // try establishing session for one minute
      // if computer is not accepting any more connections

      for (int i = 0; i < (60000 / 5000); i++)
      {
         nas = NetUseAdd(NULL, 2, (LPBYTE)&ui2, &errParm);

         if (nas != ERROR_REQ_NOT_ACCEP)
         {
            break;
         }

         Sleep(5000);
      }
   }
   else 
   {
      nas = NetUseDel(NULL, RemoteResource, 0);
   }

   if( nas == NERR_Success ) 
   {
      return TRUE; // indicate success
   }
   SetLastError(nas);
   return FALSE;
}



void
   InitLsaString(
      PLSA_UNICODE_STRING    LsaString,    // i/o- pointer to LSA string to initialize
      LPWSTR                 String        // in - value to initialize LSA string to
    )
{
   DWORD                     StringLength;

   if( String == NULL ) 
   {
       LsaString->Buffer = NULL;
       LsaString->Length = 0;
       LsaString->MaximumLength = 0;
   }
   else
   {
      StringLength = lstrlenW(String);
      LsaString->Buffer = String;
      LsaString->Length = (USHORT) StringLength * sizeof(WCHAR);
      LsaString->MaximumLength = (USHORT) (StringLength + 1) * sizeof(WCHAR);
   }
}

BOOL
   GetDomainSid(
      LPWSTR                 PrimaryDC,   // in - domain controller of domain to acquire Sid
      PSID                 * pDomainSid   // out- points to allocated Sid on success
    )
{
   NET_API_STATUS            nas;
   PUSER_MODALS_INFO_2       umi2 = NULL;
   DWORD                     dwSidSize;
   BOOL                      bSuccess = FALSE; // assume this function will fail
   
   *pDomainSid = NULL;    // invalidate pointer

   __try {

   //
   // obtain the domain Sid from the PDC
   //
   nas = NetUserModalsGet(PrimaryDC, 2, (LPBYTE *)&umi2);
   
   if(nas != NERR_Success) __leave;
   //
   // if the Sid is valid, obtain the size of the Sid
   //
   if(!IsValidSid(umi2->usrmod2_domain_id)) __leave;
   
   dwSidSize = GetLengthSid(umi2->usrmod2_domain_id);

   //
   // allocate storage and copy the Sid
   //
   *pDomainSid = LocalAlloc(LPTR, dwSidSize);
   
   if(*pDomainSid == NULL) __leave;

   if(!CopySid(dwSidSize, *pDomainSid, umi2->usrmod2_domain_id)) __leave;

   bSuccess = TRUE; // indicate success

    } // try
    
    __finally 
    {

      if(umi2 != NULL)
      {
         NetApiBufferFree(umi2);
      }

      if(!bSuccess) 
      {
        //
        // if the function failed, free memory and indicate result code
        //

         if(*pDomainSid != NULL) 
         {
            FreeSid(*pDomainSid);
            *pDomainSid = NULL;
         }

         if( nas != NERR_Success ) 
         {
            SetLastError(nas);
         }
      }

   } // finally

   return bSuccess;
}

NTSTATUS 
   OpenPolicy(
      LPWSTR                 ComputerName,   // in - computer name
      DWORD                  DesiredAccess,  // in - access rights needed for policy
      PLSA_HANDLE            PolicyHandle    // out- LSA handle
    )
{
   LSA_OBJECT_ATTRIBUTES     ObjectAttributes;
   LSA_UNICODE_STRING        ComputerString;
   PLSA_UNICODE_STRING       Computer = NULL;
   LPWSTR                    NewComputerName;

   NewComputerName = (WCHAR*)LocalAlloc(LPTR,
        (MAX_COMPUTERNAME_LENGTH+3)*sizeof(WCHAR));
   if (!NewComputerName)
      return STATUS_NO_MEMORY;

   //
   // Prepend some backslashes to the computer name so that
   // this will work on NT 3.51
   //
   lstrcpy(NewComputerName,L"\\\\");
   lstrcat(NewComputerName,ComputerName);

   lstrcpy(NewComputerName,ComputerName);

   //
   // Always initialize the object attributes to all zeroes
   //
   ZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));

   if(ComputerName != NULL) 
   {
      //
      // Make a LSA_UNICODE_STRING out of the LPWSTR passed in
      //
      InitLsaString(&ComputerString, NewComputerName);

      Computer = &ComputerString;
   }

   //
   // Attempt to open the policy
   //
   return LsaOpenPolicy(Computer,&ObjectAttributes,DesiredAccess,PolicyHandle);
}

/*++
 This function sets the Primary Domain for the workstation.

 To join the workstation to a Workgroup, ppdi.Name should be the name of
 the Workgroup and ppdi.Sid should be NULL.

--*/
NTSTATUS
   SetPrimaryDomain(
      LSA_HANDLE             PolicyHandle,      // in -policy handle for computer
      PSID                   DomainSid,         // in - sid for new domain
      LPWSTR                 TrustedDomainName  // in - name of new domain
    )
{
   POLICY_PRIMARY_DOMAIN_INFO ppdi;

   InitLsaString(&ppdi.Name, TrustedDomainName);
   
   ppdi.Sid = DomainSid;

   return LsaSetInformationPolicy(PolicyHandle,PolicyPrimaryDomainInformation,&ppdi);
}


// This function removes the information from the domain the computer used to
// be a member of
void 
   QueryWorkstationTrustedDomainInfo(
      LSA_HANDLE             PolicyHandle,   // in - policy handle for computer
      PSID                   DomainSid,      // in - SID for new domain the computer is member of
      BOOL                   bNoChange       // in - flag indicating whether to write changes
   )
{
   // This function is not currently used.
   NTSTATUS                  Status;
   LSA_ENUMERATION_HANDLE    h = 0;
   LSA_TRUST_INFORMATION   * ti = NULL;
   ULONG                     count;

   Status = LsaEnumerateTrustedDomains(PolicyHandle,&h,(void**)&ti,50000,&count);

   if ( Status == STATUS_SUCCESS )
   {
      for ( UINT i = 0 ; i < count ; i++ )
      {
         if ( !bNoChange && !EqualSid(DomainSid,ti[i].Sid) )
         {
            // Remove the old trust
            Status = LsaDeleteTrustedDomain(PolicyHandle,ti[i].Sid);

            if ( Status != STATUS_SUCCESS )
            {
               
            }
         }
      }
      LsaFreeMemory(ti);
   }
   else
   {
      
   }
}


/*++
 This function manipulates the trust associated with the supplied
 DomainSid.

 If the domain trust does not exist, it is created with the
 specified password.  In this case, the supplied PolicyHandle must
 have been opened with POLICY_TRUST_ADMIN and POLICY_CREATE_SECRET
 access to the policy object.

--*/
NTSTATUS
   SetWorkstationTrustedDomainInfo(
      LSA_HANDLE             PolicyHandle,         // in - policy handle
      PSID                   DomainSid,            // in - Sid of domain to manipulate
      LPWSTR                 TrustedDomainName,    // in - trusted domain name to add/update
      LPWSTR                 Password,             // in - new trust password for trusted domain
      LPWSTR                 errOut                // out- error text if function fails
    )
{
   LSA_UNICODE_STRING        LsaPassword;
   LSA_UNICODE_STRING        KeyName;
   LSA_UNICODE_STRING        LsaDomainName;
   DWORD                     cchDomainName; // number of chars in TrustedDomainName
   NTSTATUS                  Status;

   InitLsaString(&LsaDomainName, TrustedDomainName);

   //
   // ...convert TrustedDomainName to uppercase...
   //
   cchDomainName = LsaDomainName.Length / sizeof(WCHAR);
   
   while(cchDomainName--) 
   {
      LsaDomainName.Buffer[cchDomainName] = towupper(LsaDomainName.Buffer[cchDomainName]);
   }

   //
   // ...create the trusted domain object
   //
   Status = LsaSetTrustedDomainInformation(
     PolicyHandle,
     DomainSid,
     TrustedDomainNameInformation,
     &LsaDomainName
     );

   if(Status == STATUS_OBJECT_NAME_COLLISION)
   {
      //printf("LsaSetTrustedDomainInformation: Name Collision (ok)\n");
   }
   else if (Status != STATUS_SUCCESS) 
   {
      err.SysMsgWrite(ErrE,LsaNtStatusToWinError(Status),DCT_MSG_LSA_OPERATION_FAILED_SD,L"LsaSetTrustedDomainInformation", Status);
      return RTN_ERROR;
   }

   InitLsaString(&KeyName, L"$MACHINE.ACC");
   InitLsaString(&LsaPassword, Password);

   //
   // Set the machine password
   //
   Status = LsaStorePrivateData(
     PolicyHandle,
     &KeyName,
     &LsaPassword
     );

   if(Status != STATUS_SUCCESS) 
   {
      err.SysMsgWrite(ErrE,LsaNtStatusToWinError(Status),DCT_MSG_LSA_OPERATION_FAILED_SD,L"LsaStorePrivateData", Status);
      return RTN_ERROR;
   }

   return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\mcsdbgu.cpp ===
//---------------------------------------------------------------------------
// McsDebugUtil.cpp
//
// The classes declared in MCSDebugUtil.h are defined in
// this file.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifdef __cplusplus		/* C++  */
#ifndef WIN16_VERSION	/* Not WIN16_VERSION */

#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#endif

#include "McsDbgU.h"

// -----------
// McsDebugLog
// ----------- 
void McsDebugUtil::McsDebugLog::write 
			(const char *messageIn) {
   if (m_outStream) {
      *(m_outStream) << messageIn;
      m_outStream->flush(); 
   }
}

#endif 	/* Not WIN16_VERSION */
#endif	/* C++ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\pwdfuncs.cpp ===
#ifdef USE_STDAFX
#include "stdafx.h"
#else
#include <windows.h>
//#include <stdio.h>
#endif

#include <stdio.h>
#include <NtSecApi.h>
#include <comdef.h>
#include <io.h>
#include <winioctl.h>
#include <lm.h>
#include <Dsgetdc.h>
#include "mcsdmmsg.h"
#include "pwdfuncs.h"
#include "PWGen.hpp"
#include "UString.hpp"

using namespace _com_util;

/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 9 DEC 2000                                                  *
 *                                                                   *
 *     This function is responsible for enumerating all floppy drives*
 * on this server.                                                   *
 *                                                                   *
 *********************************************************************/

//BEGIN EnumLocalDrives
_bstr_t EnumLocalDrives()
{
/* local constants */
    const int ENTRY_SIZE = 4; // Drive letter, colon, backslash, NULL

/* local variables */
	_bstr_t			strDrives = L"";
	WCHAR			sDriveList[MAX_PATH];
    DWORD			dwRes;

/* function body */
	try
	{
       dwRes = GetLogicalDriveStrings(MAX_PATH, sDriveList);
	   if (dwRes != 0)
	   {
          LPWSTR pTmpBuf = sDriveList;

			 //check each one to see if it is a floppy drive
          while (*pTmpBuf != NULL)
		  {
		        //check the type of this drive
             UINT uiType = GetDriveType(pTmpBuf);
			 if ((uiType == DRIVE_REMOVABLE) || (uiType == DRIVE_FIXED) || 
				 (uiType == DRIVE_CDROM) || (uiType == DRIVE_RAMDISK))
			 {
			    strDrives += pTmpBuf;
			    strDrives += L",";
			 }
             pTmpBuf += ENTRY_SIZE;
		  }
		     //remove the trailing ','
		  WCHAR* pEnd = (WCHAR*)strDrives;
		  pEnd[strDrives.length() - 1] = L'\0';
	   }
	   else
	   {
		  _com_issue_error(HRESULT_FROM_WIN32(GetLastError()));
	   }
	}
	catch (...)
	{
	   throw;
	}

	return strDrives;
}
//END EnumLocalDrives


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 9 DEC 2000                                                  *
 *                                                                   *
 *     This function is responsible for saving binary data to a given*
 * file path on a floppy drive.                                      *
 *                                                                   *
 *********************************************************************/

//BEGIN StoreDataToFloppy
void StoreDataToFloppy(LPCWSTR sPath, _variant_t & varData)
{
/* local variables */
    FILE		  * floppyfile = NULL;
    LPBYTE			pByte = NULL;
	HRESULT			hr;

/* function body */
	try
	{
	      //check incoming parameters
	   if ((!sPath) || (varData.vt != (VT_ARRAY | VT_UI1)) || 
		   (!varData.parray))
	   {
	      _com_issue_error(HRESULT_FROM_WIN32(E_INVALIDARG));
	   }

	      //open the file
	   floppyfile = _wfopen(sPath, L"wb");
       if (!floppyfile)
	      _com_issue_error(HRESULT_FROM_WIN32(CO_E_FAILEDTOCREATEFILE));

	      //get the array size
	   long uLBound, uUBound;
       size_t uSLength;
	   hr = SafeArrayGetLBound(varData.parray, 1, &uLBound);
       if (FAILED(hr))
          _com_issue_error(hr);
       hr = SafeArrayGetUBound(varData.parray, 1, &uUBound);
       if (FAILED(hr))
          _com_issue_error(hr);
	   uSLength = size_t(uUBound - uLBound + 1);
	  
	      //write the data to the file
       hr = SafeArrayAccessData(varData.parray,(void**)&pByte);
       if (FAILED(hr))
          _com_issue_error(hr);
	   if (fwrite((void *)pByte, 1, uSLength, floppyfile) != uSLength)
          _com_issue_error(HRESULT_FROM_WIN32(ERROR_WRITE_FAULT));
       hr = SafeArrayUnaccessData(varData.parray);
       if (FAILED(hr))
          _com_issue_error(hr);

	      //close the file
	   if (floppyfile)
	      fclose(floppyfile);
	}
	catch (...)
	{
	   if (floppyfile)
	      fclose(floppyfile);
	   throw;
	}
}
//END StoreDataToFloppy



/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 9 DEC 2000                                                  *
 *                                                                   *
 *     This function is responsible for retrieving binary data from a*
 * given file path on a floppy drive.  The _variant_t variable       *
 * returned is of the type VT_UI1 | VT_ARRAY upoin success or        *
 * VT_EMPTY upon a failure.                                          *
 *                                                                   *
 *********************************************************************/

//BEGIN GetDataFromFloppy
_variant_t GetDataFromFloppy(LPCWSTR sPath)
{
/* local variables */
    FILE		  * floppyfile = NULL;
    LPBYTE			pByte = NULL;
	HRESULT			hr;
	_variant_t		varData;
    SAFEARRAY     * pSa = NULL;
    SAFEARRAYBOUND  bd;

/* function body */
	try
	{
	      //check incoming parameters
	   if (!sPath)
	      _com_issue_error(HRESULT_FROM_WIN32(E_INVALIDARG));

	      //path must have the '\' escaped
//	   _bstr_t sFile = EscapeThePath(sPath);

	      //open the file
	   floppyfile = _wfopen(sPath, L"rb");
       if (!floppyfile)
	      _com_issue_error(HRESULT_FROM_WIN32(ERROR_TOO_MANY_OPEN_FILES));

          //get the number of bytes in the file
	   long fileLen = _filelength(_fileno(floppyfile));
	   if (fileLen == -1)
          _com_issue_error(HRESULT_FROM_WIN32(ERROR_READ_FAULT));
       bd.cElements = fileLen;
       bd.lLbound = 0;

	      //read the data from the file one byte at a time
       pSa = SafeArrayCreate(VT_UI1, 1, &bd);
	   if (!pSa)
	      _com_issue_error(E_FAIL);
       hr = SafeArrayAccessData(pSa,(void**)&pByte);
       if (FAILED(hr))
          _com_issue_error(hr);
       
	   long nTotalRead = 0;
	   while(!feof(floppyfile))
	   {
	      if (fread((void *)(pByte+nTotalRead), 1, 1, floppyfile) == 1)
		     nTotalRead++;
	   }

       hr = SafeArrayUnaccessData(pSa);
       if (FAILED(hr))
          _com_issue_error(hr);

	      //close the file
	   if (floppyfile)
	   {
	      fclose(floppyfile);
          floppyfile = NULL;
	   }

	   if (nTotalRead != fileLen)
          _com_issue_error(HRESULT_FROM_WIN32(ERROR_READ_FAULT));

	   varData.vt = VT_UI1 | VT_ARRAY;
       if (FAILED(SafeArrayCopy(pSa, &varData.parray)))
          _com_issue_error(hr);
       if (FAILED(SafeArrayDestroy(pSa)))
          _com_issue_error(hr);
	}
	catch (...)
	{
	   if (floppyfile)
	      fclose(floppyfile);
	   throw;
	}

	return varData;
}
//END GetDataFromFloppy


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 15 DEC 2000                                                 *
 *                                                                   *
 *     This function is convert a _variant_t parameter of the type   *
 * VT_ARRAY | VT_UI1 and returns it in a char array.  The caller must*
 * free the array with the delete [] call.  This function return NULL*
 * if the data was not placed in the array.                          *
 *                                                                   *
 *********************************************************************/

//BEGIN GetBinaryArrayFromVariant
char* GetBinaryArrayFromVariant(_variant_t varData)
{
/* local variables */
    LPBYTE			pByte = NULL;
	HRESULT			hr;
	char          * cArray;
	int				i;

/* function body */
	   //check incoming parameters
	if ((varData.vt != (VT_ARRAY | VT_UI1)) || (!varData.parray))
	   return NULL;

	   //get the array size
	long uLBound, uUBound, uSLength;
	hr = SafeArrayGetLBound(varData.parray, 1, &uLBound);
    if (FAILED(hr))
       return NULL;
    hr = SafeArrayGetUBound(varData.parray, 1, &uUBound);
    if (FAILED(hr))
       return NULL;
	uSLength = uUBound - uLBound + 1;

	   //create an array to hold all this data
    cArray = new char[uSLength+1];
	if (!cArray)
	   return NULL;
	  
	   //write the data to the file
    hr = SafeArrayAccessData(varData.parray,(void**)&pByte);
    if (FAILED(hr))
	{
       delete [] cArray;
       return NULL;
	}
	for (i=0; i<uSLength; i++)
	{
	   cArray[i] = pByte[i];
	}
	cArray[i] = L'\0';
    hr = SafeArrayUnaccessData(varData.parray);
    if (FAILED(hr))
	{
       delete [] cArray;
       return NULL;
	}

	return cArray;
}
//END GetBinaryArrayFromVariant


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 15 DEC 2000                                                 *
 *                                                                   *
 *     This function is convert a char array of binary data to a     *
 * _variant_t of the type VT_ARRAY | VT_UI1 and returns it.          *
 *                                                                   *
 *********************************************************************/

//BEGIN SetVariantWithBinaryArray
_variant_t SetVariantWithBinaryArray(char * aData, DWORD dwArray)
{
/* local variables */
    LPBYTE			pByte = NULL;
	HRESULT			hr;
	_variant_t		varData;
    SAFEARRAY     * pSa = NULL;
    SAFEARRAYBOUND  bd;
	DWORD			i;

/* function body */
	   //check incoming parameters
	if (!aData)
	   return varData;

    bd.cElements = dwArray;
    bd.lLbound = 0;

	   //read the data from the file one byte at a time
    pSa = SafeArrayCreate(VT_UI1, 1, &bd);
	if (!pSa)
	   return varData;
    hr = SafeArrayAccessData(pSa,(void**)&pByte);
    if (FAILED(hr))
	   return varData;
       
    for (i=0; i<dwArray; i++)
	{
	   pByte[i] = aData[i];
	}
	  
    hr = SafeArrayUnaccessData(pSa);
    if (FAILED(hr))
	   return varData;

	varData.vt = VT_UI1 | VT_ARRAY;
    if (FAILED(SafeArrayCopy(pSa, &varData.parray)))
	{
       varData.Clear();
	   return varData;
	}
    SafeArrayDestroy(pSa);

	return varData;
}
//END SetVariantWithBinaryArray


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 15 DEC 2000                                                 *
 *                                                                   *
 *     This function is returns the size, in bytes, of the given     *
 * variant array.                                                    *
 *                                                                   *
 *********************************************************************/

//BEGIN GetVariantArraySize
DWORD GetVariantArraySize(_variant_t & varData)
{
/* local variables */
	HRESULT			hr;
	DWORD           uSLength = 0;
	long			uLBound, uUBound;

/* function body */
	   //check incoming parameters
	if ((varData.vt != (VT_ARRAY | VT_UI1)) || (!varData.parray))
	   return uSLength;

	   //get the array size
	hr = SafeArrayGetLBound(varData.parray, 1, &uLBound);
    if (FAILED(hr))
       return uSLength;
    hr = SafeArrayGetUBound(varData.parray, 1, &uUBound);
    if (FAILED(hr))
       return uSLength;
	uSLength = DWORD(uUBound - uLBound + 1);

	return uSLength;
}
//END GetVariantArraySize


/*********************************************************************
 *                                                                   *
 * Written by: Paul Thompson                                         *
 * Date: 15 DEC 2000                                                 *
 *                                                                   *
 *     This function is returns the size, in bytes, of the given     *
 * variant array.                                                    *
 *                                                                   *
 *********************************************************************/

//BEGIN PrintVariant
void PrintVariant(const _variant_t & varData)
{
/* local variables */
	HRESULT			hr;
    LPBYTE			pByte = NULL;
	long			i;
	WCHAR			sData[MAX_PATH] = L"";

/* function body */
	   //check incoming parameters
	if ((varData.vt != (VT_ARRAY | VT_UI1)) || (!varData.parray))
	   return;

	   //get the array size
	long uLBound, uUBound, uSLength;
	hr = SafeArrayGetLBound(varData.parray, 1, &uLBound);
    if (FAILED(hr))
       return;
    hr = SafeArrayGetUBound(varData.parray, 1, &uUBound);
    if (FAILED(hr))
       return;
	uSLength = uUBound - uLBound + 1;

	   //write the data to the file
    hr = SafeArrayAccessData(varData.parray,(void**)&pByte);
    if (FAILED(hr))
       return;
	FILE * myfile;
	myfile = _wfopen(L"c:\\CryptCheck.txt", L"a+");
	for (i=0; i<uSLength; i++)
	{
	   fwprintf(myfile, L"%x ", pByte[i]);
	}
    hr = SafeArrayUnaccessData(varData.parray);
    if (FAILED(hr))
       return;

	fwprintf(myfile, L"\n");
	fclose(myfile);

	return;
}
//END PrintVariant
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\sd.cpp ===
/*---------------------------------------------------------------------------
  File: SD.cpp
  Comments: class for manipulating security descriptors
  This class provides a thin wrapper around the security descriptor APIs, and 
  also helps us with some of our processing heuristics.

  The NT APIs to read and write security descriptors for files, etc. generally
  return a self-relative SD when reading, but expect an absolute SD when writing

  Thus, we keep the original data of the SD as read, in self-relative form in m_relSD,
  and store any changes in absolute form in m_absSD.  This allows us to easily track
  which parts of the SD have been modified, and to compare the before and after versions
  of the SD.  

  As an optimization in our ACL translation, we can compare each SD to the initial 
  state of the last SD we processed.  If it is the same, we can simply write the 
  result we have already calculated, instead of calculating it again.

  (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
  Proprietary and confidential to Mission Critical Software, Inc.

  REVISION LOG ENTRY
  Revision By: Christy Boles
  Revised on 01-Oct-98 15:51:41

 ---------------------------------------------------------------------------
*/
#include <windows.h>
#include "McsDebug.h"
#include "McsDbgU.h"
#include "SD.hpp"

   TSD::TSD(
      SECURITY_DESCRIPTOR   * pSD,           // in - pointer to self-relative security descriptor
      SecuredObjectType       objectType,    // in - type of object this security descriptor secures
      BOOL                    bResponsibleForDelete // in - if TRUE, this class will delete the memory for pSD
   )
{
   m_absSD         = MakeAbsSD(pSD);
   m_bOwnerChanged = FALSE;
   m_bGroupChanged = FALSE;
   m_bDACLChanged  = FALSE;
   m_bSACLChanged  = FALSE;
   m_bNeedToFreeSD = TRUE;
   m_bNeedToFreeOwner = TRUE;
   m_bNeedToFreeGroup = TRUE;
   m_bNeedToFreeDacl  = TRUE;
   m_bNeedToFreeSacl  = TRUE;
   m_ObjectType    = objectType;
   
   if ( bResponsibleForDelete )
   {
      free(pSD);
   }
}   

   TSD::TSD(
      TSD                  * pSD             // in - another security descriptor
   )
{
   MCSVERIFY(pSD);

   if ( pSD )
   {
      m_absSD         = pSD->MakeAbsSD();
      m_bOwnerChanged = FALSE;
      m_bGroupChanged = FALSE;
      m_bDACLChanged  = FALSE;
      m_bSACLChanged  = FALSE;
      m_bNeedToFreeSD = TRUE;     
      m_bNeedToFreeOwner = TRUE;
      m_bNeedToFreeGroup = TRUE;
      m_bNeedToFreeDacl  = TRUE;
      m_bNeedToFreeSacl  = TRUE;
      m_ObjectType    = pSD->GetType();
   }
}

   TSD::~TSD()
{
   MCSVERIFY(m_absSD);

   if ( m_bNeedToFreeSD )
   {
      if (m_absSD)
         FreeAbsSD(m_absSD,FALSE);
      m_absSD = NULL;
   }
}

void 
   TSD::FreeAbsSD(
      SECURITY_DESCRIPTOR  * pSD,          // in - pointer to security descriptor to free
      BOOL                   bAll          // in - flag whether to free all parts of the SD, or only those 
                                           //      allocated by this class
   )
{
   PSID                      sid = NULL;
   PACL                      acl = NULL;
   BOOL                      defaulted;
   BOOL                      present;

   GetSecurityDescriptorOwner(pSD,&sid,&defaulted);

   if ( sid && ( m_bNeedToFreeOwner || bAll ) )
   {
      free(sid);
      sid = NULL;
   }

   GetSecurityDescriptorGroup(pSD,&sid,&defaulted);
   if ( sid && ( m_bNeedToFreeGroup || bAll ) )
   {
      free(sid);
      sid = NULL;
   }

   GetSecurityDescriptorDacl(pSD,&present,&acl,&defaulted);
   if ( acl && (m_bNeedToFreeDacl || bAll ) )
   {
      free(acl);
      acl = NULL;
   }

   GetSecurityDescriptorSacl(pSD,&present,&acl,&defaulted);
   if ( acl && ( m_bNeedToFreeSacl || bAll ) )
   {
      free(acl);
      acl = NULL;
   }

   free(pSD);
}


SECURITY_DESCRIPTOR *                        // ret- copy of the SD, in Absolute format
   TSD::MakeAbsSD(
      SECURITY_DESCRIPTOR  * pSD             // in - security descriptor to copy
   ) const
{
   DWORD                     sd_size    = (sizeof SECURITY_DESCRIPTOR); 
   DWORD                     dacl_size  = 0;
   DWORD                     sacl_size  = 0;
   DWORD                     owner_size = 0;
   DWORD                     group_size = 0;
   
   // Allocate space for the SD and its parts
   SECURITY_DESCRIPTOR     * absSD = (SECURITY_DESCRIPTOR *) malloc(sd_size);
   if (!absSD || !pSD)
   {
	  if (absSD)
	  {
	     free(absSD);
		 absSD = NULL;
	  }
      return NULL;
   }

   PACL                      absDacl = NULL;
   PACL                      absSacl = NULL;
   PSID                      absOwner = NULL;
   PSID                      absGroup = NULL;
   
   if ( ! MakeAbsoluteSD(pSD,absSD,&sd_size,absDacl,&dacl_size,absSacl,&sacl_size
                         ,absOwner,&owner_size,absGroup,&group_size) )
   {
//      DWORD rc = GetLastError();
      // didn't work:  increase sizes and try again
      
      if ( sd_size > (sizeof SECURITY_DESCRIPTOR) )
      {
         free(absSD);
         absSD = (SECURITY_DESCRIPTOR *) malloc(sd_size);
         if (!absSD)
            return NULL;
      }
      if ( dacl_size )
      {
         absDacl = (PACL)malloc(dacl_size);
         if (!absDacl)
		 {
			free(absSD);
			absSD = NULL;
            return NULL;
		 }
      }
      if ( sacl_size )
      {
         absSacl = (PACL)malloc(sacl_size);
		 if (!absSacl)
		 {
            free(absSD);
            free(absDacl);
            absSD    = NULL;
            absDacl  = NULL;
			return NULL;
		 }
      }
      if ( owner_size )
      {
         absOwner = (PSID)malloc(owner_size);
		 if (!absOwner)
		 {
            free(absSD);
            free(absDacl);
            free(absSacl);
            absSD    = NULL;
            absDacl  = NULL;
            absSacl  = NULL;
			return NULL;
		 }
      }
      if ( group_size )
      {
         absGroup = (PSID)malloc(group_size);
		 if (!absGroup)
		 {
            free(absSD);
            free(absDacl);
            free(absSacl);
            free(absOwner);
            absSD    = NULL;
            absDacl  = NULL;
            absSacl  = NULL;
            absOwner = NULL;
			return NULL;
		 }
      }              
      
      // try again with bigger buffers
      if ( ! MakeAbsoluteSD(pSD,absSD,&sd_size,absDacl,&dacl_size,absSacl,&sacl_size
                           ,absOwner,&owner_size,absGroup,&group_size) )
      {
         free(absSD);
         free(absDacl);
         free(absSacl);
         free(absOwner);
         free(absGroup);
         absSD    = NULL;
         absDacl  = NULL;
         absSacl  = NULL;
         absOwner = NULL;
         absGroup = NULL;    
      }
   }
   return absSD;
}

SECURITY_DESCRIPTOR *                        // ret- copy of the SD, in Absolute format
   TSD::MakeAbsSD() const
{
   SECURITY_DESCRIPTOR     * absSD = NULL;
   SECURITY_DESCRIPTOR     * relSD = MakeRelSD();
   if (relSD)
   {
      absSD = MakeAbsSD(relSD);
      free(relSD);
   }

   return absSD;
}

SECURITY_DESCRIPTOR *                       // ret- copy of the SD, in self-relative form
   TSD::MakeRelSD() const
{
   DWORD                     nBytes;
   SECURITY_DESCRIPTOR     * relSD = NULL;

   nBytes = GetSecurityDescriptorLength(m_absSD);
   relSD = (SECURITY_DESCRIPTOR *)malloc(nBytes);
   if (!relSD)
      return NULL;

   if (! MakeSelfRelativeSD(m_absSD,relSD,&nBytes) )
   {
      free(relSD);
      relSD = NULL;
   }
   return relSD;
}

PSID const                                 // ret- sid for security descriptor owner field
   TSD::GetOwner() const
{
   PSID                      ownersid = NULL;
   BOOL                      ownerDefaulted;

   GetSecurityDescriptorOwner(m_absSD,&ownersid,&ownerDefaulted);
   
   return ownersid;
}
void       
   TSD::SetOwner(
      PSID                   pNewOwner     // in - new value for owner field
   )
{
   MCSVERIFY(IsValidSecurityDescriptor(m_absSD));
   
   if ( IsValidSid(pNewOwner) )
   {
      if ( m_bNeedToFreeOwner )
      {
         PSID                old = GetOwner();

         free(old);
      }
      
      SetSecurityDescriptorOwner(m_absSD,pNewOwner,FALSE);
      m_bOwnerChanged = TRUE;
      m_bNeedToFreeOwner = TRUE;
   }
   else
   {
      MCSVERIFY(FALSE);
   }
}

PSID const                                   // ret- sid for security descriptor owner field
   TSD::GetGroup() const
{
   PSID                      grpsid = NULL;
   BOOL                      grpDefaulted;

   MCSVERIFY(IsValidSecurityDescriptor(m_absSD));
   GetSecurityDescriptorGroup(m_absSD,&grpsid,&grpDefaulted);

   return grpsid;
}

void       
   TSD::SetGroup(
      PSID                   pNewGroup       // in - new value for primary group field.
   )
{
   MCSVERIFY(IsValidSecurityDescriptor(m_absSD));
   
   if ( IsValidSid(pNewGroup) )
   {
      if ( m_bNeedToFreeGroup )
      {
         PSID                old = GetGroup();

         free(old);
      }
      SetSecurityDescriptorGroup(m_absSD,pNewGroup,FALSE);
      m_bGroupChanged = TRUE;
      m_bNeedToFreeGroup = TRUE;
   }
   else
   {
      MCSVERIFY(FALSE);
   }
}

PACL const                                  // ret- pointer to DACL
   TSD::GetDacl() const
{
   PACL                      acl = NULL;
   BOOL                      defaulted;
   BOOL                      present;

   GetSecurityDescriptorDacl(m_absSD,&present,&acl,&defaulted);

   return acl;
}
void       
   TSD::SetDacl(
      PACL                   pNewAcl,     // in - new DACL
      BOOL                   present      // in - flag, TRUE means DACL is present.
   )
{
   BOOL                      defaulted = FALSE;
   
   if ( IsValidAcl(pNewAcl) )
   {
      if ( m_bNeedToFreeDacl )
      {
         PACL old = GetDacl();
         
         if ( old != pNewAcl )
         {
            free(old);
         }
      }
      if (! SetSecurityDescriptorDacl(m_absSD,present,pNewAcl,defaulted) )
      {
//         DWORD rc = GetLastError();
      }
      m_bDACLChanged = TRUE;
      m_bNeedToFreeDacl = TRUE;
   }
   else
   {
      MCSVERIFY(FALSE);
   }
}
                                           
PACL const                                 // ret- pointer to SACL
   TSD::GetSacl() const
{
   PACL                      acl = NULL;
   BOOL                      defaulted;
   BOOL                      present;

   GetSecurityDescriptorSacl(m_absSD,&present,&acl,&defaulted);

   return acl;
}

void       
   TSD::SetSacl(
      PACL                   pNewAcl,      // in - new SACL
      BOOL                   present       // in - flag, TRUE means SACL is present
   )
{
   BOOL                      defaulted = FALSE;

   if ( IsValidAcl(pNewAcl) )
   {
      if ( m_bNeedToFreeSacl )
      {
         PACL                old = GetSacl();
         
         if ( old != pNewAcl )
         {
            free(old);
         }
      }
      SetSecurityDescriptorSacl(m_absSD,present,pNewAcl,defaulted);
      m_bSACLChanged = TRUE;
      m_bNeedToFreeSacl = TRUE;
   }
   else
   {
      MCSVERIFY(FALSE);
   }
}


             
BOOL                                       
   TSD::IsOwnerDefaulted() const
{
   PSID                      ownersid = NULL;
   BOOL                      ownerDefaulted = FALSE;

   GetSecurityDescriptorOwner(m_absSD,&ownersid,&ownerDefaulted);
   
   return ownerDefaulted;
}

BOOL 
   TSD::IsGroupDefaulted() const
{
   PSID                      groupsid = NULL;
   BOOL                      groupDefaulted = FALSE;

   GetSecurityDescriptorGroup(m_absSD,&groupsid,&groupDefaulted);
   
   return groupDefaulted;

}
BOOL 
   TSD::IsDaclDefaulted() const
{
   PACL                      acl = NULL;
   BOOL                      defaulted = FALSE;
   BOOL                      present;

   GetSecurityDescriptorDacl(m_absSD,&present,&acl,&defaulted);

   return defaulted;
}

BOOL 
   TSD::IsDaclPresent() const
{
   PACL                      acl = NULL;
   BOOL                      defaulted;
   BOOL                      present = FALSE;

   GetSecurityDescriptorDacl(m_absSD,&present,&acl,&defaulted);

   return present;
}

BOOL 
   TSD::IsSaclDefaulted() const
{
   PACL                      acl = NULL;
   BOOL                      defaulted = FALSE;
   BOOL                      present;

   GetSecurityDescriptorSacl(m_absSD,&present,&acl,&defaulted);

   return defaulted;
}

BOOL 
   TSD::IsSaclPresent() const
{
   PACL                      acl = NULL;
   BOOL                      defaulted;
   BOOL                      present = FALSE;

   GetSecurityDescriptorSacl(m_absSD,&present,&acl,&defaulted);

   return present;
}

BOOL  
   TSD::operator == (TSD & otherSD)
{
   return EqualSD(&otherSD);
}

// Compares the relative SDs (relSD) for 2 TSecurityDescriptor's.  
// true -> SDs are equal, false -> SDs are not equal
BOOL                                                     // ret -true iff *(this->relSD) == *(otherSD->relSD)
   TSD::EqualSD(
      TSD * otherSD      // in -TSecurityDescriptor to compare this SD to 
   )
{
   PSID                      ps1;
   PSID                      ps2;
   PACL                      acl1;
   PACL                      acl2;
   BOOL                      diffound = FALSE;
   
  
   // both must be valid SD's
       
   ps1 = NULL;
   ps2 = NULL;
                           // if GetSecurityDescriptor* fails, EqualSid, or ACLCompare will fail
                                                                        
   // Compare owners
   ps1 = GetOwner();
   ps2 = otherSD->GetOwner(); 
   if ((ps1) && (ps2) && (! EqualSid(ps1,ps2)))                                            
   {
      diffound = TRUE;
   }
   ps1 = NULL;
   ps2 = NULL;                                                          
   // Compare Groups
   if ( ! diffound )
   {
      ps1 = GetGroup();
      ps2 = otherSD->GetGroup();
      if ((ps1) && (ps2) && (! EqualSid(ps1,ps2)))                                            
      {
         diffound = TRUE;
      }
      acl1 = NULL;
      acl2 = NULL;
   }
   // Compare DACLs
   if ( ! diffound )
   {
      acl1 = GetDacl();
      acl2 = otherSD->GetDacl();

      if ((acl1) && (acl2) && 
		  (!ACLCompare(acl1,IsDaclPresent(),acl2,otherSD->IsDaclPresent())))
      {
         diffound = TRUE;
      }
   }
   // Compare SACLs
   if ( ! diffound )
   {
      acl1 = GetSacl();
      acl2 = otherSD->GetSacl();
      
      if ((acl1) && (acl2)) 
         diffound = (! ACLCompare(acl1,IsSaclPresent(),acl2,otherSD->IsSaclPresent()) );
   }
   return ! diffound;
}

BOOL                                              // ret- TRUE if both ACLs are the same
  TSD::ACLCompare(
   PACL                      acl1,                // in -ptr to first acl to compare
   BOOL                      present1,            // in -present flag for acl1
   PACL                      acl2,                // in -ptr to second acl to compare
   BOOL                      present2             // in -present flag for acl2
 )
{
   DWORD                     size1;
   DWORD                     size2;
   bool                      same = true;
  
   if ( present1 && present2 )
   {
      if (  ( !acl1 && acl2 )
         || ( acl1 && ! acl2 ) )
      {
         same = false;
      } 
      if ( acl1 && acl2)
      {
         size1 = acl1->AclSize;
         size2 = acl2->AclSize;
         if ( size1 != size2 )
         {
            same = false;
         }
         else 
         {  
            if ( memcmp(acl1,acl2,size1) ) 
            {
               same = false;
            }
         }
      }
   }
   else 
   {
      if ( present1 || present2 )
      {
         same = false;
      }
   }
   return same;
}

int                                        // ret- number of aces in the ACL
   TSD::ACLGetNumAces(
      PACL                   acl           // in - DACL or SACL
   )
{
   int                       nAces = 0;
   ACL_SIZE_INFORMATION      info;
   
   if ( acl )
   {
      if ( GetAclInformation(acl,&info,(sizeof info),AclSizeInformation) )
      {
         nAces = info.AceCount;
      }
      else
      {
//         DWORD rc=GetLastError();
      }
   }
   return nAces;
}

DWORD                                     // ret- number of free bytes in the ACL
   TSD::ACLGetFreeBytes(
      PACL                   acl          // in - DACL or SACL
   )
{
   int                       nFree = 0;

   ACL_SIZE_INFORMATION      info;

   if ( acl )
   {
      if ( GetAclInformation(acl,&info,(sizeof info),AclSizeInformation) )
      {
         nFree = info.AclBytesFree;
      }
   }
   return nFree;
}


DWORD                                     // ret- number of used bytes in the ACL
   TSD::ACLGetBytesInUse(
      PACL                   acl          // in - DACL or SACL
   )
{
   int                       nBytes = 0;

   ACL_SIZE_INFORMATION      info;

   if ( acl )
   {
      if ( GetAclInformation(acl,&info,(sizeof info),AclSizeInformation) )
      {
         nBytes = info.AclBytesInUse;
      }
   }
   return nBytes;
}



void *                                     // ret- pointer to ace  
   TSD::ACLGetAce(
      PACL                   acl,          // in - DACL or SACL
      int                    ndx           // in - index of ace to retrieve
   )
{
   void                    * ace = NULL;

   if ( ndx < ACLGetNumAces(acl) )
   {
      if ( ! GetAce(acl,ndx,(void**)&ace) )
      {
         ace = NULL;
      }
   }
   else
   {
      MCSASSERT(FALSE); // you specified a non-existant index
   }
   return ace;
}  

void 
   TSD::ACLDeleteAce(
      PACL                      acl,      // in - DACL or SACL
      int                       ndx       // in - index of ace to delete
   )
{
   int                       nAces = ACLGetNumAces(acl);

   if ( ndx < nAces )
   {
      DeleteAce(acl,ndx);
   }
   else
   {
      MCSASSERT(FALSE); // you specified an invalid index
   }
}

// Access allowed aces are added at the beginning of the list, access denied aces are added at the end of the list
void 
   TSD::ACLAddAce(
      PACL                 * ppAcl,        // i/o- DACL or SACL (this function may reallocate if the acl doesn't have room
      TACE                 * pAce,         // in - ACE to add
      int                    pos           // in - position
   )
{
   DWORD                     ndx = (DWORD)pos;
   DWORD                     rc;
   PACL                      acl = (*ppAcl);
   PACL                      newAcl;
   DWORD                     numaces = ACLGetNumAces(acl);
   DWORD                     freebytes = ACLGetFreeBytes(acl);
   
   if (!pAce->GetBuffer())
	  return;

   // allocate a new ACL if it doesn't already exist
   if ( ! acl )
   {
      acl = (PACL) malloc(SD_DEFAULT_ACL_SIZE);
	  if (!acl)
	     return;
      InitializeAcl(acl,SD_DEFAULT_ACL_SIZE,ACL_REVISION);
      numaces = ACLGetNumAces(acl);
      freebytes = ACLGetFreeBytes(acl);
   }

   if ( pos == -1 )
   {
      if ( pAce->IsAccessAllowedAce() )
      {
         ndx = 0;
      }
      else
      {
         ndx = MAXDWORD; // insert at end of the list
      }
   }
   
   WORD                      currAceSize = pAce->GetSize();
   
   if ( freebytes < currAceSize ) // we must allocate more space for the ace
   {
      //make a bigger acl
      newAcl = (ACL*)malloc(ACLGetBytesInUse(acl) + freebytes + currAceSize);
	  if (!newAcl)
	  {
		 free(acl);
		 acl = NULL;
	     return;
	  }
      memcpy(newAcl,acl,ACLGetBytesInUse(acl) + freebytes);
      newAcl->AclSize +=currAceSize;
	  free(acl);
      
      acl = newAcl;
   }
   
   if  (! AddAce(acl,ACL_REVISION,ndx,pAce->GetBuffer(),currAceSize) )
   {
      rc = GetLastError();
   }
   (*ppAcl) = acl;
} 

// creates a new ace with the specified properties
   TACE::TACE(
      BYTE                   type,         // in - type of ace (ACCESS_ALLOWED_ACE_TYPE, etc.)
      BYTE                   flags,        // in - ace flags (controls inheritance, etc.  use 0 for files)
      DWORD                  mask,         // in - access control mask (see constants in sd.hpp)
      PSID                   sid           // in - pointer to sid for this ace
   )
{
   MCSVERIFY(sid);
   // allocate memory for the new ace
   DWORD                      size = (sizeof ACCESS_ALLOWED_ACE) + GetLengthSid(sid) - (sizeof DWORD);

   m_pAce = (ACCESS_ALLOWED_ACE *)malloc(size);

   // Initialize the ACE
   if (m_pAce)
   {
      m_bNeedToFree = TRUE;
      m_pAce->Header.AceType = type;
      m_pAce->Header.AceFlags = flags;
      m_pAce->Header.AceSize = (WORD) size;
      m_pAce->Mask = mask;
      memcpy(&m_pAce->SidStart,sid,GetLengthSid(sid));
   }
}

BYTE                          // ret- ace type (ACCESS_ALLOWED_ACE_TYPE, etc.)
   TACE::GetType()
{
   MCSVERIFY(m_pAce);

   BYTE                      type = ACCESS_ALLOWED_ACE_TYPE;

   if (m_pAce)
	  type = m_pAce->Header.AceType;
   
   return type;
}

BYTE                         // ret- ace flags (OBJECT_INHERIT_ACE, etc.)
   TACE::GetFlags()
{
   MCSVERIFY(m_pAce);

   BYTE                      flags = OBJECT_INHERIT_ACE;
   
   if (m_pAce)
	  flags = m_pAce->Header.AceFlags;
   
   return flags;
}

DWORD                        // ret- access control mask
   TACE::GetMask()
{
   MCSVERIFY(m_pAce);

   DWORD                     mask = 0;
   
   if (m_pAce)
	  mask = m_pAce->Mask;
   
   return mask;

}

PSID                        // ret- sid for this ace
   TACE::GetSid()
{
   MCSVERIFY(m_pAce);

   PSID                      pSid = NULL;
   
   if (m_pAce)
	  pSid = &m_pAce->SidStart;

   return pSid;
}

WORD                       // ret- size of the ace, in bytes
   TACE::GetSize()
{
   MCSVERIFY(m_pAce);

   WORD                      size = 0;
   
   if (m_pAce)
	  size = m_pAce->Header.AceSize;

   return size;
}

   
BOOL                                   
   TACE::SetType(
      BYTE                   newType   // in -new type for ace
   )
{
   MCSVERIFY(m_pAce);

   if (!m_pAce)
	  return FALSE;
   
   MCSASSERT( newType=ACCESS_ALLOWED_ACE_TYPE || 
              newType==ACCESS_DENIED_ACE_TYPE || 
              newType==SYSTEM_AUDIT_ACE_TYPE  );

   m_pAce->Header.AceType = newType;           

   return TRUE;
}

BOOL 
   TACE::SetFlags(
      BYTE                   newFlags     // in - new flags for ace
   )
{
   MCSVERIFY(m_pAce);
  
   if (!m_pAce)
	  return FALSE;
   
   m_pAce->Header.AceFlags = newFlags;

   return TRUE;
}

BOOL 
   TACE::SetMask(
      DWORD                  newMask       // in - new access control mask
   )
{
   MCSVERIFY(m_pAce);

   if (!m_pAce)
	  return FALSE;
   
   m_pAce->Mask = newMask;

   return TRUE;
}

BOOL 
   TACE::SetSid(
      PSID                   sid           // in - new SID for this ace
   )
{
   BOOL                     result = FALSE;

   MCSVERIFY( m_pAce );
   MCSASSERT( IsValidSid(sid) );
   MCSASSERT( GetLengthSid(sid) == GetLengthSid(GetSid()) );
   
   if (!m_pAce)
	  return FALSE;
   
   if ( GetLengthSid(sid) <= GetLengthSid(GetSid()) )
   {
      memcpy(&m_pAce->SidStart,sid,GetLengthSid(sid));
      result = TRUE;
   }
   return result;
}

BOOL 
   TACE::IsAccessAllowedAce()
{
   MCSVERIFY(m_pAce);
   
   return ( GetType() == ACCESS_ALLOWED_ACE_TYPE );      
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\secobj.cpp ===
/*Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  SecureObject.cpp
System      -  Domain Consolidation Toolkit.
Author      -  Christy Boles
Created     -  97/06/27
Description -  Classes for objects that have security descriptors.
               
               TSecurableObject has a derived class for each type of object 
               we will process security descriptors for.  This class handles reading 
               and writing the security descriptor.  It contains a TSD object, which 
               will handle manipulation of the SD while it is in memory.

               The TSecurableObject class also contains functions to translate a security 
               descriptor, given an account mapping cache.  These routines are only included
               in the class if the preprocessor directive SDRESOLVE is #defined.  This allows
               the TSecurableObject class to be used for generic security descriptor manipulation,
               where the rest of the ACL translation code is not needed.

Updates     -
===============================================================================
*/

#ifdef USE_STDAFX
#   include "stdafx.h"
#else
#   include <windows.h>
#	include <process.h>
#endif

#include <stdio.h>
#include <iostream.h>
#include <assert.h>

#include "common.hpp"
#include "ErrDct.hpp"
#include "Ustring.hpp"
#include "sd.hpp"
#include "SecObj.hpp"


#ifdef SDRESOLVE
   #include "sidcache.hpp"
   #include "enumvols.hpp"
   #include "txtsid.h"
#endif

#define PRINT_BUFFER_SIZE           2000

extern TErrorDct              err;

 
  TSecurableObject::~TSecurableObject()
{
#ifdef SDRESOLVE
   TStatNode *node;
   for ( node = (TStatNode *)changelog.Head() ; node ; node = (TStatNode * )changelog.Head() )
   {
      changelog.Remove((TNode *)node);
      delete node;
   }
#endif   
   if ( handle != INVALID_HANDLE_VALUE )
   {
      CloseHandle(handle);
      handle = INVALID_HANDLE_VALUE;
   }

   if ( m_sd )                        
   {
      delete m_sd; 
   }
}

#ifdef SDRESOLVE
PACL                                // ret -pointer to Resolved ACL 
   TSecurableObject::ResolveACL(
      PACL                   oldacl,      // in -acl to resolve
      TAccountCache        * cache,       // in -cache to lookup sids
      TSDResolveStats      * stat,        // in -stats object
      bool                 * changes,     // i/o-flag whether this SD has been modified
      BOOL                   verbose,     // in -flag whether to display lots of junk
      int                    opType,      // in - ADD_SECURITY, REPLACE_SECURITY, or REMOVE_SECURITY
      objectType             objType,     // in - the type of the object
	  BOOL					 bUseMapFile  // in - flag - whether we are using a sID mapping file
   )
{  
   int                       nAces,curr;
   TRidNode                * tnode;
   PSID                      ps;
   bool                      aclchanges = false;
   PACL                      acl = oldacl;
   void                    * pAce;

   nAces = m_sd->ACLGetNumAces(acl);
   
   for ( curr = 0 ; curr < nAces;  )
   {
      pAce = m_sd->ACLGetAce(acl,curr);
      if ( pAce )
      {
         TACE                 ace(pAce);
         ps = ace.GetSid();
         
	     if (!bUseMapFile)
            tnode =(TRidNode *)cache->Lookup(ps);
		 else
            tnode =(TRidNode *)((TSDRidCache*)cache)->LookupWODomain(ps);
         
         if ( ace.GetType() == SYSTEM_AUDIT_ACE_TYPE )
         {
            if ( stat )
               stat->IncrementSACEExamined();
         }
         else
         {
            if ( stat) 
               stat->IncrementDACEExamined();
         }  

         if ( tnode == NULL )
         {
            if ( ace.GetType() == SYSTEM_AUDIT_ACE_TYPE )
            {
               if ( stat )
                  stat->IncrementSACENotSelected(this);
            }
            else
            {
               if ( stat) 
                  stat->IncrementDACENotSelected(this);
            }
      
         }

//         if ( (int)tnode == -1 )    // from Totally unknown
         if ( tnode == (TRidNode*)-1 )    // from Totally unknown
         {
            if ( ace.GetType() == SYSTEM_AUDIT_ACE_TYPE )
            {
               if ( stat )
                  stat->IncrementSACEUnknown(this);
            }
            else
            {
               if ( stat) 
                  stat->IncrementDACEUnknown(this);
            }
            tnode = NULL;
         }
   
         if ( tnode )
         {
            if ( ace.GetType() == SYSTEM_AUDIT_ACE_TYPE )
            {
               if ( stat )
                  stat->IncrementSACEChange(tnode,objType,this);
            }
            else
            {
               if ( stat) 
                  stat->IncrementDACEChange(tnode,objType,this);
            }
         }
         if ( tnode && ! tnode->IsValidOnTgt() )
         {
            if ( ace.GetType() == SYSTEM_AUDIT_ACE_TYPE )
            {
               if ( stat )
                  stat->IncrementSACENoTarget(this);
            }
            else
            {
               if ( stat) 
                  stat->IncrementDACENoTarget(this);
            }
         }
         if ( tnode && tnode->IsValidOnTgt() ) 
         {
            if ( verbose ) 
               DisplaySid(ps,cache);
            
	        if (!bUseMapFile)
               ps = cache->GetTgtSid(tnode);
	        else
               ps = ((TSDRidCache*)cache)->GetTgtSidWODomain(tnode);
            switch ( opType )
            {
            case REPLACE_SECURITY:
               aclchanges = true;
               ace.SetSid(ps);
               curr++;
               break;
            case ADD_SECURITY:
               {
                  TACE       otherAce(ace.GetType(),ace.GetFlags(),ace.GetMask(),ps);
                             
                  PACL       tempAcl = acl;

                  // check to make sure we're not adding duplicates
                     // check the next ace, to see if it matches the one we're about to add
                  BOOL       bOkToAdd = TRUE;

                  // Check the ace where we are
                  if ( EqualSid(otherAce.GetSid(),ace.GetSid()) )
                  {
                     bOkToAdd = FALSE;
                  }

                  // check the next ace, if any
                  if ( curr+1 < nAces )
                  {
                     TACE        nextAce(m_sd->ACLGetAce(acl,curr+1));
                    
                     if ( EqualSid(otherAce.GetSid(),nextAce.GetSid()) )
                     {
                        bOkToAdd = FALSE;
                     }
                  }
                  // check the previous ace, if any
                  if ( curr > 0 )
                  {
                     TACE        prevAce(m_sd->ACLGetAce(acl,curr-1));
                     
                     if ( EqualSid(prevAce.GetSid(),otherAce.GetSid()) )
                     {
                        bOkToAdd = FALSE;
                     }
                  }

                  if ( bOkToAdd )
                  {
                     m_sd->ACLAddAce(&acl,&otherAce,curr);
					 if (acl)
                       aclchanges = true;
                     curr += 2;
                     nAces++;
                  }
                  else
                  {
                     curr++;
                  }
                  
                  if ( acl != tempAcl )
                  {
                     // we had to reallocate when we added the ace
                     if ( tempAcl != oldacl )
                     {
                        // we had already reallocated once before -- free the intermediate acl
                        free(tempAcl);
                     }
                  }
               }
               break;
            case REMOVE_SECURITY:
               aclchanges = true;
               m_sd->ACLDeleteAce(acl,curr);
               nAces--;
               break;
            }
            
            free(ps);
         }  
         else 
         {
            curr++;
         }
      }
      else
      {
         break;
      }
   }       
   if ( ! aclchanges ) 
   {
      acl = NULL;
   }
   if ( aclchanges )
   {
      (*changes) = true;
   }
   return acl;
}   


bool 
   TSecurableObject::ResolveSD(
      SecurityTranslatorArgs  * args,              // in -translation settings
      TSDResolveStats         * stat,              // in -stats object to increment counters
      objectType                objType,           // in -is this file, dir or share
      TSecurableObject        * Last               // in -Last SD for cache comparison
   )
{
   bool                      changes;
   bool                      iWillBeNewLast;
     
   if ( ! m_sd->m_absSD )  // Couldn't get SD for this object (or it doesn't have one).
   {
      return false;
   }
   MCSASSERT( m_sd && m_sd->IsValid() );

   if ( stat )
      stat->IncrementExamined(objType);

   if ( args->LogVerbose() )
      err.MsgWrite(0,DCT_MSG_EXAMINED_S,pathname);
   
   if ( ! Last || m_sd != Last->m_sd )
   {
      changes = ResolveSDInternal(args->Cache(),stat,args->LogVerbose(),args->TranslationMode(),objType,args->UsingMapFile());
      if ( changes )
      {
         if ( stat )
         {
               stat->IncrementChanged(objType);
         }
         if ( args->LogFileDetails() )
            err.MsgWrite(0,DCT_MSG_CHANGED_S,pathname);
         if ( args->LogMassive() )
         {
            err.DbgMsgWrite(0,L"BEFORE:************Security Descriptor for %ls*************",pathname);
            PermsPrint(pathname,objType);
         }
         if ( ! args->NoChange() ) 
         {
            if ( args->LogMassive() )
            {
               err.DbgMsgWrite(0,L"IN MEMORY:*********************************************",pathname);
               PrintSD(m_sd->m_absSD,pathname);
            }
            WriteSD();
         }
         if ( args->LogMassive() )
         {
            err.DbgMsgWrite(0,L"AFTER:************Security Descriptor for %ls*************",pathname);
            PermsPrint(pathname,objType);
         }
      }
      else
      {
         if ( args->LogMassive() )
         {
            err.DbgMsgWrite(0,L"UNCHANGED:************Security Descriptor for %ls*************",pathname);
            PermsPrint(pathname,objType);
         }
      }
      iWillBeNewLast = true;
      
   }
   else
   {        // cache hit
      if ( stat )
         stat->IncrementLastFileChanges(Last,objType);
      iWillBeNewLast = false;
      if ( Last->Changed() )
      {
         Last->CopyAccessData(this);
         if ( args->LogFileDetails() )
            err.MsgWrite(0,DCT_MSG_CHANGED_S,pathname);
         if ( args->LogMassive() )
         {
            err.DbgMsgWrite(0,L"BEFORE:************Security Descriptor for %ls*************",pathname);
            PermsPrint(pathname,objType);
         }
         if ( ! args->NoChange() )
            Last->WriteSD();

         if ( args->LogFileDetails() )
            err.MsgWrite(0,DCT_MSG_CHANGED_S,pathname);

         if ( args->LogMassive() )
         {
            err.DbgMsgWrite(0,L"AFTER:************Security Descriptor for %ls*************",pathname);
            PermsPrint(pathname,objType);
         }
      }
      else
      {
         if ( args->LogMassive() )
         {
            err.DbgMsgWrite(0,L"UNCHANGED:************Security Descriptor for %ls*************",pathname);
            PermsPrint(pathname,objType);
         }
      }
      if ( stat )
         stat->IncrementCacheHit(objType);
     
   }
   return iWillBeNewLast;
}

bool                                                      // ret -true if changes made, otherwise false
   TSecurableObject::ResolveSDInternal(
      TAccountCache        * cache,                      // in -cache to lookup sids
      TSDResolveStats      * stat,                       // in -stats object
      BOOL                   verbose,                    // in -flag - whether to display stuff
      int                    opType,                     // in -operation type Add, Replace, or Remove
      objectType             objType,                    // in - type of object 
	  BOOL					 bUseMapFile				 // in - flag - whether we are using a sID mapping file
   )
{
   /* Examine each part of the SD, looking for SIDs in the cache */
   PSID                      ps;
   TRidNode                * acct;
   bool                      changes = false;
   PACL                      pacl;
   PACL                      newacl;
   PSID                      newsid;
   
   MCSVERIFY(m_sd);
   
   // Process owner part of SD
   ps = m_sd->GetOwner(); 
   if ( ps )      
   {
	  if (!bUseMapFile)
         acct = (TRidNode *)cache->Lookup(ps); // See if owner SID is in the cache
	  else
         acct = (TRidNode *)((TSDRidCache*)cache)->LookupWODomain(ps); // See if owner SID is in the cache
      if ( stat) 
         stat->IncrementOwnerExamined();
      if (acct == NULL  )
      {
         if ( stat )
            stat->IncrementOwnerNotSelected();
      }
//      else if ((int)acct == -1 )
      else if (acct == (TRidNode*)-1 )
      {
         if (stat)
            stat->IncrementOwnerUnknown();
         unkown = true;
         acct = NULL;
      }
      if ( acct && stat )
      {
         stat->IncrementOwnerChange(acct,objType,this);
      }
      if ( acct && acct->IsValidOnTgt() ) 
      {
         changes = true;
         if ( verbose ) 
         {
            err.DbgMsgWrite(0,L"Owner: ");
            DisplaySid(ps,cache);
         }
         owner_changed = true;
	     if (!bUseMapFile)
            newsid = cache->GetTgtSid(acct);
	     else
            newsid = ((TSDRidCache*)cache)->GetTgtSidWODomain(acct);
         m_sd->SetOwner(newsid);
         //free(newsid);
      }
   }
   // Process primary group part of SD
   ps = m_sd->GetGroup();
   if ( ps )
   {
	  if (!bUseMapFile)
         acct = (TRidNode *)cache->Lookup(ps);
	  else
         acct = (TRidNode *)((TSDRidCache*)cache)->LookupWODomain(ps);
      if ( stat) 
         stat->IncrementGroupExamined();
      if (acct == NULL )
      {
         if ( stat )
            stat->IncrementGroupNotSelected();
      }
//      else if ((int)acct == -1 )
      else if (acct == (TRidNode*)-1 )
      {
         if (stat)
            stat->IncrementGroupUnknown();
         acct = NULL;
         unkgrp = true;
      }
      if ( acct && stat )
      {
         stat->IncrementGroupChange(acct,objType,this);
      }
      if ( acct && acct->IsValidOnTgt() )
      {
         changes = true;
         if ( verbose ) 
         {
            err.DbgMsgWrite(0,L"Group: ");
            DisplaySid(ps,cache);
         }
         group_changed = true;
	     if (!bUseMapFile)
            newsid = cache->GetTgtSid(acct);
	     else
            newsid = ((TSDRidCache*)cache)->GetTgtSidWODomain(acct);
         m_sd->SetGroup(newsid);
         //free(newsid);
      }
   }
   
   pacl = m_sd->GetDacl();
   if ( pacl && m_sd->IsDaclPresent() )
   {
      if ( stat )
         stat->IncrementDACLExamined();
      if ( verbose ) 
         err.DbgMsgWrite(0,L"DACL");
	  if (!bUseMapFile)
         newacl = ResolveACL(pacl,cache,stat,&changes,verbose,opType,objType, FALSE);
	  else
         newacl = ResolveACL(pacl,cache,stat,&changes,verbose,opType,objType, TRUE);
      if ( newacl )
      {
         m_sd->SetDacl(newacl,m_sd->IsDaclPresent());
         dacl_changed = true;
         if ( stat ) 
            stat->IncrementDACLChanged();
      }
   }
   pacl = NULL;
   pacl = m_sd->GetSacl();

   if ( pacl && m_sd->IsSaclPresent() )
   {
      if ( stat )
         stat->IncrementSACLExamined();
      if ( verbose ) 
         err.DbgMsgWrite(0,L"SACL");
	  if (!bUseMapFile)
         newacl = ResolveACL(pacl,cache,stat,&changes,verbose,opType,objType, FALSE);
	  else
         newacl = ResolveACL(pacl,cache,stat,&changes,verbose,opType,objType, TRUE);
      if ( newacl )
      {
         m_sd->SetSacl(newacl,m_sd->IsSaclPresent());
         sacl_changed = true;
         if ( stat )
            stat->IncrementSACLChanged();
      }
   }
   return changes;
}
#else

WCHAR *                                      // ret -machine-name prefix of pathname if pathname is a UNC path, otherwise returns NULL
   GetMachineName(
      const LPWSTR           pathname        // in -pathname from which to extract machine name
   )
{
   int                       i;
   WCHAR                   * machinename = NULL; 
   if (    pathname
        && pathname[0] == L'\\'
        && pathname[1] == L'\\'
      )
   {
      for ( i = 2 ; pathname[i] && pathname[i] != L'\\' ; i++ ) 
      ;
      machinename = new WCHAR[i+2];
	  if (machinename)
	  {
         UStrCpy(machinename,pathname,i+1);
         machinename[i] = 0;
	  }
   }
   return machinename;
}


#endif

void 
   TSecurableObject::CopyAccessData(
       TSecurableObject    * sourceFSD    // in - sd from which to copy name & handle
   )
{
   
   pathname[0] = 0;
   safecopy(pathname,sourceFSD->GetPathName());
   if ( handle != INVALID_HANDLE_VALUE )
   {
      CloseHandle(handle);
   }
   handle = sourceFSD->handle;   
   sourceFSD->ResetHandle();
}

            
               


/************************************************TFileSD Implementation*************************/
 TFileSD::TFileSD(
      const LPWSTR           path                // in -pathname for this SD           
   )
{
   daceNS = 0;
   saceNS = 0;
   daceEx = 0;
   saceEx = 0;
   daceU  = 0;
   saceU  = 0;
   daceNT = 0;
   saceNT = 0;
   unkown = false;
   unkgrp = false;

   if ( path )
   {
      safecopy(pathname,path);
   }
   else
   {
      path[0] = 0;
   }
   handle = INVALID_HANDLE_VALUE;
   ReadSD(path);    
}
 

   TFileSD::~TFileSD()
{
   if ( handle != INVALID_HANDLE_VALUE )
   {
      CloseHandle(handle);
      handle = INVALID_HANDLE_VALUE;
   }
   pathname[0]=0;
}

  
// writes the Absolute SD to the file "pathname"  
bool                                         // ret -true iff successful
   TFileSD::WriteSD()
{
//   DWORD                     rc    = 0;
   bool                      error = false;
   SECURITY_DESCRIPTOR     * sd = NULL;
   MCSVERIFY( m_sd && m_sd->IsValid() );
   
   if ( handle == INVALID_HANDLE_VALUE )
   {
      err.MsgWrite(ErrS,DCT_MSG_FST_WRITESD_INVALID);
      error = true;
   }
   SECURITY_INFORMATION si;
   if ( ! error )
   {
      si = 0;
      if ( m_sd->IsOwnerChanged() )
         si |= OWNER_SECURITY_INFORMATION;
      if ( m_sd->IsGroupChanged() )
         si |= GROUP_SECURITY_INFORMATION;
      if ( m_sd->IsDACLChanged() )
         si |=  DACL_SECURITY_INFORMATION;
      if ( m_sd->IsSACLChanged() )
         si |= SACL_SECURITY_INFORMATION;

      sd = m_sd->MakeAbsSD();
	  if (!sd)
	     return false;
      if ( ! SetKernelObjectSecurity(handle, si, sd ) ) 
      {
         err.SysMsgWrite(ErrE,GetLastError(),DCT_MSG_FILE_WRITESD_FAILED_SD,pathname,GetLastError());
         error = true;
      }
      m_sd->FreeAbsSD(sd);
   }
   return ! error;
}

bool                          // ret -pointer to SD, (or NULL if failure)
   TFileSD::ReadSD(
      const LPWSTR           path      // in -file to get SD from
   )
{                                         
   DWORD                     req;
   DWORD                     rc;
//   void                    * r = NULL;
   SECURITY_DESCRIPTOR     * sd = NULL;
   bool                      error = false;
   WCHAR                   * longpath= NULL;

   if ( handle != INVALID_HANDLE_VALUE)
   {
      CloseHandle(handle);
      handle = INVALID_HANDLE_VALUE;
   }
   owner_changed = 0;
   group_changed = 0;
   dacl_changed = 0;
   sacl_changed = 0;

   
   if ( UStrLen(path) >= MAX_PATH && path[2] != L'?' )
   {
      longpath = new WCHAR[UStrLen(path) + 10];
	  if (!longpath)
	     return true;
      UStrCpy(longpath,L"\\\\?\\");
      UStrCpy(longpath + UStrLen(longpath),path);
      
   }
   else
   {
      longpath = path;
   }
   handle = CreateFileW(longpath,
                     READ_CONTROL | ACCESS_SYSTEM_SECURITY | WRITE_OWNER |WRITE_DAC ,
                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                     NULL, 
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_BACKUP_SEMANTICS, 
                     0);
   if ( handle == INVALID_HANDLE_VALUE )
   {
      rc = GetLastError();
      if ( rc == ERROR_SHARING_VIOLATION )
      {
         err.MsgWrite(ErrW, DCT_MSG_FST_FILE_IN_USE_S,path);
      }
      else
      {
         err.SysMsgWrite(ErrE, rc, DCT_MSG_FST_FILE_OPEN_FAILED_SD,longpath,rc);
      }
      error = true;
   }
   else 
   {
      sd = (SECURITY_DESCRIPTOR *)malloc(SD_DEFAULT_SIZE);
	  if (!sd)
	  {
         if ( longpath != path )
            delete [] longpath;
	     return true;
	  }
      req = 0;
      if ( ! GetKernelObjectSecurity(handle, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION
                                                                      | DACL_SECURITY_INFORMATION
                                                                      | SACL_SECURITY_INFORMATION
                                                                       ,
               sd,
               SD_DEFAULT_SIZE,
               &req) )
      {
         if ( req <= SD_DEFAULT_SIZE )
         {
            err.SysMsgWrite(ErrE, GetLastError(), DCT_MSG_FST_GET_FILE_SECURITY_FAILED_SD, 
                            longpath, GetLastError());
             error = true;
         }
         else 
         {
            free(sd);
            sd = (SECURITY_DESCRIPTOR *)malloc(req);
	        if (!sd)
			{
               if ( longpath != path )
                  delete [] longpath;
	           return true;
			}
            if ( ! GetKernelObjectSecurity(handle,OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION
                                                                             | DACL_SECURITY_INFORMATION
                                                                             | SACL_SECURITY_INFORMATION
                                                                             ,
                  sd,
                  req,
                  &req) )   
            {
               err.SysMsgWrite(ErrE, GetLastError(), DCT_MSG_FST_GET_FILE_SECURITY_FAILED_SD,
                            longpath, GetLastError());
               error = true;
            }
         }
      }
   }
   if ( error && sd ) // free the space allocated
   {
      free(sd);
      sd = NULL;
   }
   if ( sd )
   {
      m_sd = new TSD(sd,McsFileSD,TRUE);
	  if (!m_sd)
	     error = true;
   }
   else
   {
      m_sd = NULL;
   }
   if (! error )
   {
      safecopy(pathname,longpath);
   }
   if ( longpath != path )
      delete [] longpath;

   return error;
}

//////////////////////////TShareSD implementation///////////////////////////////////////////////////////////
TShareSD::TShareSD(
      const LPWSTR           path                // in -pathname for this SD           
   )
{
   daceNS    = 0;
   saceNS    = 0;
   daceEx    = 0;
   saceEx    = 0;
   daceU     = 0;
   saceU     = 0;
   daceNT    = 0;
   saceNT    = 0;
   unkown    = false;
   unkgrp    = false;
   shareInfo = NULL;

   if ( path )
   {
      safecopy(pathname,path);
   }
   else
   {
      path[0] = 0;
   }
   handle = INVALID_HANDLE_VALUE;
   ReadSD(path);                           
}
 
bool                                       // ret-error=true
   TShareSD::ReadSD(
      const LPWSTR           path          // in -sharename
   )
{
   DWORD                     rc;
//   void                    * r = NULL;
   SECURITY_DESCRIPTOR     * sd = NULL;
   bool                      error = false;
   DWORD                     lenServerName = 0;

   if ( m_sd )
   {
      delete m_sd;
   }

   owner_changed = 0;
   group_changed = 0;
   dacl_changed = 0;
   sacl_changed = 0;

   serverName = GetMachineName(path);

   if ( serverName )
      lenServerName = UStrLen(serverName) + 1;
   
   safecopy(pathname,path + lenServerName);
      

   rc = NetShareGetInfo(serverName, pathname, 502, (LPBYTE *)&shareInfo);
   if ( rc )
   {
      err.SysMsgWrite(ErrE, rc, DCT_MSG_FST_GET_SHARE_SECURITY_FAILED_SD, 
                      path, rc);
      error = true;
   }
   else
   {
      sd = (SECURITY_DESCRIPTOR *)shareInfo->shi502_security_descriptor;
      if ( sd )
      {
         m_sd = new TSD(sd,McsShareSD,FALSE);
	     if (!m_sd)
	        error = true;
      }
      else
      {
         m_sd = NULL;
      }
   }
  
   return error;
}
   


bool                                       // ret-error=true
   TShareSD::WriteSD()
{
   bool                      error   = false;
   DWORD                     rc      = 0;
   DWORD                     parmErr = 0;
   SECURITY_DESCRIPTOR     * pSD = NULL;   

   // Build an absolute SD
   if ( m_sd )
   {
      pSD = m_sd->MakeAbsSD();
	  if (!pSD)
	     return false;
      shareInfo->shi502_security_descriptor = pSD;
   
      rc = NetShareSetInfo(serverName,pathname,502,(BYTE *)shareInfo,&parmErr);
      if ( rc )
      {
         err.SysMsgWrite(ErrE,rc,DCT_MSG_FST_SHARE_WRITESD_FAILED_SD,pathname,rc);
      }
      free(pSD);
   }
   else
   {
      MCSASSERT(FALSE); // SD does not exist
   }
   return error;
}


TRegSD::TRegSD(
      const LPWSTR           path,               // in -pathname for this SD           
      HKEY                   hKey                // in -handle for the registry key
   )
{
   daceNS    = 0;
   saceNS    = 0;
   daceEx    = 0;
   saceEx    = 0;
   daceU     = 0;
   saceU     = 0;
   daceNT    = 0;
   saceNT    = 0;
   unkown    = false;
   unkgrp    = false;

   if ( path )
   {
      safecopy(pathname,path);
   }
   else
   {
      path[0] = 0;
   }
   m_hKey = hKey;
   ReadSD(m_hKey);                           
}

bool 
   TRegSD::ReadSD(HKEY       hKey)
{
   DWORD                     rc = 0;
   DWORD                     lenBuffer = SD_DEFAULT_SIZE;
   SECURITY_DESCRIPTOR     * sd = NULL;

   m_hKey = hKey;

   sd = (SECURITY_DESCRIPTOR *)malloc(SD_DEFAULT_SIZE);
   if (!sd)
      return false;

   rc = RegGetKeySecurity(hKey,OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION
                                                          | DACL_SECURITY_INFORMATION
                                                          | SACL_SECURITY_INFORMATION,
                                                          sd,&lenBuffer);

   if ( rc == ERROR_INSUFFICIENT_BUFFER )
   {
      free(sd);
      
      sd = (SECURITY_DESCRIPTOR *)malloc(lenBuffer);
      if (!sd)
         return false;
      rc = RegGetKeySecurity(hKey,OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION
                                                             | DACL_SECURITY_INFORMATION
                                                             | SACL_SECURITY_INFORMATION,
                                                               sd,&lenBuffer);
   }                                       

   if ( rc )
   {
      free(sd);
   }
   else
   {
      m_sd = new TSD(sd,McsRegistrySD,TRUE);
	  if (!m_sd)
	     rc = ERROR_NOT_ENOUGH_MEMORY;
   }
   return ( rc == 0 );
}

bool
   TRegSD::WriteSD()
{
   DWORD                     rc = 0;
   SECURITY_DESCRIPTOR     * sd = NULL;
   
   MCSVERIFY( m_sd && m_sd->IsValid() );
   
   SECURITY_INFORMATION si;
   
   si = 0;
   if ( m_sd->IsOwnerChanged() )
      si |= OWNER_SECURITY_INFORMATION;
   if ( m_sd->IsGroupChanged() )
      si |= GROUP_SECURITY_INFORMATION;
   if ( m_sd->IsDACLChanged() )
      si |=  DACL_SECURITY_INFORMATION;
   if ( m_sd->IsSACLChanged() )
      si |= SACL_SECURITY_INFORMATION;

   sd = m_sd->MakeAbsSD();     
   if (!sd)
	  return false;
   
   rc = RegSetKeySecurity(m_hKey,si,sd);

   if ( rc )
   {
      err.SysMsgWrite(ErrE,rc,DCT_MSG_REG_SD_WRITE_FAILED_SD,name,rc);
   }
   m_sd->FreeAbsSD(sd);
   
   return ( rc == 0 );
}



//////////////////////////TPrintSD implementation///////////////////////////////////////////////////////////
TPrintSD::TPrintSD(
      const LPWSTR           path                // in -pathname for this SD           
   )
{
   daceNS    = 0;
   saceNS    = 0;
   daceEx    = 0;
   saceEx    = 0;
   daceU     = 0;
   saceU     = 0;
   daceNT    = 0;
   saceNT    = 0;
   unkown    = false;
   unkgrp    = false;
   buffer    = NULL;
   
   if ( path )
   {
      safecopy(pathname,path);
   }
   else
   {
      path[0] = 0;
   }
   handle = INVALID_HANDLE_VALUE;
   ReadSD(path);                           
}
 
bool                                       // ret-error=true
   TPrintSD::ReadSD(
      const LPWSTR           path          // in -sharename
   )
{
   DWORD                     rc = 0;
   SECURITY_DESCRIPTOR     * sd = NULL;
   
   if ( m_sd )
   {
      delete m_sd;
   }

   owner_changed = 0;
   group_changed = 0;
   dacl_changed = 0;
   sacl_changed = 0;

   PRINTER_DEFAULTS         defaults;
   DWORD                    needed = 0;
   PRINTER_INFO_3         * pInfo;

   defaults.DesiredAccess = READ_CONTROL | PRINTER_ACCESS_ADMINISTER | WRITE_OWNER | WRITE_DAC | ACCESS_SYSTEM_SECURITY;
   defaults.pDatatype = NULL;
   defaults.pDevMode = NULL;

   buffer = new BYTE[PRINT_BUFFER_SIZE];
   if (!buffer)
      return false;

   // Get the security descriptor for the printer
   if ( ! OpenPrinter(path,&hPrinter,&defaults) )
   {
      rc = GetLastError();
      err.SysMsgWrite(ErrE,rc,DCT_MSG_OPEN_PRINTER_FAILED_SD,path,rc);
   }
   else
   {
      if ( ! GetPrinter(hPrinter,3,buffer,PRINT_BUFFER_SIZE,&needed) )
      {
         rc = GetLastError();
         if ( rc == ERROR_INSUFFICIENT_BUFFER )
         {
            delete [] buffer;
            buffer = new BYTE[needed];
            if (!buffer)
               rc = ERROR_NOT_ENOUGH_MEMORY;
			else if (! GetPrinter(hPrinter,3,buffer, needed, &needed ) )
            {
               rc = GetLastError();
            }
         }
      }
      if ( rc )
      {
         err.SysMsgWrite(ErrE,rc,DCT_MSG_GET_PRINTER_FAILED_SD,path,rc);
      }
      else
      {
         pInfo = (PRINTER_INFO_3*)buffer;         
         
         sd = (SECURITY_DESCRIPTOR *)pInfo->pSecurityDescriptor;
            
         if ( sd )
         {
            m_sd = new TSD(sd,McsPrinterSD,FALSE);
	        if (!m_sd)
	           rc = ERROR_NOT_ENOUGH_MEMORY;
         }
         else
         {
            m_sd = NULL;
         }
            
      }
   }
   return (rc == 0);
}
   


bool                                       // ret-error=true
   TPrintSD::WriteSD()
{
//   bool                      error   = false;
   DWORD                     rc      = 0;
   SECURITY_DESCRIPTOR     * pSD = NULL;   
   PRINTER_INFO_3            pInfo;

   // Build an absolute SD
   MCSVERIFY(hPrinter != INVALID_HANDLE_VALUE);
   if ( m_sd )
   {
      pSD = m_sd->MakeAbsSD();
      if (!pSD)
	     return false;
      pInfo.pSecurityDescriptor = pSD;
   
      SetLastError(0);
      // Clear the primary group from the security descriptor, since in NT 4, setting a security descriptor
      // with a non-NULL primary group sometimes doesn't work
      SetSecurityDescriptorGroup(pSD,NULL,FALSE);
      
      if (! SetPrinter(hPrinter,3,(LPBYTE)&pInfo,0) )
      {
         rc = GetLastError();
      }
      if ( rc )
      {
         err.SysMsgWrite(ErrE,rc,DCT_MSG_PRINTER_WRITESD_FAILED_SD,pathname,rc);
      }
      free(pSD);
   }
   else
   {
      MCSASSERT(FALSE); // SD does not exist
   }
   return (rc == 0);
}


#ifdef SDRESOLVE   
/////////////////////////////////////////////////Utility routines to print security descriptors for debug logging
//#pragma title("PrintSD- Formats/prints security info")
// Author - Tom Bernhardt
// Created- 09/11/93

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <malloc.h>
#include <winbase.h>
#include <lm.h>



#include "common.hpp"
#include "err.hpp"
#include "Ustring.hpp"
 
#define SDBUFFSIZE (sizeof (SECURITY_DESCRIPTOR) + 10000)
static const char            sidType[][16]= {"--0--"  , "User"          ,
                                             "Group"  , "Domain"        ,
                                             "Alias"  , "WellKnownGroup",
                                             "Deleted", "Invalid"       ,
                                             "Unknown"};


class SidTree
{
public:   
   SidTree                 * left;
   SidTree                 * right;
   SID_NAME_USE              sidUse;
   USHORT                    lenSid;
   char                      buffer[1];   // contains sid, account name and domain

                        SidTree() {};
   SidTree *                              // ret-found/created node
      Find(
         SidTree             ** sidTree  ,// i/o-head of extension tree
         PSID const             pSid      // in -file extension
      );
};

static char * 
   AclType(
      BOOL                   isPresent    ,// in -1 if present
      BOOL                   isDefault     // in -1 if default ACL
   )
{
   if ( !isPresent )
      return "none";
   if ( isDefault )
      return "default";
   return "present";
}

                           
//#pragma page()
// For each "on" bit in the bitmap, appends the corresponding char in
// mapStr to retStr, thus forming a recognizable form of the bit string.
static
int _stdcall                              // ret-legngth of string written
   BitMapStr(
      DWORD                  bitmap      ,// in -bits to map
      char const           * mapStr      ,// in -map character array string
      char                 * retStr       // out-return selected map char string
   )
{
   char const              * m;
   char                    * r = retStr;

   for ( m = mapStr;  *m;  m++, bitmap >>= 1 )
      if ( bitmap & 1 )   // if current permission on
         *r++ = *m;       //    set output string to corresponding char
   *r = '\0';
   
   return (int)(r - retStr);
}

//#pragma page()
// converts an ACE access mask to a semi-undertandable string
static
char * _stdcall
   PermStr(
      DWORD                  access      ,// in -access mask
      char                 * retStr       // out-return permissions string
   )
{
// static char const         fileSpecific[] = "R W WaErEwX . ArAw";
// static char const         dirSpecific[]  = "L C M ErEwT D ArAw";
   static char const         specific[] = "RWbeEXDaA.......",
                             standard[] = "DpPOs...",
                             generic[] =  "SM..AXWR";
   char                    * o = retStr;

   if ( (access & FILE_ALL_ACCESS) == FILE_ALL_ACCESS )
      *o++ = '*';
   else
      o += BitMapStr(access, specific, o);

   access >>= 16;
   *o++ = '-';
   if ( (access & (STANDARD_RIGHTS_ALL >> 16)) == (STANDARD_RIGHTS_ALL >> 16) )
      *o++ = '*';
   else
      o += BitMapStr(access, standard, o);

   access >>= 8;
   if ( access )
   {
      *o++ = '-';
      o += BitMapStr(access, generic, o);
   }
   *o = '\0';                // null terminate string
      
   return retStr;
}


//#pragma page()
// Binary tree insertion/searching of Sids that obviates the constant
// use of LookupAccount and speeds execution by 100x!!!!!
SidTree *                                 // ret-found/created node
   SidTree::Find(
      SidTree             ** sidTree     ,// i/o-head of extension tree
      PSID const             pSid         // in -file extension
   )
{
   SidTree                 * curr,
                          ** prevNext = sidTree; // &forward-chain
   int                       cmp;          // compare result
   DWORD                     lenSid;
   WCHAR                     name[60],
                             domain[60];
   DWORD                     lenName,
                             lenDomain,
                             rc;
   SID_NAME_USE              sidUse;
   static int                nUnknown = 0;

   for ( curr = *prevNext;  curr;  curr = *prevNext )
   {
      if ( (cmp = memcmp(pSid, curr->buffer, curr->lenSid)) < 0 )
         prevNext = &curr->left;           // go down left side
      else if ( cmp > 0 )
         prevNext = &curr->right;          // go down right side
      else
         return curr;                      // found it and return address
   }

   // not found in tree -- create it
   lenName = DIM(name);
   lenDomain = DIM(domain);
   if ( !LookupAccountSid(NULL, pSid, name, &lenName,
                          domain, &lenDomain, &sidUse) )
   {
      rc = GetLastError();
      if ( rc != ERROR_NONE_MAPPED )
         err.DbgMsgWrite(0, L"LookupAccountSid()=%ld", rc);
      lenName = swprintf(name, L"**Unknown%d**", ++nUnknown);
      UStrCpy(domain, "-unknown-");
      lenDomain = 9;
      sidUse = (_SID_NAME_USE)0;
   }
   
   lenSid = GetLengthSid(pSid);
   *prevNext = (SidTree *)malloc(sizeof **prevNext + lenSid + lenName + lenDomain + 1);
   if (!(*prevNext))
      return NULL;
   memset(*prevNext, '\0', sizeof **prevNext);
   memcpy((*prevNext)->buffer, pSid, lenSid);
   (*prevNext)->lenSid = (USHORT)lenSid;
   (*prevNext)->sidUse = sidUse;
   UStrCpy((*prevNext)->buffer + lenSid, name, lenName + 1);
   UStrCpy((*prevNext)->buffer + lenSid + lenName + 1, domain, lenDomain + 1);
   return *prevNext;
}


//#pragma page()
SidTree               gSidTree;
SidTree             * sidHead = &gSidTree;
SECURITY_DESCRIPTOR * sd = NULL;


// Formats and prints (to stdout) the contents of the argment ACL
static
void _stdcall
   PrintACL(
      const PACL             acl         ,// in -ACL (SACL or DACL)
      WCHAR const           * resource     // in -resource name
   )
{
   ACCESS_ALLOWED_ACE      * ace;
   DWORD                     nAce;
   static char const         typeStr[] = "+-A*";
   SidTree                 * sidTree;
   char                      permStr[33],
                             inherStr[5];
   WCHAR                     txtSid[200];
   char                      sTxtSid[200];
   DWORD                     txtSidLen = DIM(txtSid);
   err.DbgMsgWrite(0,L" T Fl Acc Mask Permissions      Account name     "
          L"Domain         Acct Type");

   for ( nAce = 0;  nAce < acl->AceCount;  nAce++ )
   {
      if ( !GetAce(acl, nAce, (LPVOID *)&ace) )
      {
         err.DbgMsgWrite(0,L"GetAclInformation()=%ld ", GetLastError());
         return;
      }
      sidTree = sidHead->Find(&sidHead, &ace->SidStart);
      BitMapStr(ace->Header.AceFlags, "FDNI", inherStr);
      txtSid[0] = 0;
      txtSidLen = DIM(txtSid);
      GetTextualSid(&ace->SidStart,txtSid,&txtSidLen);
      safecopy(sTxtSid,txtSid);
      err.DbgMsgWrite(0,L" %c%-3S %08x %-16S %-16S %-14S %S",
              typeStr[ace->Header.AceType], 
              inherStr, 
              ace->Mask,
              PermStr(ace->Mask, permStr),
              (*(sidTree->buffer + sidTree->lenSid)) ? (sidTree->buffer + sidTree->lenSid) : sTxtSid, 
              sidTree->buffer + sidTree->lenSid + strlen(sidTree->buffer + sidTree->lenSid) + 1,
              sidType[sidTree->sidUse]);
   }
}


SECURITY_DESCRIPTOR *
GetSD(
      WCHAR                * path
      )
{                                         //added by christy
                                          //this does the same stuff as 
                                          // PermsPrint, but doesn't print
                       
   DWORD                     req;
  
   HANDLE                    hSrc;
   DWORD                     rc = 0;
  
//   void                    * r = NULL;
//   WIN32_STREAM_ID         * s = (WIN32_STREAM_ID *)copyBuffer;
   char static const       * streamName[] = {"Err", "Data", "EA", "Security", "Alternate", "Link", "Err6"}; 
   
   
   
   
   hSrc = CreateFile(path,
                     GENERIC_READ |ACCESS_SYSTEM_SECURITY,
                     FILE_SHARE_READ | FILE_SHARE_WRITE,
                     NULL, 
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN | FILE_FLAG_BACKUP_SEMANTICS, 
                     0);
   
   if ( hSrc == INVALID_HANDLE_VALUE )
   {
      rc = GetLastError();
      if ( rc == ERROR_SHARING_VIOLATION )
         err.DbgMsgWrite(ErrE, L"Source file in use %S", path );
      else
         err.DbgMsgWrite(ErrS,L"OpenR(%S) ", path);
      return NULL;
   }

   if ( ! GetKernelObjectSecurity(hSrc, OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION
                                                                   | DACL_SECURITY_INFORMATION
                                                                   | SACL_SECURITY_INFORMATION
                                                                    ,
            sd,
            SDBUFFSIZE,
            &req) )
   {
      err.DbgMsgWrite(0, L"GetKernelObjectSecurity(%S)=%ld req=%ld ",
                         path, GetLastError(),req);
      return NULL;
   }

   CloseHandle(hSrc);

   return sd;
}

                  
//#pragma page()
// Gets the security descriptors for a resource (path), format the owner
// information, gets the ACL and SACL and prints them.

DWORD 
   PermsPrint(
        WCHAR                 * path,         // in -iterate directory paths
        objectType              objType       // in -type of the object
   )
{
   TFileSD                   fsd(path);
   TShareSD                  ssd(path);
   TPrintSD                  psd(path);
   TRegSD                    rsd(path,NULL);
   SECURITY_DESCRIPTOR const* pSD = NULL;

   switch ( objType )
   {
   case file:
   case directory:
      fsd.ReadSD(path);
      if ( fsd.GetSecurity() )
      {
         pSD = fsd.GetSecurity()->GetSD();
      }
      break;
   case printer:
      psd.ReadSD(path);
      if ( psd.GetSecurity() )
      {
         pSD = psd.GetSecurity()->GetSD();
      }
      break;
   case share:
      ssd.ReadSD(path);
      if ( ssd.GetSecurity() )
      {
         pSD = ssd.GetSecurity()->GetSD();
      }
      break;
   case regkey:
      rsd.ReadSD(path);
      if ( rsd.GetSecurity() )
      {
         pSD = rsd.GetSecurity()->GetSD();
      }
      break;
   default:
      break;
   }
   if ( pSD )
   {
      PrintSD(const_cast<SECURITY_DESCRIPTOR*>(pSD),path);
   }
   else
   {
      err.DbgMsgWrite(0,L"Couldn't load Security descriptor for %ls",path);
   }
   return 0;
}

DWORD PrintSD(SECURITY_DESCRIPTOR * sd,WCHAR const * path)
{
   BOOL                      isPresent,
                             isDefault;
   PACL                      dacl;
   PACL                      sacl;
   PSID                      pSidOwner;
   SidTree                 * sidTree = &gSidTree;

//   DWORD                     rc = 0;
  
   if ( !GetSecurityDescriptorOwner(sd, &pSidOwner, &isDefault) )
   {
      err.DbgMsgWrite(0,L"GetSecurityDescriptorOwner()=%ld ", GetLastError());
      return 1;
   }
   
   err.DbgMsgWrite(0,L"%s",path);
   if ( pSidOwner )
   {
      sidTree = sidHead->Find(&sidHead, pSidOwner);
      if (sidTree)
      {
         err.DbgMsgWrite(0,L"owner=%S\\%S, type=%S, ", 
             //path,
             sidTree->buffer + sidTree->lenSid + strlen(sidTree->buffer + sidTree->lenSid) + 1,
             sidTree->buffer + sidTree->lenSid, 
             sidType[sidTree->sidUse]);
      }
   }
   else
   {
      err.DbgMsgWrite(0,L"owner=NULL");
   }
   if ( !GetSecurityDescriptorDacl(sd, &isPresent, &dacl, &isDefault) )
   {
      err.DbgMsgWrite(0, L"GetSecurityDescriptorDacl()=%ld ", GetLastError());
      return 1;
   }


   err.DbgMsgWrite(0,L" DACL=%S", AclType(isPresent, isDefault) );
   if ( dacl )
      PrintACL(dacl, path);

   if ( !GetSecurityDescriptorSacl(sd, &isPresent, &sacl, &isDefault) )
   {
      err.DbgMsgWrite(0, L"GetSecurityDescriptorSacl()=%ld ", GetLastError());
      return 1;
   }

   if ( isPresent )
   {
      err.DbgMsgWrite(0,L" SACL %S", AclType(isPresent, isDefault) );
      if (!sacl) 
      {  
         err.DbgMsgWrite(0,L"SACL is empty.");
      }
     else PrintACL(sacl, path);
   }
   return 0;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\names.cpp ===
#ifdef USE_STDAFX
#include "stdafx.h"
#else
#include <Windows.h>
#endif

#include <memory>
#include <string.h>
#include <ComDef.h>
#include "Common.hpp"
#include "ErrDct.hpp"


extern TErrorDct              err;


//---------------------------------------------------------------------------
// StripSamName Function
//
// Replaces invalid SAM account name characters with a replacement character.
//---------------------------------------------------------------------------

void StripSamName(WCHAR* pszName)
{
	// invalid punctuation characters in any position
	const WCHAR INVALID_CHARACTERS_ABC[] = L"\"*+,/:;<=>?[\\]|";
	// invalid punctuation characters only in last position
	const WCHAR INVALID_CHARACTERS_C[] = L".";
	// replacement character
	const WCHAR REPLACEMENT_CHARACTER = L'_';

	// if name specified...

	if (pszName)
	{
		size_t cchName = wcslen(pszName);

		// if length of name is valid...

		if ((cchName > 0) && (cchName < MAX_PATH))
		{
			bool bChanged = false;

			// save old name

			WCHAR szOldName[MAX_PATH];
			wcscpy(szOldName, pszName);

			// get character type information

			WORD wTypes[MAX_PATH];
			GetStringTypeEx(LOCALE_SYSTEM_DEFAULT, CT_CTYPE1, pszName, cchName, wTypes);

			// for each character in name...

			for (size_t ich = 0; ich < cchName; ich++)
			{
				bool bReplace = false;

				WORD wType = wTypes[ich];

				// if character is of specified type...

				if ((wType == 0) || (wType & C1_CNTRL))
				{
					// replace un-classified or control type
					bReplace = true;
				}
			//	Note: Windows 2000 & Windows XP allows space characters as first or last character
			//	else if (wType & (C1_BLANK|C1_SPACE))
			//	{
					// blank or space type

					// if first or last character...

			//		if ((ich == 0) || (ich == (cchName - 1)))
			//		{
						// then replace 
			//			bReplace = true;
			//		}
			//	}
				else if (wType & C1_PUNCT)
				{
					// punctuation type

					// if invalid punctuation character in any position...

					if (wcschr(INVALID_CHARACTERS_ABC, pszName[ich]))
					{
						// then replace
						bReplace = true;
					}
					else
					{
						// otherwise if invalid punctuation character in last position...

						if ((ich == (cchName - 1)) && wcschr(INVALID_CHARACTERS_C, pszName[ich]))
						{
							// then replace
							bReplace = true;
						}
					}
				}
				else
				{
					// alphabetic, digit and variations are valid types
				}

				// if replacement indicated...

				if (bReplace)
				{
					// then replace invalid character with replacement
					// character and set name changed to true
					pszName[ich] = REPLACEMENT_CHARACTER;
					bChanged = true;
				}
			}

			// if name has changed...

			if (bChanged)
			{
				// log name change
				err.MsgWrite(ErrW, DCT_MSG_SAMNAME_CHANGED_SS, szOldName, pszName);
			}
		}
	}
}


//---------------------------------------------------------------------------
// GetDomainDNSFromPath Function
//
// Generates a domain DNS name from a distinguished name or ADsPath.
//---------------------------------------------------------------------------

_bstr_t GetDomainDNSFromPath(_bstr_t strPath)
{
	static wchar_t s_szDnDelimiter[] = L",";
	static wchar_t s_szDcPrefix[] = L"DC=";
	static wchar_t s_szDnsDelimiter[] = L".";

	#define DC_PREFIX_LENGTH (sizeof(s_szDcPrefix) / sizeof(s_szDcPrefix[0]) - 1)

	std::auto_ptr<wchar_t> apDNS;

	// if non empty path...

	if (strPath.length() > 0)
	{
		// allocate buffer for DNS name
		apDNS = std::auto_ptr<wchar_t>(new wchar_t[strPath.length() + 1]);

		// allocate temporary buffer for path
		std::auto_ptr<wchar_t> apPath(new wchar_t[strPath.length() + 1]);

		// if allocations succeeded...

		if ((apDNS.get() != 0) && (apPath.get() != 0))
		{
			// initialize DNS name to empty
			*apDNS = L'\0';

			// copy path to temporary buffer
			wcscpy(apPath.get(), strPath);

			// then for each component in path...
			//
			// Note: if any path components contain the path delimiter character they will be skipped as
			//       they wont begin with domain component prefix. The domain component prefix contains
			//       a special character that must be escaped if part of path component name.

			for (wchar_t* pszDC = wcstok(apPath.get(), s_szDnDelimiter); pszDC; pszDC = wcstok(0, s_szDnDelimiter))
			{
				// if domain component...

				if (_wcsnicmp(pszDC, s_szDcPrefix, DC_PREFIX_LENGTH) == 0)
				{
					//
					// then concatenate to DNS name
					//

					// if not first component...

					if (*apDNS)
					{
						// then append delimiter
						wcscat(apDNS.get(), s_szDnsDelimiter);
					}

					// append domain component name without type prefix
					wcscat(apDNS.get(), pszDC + DC_PREFIX_LENGTH);
				}
			}
		}
	}

	return apDNS.get();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\mcsdebug.cpp ===
//---------------------------------------------------------------------------
// MCSDebug.cpp
//
// The classes declared in MCSDebug.h are defined in
// this file.
//
// (c) Copyright 1995-1998, Mission Critical Software, Inc., All Rights Reserved
//
// Proprietary and confidential to Mission Critical Software, Inc.
//---------------------------------------------------------------------------
#ifdef __cplusplus		/* C++ */
#ifndef WIN16_VERSION	/* Not WIN16_VERSION */

#ifdef USE_STDAFX
#   include "stdafx.h"
#   include "rpc.h"
#else
#   include <windows.h>
#   include <stdlib.h>
#endif

#include <time.h>
//#include <strstrea.h>
#include <strstrea.h>
#include "UString.hpp"
#include "McsDebug.h"

// -----------------
// McsDebugException
// -----------------
McsDebugException::McsDebugException 
      (const McsDebugException &t) 
: m_message (0), m_fileName (0), m_lineNum (t.m_lineNum) {
	if (t.m_message) { 
		m_message = new char [UStrLen(t.m_message)+1];
      if (m_message) { UStrCpy (m_message, t.m_message); }
    }
    if (t.m_fileName) {
		m_fileName = new char [UStrLen(t.m_fileName)+1];
      if (m_fileName) { UStrCpy (m_fileName, t.m_fileName); }
    }
}

McsDebugException::McsDebugException 
                           (const char *messageIn,
						          const char *fileNameIn,
							       int        lineNumIn) 
: m_lineNum (lineNumIn) {
   if (messageIn) { 
      m_message = new char [UStrLen (messageIn)+1];
      if (m_message) { UStrCpy (m_message, messageIn); }
   }
   if (fileNameIn) {
      m_fileName = new char [UStrLen(fileNameIn)+1];
      if (m_fileName) { UStrCpy (m_fileName, fileNameIn); }
   }
}

McsDebugException& McsDebugException::operator= 
         (const McsDebugException &t) {
   if (this != &t) {
      if (t.m_message) { 
         m_message = new char [UStrLen(t.m_message)+1];
         if (m_message) { UStrCpy (m_message, t.m_message); }
      }
      if (t.m_fileName) {
         m_fileName = new char [UStrLen(t.m_fileName)+1];
         if (m_fileName) { UStrCpy (m_fileName, t.m_fileName); }
      }
      m_lineNum = t.m_lineNum;
   }
   return *this;
}

// ------------
// McsVerifyLog
// ------------
static McsVerifyLog *pVerifyLog;
static LONG         verifyInitFlag;

McsVerifyLog* McsVerifyLog::getLog (void) {
   // If pointer not initialized use the cheap
   // locking mechanism and set pointer to the
   // the static verifyLog object.  This required
   // to gurantee the correct initialization of
   // the verify log class independent of any
   // static initialization order dependency.
   if (!pVerifyLog) {
      while (::InterlockedExchange 
               (&verifyInitFlag, 1)) {
         ::Sleep (10);
      }
      if (!pVerifyLog) {
         static McsVerifyLog verifyLog;
         pVerifyLog = &verifyLog;
      }
      ::InterlockedExchange (&verifyInitFlag, 0);
   }
   return pVerifyLog;
}

void McsVerifyLog::changeLog (ostream *outStreamIn) {
   m_logSec.enter();
   m_log.changeLog (outStreamIn);
   delete m_outLog;
   m_outLog = 0;
   m_logSec.leave();
}

void McsVerifyLog::log (const char *messageIn,
                        const char *fileNameIn,
                        int        lineNumIn) {
   m_logSec.enter();
   // If the log file has not been set, set it
   // to the module name log file.
   if (!m_log.isLogSet()) {
      m_outLog = new fstream (getLogFileName(), 
         ios::app);
      m_log.changeLog (m_outLog);
   }
   // Format and write the message.
   formatMsg (messageIn, fileNameIn, lineNumIn);
   m_log.write (m_msgBuf);
   m_logSec.leave();
}

const char* McsVerifyLog::getLogFileName (void) {
   const char  *MCS_LOG_ENV  = "MCS_LOG";
   const char  *DIR_SEP      = "\\";
   const char  *EXT          = ".err";
   const char  *DEFAULT_NAME = "MCSDEBUG";
   static char logFileName[MAX_PATH];

   // Get MCS_LOG_ENV, or temp directory path, 
   // NULL means current directory.
   logFileName[0] = 0;
   char *mcs_log_path = getenv (MCS_LOG_ENV);
   bool isLogPath = false;
   if (mcs_log_path) {
      DWORD attrib = ::GetFileAttributesA (mcs_log_path);
      if ((attrib != 0xFFFFFFFF)
          && (attrib & FILE_ATTRIBUTE_DIRECTORY)) {
         UStrCpy (logFileName, mcs_log_path);
         isLogPath = true;
      }
   }
   if (!isLogPath) { 
      ::GetTempPathA (MAX_PATH, logFileName);
   }

   // Get file name from the module name.  If error
   // generate fixed filename. 
   char fullFilePath [MAX_PATH];
   char fileName[MAX_PATH];
   if (::GetModuleFileNameA (NULL, fullFilePath, 
                  MAX_PATH)) {
      // Get file name out of the path
      _splitpath (fullFilePath, NULL, NULL, fileName, 
                        NULL);

      // Generate full path name with extension.
      int len = UStrLen (logFileName);
      if (len) {
         UStrCpy (logFileName + len, DIR_SEP);
         UStrCpy (logFileName + UStrLen (logFileName), 
                     fileName);
      } else {
         UStrCpy (logFileName, fileName);
      }
   } else {
      UStrCpy (logFileName, DEFAULT_NAME);
   }
   strcat (logFileName + UStrLen (logFileName), EXT);

   return logFileName;
}

void McsVerifyLog::formatMsg (const char *messageIn,
                              const char *fileNameIn,
                              int         lineNumIn) {
   const char  *TIME        = "TIME : ";
   const char  *MSG         = "MSG  : ";
   const char  *FILE        = "FILE : ";
   const char  *LINE        = "LINE : ";
   const char  *SPACER      = ", ";

   // Create stream buf object.
   strstream msgBufStream (m_msgBuf, MSG_BUF_LEN, ios::out);

   // Write time stamp.
   time_t cur;
   time (&cur);
   struct tm *curTm = localtime (&cur);
   if (curTm) {
      char *tstr = asctime (curTm);
      if (tstr) {
         msgBufStream << TIME << tstr << SPACER;
      }
   }

   // Write message.
   if (messageIn) {
      msgBufStream << MSG << messageIn << SPACER;
   }

   // Write file name.
   if (fileNameIn) {
      msgBufStream << FILE << fileNameIn << SPACER;
   }

   // Write line number.
   msgBufStream << LINE << lineNumIn << endl;
}

// ----------
// McsTestLog
// ----------
static McsTestLog *pTestLog;
static LONG       testInitFlag;

McsTestLog* McsTestLog::getLog (void) {
   // If pointer not initialized use the cheap
   // locking mechanism and set pointer to the
   // the static verifyLog object.  This required
   // to gurantee the correct initialization of
   // the verify log class independent of any
   // static initialization order dependency.
   if (!pTestLog) {
      while (::InterlockedExchange 
               (&testInitFlag, 1)) {
         ::Sleep (10);
      }
      if (!pTestLog) {
         static McsTestLog testLog;
         pTestLog = &testLog;
      }
      ::InterlockedExchange (&testInitFlag, 0);
   }
   return pTestLog;
}

bool McsTestLog::isTestMode (void) {
   const char *TEST_ENV = "MCS_TEST";
//   const char *PRE_FIX  = "MCS";

   // Check if tested.
   if (!m_isTested) {
      // If not tested lock, test again, and
      // initialize test mode flag.
      m_testSec.enter();
      if (!m_isTested) {
         m_isTested    = true;
         m_isTestMode_ = getenv (TEST_ENV) != NULL;
      }
      m_testSec.leave();
   }

   return m_isTestMode_;
}

#endif 	/* Not WIN16_VERSION */
#endif  /* C++ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\pwrpcutl.cpp ===
/*---------------------------------------------------------------------------
  File: PwdRpcUtil.cpp

  Comments: Functions to establish binding to Password Migration Lsa 
  Notifications packages.  These functions are used by the password extension 
  to bind to the password migration Lsa notification package on remote source 
  domain DCs.
    This files was copied from AgRpcUtil.cpp, which was created by Christy Boles
  of NetIQ Corporation.

  REVISION LOG ENTRY
  Revision By: Paul Thompson
  Revised on 09/04/00

 ---------------------------------------------------------------------------
*/
//#include "StdAfx.h"
#include <windows.h>
#include <rpc.h>
#include <rpcdce.h>


// These global variables can be changed if required
#define gsPwdProtoSeq TEXT("ncacn_np")
#define gsPwdEndPoint TEXT("\\pipe\\PwdMigRpc")

// Destroy RPC binding for connection with an Lsa notification package
DWORD                                      // ret-OS return code
   PwdBindDestroy(
      handle_t             * phBinding    ,// i/o-binding handle
      TCHAR               ** psBinding     // i/o-binding string
   )
{
   if ( *phBinding )
   {
      RpcBindingFree( phBinding );
      *phBinding = NULL;
   }

   if ( *psBinding )
   {
      RpcStringFree( psBinding );
      *psBinding = NULL;
   }

   return 0;
}




// Create RPC binding for connection with an Lsa notification package
DWORD                                      // ret-OS return code
   PwdBindCreate(
      TCHAR          const * sComputer    ,// in -computer name
      handle_t             * phBinding    ,// out-binding handle
      TCHAR               ** psBinding    ,// out-binding string
      BOOL                   bAuthn        // in -flag whether to use authenticated RPC
   )
{
   DWORD                     rcOs;         // OS return code

   do // once or until break
   {
      PwdBindDestroy( phBinding, psBinding );
      rcOs = RpcStringBindingCompose(
            NULL,
            (TCHAR *) gsPwdProtoSeq,
            (TCHAR *) sComputer,
            (TCHAR *) gsPwdEndPoint,
            NULL,
            psBinding );
      if ( rcOs ) break;
      rcOs = RpcBindingFromStringBinding( *psBinding, phBinding );
      if ( rcOs || !bAuthn ) break;
      rcOs = RpcBindingSetAuthInfo(
            *phBinding,
            0,
            RPC_C_AUTHN_LEVEL_PKT_PRIVACY,
            RPC_C_AUTHN_WINNT,
            0,
            0 );
   }  while ( FALSE );

   if ( rcOs )
   {
      PwdBindDestroy( phBinding, psBinding );
   }

   return rcOs;
}



/*/////////////////////////////////////////////////////////////////////////////
// midl allocate memory
///////////////////////////////////////////////////////////////////////////////

void __RPC_FAR * __RPC_USER
   midl_user_allocate(
      size_t                 len )
{
   return new char[len];
}

///////////////////////////////////////////////////////////////////////////////
// midl free memory
///////////////////////////////////////////////////////////////////////////////

void __RPC_USER
   midl_user_free(
      void __RPC_FAR       * ptr )
{
   delete [] ptr;
   return;
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\admin\admt\common\commonlib\pwgen.cpp ===
//#pragma title( "PwGen.cpp - PasswordGenerate implementation" )
/*
Copyright (c) 1995-1998, Mission Critical Software, Inc. All rights reserved.
===============================================================================
Module      -  PwGen.cpp
System      -  EnterpriseAdministrator
Author      -  Steven Bailey, Marcus Erickson
Created     -  1997-05-30
Description -  PasswordGenerate implementation
Updates     -
===============================================================================
*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <WinCrypt.h>

#include "Common.hpp"
#include "Err.hpp"
#include "UString.hpp"
#include "pwgen.hpp"

int   iRand(int iMin, int iMax);
void __stdcall GenerateRandom(DWORD dwCount, BYTE* pbRandomType, BYTE* pbRandomChar);

/////////////////////////////////////////////////////////////////////////////////////////////////////////
// Generate a password from the rules provided.
// Returns ERROR_SUCCESS if successful, else ERROR_INVALID_PARAMETER.
// If successful, the new password is returned in the supplied buffer.
// The buffer must be long enough to hold the minimum length password
//   that is required by the rules, plus a terminating NULL.
DWORD __stdcall                            // ret-EA/OS return code
   EaPasswordGenerate(
      DWORD                  dwMinUC,              // in -minimum upper case chars
      DWORD                  dwMinLC,              // in -minimum lower case chars
      DWORD                  dwMinDigits,          // in -minimum numeric digits
      DWORD                  dwMinSpecial,         // in -minimum special chars
      DWORD                  dwMaxConsecutiveAlpha,// in -maximum consecutive alpha chars
      DWORD                  dwMinLength,          // in -minimum length
      WCHAR                * newPassword,          // out-returned password
      DWORD                  dwBufferLength        // in -returned area buffer length
   )
{
   DWORD dwMaxLength = PWGEN_MAX_LENGTH;
   DWORD dwNewLength;      // actual length of new password
   DWORD dwUC = dwMinUC;   // actual numbers of these characters
   DWORD dwLC = dwMinLC;
   DWORD dwDigits = dwMinDigits;
   DWORD dwSpecial = dwMinSpecial;
   DWORD dwActualLength = dwUC + dwLC + dwDigits + dwSpecial;  // total length specified by the minima
   TCHAR pszNewPassword[PWGEN_MAX_LENGTH+1];                   // out-returned password
   BYTE  bRandomType[PWGEN_MAX_LENGTH];                        // cryptographically generated random bytes for type
   BYTE  bRandomChar[PWGEN_MAX_LENGTH];                        // cryptographically generated random bytes for character
   const TCHAR *szSourceString[4] = {                          // the lists of characters by type
      { TEXT("ABDEFGHJKLMNQRTY") },
      { TEXT("abcdefghkmnpqrstuvwxyz") },
      { TEXT("23456789") },
      { TEXT("~!@#$%^+=") }
      };
   DWORD dwToPlace[4];  // number of characters of a type to place
   int   iType[4];      // type of each character class
   int   iTypes;        // total number of types
   enum {               // types of chars
      eUC = 0,
      eLC,
      eDigit,
      eSpecial
   };

   // Sanity checking

   // Does the minimum passed to us exceed the maximum?
   if (dwMinLength > dwMaxLength)
      return ERROR_INVALID_PARAMETER;

   // Adjust the minimum length
   dwMinLength = max(dwMinLength, dwMinUC + dwMinLC + dwMinDigits + dwMinSpecial);
   dwMinLength = max(dwMinLength, PWGEN_MIN_LENGTH);

   // Do the minimum requirements make the password too long?
   if ((dwMinUC + dwMinLC + dwMinDigits + dwMinSpecial) > dwMaxLength)
      return ERROR_INVALID_PARAMETER;

   // Adjust maximum length to size of buffer.
   dwMaxLength = min(dwMaxLength, dwBufferLength - 1);

   // Do the min LC and UC characters make it impossible to satisfy the maximum consecutive alpha characters?
   if (dwMaxConsecutiveAlpha) {
      if (dwMaxLength - dwMaxLength / (dwMaxConsecutiveAlpha + 1) < (dwMinUC + dwMinLC))
         return ERROR_INVALID_PARAMETER;
   }

   // Adjust the minimum length to accomodate the rules about max consecutive alphas.
   if (dwMaxConsecutiveAlpha) {
      DWORD dwTotalAlpha = dwUC + dwLC;
      if (dwTotalAlpha) {
         DWORD dwMinGroups = dwTotalAlpha / dwMaxConsecutiveAlpha;   // we need at least this minus one separators
         if (dwTotalAlpha % dwMaxConsecutiveAlpha)
            ++dwMinGroups;

         dwMinLength = max(dwMinLength, dwTotalAlpha + dwMinGroups - 1);
      }
   }

   // Check confirmed min length against maximum length.
   if (dwMinLength > dwMaxLength)
      return ERROR_INVALID_PARAMETER;

   // Seed the random-number generator with current time so that
   // the numbers will be different every time we run.
#ifndef _DEBUG
   // Note for debugging: If this is run in a tight loop, the tick count
   // won't be incrementing between calls, so the same password will generate
   // repeatedly. That doesn't help you test anything.
   srand( (int)GetTickCount() );
#endif

   // Determine the actual length of new password.
   dwNewLength = dwMinLength;

   // Adjust max consecutive alpha
   if (dwMaxConsecutiveAlpha == 0)
      dwMaxConsecutiveAlpha = dwNewLength;

   // Determine the actual numbers of each type of character.
   if (dwActualLength < dwNewLength) {
      // Try to pad with alphabetic characters.
      // Determine the maximum number of alpha characters that could be added.
      int   iAddAlpha = (int)(dwNewLength - dwNewLength / (dwMaxConsecutiveAlpha + 1) - (dwUC + dwLC));

      // It cannot exceed the number of characters we need.
      if ((DWORD)iAddAlpha > (dwNewLength - dwActualLength))
         iAddAlpha = (int)(dwNewLength - dwActualLength);

      dwLC += (DWORD)iAddAlpha;
      dwActualLength += (DWORD)iAddAlpha;
   }

   // Make certain there are enough groups.
   if (dwActualLength < dwNewLength)
      // The padding is separators.
      dwDigits += dwNewLength - dwActualLength;

   // Prepare to generate the characters.
   dwToPlace[0] = dwUC;
   dwToPlace[1] = dwLC;
   dwToPlace[2] = dwDigits;
   dwToPlace[3] = dwSpecial;
   iType[0] = eUC;
   iType[1] = eLC;
   iType[2] = eDigit;
   iType[3] = eSpecial;
   iTypes   = 4;
   for (int iPos = 0; iPos < iTypes; ) {
      if (!dwToPlace[iPos]) {
         for (int iNextPos = iPos + 1; iNextPos < iTypes; ++iNextPos) {
            dwToPlace[iNextPos - 1] = dwToPlace[iNextPos];
            iType[iNextPos - 1] = iType[iNextPos];
         }
         --iTypes;
      }
      else
         ++iPos;
   }
   // Result: dwToPlace[0..iTypes - 1] contain all non-zero values;
   //         iType[0..iTypes - 1] contain the type of character they represent.

   // generate cryptographically random bytes
   // for choosing both the character type and character
   GenerateRandom(dwNewLength, bRandomType, bRandomChar);

   // Generate a string.
   DWORD dwConsecAlpha = 0;
   int   iRemainingAlpha = (int)(dwUC + dwLC);
   int   iTypeList[PWGEN_MAX_LENGTH];     // A distributed list of types.
   for (int iNewChar = 0; (DWORD)iNewChar < dwNewLength; ++iNewChar) {
      // Determine whether the next char must be alpha or must not be alpha.
      BOOL  bMustBeAlpha = FALSE;
      BOOL  bMustNotBeAlpha = dwConsecAlpha == dwMaxConsecutiveAlpha;

      // If it can be alpha, determine whether it HAS to be alpha.
      if (!bMustNotBeAlpha) {
         // If, among the remaining chars after this one, it would be impossible to
         // fit the remaining alpha chars due to constraints of dwMaxConsecutiveAlpha,
         // then this character must be alpha.

         // Determine the minimum number of groups if we put remaining alpha chars
         // into groups that are the maximum width.
         int   iMinGroups = iRemainingAlpha / (int)dwMaxConsecutiveAlpha;
         if (iRemainingAlpha % (int)dwMaxConsecutiveAlpha)
            ++iMinGroups;

         // Determine the minimum number of non-alpha characters we'll need.
         int   iMinNonAlpha = iMinGroups - 1;

         // Determine the characters remaining.
         int   iRemaining = (int)dwNewLength - iNewChar;

         // Is there room for a non-alpha char here?
         if (iRemaining <= (iRemainingAlpha + iMinNonAlpha))
            // no.
            bMustBeAlpha = TRUE;
      }

      // Determine the type range.
      int   iMinType = 0;
      int   iMaxType = iTypes - 1;

      // If next char must be alpha, then alpha chars remain.
      // Type position 0 contains either UC or LC.
      // Type position 1 contains LC, non-alpha, or nothing.
      if (bMustBeAlpha) {
         if ((iType[1] == eLC) && (iTypes > 1))
            iMaxType = 1;
         else
            iMaxType = 0;
      }
      // If next char may not be alpha, there may be no alpha left to generate.
      // If so, type position 0 is non-alpha.
      // O.w., type positions 0 and 1 may both be alpha.
      else i